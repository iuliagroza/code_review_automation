code&comment2code: <code> private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) { return resourceTypes.getRoots().stream() .map(ResourceType::getQualifier) <START> .filter(q -> !DEPRECATED_QUALIFIERS.contains(q)) <END> .collect(Collectors.toCollection(TreeSet::new)); } </code><technical_language> I think LIBRARY are no more used </technical_language>
code&comment2code: <code> public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) { this.rootWrapper = workUnit.getRootWrapper(); this.drillbitContext = drillbitContext; <START> lineSeparator = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction("line.separator")); <END> } </code><technical_language> Consider using System.lineSeparator() instead. </technical_language>
code&comment2code: <code> private void activateMarkers() { if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) { String value = NLS.bind(Messages.ChangeDetailEditor_EGerriTipValue, <START> fChangeInfo.getUserSelectedRevision().get_number()); <END> UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value); } } </code><technical_language> ChangeDetailEditor_EGerriTipValue has no more arguments, should we just use it directly , no need to set the arguments ? </technical_language>
code&comment2code: <code> public void testCreate() throws StripeException { Map<String, Object> params = new HashMap<String, Object>(); params.put("currency", "usd"); final Order order = Order.create(params); assertNotNull(order); verifyRequest( APIResource.RequestMethod.POST, <START> "/v1/orders", <END> params ); } </code><technical_language> should be called resource </technical_language>
code&comment2code: <code> private FirewallRule findById(List<FirewallRule> collection, String id) { FirewallRule result = null; for (FirewallRule rule : collection) { if (rule.id().equals(id)) { <START> result = rule; <END> } } return result; } </code><technical_language> Just return rule. </technical_language>
code&comment2code: <code> public void addDownload(String download){ <START> if(!downloads.contains(download)) { <END> downloads.add(download); } } </code><technical_language> Should probably use a Set<String> instead of a List<String> so that the intention of the code is clear by first glance. </technical_language>
code&comment2code: <code> public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) { for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) { CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail); newDetail.setObjectId(null); newDetail.setDocumentNumber(getDocumentNumber()); <START> newDetail.setVersionNumber(new Long(0)); <END> getObjectCodeGlobalDetails().add(newDetail); } } </code><technical_language> Should this be 1 or null instead of 0? </technical_language>
code&comment2code: <code> private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) { if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) { return; } model.setSelectedProtocol(ConsoleProtocol.VNC); asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode <START> .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE)))); <END> } </code><technical_language> You can not be sure that the value is present in the local storage (see the storeVncData). Please wrap the ...valueOf(...) by try-catch </technical_language>
code&comment2code: <code> private RuleApplication applyRule() { SymbolAllocator symbolAllocator = new SymbolAllocator(symbols); Memo memo = new Memo(idAllocator, plan); Lookup lookup = Lookup.from(memo::resolve); Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session)); <START> return new RuleApplication( <END> memo, lookup, symbolAllocator.getTypes(), result); } </code><technical_language> These arguments can all go on the same line </technical_language>
code&comment2code: <code> public void testPushDownArray() throws Exception { testParquetFilterPushDown("t.`user`.hobby_ids[0] = 1", 3, 2); testParquetFilterPushDown("t.`user`.hobby_ids[0] = 100", 0, 1); <START> testParquetFilterPushDown("t.`user`.hobby_ids[0] <> 1", 8, 7); <END> testParquetFilterPushDown("t.`user`.hobby_ids[2] > 20", 5, 4); testParquetFilterPushDown("t.`user`.hobby_ids[0] between 10 and 20", 5, 5); testParquetFilterPushDown("t.`user`.hobby_ids[4] = 15", 1, 3); testParquetFilterPushDown("t.`user`.hobby_ids[2] is not null", 11, 6); testParquetFilterPushDown("t.`user`.hobby_ids[3] is null", 11, 7); } </code><technical_language> Why the expected output was changed? </technical_language>
code&comment2code: <code> default Direction getBubbleElevatorDirection() { Block block = this.getBlockState().getBlock(); if (block == Blocks.BUBBLE_COLUMN) { <START> return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP; <END> } else { return block.getBubbleElevatorDirection(this.getBlockState()); } } </code><technical_language> This logic should be in the default implementation. </technical_language>
code&comment2code: <code> public void testSystemPropertiesOverrideConfigurationValues() { final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString(); Configuration config = Configuration.getInstance(); try { Assert.assertEquals("75", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); System.setProperty(keyName, "something else"); Assert.assertEquals("something else", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); } finally { System.clearProperty(keyName); <START> Configuration.clearProperty(keyName); <END> } } </code><technical_language> Why access this method staticly? </technical_language>
code&comment2code: <code> public void onSubscribe(Subscription inner) { <START> SubscriptionHelper.setOnce(this, inner); <END> o.onSubscribe(this); inner.request(Long.MAX_VALUE); } </code><technical_language> You can set it on a plain field, no need for atomics:  java this.inner = inner; o.onSubscribe(this); inner.request(Long.MAX_VALUE); </technical_language>
code&comment2code: <code> public WebElement forElementPresent(By by) { changeImplicitWait(250, TimeUnit.MILLISECONDS); try { return wait.until(ExpectedConditions.presenceOfElementLocated(by)); } catch(TimeoutException e) { PageObjectLogging.log( ELEMENT_PRESENT_MESSAGE, String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()), <START> true <END> ); throw e; } finally { restoreDeaultImplicitWait(); } } </code><technical_language> true -> false ? </technical_language>
code&comment2code: <code> public boolean accept(Issue issue) { <START> if (issueShouldNotBeReported(issue, excludedLinesByRule())) { <END> return false; } return true; } </code><technical_language> could be simplified. </technical_language>
code&comment2code: <code> <START> public HashMap<String, <END> ArrayList<Order>> getBuyOrders() { return buyOrders; } </code><technical_language> this method should be changed to private </technical_language>
code&comment2code: <code> <START> public static <END> Color getSystemForegroundColor(Display display) { ColorRegistry colorRegistry = JFaceResources.getColorRegistry(); Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR); if (foreground == null) { return JFaceColors.getInformationViewerForegroundColor(display); } return foreground; } </code><technical_language> There's no need to make these public, even if the package is internal. </technical_language>
code&comment2code: <code> public void visitNode(Tree tree) { if (!hasSemantic()) { return; } SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree; <START> Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree); <END> if (!defaultLabel.isPresent()) { if (!isSwitchOnEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Add a default case to this switch."); } else if (missingCasesOfEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Complete cases by adding the missing enum constants or add a default case to this switch."); } } } </code><technical_language> You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault); </technical_language>
code&comment2code: <code> <START> public String getAttribute() { <END> if (fAttribute.equals(NOT_SET)) { setAttribute(); } return fAttribute; } </code><technical_language> This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute. </technical_language>
code&comment2code: <code> public DotRunnableThread(final List<DotRunnable> allListeners) { this.listeners = getListeners(allListeners); this.flushers = getFlushers(allListeners); <START> this.networkCacheFlushThread.start(); <END> } </code><technical_language> ![BLOCKER](<LINK_1> 'Severity: BLOCKER') Move this "start" call to another method. [![rule](<LINK_0>](<LINK_2> </technical_language>
code&comment2code: <code> private void createIndex() { lastFoundElementPosition = 0; filteredPlan.clear(); for (PlanElement element : plan.getList()) { <START> if (!element.isComment()) { <END> filteredPlan.add(element); } } } </code><technical_language> style nit: no braces around single line blocks </technical_language>
code&comment2code: <code> public Collection<Map.Entry<K, V>> scanAndFilterByEntry( Predicate<? super Map.Entry<K, V>> entryPredicate) { <START> return mainMap.entryStream().parallel() <END> .filter(entryPredicate) .collect(Collectors.toCollection(ArrayList::new)); } </code><technical_language> is there a difference between parallelStream() and entryStream().parallel() ? </technical_language>
code&comment2code: <code> <START> protected boolean isValidChar(final char c) { <END> return isValidChar(regExp, c); } </code><technical_language> can be private? or at least package protected access? </technical_language>
code&comment2code: <code> public boolean verifyEventIdentifier(AbstractPlaceEvent event) { boolean equals = Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier()); boolean equals1 = Objects.equals(editorPlaceRequest, event.getPlace()); return (equals && <START> equals1); <END> } </code><technical_language> Toni, could we please choose better variable names here? equals and equals1 do not say much for newcomer to the codebase. Or we could avoid storing partial results by: java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true;  Please let me know what do you think. </technical_language>
code&comment2code: <code> public void star() throws IOException { this.entry.uri() <START> .path(RtGist.PATH_ELEMENT_STAR).back().method("PUT") <END> .fetch().as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_NO_CONTENT); } </code><technical_language> It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look </technical_language>
code&comment2code: <code> public IssueOutputView(Issue issue) { <START> this(issue, null, null); <END> } </code><technical_language> What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference. </technical_language>
code&comment2code: <code> <START> public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) { <END> this.defaultNumberOfRetries = defaultNumberOfRetries; return this; } </code><technical_language> not 100% sure, but this breaks binary compatibility, right? </technical_language>
code&comment2code: <code> <START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); } </code><technical_language> The Exception is never thrown. </technical_language>
code&comment2code: <code> public long getSessionSeqId() { if (sessionSeqId == null) { <START> sessionSeqId = -1L; <END> String sessionId = getContext().getEngineContext().getSessionId(); if (getSessionDataContainer().isSessionExists(sessionId)) { sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId); } } return sessionSeqId; } </code><technical_language> instead of an early assignment which might be overridden in line 2355, it can be set as the 'else' part of the if statement below (line 2356). </technical_language>
code&comment2code: <code> private boolean isTxnRelatedEvent(final NotificationEvent event) { return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) || <START> (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT)) <END> ); } </code><technical_language> Allocate write ID is a DB/table related event and should be ignored if not lookup on this DB/table. </technical_language>
code&comment2code: <code> public static void setBackground(boolean async) { background = async; <START> } <END> </code><technical_language> Can't we have this static flag on FS instead? Then we wouldn't need to make FileStoreAttributeCache public. </technical_language>
code&comment2code: <code> public V put(@NonNull K key, @NonNull V value) { map.put(key, new Entry<>(key, value, ++time)); <START> if (map.size() >= maximumSize) { <END> purge(); } return value; } </code><technical_language> For a small maximuSize, like 1, it may be more reasonable to check for: map.size() > maximumSize </technical_language>
code&comment2code: <code> private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) { if ( value != null && value.trim().length() > 0 ) { boolean isPassword = MongoProp.PASSWORD.equals( prop ); <START> boolean isEncrypted = value.startsWith( Encr.PASSWORD_ENCRYPTED_PREFIX ); <END> if ( isPassword && isEncrypted ) { value = Encr.decryptPasswordOptionallyEncrypted( value ); } builder.set( prop, value ); } } </code><technical_language> Shouldn't do this line - it's handled by the ...Optionally... bit in the Encr class. <LINK_0> </technical_language>
code&comment2code: <code> public Mutation toMutation(K key) { <START> V valueFromStorage = (V) valueDataConversion.fromStorage(value); <END> return new Mutations.ReadWriteWithValue<>(valueFromStorage, f); } </code><technical_language> One use/test case is, a non-serializable pojo (user type) that is encoded as a UTF-8 byte[ ] with some string representation of it. </technical_language>
code&comment2code: <code> <START> public Entry(Map.Entry<String,String> e) { <END> this(e.getKey(), e.getValue()); } </code><technical_language> IMHO it does not need to be public </technical_language>
code&comment2code: <code> private String parsePath() throws URISyntaxException { String[] parts = uri.split("\\?")[0].split(":", 2); <START> if (parts.length < 2 || parts[1].length() < 1) throw new URISyntaxException(uri, "invalid path"); <END> else return parts[1]; } </code><technical_language> parts[1].isEmpty </technical_language>
code&comment2code: <code> public void setItems(Collection value) { genVersionToBaseTemplate(value); <START> final List<VmTemplate> sortedValues = sortTemplates(value); <END> super.setItems(sortedValues); } </code><technical_language> this will affect the sorting also on the webadmin - but on webadmin we support sortable columns. Please move this logic to UserPortalTemplateListModel. </technical_language>
code&comment2code: <code> public void edit(VolumeBrickModel object) { <START> table.setRowData(new ArrayList<ListModel>()); <END> table.edit(object.getBricks()); Driver.driver.edit(object); } </code><technical_language> why you need this line? table.setRowData(new ArrayList<ListModel>()); </technical_language>
code&comment2code: <code> public List<QuickFilter> getQuickFilters() { <START> return this.quickFilters; <END> } </code><technical_language> return quickFilters </technical_language>
code&comment2code: <code> public void testBounds() { int low = fCondition.min(); <START> assertEquals(LOW, low); <END> int high = fCondition.max(); assertEquals(HIGH, high); } </code><technical_language> why not directly assertEquals(LOW, fCondition.min()); ? </technical_language>
code&comment2code: <code> public String weather() { <START> String result = this.restTemplate.getForObject("http://" + WEATHER_SERVICE + "/weather", String.class); <END> return "Weather Service Response: " + result; } </code><technical_language> this is redundant here. </technical_language>
code&comment2code: <code> public boolean isExtensionEnabled() { if (enablement != null) { try { <START> return enablement.getExpression().evaluate(new EvaluationContext(null, new Object())) <END> .equals(EvaluationResult.TRUE); } catch (CoreException e) { } } return true; } </code><technical_language> Let's move this into an EnablementTester.evaluate(...) method. </technical_language>
code&comment2code: <code> public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) { <START> if (manager != null) { <END> return manager; } manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) { @Override protected void registerListeners() { } }; return manager; } </code><technical_language> 'null' must be first operande </technical_language>
code&comment2code: <code> <START> public void startSyncFolderOperation(OCFile folder) { <END> long currentSyncTime = System.currentTimeMillis(); mSyncInProgress = true; RemoteOperation synchFolderOp = new RefreshFolderOperation( folder, currentSyncTime, false, false, false, getStorageManager(), getAccount(), getApplicationContext() ); synchFolderOp.execute(getAccount(), this, null, null); } </code><technical_language> This method can beprivate. </technical_language>
code&comment2code: <code> <START> public static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) { <END> if (cacheManager == null) { throw new IllegalArgumentException("cacheManager cannot be null"); } ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class); if (metadataManager == null) { throw new IllegalStateException("ProtobufMetadataManager not initialised yet!"); } return metadataManager; } </code><technical_language> This can be private again. </technical_language>
code&comment2code: <code> public void onSessionKeyUpdate(SessionKey sessionKey) { <START> log.info("Session key updated"); <END> synchronized (DistributedHerder.this) { DistributedHerder.this.sessionKey = sessionKey.key(); if (isLeader() && keyRotationIntervalMs > 0) { DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs; } } } </code><technical_language> Should this log message be before or after we actually do update the session key? </technical_language>
code&comment2code: <code> public String getAuthorizationUrl(OAuthConfig config) { <START> System.out.print("Authorisation URL: "); <END> String url = String.format(AUTHORIZE_URL, OAuthEncoder.encode(config.getApiKey()), OAuthEncoder.encode(config.getCallback()), OAuthEncoder.encode(config.getScope()), OAuthEncoder.encode(config.getState())); return url; } </code><technical_language> forgotten line of code? </technical_language>
code&comment2code: <code> public Object getParameter(String name) { <START> final HostThread currentHostThread = fCurrentHostThread; <END> if (currentHostThread == null) { return null; } if (name.equals(CriticalPathModule.PARAM_WORKER)) { IAnalysisModule mod = getModule(); if ((mod != null) && (mod instanceof CriticalPathModule)) { LttngWorker worker = new LttngWorker(currentHostThread, "", 0); return worker; } return currentHostThread; } return null; } </code><technical_language> This code here should be inside the if, because we don't need to do anything if the parameter request is not PARAM_WORKER </technical_language>
code&comment2code: <code> public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) { <START> return expectException( runnable.toString(), runnable ); <END> } </code><technical_language> Maybe expectThrowable for consistency? </technical_language>
code&comment2code: <code> protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion, ServicePortBuilder<T> portBuilder) { serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url, assertion != null ? assertion.getTransactionTimeout() : null); <START> configCNCheck(); <END> } </code><technical_language> remove this </technical_language>
code&comment2code: <code> public <V> Setting<V> get(SimpleUri id, Class<V> valueType) { Setting setting = settings.get(id); Class settingValueClass = setting.getValueClass(); if (!settingValueClass.equals(valueType)) { throw new ClassCastException( "Expected a Setting of type " + valueType.getName() + ", found a Setting of type " + settingValueClass.getName() <START> ); <END> } return (Setting<V>) setting; } </code><technical_language> Can we add the name of the setting in there somewhere as well? </technical_language>
code&comment2code: <code> public String getCustomField(String fieldName) { <START> if(customFields == null) return null; <END> for (CustomField f : customFields) { if (f.getName().equals(fieldName)) { return f.getValue(); } } return null; } </code><technical_language> it's better to init customFields with an empty collection to avoid "==null" </technical_language>
code&comment2code: <code> private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) { String expression = commandCall.getExpression(); <START> if (expression.equals("")) { <END> expression = element.getText(); } return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource()); } </code><technical_language> Any way we can clean this up? It seems to only be needed for example commands, but hard to check what the command is here since it's wrapped in decorators. </technical_language>
code&comment2code: <code> public M fromBytes(byte[] messageBuffer) { if (deserializer == null) deserializer = new ThriftBinaryDeserializer(); try { M message = typeRef.safeNewInstance(); deserializer.deserialize(message, messageBuffer); return message; } catch (TException e) { logWarning("failed to deserialize", e); return null; <START> } catch (Throwable e) { <END> logWarning("failed to deserialize", e); return null; } } </code><technical_language> TException is throwable, too, and treated the same -- combine the catch clauses? </technical_language>
code&comment2code: <code> public void showPage(Control page) { if (page.isDisposed() || page.getParent() != this) { return; } currentPage = page; page.setVisible(true); layout(true); Control[] children = getChildren(); for (Control element : children) { <START> Control child = element; <END> if (child != page && !child.isDisposed()) { child.setVisible(false); } } } </code><technical_language> remove </technical_language>
code&comment2code: <code> public void info(String message, Object... objects) { <START> LOG.warn(message, objects); <END> } </code><technical_language> info vs warn </technical_language>
code&comment2code: <code> public String getLinkAt(int offset) { for (int i = 0; i < linkRanges.size(); i++) { if (linkRanges.get(i).isOffsetInRange(offset)) { return hrefs.get(i); } } <START> return null; <END> } </code><technical_language> Let's avoid null and rework to empty string </technical_language>
code&comment2code: <code> public String toString() { readLock.lock(); try { <START> return "FileListCacheValue{fileNames=" + getFileNames() + "}"; <END> } finally { readLock.unlock(); } } </code><technical_language> This change I requested was supposed to remove the need for a read lock </technical_language>
code&comment2code: <code> protected Control createControl(Composite parent) { CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID); config.setHorizontalAlignment(SWT.CENTER); config.setCellSelectionEnabled(false); config.setColumnSelectionEnabled(false); config.setRowSelectionEnabled(false); config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL); config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT); <START> this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config); <END> return this.table.getControl(); } </code><technical_language> Please not here. This is not a standard SWT table. </technical_language>
code&comment2code: <code> public boolean isEnabled() { return <START> getActiveTextEditor() != null; <END> } </code><technical_language> return 'true' </technical_language>
code&comment2code: <code> void verifyMetadata(MessageMetadata metadata) throws Exception { if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) { log.error("Wrong message metadata {}, expecting type {} snapshot {}", metadata, MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot); <START> throw new Exception("wrong type of message"); <END> } } </code><technical_language> maybe you need a specific Exception Type </technical_language>
code&comment2code: <code> public void setVmBackup(VmBackup value) { <START> vmBackup = value; <END> } </code><technical_language> This is a bug, the setter does nothing, use 'this' </technical_language>
code&comment2code: <code> public void setPrice1(int price3) { if (price3 < 0 || price3 > 10000) { <START> throw new IllegalArgumentException("Invalid price: " + price3); <END> } if (true) { assert price3 > 1000; } } </code><technical_language> what is this part for? you are not checking throw statements. </technical_language>
code&comment2code: <code> public String evaluate(TransactionContext txnCtx, Input<Object>[] args) { assert args.length == 2 : "repeat takes exactly two arguments"; var text = (String) args[0].value(); if (text == null) { return null; } <START> var repetitions = (int) args[1].value(); <END> if (repetitions <= 0) { return ""; } else { return text.repeat(repetitions); } } </code><technical_language> This will fail on null </technical_language>
code&comment2code: <code> <START> public void setActionBarNotificationBarColor(MaterialColor color) { <END> getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this))); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { getWindow().setStatusBarColor(color.toStatusBarColor(this)); } } </code><technical_language> why is this public? </technical_language>
code&comment2code: <code> public static ProjectBuildType getProjectType(IProject project) { <START> if (isAutoTools(project)) <END> return ProjectBuildType.AUTO_TOOLS; IConfiguration defaultConfiguration = helper_getActiveConfiguration(project); IBuilder builder = defaultConfiguration.getBuilder(); Boolean projIsManaged = builder.isManagedBuildOn(); if (projIsManaged) return ProjectBuildType.MANAGED_MAKEFILE; else return ProjectBuildType.OTHER; } </code><technical_language> Please use {} for every if/else/for/etc. block. </technical_language>
code&comment2code: <code> protected long download(T object, File outFile) throws IOException { try { openObjectFunction.open(object, outFile); } <START> catch (IOException e) { <END> throw new RuntimeException(e); } return outFile.length(); } </code><technical_language> This isn't necessary. </technical_language>
code&comment2code: <code> private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; try { results = dataStore.getAllResults(); } catch (OseeCoreException ex) { <START> throw new OseeCoreException(ex, "SQL error while reading results"); <END> } return results; } </code><technical_language> what's the point of catching and then throwing the same exception type? </technical_language>
code&comment2code: <code> public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context) <START> { <END> context = node.getSource().accept(this, context); requireNonNull(context, "context is null"); LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections(); String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition(); return context.withFilter(filter).withOutputColumns(node.getOutputVariables()); } </code><technical_language> public </technical_language>
code&comment2code: <code> <START> private Space(String enumeratedValue) { <END> this.enumeratedValue = enumeratedValue; } </code><technical_language> JavaDoc and method signature did not match. Please update the JavaDoc! </technical_language>
code&comment2code: <code> public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) { Guid returnValue = Guid.Empty; List<storage_domains> domains = getAllForStoragePool(pool); for (storage_domains domain : domains) { <START> if (domain.getstorage_domain_type() == StorageDomainType.Master) { <END> returnValue = domain.getId(); break; } } return returnValue; } </code><technical_language> still requires fix: domain.getstorage_domain_type() == type </technical_language>
code&comment2code: <code> public void lock(T id) throws InterruptedException { <START> threadsLocked.inc(); <END> idsLocked.update(1); lockInternal(id); threadsLocked.dec(); } </code><technical_language> For this it's better to do:  threadsLocked.inc(); try { // other stuff } finally { threadsLocked.dec(); }  This way if an exception is thrown we still decrement the threadsLocked counter. </technical_language>
code&comment2code: <code> public RunLengthEncodedBlock(Block value, int positionCount) { requireNonNull(value, "value is null"); if (value.getPositionCount() != 1) { throw new IllegalArgumentException(format("Expected value to contain a single position but has %s positions", value.getPositionCount())); } if (value instanceof RunLengthEncodedBlock) { throw new IllegalArgumentException(format("Value can not be an instance of a %s", getClass().getName())); } if (positionCount < 0) { throw new IllegalArgumentException("positionCount is negative"); } <START> this.value = value <END> this.positionCount = positionCount; } </code><technical_language> looks like syntax typo (Add position checks in RunLenghtEncodedBlock commit) </technical_language>
code&comment2code: <code> public Message.Request request() { <START> Message.Request request = callback.request(); <END> if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency()) return request.copy(retryConsistencyLevel); else return request; } </code><technical_language> Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?) </technical_language>
code&comment2code: <code> public void init(FilterConfig filterConfig) throws ServletException { <START> dirAllowed = Context.getConfig().getBoolean("media.dirAllowed"); <END> } </code><technical_language> I would prefer to use full words. For example directoryAllow. </technical_language>
code&comment2code: <code> public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) { super(extent); <START> checkArgument(patterns.length == 0, "patterns cannot be empty"); <END> this.patterns = patterns; } </code><technical_language> This is backwards, you want the expected condition to be here. </technical_language>
code&comment2code: <code> public boolean isValid(Object[] value, ConstraintValidatorContext context) { if ( value.length != 3 ) { <START> throw new IllegalStateException( "Unexpected method signature" ); <END> } if ( value[1] == null || value[2] == null ) { return true; } return ( (Date) value[1] ).before( (Date) value[2] ); } </code><technical_language> It's tangential, but IllegalArgumentException seems more reasonable. </technical_language>
code&comment2code: <code> <START> private static boolean monoNativeFailure(Either<Utils.CommandResult> result) { <END> if (result == null || !result.isSuccess()) { return true; } else { Utils.CommandResult commandResult = result.get(); return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error); } } </code><technical_language> maybe check for start of file or newline also? </technical_language>
code&comment2code: <code> private void removeAppBar() { DWORD dwABM = new DWORD(); APPBARDATA ABData = new APPBARDATA.ByReference(); ABData.cbSize.setValue( ABData.size() ); dwABM.setValue(ShellAPI.ABM_REMOVE); UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData); <START> assertNotNull(result ); <END> } </code><technical_language> Another extra space, can you plese cleanup all these similar things? There're a few others, some functions have spaces in parameters, some don't like queryPos( APPBARDATA ABData ) vs. dwABM.setValue(ShellAPI.ABM_QUERYPOS);. Sorry to be a pest, just looks messy and inconsistent. </technical_language>
code&comment2code: <code> public boolean couldMatch(ScriptPath path) { <START> return (path.eventLower.startsWith("mythicmob") && (path.eventArgLowerAt(2).equals("spawns"))); <END> } </code><technical_language> stray parens Also, use the standard couldMatch format used through Denizen, not this weird inline thing. </technical_language>
code&comment2code: <code> void init() { <START> controllerHomeDir = resolveControllerHomeDir(); <END> this.initAccessOfDirectories(); this.initAccessOfHosts(); } </code><technical_language> Why does it resolve controller home? is it better to name it with HomeDir? It's because this class not only called from controller but agent. </technical_language>
code&comment2code: <code> protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) { if (launch instanceof GdbLaunch) { return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm); } return null; <START> } <END> </code><technical_language> It is always expected that launch would be an instance of GdbLaunch, I don't think the check is required. </technical_language>
code&comment2code: <code> <START> public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, MiddlewareQueryException, FieldbookException { <END> return this.namingConventionService.advanceNursery(advanceInfo, workbook); } </code><technical_language> MiddlewareQueryException is now a run time exception so it is not required to be part of the method signature. Not invalid to have it in signature, but Sonar will report it as a _Major_ category violation. </technical_language>
code&comment2code: <code> public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) { MacPool macPool = incoming.getMacPool(); <START> macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), <END> macPool.getName(), this)); return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class), VdcActionType.UpdateCluster, new UpdateParametersProvider()); } </code><technical_language> Please make it non-static, similar to what is done with ManagementNetworkFinder </technical_language>
code&comment2code: <code> protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) <START> { String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId()); <END> return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) { IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId); if (module instanceof ISegmentStoreProvider) { return (ISegmentStoreProvider) module; } return null; } }; } </code><technical_language> handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id? </technical_language>
code&comment2code: <code> public void testReservedSkippableBeforeStreamIdentifier() throws Exception { ByteBuf in = Unpooled.wrappedBuffer(new byte[] { -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y' }); <START> assertFalse(channel.writeInbound(in)); <END> } </code><technical_language> I think it makes more sense to omit this assert in the expected exception cases? </technical_language>
code&comment2code: <code> public void set(String name, Property property) throws PropertyNotFoundException { Field field = getType().getField(name); if (field == null) { Property removedProperty = computeRemovedProperty(name); if (removedProperty != null) { removedProperty.set(name, property); } return; } <START> children.put(field.getName().getPrefixedName(), property); <END> setIsModified(); } </code><technical_language> In the get method which calls getChild we use property.getName() instead of field.getName().getPrefixedName() as the key in the children map. Can you make this consistent so that we're sure there's no discrepancy between prefixed/unprefixed? </technical_language>
code&comment2code: <code> public int andCardinality(Container x) { if (this.getCardinality() == 0) return 0; else if (x.getCardinality() ==0) return 0; else { if (x instanceof ArrayContainer) <START> return and((ArrayContainer) x).getCardinality(); <END> else if (x instanceof BitmapContainer) return and((BitmapContainer) x).getCardinality(); return and((RunContainer) x).getCardinality(); } } </code><technical_language> andCardinality(Container) should be called here instead of and(Container).getCardinality() </technical_language>
code&comment2code: <code> public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } <START> Set<WorkerNetAddress> workerAddresses = new HashSet<>(); <END> for (MasterWorkerInfo worker : mWorkers) { workerAddresses.add(worker.getWorkerAddress()); } return workerAddresses; } </code><technical_language> (nit) Initialize with initial capacity to be the number of workers. </technical_language>
code&comment2code: <code> public void setUp() { params.put("CallSid", "CA1234567890ABCDE"); params.put("Caller", "+14158675309"); params.put("Digits", "1234"); params.put("From", "+14158675309"); params.put("To", "+18005551212"); <START> signature = "RSOYDt4T1cUTdK1PDd93/VVr8B8="; <END> } </code><technical_language> move this to where signature is declared, since it never changes? </technical_language>
code&comment2code: <code> <START> public String getAttributeValue(@Nullable String name) { <END> return name; } </code><technical_language> public @Nullable String... </technical_language>
code&comment2code: <code> public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { for (Object cookie : cookiesToClear) { Cookie realCookie = null; <START> if (cookie instanceof String) { <END> realCookie = new Cookie((String) cookie, null); String cookiePath = request.getContextPath() + "/"; realCookie.setPath(cookiePath); realCookie.setMaxAge(0); }else if (cookie instanceof Cookie){ realCookie = (Cookie) cookie; } response.addCookie(realCookie); } } </code><technical_language> This logic will obviously need updated once we change this.cookiesToClear. </technical_language>
code&comment2code: <code> <START> private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) throws InvalidWebSocketException <END> { return MethodHandles.publicLookup().in(endpointClass); } </code><technical_language> Can remove the throws InvalidWebSocketException now. </technical_language>
code&comment2code: <code> public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); <START> numConnections.decrementAndGet(); <END> log.info("Accepted connection above limit ({}). Dropping.", maxConnections); } } super.channelOpen(ctx, e); } </code><technical_language> won't this be a double-decrement? </technical_language>
code&comment2code: <code> public Builder from(int ... nums) { <START> this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0); <END> return this; } </code><technical_language> this assumes the input is sorted, but the test case is what calls this; its very possible that the test defined them in non-sorted order </technical_language>
code&comment2code: <code> public B channel(Class<? extends C> channelClass) { ObjectUtil.checkNotNull(channelClass, "channelClass"); <START> return channelFactory(new ReflectiveChannelFactory<C>(channelClass)); <END> } </code><technical_language> @qeesung: nit you can merge the above 2 lines as checkNotNull returns channelClass. </technical_language>
code&comment2code: <code> public void getActiveConditions_shouldGetActiveConditions() { List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2)); Condition firstActiveCondition = activeConditions.get(0); Condition secondActiveCondition = activeConditions.get(1); <START> String firstUUID = "2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"; <END> String secondUUID = "2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"; Assert.assertTrue(activeConditions.size() == 2); Assert.assertEquals(firstUUID,firstActiveCondition.getUuid()); Assert.assertEquals(secondUUID, secondActiveCondition.getUuid()); } </code><technical_language> For variables which you are using in one place, remove them and just use the actual value in that one place. </technical_language>
code&comment2code: <code> public synchronized Inode<?> getInodeOrNull() { if (!fullPathExists()) { return null; } <START> List<Inode<?>> inodeList = Lists.newArrayList(mLockList.getInodes()); <END> return inodeList.get(inodeList.size() - 1); } </code><technical_language> why is there a newArrayList? </technical_language>
code&comment2code: <code> private static <T> Set<T> findDuplicates(Collection<T> list) { Set<T> duplicates = new HashSet<>(); Set<T> uniques = new HashSet<>(); <START> for(T t : list) { <END> if(!uniques.add(t)) { duplicates.add(t); } } return duplicates; } </code><technical_language> why not list.stream().forEach? </technical_language>
code&comment2code: <code> public boolean next() throws IOException { for (;;) { LogQueueEntry t = queue.poll(); if (t == null) { return false; } refName = t.lc.getRefName(); updateIndex = t.lc.getUpdateIndex(); entry = t.lc.getReflogEntry(); boolean include = includeDeletes || entry != null; skipShadowed(refName, updateIndex); add(t); <START> if (include) { return true; } return true; <END> } } </code><technical_language> This isn't right. </technical_language>
code&comment2code: <code> void remove(MessageGroup group) { Object correlationKey = group.getGroupId(); <START> if (this.groupIds.contains(correlationKey)) { <END> this.messageStore.removeMessageGroup(correlationKey); this.groupIds.remove(correlationKey); } } </code><technical_language> That's not logic for this method. If we are here, we have to be already sure that it is our own group. The real problem is definitely in the ForceReleaseMessageGroupProcessor implementation. We have to check for its presence there. All other logic should not be affected. Please, make this remove() method protected. </technical_language>
code&comment2code: <code> public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException { <START> if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { <END> log.warn("Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API", cachedGroupMetadata.groupId(), consumerGroupId); cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId, JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty()); } sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false); } </code><technical_language> Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams? </technical_language>
code&comment2code: <code> public boolean cancel(final Exception rootReason) { if (transitionCancel(rootReason)) { final Exception reason = new CancellationException(rootReason); try { traceFailure(reason); } catch (Throwable ex) { <START> LOGGER.warn("Exception thrown in logging trace for failure!", ex); <END> } getSettableDelegate().fail(reason); return true; } return false; } </code><technical_language> The issue we found was when the original reason could not be logged due to an error in its toString. Do we have any concern that logging the _new_ error might have the same issue? Would it be better to have two stages to this? 1. Catch the logging error, then try to log that error. 2. Catch _that_ error if it happens, and log a generic, static message. </technical_language>
code&comment2code: <code> <START> int allVersionsCombined() <END> { return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION; } </code><technical_language> Can be private </technical_language>
code&comment2code: <code> <START> protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { <END> writer.writeStartElement(Element.SIMPLE_CONNECTION); writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl()); writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass()); writeOptional(writer, Attribute.USERNAME, configuration.username()); writeOptional(writer, Attribute.PASSWORD, configuration.password()); writer.writeEndElement(); } </code><technical_language> the connection configuration is never serialized. </technical_language>
code&comment2code: <code> <START> static ByteBuf copyData(ByteBufList list) { <END> ByteBuf buf = Unpooled.buffer(list.readableBytes()); for (int i = 0; i < list.size(); i++) { buf.writeBytes(list.getBuffer(i).slice()); } return buf; } </code><technical_language> "public" or "private" ? </technical_language>
code&comment2code: <code> private String getXMI_ID(final EObject eobject) { if (eobject.eResource() instanceof XMIResource) { return ((XMIResource) eobject.eResource()).getID(eobject); } <START> ; <END> return null; } </code><technical_language> Useless </technical_language>
code&comment2code: <code> <START> @Override public float getPressure () { <END> return 0; } </code><technical_language> Can you format these overrides? </technical_language>
code&comment2code: <code> private boolean checkForJournalFlush() { <START> if ( QueueBatchSize == 0 ) <END> return true ; if ( queue.size() >= QueueBatchSize ) return true ; boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ; if ( journalSizeFlush ) return true ; return false ; } </code><technical_language> I'm probably missing something, but it seems like this is part of the next case (isn't queue.size() >= 0 an invariant?). Is this called out just to emphasize that setting 0 => "no queuing"? </technical_language>
code&comment2code: <code> private ProjectState newProjectState(ProjectConfig local) { <START> PrologEnvironment.Factory envFactory = null; GitRepositoryManager gitMgr = null; ProjectControl.AssistedFactory projectControlFactory = null; RulesCache rulesCache = null; SitePaths sitePaths = null; List<CommentLinkInfo> commentLinks = null; all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local)); <END> return all.get(local.getProject().getNameKey()); } </code><technical_language> Use add(ProjectConfig) method here instead of repeating the same code? </technical_language>
code&comment2code: <code> public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId <START> + "AND p.status_id != " + Persona.PersonaStatus.DELETED.getStatusId(); <END> CentralRepository cr = CentralRepository.getInstance(); if (cr != null) { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId; PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback(); cr.executeSelectSQL(queryClause, queryCallback); return queryCallback.getPersonaAccountsList(); } return new ArrayList<>(); } </code><technical_language> There's a re-declaration error here, that got fixed on the parent branch. That needs to get merged in here. </technical_language>
code&comment2code: <code> public boolean hasMultipleValues(final String dimension) { if (isVirtualColumn(dimension)) { return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues(); } final Column column = index.getColumn(dimension); <START> if (column == null || !columnSupportsFiltering(column)) { <END> return false; } else { return column.getCapabilities().hasMultipleValues(); } } </code><technical_language> The same question, how "column supports filtering" relates to "has multiple values"? </technical_language>
code&comment2code: <code> public void resumeNode(String id) { <START> waitServerUntilAvailable.apply(getNode(id)); <END> api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE)); } </code><technical_language> This won't work? You wait until the node is powered on when you want to resume it. This will take forever. </technical_language>
code&comment2code: <code> public IStyledLabelProvider[] getLabelProviders() { <START> if (fLabelProviders == null) { <END> fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders(); } return fLabelProviders; } </code><technical_language> either make this a get method that returns the result, or have it be a "load" method. Having it do both is unexpected (same for above method) </technical_language>
code&comment2code: <code> public void registerOperations(ManagementResourceRegistration resourceRegistration) { if (showResources) { resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler()); } else { resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE); <START> resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); <END> } } </code><technical_language> Why are these registered at all? What invokes them? </technical_language>
code&comment2code: <code> public int hashCode() { <START> int result = processId.hashCode(); <END> result = 31 * result + taskId.hashCode(); result = 31 * result + taskName.hashCode(); result = 31 * result + formName.hashCode(); return result; } </code><technical_language> And one for luck ;-) </technical_language>
code&comment2code: <code> <START> public synchronized void stop(final String reason) <END> { new Thread( "Shutdown Thread" ) { @Override public void run() { independentThreadStop( reason, true ); } }.start(); } </code><technical_language> Can probably remove synchronized now? </technical_language>
code&comment2code: <code> public boolean equals(Object o) { if (!(o instanceof Map.Entry)) <START> return <END> false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; return ((key == null ? e.getKey() == null : key.equals(e.getKey())) && (value == null ? e.getValue() == null : value.equals(e.getValue()))); } </code><technical_language> braces </technical_language>
code&comment2code: <code> <START> public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { <END> super(driver, properties, Dialect.POSTGRESQL); } </code><technical_language> protected ? </technical_language>
code&comment2code: <code> <START> public void dispose() { <END> clearCachedSwingEditor(); } </code><technical_language> make dispose synchronized, then we could remove the volatile keyword in the class member. </technical_language>
code&comment2code: <code> public void run() { if(thread == null || !Thread.currentThread().equals(thread)) { <START> thread = new Thread(this); <END> thread.start(); } else { try { if (logger.isInfoEnabled()) logger.info("Start reconnecting " + provider); provider.register( getUIService().getDefaultSecurityAuthority(provider)); } catch (OperationFailedException ex) { logger.error("cannot re-register provider will keep going", ex); } } } </code><technical_language> I'm thinking that new thread is not needed for the reconnect task. This thread should be dead already by the time a new reconnect is needed and I see Timer instance serving the purpose of this thread. What do you think? </technical_language>
code&comment2code: <code> public void checkProperties(Properties properties) { <START> properties.setProperty("log4j.shutdownCallbackRegistry", "io.druid.common.config.Log4jShutdown"); <END> properties.setProperty("log4j.shutdownHookEnabled", "true"); } </code><technical_language> Couldn't this actually depend on the class and generate the name from that? </technical_language>
code&comment2code: <code> public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class); assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, ""); <END> } </code><technical_language> suggestion assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE); </technical_language>
code&comment2code: <code> private EmbeddedExpirableMetadata( long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) { super(version); this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan); <START> this.maxIdle = maxIdleUnit.toMillis(maxIdle); <END> } </code><technical_language> We should handle maxIdle as well </technical_language>
code&comment2code: <code> protected void setMatcherString(String pattern) { if (pattern.length() == 0) { searchPattern = null; } else { SearchPattern patternMatcher = new SearchPattern(); if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) { <START> pattern = "*" + pattern; <END> } patternMatcher.setPattern(pattern); searchPattern = patternMatcher; } } </code><technical_language> @Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well? </technical_language>
code&comment2code: <code> public DefaultEditorSession(final ManagedSession session, final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager, final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager, final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager, final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) { this.session = session; <START> this.commandRegistry = clientCommandRegistry.setSession(session); <END> this.sessionCommandManager = sessionCommandManager; this.requestCommandManager = requestCommandManager; this.canvasCommandManager = canvasCommandManager; } </code><technical_language> yeah let's remove this :) </technical_language>
code&comment2code: <code> private String transformToHeaderValue(Directive... directives) { <START> final StringBuilder sb = new StringBuilder(); <END> for (int i = 0; i < directives.length - 1; i++) { sb.append(directives[i].headerValue).append(", "); } sb.append(directives[directives.length - 1].headerValue); return sb.toString(); } </code><technical_language> For consistency across the project, please remove the final keyword here. </technical_language>
code&comment2code: <code> private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) { for (CloudProvisioningListener cl : CloudProvisioningListener.all()) { try { cl.onFailure(plannedNode, cause); } catch (Throwable e) { LOGGER.log(Level.SEVERE, "Unexpected uncaught exception encountered while " + "processing onFailure() listener call in " + cl + " for agent " + plannedNode.displayName, e); <START> if (e instanceof Error) { <END> throw e; } } } } </code><technical_language> De-facto we process errors in the logging handler. E.g. logging constructs the string, and it may cause OutOfMemoryError, which suppresses the original one. I'd rather vote that Errors are being rethrown without any processing </technical_language>
code&comment2code: <code> public synchronized boolean isLastMQNotifLongAgo() { long delay = 18 * 3600; long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay; if (threshold < Calendar.getInstance().getTimeInMillis()) { Logger.d(TAG, "{} - Last MQ notif was yesterday", getCurrentModeName()); return true; } else { <START> Logger.d(TAG, "{} - Last MQ notif was recent, do not notify", getCurrentModeName()); <END> return false; } } </code><technical_language> These two logs could be Logger.v(). That's all, good to go! </technical_language>
code&comment2code: <code> public CrewMember apply(org.atlasapi.media.entity.CrewMember input) { if (input instanceof org.atlasapi.media.entity.Actor) { return translateLegacyActor((org.atlasapi.media.entity.Actor) input); <START> } else if(Objects.nonNull(input)) { <END> return translateLegacyCrewMember(input); } else { return null; } } </code><technical_language> Ditto input != null </technical_language>
code&comment2code: <code> public void testSocket() throws Exception { Socket s = new Socket(); s.connect(server.getLocalAddress()); s.close(); assertEquals(Collections.EMPTY_MAP, <START> tagger.getLiveDescriptors()); <END> } </code><technical_language> Did you want to assert something before close in all these cases? i.e. it's not empty. </technical_language>
code&comment2code: <code> public ValuesMatcher( Map<String, Integer> outputSymbolAliases, Optional<Integer> expectedOutputSymbolCount, Optional<List<List<Expression>>> expectedRows) { <START> this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, "outputSymbolAliases is null")); <END> this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, "expectedOutputSymbolCount is null"); this.expectedRows = requireNonNull(expectedRows, "expectedRows is null"); } </code><technical_language> requireNonNull is not needed given copyOf checks for nullability. </technical_language>
code&comment2code: <code> protected Button getButton(int id) { <START> return buttons.get(new Integer(id)); <END> } </code><technical_language> Can just pass id and let Java autoboxing take care of it. </technical_language>
code&comment2code: <code> public void setInitializationData(IConfigurationElement config, String propertyName, Object data) { if (data instanceof <START> Hashtable) { <END> Hashtable<?, ?> table = (Hashtable<?, ?>) data; color = (String) table.get("color"); } } </code><technical_language> Better: Map </technical_language>
code&comment2code: <code> public void addRequestCleanupHandler(HttpServletRequest request) { RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() { @Override public void cleanup(HttpServletRequest req) { try { close(); } catch (OperationException cause) { <START> throw new NuxeoException(cause); <END> } } }); } </code><technical_language> cause -> e please </technical_language>
code&comment2code: <code> public void visitStatementList(PyStatementListTree pyStatementListTree) { <START> if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) { <END> nestingLevelStack.peek().increment(); super.visitStatementList(pyStatementListTree); nestingLevelStack.peek().decrement(); } else { super.visitStatementList(pyStatementListTree); } } </code><technical_language> Why not move the logic about Kind.FILE_INPUT inside isStmtListIncrementsNestingLevel? </technical_language>
code&comment2code: <code> private static void checkLxmlParseCall(SubscriptionContext ctx) { CallExpression callExpression = (CallExpression) ctx.syntaxNode(); if (checkCallExpressionFqn(callExpression, LXML_PARSE)) { CallExpression parserCall = getParserCall( getArgValueAsCallExpression( TreeUtils.nthArgumentOrKeyword(1, "parser", callExpression.arguments()))); if (parserCall != null && isUnsafeParserUsage(parserCall)) { <START> ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE); <END> } } } </code><technical_language> no need to add the same message to the secondary location </technical_language>
code&comment2code: <code> public int getVisibility(IBinding member) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST); return members.getAccessibility(member); } catch (CoreException e) { CCorePlugin.log(e); <START> throw new IllegalArgumentException(member.getName() + " is not a member of " + getName()); <END> } } </code><technical_language> The same error is reported twice. </technical_language>
code&comment2code: <code> public Map<String,Object> getDynamicTemplateData() { if(dynamicTemplateData == null) <START> return Collections.<String,Object>emptyMap(); <END> return dynamicTemplateData; } </code><technical_language> Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be:  return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData; </technical_language>
code&comment2code: <code> <START> public String getVersion() { <END> return version; } </code><technical_language> I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems. </technical_language>
code&comment2code: <code> public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException { Utils.checkPerunSession(sess); if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) && <START> !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { <END> throw new PrivilegeException(sess, "getUsers"); } return getUsersManagerBl().getUsers(sess); } </code><technical_language> You can drop PERUNADMIN check here. And also in all other such methods in this file please. </technical_language>
code&comment2code: <code> protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (cluster.isSetRequiredSwitchType()) { <END> SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } } </code><technical_language> Negation missing? if (!cluster.isSetRequiredSwitchType()) { </technical_language>
code&comment2code: <code> public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI) <START> throws IOException <END> { throw new UnsupportedOperationException("GetBlockLocations is not supported."); } </code><technical_language> Removed. </technical_language>
code&comment2code: <code> public CustomTxtParserWizard() { super(); <START> setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); <END> } </code><technical_language> can this be in the second ctor and call this(null) here? </technical_language>
code&comment2code: <code> <START> protected Provider<AdditionalProperties> createProvider(String name) { <END> Provider<AdditionalProperties> p = mock(Provider.class); when(p.getName()).thenReturn(name); return p; } </code><technical_language> Don't see how this change is necessary </technical_language>
code&comment2code: <code> public static int mapApiToArtVersion(int api) { if (api < 19) { return NO_VERSION; } switch (api) { case 19: case 20: return 7; case 21: return 39; case 22: return 45; case 23: return 64; case 24: case 25: return 79; case 26: return 124; case 27: return 131; case 28: return 144; } <START> return 143; <END> } </code><technical_language> You can change the 28 case to a default case, and remove this. </technical_language>
code&comment2code: <code> public void onAppendColumnEvent() { AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP); scenarioSimulationEventHandler.onEvent(event); verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class)); <START> verify(scenarioGridPanelMock).setFocus(true); <END> } </code><technical_language> @jomarko If it is possible to move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution, then move this "verify(scenarioGridPanelMock).setFocus(true);" inside "commonExecution" Test </technical_language>
code&comment2code: <code> public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception { byte[] bytes = serialize( instance ); T result = ( T )deserialize( bytes ); <START> Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); <END> IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter; displayAdapter.attachThread(); return result; } </code><technical_language> Since getAdapter() has a generic interface, there is no need to type cast anymore. </technical_language>
code&comment2code: <code> <START> public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { <END> for (PreReceiveHook hook : hooks) { hook.onPreReceive(rp, commands); } } </code><technical_language> maybe line wrap? </technical_language>
code&comment2code: <code> public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) { if (annotation == null) { throw new NullPointerException("Cannot add a null annotation"); } annotations.add(annotation); <START> annotations.addAll(Arrays.asList(additionalAnnotations)); <END> return this; } </code><technical_language> This only checks the first parameter for null. Could you update the version that takes in a List to check the entries for nulls and update this line to call that version? </technical_language>
code&comment2code: <code> public void onAttach(final Activity activity) { super.onAttach(activity); try { mListener = (Listener) activity; <START> } catch (final ClassCastException e) { <END> Lg.e(activity.getClass().getName(), " should implement ", Listener.class.getName()); } } </code><technical_language> instanceof? </technical_language>
code&comment2code: <code> private void preloadDataSet(){ preloadedDataSet = load(iter.next()); totalOutcomes = preloadedDataSet.getLabels().size(1); inputColumns = preloadedDataSet.getFeatureMatrix().size(1); <START> batch = preloadedDataSet.numExamples(); <END> } </code><technical_language> Need to be careful here. We can't always assume classification problems. Maybe use -1 (last dimension) instead? </technical_language>
code&comment2code: <code> public void startup(Application application, ComponentStartupStatus ss) { FileOps.ensureDir(deltaClientZone); FileOps.clearAll(deltaClientZone); zone = Zone.connect(deltaClientZone); deltaLink = DeltaLinkHTTP.connect(deltaServerURL); deltaClient = DeltaClient.create(zone, deltaLink); jmsMessagingClient = application.getJMSMessagingClient(); <START> log.info(String.format("DeltaClient connected to DeltaServer at %s with zone %s", deltaServerURL, deltaClientZone)); <END> } </code><technical_language> log.info() to ss.info(). </technical_language>
code&comment2code: <code> protected void onInit() { super.onInit(); if (this.connectionFactory == null) { <START> this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); <END> this.connectionFactory.setDeserializer(new ByteArrayLfSerializer()); this.connectionFactory.setBeanFactory(getBeanFactory()); if (this.applicationEventPublisher != null) { this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher); } this.connectionFactory.afterPropertiesSet(); } this.connectionFactory.registerListener(this); } </code><technical_language> I think we don't need this change. We have similar structure in the UdpSyslogReceivingChannelAdapter below but you don't override the onInit() logic there. </technical_language>
code&comment2code: <code> <START> public static Pair<Integer, Integer> getPrecisionAndScale(String type) { <END> String param = type.substring(8, type.length() - 1); String[] params = param.split(","); return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim())); } </code><technical_language> are there some unit tests for this? Will this handle extraneous whitespaces well? </technical_language>
code&comment2code: <code> <START> static String constructSegmentPath(String baseKey, String storageDir) <END> { return JOINER.join( baseKey.isEmpty() ? null : baseKey, storageDir ) + "/index.zip"; } </code><technical_language> we don't know if these were used in extensions, can the things that were public remain so? </technical_language>
code&comment2code: <code> public MappingIterator(Collection<S> source, Function<S, D> transformation) { this.sourceIt = source.iterator(); this.transformation = transformation; <START> readNext(); <END> } </code><technical_language> I find it strange that the constructor already does some work. Might catch someone by surprise, especially if he wants to concatenate several iterators. I'd like this better if only hasNext() or next() actually advanced. It's more predictable. Maybe similar to the logic in CachingKeyPairProvider$CancellingKeyPairIterator . That one is similar to MappingIterator<Path, KeyPair>. </technical_language>
code&comment2code: <code> public boolean removeAll(Collection<?> c) { boolean changed = false; for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) { <START> if (map.remove(x.getFilename(), x)) { <END> changed = true; } } if (changed) { updatedMap(); } return changed; } </code><technical_language> remove(a,b) is going to use equals which is not right for XWikiAttachment. You should use remove(a) != b instead. </technical_language>
code&comment2code: <code> public void run(String... strings) throws Exception { <START> System.out.println(">>> Starting Audit App... "); <END> } </code><technical_language> @erdemedeiros let's remove all the system outs </technical_language>
code&comment2code: <code> public CollectEnvCommand(FileSystemContext fsContext) { super(fsContext); <START> mCommands = new HashMap<>(); mCommandsAlt = new HashMap<>(); <END> registerCommands(); } </code><technical_language> This is already initialized by super class. </technical_language>
code&comment2code: <code> protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException("BlobStorageService cannot be null"); <START> } else { <END> this.blobStorageService = blobStorageService; logger.trace("BlobStorage service set to {}", blobStorageService.getClass()); } } </code><technical_language> The "else" seems unnecessary </technical_language>
code&comment2code: <code> public void dispose() { app.getChildren().remove(windowModel); coolBarManager.dispose(); menuManager.dispose(); statusLineManager.dispose(); <START> windowModel.setToBeRendered(false); <END> windowModel.getContext().deactivate(); windowModel.getContext().dispose(); ((Shell) windowModel.getWidget()).dispose(); } </code><technical_language> I don't think this hurts but line 96 already sets this window.tbr to false and I have not seen that this property has changed. </technical_language>
code&comment2code: <code> public void setUp() { n = new CacheManagerNotifierImpl(); cl = new CacheManagerListener(); <START> TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); <END> n.start(); n.addListener(cl); } </code><technical_language> The executor shouldn't be needed here either </technical_language>
code&comment2code: <code> public char getLabel() { <START> char rv; <END> switch (getType()) { case INPUT_VAL: rv = buttonData.inputVal; break; case AUTO_CHAR: rv = buttonData.autoChar; break; case CUSTOM: rv = buttonData.customChar; break; default: rv='*'; } return rv; } </code><technical_language> Should be final char rv;. </technical_language>
code&comment2code: <code> public ReleasableBytesReference retainedSlice(int from, int length) { BytesReference slice = delegate.slice(from, length); <START> refCounted.incRef(); <END> return new ReleasableBytesReference(slice, refCounted); } </code><technical_language> I would prefer to move this call to the private ReleasableBytesReference constructor. </technical_language>
code&comment2code: <code> public static <T> Iterable<T> latest(final Observable<? extends T> source) { return new Iterable<T>() { @Override public Iterator<T> iterator() { LatestObserverIterator<T> lio = new LatestObserverIterator<T>(); <START> lio.subscription = source.materialize().subscribe(lio); <END> return lio; } }; } </code><technical_language> This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value lio essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call this.unsubscribe() on L101. </technical_language>
code&comment2code: <code> public static MessageType fromId(String id) { for(MessageType current : values()) { if(current.getId().equals(id)) { return current; } } <START> return UNKNOWN; <END> } </code><technical_language> Discussion: does it make sense to return an enum entry here that I guess only exists for this method? Other alternatives could be to return null here, or an Optional </technical_language>
code&comment2code: <code> private boolean isHostNetworkUnreacable(VDS vds) { VdsDynamic vdsDynamic = vds.getDynamicData(); return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational <START> && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); <END> } </code><technical_language> Please remove unnecessary brackets: return vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE); Even remaining brackets are not necessary, but they makes code more readable </technical_language>
code&comment2code: <code> <START> ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { <END> this.scriptMessageProcessor = scriptMessageProcessor; } </code><technical_language> Having the Java Config style, it'd better to make this class public. </technical_language>
code&comment2code: <code> public void typeInSearchField(String content, int length) { waitForElementVisibleByElement(searchInput); <START> searchInput.sendKeys(content.substring(0, length)); <END> PageObjectLogging.log( "typeInSearchField", "String >>" + content.substring(0, length) + "<< was typed in string field", true ); } </code><technical_language> How come there needs to be a substring for this? </technical_language>
code&comment2code: <code> public Iterable<E> read(Configuration configuration) throws IOException { DatasetReader<E> reader = view.newReader(); <START> return reader; <END> } </code><technical_language> Inline. </technical_language>
code&comment2code: <code> public void setRefreshInterval(final long refreshInterval) { <START> REFRESH_INTERVAL_IN_SECONDS = refreshInterval; <END> } </code><technical_language> if it is not constant, please convert to lower case? </technical_language>
code&comment2code: <code> public void onNewImageFromCamera() { <START> if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { <END> navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA); } else { interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null); } } </code><technical_language> These copy-paste sections are starting to clutter up the presenter. Please try to extract a common denominator (e.g. a function) to reduce repeating code snippets. </technical_language>
code&comment2code: <code> public void testEquals() throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, "UTF8", <START> 10, true, false, true); <END> FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, "UTF8", 10, true, false, true); assertEquals(conf1, conf2); FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, "UTF8", 10, false, false, true); assertFalse(conf1.equals(conf3)); } </code><technical_language> Please make sure there are overloaded constructors available for the old constructor signature. Then you also wont have to change this existing test. </technical_language>
code&comment2code: <code> public void showLinkPreview(PageTitle title, int entrySource) { final String linkPreviewFragmentTag = "link_preview_dialog"; if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) { <START> linkPreview = LinkPreviewDialog.newInstance(title, entrySource); <END> linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag); } } </code><technical_language> You actually don't need a private variable for storing the link preview. If you look at the line directly above, the findFragmentByTag() function finds the dialog by its tag name (also specified above). You can cast the return value of this function into a LinkPreviewDialog, and call dismiss() on it. </technical_language>
code&comment2code: <code> public void clear() { <START> if (loader instanceof CacheStore) <END> try { ((CacheStore) loader).clear(); } catch (CacheLoaderException e) { throw newCacheLoaderException(e); } } </code><technical_language> IMO, if you use if (...) { ... }, it makes the code easy to read. I meant the { and } are missing :) edit: the same for the following ifs </technical_language>
code&comment2code: <code> public ApplicabilityIds getApplicabilityIds() { <START> ApplicabilityIds ids = new ApplicabilityIds(); <END> return ids; } </code><technical_language> This file needs some work to ensure it works with client. </technical_language>
code&comment2code: <code> <START> MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { <END> if (!negotiated.matchesAll()) return negotiated; MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType(); if (storageMediaType == null) return negotiated; if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN; if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON; return negotiated; } </code><technical_language> private? </technical_language>
code&comment2code: <code> protected void addJAROption(Composite comp) { fJarButton = new Button(comp, SWT.CHECK); fJarButton.setText(getJarButtonText()); <START> fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { <END> })); } </code><technical_language> This does not do anything. Can be removed </technical_language>
code&comment2code: <code> public String getTurnDescription( Translation tr ) { <START> if (rawName || !name.isEmpty()) <END> return getName(); return tr.tr("finish"); } </code><technical_language> The additional check is not used in other instructions, is it needed? </technical_language>
code&comment2code: <code> private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions(); presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton()); try { createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true); } catch (Exception e) { <START> throw e; <END> } } </code><technical_language> Catch? </technical_language>
code&comment2code: <code> public String toString() { StringWriter writer = new StringWriter(); try { new ObjectMapper().writeValue(writer, graph); } catch (Exception e) { log.debug ("Error while constructing new ObjectMapper",e); <START> } <END> return writer.toString(); } </code><technical_language> Make this as a log.error statement. And needs to have space after the "," </technical_language>
code&comment2code: <code> public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) { this.topic = topic; this.connector = task.connector(); this.task = task.task(); <START> this.discoverTimestamp = discoverTimestamp; <END> } </code><technical_language> How about replacing these four lines with:  this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp);  and then removing the TODO line? </technical_language>
code&comment2code: <code> private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length) { switch (type) { case POINT: return readPoint(input); case MULTI_POINT: case LINE_STRING: case MULTI_LINE_STRING: case POLYGON: case MULTI_POLYGON: return readSimpleGeometry(input, inputSlice, type, length); case GEOMETRY_COLLECTION: return readGeometryCollection(input, inputSlice); case ENVELOPE: <START> return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); <END> default: throw new IllegalArgumentException("Unexpected type: " + type); } } </code><technical_language> Just add an envelope section to createFromEsriGeometry method in this file </technical_language>
code&comment2code: <code> public void close() { <START> sketch = null; <END> } </code><technical_language> Could set null to the values field too </technical_language>
code&comment2code: <code> public boolean shouldSpill() { long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch; long reserveForOutgoing = batchMemoryManager.getOutputBatchSize(); <START> long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing; <END> boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow; if ( needsSpill ) { logger.debug("should spill now - batch size {}, mem avail {}, reserved for outgoing {}", batchSize, memoryAvailableNow, reserveForOutgoing); } return needsSpill; } </code><technical_language> We still need to account for the probe batch size here when we are processing a spilled partition. If we try to account for it in he PostBuildCalculator it will already be too late, because we will have already prefetched the probe side batch. </technical_language>
code&comment2code: <code> public void close() { try { Await.result(beam.close()); } catch (Exception e) { final String errorMsg = "Error while closing Druid beam client"; LOG.error(errorMsg, e); <START> throw new RuntimeException(errorMsg); <END> } } </code><technical_language> same as above. we shouldn't be throwing run-time exceptions when close is called. </technical_language>
code&comment2code: <code> private boolean isPlatformKeybindingBug517068Fixed() { Bundle bundle = Platform.getBundle("org.eclipse.e4.ui.bindings"); Version currentVersion = bundle.getVersion(); <START> Version fixVersion = new Version(0, 12, 100); <END> return currentVersion.compareTo(fixVersion) >= 0; } </code><technical_language> Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1. </technical_language>
code&comment2code: <code> public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 ) { <START> if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) <END> && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) ) { return true; } return false; } </code><technical_language> Why not just: return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ); </technical_language>
code&comment2code: <code> public <VT> MessageOut<T> withParameter(ParameterType type, VT value) { <START> List<Object> newParameters = new ArrayList<>(parameters.size() + 3); <END> newParameters.addAll(parameters); newParameters.add(type); newParameters.add(value); return new MessageOut<T>(verb, payload, serializer, newParameters); } </code><technical_language> I think tuple size used to be 3. I'll fix it. </technical_language>
code&comment2code: <code> private boolean validateTimeRange() { boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty(); return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0; <START> } <END> </code><technical_language> should this be < 0? do we want to import a 0 nanosecond range? </technical_language>
code&comment2code: <code> public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) { String filenamePath = ""; StringBuilder filenameBuilder = new StringBuilder(); filenameBuilder.append(fieldbookProperties.getUploadDirectory()); filenameBuilder.append(File.separator); filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename)); <START> filenamePath = filenameBuilder.toString(); <END> return filenamePath; } </code><technical_language> Move filenamePath declaration to this line and make it final </technical_language>
code&comment2code: <code> protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) { executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() { @SuppressWarnings("synthetic-access") @Override public StoragePoolIsoMap runInTransaction() { <START> CompensationContext context = getCompensationContext(); <END> context.snapshotEntityStatus(map, map.getstatus()); map.setstatus(status); getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus()); getCompensationContext().stateChanged(); return null; } }); } </code><technical_language> this line can be removed </technical_language>
code&comment2code: <code> public void visitMemberSelectExpression(MemberSelectExpressionTree tree) { if (tree.expression().is(Tree.Kind.IDENTIFIER)) { IdentifierTree identifier = (IdentifierTree) tree.expression(); <START> final Symbol owner = identifier.symbol().owner(); <END> if (owner != null && owner.isMethodSymbol()) { return; } } if (tree.expression().symbolType().isSubtypeOf("java.lang.Class")) { return; } super.visitMemberSelectExpression(tree); } </code><technical_language> remove final modifier. </technical_language>
code&comment2code: <code> public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED); checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED); <START> if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { <END> BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction); return executeOnKeyInternal(key, ep); } else { return computeIfPresentLocally(key, remappingFunction); } } </code><technical_language> Hi, @mmedenjak is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the computeIfPresentLocally only implementation for now for the client. The optimisation for the client can be addressed later. </technical_language>
code&comment2code: <code> public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) { Tuple tuple = task.getTuple(stream, values); List<Integer> tasks = task.getOutgoingTasks(stream, values); <START> if (tasks.size() == 0) { <END> return; } for (Integer t : tasks) { transfer.transfer(t, tuple); } } </code><technical_language> we don't need this check right. For loop won't enter if tasks are empty. We should avoid having multiple returns. </technical_language>
code&comment2code: <code> AffinityResourceDefinition(PathElement path) { <START> super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler()); <END> } </code><technical_language> Unless I'm mistaken, you don't need to reload the whole server, just restart the services of the parent resource. You can leverage RestartParentResourceRegistration for this. </technical_language>
code&comment2code: <code> @Override public E poll() { lock.lock(); try { if (queue.isEmpty()) { return null; } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> } finally { lock.unlock(); } } </code><technical_language> throws </technical_language>
code&comment2code: <code> public void testTimeout() throws SystemException, RemoteException { <START> log.info("Method stateful #testTimeout called"); <END> Transaction txn; txn = tm.getTransaction(); TxTestUtil.enlistTestXAResource(txn); TxTestUtil.enlistTestXAResource(txn); try { TxTestUtil.waitForTimeout(tm); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RemoteException("Interupted during waiting for transaction timeout", ie); } } </code><technical_language> log.tracef </technical_language>
code&comment2code: <code> <START> public UnstagedComparator(boolean sortAlphabetically) { <END> this.alphabeticallySort = sortAlphabetically; } </code><technical_language> doesn't need to be public </technical_language>
code&comment2code: <code> public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) { StorageType storageType = diskImage.getStorageTypes().get(0); String diskType = getDiskType(vm, diskImage, device); boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())); if <START> (device.getSnapshotId() != null) { <END> isNativeIO = false; } return isNativeIO; } </code><technical_language> So why not just add it to the boolean expression in line #1377? </technical_language>
code&comment2code: <code> public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException { if (!isAnonymous()) { return execute(request, true, monitor); } <START> return execute(request, false, monitor); <END> } </code><technical_language> Lines 316-319 can be rewritten as return execute(request, !isAnonymous(), monitor); </technical_language>
code&comment2code: <code> public HighlightingInlineHyperlink(final String text, final String token, final String toHighlight) { super(text, token); <START> highlight(text, toHighlight); <END> } </code><technical_language> Maybe highlight should be called from setText instead? That way, if the text is changed after construction it will get highlighted too. </technical_language>
code&comment2code: <code> <START> String serializeInstallCmd(Collection<String> packages) { <END> if (packages.isEmpty()) { return ""; } else { return CommandInfo.CMD_INSTALL + " " + String.join(" ", packages); } } </code><technical_language> Not sure if this is guideline, I would prefer to use protected visibility rather than package protected one. </technical_language>
code&comment2code: <code> private List roundtrip(List vals, Map conf) { List ret = null; try { ret = deserialize(serialize(vals, conf), conf); <START> } catch (IOException e) { <END> LOG.error("Exception when serialize/deserialize ", e); } return ret; } </code><technical_language> I would prefer to have the IOException thrown by roundtrip. Catching it will still cause the test to fail, but it will be harder to debug. </technical_language>
code&comment2code: <code> public GlobalDirectoryResourceDefinition() { super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY)) <START> .setAddRestartLevel(OperationEntry.Flag.RESTART_JVM) <END> .setRemoveRestartLevel(OperationEntry.Flag.RESTART_JVM) .setAddHandler(GlobalDirectoryResourceDefinition.ADD) .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE) .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY) ); } </code><technical_language> Why RESTART_JVM? AFAICT if I add this after boot the service is installed immediately. You'd have to redeploy any app for it to use the module, but that doesn't even require a reload much less a process restart. </technical_language>
code&comment2code: <code> public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> this.fChartViewer <END> = chartViewer; } </code><technical_language> You can remove the this </technical_language>
code&comment2code: <code> public String toStringShort() { <START> return MoreObjects.toStringHelper("") <END> .add("ClientType", getStringFromOptional(mClientType)) .add("ClientHostname", mLocalHostName) .add("ServerAddress", mServerAddress) .add("ChannelId", mChannelId) .omitNullValues() .toString(); } </code><technical_language> I am confused when this is supposed to be "" or this? </technical_language>
code&comment2code: <code> public CompilationUnit() { <START> this(null, false, null, new NodeList<>(), new NodeList<>(), null); <END> } </code><technical_language> for the boolean parameter could be useful to use enums, so that it is more clear what it means </technical_language>
code&comment2code: <code> public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); <START> description = (String) command.getParam(PARAM_DESC); <END> } </code><technical_language> cast is not needed. </technical_language>
code&comment2code: <code> protected void executeQueryCommand() { <START> Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); <END> NetworkProviderProxy client = getProviderProxyFactory().create(provider); getQueryReturnValue().setReturnValue(client.getAll()); } </code><technical_language> shouldn't provider be validated for existence prior to accessing it? </technical_language>
code&comment2code: <code> public void testCrashlyticsUninitializedOnAnonymousReportDisabled() { Context context = InstrumentationRegistry.getTargetContext(); SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false); <START> editor.clear(); <END> editor.commit(); CrashReporter crashReporter = new CrashReporter(context); assertFalse(crashReporter.initialize()); } </code><technical_language> In some tests you're using editor.clear(), in some you don't. I guess it's better to use it in all tests. Assume that the tests are executed in a random order and should also start in a clean state. So using a [@Before method (setUp)](<LINK_0> to clear the SharedPreferences seems like a good idea. Maybe create a static util method so others can benefit from it as well. </technical_language>
code&comment2code: <code> <START> protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { <END> if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages())) { return false; } else { return true; } } </code><technical_language> it can be simplified to a single return statement protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages()); } </technical_language>
code&comment2code: <code> private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException { log.info("Start Discovery Service."); CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>(); this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath()); replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext, <START> clusterManagerAdapter, discoveryServiceCallback);; <END> return discoveryServiceCallback; } </code><technical_language> typo --> ;; </technical_language>
code&comment2code: <code> public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception { long prevChunk = mallocChunks(4); long middleChunk = mallocChunks(4); long nextChunk = mallocChunks(2); free(middleChunk); long smallChunk1 = mallocChunks(1); long smallChunk2 = mallocChunks(1); <START> assertTrue("The small chunks should have been allocated from the end of the free block", smallChunk1 > smallChunk2); assertTrue("The small chunks should have been allocated from space before 'nextChunk'", smallChunk1 < nextChunk); assertTrue("The small chunks should have been allocated from space after 'prevChunk'", smallChunk2 > prevChunk); <END> } </code><technical_language> I would change the order to: assertTrue(prevChunk < smallChunk2); assertTrue(smallChunk2 < smallChunk1); assertTrue(smallChunk1 < nextChunk); </technical_language>
code&comment2code: <code> public void shouldSetTempImagesPathAsCompleteDirectory() { URI path = URI.create("/pages/newImagesTemp/"); ConfigCore.setImagesPath(URI.create("/pages/newImagesTemp/")); <START> System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory()); <END> assertEquals("Temp images path was set incorrectly!", path, URI.create("/pages/newImagesTemp/")); } </code><technical_language> Why did you add this System.out.println() call? Maybe a logger is a better solution. </technical_language>
code&comment2code: <code> public MetadataHashAggPOP(@JsonProperty("child") PhysicalOperator child, @JsonProperty("context") MetadataAggregateContext context, @JsonProperty("phase") OperatorPhase phase) { super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F); <START> this.context = context; <END> this.phase = phase; Preconditions.checkArgument(context.createNewAggregations(), "Hash aggregate for metadata collecting should be used only for creating new aggregations."); } </code><technical_language> Please move this check before assigning the variables. </technical_language>
code&comment2code: <code> private void saveProcess(Process process) { try { serviceManager.getProcessService().save(process); } catch (DataException e) { <START> Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, "Error while saving process: " + process.getTitle(), e); <END> logger.error(KITODO_SCRIPT_FIELD + "Error while saving process: " + process.getTitle(), e); } } </code><technical_language> Please first log the error and then inform the user. </technical_language>
code&comment2code: <code> <START> private String toHexString(QuantileDigest qdigest) <END> { return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll("\\s+", " "); } </code><technical_language> private static </technical_language>
code&comment2code: <code> <START> public String getHeader(){ <END> return selectedPageHeader.getText(); } </code><technical_language> this should be private method </technical_language>
code&comment2code: <code> public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) { String userModelAttrName = getUserModelAttribute(); String attributeValue = getAttributeValue(); Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase()); if (userModelProperty != null) { <START> checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user); <END> setPropertyOnUserModel(userModelProperty, user, attributeValue); } else { user.setAttribute(userModelAttrName, Arrays.asList(attributeValue)); } } </code><technical_language> Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute. </technical_language>
code&comment2code: <code> <START> public Boolean delete( ProjectName projectName ) <END> { return callWithContext( () -> { final Boolean result = doDelete( projectName ); LOG.info( "Project deleted: " + projectName ); return result; } ); } </code><technical_language> boolean instead of Boolean </technical_language>
code&comment2code: <code> public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, <START> InterruptedException, KeeperException.NoNodeException { <END> final int port = getPort(hostPort); LOG.info("STARTING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure())); } </code><technical_language> this isn't needed anymore right? </technical_language>
code&comment2code: <code> public void shouldShowAllMusicsAsHTTP() { MockHttpResult mockHttpResult = new MockHttpResult(); controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics); when(dao.listAll()).thenReturn(Arrays.asList(music)); controller.showAllMusicsAsHTTP(); assertEquals("<p class=\"content\">"+ Arrays.asList(music).toString()+"</p>", mockHttpResult.getBody()); <START> } <END> </code><technical_language> If you want, you can change to use hamcrest here too. The method Matchers.is compare if two objects are equals. </technical_language>
code&comment2code: <code> public AttributeValueSearch(IAttributeType attributeType, String attributeValue) { this.attributeType = attributeType; this.attributeValue = attributeValue; <START> Conditions.checkNotNull(attributeType, "attributeType"); Conditions.checkNotNullOrEmpty(attributeValue, "attributeValue"); <END> } </code><technical_language> wouldn't you want the conditions check prior to assignments? </technical_language>
code&comment2code: <code> public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) { super(source); <START> this.idleTime = Duration.ofMillis(idleTime); <END> this.listenerId = id; this.queueNames = Arrays.asList(queueNames); } </code><technical_language> What made you to wrap, when you still use a simple long afterwards? </technical_language>
code&comment2code: <code> public static XARecoveryModule getRegisteredXARecoveryModule () { if (registeredXARecoveryModule == null) { RecoveryManager recMan = RecoveryManager.manager(); Vector recoveryModules = recMan.getModules(); if (recoveryModules != null) { Enumeration modules = recoveryModules.elements(); while (modules.hasMoreElements()) { RecoveryModule m = (RecoveryModule) modules.nextElement(); if (m instanceof XARecoveryModule) { <START> registeredXARecoveryModule = (XARecoveryModule) m; <END> } } } } return registeredXARecoveryModule; } </code><technical_language> you should break out of the loop early after finding the target module </technical_language>
code&comment2code: <code> public String getUrl() { <START> return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); <END> } </code><technical_language> possible NPE </technical_language>
code&comment2code: <code> public void testBoundarySignalProcessInstance() throws Exception { Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS); assertNotNull(processInstanceId); assertTrue(processInstanceId.longValue() > 0); try { <START> checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); <END> } catch (Exception e){ processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); e.printStackTrace(); fail(e.getMessage()); } } </code><technical_language> Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log. </technical_language>
code&comment2code: <code> private void validateAppConfig(String fileName) throws Exception { String appsDir = getAppsDirectory(); if (appsDir.equalsIgnoreCase("apps") && !isAppConfiguredInSourceServerXml(fileName)) { applicationXml.createWebApplicationElement(fileName); } <START> else if (appsDir.equalsIgnoreCase("dropins") && isAnyAppConfiguredInSourceServerXml()) <END> throw new MojoExecutionException(messages.getString("error.install.app.dropins.directory")); } </code><technical_language> why not calling isAppConfiguredInSourceServerXml(fileName) to make sure the app installed to the dropins location is not configured? </technical_language>
code&comment2code: <code> <START> static RequestContextDataHolder getRequestContext(Context ctx) { <END> return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null); } </code><technical_language> Please add private modifier </technical_language>
code&comment2code: <code> public long getNumberOfImagesInStorageDomain(Guid storageDomainId) { <START> MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId); <END> return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), params); } </code><technical_language> I'd inline this to conform with the rest of the class. </technical_language>
code&comment2code: <code> public TestObjectAsync() { try { <START> Thread.sleep(100); <END> Thread.sleep(100); counter = 1; } catch (InterruptedException ie) { throw new RuntimeException(ie); } } </code><technical_language> Is it really necessary to wait 100 milliseconds? Why not Thread.sleep(1). Why not Thread.yield()? </technical_language>
code&comment2code: <code> private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) { Field field = getField(beanClass, beanProp.getName()); return field != null ? field.getAnnotationsByType(Optional.class).length > 0 <START> || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 <END> : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0; } </code><technical_language> Maybe beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 should be checked before calling getField ? Method getField modifies field via reflection and optionally recursively calls itself, so it could be costly. </technical_language>
code&comment2code: <code> public int getImageselector () { return imageSelectorIndex; <START> } <END> </code><technical_language> Why is this method required? Didn't see it used anywhere in the code </technical_language>
code&comment2code: <code> public InputStream getInputStream(FileHeader entry) throws IOException { if (entry == null) { return null; } InputStream inputStream = getEntryData(entry).getInputStream(); if (entry.getMethod() == ZipEntry.DEFLATED) { <START> inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true), <END> (int) entry.getSize()); } return inputStream; } </code><technical_language> I don't think we want to pass in an Inflater and than have ZipInflaterInputStream call end() on it. </technical_language>
code&comment2code: <code> private org.eclipse.swt.graphics.Image createImage() { org.eclipse.swt.graphics.Image newImage; RenderedImage image = renderManager.getImage(); <START> this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); <END> if (image != null) newImage = AWTSWTImageUtils.createSWTImage(image, false); else { newImage = new Image(getDisplay(), getWidth(), getHeight()); } return newImage; } </code><technical_language> Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls? </technical_language>
code&comment2code: <code> public VirtualMachine getCurrentMachineBuild(ITmfEvent event) { VirtualMachine machine = innerGetCurrentMachine(event); if (machine == null) { synchronized (fStateSystem) { String hostId = event.getTrace().getHostId(); <START> machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); <END> fKnownMachines.put(hostId, machine); } } return machine; } </code><technical_language> this is nullable </technical_language>
code&comment2code: <code> public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && isDeterministic(expression) && !mayReturnNullOnNonNullInput(expression) && <START> !isDynamicFilter(expression)) { <END> ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; } </code><technical_language> Why do we need it here? </technical_language>
code&comment2code: <code> private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates) throws DbException { for (int agg = 0; agg < aggregators.length; ++agg) { if (!(aggregators[agg] .getClass() .getName() <START> .equals(StatefulUserDefinedAggregator.class.getName()))) { <END> aggregators[agg].addRow(tb, row, curAggStates[agg]); } } } </code><technical_language> instanceof </technical_language>
code&comment2code: <code> protected void update(float delta) { int lengthInterpretation; try { <START> lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); <END> } catch (InterpretationException interpretationException) { lengthInterpretation = 0; Log.d(getClass().getSimpleName(), "Formula interpretation for this specific Brick failed.", interpretationException); } this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation)); } </code><technical_language> Please apply same changes as requested in first review here. </technical_language>
code&comment2code: <code> protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) { long sum = 0; for (String weaselParameterToSum : weaselParametersToSum) { final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters)); if (timing == null) { <START> discardSpan(span); <END> return; } else { sum += timing; } } span.setTag(TIMING_RESOURCE, sum); } </code><technical_language> remove line </technical_language>
code&comment2code: <code> private void close(Path path) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent(); try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced)) { <START> s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p)) <END> .forEach(ThrowingConsumer.unchecked(Files::delete)); } } </code><technical_language> .map(ThrowingFunction.unchecked(p -> p)) unnecessary </technical_language>
code&comment2code: <code> public void hashcodeVerifyEqualsContract() { <START> EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify(); <END> } </code><technical_language> As a general rule: If you're unsure whether or not to suppress a warning, don't! You discovered the principal problem of mutable objects. The easy fix is to use [immutable objects](<LINK_0> whenever possible. MessageReference looks like it could be easily made immutable. So you should definitely do that instead of suppressing the warning. </technical_language>
code&comment2code: <code> public HttpRequest setUri(String uri) { ObjectUtil.checkNotNull(uri, "uri"); <START> this.uri = uri; <END> return this; } </code><technical_language> nit: you can merge both lines above as checkNotNull will return the given argument </technical_language>
code&comment2code: <code> <START> protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { <END> this.creds = creds; } </code><technical_language> Make all Guice constructors package private by removing the method modifier. Just:  java @Inject ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { </technical_language>
code&comment2code: <code> protected int countChildrenOf(IResource checkResource) throws CoreException { if (checkResource.getType() == IResource.FILE) { return 1; } int count = 0; if (checkResource.isAccessible()) { for (IResource <START> resource : <END> ((IContainer) checkResource).members()) { count += countChildrenOf(resource); } } return count; } </code><technical_language> rename 'child' </technical_language>
code&comment2code: <code> public String getAppFolderToMonitor() { <START> if (folder == null) { <END> File f = new File("Applications"); folder = f.getAbsolutePath(); } return folder; } </code><technical_language> If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The startMonitor method below also checks for the return value of this method being null. I guess null would then also be the default. </technical_language>
code&comment2code: <code> private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts) { long input = inputAddress; Arrays.fill(counts, 0); <START> if (inputSize != 0) { <END> for (int i = 0; i < inputSize; i++) { int symbol = UNSAFE.getByte(inputBase, input) & 0xFF; input++; counts[symbol]++; } } } </code><technical_language> I don't think you need this </technical_language>
code&comment2code: <code> public void submit(List<LuceneWork> workList, IndexingMonitor monitor) { Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor ); transferQueue.add( changeset ); wakeUpConsumer(); boolean interrupted = false; while ( ! changeset.isProcessed() ) { LockSupport.park(); if ( Thread.interrupted() ) { <START> interrupted = true; <END> } } if ( interrupted ) { Thread.currentThread().interrupt(); } } </code><technical_language> If it's interrupted you might want to return too, rather than getting stuck in another park. </technical_language>
code&comment2code: <code> public void setHttpService(HttpService httpService) { <START> logger.info("setHttpService called"); <END> this.httpService = httpService; } </code><technical_language> could we directly reduce this to debug level? </technical_language>
code&comment2code: <code> public boolean isInternal() { return getParentNode() .filter(parent -> parent instanceof Name) .map(parent -> (Name) parent) .flatMap(Name::getQualifier) <START> .map(parentNameQualifier -> parentNameQualifier == this) <END> .orElse(false); } </code><technical_language> Oh, yes, Name can only be qualified by another Name. I think it's a safe assumption to make :-) </technical_language>
code&comment2code: <code> private void logStart() { log(3, "Running test " + m_testName + " on " + m_classMap.size() + " " + " classes, " <START> + " included groups:[" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) <END> + "] excluded groups:[" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + "]"); if (getVerbose() >= 3) { for (ITestClass tc : m_classMap.values()) { ((TestClass) tc).dump(); } } } </code><technical_language> valueOf looks more appropriate (like String#valueOf) </technical_language>
code&comment2code: <code> public NutchJob(Configuration conf) throws IOException { <START> super(conf, "NutchJob"); <END> } </code><technical_language> Does this mean that every Job will be named "NutchJob"? </technical_language>
code&comment2code: <code> private void loadMachineUUID() { if <START> (System.getProperty(PROP_UUID) != <END> null) return; String uuid = loadExistingUUID(); if (uuid == null) { uuid = UUID.randomUUID().toString(); saveUUID(uuid); } EnvironmentInfo environment = environmentTracker.getService(); if (environment != null) { environment.setProperty(PROP_UUID, uuid); } else { System.setProperty(PROP_UUID, uuid); } } </code><technical_language> Should use BundleContext.getProperty here, or the EnvonmentInfo service. </technical_language>
code&comment2code: <code> public synchronized boolean retry(ITestResult result) { if (currentTry < maxreruntimes) { <START> ++currentTry; <END> return true; } return false; } </code><technical_language> Maybe we can use AtomicInteger and get rid of synchronized keyword ? On a side note, I noticed that you haven't enabled the parallel attribute on @DataProvider annotation. So you can completely get rid of the need for ensuring Thread safety. </technical_language>
code&comment2code: <code> public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException { <START> return (Statistics<T>)getStatistics(expr.getInt()); <END> } </code><technical_language> It was much nicer when we did not have to explicitly cast everywhere to (Statistics<T>). Please consider re-working this part your changes. </technical_language>
code&comment2code: <code> public ServiceDate getEnd() { <START> return end == UNBOUNDED_END ? null : end; <END> } </code><technical_language> It might even be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging. </technical_language>
code&comment2code: <code> <START> public boolean <END> isLoggedIn() { return token != null && hub != null; } </code><technical_language> no public </technical_language>
code&comment2code: <code> <START> public void setBuildStatus(String buildStatus) { <END> StashBuildState overwrittenBuildState = null; try { overwrittenBuildState = StashBuildState.valueOf(buildStatus); } catch (Exception e) { } this.buildStatus = overwrittenBuildState; } </code><technical_language> The complete method could be stripped down to:  try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } </technical_language>
code&comment2code: <code> public void preInit(FMLPreInitializationEvent evt) { RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID); BCSiliconConfig.preInit(); BCSiliconItems.preInit(); BCSiliconBlocks.preInit(); <START> BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); <END> NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy()); BCSiliconProxy.getProxy().fmlPreInit(); } </code><technical_language> Put this in the config preinit please </technical_language>
code&comment2code: <code> public Hash(HashType type){ this.type = type; try { digest = type.get(); } finally { <START> type.recycle(digest); <END> } } </code><technical_language> Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers! </technical_language>
code&comment2code: <code> private boolean validateExternalVnicProfileMapping() { <START> drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); <END> final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping( getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId()); return validate(validationResult); } </code><technical_language> the mapping is still performed before the validation. it should be after it </technical_language>
code&comment2code: <code> public void serDeTest() { <START> doSerDeTest(Collections.emptyList()); <END> doSerDeTest(Arrays.asList("a", "b", "/signedId/abcdef")); } </code><technical_language> do we need a null case? </technical_language>
code&comment2code: <code> protected void buildVmVideoCards() { createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); createInfo.add(VdsProperties.num_of_monitors, <START> (new Integer(vm.getnum_of_monitors())).toString()); <END> } </code><technical_language> use String.valueOf(vm.getnum_of_monitors()) instead. </technical_language>
code&comment2code: <code> <START> String encode(String segment) { <END> return URL.encodeQueryString(type.replacePathSeparator(segment)); } </code><technical_language> [optional] maybe this method can be static and should be moved to end of the class </technical_language>
code&comment2code: <code> public List<String> getStrongDependencies() { List<String> strongDependencies = new ArrayList<>(); <START> strongDependencies.add(A_U_D_preferredMail); <END> strongDependencies.add(A_U_D_ISMail); strongDependencies.add(A_U_D_publicAliasMails); strongDependencies.add(A_U_D_privateAliasMails); strongDependencies.add(A_U_D_o365EmailAddressesMU); return strongDependencies; } </code><technical_language> This code is duplicate. Moreover, repeated "add" operations are not necessary. You can use something like this:  return Arrays.asList( A_U_D_preferredMail, A_U_D_ISMail, A_U_D_publicAliasMails, A_U_D_privateAliasMails, A_U_D_o365EmailAddressesMU); </technical_language>
code&comment2code: <code> boolean isCacheable() { <START> return true; <END> } </code><technical_language> isCacheable is now true? I guess this was supposed to be false for generic extractors. Or am I wrong? </technical_language>
code&comment2code: <code> <START> protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile, <END> String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf, String keyStore) throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, IOException, CertificateException, KeyException, UnrecoverableKeyException { return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm, toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore); } </code><technical_language> It does not make sense to expose a protected method and mark it as @Deprecated from the beginning. Maybe you should remove the annotation and make it package-private ? </technical_language>
code&comment2code: <code> public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { channel.connect(); fail("should have thrown!"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains("Connection refused")); <END> } } </code><technical_language> It's probably a bad idea to be checking for exception messages in the first place. </technical_language>
code&comment2code: <code> public void notifyParameterChanged(String name) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <START> synchronized (fParameters) { <END> Object oldValue = fParameters.get(name); Object value = getParameter(name); if ((value != null) && !(value.equals(oldValue))) { parameterChanged(name); } } } </code><technical_language> the .contains() should probably be in the synchronized block too </technical_language>
code&comment2code: <code> public void testUnrecognizedSpec() { when(authentication.getAttributes().get(any(String.class))).thenReturn("strong_two_factor"); spec.setAuthenticationMethod("weak_two_factor"); <START> assertTrue(this.spec.isSatisfiedBy(this.assertion)); <END> } </code><technical_language> Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue? </technical_language>
code&comment2code: <code> <START> public static Bundle updateBundleConfig(Connection connection, Bundle bundle) <END> throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"; try (final PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, bundle.config); statement.setLong(2, bundle.bundle); statement.setLong(3, bundle.view); statement.execute(); } return null; } </code><technical_language> Why does this claim to return Bundle? Doesn't really matter though :) </technical_language>
code&comment2code: <code> protected int getOverProvisioningFactor() { <START> return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); <END> } </code><technical_language> Integer.parseInt </technical_language>
code&comment2code: <code> protected void onDestroy() { <START> super.onDestroy(); <END> webView.setDownloadListener(null); } </code><technical_language> Please move super.onDestroy to the end of the method. </technical_language>
code&comment2code: <code> <START> public void closeTest() { <END> HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString()); EmbeddedChannel channel = createEmbeddedChannel(); channel.writeInbound(request); while (channel.readOutbound() != null) { ; } assertFalse("Channel should be closed", channel.isOpen()); } </code><technical_language> Which part in this test calls NettyResponseChannel.close()? </technical_language>
code&comment2code: <code> public String getRuleLogsForVms() { <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("get_rule_logs_for_vms"); final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser(); final String result = cmd.execute(parser); if (result == null) { return parser.getLine(); } return null; } </code><technical_language> Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion. </technical_language>
code&comment2code: <code> private void addReporter(Class<? extends IReporter> r) { <START> m_reporters.put(r, ClassHelper.newInstance(r)); <END> } </code><technical_language> We can avoid the instance creation if the reporter already exist </technical_language>
code&comment2code: <code> <START> public final synchronized void addFunctions(List<? extends SqlFunction> functions) <END> { addFunctions(TEMP_DEFAULT_CATALOG, functions); } </code><technical_language> Don't mark methods as final. </technical_language>
code&comment2code: <code> public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) { <START> if (oldInput != newInput) { <END> if (newInput != null) { ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); } } } </code><technical_language> You can join the ifs. There's a content assist for that, it's awesome. </technical_language>
code&comment2code: <code> <START> boolean isPowerManagementLegal() { <END> return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup() .getcompatibility_version().toString()); } </code><technical_language> please set a modifier - protected seem suitable </technical_language>
code&comment2code: <code> public void info(String message) { <START> System.out.println(message); <END> info.add(message); } </code><technical_language> Should avoid System.out in tests. Instead can you write to log4j </technical_language>
code&comment2code: <code> public static File makeNumericDimFile(File dir, String dimension, ByteOrder order) { <START> return new File(dir, StringUtils.safeFormat("numeric_dim_%s_%s.drd", dimension, order)); <END> } </code><technical_language> Probably should crash if bad format string </technical_language>
code&comment2code: <code> private AuditLogableBase createAuditLog(final VmNic iface) { AuditLogableBase logable = new AuditLogableBase(); <START> logable.setVmId(iface.getVmId()); <END> logable.addCustomValue("MACAddr", iface.getMacAddress()); logable.addCustomValue("IfaceName", iface.getName()); return logable; } </code><technical_language> Is there any longer a need for the VM ID ? </technical_language>
code&comment2code: <code> public boolean equals( VirtualValue other ) { <START> if ( other == null || !(other instanceof MapValue) ) <END> { return false; } MapValue that = (MapValue) other; return size() == that.size() && Arrays.equals( keys, that.keys ) && Arrays.equals( values, that.values ); } </code><technical_language> same here, redundant? </technical_language>
code&comment2code: <code> private void processSingleClusterChanges(ManageNetworkClustersParameters param) { final List<ActionParametersBase> setupNetworksParams = new ArrayList<>( createNetworkClustersToSetupNetworksParametersTransformer().transform( param.getAttachments(), param.getDetachments(), param.getUpdates()) ); HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams); setupNetworksParams.forEach(this::withRootCommandInfo); <START> runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); <END> } </code><technical_language> nit: Formatting </technical_language>
code&comment2code: <code> <START> private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { <END> try { HttpURLConnection.class.getMethod("setFixedLengthStreamingMode", long.class).invoke(connection, length); } catch (Exception e) { throw new IllegalArgumentException("Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations." + " Use chunked encoding or multi-part upload, if possible, or use a different http driver." + " For more information: <LINK_0>"); } } </code><technical_language> [minor] Can be static? </technical_language>
code&comment2code: <code> <START> String getErrorMessage(ClientResponse clientResponse) { <END> String response = clientResponse.getEntity(String.class); try { ApiError error = getJsonParser().readValue(response, ApiError.class); return error.getMessage(); } catch (IOException e) { int statusCode = clientResponse.getStatus(); ClientResponse.Status status = clientResponse.getClientResponseStatus(); String responseText = clientResponse.getEntity(String.class); return "Server returned "+status+"("+statusCode+"); "+responseText; } } </code><technical_language> Method should probably be protected, given writing this for sub-classing. </technical_language>
code&comment2code: <code> public int hashCode() { int bits = 1; bits = 31 * bits + this.type.ordinal(); bits = 31 * bits + getToX(); bits = 31 * bits + getToY(); bits = 31 * bits + getToZ(); bits = 31 * bits + getFromX(); bits = 31 * bits + getFromY(); bits = 31 * bits + getFromZ(); <START> return bits; <END> } </code><technical_language> b ^ (b >> 31) is missed here. </technical_language>
code&comment2code: <code> public static AccountCollection all(Map<String, Object> params) throws AuthenticationException, InvalidRequestException, APIConnectionException, CardException, APIException { <START> return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null); <END> } </code><technical_language> This should call all  java return all(params, (RequestOptions) null); </technical_language>
code&comment2code: <code> public void onSaveClick() { editView.setSaveState(true); WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient(); <START> client.submitDescription(pageTitle, editView.getDescription(), <END> new WikidataDescriptionEditDataClient.Callback() { @Override public void success() { editView.setSaveState(false); L.i("WD description edit successful"); } @Override public void failure(@NonNull Throwable caught) { editView.setSaveState(false); L.e("WD description edit failed: ", caught); } }); } </code><technical_language> Since this is a Fragment with a lifecycle, consider holding a reference to Call<?> and canceling it in onDestroy() if Call<?> is nonnull. </technical_language>
code&comment2code: <code> protected ResourceSet loadResource(IEditorInput editorInput) { <START> final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null); <END> return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack()); } </code><technical_language> why not use the passed in editorInput </technical_language>
code&comment2code: <code> FileReftableStack.CompactionStats getCompactionStats() <START> throws IOException { <END> return reftableStack.getStats(); } </code><technical_language> declared exception isn't thrown </technical_language>
code&comment2code: <code> public OnlineBackup incremental( String targetDirectory ) { outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ), <START> getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); <END> return this; } </code><technical_language> This changes default behaviour, right? Should it? </technical_language>
code&comment2code: <code> private boolean isValidConfiguration() { if (isDiscarding() || isCalleeData()) { return isAsync(); } else { return true; <START> } <END> } </code><technical_language> This could just be return !(isDiscarding() || isCalleeData()) || isAsync(); </technical_language>
code&comment2code: <code> public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException { boolean ret = super.setTrace(trace); if (!ret) { return ret; } ret = fCriticalPathModule.setTrace(trace); <START> fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); <END> return ret; } </code><technical_language> should this be set if ret is false? I don't know. </technical_language>
code&comment2code: <code> public void fillContextMenu(final IMenuManager menu) { super.fillContextMenu(menu); final ISelection selection = getContext().getSelection(); if (selection.isEmpty()) { return; } try { Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor()); } catch (InterruptedException e) { <START> throw new RuntimeException(e); <END> } contextMenuFiller.fillContextMenu(menu, selection); } </code><technical_language> Before, with waitOtherJobs, we "Do nothing" in case of InterruptedException. Why do you change that? Have you test the difference? </technical_language>
code&comment2code: <code> public void dispose() { super.dispose(); getSite().getPage().removePostSelectionListener(this); RegistryFactory.getRegistry().removeListener(this); SaveablesList saveables = <START> (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); <END> if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } currentPart = null; currentSelection = null; pinPropertySheetAction = null; } </code><technical_language> Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList. </technical_language>
code&comment2code: <code> public void setBaseballCard(BaseballCard card) { Locale locale = Locale.getDefault(); brand.setText(card.brand); year.setText(String.format(locale, "%d", card.year)); <START> number.setText(String.format(locale, "%s", card.number)); <END> player.setText(card.playerName); } </code><technical_language> String.format() is no longer necessary here. </technical_language>
code&comment2code: <code> <START> private String capitalize(String word) { <END> return Character.toUpperCase(word.charAt(0)) + word.substring(1); } </code><technical_language> Can be static </technical_language>
code&comment2code: <code> <START> private static boolean isStringParameter( <END> @NonNull Expression expression, @NonNull JavaContext context) { if (expression instanceof StringLiteral) { return true; } else { JavaParser.ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof JavaParser.ResolvedField) { if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) { return true; } } } return false; } </code><technical_language> instead of this, use (at the callsite where you have the JavaContext) TypeDescriptor type = context.getType(expression); return type != null && type.matchesSignature(JavaContext.TYPE_STRING); </technical_language>
code&comment2code: <code> protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) { <START> TopologyDetails td = getNextHighest(); <END> return getScore(availableCpu, availableMemory, availableGenericResources, td); } </code><technical_language> Nit: could we inline this to avoid unnecessary object creation </technical_language>
code&comment2code: <code> public <T extends Action> List<T> getActions(Class<T> type) { <START> List<T> _actions = Util.filter(getPersistedActions(), type); <END> for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) { _actions.addAll(Util.filter(createFor(taf), type)); } return Collections.unmodifiableList(_actions); } </code><technical_language> I think this should be reverted, so it would still take into account additions from pre-TransientActionFactory implementations. </technical_language>
code&comment2code: <code> public void addRepresentation (ImageData srcImageData, int zoom) { if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT); int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom); if (imageSelectorIndex == device.getImageSelector ()) { init(srcImageData); <START> init(); <END> } else { data [imageSelectorIndex] = srcImageData; } } </code><technical_language> ImageData for current image needs to be updated in the array? </technical_language>
code&comment2code: <code> private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType); <START> defaultEnvironment.setup(); <END> return defaultEnvironment; } </code><technical_language> you don't need to do that if you're already calling loadProperties in the public constructor, right? <LINK_0> </technical_language>
code&comment2code: <code> public int hashCode() { <START> return getRepositoryName() != null ? getRepositoryName().hashCode() : <END> System.identityHashCode(this); } </code><technical_language> Style-nit: This is hard to read. Maybe: if (getRepositoryName() != null) return getRepositoryName().hashCode(); return System.identityHashCode(this); </technical_language>
code&comment2code: <code> public List<String> getExtensions() { <START> return extensions == null ? DEFAULT_EXTS : extensions; <END> } </code><technical_language> Can be removed and return only extensions without assigning logic. </technical_language>
code&comment2code: <code> public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria(); addRestrictionOnPatient(radiologyOrderCriteria, patient); <START> List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); <END> return result == null ? new ArrayList<RadiologyOrder>() : result; } </code><technical_language> use final </technical_language>
code&comment2code: <code> public Weld addExtensions(Class<? extends Extension>... extensionClasses) { <START> Object[] constructorParams = new Object[] {}; <END> for (Class<? extends Extension> extensionClass : extensionClasses) { try { Extension extension = SecurityActions.newInstance(extensionClass); addExtension(extension); } catch (Exception ex) { CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex); } } return this; } </code><technical_language> This variable is useless in most cases. I would rather pass new Object[] {} to log method directly. </technical_language>
code&comment2code: <code> public RTTestsParser() { super(Messages._Warnings_RTTests_ParserName(), Messages._Warnings_RTTests_LinkName(), Messages._Warnings_RTTests_TrendName(), <START> CYCLICTEST_WARNING_PATTERN, true); <END> } </code><technical_language> If the last parameter is true then you need to overwrite isLineInteresting. </technical_language>
code&comment2code: <code> private ValidationResult hostExists() { <START> if (getVds() == null) { <END> return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST); } return ValidationResult.VALID; } </code><technical_language> You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID; </technical_language>
code&comment2code: <code> public static ToolTipString fromString(String text) { <START> Objects.requireNonNull(text, "fromString cannot take null"); <END> return new ToolTipString(text, toHtmlString(text)); } </code><technical_language> You can remove all the requireNonNull due to @NNBD. I'm surprised we're allowed to use it, doing an explicit null check would be a compilation error... </technical_language>
code&comment2code: <code> public DataRadioStation getNextById(String id) { <START> if (listStations.size() == 0) <END> return null; for (int i = 0; i < listStations.size() - 1; i++) { if (listStations.get(i).ID.equals(id)) { return listStations.get(i + 1); } } return listStations.get(0); } </code><technical_language> if (listStations.isEmpty()) </technical_language>
code&comment2code: <code> public static void setBiomeArrayMethod(boolean jeidPresent) { try { if (jeidPresent) { biomeArrayMethod = Chunk.class.getMethod("getIntBiomeArray"); } else <START> biomeArrayMethod = Chunk.class.getMethod("getBiomeArray"); <END> } catch (NoSuchMethodException e) { throw new RuntimeException(e); } } </code><technical_language> Please add the {} for the one-liner </technical_language>
code&comment2code: <code> public String getDescription() { return "Transform files representing a structured table under an Alluxio directory." + "\n\n" + "Files are coalesced and converted to parquet format." + "\n\n" + "Definition is in format like 'write(hive).option(hive.num.files, 100)'," + "currently, the only modification you can do to the example definition is " <START> + "the number of files in the option." <END> } </code><technical_language> I think since this will change in future release, it's better to let it be here so it's easier to update. </technical_language>
code&comment2code: <code> <START> public static void validateNonNegative(int[] data, String paramName){ <END> boolean nonnegative = true; for(int value : data){ if(value < 0) { nonnegative = false; } } Preconditions.checkArgument(nonnegative, "Values for %s must be >= 0, got: %s", paramName, data); } </code><technical_language> Handling of nulls? You have some in the later methods, but not here... If null is acceptable, we should return null here. If not, let's either add a lombok @NonNull or a Preconditions.checkNotNull(. At present, nulls will give a non-useful NPE. </technical_language>
code&comment2code: <code> <START> public SetContentTypeFilter() { <END> try { mimetypeToExtensionMap = new Properties(); mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream( "mimetypeToExtension.txt"))); contentTypeProperties = new Properties(); contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream( "toContentType.properties"))); } catch (IOException e) { log.error("Failed to load mimetype mappings", e); } } </code><technical_language> Looking at this (and i realize this is my own crappy code), its really a configuration error for the files to fail to load, and we really don't want to be eating that and just putting something in the log. Could you either remove the try block and make this constructor throw the IOException, or rethrow an exception with a little extra context? Up to you which you prefer. </technical_language>
code&comment2code: <code> private SwiftApi api(String authUrl, Properties overrides) throws IOException { if (overrides == null){ overrides = new Properties(); <START> } <END> overrides.setProperty(CREDENTIAL_TYPE, "tempAuthCredentials"); return ContextBuilder.newBuilder(new SwiftApiMetadata()) .credentials("user", "password") .endpoint(authUrl) .overrides(overrides) .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor()))) .buildApi(SwiftApi.class); } </code><technical_language> Instead of passing null, remove this check and call this method with a new Properties object. </technical_language>
code&comment2code: <code> public void setAcceptableValues(Collection<K> values) { buttons.clear(); panels.clear(); wrapperPanel.clear(); <START> for (final K value : values) { <END> addValue(value); } updateButtons(); } </code><technical_language> add null check </technical_language>
code&comment2code: <code> public Bucket getOrCreateBucket(String bucketName) { try { Bucket bucket = storage.get(bucketName); if (bucket == null) { log.debug(String.format("Creating a new bucket %s", bucketName)); return storage.create(BucketInfo.of(bucketName)); } return bucket; } catch (StorageException e) { <START> throw new NuxeoException(e); <END> } } </code><technical_language> StorageException is a runtime exception, no need to catch and rethrow it (several occurrences). </technical_language>
code&comment2code: <code> private void onFragmentLoaded() { if (searchAdapter == null) { searchAdapter = new SearchlistAdapter(getActivity(), itemAccess); setListAdapter(searchAdapter); } searchAdapter.notifyDataSetChanged(); setListShown(true); String query = getArguments().getString(ARG_QUERY); <START> setEmptyText(getString(R.string.no_results_for_query) + " \"" + query + "\""); <END> } </code><technical_language> You need to keep in mind that the sentence construction in other languages could be different, so the query string doesn't always show at the end. You should use %1$s in your string on values/strings.xml and pass the query term as an extra argument to getString() </technical_language>
code&comment2code: <code> private Iterable<Ref> getSortedRefs() throws Exception { List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL); <START> if (all instanceof RefMap <END> || (all instanceof SortedMap && ((SortedMap) all).comparator() == null)) { return all; } return RefComparator.sort(all); } </code><technical_language> Thanks. Marking resolved. </technical_language>
code&comment2code: <code> private static void convertAAAProfilesResult(AsyncQuery aQuery) { aQuery.converterCallback = new IAsyncConverter() { @Override public Object Convert(Object source, AsyncQuery _asyncQuery) { List<String> results = new ArrayList<String>(); <START> for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) <END> : new ArrayList<ProfileEntry>()) { results.add(profileEntry.getProfile()); } return results; } }; } </code><technical_language> I don't understand why you need to create a new ArrayList for a collection that is coming from a query - it is necessarily not being used by anyone else. Also, why cast what's coming from the backend to an ArrayList? This means you're committing to a specific implementation. I think a cast to Collection is more appropriate. If it's important for you to have the end result in specifically an ArrayList (and not any other kind of collection), then I would create a new ArrayList, but still cast the result from the backend to Collection. </technical_language>
code&comment2code: <code> <START> public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, <END> final CellEditorControlsView.Presenter cellEditorControls, final KindPopoverView.Presenter editor, final Optional<String> editorTitle, final FunctionGrid gridWidget) { super(cellEditorControls, editor, editorTitle); this.functionSupplier = functionSupplier; this.gridWidget = gridWidget; } </code><technical_language> Since the class has _package_ protected access the constructor can probably have _package_ protection too? </technical_language>
code&comment2code: <code> public List<ProxiedPlayer> matchPlayer(String partialName) { List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>(); for (ProxiedPlayer iPlayer : this.getPlayers()) { String iterPlayerName = iPlayer.getName(); if (partialName.equalsIgnoreCase(iterPlayerName)) { matched.add(iPlayer); break; } <START> if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) { <END> matched.add(iPlayer); } } return matched; } </code><technical_language> Wouldn't starts with make more sense? </technical_language>
code&comment2code: <code> private int zigzagDecode(int input) { <START> return (input >> 1) ^ (-(input & 1)); <END> } </code><technical_language> I notice in the unzigzag method below, you use the unsigned right shift operator (>>>), but here you're using the signed one (>>). Is that intentional? </technical_language>
code&comment2code: <code> <START> public void testEqualsCondition() { doTest(GoStringIndexIsByteQuickFix.NAME); } <END> </code><technical_language> Please create methoddoTest() { doTest(GoStringIndexIsByteQuickFix.NAME); } and maybe same method doTestNoFix() </technical_language>
code&comment2code: <code> public void testRedrawAfterDispose() { LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn(); CompositeRuler ruler= new CompositeRuler(); ruler.addDecorator(0, lineNumberRulerColumn); SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE); lineNumberRulerColumn.getControl().setSize(10, 10); sourceViewer.getTextWidget().dispose(); try { lineNumberRulerColumn.redraw(); } <START> catch (Exception <END> notExpected) { notExpected.printStackTrace(); fail(); } } </code><technical_language> why do we need try/catch here? It should not fail, and if it fails, junit will take care about the stack etc </technical_language>
code&comment2code: <code> public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) { if (!_canBridgeFirewall) { return false; } <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("default_network_rules_systemvm"); cmd.add("--vmname", vmName); cmd.add("--localbrname", _linkLocalBridgeName); final String result = cmd.execute(); if (result != null) { return false; } return true; } </code><technical_language> Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion. </technical_language>
code&comment2code: <code> public void testQueryCumulativeTable() { computeActual("SELECT * FROM \"*:*\""); computeActual("SELECT * FROM \"java.util.logging:*\""); <START> assertTrue(computeActual("SELECT * FROM \"java.lang:*\"").getRowCount() > 0); <END> assertTrue(computeActual("SELECT * FROM \"jAVA.LANg:*\"").getRowCount() > 0); } </code><technical_language> shouldn't it be > 1 </technical_language>
code&comment2code: <code> public RequestLogger get() { LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC); <START> log.info(new Exception("Stack trace"), "Creating %s at", logger); <END> return logger; } </code><technical_language> should these be debug level? </technical_language>
code&comment2code: <code> private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) { String accessRecord = leak.toString(); if (StringUtil.isNullOrEmpty(accessRecord)) { return e; } <START> return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord); <END> } </code><technical_language> shouldn't we wrap the original e ? </technical_language>
code&comment2code: <code> public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); <END> } </code><technical_language> The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments </technical_language>
code&comment2code: <code> public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER); disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString()); retentionManager = Framework.getService(RetentionManager.class); <START> ruleId = (String) command.getParam(PARAM_RULE_ID); <END> } </code><technical_language> No need to cast to String, here getParam is a generic method public <T> T getParam(String key) </technical_language>
code&comment2code: <code> public boolean remove(Connection connection) { boolean removed = connectionPool.remove(connection); if (getHttpExchanges().isEmpty()) { tryRemoveIdleDestination(); } else { if (removed) <START> process(true); <END> } return connectionPool.remove(connection); } </code><technical_language> should this check that the queue is not 0? Why acquire a connection if there are no waiting exchanges? </technical_language>
code&comment2code: <code> public boolean getRewriteBatchedStatements() { final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS); <START> return isRewrite == null ? null : Boolean.valueOf(isRewrite); <END> } </code><technical_language> return null ? I think you meant 'false', did not you? </technical_language>
code&comment2code: <code> public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon)); scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); <START> scheduler.setRemoveOnCancelPolicy(true); <END> return scheduler; } </code><technical_language> I am little wary about this. coz, all our existing schedulers are using this and setting this might cause them to be removed immediately. Even though ideally we want to be in that position, when rolling this out, don't want to have any unexpected behaviors. </technical_language>
code&comment2code: <code> public boolean setValue(T newValue) { if (!validator.validate(newValue)) { <START> LOGGER.warn("The passed value {} is invalid.", newValue); <END> return false; } PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue); this.value = newValue; dispatchChangedEvent(event); return true; } </code><technical_language> Ah, that's what you meant. =) No, this isn't good: it's too generic, it wouldn't help you debug a failure. The validator itself has to log a warning and then return false, so that the warning can be very specific on what went wrong, i.e. the new value being beyond the maximum value allowed. </technical_language>
code&comment2code: <code> public void onMessage(MessageHolderWithTokens message) { try { <START> logger.debug("receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"); <END> dequeueEvent.fire(message); } catch (DispatchInitiationException e) { throw e; } catch (Exception e) { logger.error("NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered", e); } } </code><technical_language> Do we really want to move this from trace to debug? </technical_language>
code&comment2code: <code> private Collection<Key> getRegisteredKeys() { List<Key> result = new ArrayList<Key>(); <START> for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) { result.add(i.next()); } return result; <END> } </code><technical_language> why not: return result.addAll(cacheMap.keySet()); </technical_language>
code&comment2code: <code> <START> public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { <END> name = metricName; type = metricType; value = initialValue; metricManager = manager; } </code><technical_language> I would make this constructor protected because you cannot directly instantiate abstract classes. See the answers to <LINK_0> for a discussion. </technical_language>
code&comment2code: <code> public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() { Allergy allergy = allergy(); <START> allergy.hasSameValues(allergy()); <END> } </code><technical_language> Shouldn't this line be something like AssertTrue(allergy.hasSameValues(allergy())); ? </technical_language>
code&comment2code: <code> private static String readMapping() throws IOException, ParseException { JSONParser parser = new JSONParser(); ClassLoader classloader = Thread.currentThread().getContextClassLoader(); <START> InputStream inputStream = classloader.getResourceAsStream("mapping.json"); <END> String mapping = IOUtils.toString(inputStream, "UTF-8"); Object object = parser.parse(mapping); JSONObject jsonObject = (JSONObject) object; return jsonObject.toJSONString(); } </code><technical_language> You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here. </technical_language>
code&comment2code: <code> public synchronized void commit() throws CommitException { SyncCommitObserver sco = null; try { sco = new SyncCommitObserver(); commitAsync(sco); sco.waitForCommit(); } finally { updates.clear(); weakNotification = null; <START> observedColumns.clear(); <END> columnsRead.clear(); } } </code><technical_language> @mjwall I found the bug. Its my fault, I suggested clearing observedColumns and that is a bad thing to do. observedColumns is shared between transactions. It should be an immutable set, I'll open an issue for that. </technical_language>
code&comment2code: <code> public static boolean hasPictureId(byte[] buf, int off, int len) { if (!isValid(buf, off)) return false; if ((buf[off] & X_BIT) == 0 || (buf[off+1] & I_BIT) == 0) <START> return false; <END> return true; } </code><technical_language> I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)" </technical_language>
code&comment2code: <code> public void setEnabled(boolean enabled) { this.active = enabled; <START> System.out.println("active state change: " + active); <END> updateButtonState(); } </code><technical_language> remove the println </technical_language>
code&comment2code: <code> <START> default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { <END> throw new UnsupportedOperationException("Method is not implemented"); } </code><technical_language> Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations. </technical_language>
code&comment2code: <code> private void handleEndActionJobAndStep() { if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) { <START> if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) { <END> startFinalizingStep(); } } } </code><technical_language> the inner 'if' isn't needed - the conditions can be added to the outer 'if' </technical_language>
code&comment2code: <code> private boolean waitForScanState(ScanStates state) { try { <START> while (!getScanState().equals(state)) { <END> scanState.wait(); } return true; } catch (InterruptedException e) { tsLogger.logger.warn("problem waiting for scanLock whilst in state " + state.name(), e); return false; } } </code><technical_language> why did you change the do ... while into a while do loop. The caller already knows the scan state is not equal to state and since this is a private method it is safe to assume that the caller has already checked (under the lock) that he has to wait for a state change. </technical_language>
code&comment2code: <code> private void maybeScheduleCheckpoint() { switch (state()) { <START> case RESTORING: <END> this.checkpoint = checkpointableOffsets(); break; case RUNNING: if (!eosEnabled) { this.checkpoint = checkpointableOffsets(); } break; case SUSPENDED: this.checkpoint = checkpointableOffsets(); break; case CREATED: case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while scheduling checkpoint for active task " + id); default: throw new IllegalStateException("Unknown state " + state() + " while scheduling checkpoint for active task " + id); } } </code><technical_language> Could we merge RESTORING and SUSPENDED? </technical_language>
code&comment2code: <code> protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); <END> getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); } </code><technical_language> Why do you cast to HostProviderProxy? </technical_language>
code&comment2code: <code> public void t1() { <START> testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); <END> } </code><technical_language> We could have leveraged InvokedMethodListener for this. See [here](<LINK_0> </technical_language>
code&comment2code: <code> public void testValidateDataStreamsNoConflicts() { Metadata metadata = createIndices(5, 10, "foo-datastream").metadata; try { <START> validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); <END> } catch (Exception e) { fail("did not expect exception when validating a system without indices that would conflict with future backing indices: " + e.getMessage()); } } </code><technical_language> Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier? That being said, this is just preference, so feel free to ignore :) </technical_language>
code&comment2code: <code> public ShaderProvider getPassShaderProvider (int n) { <START> if (n >= passShaderProviders.length) <END> throw new GdxRuntimeException("ShaderProvider " + n + " doesn't exist in " + getClass().getName()); return passShaderProviders[n]; } </code><technical_language> I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). <LINK_0> </technical_language>
code&comment2code: <code> public void install(ITextViewer textViewer) { for (IReconciler iReconciler : fReconcilers) { <START> if(iReconciler != null) { <END> iReconciler.install(textViewer); } } } </code><technical_language> It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here. </technical_language>
code&comment2code: <code> public PlanItem(String id, String definitionRef) { <START> super(); <END> this.id = id; this.definitionRef = definitionRef; } </code><technical_language> AFAIK this is redundant. </technical_language>
code&comment2code: <code> public int hashCode() { <START> return name.hashCode(); <END> } </code><technical_language> Looking on QName class, maybe we should use return ~~name.hashCode(). </technical_language>
code&comment2code: <code> protected boolean copyObject(String src, String dst) { try { <START> LOG.info("Copying {} to {}", src, dst); <END> mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst); return true; } catch (CosClientException e) { LOG.error("Failed to rename file {} to {}", src, dst, e); return false; } } </code><technical_language> LOG.debug please to avoid overhead on operations. </technical_language>
code&comment2code: <code> public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> false); <END> } </code><technical_language> Since the logic switch, this should be true (former behavior). </technical_language>
code&comment2code: <code> public DelegatingResourceDescription getCreatableProperties() { DelegatingResourceDescription description = super.getCreatableProperties(); <START> description.addProperty("name"); <END> description.addProperty("location"); description.addProperty("description"); return description; } </code><technical_language> Aren't the name and description properties already added by the super class? </technical_language>
code&comment2code: <code> private JsonParser getParser(String data) throws IOException { <START> Character firstChar = data.charAt(0); <END> if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } } </code><technical_language> Character should be "char" <LINK_0> This is returning a char (primitive type) and that is why the "=="test works I think, if it was returning Character (object wrapper for char) we would need to use ".equals" </technical_language>
code&comment2code: <code> public void testGenerateDroolsTestOption() { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig(); assertThat(config.isGenerateDroolsTestOnError()).isNull(); config.setGenerateDroolsTestOnError(true); <START> assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue(); <END> config.setGenerateDroolsTestOnError(Boolean.FALSE); assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse(); config.setGenerateDroolsTestOnError(null); assertThat(config.isGenerateDroolsTestOnError()).isNull(); } </code><technical_language> Redundant cast. </technical_language>
code&comment2code: <code> private RawText getRawText(ObjectId id, Repository repo) throws IOException { <START> if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {}); <END> return new RawText(repo.openBlob(id).getCachedBytes()); } </code><technical_language> Style-nit: Use curly brackets and wrap the return to next line. </technical_language>
code&comment2code: <code> private static String getUserAgentSuffix() { String suffix = ";" + USER_AGENT_SUFFIX; <START> return suffix; <END> } </code><technical_language> We can make this inline. suggestion return ";" + USER_AGENT_SUFFIX; </technical_language>
code&comment2code: <code> public Builder setDataSize(Estimate dataSize) { <START> this.dataSize = requireNonNull(dataSize, "dataSize can not be null"); <END> return this; } </code><technical_language> you don't validate in other builders method (and you don't have to) </technical_language>
code&comment2code: <code> public boolean isExpired(Date invocationDate) { if (getExpires() != null) { Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate; <START> return getExpires().before(currentInvocationDate); <END> } return false; } </code><technical_language> Statement can be rewritten inline. </technical_language>
code&comment2code: <code> public void stop() { if (isRunning()) { process.destroy(); try { if (stdout !=null) { <START> stdout.close(); <END> } if (stdin !=null) { stdin.close(); } } catch (IOException e) { throw new RuntimeException(e.getMessage(),e); } finally { running.set(false); } } } </code><technical_language> Is this really needed? </technical_language>
code&comment2code: <code> public boolean equals(Object object) { <START> if (object == null || object.getClass() != getClass()) { <END> return false; } if (object == this) { return true; } MacroId rhs = (MacroId) object; return new EqualsBuilder() .append(getId(), rhs.getId()) .append(getSyntax(), rhs.getSyntax()) .isEquals(); } </code><technical_language> Actually since MacroId is not really supposed to be extended you could replace this with a if (!(object instanceof MacroId)). Can't be null if it's an instance of MacroId. Also I would put it after the if (object == this) test instead of before. </technical_language>
code&comment2code: <code> <START> Map<String, Object> getExtraInformation() { <END> return extraInformation; } </code><technical_language> this is public API, we can't lower the visibility without deprecating first </technical_language>
code&comment2code: <code> public int hashCode() { <START> return Objects.hash(pointer, ownerName, owner, readers, writers); <END> } </code><technical_language> neat. </technical_language>
code&comment2code: <code> private String getFriendsPath( SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) { ImmutableSortedSet<String> absoluteFriendPaths = ImmutableSortedSet.copyOf( friendPathsSourcePaths .stream() .map(path -> sourcePathResolver.getAbsolutePath(path).toString()) .collect(Collectors.toSet())); return "-Xfriend-paths=" <START> + absoluteFriendPaths.stream().reduce("", (path1, path2) -> path1 + "," + path2); <END> } </code><technical_language> What about the same when the list is empty, it still adds -Xfriend-paths= option? </technical_language>
code&comment2code: <code> public Target(String targetUriAsString) { <START> super(); <END> Assert.hasText(targetUriAsString, "The provided targetUriAsString must neither be null nor empty."); this.targetUri = URI.create(targetUriAsString); } </code><technical_language> Do we need super(), if the class is not inheriting from a super class? </technical_language>
code&comment2code: <code> public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) { super(definition); final String propertyName = definition.getTestValue(); String regexExpression = PropertiesManager.getProperty (propertyName, ""); if (StringUtils.isBlank(regexExpression)) { logger.error("Unable to find property name {} in portal.properties or has empty value." + " PAGS PropertyInvertedRegexTester will always return true for attribute {}", propertyName, definition.getAttributeName()); } setPattern(regexExpression); <START> } <END> </code><technical_language> Minor, but rather than duplicating lines 44 - 51, perhaps put them in a private method invoked by both constructors, or have this constructor invoke the other. </technical_language>
code&comment2code: <code> public final boolean doesProvideNewPage() { if (provision == null) { <START> throw new IllegalStateException("Page instance not yet resolved"); <END> } return getProvision().doesProvideNewPage(); } </code><technical_language> Looking bad indeed, I fixed later during my work on the branch: <LINK_0> The three states looks overcomplicated. There's no place in Wicket core needing to test such flag for the value "OLD". </technical_language>
code&comment2code: <code> private Handler getHandler() { <START> if (mHandler == null) { <END> mHandler = new Handler(mContext.getMainLooper()); } return mHandler; } </code><technical_language> This doesn't look thread-safe. </technical_language>
code&comment2code: <code> @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); <START> setLoggingEnabled(debugging); <END> } </code><technical_language> Let's remove this behavior. setDebugging will only affect the indicators. </technical_language>
code&comment2code: <code> public List<ServerTemplate> load() { synchronized (store) { return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList()); <START> } <END> } </code><technical_language> I guess we no longer need store to be of ConcurrentHashMap implementation if we are fully locking it. </technical_language>
code&comment2code: <code> public String getLearnerMaster() { QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster(); InetSocketAddress address = learnerMaster.addr.getReachableOrOne(); <START> if (learnerMaster == null || address == null) { <END> return "Unknown"; } return address.getAddress().getHostAddress() + ":" + address.getPort(); } </code><technical_language> if learnerMaster is null here then you'll get a NPE on the learnerMaster.addr.getReachableOrOne() above. </technical_language>
code&comment2code: <code> default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) { ArgumentUtil.requireNotNull(func, "function"); final Task<Task<R>> nested = map("map: " + desc, func); nested.getShallowTraceBuilder().setSystemHidden(true); <START> nested.getShallowTraceBuilder().setTaskType("nestedTask"); <END> return flatten(desc, nested); } </code><technical_language> I think we should drop redundant "Task" suffix from the task types e.g.: "nestedTask" -> "nested" "withSideEffectTask" -> "withSideEffect" "timeoutTask" -> "timeout" "withTimeoutTask" -> "withTimeout" </technical_language>
code&comment2code: <code> protected List<String> findStringsInFileCommon(String regexp, boolean stopOnFirst, int searchLimit, File fileToSearch) <START> throws Exception { <END> return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO); } </code><technical_language> As stated above, I don't see the need for this method to throw an exception. </technical_language>
code&comment2code: <code> public void notifyAboutStartProcess(String id) { Long processInstanceId = Long.parseLong(id); newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId, deploymentId, processInstanceId, processDefId, processName, <START> 1)); <END> final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue()); notificationEvent.fire(new NotificationEvent(message, NotificationEvent.NotificationType.SUCCESS)); close(); } </code><technical_language> can you pass null in here for the status, I recently refactored similar code, and status should not be part of the event. </technical_language>
code&comment2code: <code> protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { <END> maybeMove(oldChildReference, newChildReference); } } }); } </code><technical_language> I don't understand what this check is doing here. maybeMove is already taking check of checking rights. </technical_language>
code&comment2code: <code> <START> public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { <END> log.info("Process event {}", event.getType()); switch (event.type) { case DISCOVER_INIT_TOPOLOGY: startDiscovery(); break; case ACQUIRE_LOCK: processLockAcquire(); break; case RELEASE_LOCK: processLockRelease(); break; case DISCOVERED_TOPOLOGY: processTopologyChangeNotification(event); break; case UPGRADE: processUpgrade(event); break; default: log.error("Invalid event type {}", event.type); } } </code><technical_language> same, we can delete LogReplicationDiscoveryServiceException.java file now. </technical_language>
code&comment2code: <code> public void deleteError(final ProgramError error) { synchronized (errors) { errors.remove(error); <START> eventBus.publish(new ProgramErrorDeletedEvent(error)); <END> } } </code><technical_language> Don't really like firing events when holding locks on things... If anything that receives a ProgramErrorDeletedEvent tries to access the ErrorManager (which is not altogether unreasonable!) you'll end up with a nasty deadlock. Could we just make errors a ConcurrentSkipListSet and drop all the synchronization? </technical_language>
code&comment2code: <code> public LamiTableContentProvider() { fCurrentEntries = <START> checkNotNull(Collections.emptyList()); <END> } </code><technical_language> Can remove checkNotNull, we have external @NonNull annotation on Collections.emptyList(). </technical_language>
code&comment2code: <code> public ArticlePageObject clickGetInfoLink() { switchToIFrame(); waitForElementByElement(getInfoLink); getInfoLink.click(); switchOutOfIFrame(); <START> return new ArticlePageObject(driver); <END> } </code><technical_language> in case of switching, in my opinion it's better to us etry/finnally like that:  switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); }  it's clearer in reading </technical_language>
code&comment2code: <code> @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setAdviceChain(new CacheInterceptor()); assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain()) .hasSize(2) <START> .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice); <END> } </code><technical_language> would this work? (also removing the import) suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice); </technical_language>
code&comment2code: <code> private static List<IResource> getReadonlyFiles(IResource[] resources) { <START> List<IResource> readOnlyFiles= new ArrayList<IResource>(); <END> for (int i= 0; i < resources.length; i++) { IResource resource= resources[i]; ResourceAttributes resourceAttributes= resource.getResourceAttributes(); if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly()) readOnlyFiles.add(resource); } return readOnlyFiles; } </code><technical_language> Use ArrayList<> </technical_language>
code&comment2code: <code> void clean(K key) { List<V> data = getDataMap().get(key); if (data != null) { <START> data.clear(); <END> } getDataMap().remove(key); } </code><technical_language> I think this is not necessary as the GC will remove it as soon as there is no more reference on the Object </technical_language>
code&comment2code: <code> public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) { if (!isMemory(memoryDevice)) { <START> throw new RuntimeException("Memory device expected but device " + memoryDevice + " obtained."); <END> } return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent(); } </code><technical_language> IllegalArgumentException sounds better here. </technical_language>
code&comment2code: <code> public boolean connectorExists(String id) { try { List<ConnectorConfiguration> list = configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id)); if (list.isEmpty()) { return false; } return true; } catch (PersistenceException e) { <START> throw new RuntimeException(e); <END> } } </code><technical_language> Would be nice if you add here an exception text. Something like "unable to load the list of connector configurations" </technical_language>
code&comment2code: <code> public void testUpdateStmtBuilder() { printStatement("update foo set \"column['looks_like_nested']\"=1"); printStatement("update foo set foo.a='b'"); printStatement("update bar.foo set bar.foo.t=3"); printStatement("update foo set col['x'] = 3"); printStatement("update foo set col['x'] = 3 where foo['x'] = 2"); printStatement("update schemah.foo set foo.a='b', foo.b=foo.a"); printStatement("update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"); printStatement("update foo set foo='a' returning id"); printStatement("update foo set foo='a' where x=false returning id"); printStatement("update foo set foo='a' returning id AS foo"); printStatement("update foo set foo='a' returning id + 1 AS foo, id -1 as bar"); <START> } <END> </code><technical_language> can we maybe have separate test cases for the returning clause? </technical_language>
code&comment2code: <code> public void setSetPath(String path) { <START> setPath.set(requireNonNull(path, "path is null")); <END> } </code><technical_language> nit: I know that in other parts of this class we put the requireNonNull calls inside another method call, but let's not do it here for the sake of slightly better readability:  requireNonNull(path, "path is null"); setPath.set(path); </technical_language>
code&comment2code: <code> public EnvVars getEnvironment() throws IOException, InterruptedException { if (cachedEnvironment != null) { <START> return cachedEnvironment; <END> } cachedEnvironment = EnvVars.getRemote(getChannel()); return cachedEnvironment; } </code><technical_language> Something like this:  public EnvVars getEnvironment() throws IOException, InterruptedException { EnvVars cachedEnvironment = this.cachedEnvironment; if (cachedEnvironment != null) { return cachedEnvironment; cachedEnvironment = EnvVars.getRemote(getChannel()); // all non-null values should be equivalent so in a race it doesn't matter who wins this.cachedEnvironment = cachedEnvironment; return cachedEnvironment; } </technical_language>
code&comment2code: <code> public int getMaxCapacity() { <START> readLock.lock(); <END> try { return maxCapacity; } finally { readLock.unlock(); } } </code><technical_language> why should add lock here? </technical_language>
code&comment2code: <code> public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() { List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> } </code><technical_language> Can you use isEmpty()? </technical_language>
code&comment2code: <code> protected Control createPageControls(Composite parent) { setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer); <START> Label label = new Label(parent, SWT.CENTER); <END> label.setText( NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName())); return parent; } </code><technical_language> no need to center it, just give it SWT.NONE </technical_language>
code&comment2code: <code> public List<PermissionSubject> getPermissionCheckSubjects() { List<PermissionSubject> list = new ArrayList<PermissionSubject>(); Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue(); list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup())); QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId()); return list; <START> } <END> </code><technical_language> I think you need to call super otherwise you loose the permissions that you need to check by default. </technical_language>
code&comment2code: <code> public void onInit( String clientName, Map<String,Object> credentials ) throws IOException { <START> packer.packStructHeader( 1, INIT.signature() ); <END> packer.pack( clientName ); packer.pack( ValueUtils.asMapValue( credentials ) ); onMessageComplete.onMessageComplete(); } </code><technical_language> This is actually wrong but it is an error that has propagated to all drivers. The init struct has size 2 and not size 1. We are saved by ignoring the struct size when we read the init message. </technical_language>
code&comment2code: <code> <START> public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, <END> NovaSecurityGroupExtension novaSecurityGroupExtension) { this.neutronSecurityGroupExtension = neutronSecurityGroupExtension; this.novaSecurityGroupExtension = novaSecurityGroupExtension; } </code><technical_language> Remove the public modifier </technical_language>
code&comment2code: <code> private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionNotEqualNullWithOr(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionComparedWithFunction(expression, kind); <START> if (comparedExpression == null) { <END> return null; } } } return comparedExpression; } </code><technical_language> @vilchik-elena Do we need this block? </technical_language>
code&comment2code: <code> private void scheduleRefresh(Duration delay) { if (executor.isShutdown()) { return; } <START> executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); <END> } </code><technical_language> Is the (Runnable) needed? </technical_language>
code&comment2code: <code> public static void main(String[] args) { <START> LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of("reorder_joins", "false")); <END> new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out)); } </code><technical_language> Technically, you should queryRunner.close() (or t-w-r). This would ensure proper cleanup of any temp files (or whatevers) it might have created </technical_language>
code&comment2code: <code> <START> public void beforeStartingVertx(VertxOptions options) { <END> } </code><technical_language> Shouldn't they be protected not public? </technical_language>
code&comment2code: <code> public Builder body(String json) { checkNotNull(json, "body required"); checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES), <START> "json size must be <= %s bytes", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); <END> this.body = new JsonBall(json).toString(); return self(); } </code><technical_language> Ah, so I guess that lack of a Guice context here (and above) is the reason for the system properties? How do we solve that elsewhere in jclouds? Would we inject some kind of factory object via Guice? </technical_language>
code&comment2code: <code> private String getTokenFromHeader(HttpServletRequest request) { String token = null; String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION); if (headerValue != null && headerValue.startsWith(BEARER)) { token = <START> headerValue.substring("Bearer".length()).trim(); <END> } return token; } </code><technical_language> s/"Bearer"/BEARER </technical_language>
code&comment2code: <code> <START> public static CDIProvider getCDIProvider() { <END> if (configuredProvider != null) { return configuredProvider; } else { if (discoveredProviders == null) { synchronized (lock) { if (discoveredProviders == null) { findAllProviders(); } } } configuredProvider = discoveredProviders.stream() .filter(c -> c.getCDI() != null) .findAny().orElseThrow(() -> new IllegalStateException("Unable to access CDI")); return configuredProvider; } } </code><technical_language> This method should not be public or what's the point? </technical_language>
code&comment2code: <code> <START> public void testIsDrawable_Stage() throws Exception { <END> testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true); } </code><technical_language> The Exception is never thrown. </technical_language>
code&comment2code: <code> public static boolean customImageExists(String storage, String key) { final AzureBlobClient azureBlob = ContextBuilder.newBuilder("azureblob") .credentials(storage, key) .buildApi(AzureBlobClient.class); try { return azureBlob.containerExists("system"); } catch (Exception e) { e.printStackTrace(); return false; <START> } <END> finally { Closeables2.closeQuietly(azureBlob); } } </code><technical_language> The container exists method should already return false [if the container exists call returns a 404](<LINK_0> Worth removing the catch, as it might be caused by other errors that should be taken into acount? </technical_language>
code&comment2code: <code> public void enter() { mUseEap = (IkeSessionOptions.IKE_AUTH_METHOD_EAP == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod); <START> super.enter(); <END> } </code><technical_language> Nit: By convention, this is almost always the first thing called, unless there's a explicit reason why it needs to happen after (which is usually a code smell) </technical_language>
code&comment2code: <code> public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && DeterminismEvaluator.isDeterministic(expression) && <START> !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && <END> !isDynamicFilter(expression)) { ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; } </code><technical_language> you can static import these functions. </technical_language>
code&comment2code: <code> public void startMasters() throws Exception { mMaster = LocalAlluxioMaster.create(mWorkDirectory, true); mMaster.start(); <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END> } </code><technical_language> why is this needed? </technical_language>
code&comment2code: <code> public Proxy getProxy() { <START> if (mProxyHost == null) return null; <END> Proxy.Type type = null; switch (mProxyType) { case TYPE_HTTP: type = Proxy.Type.HTTP; break; case TYPE_SOCKS: type = Proxy.Type.SOCKS; break; } return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort)); } </code><technical_language> mind the code style </technical_language>
code&comment2code: <code> public HttpRequest setMethod(HttpMethod method) { ObjectUtil.checkNotNull(method, "method"); <START> this.method = method; <END> return this; } </code><technical_language> nit: you can merge both lines above as checkNotNull will return the given argument </technical_language>
code&comment2code: <code> public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) { if (!FeatureSupported.deviceCustomProperties(version)) { return Collections.emptySet(); } <START> Set<VmDeviceGeneralType> types; <END> EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version); if (map.isEmpty()) { types = Collections.emptySet(); } else { types = Collections.unmodifiableSet(map.keySet()); } return types; } </code><technical_language> a matter of taste - types can be avoided for the sake of return statements from the if-else block. </technical_language>
code&comment2code: <code> public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException { super(reference, bot); GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() { @Override public GraphicalViewer run() { final IEditorPart editor = partReference.getEditor(true); <START> return editor.getAdapter(GraphicalViewer.class); <END> } }); ReflectionHelper.setFieldValueWithoutException(this, "viewer", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass()); } </code><technical_language> generic has come with mars. Consequently that code won't compile against previous platform </technical_language>
code&comment2code: <code> public CreateAllSnapshotsFromVmParameters() { needsLocking = true; <START> snapshotType = SnapshotType.REGULAR; <END> saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); } </code><technical_language> I'd prefer that we handled it (the snapshot type) in a separate change. </technical_language>
code&comment2code: <code> public SchedulerTask<?> createTaskInstance( String taskType ) throws IllegalArgumentException <START> { <END> try { return lookupTask( taskType ); } catch ( ComponentLookupException e ) { this.logger.debug( "Failed to load Schedule Task: " + taskType, e ); throw new IllegalArgumentException( "Could not create task of type" + taskType, e ); } } </code><technical_language> afacit vvv is all noise </technical_language>
code&comment2code: <code> public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) { super(adapterFactory); <START> labelProviderService = new LabelProviderServiceImpl(); <END> try { labelProviderService.startService(); } catch (ServiceException ex) { Activator.getDefault().getLog().log( new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Unable to start Papyrus Label Provider Service", ex)); } } </code><technical_language> It worries me a bit to imagine that _each_ decorator will start its own service (whatever that means, I'm not familiar with papyrus services) Can you check whether this is a common way of using services? Would it be possible to share a common instance somehow between decorators? </technical_language>
code&comment2code: <code> <START> default SourceMap sourceMap() { <END> return null; } </code><technical_language> Why not rely on Optional, rather than introducing another method which could lead to NPEs? </technical_language>
code&comment2code: <code> public static void setupDefaultTestCluster() throws Exception { config = DrillConfig.create(cloneDefaultTestConfigProperties()); classpathScan = ClassPathScanner.fromPrescan(config); openClient(); test("ALTER SESSION SET `exec.errors.verbose` = true"); <START> emptyDirCreating(); <END> } </code><technical_language> Why do we create empty directory for all tests that extend this class? I guess need to create it only for those tests that need it. </technical_language>
code&comment2code: <code> private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier, final String errorMessage) { try { theTypeSupplier.get(); <START> throw new RuntimeException(errorMessage); <END> } catch (MirroredTypeException mte) { return mte.getTypeMirror().toString(); } } </code><technical_language> As I am looking at the code, this is not necessary wrong, but maybe it would be better to throw new RuntimeException() in the end of the method. It's up to you what do you prefer. </technical_language>
code&comment2code: <code> default StreamPriority getStreamPriority() { <START> return StreamPriority.DEFAULT; <END> } </code><technical_language> return null instead when there is no priority </technical_language>
code&comment2code: <code> public static void onAdvancementEvent(AdvancementEvent event) { <START> if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) <END> { logger.info("{} got the {} advancement", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText()); } } </code><technical_language> Second ENABLED check is not necessary if you have the first one. </technical_language>
code&comment2code: <code> public ExampleEndpointsProvider() { try { JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI("<LINK_0>")); <START> endpoints.add(httpEndpoint); <END> } catch (URISyntaxException e) { throw new IllegalStateException(e); } } </code><technical_language> let's use URI.create and avoid try/catch </technical_language>
code&comment2code: <code> public SlackUserProperty() { <START> this.userId = null; <END> this.disableNotifications = false; } </code><technical_language> do we need any content in this constructor at all? </technical_language>
code&comment2code: <code> public void onStreamCreate(IMediaStream stream) { <START> if (!stream.isTranscodeResult()) { <END> PacketListener listener = new PacketListener(); WMSProperties props = stream.getProperties(); synchronized (props) { props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener); } stream.addLivePacketListener(listener); } } </code><technical_language> do return </technical_language>
code&comment2code: <code> public long getEstimatedSizeInBytes() { <START> int result = INSTANCE_SIZE; <END> result += sizeOf(levelOffsets); result += tree.sizeOf(); for (T item : items) { result += item.getEstimatedSizeInBytes(); } return result; } </code><technical_language> result -> size </technical_language>
code&comment2code: <code> public boolean respondsTo(RunEvent event) { Run r = event.getEventObject(); <START> if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) { <END> log.info("Run " + r.getAlias() + ": " + event.getEventMessage()); return true; } return false; } </code><technical_language> == instead of .equals (in both instances) would make this null-safe </technical_language>
code&comment2code: <code> private void updateSslVerifyUser(boolean value) { StoredConfig userConfig = GlobalConfigCache.getInstance() .getUserConfig(); try { <START> userConfig.load(); <END> updateSslVerify(userConfig, value); } catch (IOException | ConfigInvalidException e) { LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid, userConfig, e)); } } </code><technical_language> If I understand this change correctly, this shouldn't be needed anymore? </technical_language>
code&comment2code: <code> <START> private boolean isUserBrickAdapter(BaseAdapter baseAdapter) { <END> return baseAdapter instanceof UserBrickAdapter; } </code><technical_language> this method could be static i guess? more relevant: is this method necessary? i only see one usage </technical_language>
code&comment2code: <code> private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) { FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager() .findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG)); <START> formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); <END> return formulaEditorFragment; } </code><technical_language> Please check if the fragment exists. It could lead to a null-pointer exception. </technical_language>
code&comment2code: <code> public final ReviewCategoryStrategy reviewCategoryStrategy() { String s = reviewCategeoryStrategyRaw(); return s != null ? ReviewCategoryStrategy.valueOf(s) : <START> null; <END> } </code><technical_language> Shouldn't this return ReviewCategoryStrategy.NONE? Otherwise why do we have ReviewCategoryStrategy.NONE if null means NONE too? </technical_language>
code&comment2code: <code> public Iterable<ConnectorFactory> getConnectorFactories() { <START> return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore))); <END> } </code><technical_language> metastore is nullable here </technical_language>
code&comment2code: <code> public void testDBConnectionTimeMetrics() { <START> metrics.setDBConnectionTime(14); <END> assertEquals(14, testUtil.getGaugeValue("dbConnectionTime")); } </code><technical_language> Did you apply saveaction? </technical_language>
code&comment2code: <code> protected void createCacheManagers() throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true); <START> builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS); <END> createClusteredCaches(4, cacheName(), builder); } </code><technical_language> I think I like 20 better, to exercise the key migration code more. </technical_language>
code&comment2code: <code> private String getByAccountName(CodeReviewCommit codeReviewCommit) { Account account = getAccount(codeReviewCommit); if (account != null && account.getFullName() != null) { return " by " + <START> account.getUserName(); <END> } return ""; } </code><technical_language> getFullName() </technical_language>
code&comment2code: <code> public void findByUndefinedSchema() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> getClient().perform(get("/api/core/metadatafields/search/bySchema") .param("schema", "undefined")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath("$.page.size", is(20))) .andExpect(jsonPath("$.page.totalElements", is(0))); } </code><technical_language> I believe the Auth system should remain on in this method. </technical_language>
code&comment2code: <code> <START> private void addAll(QuantileDigest digest, long... values) <END> { requireNonNull(values, "values is null"); for (long value : values) { digest.add(value); } } </code><technical_language> private static </technical_language>
code&comment2code: <code> protected Object encodeCommand(Command command) { initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD); switch (command.getType()) { case Command.TYPE_CUSTOM: return formatCommand(command, "{%s}", Command.KEY_DATA); case Command.TYPE_POSITION_SINGLE: return formatCommand(command, "AVREQ,{%s},1", Command.KEY_DEVICE_PASSWORD); case Command.TYPE_REBOOT_DEVICE: return formatCommand(command, "AVRESET,{%s},{%s}", Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD); default: break; } <START> return null; <END> } </code><technical_language> Move this to default. </technical_language>
code&comment2code: <code> public void close() throws IOException { <START> if (selectObjectContentResult != null) { <END> selectObjectContentResult.close(); selectObjectContentResult = null; selectObjectRequest = null; } } </code><technical_language> We shouldn't need to check or clear any fields here, as SelectObjectContentResult is a Closeable which guarantees that close() is idempotent: > If the stream is already closed then invoking this method has no effect. </technical_language>
code&comment2code: <code> @Override public boolean isDisposed() { <START> return inner == null; <END> } </code><technical_language> get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null). </technical_language>
code&comment2code: <code> public void close() throws IOException { if (s3Object != null) { <START> s3Object.close(); <END> } } </code><technical_language> I think that we need super.close() here. </technical_language>
code&comment2code: <code> public void loadChunk(int x, int z) { <START> w.loadChunk(z, z); <END> } </code><technical_language> (z, z) certainly doesn't look right. </technical_language>
code&comment2code: <code> <START> public GeneratorUtil(TypeOracle typeOracle, <END> Logger logger, GeneratorContext generatorContext) { this.typeOracle = typeOracle; this.logger = logger; this.generatorContext = generatorContext; } </code><technical_language> rm public </technical_language>
code&comment2code: <code> protected boolean failPassthroughVnicHotPlug() { if <START> (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) <END> { addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED); return true; } return false; } </code><technical_language> replace equals with == for enums. </technical_language>
code&comment2code: <code> <START> public List<Map> getStageReachedCounts(Context context) throws SQLException { <END> return workspaceItemDAO.getStageReachedCounts(context); } </code><technical_language> It would be great if this map could use generics so we know what it contains. </technical_language>
code&comment2code: <code> Evaluator( final ObjectMapper mapper, final AsyncTaskExecutor asyncTaskExecutor, <START> final long timeoutLength) { <END> this.mapper = mapper; this.asyncTaskExecutor = asyncTaskExecutor; this.timeoutLength = timeoutLength; } </code><technical_language> usually this ) { is on the next line </technical_language>
code&comment2code: <code> public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) <START> throws IOException { <END> mMasterAddress = masterAddress; mMasterClient = masterClient; mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS); mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs; } </code><technical_language> do we still need to throw exception here? if not, you can remove the next TODO </technical_language>
code&comment2code: <code> public void sendLayerDeleted(String layerName) { <START> listeners.stream().forEachOrdered(listener->{ <END> listener.layerDeleted(layerName); }); } </code><technical_language> Seems me a  listeners.forEach(listener -> layerDeleted(layerName));  would have been at the same time more compact, readable, and faster (streams are very slow) </technical_language>
code&comment2code: <code> public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) { <START> List<SqlIdentifier> columnList = new ArrayList<>(); <END> columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO)); columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO)); return columnList; } </code><technical_language> Please immutable collection. </technical_language>
code&comment2code: <code> protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) { <START> super((Snapshot)tx, encoder, tl); <END> this.tx = tx; this.encoder = encoder; this.tl = tl; } </code><technical_language> can TypedSnapshotBase constructor take SnapshotBase instead of Snapshot? </technical_language>
code&comment2code: <code> public int hashCode() { int result = name != null ? name.hashCode() : 0; <START> result = 31 * result + (permissions != null ? permissions.hashCode() : 0); <END> result = 31 * result + mask; return result; } </code><technical_language> permissions can't be null, otherwise the constructor would throw a NPE. </technical_language>
code&comment2code: <code> public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> } </code><technical_language> this.contributor </technical_language>
code&comment2code: <code> public List<String> getSuggestions(String input) { <START> return WorldEdit.getInstance().getPlatformManager() <END> .queryCapability(Capability.GAME_HOOKS).getWorlds().stream() .map(World::getId) .filter(world -> world.startsWith(input)) .collect(Collectors.toList()); } </code><technical_language> You should probably extract the world-stream extraction to its own method. </technical_language>
code&comment2code: <code> <START> protected void executeCommand() { <END> boolean isStorageDisconnectSucceeded = disconnectStorage(); if(isStorageDisconnectSucceeded) { String connectionId = getConnection().getid(); if(StringUtils.isNotEmpty(connectionId)) { getDbFacade().getStorageServerConnectionDao().remove(connectionId); setSucceeded(true); } } } </code><technical_language> I don't understand something - now we will perform the this command for one host and then the connection will be removed from db, how we will perform the disconnect for other hosts? the load of connection will return null..no? you should take care of that i guess. </technical_language>
code&comment2code: <code> public void testNotEliminateSorts() { @Language("SQL") String sql = "SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"; PlanMatchPattern pattern = anyTree( sort( <START> window(windowMatcherBuilder -> windowMatcherBuilder <END> .specification(windowSpec) .addFunction(functionCall("row_number", Optional.empty(), ImmutableList.of())), anyTree(LINEITEM_TABLESCAN_Q)))); assertUnitPlan(sql, pattern); } </code><technical_language> curious: why remove anyTree? </technical_language>
code&comment2code: <code> public Program getAssociatedProgram(Artifact artifact) { String extension = getAssociatedExtension(artifact); Program program = <START> ProgramFinder.findProgram(extension.toLowerCase()); <END> if (program == null) { throw new OseeArgumentException("No program associated with the extension [%s] found on your local machine.", extension); } return program; } </code><technical_language> Perform this operation in the custom ProgramFinder.findProgram() method instead. </technical_language>
code&comment2code: <code> public final Iterable<N> toDepthFirstIterable() { <START> return () -> AbstractTree.this.depthFirstIterator(); <END> } </code><technical_language> Please replace all the occurrences of AbstractTree.this. Indeed, the code style we are using does not recommend to add this as a prefix of a function call when the function is in the current object. </technical_language>
code&comment2code: <code> void put(final K key, final V value) { clusterRegistry.put(scope, key, value); <START> System.out.println("putting key "+key+" ffrom thread "+Thread.currentThread().getName()); <END> localCacheInsert(key, value); } </code><technical_language> This is definitely a leftover that must be removed. </technical_language>
code&comment2code: <code> <START> public static String getWarningMessages(String filename){ <END> String warningMessage = ""; if (getErrorMessage(filename).length() == 0 && filename.length() > 0) { if (!filename.matches("[A-Za-z][A-Za-z0-9_]*")) { String errorMessage = MESSAGES.whitespaceProjectNameError(); filename = filename.replaceAll("( )+", " ").replace(" ","_"); warningMessage = errorMessage + ". \n '" + filename + "' will be used if continued."; } } return warningMessage; } </code><technical_language> Missed a space here between the ) and { </technical_language>
code&comment2code: <code> public @NonNull TraceSessionComponent[] getSessions() { List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class); if (compenents.size() > 0) { TraceSessionGroup group = (TraceSessionGroup)compenents.get(0); List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class); return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]); } return new <START> @NonNull TraceSessionComponent[0]; <END> } </code><technical_language> this doesn't seem to change anything for me? </technical_language>
code&comment2code: <code> private static void cacheColors(Display display) { BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB(); FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB(); Color hyperlinkText= JFaceColors.getHyperlinkText(display); <START> Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); <END> if (hyperlinkText != null) { LINK_COLOR_RGB= hyperlinkText.getRGB(); } if (activeHyperlinkText != null) { ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB(); } } </code><technical_language> Minor: Move declaration before the if block where it is used? </technical_language>
code&comment2code: <code> private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) { if (f instanceof IRadioButton) { <START> return (IRadioButton<T>) f; <END> } else if (f instanceof ICompositeField) { for (IFormField sub : ((ICompositeField) f).getFields()) { IRadioButton<T> b = findFirstButtonInFieldTree(sub); if (b != null) { return b; } } } return null; } </code><technical_language> you can use TypeCastUtility.getGenericsParameterClass(getClass(), IHolder.class); to check the type parameter </technical_language>
code&comment2code: <code> public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception { final String expected = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE suppressions PUBLIC\n" <START> + " \"- <END> + " \"<LINK_0>" + "suppressions_1_2_xpath_experimental.dtd\">\n" + "<suppressions>\n" + "</suppressions>\n"; exit.checkAssertionAfterwards(() -> { assertEquals("Unexpected output log", expected, systemOut.getLog()); assertEquals("Unexpected system error log", "", systemErr.getLog()); }); Main.main("-c", getPath("InputMainConfig-empty.xml"), "--generate-xpath-suppression", getPath("InputMainComplexityOverflow.java")); } </code><technical_language> fix name </technical_language>
code&comment2code: <code> public String getPackageName() { if (clazz.getPackage() != null) { return clazz.getPackage().getName(); } <START> return null; <END> } </code><technical_language> Can this method return null? Or should it return empty string? </technical_language>
code&comment2code: <code> public void testIsStringLiteral() { Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1); ASTLiteral literal = literals.iterator().next(); assertTrue(literal.isStringLiteral()); <START> assertEquals("String", literal.getTypeImage()); <END> } </code><technical_language> This could also be java.lang.String. </technical_language>
code&comment2code: <code> public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys) { ImmutableMap.Builder builder = ImmutableMap.builder(); for (K key : keys <START> ) { <END> V value = getIfPresent(key); if (value != null) { builder.put(key, value); } } return builder.build(); } </code><technical_language> formatting weird </technical_language>
code&comment2code: <code> <START> public void configure(ServerHttpSecurity http) { <END> ReactiveAuthenticationManager authenticationManager = getAuthenticationManager(); X509PrincipalExtractor principalExtractor = getPrincipalExtractor(); AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager); filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor)); http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION); } </code><technical_language> Please make this protected to avoid exposing methods that consumers of the API do not care about. </technical_language>
code&comment2code: <code> public void action(AuthenticationFlowContext context) { if (DisplayUtils.isConsole(context)) { <START> ConsoleOTPFormAuthenticator.SINGLETON.action(context); <END> return; } validateOTP(context); } </code><technical_language> Would it not be better to obtain this from the session? With this approach it's not pluggable. </technical_language>
code&comment2code: <code> private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber, Repository which, Collection<IFile> resources) { for (GitSynchronizeData gsd : gsds) { if (which.equals(gsd.getRepository())) { <START> if (!resources.isEmpty()) <END> refreshResources(subscriber, resources); else refreshRepository(subscriber); } } } </code><technical_language> A null check is needed also. An NPE will be thrown if reopening a very large project. java.lang.NullPointerException at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.handleResourceChange(GitSubscriberMergeContext.java:141) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.access$1(GitSubscriberMergeContext.java:137) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext$2.indexDiffChanged(GitSubscriberMergeContext.java:69) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.notifyListeners(IndexDiffCache.java:94) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.access$0(IndexDiffCache.java:86) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache$1.indexDiffChanged(IndexDiffCache.java:81) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.notifyListeners(IndexDiffCacheEntry.java:313) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.access$6(IndexDiffCacheEntry.java:306) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry$3.run(IndexDiffCacheEntry.java:171) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) </technical_language>
code&comment2code: <code> public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root, Sort rootSort) { <START> Set<Path> ret=new HashSet<Path>(); <END> if(rootSort!=null) { SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot()); for(SortFieldInfo fi:sfi) ret.add(fi.getName()); } return ret; } </code><technical_language> Don't necessarily need the type info in the right hand assignment anymore. Only mention it because you use both ways throughout. </technical_language>
code&comment2code: <code> public LocalCluster(String jarFileName, int siteCount, int hostCount, int kfactor, int clusterId, BackendTarget target, FailureState failureState, boolean debug, boolean isRejoinTest, Map<String, String> env) { <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END> } </code><technical_language> Why remove unused at only one level below if its not used at all remove all together. </technical_language>
code&comment2code: <code> public void execute(String userName) { FollowModeManager currentFollowModeManager = followModeManager; User userToFollow = findUser(userName); if (currentFollowModeManager == null) { return; } <START> User currentlyFollowedUser = followModeManager.getFollowedUser(); <END> if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow)) || (currentlyFollowedUser == null && userToFollow != null)) { currentFollowModeManager.follow(userToFollow); } actionPerformed(); } </code><technical_language> I would prefer to move this logic into the FollowModeManager </technical_language>
code&comment2code: <code> @Override public Appendable write(Appendable appendable, Context context) throws IOException { <START> String sep = ""; <END> for (TypeName className : typeNames) { appendable.append(sep); className.write(appendable, context); sep = " & "; } return appendable; } </code><technical_language> nit: sep -> separator ? </technical_language>
code&comment2code: <code> public void flush() throws IOException { <START> entryLogManager.flushCurrentLogs(); <END> entryLogManager.flushRotatedLogs(); } </code><technical_language> for single-log manager, it is better to flush rotated logs before flushing current logs, because the way how it rotates files and do the checkpoint. I would prefer keeping existing logic unchanged to reduce the risks. besides that, why not provide flush method in EntryLogManager? so different entry log manager implementation can implement its own flushing logic rather than exposing this knowledge to EntryLogger. If you provide flush method, it is possible that you don't need to expose flushCurrentLogs and flushRotatedLogs. </technical_language>
code&comment2code: <code> public void disableWireframe() { boolean refreshTaskList = false; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling(); <START> if (!getDesiredStateChanges().contains(faceCullingStateChange)) { <END> addDesiredStateChange(faceCullingStateChange); refreshTaskList = true; } if (getDesiredStateChanges().contains(wireframeStateChange)) { removeDesiredStateChange(wireframeStateChange); refreshTaskList = true; } if (refreshTaskList) { worldRenderer.requestTaskListRefresh(); } } </code><technical_language> Also notice OpaqueObjectsNode.java needs the same treatment. </technical_language>
code&comment2code: <code> public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) { List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId()); connections.clear(); connections.addAll(res); <START> return true; <END> } </code><technical_language> What's the point of this return value if it's always true? </technical_language>
code&comment2code: <code> public HibernateErrorReportingServiceDao() { <START> this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); <END> } </code><technical_language> I am not sure that converter should be part of DAO. Given we still using save on single entity I would suggest i would move that code to Service layer. </technical_language>
code&comment2code: <code> public JettyConfig getJettyConfig() { <START> if(jettyConfig != null) <END> { return jettyConfig; } else { return new DefaultJettyConfig(); } } </code><technical_language> Would much rather use the ternary operator here. Or even Optional, since we're on Java8 now.  Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig()); </technical_language>
code&comment2code: <code> public void setNumThreads(final Integer numThreads) { <START> m_threads = ConfigUtils.assertNotNull(numThreads, "threads"); <END> } </code><technical_language> Why do we not allow this field to be null? </technical_language>
code&comment2code: <code> <START> public String getModeName() { <END> String header = getHeader(); return header.substring(0, header.indexOf('"') - 1); } </code><technical_language> change to private </technical_language>
code&comment2code: <code> private List<RequestInfo> pollForRequests() { idsToDelete.clear(); <START> putManager.getIdsToDelete(idsToDelete); <END> for (String blobId : idsToDelete) { deleteManager .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null); } List<RequestInfo> requests = new ArrayList<RequestInfo>(); putManager.poll(requests); getManager.poll(requests); deleteManager.poll(requests); return requests; } </code><technical_language> If you make the getIdsToDelete() to return a list of blob Ids, we can avoid idsToDelete.clear(). We can just call idsToDelete = putManager.getIdsToDelete() everytime. </technical_language>
code&comment2code: <code> public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager) { Type type = boundVariables.getTypeVariable("E"); MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation( <START> functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); <END> return generateAggregation(type, compareMethodHandle); } </code><technical_language> Static import fromTypes. </technical_language>
code&comment2code: <code> public AccountInfo getAccountInfo() throws IOException { CoingiBalances coingiBalances; try { coingiBalances = getCoingiBalance(); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); <START> } <END> </code><technical_language> it would be easier to read if would surround the entire method with this type of try / catch like:  @Override public AccountInfo getAccountInfo() throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance(); return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } }  please apply this hint to all the methods that have this type of try catch </technical_language>
code&comment2code: <code> public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context) { <START> IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> node.getSources().forEach(source -> ret.putAll(source.accept(this, context))); return ret; } </code><technical_language> Map<TableScanNode, Void> result = new IdentityHashMap<>(); </technical_language>
code&comment2code: <code> protected RevCommit findHead(Repository repo) { try (RevWalk walk = new RevWalk(repo)) { try { ObjectId head = repo.resolve(HEAD); return walk.parseCommit(head); <START> } catch (RevisionSyntaxException e) { <END> throw new RuntimeException(e); } catch (AmbiguousObjectException e) { throw new RuntimeException(e); } catch (IncorrectObjectTypeException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } } </code><technical_language> you handle all these exceptions in the same way so you can use multi-catch: } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) { </technical_language>
code&comment2code: <code> public void process(EquivalentContentUpdatedMessage message) throws RecoverableException { Id contentId = message.getContentRef().getId(); <START> log.debug("Processing message on id {}, took PT{}S, message: {}", <END> contentId, getTimeToProcessInSeconds(message)); Timer.Context time = timer.time(); try { Content content = getContent(contentId); neo4JContentStore.writeContent(content); time.stop(); } catch (Exception e) { failureMeter.mark(); throw Throwables.propagate(e); } } </code><technical_language> You're not passing in the message even though you have a marker there. Think that might throw weird RTEs. </technical_language>
code&comment2code: <code> public String apply(String dimValue) { <START> if (dimValue == null) return null; <END> Matcher matcher = pattern.matcher(dimValue); return matcher.find() ? dimValue : null; } </code><technical_language> Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though. </technical_language>
code&comment2code: <code> private void writeSubscribeCommands( String repoName, List<SubscribeCommand> commands) throws IOException { write("repository " + repoName); for (SubscribeCommand cmd : commands) { switch (cmd.getCommand()) { case SUBSCRIBE: write("want " + cmd.getSpec()); break; case UNSUBSCRIBE: write("stop " + cmd.getSpec()); break; <START> } <END> } } </code><technical_language> default: throw new IllegalArgumentException... </technical_language>
code&comment2code: <code> private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) { Set<GlusterServerInfo> fetchedServers = null; <START> while (fetchedServers == null && existingServers.size() > 0) { <END> fetchedServers = fetchServers(upServer); if (fetchedServers == null) { logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED); setNonOperational(upServer); existingServers.remove(upServer); upServer = getNewUpServer(existingServers, upServer); } } return fetchedServers; } </code><technical_language> consider !existingServes.isEmpty() </technical_language>
code&comment2code: <code> public static String sanitizeSecondCachedKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId()); } </code><technical_language> ![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_0>](<LINK_1> </technical_language>
code&comment2code: <code> void remove(I key) { Integer prev = this.identityMap.remove(key); <START> if (prev != null) this.objectList.set(prev, null); <END> } </code><technical_language> please keep the body of an if on its own line </technical_language>
code&comment2code: <code> public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof TaskPropertyType)) { return false; } TaskPropertyType that = (TaskPropertyType) o; <START> if (!name.equals(that.name)) { <END> return false; } return true; } </code><technical_language> This is always FALSE. since name is static final </technical_language>
code&comment2code: <code> <START> protected long obtainEntityId() { <END> return nextEntityId++; } </code><technical_language> This could be private right? </technical_language>
code&comment2code: <code> public void markInCatalog() { <START> exportLog.info("ExportDataSource for table " + m_tableName + " partition " + m_partitionId + " marked as in catalog."); <END> m_isInCatalog = true; } </code><technical_language> I'm not sure that this INFO message is helpful to users. </technical_language>
code&comment2code: <code> private static boolean canConvert(ParameterDefinition def, ParameterValue v) { return def instanceof SimpleParameterDefinition && !(def instanceof StringParameterDefinition) && v instanceof StringParameterValue; <START> } <END> </code><technical_language> This results conversion will be applyed also to subclass of StringParameterValue. It would be better applied to exact StringParameterValue. </technical_language>
code&comment2code: <code> public void setUp() { <START> deviceHandler = new EventHandlerTest(); <END> passingHandler = new FilterHandler(); filtingHandler = new FilterHandler(); filtingHandler.setFilterInvalid(true); filtingHandler.setFilterZero(true); filtingHandler.setFilterDuplicate(true); filtingHandler.setFilterFuture(true); filtingHandler.setFilterApproximate(true); filtingHandler.setFilterStatic(true); filtingHandler.setFilterDistance(10); filtingHandler.setFilterLimit(10); } </code><technical_language> Why are you using EventHandlerTest here? It has nothing to do with filtering. </technical_language>
code&comment2code: <code> public void download(String url, String downloadPath) { InputStream in = null; try { in = new URL(url).openStream(); FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in)); System.out.println(IOUtils.toString(in)); } catch (IOException e) { <START> log.error(e); <END> } finally { IOUtils.closeQuietly(in); } } </code><technical_language> The connector setup should fail when an exception occurs. </technical_language>
code&comment2code: <code> private boolean getOldChildStale(IObservable child) { Boolean oldChildValue = staleMap.get(child); boolean oldChildStale = <START> oldChildValue == null ? false : oldChildValue .booleanValue(); <END> return oldChildStale; } </code><technical_language> Simpler: oldChildValue != && oldChildValue.booleanValue() </technical_language>
code&comment2code: <code> public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) { if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return; if (editor.getSettings().isVariableInplaceRenameEnabled()) { final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor); <START> if (templateState != null && !templateState.isFinished()) return; <END> } performAction(new GoIntroduceOperation(project, editor, file)); } </code><technical_language> Add tooltip </technical_language>
code&comment2code: <code> <START> private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { <END> List<String> isoFileList = new ArrayList<String>(); File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info)); for (File file : filterOvirtFiles) { isoFileList.add(file.getName()); } return isoFileList; } </code><technical_language> but you removed the static from there as well. </technical_language>
code&comment2code: <code> EWAHCompressedBitmap getBitmap() { Object r = bitmapContainer; if (r instanceof EWAHCompressedBitmap) return (EWAHCompressedBitmap) r; XorCompressedBitmap xb = (XorCompressedBitmap) r; EWAHCompressedBitmap out = xb.bitmap; <START> while (true) { <END> r = xb.xorBitmap.bitmapContainer; if (r instanceof EWAHCompressedBitmap) { bitmapContainer = out = out.xor((EWAHCompressedBitmap) r); return out; } xb = (XorCompressedBitmap) r; out = out.xor(xb.bitmap); } } </code><technical_language> nit: jgit spells this for (;;) </technical_language>
code&comment2code: <code> public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store, CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) { Assert.notNull(processor); Assert.notNull(store); setMessageStore(store); this.outputProcessor = processor; this.correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy; this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy; <START> super.messagingTemplate.setSendTimeout(DEFAULT_SEND_TIMEOUT); <END> sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy; } </code><technical_language> ??? this. of course. That's why I said to revert those all changes for the messagingTemplate and PR is becoming clear </technical_language>
code&comment2code: <code> public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) { <START> return groupToBootScript.apply(group, null); <END> } </code><technical_language> Hmmm this is wrong now? There should be two methods, one passing null and the other one passing the nodeName. </technical_language>
code&comment2code: <code> public boolean create(Personname personnameRecord) { LOG.trace("PersonnameDAO.create() - Begin"); <START> boolean result = true; <END> if (personnameRecord != null) { result = super.create(personnameRecord); } LOG.trace("PersonnameDAO.create() - End"); return result; } </code><technical_language> No need for result variable </technical_language>
code&comment2code: <code> public void handleInvocation(EJBClientInvocationContext context) throws Exception { <START> log.info("In the client interceptor handleInvocation : " + this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); <END> context.getContextData().put("ClientInterceptorInvoked", this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); context.sendRequest(); } </code><technical_language> Please only log at debug or trace </technical_language>
code&comment2code: <code> public void edit(final NewExternalSubnetModel subnet) { driver.edit(subnet); <START> if (subnet.getNetwork().getEntity() != null){ <END> networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName()); } } </code><technical_language> If I'm not mistaken, it shouldn't be possible for subnet.getNetwork() to be null, so you can drop the check. </technical_language>
code&comment2code: <code> protected AddVmFromTemplateCommand<AddVmParameters> createCommand() { initVM(); AddVmParameters <START> param = <END> new AddVmParameters(vm); return new AddVmFromTemplateCommand<>(param, null); } </code><technical_language> this is probably simple enough to be inlined... </technical_language>
code&comment2code: <code> public void testGetNameFromPath() { <START> String path1 = "/group1"; <END> String path2 = "/group1/group2/group3"; String emptyPath = ""; String nullPath = null; String rootPath = "/"; assertEquals(HDF5Utils.getNameFromPath(path1), "group1"); assertEquals(HDF5Utils.getNameFromPath(path2), "group3"); assertEquals(HDF5Utils.getNameFromPath(emptyPath), ""); assertNull(HDF5Utils.getNameFromPath(nullPath)); assertEquals(HDF5Utils.getNameFromPath(rootPath), ""); } </code><technical_language> Please split this test into several, testing each case separately. </technical_language>
code&comment2code: <code> <START> @Override public <END> GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() { JsonRpcRequest request = new RequestBuilder("GlusterHost.logicalVolumeList").build(); Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey(); return new GlusterLocalLogicalVolumeListReturn(response); } </code><technical_language> Coding conventions: Let's have the @Override on its own line please </technical_language>
code&comment2code: <code> <START> public String toString() { <END> return "TypedByteArray[length=" + length() + "]"; } </code><technical_language> needs @Override </technical_language>
code&comment2code: <code> public void onEntityDestroyed(EntityRef entity) { <START> if (!entity.isPersistent()) { <END> return; } entityDeltas.remove(entity.getId()); destroyedEntities.add(entity.getId()); } </code><technical_language> Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code). </technical_language>
code&comment2code: <code> private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) { Optional<OrganizationalUnit> targetOU = organizationalUnits.stream() .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst(); <START> if ( targetOU.isPresent() ) { <END> return targetOU.get(); } return null; } </code><technical_language> Isn't this use of Optional and returning null contradictory? Surely checking isPresent(..) in getDefaultOrganizationalUnit(..) would be better? </technical_language>
code&comment2code: <code> public void testPutAsync() throws Exception { Future<String> f = c.putAsync("k", "v"); testFuture(f, null); testK("v"); f = c.putAsync("k", "v2"); testFuture(f, "v"); <START> assertEquals("v2", c.get("k")); <END> } </code><technical_language> to keep code consistency, you may use testK("v2"); </technical_language>
code&comment2code: <code> public boolean isReady(TaskActionClient taskActionClient) throws Exception { <START> return false; <END> } </code><technical_language> should this return true instead ? </technical_language>
code&comment2code: <code> <START> static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { <END> Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean); return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer()); } </code><technical_language> why not public </technical_language>
code&comment2code: <code> public RequestHeader(Struct struct, short headerVersion) { this.data = new RequestHeaderData(struct, headerVersion); <START> this.headerVersion = headerVersion; <END> } </code><technical_language> nit: replace with this(new RequestHeaderData(struct, headerVersion), headerVersion). Consolidates c'tor logic to one place. </technical_language>
code&comment2code: <code> public void accountSession(String username, String password) throws TmdbInvalidParametersException { <START> if (username == null || password==null) <END> throw new TmdbInvalidParametersException(401,"Username and Password may not be null"); this.username = username; this.password = password; hasAccountSession = true; } </code><technical_language> Please add braces to conditionals (like if { }). </technical_language>
code&comment2code: <code> public void setProjectName(String projectName) { fProjectName = projectName; if(fLocationText.getText().equals(EMPTY_STRING)) { fRemoteDirSelected = false; } <START> if (fRemoteDirSelected == false) { <END> fLocationText.setText(getDefaultPathDisplayString()); } } </code><technical_language> Use if (!fRemoteDirSelected) { </technical_language>
code&comment2code: <code> public void testAddChildCycle3() { assertNotNull(fFixture); assertNotNull(f42Fixture); assertNotNull(fHiFixture); ((CalledFunction) f42Fixture).addChild(fHiFixture); <START> assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); <END> } </code><technical_language> unreachable. Maybe you should remove. </technical_language>
code&comment2code: <code> private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) { <START> if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { <END> return fieldName.charAt(0); } else { return Character.toUpperCase(fieldName.charAt(0)); } } </code><technical_language> I think the condition needs top start as fieldName.length() > 1 instead of fieldName.length() > 2 . I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong? </technical_language>
code&comment2code: <code> public void start() { <START> logger.debug("start()"); <END> for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) { cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType)); } } </code><technical_language> Are these logging statements really needed? </technical_language>
code&comment2code: <code> private WorkingSetDescriptor getSelectedWorkingSet() { IStructuredSelection selection = typesListViewer.getStructuredSelection(); WorkingSetDescriptor descriptor = null; if (!selection.isEmpty()) { descriptor = (WorkingSetDescriptor) <START> selection.getFirstElement(); <END> } return descriptor; } </code><technical_language> I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if. </technical_language>
code&comment2code: <code> public void evaluate() throws Throwable { <START> if (null != previous) { <END> previous.evaluate(); } for (FrameworkMethod before : befores) { before.invokeExplosively(target); } next.evaluate(); } </code><technical_language> Is it reasonable for the caller to pass in a null value for previous into the constructor? If not, then the constructor should throw a NullPointerException if it is null. </technical_language>
code&comment2code: <code> public Response add(OpenStackVolumeProvider provider) { validateParameters(provider, "name"); StoragePool storagePool = provider.isSetDataCenter() ? <START> getStoragePool(provider.getDataCenter()) : new StoragePool(); <END> provider.setDataCenter(DataCenterMapper.map(storagePool, null)); return performCreate( VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class) ); } </code><technical_language> It is a bit weird to create here an empty "StoragePool" to indicate that there is no storage pool to use. Can't we just pass "null" to the backend in that case? </technical_language>
code&comment2code: <code> <START> protected void doStoreUsers() <END> { try { usersFileManager.store(new UsersDto(new HashSet<>(userMap.values()))); } catch (IOException e) { throw new UndeclaredThrowableException(e); } } </code><technical_language> private </technical_language>
code&comment2code: <code> <START> public void tearDown() throws IOException, SQLException { <END> try { globalScheduler.shutdown(); } catch (Exception e) { } cleanup(); tearDownOnce(); } </code><technical_language> Why is this needed now? </technical_language>
code&comment2code: <code> private CloudMachineNamer getCloudMachineNamer(ConfigBag config) { String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS); if (namerClass != null) { try { return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass) .getDeclaredConstructor(ConfigBag.class).newInstance(config); } catch (Exception e) { throw Exceptions.propagate(e); } } else { <START> return new JcloudsMachineNamer(getAllConfigBag()); <END> } } </code><technical_language> This shouldn't call getAllConfigBag(). It should use the config passed in, otherwise we lose the local values passed in to the obtain() method. Do you agree? </technical_language>
code&comment2code: <code> <START> public IllustratedSelectItem(Object value, String label, String image) { <END> super(value, label); this.image = image; } </code><technical_language> Missing JavaDoc. </technical_language>
code&comment2code: <code> private boolean layerGroupContainmentCheckRequired() { Request request = Dispatcher.REQUEST.get(); if(request == null) { return false; } final String service = request.getService(); boolean isMapService = "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); if(!isMapService) { return false; } <START> return true; <END> } </code><technical_language> The last six lines can be squashed into: return "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); </technical_language>
code&comment2code: <code> public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) { <START> initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null); <END> } </code><technical_language> I would do this instead: initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null); IOW, no point in spending time on checking if the cache can be used if there's no initData provided. </technical_language>
code&comment2code: <code> private void buildUnaryExpression(UnaryExpressionTree tree) { <START> if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { <END> build(tree.expression()); currentBlock.elements.add(tree); } else { currentBlock.elements.add(tree); build(tree.expression()); } } </code><technical_language> @benzonico The fact that postfix operators return value before modification shouldn't change order in CFG, because loading of value should anyway happen before operation, i.e. order should be the same. </technical_language>
code&comment2code: <code> <START> public Class getRealClass() { <END> return testNGMethod.getRealClass(); } </code><technical_language> Class<?> </technical_language>
code&comment2code: <code> private KeyStore getSecretsStore() { final File secretStoreFile = createStoreIfNeeded(); try { final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE); <START> try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { <END> keyStore.load(inputStream, loadStorePassword()); } return keyStore; } catch (Exception e) { Logger.warn(this.getClass(), "unable to load secrets store " + SECRETS_STORE_FILE + ": " + e); throw new DotRuntimeException(e); } } </code><technical_language> Good it is the way </technical_language>
code&comment2code: <code> public AnonymousSpec anonymous(){ if (this.anonymous == null) { this.anonymous = new AnonymousSpec(); } <START> return this.anonymous.authorities("ROLE_USER"); <END> } </code><technical_language> This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it </technical_language>
code&comment2code: <code> public int getNumWaiters() { <START> return this.connectionPool.getNumActive(); <END> } </code><technical_language> suggestion return this.connectionPool.getNumWaiters(); </technical_language>
code&comment2code: <code> private void store() throws IOException { byte[] serialized = state.toCbor().serialize(); System.out.println("Writing "+ serialized.length +" bytes to "+ statePath); Files.write( statePath, serialized, <START> StandardOpenOption.CREATE); <END> } </code><technical_language> can we do this atomically? </technical_language>
code&comment2code: <code> private static void initFacets(@CheckForNull Fingerprint fingerprint){ if (fingerprint==null) return; <START> for (FingerprintFacet facet : fingerprint.facets) <END> facet._setOwner(fingerprint); } </code><technical_language> Please add curlies here </technical_language>
code&comment2code: <code> public Map<FactoryContainer, Attributes> getEnabledContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(); synchronized(_path) { for <START> (Entry<FactoryContainer, <END> Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; } </code><technical_language> For clarity it's preferable: Map.Entry </technical_language>
code&comment2code: <code> private FileListCacheValue getFileList() { <START> readLock.lock(); <END> try { FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey); if (fileList == null) { fileList = new FileListCacheValue(); FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList); if (prev != null) { fileList = prev; } } if (trace) log.trace("Refreshed file listing view"); return fileList; } finally { readLock.unlock(); } } </code><technical_language> I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head. </technical_language>
code&comment2code: <code> public long size() { build(); <START> return body.length() + partBoundary.length + partHeader.length; <END> } </code><technical_language> What happens when one of these TypedOutput instances return -1 because they don't know their length? </technical_language>
code&comment2code: <code> public boolean canStreamToNextPipe() { <START> return super.canStreamToNextPipe() && !isCollectResults(); <END> } </code><technical_language> Performance gezien is het natuurlijk handiger eerst een boolean check te hebben en dan extra logica.. </technical_language>
code&comment2code: <code> public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) { String idRefString = idRef.name(); FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString); if (foundViewHolder == null) { foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass); <START> foundHolders.put(idRefString, foundViewHolder); <END> } return foundViewHolder; } </code><technical_language> Where do you handle this now? </technical_language>
code&comment2code: <code> public void tearDown() { try { queryRunner.close(); } <START> finally { <END> queryRunner = null; } } </code><technical_language> finally is not really needed. If close throws the test will fail anyway and we won't care whether queryRunner is null or not. </technical_language>
code&comment2code: <code> private CommitConfig(Config rc) { commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION, null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE); String i18nCommitEncoding = rc.getString( ConfigConstants.CONFIG_SECTION_I18N, null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING); if (i18nCommitEncoding != null) { <START> commitMessageEncoding = Charset.forName(i18nCommitEncoding); <END> } } </code><technical_language> What if this throws an exception? Should probably be mapped to a ConfigInvalidException, and the caller should report the error. </technical_language>
code&comment2code: <code> public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) throws MalformedInputException { <START> try { <END> Inflater inflater = new Inflater(true); inflater.setInput(input, inputOffset, inputLength); int resultLength = inflater.inflate(output, outputOffset, maxOutputLength); inflater.end(); return resultLength; } catch (DataFormatException e) { throw Throwables.propagate(e); } } </code><technical_language> What's broken (add some details in the commit message)? This is not very obvious. </technical_language>
code&comment2code: <code> <START> public List<OutputLine> getLog() { <END> return this.log; } </code><technical_language> we should return an ImmutableList if we don't intend for users of this method to edit the list. </technical_language>
code&comment2code: <code> protected void doInit() { super.doInit(); if (!this.evaluationContextSet) { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory()); } <START> Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true, <END> "Single use connection needed with closeStreamAfterSend"); } </code><technical_language> !this.closeStreamAfterSend || this.isSingleUse ? </technical_language>
code&comment2code: <code> public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) { super(xStream); this.extensionRegisters = new ArrayList<DMNExtensionRegister>(); if(extensionRegisters != null && extensionRegisters.size() > 0) <START> this.extensionRegisters.addAll(extensionRegisters); <END> } </code><technical_language> I'm reworking this code in the context of the class, also to avoid potential NPE if the extensionRegisters field might have not been initialized, from the no-args constructor. </technical_language>
code&comment2code: <code> public void executeBatch(OperationsQueue operationsQueue) { <START> log.tracef( "Executing batch" ); <END> try { if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class ) || GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) { super.executeBatch( operationsQueue ); } } catch ( TupleAlreadyExistsException taee ) { throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee ); } } </code><technical_language> Maybe we should move that inside the if body, since we won't always execute the batch... ? </technical_language>
code&comment2code: <code> public int hashCode() { <START> return (((startCommit.hashCode() * 31) + numbers.length) * 31) <END> + getNumber(); } </code><technical_language> nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed </technical_language>
code&comment2code: <code> <START> private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { <END> AuthenticationSettings.INSTANCE.setUseBroker(true); } </code><technical_language> can this function now throw NoSuchAlgorithmException </technical_language>
code&comment2code: <code> public boolean isWrapperFor(Class<?> iface) { if (gridCoverage instanceof Wrapper) return ((Wrapper) gridCoverage).isWrapperFor(iface); <START> else if (iface.isInstance(gridCoverage)) return true; <END> else return false; } </code><technical_language> I woudl remove this else, if the gridCoverage is a wrapper and says "false" but iface is "GridCoverage2D" you want to fall back on the isInstance check anyways. </technical_language>
code&comment2code: <code> DataSegment uploadDataSegment( DataSegment segment, final int binaryVersion, final long size, final File compressedSegmentData, final String azurePath ) throws StorageException, IOException, URISyntaxException { azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath); final DataSegment outSegment = segment .withSize(size) .withLoadSpec(this.makeLoadSpec(new URI(azurePath))) .withBinaryVersion(binaryVersion); <START> log.info("Deleting file [%s]", compressedSegmentData); <END> compressedSegmentData.delete(); return outSegment; } </code><technical_language> Would you change the log level to debug? it doesn't look worth to be the info level. </technical_language>
code&comment2code: <code> public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter, TransactionalEditingDomain editingDomain) { <START> super(description, variableManager, <END> interpreter, editingDomain); this.description = description; } </code><technical_language> not done </technical_language>
code&comment2code: <code> private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) { return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) && <START> (!formatString.contains("{}") && formatString.contains("%")); <END> } </code><technical_language> useless parenthesis </technical_language>
code&comment2code: <code> void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); } <START> skipNum.setText(PatchUtil.C.patchSkipRegion(Integer <END> .toString(length))); } </code><technical_language> PatchUtil.M </technical_language>
code&comment2code: <code> public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) { this.publisher = publisher; this.run = build; this.workspace = build.getWorkspace(); this.launcher = launcher; <START> this.listener = listener; <END> } </code><technical_language> Wouldn't be better to directly call the new constructor? Just for easier maintenance in the future. </technical_language>
code&comment2code: <code> public void testWrongFormatNumber() throws Exception { NumberCellEditor editor; editor = new NumberCellEditor(shell, Integer.class); editor.setValue(" "); editor.getValue(); assertNull(editor.getValue() ); editor.setValue("aa"); <START> editor.getValue(); <END> assertNull(editor.getValue() ); } </code><technical_language> this might be obsolete if isValueValidis implemented... </technical_language>
code&comment2code: <code> public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) { if (hasAvatarProvider(newPlugin)) { avatarSupport = true; <START> } else { if (avatarSupport <END> && hasAvatarProvider(oldPlugin)) { avatarSupport = false; } } } </code><technical_language> else if on one line. </technical_language>
code&comment2code: <code> <START> public Class getRealClass() { <END> return clazz; } </code><technical_language> Class<?> </technical_language>
code&comment2code: <code> private String read(String resourcePath) throws IOException { InputStream is = getClass().getResourceAsStream(resourcePath); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } } </code><technical_language> I suppose close() is already done in Util.read(..) </technical_language>
code&comment2code: <code> public static String getModelFileWithGAV(ReleaseId releaseId) { <START> ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId; <END> return Paths.get(MODEL_FILE_DIRECTORY, releaseIdImpl.getGroupId(), releaseIdImpl.getArtifactId(), releaseIdImpl.getVersion(), MODEL_FILE_NAME).toString(); } </code><technical_language> I don't see why I need this cast. The group and artifact IDs are accessible even at interface level. Also the version is accessible, but I don't think you should add it here: this is for multimodule project compilaton and afaik you cannot have different modules with same GA and different version in the same project. </technical_language>
code&comment2code: <code> void removeConnection(String connectionId) { <START> if (availableConnections.remove(connectionId)) { <END> availableCount--; } poolCount--; } </code><technical_language> This operation can be O(n), though the size of the list may be small. Making sense to use a set instead? </technical_language>
code&comment2code: <code> private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if <START> (!desiredColumns.isEmpty()) <END> { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; } </code><technical_language> return before instantiating the map? </technical_language>
code&comment2code: <code> static boolean isValidMining(ICodeMining mining) { <START> return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty(); <END> } </code><technical_language> Why Objects.nonNull instead of != null? </technical_language>
code&comment2code: <code> public void addInput(Page page) { verify(probe == null); probe = page; probePosition = 0; joinAddresses = null; <START> joinAddressIndex = 0; <END> } </code><technical_language> -1 would be more correct. AFAIC you can skip this. </technical_language>
code&comment2code: <code> public DescriptorImpl() { super(ThrottleJobProperty.class); synchronized(propertiesByCategoryLock) { load(); if (!propertiesByCategory.isEmpty()) { propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>(); save(); } <START> } <END> } </code><technical_language> Simpler to just rename the field. Then XStream will discard the old data automatically. </technical_language>
code&comment2code: <code> public String toString() { String domainName = staticData.getName() == null ? "null" : staticData.getName(); <START> String domainId = staticData.getId() == null ? "null" : staticData.getId().toString(); <END> return "StorageDomain[" + domainName + ", " + domainId + "]"; } </code><technical_language> you don't need this. the "+" operator does this for you. </technical_language>
code&comment2code: <code> Predicate<Entry<Key,Value>> getScanPredicate() { final Range range = getRange(); <START> return input -> { if (range != null && !range.contains(input.getKey())) return false; return true; }; <END> } </code><technical_language> Can this be simplified to: java return input -> range == null || range.contains(input.getKey()); </technical_language>
code&comment2code: <code> public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, "client is null"); <END> this.client = client; } </code><technical_language> nit java this.client = requireNonNull(client, "client is null"); </technical_language>
code&comment2code: <code> private void addWorkPackageCriteria() { if (isWorkPackageSpecified()) { ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId); if (isColorTeamMatch(workPackArt)) { <START> if (workPackArt.isValid()) <END> { queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString()); } } } } </code><technical_language> Should this be above "isColorTeamMatch"? For example, on line #755. </technical_language>
code&comment2code: <code> private void sendToSocket(Socket socket, String cmdString) throws IOException { byte[] sendBytes = ("A" + cmdString.trim().replaceAll("\\s+", " ") + "\n").getBytes(); <START> socket.getInputStream().skip(tcpSocket.getInputStream().available()); <END> socket.getOutputStream().write(sendBytes); socket.getOutputStream().flush(); AstericsErrorHandling.instance.reportInfo(this, "IRTrans sent data: " + cmdString); } </code><technical_language> you directly use the member variable tcpSocket, but shouldnt it be the parameter socket? </technical_language>
code&comment2code: <code> public int hashCode() { <START> return getClass().hashCode(); <END> } </code><technical_language> can you explain why this is necessary? </technical_language>
code&comment2code: <code> private void reset() { <START> setId( next = NO_ID ); <END> } </code><technical_language> i do not think we need to save this line better make it more readable </technical_language>
code&comment2code: <code> public String getActualDowntime() { <START> return (actualDowntime == null) ? "(N/A)" : actualDowntime.toString() + "ms"; <END> } </code><technical_language> so now you can drop the "toString()" </technical_language>
code&comment2code: <code> String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params, final String argument) { if (argument.contains("/")) { <START> <END> }else{ return (params.live) ? "/live/" + argument + "." + EXTENSION : "/working/" + argument + "." + EXTENSION; } } </code><technical_language> @wezell , missing return statement... This is breaking when compiling the code </technical_language>
code&comment2code: <code> public DispoConfig findDispoConfig(DispoProgram program) { <START> ArtifactReadable config = <END> getQuery().fromBranch(program.getUuid()).andNameEquals("Program Config").getResults().getOneOrNull(); if (config == null) { DispoUtil.getDefaultConfig(); } return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config)); } </code><technical_language> andNameEquals is un-needed and probably undesired incase name ever changes </technical_language>
code&comment2code: <code> public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (operations.get(entry.getKey()).contains(name)) { <END> return true; } } } return false; } </code><technical_language> This is wrong, should be entry.getValue() </technical_language>
code&comment2code: <code> <START> IonSqlQueryBuilder(TypeManager typeManager) <END> { this.typeManager = requireNonNull(typeManager, "typeManager is null"); } </code><technical_language> Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private. </technical_language>
code&comment2code: <code> protected OperationController getOperationController() { <START> return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); <END> } </code><technical_language> Should we abstract this. I mean the way we choose the operation controller. What in case in future, we wish to choose the one which is less loaded compared to others? </technical_language>
code&comment2code: <code> public List<JDK> getJDKs() { <START> if(jdks==null) <END> jdks = new ArrayList<JDK>(); return jdks; } </code><technical_language> So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded. I don't see how that could happen - but there may be some old version of Jenkins that could have done it. Would probably make sense to modify a readResolve() to set it to an empty list and remove this check and the theoretical possibility? </technical_language>
code&comment2code: <code> public boolean addAll(int index, Collection<? extends T> c) { Collection<T> uniqueValuesToAdd = getUniqueValues(c); if (uniqueValuesToAdd.isEmpty()) { return false; } try { return super.addAll(index, uniqueValuesToAdd); } catch (IndexOutOfBoundsException ioobException) { comparingSet.removeAll(uniqueValuesToAdd); <START> throw new IndexOutOfBoundsException(); <END> } } </code><technical_language> same as above: please pass on the original exception so that we retain the stacktrace and message. </technical_language>
code&comment2code: <code> public Context getContext() { if (sdkName == null) { sdkName = this.getClass().getPackage().getName(); } return new Context("Sdk-Name", sdkName) <START> .addData("Sdk-Version", SDK_VERSION); <END> } </code><technical_language> why sdk version hardcoded? </technical_language>
code&comment2code: <code> <START> public void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> getStorageDevices().setSelectedItems(selectedDevices); } </code><technical_language> Can this be protected. I assume only the ListModel is using it </technical_language>
code&comment2code: <code> private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) { Snapshot snapshot = timer.getSnapshot(); JsonObject json = new JsonObject(); populateMetered(json, timer, rateUnit); double factor = 1.0 / durationUnit.toNanos(1); populateSnapshot(json, snapshot, factor); <START> String duration = durationUnit.toString().toLowerCase(Locale.US); <END> json.putString("durationRate", duration); return json; } </code><technical_language> Why US? </technical_language>
code&comment2code: <code> protected void delete(LogEntry delegate, String reason, RequestContext context) throws ResourceDoesNotSupportOperationException { <START> throw new UnsupportedOperationException("delete not supported"); <END> } </code><technical_language> Should be ResourceDoesNotSupportOperationException </technical_language>
code&comment2code: <code> <START> protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) { <END> this.consumerBatchEnabled = consumerBatchEnabled; } </code><technical_language> Why is this protected ? Are you going to detect this option internally by the @RabbitListener(Handler) method signature? </technical_language>
code&comment2code: <code> public int getLevel() { <START> return data.optInt("toclevel"); <END> } </code><technical_language> old code seems to indicate this should be "level" not "toclevel"? Could be causing failure of getLevel() calls being compared in SectionsFetchTask.processResult? </technical_language>
code&comment2code: <code> private void setPagesRecycler(OnThisDayCard card) { if (card.pages() != null) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) <START> this.getContext()); <END> recyclerAdapter.setCallback(new ItemCallback()); pagesRecycler.setAdapter(recyclerAdapter); } else { pagesRecycler.setVisibility(GONE); } } </code><technical_language> use getContext() instead of this.getContext() ? </technical_language>
code&comment2code: <code> public String getExtendedLabelForVSM(String providedShapeURI) { for (IConfigurationElement configurationElement : extensions) { String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier(); if (identifier != null && identifier.equals(providedShapeURI)) { return <START> configurationElement.getAttribute(LABEL_ATTRIBUTE) + " - " + configurationElement.getNamespaceIdentifier(); <END> } } return "Unknown URI"; } </code><technical_language> Add a getExtendedLabelsForVSM(IConfigurationElement) method to avoid duplication </technical_language>
code&comment2code: <code> public void stopServer() { if (server instanceof GrizzlyServer) { <START> ((GrizzlyServer) server).setCleanIdleConnections(); <END> } server.stop(); } </code><technical_language> I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter. </technical_language>
code&comment2code: <code> protected Supplier<Operation> createOperationSupplier() { <START> return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name); <END> } </code><technical_language> We can make DestroyProxyMessageTask implement the Supplier, so that this method will no create a lamda but return this instead. </technical_language>
code&comment2code: <code> public <C extends CtTypedElement> C setType(CtTypeReference<T> type) { if (type != null) { type.setParent(this); } <START> getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); <END> if (getExecutable() != null) { getExecutable().setType(type); } return (C) this; } </code><technical_language> So model change listener will be called twice for single modification? I do not like it. @monperrus Could you explain why it is good? </technical_language>
code&comment2code: <code> public static AuthenticationProfileRepository getInstance() { return instance; <START> } <END> </code><technical_language> I do not understand the above two... but for ut it will be hell. </technical_language>
code&comment2code: <code> public HttpRequest filterKey(HttpRequest request) throws HttpException { request = replaceDateHeader(request); String signature = calculateSignature(createStringToSign(request)); <START> request = replaceAuthorizationHeader(request, signature); <END> return request; } </code><technical_language> suggestion </technical_language>
code&comment2code: <code> public ScreenshotSize get() { <START> if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) { <END> return ScreenshotSize.DOUBLE_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) { return ScreenshotSize.NORMAL_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) { return ScreenshotSize.HALF_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) { return ScreenshotSize.QUARTER_SIZE; } else { return ScreenshotSize.NORMAL_SIZE; } } </code><technical_language> Again, should just return the value if not null. </technical_language>
code&comment2code: <code> <START> public String canonicalID() { <END> return canonical; } </code><technical_language> Why make this non-final? Given how important this method is for its serialization/internal representation, it's pretty important that it not be overridden. </technical_language>
code&comment2code: <code> protected void close() { try { <START> m_sout.flush(); <END> m_sout.close(); } catch (IOException ex) { } } </code><technical_language> close does an implicit flush </technical_language>
code&comment2code: <code> protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) { long last = tracker.readLastCommittedOffset(); <START> return (last > 0) && (last >= offset); <END> } </code><technical_language> No need for parentheses. </technical_language>
code&comment2code: <code> public EList<Diff> getDifferences() { <START> return new BasicEList<Diff>(this.diffs); <END> } </code><technical_language> Please don't create a new list on every call of getDifferences(), but create the list once, e.g., on the first call, and then return the same instance. You might want to use an UnmodifiableEList instead, to fail early, if someone tries to modify it. </technical_language>
code&comment2code: <code> <START> public IOWorkers.Selector getWorkerSelector() { <END> return workerSelector; } </code><technical_language> @clevertension Why do we need to expose IOWorkers.Selector? Looks completely unnecessary to me. </technical_language>
code&comment2code: <code> public Iterable<Tree> children() { List<Tree> result = new ArrayList<>(); if(openParenToken != null) { result.add(openParenToken); } <START> for (Tree tree : super.children()) { <END> result.add(tree); } if(closeParenToken != null) { result.add(closeParenToken); } return result; } </code><technical_language> super.children().forEach(res::add); ? </technical_language>
code&comment2code: <code> public void setName(String name) { Objects.requireNonNull(name); <START> this.name = name; <END> } </code><technical_language> requireNonNull could be on same line than affectation. </technical_language>
code&comment2code: <code> public Query existsQuery(QueryShardContext context) { if (hasDocValues()) { return new DocValuesFieldExistsQuery(name()); <START> } else if (omitNorms()) { <END> return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())); } else { return new NormsFieldExistsQuery(name()); } } </code><technical_language> I believe it should be omitNorms() || indexOptions() != IndexOptions.NONE </technical_language>
code&comment2code: <code> <START> private void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) { <END> if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) { yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, "yield")); } } </code><technical_language> This method should be static </technical_language>
code&comment2code: <code> <START> private void importLdif(InMemoryDirectoryServer directoryServer) throws LDAPException { <END> if (StringUtils.hasText(this.ldif)) { try { Resource resource = locateResource(); try (InputStream inputStream = resource.getInputStream()) { directoryServer.importFromLDIF(false, new LDIFReader(inputStream)); } } catch (Exception ex) { throw new IllegalStateException("Unable to load LDIF " + this.ldif, ex); } } } </code><technical_language> We do not need to declare that this throws an LDAPException. </technical_language>
code&comment2code: <code> <START> public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) { <END> this.table = table; this.ctTableColumn = ctTableColumn; } </code><technical_language> I would insist in having all methods that use a CT* parameter to be annotated as @Internal when they are not private. </technical_language>
code&comment2code: <code> private boolean isDateSelectable(Date date) { <START> if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) return false; <END> return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date); } </code><technical_language> We'd use { and } here or just fold the conditional into a single return statement. </technical_language>
code&comment2code: <code> <START> public void updatePathGroup(List<Variable> <END> variables, IPath node, IPath selection) { final int segmentsSelection = selection.segmentCount(); for (final Variable variable : variables) if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) { final IPath oldPath = variable.getPath(); final int count = selection.segmentCount(); variable.setPath(buildPath(oldPath, node, count)); } } </code><technical_language> make static </technical_language>
code&comment2code: <code> private FactorComparator(String factorName, int weight, Comparator<T> comparator){ this.factorName = factorName; this.weight = weight; this.comparator = comparator; <START> logger.info("comparator created for " + this.factorName); <END> } </code><technical_language> is this necessary? </technical_language>
code&comment2code: <code> <START> public PatternMatcher(TermContext context) { <END> this.termContext = context; multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>(); } </code><technical_language> why was this done? </technical_language>
code&comment2code: <code> public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode()); <START> result = prime * result + ((getBranchId().isInvalid()) ? 0 : getBranchId().hashCode()); <END> return result; } </code><technical_language> result = prime * result + getBranchId().hashCode(); can use BranchId's hashCode method directly since branchId is not allowed to be null and it will work whether the id is valid or not </technical_language>
code&comment2code: <code> <START> protected void <END> setUpGetUnregisteredVmTemplateExpectations(boolean notFound) { setUpEntityQueryExpectations( QueryType.GetUnregisteredVmTemplate, GetUnregisteredEntityQueryParameters.class, new String[] { "StorageDomainId", "EntityId" }, new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID }, notFound ? null : getEntity(1)); } </code><technical_language> Can be private </technical_language>
code&comment2code: <code> <START> public boolean isDomainXmlEnabledForVds(Guid vdsId) { <END> return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion()); } </code><technical_language> The whole purpose of FullListAdapter is to abstract the implementation details of querying the device list from the caller - so how about moving the changes that are done in VmDevicesMonitoring to FullListVDSCommand ? </technical_language>
code&comment2code: <code> public void mousePressed(MouseEvent e) { <START> if (e.isPopupTrigger()) <END> doPop(e); } </code><technical_language> Please add {} also for if blocks with only one statement. </technical_language>
code&comment2code: <code> public boolean isSuggestionListDisplayed() { try { <START> waitForElementByElement(searchSuggestions.get(0)); <END> return searchSuggestions.get(0).isDisplayed(); } catch (NoSuchElementException|IndexOutOfBoundsException e) {} return false; } </code><technical_language> Use .getSize to see if element is on page </technical_language>
code&comment2code: <code> public ConnectionId(final String host, final int port, final String connectionId) { Objects.requireNonNull(host); if (port <= 0) { <START> throw new IllegalArgumentException(String.format("Port must be greater than 0")); <END> } this.host = host; this.port = port; this.connectionId = connectionId; } </code><technical_language> no need to use String.format as there is no parameter. Either provide directly throw new IllegalArgumentException("Port must be greater than 0"); or maybe improve message with somethign like: throw new IllegalArgumentException(String.format("Port must be greater than 0 (provided {0})", port)); </technical_language>
code&comment2code: <code> public RecursiveLoggerContextInstantiationException(String message) { <START> super(I18nMessageFactory.createStaticMessage(message)); <END> } </code><technical_language> use static import. </technical_language>
code&comment2code: <code> <START> public Map<String, MetricPlotDTOs> createTaskPlots() { <END> sessionId = getSessionIdProvider().getSessionId(); List<MetricPointEntity> metricDetails = getHibernateTemplate().find( "select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?", sessionId); if (metricDetails == null || metricDetails.isEmpty()) { return oldWay(); } else { return newWay(metricDetails); } } </code><technical_language> why is it public? </technical_language>
code&comment2code: <code> public void testDeadlock() throws Exception { doTest(1000 * 30); boolean <START> interrupted = <END> Thread.interrupted(); if (interrupted) { fail("Thread was interrupted at end of test"); } } </code><technical_language> Why not inline this variable? </technical_language>
code&comment2code: <code> public static QueryGranularity fromString(String str) { String name = str.toUpperCase(); if(name.equals("ALL")) { return QueryGranularity.ALL; } else if(name.equals("NONE")) { return QueryGranularity.NONE; } else if(CALENDRIC_GRANULARITIES.containsKey(name)) { <START> return new PeriodGranularity(CALENDRIC_GRANULARITIES.get(name), null, null); <END> } return new DurationGranularity(convertValue(str), 0); } </code><technical_language> instead of creating a new object every time, it might make more sense to store constants for each predefined granularity string </technical_language>
code&comment2code: <code> public Object[] getElements(Object element) { <START> if (element instanceof Object[]) { <END> return (Object[]) element; } if (element instanceof Collection) { return ((Collection) element).toArray(); } return new Object[0]; } </code><technical_language> style nit: we don't use braces around single line blocks </technical_language>
code&comment2code: <code> public void setUp() throws Exception { super.setUp(); <START> if (SystemUtils.IS_OS_LINUX) { <END> try { eventLoopGroup = new EpollEventLoopGroup(); } catch (Throwable t) { LOG.warn("Could not use Netty Epoll event loop {}", t.getMessage()); eventLoopGroup = new NioEventLoopGroup(); } } else { eventLoopGroup = new NioEventLoopGroup(); } executor = OrderedSafeExecutor.newBuilder() .name("BKClientOrderedSafeExecutor") .numThreads(2) .build(); } </code><technical_language> maybe we should create a common utility function to build EventLoopGroups and do not duplicate this kind of code </technical_language>
code&comment2code: <code> private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength) { try { long readStart = System.nanoTime(); inputStream.readFully(position, buffer, bufferOffset, bufferLength); stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart); } catch (PrestoException e) { throw e; } catch (Exception e) { <START> throw new PrestoException(HIVE_FILESYSTEM_ERROR, format("Error reading from %s at position %s", id.toString(), position), e); <END> } } </code><technical_language> Don't need the toString call. </technical_language>
code&comment2code: <code> public void invalidPropertiesFormat() { VmDevice device = new VmDevice(); device.setType(VmDeviceGeneralType.DISK); device.setCustomProperties("bootable"); DevicePropertiesUtils utils = mockDevicePropertiesUtils(); List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device); assertFalse(errors.isEmpty()); <START> assertTrue(errors.get(0).getReason() == ValidationFailureReason.SYNTAX_ERROR); <END> } </code><technical_language> Don't you prefer to use assertEquals? </technical_language>
code&comment2code: <code> private boolean isMandatory(MethodExpression expression) { <START> return expression.getMethod().getWords().get(0).equals(MANDATORY) ? true : false; <END> } </code><technical_language> If this is the use of the "MANDATORY" constant then you may want to define it as a "Name" instead of "String": privates static final Name MANDATORY = NameParser.parseUsingCase("Mandatory"); Then you can compare it easily: return expression.getMethod().equals(MANDATORY); </technical_language>
code&comment2code: <code> <START> private DeltaVisit next() { <END> if (parent != null && parent.nextChild == null) { parent.data = null; parent = parent.parent; } if (nextChild != null) return new DeltaVisit(this); if (parent != null) return new DeltaVisit(parent); return null; } </code><technical_language> Good change making this an instance member, thanks. </technical_language>
code&comment2code: <code> boolean delayNextTimeToRun(Date timeToRunTheVm) { this.timeToRunTheVm = timeToRunTheVm; <START> return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; <END> } </code><technical_language> we can do something like: numOfSkips = ++numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; return numOfSkips == 0; and remove clearSkipCounter, no? if this was already properly verified, we can merge this and think about the change above on master-only </technical_language>
code&comment2code: <code> protected boolean isTransientException(Throwable e) { if(e instanceof SQLException) { final String sqlState = ((SQLException) e).getSQLState(); <START> return sqlState.startsWith("08") || sqlState.startsWith("53"); <END> } return false; } </code><technical_language> Of the "53" class of errors, I think only "53300" might be transient, no? </technical_language>
code&comment2code: <code> public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) { JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor); <START> if (!(op instanceof TimestampOperation)) { <END> this.ackJupiterActivityList.add( new OperationWrapper(op, this.vectorTime.getLocalOperationCount())); } this.vectorTime = this.vectorTime.incrementLocalOperationCount(); return jupiterActivity; } </code><technical_language> So you pointed me to this line and what is the problem here ? The problem is that discardAcknowledgedOperations is never called. This was never done in this method anyway. </technical_language>
code&comment2code: <code> public void testAssignExecutorInvalidExecutor() throws Exception { final ExecutableFlow flow = TestUtils.createExecutableFlow("exectest1", "exec1"); this.executionFlowDao.uploadExecutableFlow(flow); assertThatThrownBy( <START> () -> this.assignExecutor.assignExecutor(flow.getExecutionId(), 1)) <END> .isInstanceOf(ExecutorManagerException.class) .hasMessageContaining("non-existent executor"); } </code><technical_language> Should it be assignExecutor(1, flow.getExecutionId())? Also how do you know 1 is a non-existent executor? </technical_language>
code&comment2code: <code> private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions() <START> throws Exception <END> { ConnectorSession connectorSession = new TestingConnectorSession( new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties()); return new BackgroundHiveSplitLoader( SIMPLE_TABLE, createPartitionMetadataWithOfflinePartitions(), TupleDomain.all(), createBucketSplitInfo(Optional.empty(), ImmutableList.of()), connectorSession, new TestingHdfsEnvironment(), new NamenodeStats(), new TestingDirectoryLister(TEST_FILES), directExecutor(), 2, false); } </code><technical_language> no Exception is thrown here </technical_language>
code&comment2code: <code> public String toString() { <START> return methodPrefix.toString(); <END> } </code><technical_language> 'methodPrefix.toString()' is redundant </technical_language>
code&comment2code: <code> private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) { android.view.textclassifier.TextClassificationManager <START> textClassificationManager = <END> (android.view.textclassifier.TextClassificationManager) mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE); android.view.textclassifier.TextClassifier platformTextClassifier = textClassifier == null ? null : new PlatformTextClassifier(mContext, textClassifier); textClassificationManager.setTextClassifier(platformTextClassifier); } </code><technical_language> TCM is an optional Android system service. Check for null. </technical_language>
code&comment2code: <code> Object loadServiceCapabilities(String serviceUrl) throws IOException { HttpGet request = new HttpGet(serviceUrl); request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES)); CloseableHttpResponse httpResponse = execute(request, serviceUrl, "retrieve help"); validateResponse(httpResponse, serviceUrl); HttpEntity httpEntity = httpResponse.getEntity(); ContentType contentType = ContentType.getOrDefault(httpEntity); <START> if ("text/plain".equals(contentType.getMimeType())) { <END> return getContent(httpEntity); } return parseJsonMetadata(httpEntity); } </code><technical_language> mime type is mandatory </technical_language>
code&comment2code: <code> protected void doStop() { log.info("Stopping Netty server"); boss.shutdownGracefully(); if(!datagram) { <START> wrkr.shutdownGracefully(); <END> } try { sock.channel().closeFuture().sync(); } catch (InterruptedException e) { log.warn("Netty server stop interrupted"); Thread.currentThread().interrupt(); } log.info("Netty server stopped"); notifyStopped(); } </code><technical_language> I think it is the boss who should be shut down if (!datagram) </technical_language>
code&comment2code: <code> public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { <START> LayoutInflater inflater = LayoutInflater.from(parent.getContext()); <END> return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false)); } </code><technical_language> Maybe pass the layout inflater as a param to the adapter. </technical_language>
code&comment2code: <code> public void onSelectionChanged(int selectedItemCnt) { int numberMergeSelections = adapter.numberMergeSelections; if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) { <START> ToastUtil.showError(getContext(), "We can only merge " + numberMergeSelections + " projects"); <END> } updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection)); actionMode.setTitle(getResources() .getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt)); } </code><technical_language> is there a reason that this is displayed everytime? since this is shown when the second project is selected, it will always be there. </technical_language>
code&comment2code: <code> private boolean shouldBeDistributed(PlanNode planNode) { return planNode instanceof AggregationNode || planNode instanceof JoinNode || <START> (planNode instanceof TopNNode && ((TopNNode) planNode).getStep().equals(TopNNode.Step.PARTIAL)); <END> } </code><technical_language> The method will grow (i once already wanted to add something here), so what about putting this in a more lengthy but more readable way? (Note, I also changed TopNNode's condition)  if (planNode instanceof JoinNode) { return true; } if (planNode instanceof AggregationNode) { return true; // here you could differentiate between partial/... } if (planNode instanceof TopNNode) { return ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL; } return false; </technical_language>
code&comment2code: <code> public void testConcurrency() { final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId); marshal("application/xml", serverTemplate); Thread disconnect = new Thread(() -> disconnect()); disconnect.start(); String response = marshal("application/xml", serverTemplate); <START> LOGGER.info(response); <END> } </code><technical_language> suggestion assertNotNull(response); </technical_language>
code&comment2code: <code> protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) { <START> builder.append(String.format(Locale.ENGLISH, "%d", node.getValue())); <END> return null; } </code><technical_language> suggestion builder.append(Integer.toString(node.getValue()));  Cheaper than going through String.format </technical_language>
code&comment2code: <code> <START> private List<GerritQueryResult> executeQueryRest(String query) throws GerritException { <END> List<GerritQueryResult> results = null; results = client.executeQueryRest(new NullProgressMonitor(), query); return results; } </code><technical_language> This is essentially one line of code, I'd prefer to inline this. </technical_language>
code&comment2code: <code> public QueryWrapper(@JsonProperty("query") String query, @JsonProperty("queryType") String queryType) { <START> this(query, queryType, ""); <END> } </code><technical_language> to avoid redundant pattern check : suggestion this(query, queryType, null); </technical_language>
code&comment2code: <code> private List<CoordinatorDuty> makeCompactSegmentsDuty() { <START> List<CoordinatorDuty> duties = new ArrayList<>(); duties.add(compactSegments); return ImmutableList.copyOf(duties); <END> } </code><technical_language> Why not return ImmutableList.of(compactSegments); instead? </technical_language>
code&comment2code: <code> public CreateServerOptions networks(String... networks) { <START> return networks(ImmutableSet.copyOf(checkNotNull(networks, "network should not be empty"))); <END> } </code><technical_language> The "standard" jclouds pattern would be checkNotNull(networks, "networks"), but in this case it's not doing the expected thing since a varargs argument cannot be null, it will be an empty array instead. If we want to enforce this check, it probably should be:  checkArgument(networks.length > 0, "networks should not be empty"); return networks(ImmutableSet.copyOf(networks));  but since networks(Iterable<String> networks) already checks I don't think we need the check here. </technical_language>
code&comment2code: <code> private static AbbreviatedObjectId id(DiffEntry de) { <START> return (de.changeType == ChangeType.DELETE ? de.oldId : de.newId); <END> } </code><technical_language> Style-nit: We don't put () around ?: in a return. </technical_language>
code&comment2code: <code> protected VariableReferenceExpression getVariableReference(RowExpression expression) { if (expression instanceof VariableReferenceExpression) { return ((VariableReferenceExpression) expression); } else { <START> throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), "Expected a variable reference but got " + expression); <END> } } </code><technical_language> private </technical_language>
code&comment2code: <code> public boolean isLocalOnly() { <START> switch (this) { <END> case LOCAL: return true; default: return false; } } </code><technical_language> it could be simpler return this == LOCAL </technical_language>
code&comment2code: <code> protected void findUsers(String searchString, AsyncQuery query) { Frontend.getInstance() .runQuery(VdcQueryType.Search, <START> new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); <END> } </code><technical_language> Done </technical_language>
code&comment2code: <code> public String getImageUrl(String id) { return getProvider().getUrl() + API_VERSION + "/images/" + id + <START> "/file"; <END> } </code><technical_language> if it's v2 older hosts won't work since they use HEAD, no? </technical_language>
code&comment2code: <code> public User(@NonNull String username, @NonNull String password) { this(username, password, <START> new HashMap<String, Integer>(), null); <END> } </code><technical_language> I recommend using Collections.emptyMap() instead </technical_language>
code&comment2code: <code> public final String consoleClientResourcesUrl() { String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL); boolean isAbsolute = url.contains("://"); return isAbsolute ? url : Window.Location.getProtocol() + " <START> "/" + BaseContextPathData.getInstance().getRelativePath() + url; <END> } </code><technical_language> no... this can be relative as well... see: frontend/webadmin/modules/uicommonweb/src/main/java/org/ovirt/engine/ui/uicommonweb/ReportInit.java </technical_language>
code&comment2code: <code> private boolean isFileEntryPackageable(ZipEntry entry) { <START> String entryName = entry.getName(); <END> return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entryName); } </code><technical_language> don't need this. Just refer to entry.getName() in both places </technical_language>
code&comment2code: <code> public void testList() { List<VirtualMachine> list = api().list(); <START> for (VirtualMachine machine : list) { <END> assertTrue(!machine.name().isEmpty()); } } </code><technical_language> I'd just assert that it contains the created VM. </technical_language>
code&comment2code: <code> <START> void addLayer(String id, StyleLayer layer) { <END> layersById.put(id, layer); } </code><technical_language> package-private? </technical_language>
code&comment2code: <code> public void setSelection(ITimeGraphEntry trace) { synchronized (fListenerNotifierLock) { <START> if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) { <END> return; } } fSelectedEntry = trace; fTimeGraphCtrl.selectItem(trace, false); adjustVerticalScrollBar(); } </code><technical_language> idem </technical_language>
code&comment2code: <code> private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) { try { <START> return SecurityActions.getConstructor(ClassFile.class, String.class, int.class, String.class, ClassLoader.class, Arrays2.EMPTY_STRING_ARRAY.getClass()) <END> .newInstance(name, accessFlags, superclass, classLoader, interfaces); } catch (Exception e) { throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause()); } } </code><technical_language> Why not use the constructor right away, i.e. without reflection? </technical_language>
code&comment2code: <code> public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) { <START> final VirtualClassLoader localClassLoader = ((VirtualClassLoader) getLocalClassLoader(type, id)); <END> return localClassLoader.addListener(classLoaderListener); } </code><technical_language> We can change the return type of getLocalClassLoader only in the implementation to avoid the cast. </technical_language>
code&comment2code: <code> public static final void setPreferenceNodeId (String id) { if (fgPreferenceNodeId == null) { <START> fgPreferenceNodeId = <END> id; } } </code><technical_language> JDT uses compact assignement, e.g. i= 3; </technical_language>
code&comment2code: <code> private void init() { try { hostname = InetAddress.getLocalHost().getHostName(); <START> hostname = "localhost"; <END> } catch (UnknownHostException e) { logger.warn("Error getting the value of localhost. " + "Proceeding with 'localhost'.", e); } } </code><technical_language> Please remove this. This is probably due to an incorrect /etc/hosts file in your test environment </technical_language>
code&comment2code: <code> <START> protected OSImageToImage(JustProvider provider) { <END> this.provider = provider; } </code><technical_language> Make it package private by removing the protected modifier. </technical_language>
code&comment2code: <code> private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) { <START> Optional<Cookie> cookie = <END> Arrays.stream(httpClient.getState().getCookies()) .filter(c -> cookieName.equals(c.getName())) .findFirst(); return cookie; } </code><technical_language> return immediately, no need to store it in a local var </technical_language>
code&comment2code: <code> public void destroy() { for (JettyHttpClient client : clients) { client.close(); } if (pool != null) { pool.close(); pool = null; <START> if(injector.getExistingBinding(Key.get(MBeanExporter.class)) != null) { <END> injector.getInstance(MBeanExporter.class) .unexport(generatedNameOf(QueuedThreadPoolMBean.class) + "_" + name); } } destroyed.set(true); } </code><technical_language> This class is effectively a provider. Instead of doing the export directly, we should bind the JMX export when we bind IO pool and let the export happen the normal way. </technical_language>
code&comment2code: <code> private Set<String> expandRegionalChannelUris(String channelUri) { Set<String> expandedUris = null; if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC1_TXLOG_CHANNEL_URIS; } if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC2_TXLOG_CHANNEL_URIS; } <START> return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri)); <END> } </code><technical_language> you could do the difference and return in inside the if, and save 2 checks. </technical_language>
code&comment2code: <code> public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception { String sql = "SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM " + "dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)" + " AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"; testBuilder() .optionSettingQueriesForTestQuery("alter session set `%s` = true", <START> PlannerSettings.STREAMAGG.getOptionName()) <END> .sqlQuery(sql) .unOrdered() .baselineColumns("maxprice") .baselineValues(367190) .baselineValues(316347) .baselineValues(146610) .baselineValues(306996) .baselineValues(235695) .baselineValues(177819) .build().run(); } </code><technical_language> Should "planner.enable_hashagg" be set to **false** ? "planner.enable_streamagg" defaults to **true** anyway. </technical_language>
code&comment2code: <code> public boolean isType(String value) { GlusterStatus volStatus = <START> GlusterStatus.valueOf(value); <END> for (GlusterStatus status : values) { if (status.equals(volStatus)) { return true; } } return false; } </code><technical_language> This might throw IllegalArgumentException in case value doesn't match any enum constant. It's much easier to compare value to name() of enum constants: for (GlusterStatus status : values) { if (status.name().equals(value)) { return true; } } return false; </technical_language>
code&comment2code: <code> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); <START> ctx.channel().close(); <END> } </code><technical_language> ctx.close() </technical_language>
code&comment2code: <code> <START> public CloseNoOpServerProtocolHandler(String websocketPath) { <END> super(websocketPath, null, false); } </code><technical_language> remove public </technical_language>
code&comment2code: <code> public MessageView(Context context, AttributeSet attrs) { super(context, attrs); <START> setOrientation(VERTICAL); <END> } </code><technical_language> Since you are forcing the orientation, it might be a good idea to use the super.setOrientation() instead, override the setOrientation() method and only print a log or throw an exception if someone tries to mess with it </technical_language>
code&comment2code: <code> public Canvas addShapeIntoView(final Shape shape) { if (shape.getUUID() == null) { shape.setUUID(UUID.uuid()); } <START> shape.getShapeView().setUUID(shape.getUUID()); <END> getView().add(shape.getShapeView()); return this; } </code><technical_language> Shouldn't it be a part of shape#setUUID method? </technical_language>
code&comment2code: <code> public boolean getRequiredParamBoolean(final String key) throws ActionParamsException { <START> final String errMsg = "Required parameter '" + key + "' missing!"; <END> final String val = getRequiredParam(key, errMsg); try { return Boolean.parseBoolean(val); } catch (Exception e) { throw new ActionParamsException(errMsg); } } </code><technical_language> You don't need to give this string (even as other similar do) since it's the default message for getRequiredParam(key). </technical_language>
code&comment2code: <code> public void onPingFromClient(PingFromClientEvent event, EntityRef entity){ <START> if (networkSystem.getMode().isServer()) { <END> Instant end = Instant.now(); endMap.put(entity, end); updatePing(entity); } } </code><technical_language> In the @ReceiveEvent annotation and in the @RegisterSystem annotation you can specify if a event handler / all event handlers of that class are for a server or client. So you don't need to check the mode of networkSystem. </technical_language>
code&comment2code: <code> public boolean areEqual(MapObject o1, MapObject o2) { if (o1 == null ^ o2 == null) { return false; <START> } else if (o1 == o2) { <END> return true; } else { return o1.id.equals(o2.id); } } </code><technical_language> This block is useless. </technical_language>
code&comment2code: <code> public RedisMetadataStore(RedisConnectionFactory connectionFactory) { Assert.notNull(connectionFactory, "'connectionFactory' must not be null."); this.redisTemplate = new StringRedisTemplate(connectionFactory); <START> this.redisTemplate.afterPropertiesSet(); <END> } </code><technical_language> StringRedisTemplate constructor takes care of it. </technical_language>
code&comment2code: <code> public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId, long txnId, boolean isReadOnly, int hash, boolean isRollback, boolean requiresAck, boolean isRestart, boolean isForReplay) { super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay); m_hash = hash; setBit(ISROLLBACK, isRollback); setBit(REQUIRESACK, requiresAck); setBit(ISRESTART, isRestart); <START> m_toLeader = false; <END> m_ackRequestedFromSender = true; } </code><technical_language> Can you use the inherited "m_isLeaderToReplica" instead of adding a new "m_toLeader"? The message is either from leader to replica or from MPI to leader? </technical_language>
code&comment2code: <code> private CuEinvoiceDao getCuEinvoiceDao() { <START> if (ObjectUtils.isNull(null)) { <END> cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class); } return cuEinvoiceDao; } </code><technical_language> This will always return true, did you want cuEinvoiceDao instead of null here </technical_language>
code&comment2code: <code> <START> public static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) { <END> SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList()); return newEchoTagStatement(expressionList, eosToken); } </code><technical_language> Can we make this method private? </technical_language>
code&comment2code: <code> private static TextSummarizer getLocalSummarizer() throws IOException { Collection<? extends TextSummarizer> summarizers = Lookup.getDefault().lookupAll(TextSummarizer.class ); if (!summarizers.isEmpty()) { summarizerToUse = summarizers.iterator().next(); return summarizerToUse; } <START> throw new IOException("No summarizers found"); <END> } </code><technical_language> Perhaps it would be better to return null instead of throwing an exception? Nothing has really gone wrong. And then you wouldn't need that empty catch block. </technical_language>
code&comment2code: <code> public void verifyNoVideo() { if(checkIfElementOnPage(mediaNode)) <START> throw new AssertionError("Media Node is still on the page"); <END> else PageObjectLogging.log("verifyNoVideo", "Verified no video is on page", true, driver); } </code><technical_language> could you please put it in brackets to make it easier to read? </technical_language>
code&comment2code: <code> private void startOrStopGeoDataListener() { if (requireGeodata) { <START> geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA); <END> } else { geoDataSubscription.unsubscribe(); } } </code><technical_language> Is it save to assign a new subscription here without unsubscribing a potentially existing previous subscription? Or to ask different: Can you guarantee this is not called two times in a row in the activity lifecycle with requireGeodata==true? </technical_language>
code&comment2code: <code> ZipFormatter( <START> Formatters formatters, <END> FormatterUtil formatterUtil, HtmlBuilder html) { this.formatters = formatters; this.util = formatterUtil; this.html = html; } </code><technical_language> not needed. </technical_language>
code&comment2code: <code> private boolean clusterHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); return cluster != null && cluster.getArchitecture() != null <START> && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily(); <END> } </code><technical_language> I think I saw multiple ppc types in the enum: ppc, ppc64, ppcle, ppc64le </technical_language>
code&comment2code: <code> <START> protected void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException { <END> if (metaData.isIndexingDisabled()) return; boolean indexExists = indexExists(getIndexName(false, indexExt), conn); if (!indexExists) { String ddl = String.format("CREATE INDEX %s ON %s (%s)", getIndexName(true, indexExt), getTableName(), columnName); if (log.isTraceEnabled()) { log.tracef("Adding index with following DDL: '%s'.", ddl); } executeUpdateSql(conn, ddl); } } </code><technical_language> We can make this private </technical_language>
code&comment2code: <code> public Object getValue() { <START> if (value == null) { <END> return null; } else { return value; } } </code><technical_language> This should be simplified to just: >return value; </technical_language>
code&comment2code: <code> private boolean needProjectionNode (AbstractPlanNode root) { <START> if ( false == root.planNodeClassNeedsProjectionNode()) { <END> return false; } if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) { return false; } if (root instanceof AbstractReceivePlanNode && m_parsedSelect.hasPartitionColumnInGroupby()) { return false; } return true; } </code><technical_language> false == is a peculiar way to express !. BTW, peculiar is a polite way to say wrong. </technical_language>
code&comment2code: <code> public void isExecutable_HeaderCellSelected() { when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList()); <START> when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell, selectedCell2)); <END> assertTrue(handler.isExecutable(scenarioGridMock)); } </code><technical_language> just one cell please </technical_language>
code&comment2code: <code> public boolean equals(Object object) { if (object == this) { return true; } if (!(object instanceof XarSecurityRule)) { return false; } XarSecurityRule rhs = (XarSecurityRule) object; return new EqualsBuilder() .append(this.right, rhs.right) .append(this.simple, rhs.simple) <START> .append(this.securityTool, rhs.securityTool) <END> .isEquals(); } </code><technical_language> This is not really relevant IMO. It's not data of that rules, just an internal helper. In practice this is always going to be true anyway since it's a singleton component. </technical_language>
code&comment2code: <code> public static boolean containsSearchAnnotations(XClass mappedClass) { <START> List<XClass> hierarchy = ReflectionHelper.createXClassHierarchy( mappedClass ); <END> for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation( clazz ) ) { return true; } } return false; } </code><technical_language> Any reason why you added ReflectionHelper.? Might as well remove it so that we see it's a method of this very class? </technical_language>
code&comment2code: <code> private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) { int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload); assert newUsedCapacity >= 0; <START> return newUsedCapacity <= currentCapacity ? currentCapacity : newUsedCapacity; <END> } </code><technical_language> Math.max(newUsedCapacity, currentCapacity) would be a little bit clearer here. </technical_language>
code&comment2code: <code> private static void cleanShutdown() { log.info("CleanShutdown: Starting Cleanup."); shutdownServer = true; try { CorfuServerNode current = activeServer; if (current != null) { activeServer.close(); } } catch (Throwable th) { log.error("cleanShutdown: failed during shutdown", th); } <START> LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); <END> loggerContext.stop(); } </code><technical_language> This doesn't help at all, I suspect it can even cause loss of the logs. Logback already have solved the problem, and we have it enabled <LINK_0> </technical_language>
code&comment2code: <code> public void preInit(FMLPreInitializationEvent event) { <START> Log.setModLog(event.getModLog()); <END> configDir = new File(event.getModConfigurationDirectory(), "antiqueatlas"); configDir.mkdir(); extTileIdMap = ExtTileIdMap.instance(); extTileConfig = new ExtTileConfig(new File(configDir, "tileids.json")); extTileConfig.load(extTileIdMap); registerVanillaCustomTiles(); checkSaveConfig(); } </code><technical_language> As I said in the last PR (<LINK_0> that did something like this, this should use LogManager.getLogger(...). Honestly, Log#modLog should just be changed to java private static final Logger LOGGER = LogManager.getLogger(AntiqueAtlasMod.ID); </technical_language>
code&comment2code: <code> public void close() { try { if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) { LOGGER.warn("Finalize on readRaw() returned false for " + this); } <START> if (this.client.isConnected()) <END> this.client.logout(); this.client.disconnect(); } catch (Exception e) { LOGGER.warn("failed to disconnect FTPClient", e); } } </code><technical_language> Checkstyle violation:  [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces]  You can verify yourself locally using gradlew clean :spring-integration-ftp:check </technical_language>
code&comment2code: <code> protected FileType doGetType() throws Exception { <START> return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER; <END> } </code><technical_language> No extra (clutter) please. </technical_language>
code&comment2code: <code> public EquivalentHashMap( int initialCapacity, float loadFactor, Equivalence<K> keyEq, Equivalence<V> valueEq) { int capacity = 1; while (capacity < initialCapacity) capacity <<= 1; this.loadFactor = loadFactor; <START> threshold = (int)(capacity * DEFAULT_LOAD_FACTOR); <END> table = new Node[capacity]; this.keyEq = keyEq; this.valueEq = valueEq; } </code><technical_language> capacity * loadFactor maybe? </technical_language>
code&comment2code: <code> <START> private void mockSSHClient() { <END> try { doNothing().when(sshclient).connect(); doNothing().when(sshclient).authenticate(); } catch(Exception e) {} } </code><technical_language> just throw the exception upwards.. </technical_language>
code&comment2code: <code> public static String sanitizeKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); } </code><technical_language> ![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_0>](<LINK_1> </technical_language>
code&comment2code: <code> protected void dataTemplateToJsonGenerator(Object data, DataSchema schema, JsonGenerator generator, boolean order) throws IOException { if (order) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator); Data.traverse(data, callback); } else { <START> objectToJsonGenerator(data, generator, false); <END> } } </code><technical_language> You can revert this change now. </technical_language>
code&comment2code: <code> <START> public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException { <END> ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this); response.setResponseName(getCommandName()); setResponseObject(response); } </code><technical_language> these exceptions are unacceptable (intended pun miserably failed) we are listing clusters, no resource-, allocation-, or any change related exception should ever occur. at most a entity not found kind of thing. </technical_language>
code&comment2code: <code> public void loggedInUserPropertyFalseTest() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> configurationService.setProperty("webui.user.assumelogin", false); context.restoreAuthSystemState(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get("/api/authn/status") .header("X-On-Behalf-Of", eperson.getID())) .andExpect(status().isBadRequest()); context.turnOffAuthorisationSystem(); configurationService.setProperty("webui.user.assumelogin", true); context.restoreAuthSystemState(); } </code><technical_language> the turnOff is not really needed </technical_language>
code&comment2code: <code> protected void addExtraHeaders(Builder webResource) { if (additionalHeaders != null) { <START> for (String key : additionalHeaders.keySet()) { <END> webResource.header(key, additionalHeaders.get(key)); } } } </code><technical_language> Could use an entrySet. </technical_language>
code&comment2code: <code> private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) { <START> boolean newFragment = false; if (newList.size() > currentList.size()) { newFragment = true; } return newFragment; <END> } </code><technical_language> I think return (newList.size() > currentList.size()) is sufficient </technical_language>
code&comment2code: <code> void closeResultSets() throws SQLException { closeResultSets(activeResultSets); <START> <END> if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) { generatedKeysResultSet.internalClose(); } generatedKeysResultSet = null; } </code><technical_language> This is unnecessary as generatedKeysResultSet is added to activeResultSets when created </technical_language>
code&comment2code: <code> public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader, ResourceLoader resourceLoader) { if (ClassUtils.isPresent("org.apache.jasper.compiler.JspConfig", classLoader)) { try { String resourceName = getResourceName(view, environment); if (resourceLoader.getResource(resourceName).exists()) { return true; } <START> return new File("src/main/webapp", resourceName).exists(); <END> } catch (AccessControlException ex) { return false; } } return false; } </code><technical_language> The scope of this try block is broader than necessary. It only needs to contain this line. </technical_language>
code&comment2code: <code> <START> public Object visit(final AntlrBaseNode node) { <END> return node.accept(this); } </code><technical_language> Why does this return Object instead of T ? </technical_language>
code&comment2code: <code> public static void addDiskToVm(BaseDisk disk, Guid vmId) { DbFacade.getInstance().getBaseDiskDao().save(disk); VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceType.DISK, VmDeviceType.DISK, null, true, false, <START> ""); <END> } </code><technical_language> please remove alias setting (should be encapsulated in addManagedDevice </technical_language>
code&comment2code: <code> private static Throwable getConfigFailureException(ITestContext context) { Throwable t = null; for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) { ITestNGMethod m = method.getTestMethod(); if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) { <START> t = method.getTestResult().getThrowable(); <END> break; } } return t; } </code><technical_language> return here </technical_language>
code&comment2code: <code> protected String toString(Operator operator) { <START> if (Operator.STARTSWITH.equals(operator)) return LIKE; <END> return operator.toString(); } </code><technical_language> I recommend adding {} here </technical_language>
code&comment2code: <code> <START> static UberDocument toUberDocument(final Object object) { <END> if (object == null) { return null; } if (object instanceof UberDocument) { return (UberDocument) object; } if (object instanceof Iterable) { } else if (object instanceof Map) { } throw new IllegalArgumentException("Don't know how to handle type : " + object.getClass()); } </code><technical_language> This looks like a leftover and it hasn't any usage. Can we remove it? </technical_language>
code&comment2code: <code> <START> public ArgumentSplitter(String arguments) { <END> this.arguments = arguments; } </code><technical_language> There is no point exposing this constructor if there is not even a single public method. All methods are private (except for the static, which does not require a constructor to be used) </technical_language>
code&comment2code: <code> public LgoProducts getProducts() { LgoProducts products = null; try { products = this.proxy.getProducts( exchange.getNonceFactory().createValue(), exchange.getSignatureService()); <START> } catch (HttpStatusIOException e) { <END> LgoErrorAdapter.adapt(e); } return products; } </code><technical_language> please improve error handling in accordance to: <LINK_0> you should introduce and LgoException that implements HttpStatusExceptionSupport try catch adapt should be done in methods that implement generic interfaces, *Raw methods should throw our the LgoException </technical_language>
code&comment2code: <code> protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink); note.setAttachment(attachment); } catch (IOException e) { LOG.error("addAttachmentToNote, unable to create attachment: " + e.getMessage()); String message = MessageFormat.format( configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), <START> KFSConstants.BLANK_SPACE + backupLink.getLinkUrl()); <END> throw new ValidationException(message); } } </code><technical_language> Do you still need to prepend the blank space, now that you're using MessageFormat.format()? If not, then you should be able to simplify this a little further. </technical_language>
code&comment2code: <code> public Void getResult() { <START> throw new UnsupportedOperationException(getClass().getName()); <END> } </code><technical_language> This is effectively final class, so just throw new UnsupportedOperationException() </technical_language>
code&comment2code: <code> public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties) { PreferredProperties translatedPreferred = preferredProperties.translate(variable -> { <START> checkArgument(variable instanceof VariableReferenceExpression, "Expect VariableReferenceExpression"); <END> return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty(); }); return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred)); } </code><technical_language> Please add the actual type, just in case it ever fails </technical_language>
code&comment2code: <code> public ValidationResult isAnyDomainInProcess() { List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId()); for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) { if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) { return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2, <START> String.format("$status %1$s", StorageDomainStatus.Locked)); <END> } } return ValidationResult.VALID; } </code><technical_language> please put the correct status. </technical_language>
code&comment2code: <code> <START> private boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName) <END> { if (castToExpression(rowExpression) instanceof FunctionCall) { return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName); } return false; } </code><technical_language> static </technical_language>
code&comment2code: <code> public boolean hasError() { <START> return result != null && result.getType() != null && CommandResult.Type.ERROR.equals(result.getType()); <END> } </code><technical_language> We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType()); </technical_language>
code&comment2code: <code> private void setupVdsNetworkInterfaceDao() { when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock); List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface); when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn( <START> expectedVdsNetworkInterface); <END> } </code><technical_language> Why did you have to change the order of the lines here?... </technical_language>
code&comment2code: <code> <START> public void setProject(IProject project) { <END> this.project=project; } </code><technical_language> Do we need this method public ? The place where it's used is in the same package so protected/default should work ? </technical_language>
code&comment2code: <code> public List<String> values(String name) { <START> return headers == null ? null : headers.get("Request-Id"); <END> } </code><technical_language> I think this should be headers.get(name). </technical_language>
code&comment2code: <code> <START> @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) { <END> Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability(); return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED); } </code><technical_language> dude </technical_language>
code&comment2code: <code> public void cleanup() { <START> myIdeFrame = <END> null; myNavigationHelper.cleanup(); myNavigationHelper = null; myStateComponent = null; myTaskContext = null; } </code><technical_language> Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :) </technical_language>
code&comment2code: <code> <START> public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) { <END> DateTime beginValidTime = beginValidTimeArg; final DateTime now = new DateTime(); if (beginValidTime == null || beginValidTime.isAfter(now)) { beginValidTime = now; } if (beginValidTime.isAfter(issueInstant)) { if (issueInstant.isAfter(now)) { beginValidTime = now; } } else { beginValidTime = issueInstant; } return beginValidTime; } </code><technical_language> Why is this public? </technical_language>
code&comment2code: <code> private void <START> setupRestrictedNotification() <END> { final Resources res = getResources(mContext, mActiveDataSubId); final String title = res.getString(R.string.disable_tether_notification_title); final String message = res.getString(R.string.disable_tether_notification_message); showNotification(R.drawable.stat_sys_tether_general, title, message, ""); } </code><technical_language> We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it. </technical_language>
code&comment2code: <code> <START> private File getFeatureTypeDir( <END> File featureTypesBaseDir, String namespacePrefix, String typeName) { return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName)); } </code><technical_language> Any specific reason to make this method no static anymore ? </technical_language>
code&comment2code: <code> public static void setupSystemProperties() { <START> int freePort = TestUtilGit.findFreePort(); <END> System.setProperty("org.uberfire.nio.git.daemon.port", String.valueOf(freePort)); logger.info("Git port used:{}", freePort); System.setProperty("org.uberfire.nio.git.daemon.enabled", "false"); System.setProperty("org.uberfire.nio.git.ssh.enabled", "false"); System.setProperty("org.uberfire.sys.repo.monitor.disabled", "true"); } </code><technical_language> Just a note about consistency: does it make any sense to find free port and set system property if you're setting org.uberfire.nio.git.daemon.enabled=false on the lines below that? </technical_language>
code&comment2code: <code> public void setPreferredAgencies(String s) { if (s != null && !s.equals("")) <START> preferredAgencies = Sets.newHashSet(s.split(",")); <END> } </code><technical_language> "This method is not actually very useful and will likely be deprecated in the future." </technical_language>
code&comment2code: <code> synchronized void updateSubscribedTopics(final Set<String> topics, final String logPrefix) { <START> log.debug("{}found {} topics possibly matching subscription", logPrefix, topics.size()); <END> subscriptionUpdates.clear(); subscriptionUpdates.addAll(topics); log.debug("{}updating builder with {} topic(s) with possible matching regex subscription(s)", logPrefix, subscriptionUpdates.size()); setRegexMatchedTopicsToSourceNodes(); setRegexMatchedTopicToStateStore(); } </code><technical_language> Thanks for the PR! I just noticed these two log messages are completely redundant; can we remove one of them, or combine into a single log? </technical_language>
code&comment2code: <code> public void releaseCursor(Cursor cursor) { try { cursor.release(); if (cursors.remove(cursor)) { <START> if (provider.isClosed() && cursors.isEmpty()) { <END> releaseResources(); } } } catch (Exception e) { LOGGER.warn("Exception was found trying to release cursor resources. Execution will continue", e); } finally { statistics.decrementOpenCursors(); } } </code><technical_language> why not put this with an && in the previous if? </technical_language>
code&comment2code: <code> protected void doStop() { <START> autoEncryptionSupport.close(); <END> super.doStop(); LDAPCache.clear(); } </code><technical_language> Check for null missing? </technical_language>
code&comment2code: <code> <START> private Now(A a) { <END> this.a = a; } </code><technical_language> make the constructor package private instead of private to avoid going through a generated synthetic constructor. </technical_language>
code&comment2code: <code> private String getWorkspaceRelativePath(String sourcePath) { if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains("{")) { return sourcePath; } IPath absolutePath = new Path(sourcePath); IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath); if (container != null) { <START> return container.getFullPath().toPortableString(); <END> } return null; } </code><technical_language> I am not sure that toPortableString() is preferred here to just toString(). IPath.toString() makes only separator '/' for all platforms and it is what we need. Docs say that if toPortableString() is used it has to be matched with fromPortableString() when converting back to Path. toPortableString() doubles all ':' after the one that belongs to the device part (for Windows). For example "c:\one\two:x" will be transformed into "c://one/two::x". If segments have no ':' symbols, then there is no difference from toString(). However if a segment has ':' symbol, fromPortableString() is necessary to restore the original path, even for Linux. </technical_language>
code&comment2code: <code> private void buildErrataDetailPanel() { errataDetailPanel.clear(); errataDetailFormPanel = new GeneralFormPanel(); errataTitle = new Span(); errataTitle.setStyleName(style.errataTitleLabel()); FlowPanel errataTitlePanel = new FlowPanel(); errataTitlePanel.setStyleName(style.errataTitlePanel()); errataTitlePanel.add(errataTitle); errataDetailPanel.add(errataTitlePanel); <START> errataDetailPanel.setStyleName("testtest"); <END> errataDetailPanel.add(errataDetailFormPanel); } </code><technical_language> style name wrong? should use the style.something()? </technical_language>
code&comment2code: <code> public List<String> getMoreStable(String branch) { int i = order.indexOf(fullName(branch)); if (0 <= i) { <START> return order.subList(i + 1, order.size()); <END> } else { return Collections.emptyList(); } } </code><technical_language> This subList should not be mutable to the caller. </technical_language>
code&comment2code: <code> public void notifyListeners(int eventType, Event event) { if <START> (this.dropdownTableViewer != <END> null && !this.dropdownTable.isDisposed()) this.dropdownTable.notifyListeners(eventType, event); } </code><technical_language> why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table. </technical_language>
code&comment2code: <code> public static void setup() throws Exception { <START> assumeTrue("Skipping tests since Hive supports only JDK 8.", HiveTestUtilities.supportedJavaVersion()); <END> startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName()); prepHiveConfAndData(); setSqlStdBasedAuthorizationInHiveConf(); startHiveMetaStore(); startDrillCluster(true); addHiveStoragePlugin(getHivePluginConfig()); addMiniDfsBasedStorage(new HashMap<>()); generateTestData(); } </code><technical_language> Can't we move check to BaseTestHiveImpersonation and extend from some common Hive test class? </technical_language>
code&comment2code: <code> public OrderType retireOrderType(OrderType orderType, String reason) { orderType.setRetired(true); <START> orderType.setRetireReason(reason); <END> return dao.saveOrderType(orderType); } </code><technical_language> these fields are already set by AOP in RetireSaveHandler and this needs to delegate to saveOrderType instead of calling the DAO just in case there is extra logic in the save method we don't want to by pass </technical_language>
code&comment2code: <code> private void updateFiltersCheckState() { Object[] children = filterContentProvider .getElements(getContentService()); ICommonFilterDescriptor filterDescriptor; INavigatorFilterService filterService = getContentService() .getFilterService(); for (Object <START> element : <END> children) { filterDescriptor = (ICommonFilterDescriptor) element; if(filterService.isActive(filterDescriptor.getId())) { getTableViewer().setChecked(element, true); getCheckedItems().add(element); } else { getTableViewer().setChecked(element, false); } } } </code><technical_language> rename 'child'? </technical_language>
code&comment2code: <code> public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) { <START> FeatureTypeStyle style = transform(styleContext); <END> for (Rule rule : style.rules()) { if (minScaleDenominator != null) { rule.setMinScaleDenominator(minScaleDenominator); } if (maxScaleDenominator != null) { rule.setMaxScaleDenominator(maxScaleDenominator); } } return style; } </code><technical_language> This may return null if layer visibility = false </technical_language>
code&comment2code: <code> public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets, Collection<RevCommit> starters) throws MissingObjectException, IncorrectObjectTypeException, IOException { walk.reset(); <START> walk.setRetainBody(false); <END> if (topoSort) { walk.sort(RevSort.TOPO); } for (RevCommit target: targets) { walk.markStart(target); } for (RevCommit starter : starters) { walk.markUninteresting(starter); } return Optional.ofNullable(walk.next()); } </code><technical_language> The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it. </technical_language>
code&comment2code: <code> <START> public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) { <END> return trackableSession == null ? Optional.empty() : Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession)); } </code><technical_language> shouldn't trackableSession be an Optional? Either they are both or none are for me  actually, I don't think we really need to introduce Optional here, it is the caller that should be careful of not calling this with a null value! </technical_language>
code&comment2code: <code> public Response awaitResponse() throws Exception { <START> return Objects.requireNonNull(remoteFuture).get(); <END> } </code><technical_language> I don't see any advantage of using requireNonNull() </technical_language>
code&comment2code: <code> static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) { <START> if (!methodNode.name.equals("<init>")) { <END> return false; } final Type[] argumentTypes = Type.getMethodType(methodNode.desc) .getArgumentTypes(); if (argumentTypes.length < 2) { return false; } return "kotlin.jvm.internal.DefaultConstructorMarker" .equals(argumentTypes[argumentTypes.length - 1].getClassName()); } </code><technical_language> "<init>".equals() is null safe and consistent to the last check in this method. </technical_language>
code&comment2code: <code> public void increment(long amount) { long now = clock.now() / 1000L; <START> if (now != currentSecond.get()) { <END> currentCount.set(0); } long count = currentCount.addAndGet(amount); updatePeak(count); } </code><technical_language> Where is currentSecond being updated? </technical_language>
code&comment2code: <code> public static void assertValidSubmodulePath(String path) throws SubmoduleValidationException { if (path.startsWith("-")) { throw new SubmoduleValidationException( MessageFormat.format( JGitText.get().submodulePathInvalid, path), <START> ObjectChecker.ErrorType.GITMODULES_PATH); <END> } } </code><technical_language> Ack </technical_language>
code&comment2code: <code> public String getMessage() { <START> String ret = super.getMessage(); <END> if (pql.isPresent()) { ret += " with pql \"" + pql.get() + "\""; } return ret; } </code><technical_language> ret -> message </technical_language>
code&comment2code: <code> protected AbstractGraphDecorator(Graph g) { if (g == null) { <START> throw new NullPointerException("g may not be null."); <END> } this.inner = g; } </code><technical_language> Minor suggestion to change this exception to:  throw new IllegalArgumentException("g may not be null."); </technical_language>
code&comment2code: <code> public boolean isDTS() { <START> return getCodecA() != null && (getCodecA().startsWith("dts") || "dca".equals(getCodecA()) || "dca (dts)".equals(getCodecA())); <END> } </code><technical_language> return getCodecA() != null && ("dts".contains(getCodecA()) || "dca".contains(getCodecA())); </technical_language>
code&comment2code: <code> <START> public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { <END> return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); } </code><technical_language> This one shouldn't be public. </technical_language>
code&comment2code: <code> public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) { if (percent < 0f) { percent = 0f; } else if (percent > 200f) { percent = 200f; } brightness = percent / 100f; <START> changeShader = true; <END> refreshTextures(); } </code><technical_language> Please, change as discussed. </technical_language>
code&comment2code: <code> <START> public Handles setForceEndTransactions(boolean forceEndTransactions) { <END> this.forceEndTransactions = forceEndTransactions; return this; } </code><technical_language> This is a backwards incompatible change and cannot be merged. </technical_language>
code&comment2code: <code> protected Cause createUpstreamCause(Run<?, ?> build) { if(Jenkins.getInstance().getPlugin("promoted-builds") != null) { if(build instanceof Promotion) { Promotion promotion = (Promotion)build; return new UpstreamCause((Run<?,?>)promotion.getTarget()); } } <START> return new UpstreamCause((Run) build); <END> } </code><technical_language> You should remove obsolete class casts </technical_language>
code&comment2code: <code> public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) { if (d1 == null) { return d2 == null; } else if (d2 == null) { return false; } <START> return (d1 instanceof Timestamp || d2 instanceof Timestamp) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2); <END> } </code><technical_language> Wouldn't it actually be better to check if instance of Date and then delegate to compare(Date, Date)? </technical_language>
code&comment2code: <code> public boolean equals( Object obj ) { if ( this == obj ) { return true; } if ( obj == null ) { return false; } if ( getClass() != obj.getClass() ) { return false; } final HeapObject other = (HeapObject) obj; if ( node == null ) { return other.node == null; } <START> else return node.equals(other.node); <END> } </code><technical_language> You don't need the else clause because the if clause does a return. </technical_language>
code&comment2code: <code> public void testSignalIntermediateThrow() throws Exception { KieBase kbase = createKnowledgeBase("BPMN2-IntermediateThrowEventSignal.bpmn2"); ksession = createKnowledgeSession(kbase); Map<String, Object> params = new HashMap<String, Object>(); params.put("x", "MyValue"); ProcessInstance processInstance = ksession.startProcess( "SignalIntermediateEvent", params); <START> Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED); <END> } </code><technical_language> I think in this class it is possible. </technical_language>
code&comment2code: <code> public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash) { this.maxSize = maxSize; this.hllBuckets = hllBuckets; this.minhash = requireNonNull(minhash, "minhash is null"); hllsTotalEstimatedInMemorySize = 0; hllsTotalEstimatedSerializedSize = 0; <START> for (HyperLogLog hll : minhash.values()) { <END> increaseTotalHllSize(hll); } } </code><technical_language> nit: how about minhash.values().stream().forEach(this:: increaseTotalHllSize)? </technical_language>
code&comment2code: <code> public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException { <START> final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey(); <END> try { return projectControl.controlFor(projectKey, user).controlFor(change); } catch (NoSuchProjectException e) { throw new NoSuchChangeException(change.getId(), e); } } </code><technical_language> This is dumb. Add a Project.Id form to ProjectControl.GenericFactory and ProjectControl.Factory. That way we only have to perform 1 cache lookup, not 2. </technical_language>
code&comment2code: <code> public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (ShareFragmentListener) activity; } catch (ClassCastException e) { <START> throw new ClassCastException(activity.toString() <END> + " must implement OnShareFragmentInteractionListener"); } } </code><technical_language> Should throw IllegalStateException , or similar. </technical_language>
code&comment2code: <code> <START> public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) { <END> if (variables == null || variables.isEmpty()) { return; } Task task = event.getTask(); List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT); AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate()); sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2); } </code><technical_language> I wonder why we don't emit an event in this case. Another thing is that I think in this case (using JMS) we will update autitTaskImpl in the database, but we currently don't update it in case we use normal JPA LifeCycleListener for tasks. Isn't this a little bit inconsistent? <LINK_0> Here we just index and persist variables. </technical_language>
code&comment2code: <code> public RubyGemParser(IFile file) throws IOException, CoreException { mSetupDefinitions = new HashMap<String, ArrayList<Object>>(); mSetupDependencies = new HashMap<String, ArrayList<Object>>(); <START> if (file.getContents().available() <= 0) <END> return; this.file = file; gemVariable = ""; parse(); } </code><technical_language> Remember to put {} around if/else/while/for etc. </technical_language>
code&comment2code: <code> public boolean canHandle(Message<?> message) { <START> return super.canHandle(message) && deadlineNameMatch((DeadlineMessage) message); <END> } </code><technical_language> I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification. </technical_language>
code&comment2code: <code> private void checkImportedSymbol(Symbol symbol) { for (IdentifierTree usageIdentifier : symbol.usages()) { Tree parent = usageIdentifier.parent(); <START> if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) { <END> reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } } } </code><technical_language> This approach won't work if all the classes of a project are in a single root package:  package org; import org.B; class A { org.B b; // should be noncompliant }   package org; class B { ... }  You probably should rather rely on the type of the symbol associated to the identifier of the parent member select, if the parent is a member select.  if (parent.is(Kind.MEMBER_SELECT)) { ExpressionTree expression = ((MemberSelectExpressionTree) parent).expression(); if (expression.is(Kind.MEMBER_SELECT) && !((MemberSelectExpressionTree) expression).identifier().symbol().isTypeSymbol()) { return; } reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } </technical_language>
code&comment2code: <code> public void jmsPort_shouldBeExportedWithCorrectId() throws Exception { <START> if (!featuresService.isInstalled(featuresService.getFeature("openengsb-ports-ws"))) { <END> featuresService.installFeature("openengsb-ports-jms"); } OutgoingPort serviceWithId = OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, "jms-json", 60000); assertNotNull(serviceWithId); } </code><technical_language> maybe, if @ Before doesn't work, create a method setUp for this? since the same code lines are in the beginning of each test of this class </technical_language>
code&comment2code: <code> private EventHandler createContextEventHandler() { if (contextEventHandler == null) { contextEventHandler = <START> new EventHandler() { <END> @Override public void handleEvent(Event event) { handleContextSet(event); } }; } return contextEventHandler; } </code><technical_language> we have lambdas for this now. </technical_language>
code&comment2code: <code> public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) { <START> super(dex, in); this.dex = dex; <END> } </code><technical_language> Make the "super" dex field protected and remove this one? Or a protected getDexBuffer() method? </technical_language>
code&comment2code: <code> protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) { BlobHolder bh = new SimpleBlobHolder(blob); <START> bh = convertToMimeType(destinationMimeType, bh, new HashMap<String, Serializable>()); <END> if (bh == null) { return null; } Blob result = bh.getBlob(); return result; } </code><technical_language> You can pass null instead of new HashMap<String, Serializable>(). </technical_language>
code&comment2code: <code> private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() { Set<SupportedAdditionalClusterFeature> featuresSupported = <START> new HashSet<SupportedAdditionalClusterFeature>(getVdsGroup().getAddtionalFeaturesSupported()); <END> featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId())); return featuresSupported; } </code><technical_language> i don't think redeclaring the type on the right side is needed. </technical_language>
code&comment2code: <code> static void runScript(String filename, Connection cx) throws SQLException { try { SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx); } catch (IOException e) { <START> <END> } } </code><technical_language> Eeek, eatin away exceptions? </technical_language>
code&comment2code: <code> public void recycleAttributes(long ts) { <START> fPoolAttributes.entrySet().stream().forEach(e <END> -> { NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts); }); } </code><technical_language> why stream? entrySet is iterable. </technical_language>
code&comment2code: <code> public boolean hasNext() { <START> if (next == null) { <END> checkInvariants(); if (iterator.isValid()) { next = new AbstractMap.SimpleEntry( serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime), serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime)); iterator.next(); } else { iterator.close(); } } return next != null; } </code><technical_language> please invert if condition </technical_language>
code&comment2code: <code> public int run() throws IOException { int b; if (in != null) { <START> while ((b = in.read()) != -1) out.write(b); <END> in.close(); } out.close(); return -1; } </code><technical_language> Missing braces </technical_language>
code&comment2code: <code> public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException { return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class) <START> .add(Restrictions.eq("voided", false)) <END> .createAlias("members", "m") .createAlias("m.patientId", "p") .add(Restrictions.eq("p.patientId", patientId)) .list(); } </code><technical_language> Do you have a voided field in this cohort_member table? In theory members don't get removed from the set. You might need to update Cohort.removeMember() to set stop date instead of removing. Which means that getCohortsContainingPatientId() should return cohorts that contain the patient as of the current date i.e members that have no stop date or those where the startDate is before current date and end date is after current date </technical_language>
code&comment2code: <code> protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException { try { if (dataSink != null) { tupleWriter.open(dataSink.getOutputStream()); } <START> tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames()); <END> } catch (IOException e) { throw new DbException(e); } } </code><technical_language> How can this succeed if tupleWriter.open() isn't called (when dataSink is null)? </technical_language>
code&comment2code: <code> public long getSizeInBytes() { long sizeInBytes = 0; <START> int partitionCount = partitionFunction.getPartitionCount(); <END> for (int i = 0; i < partitionCount; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; } </code><technical_language> use partitionData.length for consistency with getRetainedSizeInBytes  public long getSizeInBytes() { long sizeInBytes = 0; for (int i = 0; i < partitionData.length; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; } </technical_language>
code&comment2code: <code> public FixedRealVarImpl(String name, double value, Model model) { <START> super(name, model); this.lb = value; this.ub = value; <END> } </code><technical_language> Replace by this(name, value, value, model); </technical_language>
code&comment2code: <code> public void isGreaterThan() { assertTrue(V3_0.isGreaterThan(of(2, 0))); assertFalse(V3_0.isGreaterThan(of(3, 0))); assertFalse(V3_0.isGreaterThan(of(4, 0))); assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1)); <START> assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2)); <END> } </code><technical_language> I'd expect this to be the other way around, when version is a WAN version. I'm thinking about subclassing Version. That way we can create ClusterVersion and WanVersion that can - compare/sort the versions properly, - validate that once we set a cluster version, it can't be replaced by a WAN version (checking the sign bit) and vice-versa. WDYT? </technical_language>
code&comment2code: <code> private String extractDefinitionLine(String typeDeclaration) { String typeLine = ""; String[] lines = typeDeclaration.split("\n"); for (String line : lines) { typeLine = typeLine + "\n" + line; if (line.contains("{")) { break; } } return typeLine; <START> } <END> </code><technical_language> I think that it is ok, although I am not sure how I feel about including the "\n". </technical_language>
code&comment2code: <code> public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) { super(material, renderIndex, slot); setHasSubtypes(true); <START> this.maxStackSize = 64; <END> this.maskType = maskType; ItemRegistry.maskMap.put(maskType, this); } </code><technical_language> stackable armo(u)r? </technical_language>
code&comment2code: <code> private void onSuccess() { <START> if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) { <END> logger.info("Resetting the error count of BlobStore {} because restart or one operation succeeded", storeId); } } </code><technical_language> I don't understand the if here. If the errorCount() was higher or equal to config.storeIOErrorCountToTriggerShutdown, won't the store be shutting/shut down? </technical_language>
code&comment2code: <code> private ApplicationReportModel createAppDependencyGraphReport(GraphContext context) { <START> ApplicationReportService applicationReportService = new ApplicationReportService(context); <END> ApplicationReportModel report = applicationReportService.create(); report.setReportPriority(104); report.setReportIconClass("glyphicon glyphicon-tree-deciduous"); report.setTemplatePath(TEMPLATE); report.setTemplateType(TemplateType.FREEMARKER); report.setDisplayInApplicationReportIndex(Boolean.TRUE); report.setDescription(REPORT_DESCRIPTION); return report; } </code><technical_language> Perhaps the '104' could be a constant? </technical_language>
code&comment2code: <code> private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException { if (client == null) { LOG.info("Connecting to the ElasticSearch cluster: " + configuration.getClusterName()); if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) { client = createClient(); } else { <START> LOG.info("Incorrect ip address and port parameters settings for ElasticSearch cluster"); <END> } } } </code><technical_language> Should this not be WARN or some exception thrown? Instead of logging that the ip is incorrect. And maybe this validation should be done in the doStart method so its validated earlier </technical_language>
code&comment2code: <code> protected String getRemoveQosMessage(int size) { <START> return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(); <END> } </code><technical_language> shouldn't the message get the 'size'? </technical_language>
code&comment2code: <code> public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) { Map<Guid, List<DiskImage>> retVal = new HashMap<>(); <START> images.stream().forEach(image <END> -> MultiValueMapUtils.addToMap(image.getId(), image, retVal)); retVal.values().forEach(ImagesHandler::sortImageList); return retVal; } </code><technical_language> Just use images.forEach </technical_language>
code&comment2code: <code> protected boolean moveToState(STATE to) { if (state.get() == to) { <START> return false; <END> } return moveToState(state.get(), to); } </code><technical_language> What is the contract for the return of this method? If we are already at the state that we are trying to move to, it could be said that the moveToState is successful (i.e. true). </technical_language>
code&comment2code: <code> public void writeTo(Resource file) throws JDOMException, IOException { OutputStream out = path.out(); try { IOUtils.write(body, out); } finally { out.close(); <START> } <END> } </code><technical_language> @NielsCharlier try-with-resources? </technical_language>
code&comment2code: <code> <START> public ApplicationFetchException(String apiKey, ErrorCode errorCode) { <END> super(); this.apiKey = apiKey; this.errorCode = errorCode; } </code><technical_language> The class is abstract. Constructor should be protected </technical_language>
code&comment2code: <code> private void addResource(final BackendResource resource) { resource.setMessageBundle(messageBundle); resource.setBackend(backend); resource.setSessionHelper(sessionHelper); if (resource instanceof AbstractBackendResource) { ((AbstractBackendResource) resource).setMappingLocator(mappingLocator); } else if (resource instanceof CapabilitiesResource) { ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator); } <START> resource.setValidatorLocator(validatorLocator); <END> singletons.add(resource); } </code><technical_language> using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource. </technical_language>
code&comment2code: <code> public boolean isEmpty() { <START> synchronized (listeners) <END> { return listeners.size() == 0; } } </code><technical_language> listeners is atomic </technical_language>
code&comment2code: <code> void setEnd(int end) { this.end = end; <START> if (this.end > this.maxSeen) <END> { this.maxSeen = this.end; } } </code><technical_language> Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the maxSeen, and prevent the maxSeen from being set if the end has been set. However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method. </technical_language>
code&comment2code: <code> public void dispose() { <START> this.mHandler.removeCallbacksAndMessages(null); <END> this.mHandler = null; this.mPhone = null; } </code><technical_language> > Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2 </technical_language>
code&comment2code: <code> public boolean indexShareable() { TypedProperties properties = properties(); boolean hasRamDirectoryProvider = false; boolean hasOtherDirectoryProvider = false; for (Object objKey : properties.keySet()) { String key = (String) objKey; if (key.endsWith(DIRECTORY_PROVIDER_KEY)) { if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) { hasRamDirectoryProvider = true; } else { <START> hasOtherDirectoryProvider = true; <END> } } } boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider; return !ramOnly; } </code><technical_language> a couple of questions: - can't you return true here? - is it possible to configure multiple directory providers? </technical_language>
code&comment2code: <code> public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata ) throws TransferException { final Transfer item = getCacheReference( resource ); if ( !resource.allowsDeletion() ) { throw new TransferException( "Deletion not allowed for: {}", resource ); <START> } <END> return doDelete( item, eventMetadata ); } </code><technical_language> move this to the first line of this method for optimization. </technical_language>
code&comment2code: <code> public String getActualCpuTopology() { <START> if (actualCpuTopology < 0) { <END> return ConstantsManager.getInstance().getConstants().notAvailableLabel(); } else { return String.valueOf(actualCpuTopology); } } </code><technical_language> when will it be < 0? isnt it better to use Integer that can be null? (like other fields in vm dynamic) </technical_language>
code&comment2code: <code> public void onPageScrolled(int i, float v, int i2) { if (pager.getCurrentItem() != 0) { speakerbox.stop(); } if (pager.getCurrentItem() == pagerPositionWhenPaused) { resume.setVisibility(View.GONE); <START> getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext() <END> .getResources().getColor(R.color.transparent_white)); } } </code><technical_language> Oh I see now it does get slightly darker when you manually page. It was so subtle I didn't see it at first. </technical_language>
code&comment2code: <code> public void benchWavTrack() throws Exception { WavTrack wavTrack = new WavTrack(url); boolean isEOMReached = false; while (!isEOMReached) { Frame process = wavTrack.process(0); isEOMReached = process.isEOM(); } <START> wavTrack.close(); <END> } </code><technical_language> If an exception can be thrown, then wrap wavTrack.close() in a try-finally block, to guarantee resources are properly closed. </technical_language>
code&comment2code: <code> private static void setupLogger(Map<String, Object> args) throws IOException{ String logfile = (String)args.get("log-file"); Logger logger = Logger.getLogger(""); logger.setLevel((Level)args.get("log-level")); logger.addHandler(new ConsoleHandler()); if(logfile != null) { FileHandler fh = new FileHandler(logfile); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); <START> } <END> } </code><technical_language> aren't these already set by logging.properties? </technical_language>
code&comment2code: <code> public XWikiAttachment set(XWikiAttachment attachment) { XWikiAttachment put = map.put(attachment.getFilename(), attachment); <START> if (put == null || !put.equals(attachment)) { <END> added(attachment); updatedMap(); } return put; } </code><technical_language> I would use == instead of equals. XWikiAttachment don't implement equals and even if they were is might be super slow (they would have to compare sometime big files contents). Then no need for put == null anymore since the input cannot be null. </technical_language>
code&comment2code: <code> <START> public boolean equals(Object obj) { <END> if (obj instanceof MethodKey) { MethodKey toCompare = (MethodKey) obj; return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes); } return false; } </code><technical_language> final, here and elsewhere </technical_language>
code&comment2code: <code> MongoDBTracing(Builder builder) { tracing = builder.tracing; maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength; <START> commandsWithCollectionName = Collections.unmodifiableSet(builder.commandsWithCollectionName); <END> } </code><technical_language> Copy into a new set too, the user will still be able to modify the set through the builder. </technical_language>
code&comment2code: <code> public void disconnect() { <START> Object lock = partitions != null ? partitions : new Object(); <END> synchronized (lock) { document = null; partitions = null; try { inputStream.close(); } catch (IOException e) { } } } </code><technical_language> this makes no sense. synchronizing on a new object is meaningless. I do not know why partitions must be null, if we want synchronize on this object, we should make it final and never null, instead simply clear() them on dispose </technical_language>
code&comment2code: <code> private void printInfo(String sizeMessage, String inAlluxioMessage, String inMemMessage, String path) { <START> System.out.println(inMemMessage.equals("") <END> ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path) : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path)); } </code><technical_language> can use inMemMessage.isEmpty() </technical_language>
code&comment2code: <code> public void tearDown() { <START> MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry); <END> metricsService.init(nodeEngineMock, new Properties()); metricsService.shutdown(true); JmxLeakHelper.checkJmxBeans(); if (executionService != null) { executionService.shutdown(); } } </code><technical_language> I think alternatively we can move out the construction of the service from the test cases into a factory method that sets a shutdown function object field that we can call in the tearDown. This may prevent some other unwanted potential side-effects. With this approach we construct two services, but shutdown only one. For example, the service submits a scheduled task. I think it is fine for now, but it would be safer with the function proposed. </technical_language>
code&comment2code: <code> public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) { WebElement element = getWebElement(slotName); <START> boolean isMobile = src.toUpperCase().equals("MOBILE"); <END> Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile)); PageObjectLogging.log("verifyAdImage", "Ad looks good", true, driver); return this; } </code><technical_language> swap the left and right for the equals to avoid NullPointerException also, use equalsIgnoreCase instead  "MOBILE".equalsIgnoreCase(src); </technical_language>
code&comment2code: <code> <START> public Set<String> getUnmatchedLabels() { <END> return Collections.unmodifiableSet(unmatchedLabels); } </code><technical_language> Missing synchronization? </technical_language>
code&comment2code: <code> public void scanForRepoChanges() throws IOException { refs.refresh(); <START> getAllRefs(); <END> if (!isBare()) getIndex(); } </code><technical_language> This shouldn't be necessary anymore. RefDirectory.refresh() should trigger an event listener if one or more refs was detected to be modified, which means we can drop the getAllRefs() call here. </technical_language>
code&comment2code: <code> public List<Server> getReachableServers() { <START> return getServerList(true); <END> } </code><technical_language> In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean. </technical_language>
code&comment2code: <code> protected Guid getStoragePoolId() { <START> return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId(); <END> } </code><technical_language> Might throw an IndexOutOfBound if no the storage domain is not attached to any storage pool </technical_language>
code&comment2code: <code> <START> private Integer prerequirementImgResource(String group) { <END> if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) { return R.drawable.rank_prerequirement; } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) { return R.drawable.group_prerequirement; } else { return R.drawable.empty; } } </code><technical_language> Why returning Integer instead of plain int? </technical_language>
code&comment2code: <code> public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException { checkBounds(pImageIndex); <START> return Collections.singletonList(getRawImageType(pImageIndex)).iterator(); <END> } </code><technical_language> The TODO above the changed line indicates the reason for using a multi value list here... But of course, we could change this until we actually return multiple values. </technical_language>
code&comment2code: <code> <START> public void resetPositions(int positionCount) <END> { positions = ensureCapacity(positions, positionCount); this.positionCount = 0; } </code><technical_language> For better readability i would sort the methods in the way they are used resetPositions -> addPosition -> appendData -> flush. Please also order the private methods accordingly: Method that uses a private method - > private method </technical_language>
code&comment2code: <code> public static SelectorHandler getHandler(final String selectorStr) { if (!selectorStr.isEmpty()) <START> for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) <END> if (selectorStr.startsWith(handler.getKey())) return handler.getValue(); return vanillaHandler; } </code><technical_language> Why selectorStr.substring(0, 1) </technical_language>
code&comment2code: <code> public synchronized void close() { if (closed) { return; } closed = true; <START> if (parentMemoryContext != null) { <END> parentMemoryContext.updateBytes(-usedBytes); } usedBytes = 0; } </code><technical_language> This if is redundant. Question for you, @nezihyigitbasi: Do you see IntelliJ "warning"s for this? If not, you should turn those on. </technical_language>
code&comment2code: <code> <START> public Map<K, V> getEntries() { <END> return (Map<K, V>) entries; } </code><technical_language> Change seems unneeded. And actually the unchecked can be removed as well. </technical_language>
code&comment2code: <code> public void testDefaultConfig() throws Exception { Files.write(springTestFile.toPath(), "modification".getBytes(), StandardOpenOption.SYNC); Thread.sleep(50); Files.write(springTestFile.toPath(), "modification 2".getBytes(), StandardOpenOption.SYNC); MockEndpoint mock = getMockEndpoint("mock:springTest"); <START> mock.setExpectedCount(1); <END> mock.setResultWaitTime(1000); mock.assertIsSatisfied(); } </code><technical_language> Why are you changing expectation, when no related production code changed? There should be really two events (modification and modification 2) Please note that this test is platform dependent. We are targetting to Linux and CI reports no issues or flakes with this test. Which OS are you running tests? Last CI build is here: <LINK_0> </technical_language>
code&comment2code: <code> private boolean startsOrEndsWithWhitespace(String value) { boolean startsOrEndsWithWhitespace = false; <START> if (value != null && StringUtils.isNotBlank(value)) { <END> int lastIndex = value.length() - 1; if (Character.isSpaceChar(value.charAt(0))) { startsOrEndsWithWhitespace = true; } else if (Character.isSpaceChar(value.charAt(lastIndex))) { startsOrEndsWithWhitespace = true; } } else { startsOrEndsWithWhitespace = false; } return startsOrEndsWithWhitespace; } </code><technical_language> Isn't isNotBlank already checking for null? </technical_language>
code&comment2code: <code> private void updateData(OCShare share) { share.setPath(mPath); <START> if (mPath.endsWith(FileUtils.PATH_SEPARATOR)) { <END> share.setIsFolder(true); } else { share.setIsFolder(false); } share.setPermissions(READ_ONLY); getStorageManager().saveShare(share); OCFile file = getStorageManager().getFileByPath(mPath); if (file!=null) { file.setShareWithSharee(true); getStorageManager().saveFile(file); } } </code><technical_language> This Block can be shortened to share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR)) </technical_language>
code&comment2code: <code> protected void startMasters(boolean isLeader) { try { connectToUFS(); mRegistry.start(isLeader); } catch (IOException e) { <START> LOG.error("Failed to start master.", e); <END> throw Throwables.propagate(e); } } </code><technical_language> does the propagated exception not get logged? This looks like it would result in logging the same thing twice </technical_language>
code&comment2code: <code> <START> public BugzillaRestRepositoryConnectorUi() { <END> connector = BugzillaRestConnector.getDefault() == null ? new BugzillaRestConnector() : BugzillaRestConnector.getDefault(); } </code><technical_language> The default constructor should assign "null" to connector. </technical_language>
code&comment2code: <code> public static ListStatusPOptions getListStatusOptions() { <START> FileSystemMasterCommonPOptions commonOptions = <END> getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL)) .setTtlAction(GrpcUtils.toProto( Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class))) .build(); return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions) .setLoadMetadataType(GrpcUtils.toProto(Configuration .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class))) .build(); } </code><technical_language> helper for setting common options? </technical_language>
code&comment2code: <code> Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) { requireNonNull(nodeProcessor, "The nodeProcessor parameter can't be null."); this.nodeProcessor = nodeProcessor; requireNonNull(name, "The name of the node can't be null"); this.name = name; <START> requireNonNull(name, "The dag of the node can't be null"); <END> this.dag = dag; } </code><technical_language> small typo - I think name is supposed to be dag, right? </technical_language>
code&comment2code: <code> public String getTooltip(MergeMode mode) { String tooltip; switch (mode) { case LEFT_TO_RIGHT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.right.tooltip"); break; case RIGHT_TO_LEFT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.left.tooltip"); break; case ACCEPT: tooltip = EMFCompareDiagramEditMessages.getString("accept.change.tooltip"); break; case REJECT: tooltip = EMFCompareDiagramEditMessages.getString("reject.change.tooltip"); break; default: <START> throw new IllegalStateException(); <END> } return tooltip; } </code><technical_language> Here it's not the state of this class that's invalid, it's the given parameter. The relevant exception in such a case is IllegalArgumentException </technical_language>
code&comment2code: <code> <START> public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) { <END> this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null; this.upstreamFilterStrategy = upstreamFilterStrategy; this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null; } </code><technical_language> Please add an overloaded constructor to keep comparibility (like TriggerredBuildSelector(boolean)). </technical_language>
code&comment2code: <code> public Attachment(@NonNull Uri uri, @NonNull String contentType, long date, @Nullable String fileName) { <START> if (date < 0) { <END> throw new AssertionError("uri, content type, and date must all be specified"); } this.uri = uri; this.fileName = fileName; this.contentType = contentType; this.date = date; } </code><technical_language> I know these are annotated nonnull, but since this is an assertion let's leave it in </technical_language>
code&comment2code: <code> private List<VoldemortService> createServices() { List<VoldemortService> services = new ArrayList<VoldemortService>(); CoordinatorProxyService coordinator = new CoordinatorProxyService(config, storeClientConfigs); <START> services.add(coordinator); <END> if(config.isAdminServiceEnabled()) { services.add(new CoordinatorAdminService(config, storeClientConfigs)); } return ImmutableList.copyOf(services); } </code><technical_language> Just this will work too : services.add(new CoordinatorProxyService(config, storeClientConfigs)); You can save a line by not declaring a coordinator object. </technical_language>
code&comment2code: <code> public void afterBegin() throws EJBException, RemoteException { <START> log.info("afterBegin called"); <END> checker.setSynchronizedBegin(); } </code><technical_language> log.trace </technical_language>
code&comment2code: <code> private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending) { for (Integer value : pagingSpec.getPagingIdentifiers().values()) { <START> if (descending ^ value < 0) { <END> return false; } } return pagingSpec.getThreshold() >= 0; } </code><technical_language> This is a part of the java spec I'm not as familiar with. Is this doing ((descending ? 1 : 0) ^ value) < 0 or descending ^ (value < 0)? </technical_language>
code&comment2code: <code> private void init(Jdbi db) { <START> db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, "int", UserId::getId)); <END> db.registerColumnMapper(new UserIdColumnMapper()); } </code><technical_language> Can we unroll this to use the new Configurable method instead? </technical_language>
code&comment2code: <code> protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) { VdsStatic server = getVdsStaticDao().get(brick.getServerId()); <START> if ((server == null || !server.getvds_group_id().equals(getVdsGroupId())) && addCanDoActionMessage) { <END> addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID); return false; } brick.setServerName(server.gethost_name()); return true; } </code><technical_language> shouldn't it return false even if addCanDoActionMessage=false? from the name of the parameter it sounds like only the message is not needed but still give the correct return value </technical_language>
code&comment2code: <code> <START> public static <END> @NonNull String getSpanName(String attributeName) { return attributeName.substring(0, attributeName.lastIndexOf('/')); } </code><technical_language> private </technical_language>
code&comment2code: <code> private static boolean containsAll(String text, final Collection<String> items) { final String _text = text.toLowerCase(); return items.stream() <START> .allMatch((String it) -> { <END> return _text.contains(it); }); } </code><technical_language> Why do you need to type parameter ? </technical_language>
code&comment2code: <code> private void recursiveDelete(Path file) throws IOException { Files.walkFileTree(file, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException { if (e == null) { Files.delete(dir); return FileVisitResult.CONTINUE; <START> } else { throw e; } <END> } }); } </code><technical_language> This doesn't really need to be in an else clause. It might be more readable to invert the logic of this block, i.e.: if (e != null) { throw e; } Files.delete(dir); return FileVisitResult.CONTINUE; </technical_language>
code&comment2code: <code> public Optional<Object> nextMarker() { if (totalCount < pageSize) return Optional.absent(); <START> if (pageNumber < (totalCount / pageSize)) { <END> return Optional.of(toPaginationOptions(pageNumber + 1)); } return Optional.absent(); } </code><technical_language> Does the pageNumber start at 1 or 0? If it starts at one, this conditional could be wrong: pageNumber=1, totalCount=7,pageSize=5 would return false, but there is still a next page. </technical_language>
code&comment2code: <code> public void testInvalidUser(AuthenticationFlowContext context, UserModel user) { <START> if (user == null || user.getServiceAccountClientLink() != null) { <END> dummyHash(context); context.getEvent().error(Errors.USER_NOT_FOUND); Response challengeResponse = challenge(context, getDefaultChallengeMessage(context)); context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse); } } </code><technical_language> Is it really necessary to add this check here? Doesn't the AuthenticationProcessor prevent the login request from reaching this point? </technical_language>
code&comment2code: <code> public boolean validateChecksum() { if (StringUtils.isNotBlank(checksum)) { try { return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath)); } catch (IOException e) { <START> throw new CloudRuntimeException("could not check sum for file: " + downloadedFilePath); <END> } catch (NoSuchAlgorithmException e) { throw new CloudRuntimeException("Unknown checksum algorithm: " + checksum, e); } } return true; } </code><technical_language> missing second argument to view the actual exception message/stack trace: file: " + downloadedFilePath, e) </technical_language>
code&comment2code: <code> public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) { this.address = address; if (registrations == null || registrations.isEmpty()) { this.registrations = Collections.emptyList(); } else { <START> this.registrations = Collections.unmodifiableList(registrations); <END> } } </code><technical_language> can we avoid using unmodifiableList and have the cluster manager trust the list will be not modified ? </technical_language>
code&comment2code: <code> public InvocationContext createInvocationContext(boolean isWrite, int keyCount) { if (keyCount == 1) { <START> SingleKeyNonTxInvocationContext result = <END> new SingleKeyNonTxInvocationContext(true, keyEq); return result; } else if (keyCount > 0) { NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq); return ctx; } return createInvocationContext(null); } </code><technical_language> I would remove the variables and do return new SingleKeyNonTxInvocationContext(true, keyEq); the same thing can be applied to other methods </technical_language>
code&comment2code: <code> private boolean isRealWorklog(final EveritWorklog worklog) { boolean isRealWorklog = true; if (issuesRegex != null) { <START> for (final Pattern issuePattern : issuesRegex) { <END> final boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches(); if (issueMatches) { isRealWorklog = false; break; } } } return isRealWorklog; } </code><technical_language> Remove all of the unnecessary final modifier from the local variables from all of the modified classes. </technical_language>
code&comment2code: <code> public void removed(IExtension[] extensions) { for (IExtension extension : extensions) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension); if (layoutAlgorithmProvider != null) { List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms(); for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) { layoutProviderRegistry.remove(customLayoutAlgorithm.getId()); } } <START> extensionToLayoutAlgorithmProvider.put(extension, <END> null); } } </code><technical_language> remove instead? </technical_language>
code&comment2code: <code> public void increment( int typeId ) { if ( typeId >= counts.length ) { <START> counts = Arrays.copyOf( counts, max( counts.length * 2, typeId ) ); <END> } counts[typeId]++; if ( typeId > highestTypeId ) { highestTypeId = typeId; } } </code><technical_language> This needs to be typeId + 1, since the parameter here is the _length_, while typeId is elsewhere used as an _index_. </technical_language>
code&comment2code: <code> private static void delete(List<ReceiveCommand> cmds, List<ReceiveCommand> createCmds) { for (ReceiveCommand c : createCmds) { ObjectId id = c.getNewId(); String <START> n = <END> c.getRefName(); cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n)); } } </code><technical_language> s/n/name/ n is always an index </technical_language>
code&comment2code: <code> public RefreshLocalVisitor(IProgressMonitor monitor) { this.monitor = <START> SubMonitor.convert(monitor, <END> TOTAL_WORK); workspace = (Workspace) ResourcesPlugin.getWorkspace(); resourceChanged = false; String msg = Messages.resources_errorMultiRefresh; errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null); } </code><technical_language> Use the one-argument version of convert, since the second argument passed in here is never used. </technical_language>
code&comment2code: <code> private ConfigurationImpl() { this.validationBootstrapParameters = new ValidationBootstrapParameters(); this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES ); this.defaultTraversableResolver = new DefaultTraversableResolver(); this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl(); if ( Version.getJavaRelease() >= 8 ) { <START> this.defaultParameterNameProvider = new Java8DefaultParameterNameProvider(); <END> } else { this.defaultParameterNameProvider = new DefaultParameterNameProvider(); } this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator ); } </code><technical_language> Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now. </technical_language>
code&comment2code: <code> public void testNull_Event() { XDRResponseEventType eventA = new XDRResponseEventType(); <START> XDREventType eventB = new XDREventType(); <END> eventA = null; eventB = null; assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA)); assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB)); } </code><technical_language> Do we need to declare object and then assign to null? Just remove them </technical_language>
code&comment2code: <code> public void testJNDIBindingsNoAppName() throws Exception { <START> boolean passed = false; <END> Context ctx = getInitialContext(HOST, PORT); Hello ejb = (Hello) ctx.lookup("ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"); Assert.assertNotNull("Null object returned for local business interface lookup in the ejb namespace", ejb); Assert.assertTrue("Expected JNDI binding message not found", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME, "ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello")); } </code><technical_language> Cruft, It doesn't matter, but this is an unused variable. </technical_language>
code&comment2code: <code> public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) { this.importedList = importedList; this.doParseDetails = true; this.doParseConditions = true; this.doParseFactors = true; this.doParseVariates = true; this.userDataManager = userDataManager; this.descriptionSheetIndex = 0; <START> ; <END> } </code><technical_language> remove </technical_language>
code&comment2code: <code> public VolumeClassification getVolumeClassification() { if (volumeClassification == null) { if <START> (active) <END> { return VolumeClassification.Volume; } return VolumeClassification.Snapshot; } return volumeClassification; } </code><technical_language> please change to ternary </technical_language>
code&comment2code: <code> public void registerSonarQubeVersion_publishes_version_on_first_call() { ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings()); try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) { hzCluster.registerSonarQubeVersion("1.0.0.0"); HazelcastInstance hzInstance = createHazelcastClient(hzCluster); assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get()) .isNotNull() .isInstanceOf(String.class) <START> .isEqualTo("1.0.0.0"); <END> } } </code><technical_language> no need for isNotNull nor isInstanceOf(String.class). They are both implicit with .isEqualTo("1.0.0.0") </technical_language>
code&comment2code: <code> public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) { String[] texts = new <START> String[fColumns.length]; <END> for (int i = 0; i < fColumns.length; i++) { texts[i] = fLabelProvider.getColumnText(entry, i); } return texts; } </code><technical_language> Null pointer... </technical_language>
code&comment2code: <code> protected Pageview() { <START> } <END> </code><technical_language> private </technical_language>
code&comment2code: <code> public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration, final List<PasteEObjectConfiguration> existingPasteConfigurations) { super(parentShell); this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration); this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration; this.existingPasteConfigurations = existingPasteConfigurations; <START> setTitle(org.eclipse.papyrus.customization.nattableconfiguration.messages.Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); <END> } </code><technical_language> import the class Messages ? </technical_language>
code&comment2code: <code> public void execute(final Talks talks) throws IOException { int idx = this.index(talks); for (final Talk talk : talks.active()) { <START> final int current = idx + 1; <END> talk.modify( new Directives() .xpath("/talk/request") .attr("index", Integer.toString(current)) ); idx = current; } } </code><technical_language> current is redundant, just use idx </technical_language>
code&comment2code: <code> public long getSafePointDrId() { <START> synchronized (m_map) { <END> assert (!m_map.isEmpty()); return end(m_map.asRanges().iterator().next()); } } </code><technical_language> Looks good to me, but worth to protect getFirstDrId() and getLastDrId() too, they'll throw NoSuchElementException also if m_map is empty. </technical_language>
code&comment2code: <code> public void setUp() throws Exception { createProjectWithNfcAndSetVariable(PROJECT_NAME); numDetectedTags.setValue(0); nfcBrickPosition = 0; setVariableIDPosition = 1; setVariableMessagePosition = 2; baseActivityTestRule.launchActivity(null); <START> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID); <END> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition, READ_TAG_MESSAGE); } </code><technical_language> is this necessary in the set up? wouldnt it be sufficient if this would be done once in the layout test? </technical_language>
code&comment2code: <code> public ListRequest list() { return new ListRequest() { @Override public List<ProjectInfo> get() throws RestApiException { <START> return ProjectsImpl.this.list(this); <END> } }; } </code><technical_language> I don't think ProjectsImpl.this is necessary, it would only be necessary if the method call were get(this) which conflicts with the method name in the anonymous class. </technical_language>
code&comment2code: <code> <START> public void validateEnums(WatchDog entity) { <END> EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true); EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false); } </code><technical_language> potential NPE, entity can be NULL </technical_language>
code&comment2code: <code> void error(ZuulException e) { RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); <START> LOG.error(e.getMessage(), e); <END> } </code><technical_language> My preference would be to remove e.printStackTrace() altogether and let the 'error' filters determine if they want to log the error. </technical_language>
code&comment2code: <code> private List<String> defaultIncludedModuleNamesForUnnamedModule() { if (fJavaElements != null) { List<IPackageFragmentRoot> roots= new ArrayList<>(); for (IJavaElement <START> fJavaElement : <END> fJavaElements) { if (fJavaElement instanceof IPackageFragmentRoot) { roots.add((IPackageFragmentRoot) fJavaElement); } } return JavaCore.defaultRootModules(roots); } return Collections.emptyList(); } </code><technical_language> rename to element </technical_language>
code&comment2code: <code> <START> public ResponseEntity<?> disable(@RequestBody List<Long> printerIds) throws IOException { <END> return setState(printerIds, false); } </code><technical_language> @ResponseStatus(HttpStatus.NO_RESPONSE), void return type Same for /enable </technical_language>
code&comment2code: <code> public double getFilterMinSelectivityEstimateFactor() { <START> return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR.getOptionName()).float_val; <END> } </code><technical_language> Make the option validators above typed: public static final FloatValidator FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ... and change this line to: return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR); Same for the other option. </technical_language>
code&comment2code: <code> public JavaOutputProcessor(PrettyPrinter printer) { <START> this.printer = printer; <END> this.environment = printer.getEnvironment(); } </code><technical_language> why did you need to copy the env? it is accessible via getFactory().getEnv(). </technical_language>
code&comment2code: <code> public BucketFunction getBucketFunction( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorPartitioningHandle partitioningHandle, List<Type> partitionChannelTypes, int bucketCount) { HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle; BucketFunctionType bucketFunctionType = handle.getBucketFunctionType(); switch (bucketFunctionType) { case HIVE_COMPATIBLE: return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get()); case PRESTO_NATIVE: return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get()); default: <START> throw new IllegalStateException("Unsupported bucket function type " + bucketFunctionType); <END> } } </code><technical_language> nit IllegalArgumentException </technical_language>
code&comment2code: <code> public void writePacketData(RailcraftOutputStream data) throws IOException { super.writePacketData(data); <START> tankManager.writePacketData(data); <END> data.writeBoolean(boiler.isBurning()); } </code><technical_language> This is only required in things that render the FluidStack in a TESR. </technical_language>
code&comment2code: <code> protected void setValue(final int rowIndex, final int columnIndex, final Date value) { DTCellValue52 dtCellValue52 = table52.getData() .get(rowIndex) .get(columnIndex); dtCellValue52 .setDateValue(value); try { updateManager.update(table52, getUpdates(rowIndex, columnIndex)); <START> } catch (UpdateException e) { <END> e.printStackTrace(); } } </code><technical_language> This _smells_ bad.. what was your reasoning to catch UpdateException? </technical_language>
code&comment2code: <code> private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) { return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent, <START> () -> new TreeMap<>(Comparator.comparing(Event::getExternalId).thenComparing(Event::getWhenOccured)), Collectors.toList())); <END> } </code><technical_language> suggestion () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList())); </technical_language>
code&comment2code: <code> <START> public void verifyTableProperty(String propertyName, int propertyValue) { <END> waitForElementByElement(table); Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue)); PageObjectLogging.log( "verifyTableProperty", "table has correct " + propertyName + " property", true ); } </code><technical_language> 1. set this method to private, 2. create helpers for each property </technical_language>
code&comment2code: <code> public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) { <START> this.name = name; <END> this.minValue = minValue; this.maxValue = maxValue; this.nulls = nulls; this.primitiveType = primitiveType; } </code><technical_language> Please post the examples of content for new metadata cache files to the Jira description </technical_language>
code&comment2code: <code> <START> @Override public <END> ReflogEntry getReverseEntry(int number) throws IOException { lock.lock(); try { LogCursor cursor = reftable.seekLog(refname); while (true) { if (!cursor.next() || number < 0) { return null; } if (number == 0) { return cursor.getReflogEntry(); } number--; } } finally { lock.unlock(); } } </code><technical_language> The @Override should go on a line on its own, like in getReverseEntries() and the same below. </technical_language>
code&comment2code: <code> public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource("bags/v0_98/bag").toURI()); if (System.getProperty("os.name").contains("Windows")){ <START> Path bagitDir = rootDir.resolve(".bagit"); <END> Files.setAttribute(bagitDir, "dos:hidden", Boolean.TRUE); } Bag bag = reader.read(rootDir); sut.isValid(bag, true); } </code><technical_language> the .bagit folder does not have to be hidden. .bagit is our incubating next version of the bagit spec; it solves a lot of problems from the originial spec. </technical_language>
code&comment2code: <code> public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) { <START> final AbstractStatementVisitor visitor = new PreStatementVisitor(context); <END> syntaxNode.accept(visitor); return visitor.programState; } </code><technical_language> remove final modifiers everywhere. </technical_language>
code&comment2code: <code> <START> ParameterMap getQueryParams(MuleEvent event) <END> { return resolveParams(event, HttpParamType.QUERY_PARAM); } </code><technical_language> This breaks compatibility. </technical_language>
code&comment2code: <code> public Mutation(Mutation m) { m.serialize(); this.row = m.row; this.data = m.data; <START> this.size = new MutationSize(m.size.entries, m.size.sizeInBytes); <END> this.values = m.values; this.replicationSources = m.replicationSources; } </code><technical_language> maybe make a copy constructor for this case? </technical_language>
code&comment2code: <code> public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) { <START> this(delegate, classLoader, null, null); <END> } </code><technical_language> The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0> </technical_language>
code&comment2code: <code> default Query getRemoveByQuery() { <START> if (isVersionedEntity()) { <END> return getQueryForVersion(); } return getByIdQuery(); } </code><technical_language> Ternary ? true : false. ;) </technical_language>
code&comment2code: <code> <START> public void addError(String errorMessage, Element element) { <END> errors.add(new ProblemImpl(errorMessage, name, element)); } </code><technical_language> There are still a lot of calls to this method, resulting in errors that will not reference any BPMN element. From a quick look, many of those do have an element id that we could reference. </technical_language>
code&comment2code: <code> private void validatePage() { String message = null; if (userText.getText().trim().length() == 0) message = Messages.CredentialsWizardPage_ErrorUser; <START> if (message == null && passwordText.getText().trim().length() == 0) <END> message = Messages.CredentialsWizardPage_ErrorPassword; setErrorMessage(message); setPageComplete(message == null); } </code><technical_language> Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty(). </technical_language>
code&comment2code: <code> public boolean isSupporting(Capabilities capabilities) { return BrowserType.EDGE.equals(capabilities.getBrowserName()) || capabilities.getCapability("chromeOptions") != null || <START> capabilities.getCapability("goog:chromeOptions") != null; <END> } </code><technical_language> You probably don't want to pick this if browserName is also chrome or chromium, right? Otherwise this will match: {"browserName": "chrome", "goog:chromeOptions": {}}, which isn't what you want. </technical_language>
code&comment2code: <code> public HistoryTreeStub getHistoryTree() { <START> return (HistoryTreeStub) NonNullUtils.checkNotNull(super.getSHT()); <END> } </code><technical_language> getSHT() can never actually be null, we should just annotate it. </technical_language>
code&comment2code: <code> public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) { return <START> Lists.newArrayList(Iterables.filter(Iterables.concat(trace.getEventAspects(), <END> EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass()))); } </code><technical_language> why the newArrayList? Iterables.filter already returns an iterable. </technical_language>
code&comment2code: <code> public PrestoSparkRow get() throws InterruptedException { PrestoSparkRow row; synchronized (monitor) { while (!finished && buffer.isEmpty()) { <START> monitor.wait(); <END> } if (finished) { return null; } row = buffer.poll(); } memoryManager.updateMemoryUsage(-row.getRetainedSize()); return row; } </code><technical_language> So PrestoSparkRowBuffer#get is a blocked call. Is there any reason for that -- I am asking this since the general convention in Presto seems to be using ListenableFuture<PrestoSparkRow> for such cases? </technical_language>
code&comment2code: <code> private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException { ByteBuffer pcapPacketData; pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <START> pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <END> pcapPacketData.clear(); SeekableByteChannel fFileChannel; try { fFileChannel = getFileChannel(); fFileChannel.read(pcapPacketData); } catch (BadPcapFileException e1) { } pcapPacketData.flip(); return pcapPacketData; } </code><technical_language> This is useless since clear() below resets position to zero? </technical_language>
code&comment2code: <code> public MiniEditorComponentObject triggerEditCommentArea() { jsActions.scrollToElement(allCommentsArea); WebElement mostRecentComment = articleComments.get(0); PageObjectLogging.log("First check",mostRecentComment.getText(), true); JavascriptExecutor js = (JavascriptExecutor) driver; WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR)); <START> Actions actions = new Actions(driver); <END> actions.moveToElement(editButton).perform(); js.executeScript("arguments[0].querySelector(arguments[1]).click()", mostRecentComment, EDIT_BUTTON_SELECTOR); return new MiniEditorComponentObject(driver); } </code><technical_language> merge into one line </technical_language>
code&comment2code: <code> public String getContentAccessModeList() { String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split(","); String ammend = ""; <START> if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) { <END> ammend = modeList.length > 0 ? "," : ""; ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE; } return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend; } </code><technical_language> @wottop Would this mean that the "entitlement" mode is always included? Even if a mode list has been set on the owner that did not include it? If so, that does not seem right as it is valid to set the list to not contain entitlements as an option, just that if the list is empty that means it should be set to entitlement. </technical_language>
code&comment2code: <code> public void setUp() { <START> System.setProperty("user.timezone", "UTC"); <END> TimeZone.setDefault(null); configuration = Configuration.DEFAULT; } </code><technical_language> @timowest weird. I remembered it was failed with testing on querydls-sql module. but it's gone now. </technical_language>
code&comment2code: <code> private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive) { try { hdfsEnvironment.getFileSystem(context, path).delete(path, recursive); } catch (Exception e) { <START> Logger.get(GlueHiveMetastore.class).warn(e, "Failed to delete path: " + path.toString()); <END> } } </code><technical_language> Declare the logger at the top of the class: java private static final Logger log = Logger.get(GlueHiveMetastore.class);  (you might see the inline Logger.get() pattern in some tests, but it's not the normal way) </technical_language>
code&comment2code: <code> <START> private boolean isNakedTD1Key(String s) <END> { return NAKED_TD1_KEY_PATTERN.matcher(s).matches(); } </code><technical_language> private static </technical_language>
code&comment2code: <code> public long skip(long n) throws IOException { if (n <= 0) { return 0; } if (n > MOVEMENT_LIMIT) { mSequentialReadCount = 0; } else { <START> ((Seekable) in).seek(mPos + n); <END> } mPos += n; return n; } </code><technical_language> nit: for readability i prefer a method called isSequentialReadMode to determine whether to seek or not </technical_language>
code&comment2code: <code> public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { <START> Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); <END> assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE); } </code><technical_language> Missing assertNotNull for executionSet here. </technical_language>
code&comment2code: <code> private List<Window> fetchWindowsInQueue() { List<Window> windows = Lists.newArrayList(getWindows()); <START> return ImmutableList.copyOf(Lists.reverse(windows)); <END> } </code><technical_language> Remove the reversal here, and let the JDK 8 implementation return it in reverse, and the JDK 9 implementation *not* reversed. </technical_language>
code&comment2code: <code> protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException { <START> try { executor.startFB(resource, new FBDeploymentData("", resFB)); } catch (DeploymentException e) { throw e; } <END> } </code><technical_language> what is the point of catching the exception here? </technical_language>
code&comment2code: <code> <START> void setReaderBudget() <END> { reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes); } </code><technical_language> Make this method private. </technical_language>
code&comment2code: <code> <START> default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) { <END> return find(query, entityType, entityType); } </code><technical_language> Same as with the imperative template: Shouldn't we just deprecate these methods and introduce Flux<SearchHit<T>> search( )? </technical_language>
code&comment2code: <code> public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), <START> false); <END> WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; } </code><technical_language> True, now. </technical_language>
code&comment2code: <code> public Map<String, String> load() { final Map<String, String> preferences = new HashMap<String, String>(); <START> final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED ); <END> log.info( "Setting preference '" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + "' to '" + property + "'." ); preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED, property ); return preferences; } </code><technical_language> We normally check if this is null and only set if non-null... IDK if your code handles null differently? </technical_language>
code&comment2code: <code> protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) { if (m_grouping.parallelScheduler != null) { int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism; if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) { <START> taskParallelism = ctx.getDefaultMaxDegreeOfParallelism(); <END> } } return defaultValue; } </code><technical_language> I think you need to return taskParallelism here b/c if the value specified as the max degree != DEFAULT_MAX_DEGREE_OF_PARALLELISM, then we return 1, not, say 40 </technical_language>
code&comment2code: <code> <START> public static boolean stopIfIsPlaying(@Nullable AudioSlide slide) { <END> if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) { playing.get().stop(); return true; } else { return false; } } </code><technical_language> think this has to be synchronized </technical_language>
code&comment2code: <code> public List<AggregatorFactory> getRequiredColumns() { return fields.stream() .map( input -> new CardinalityAggregatorFactory( input.getOutputName(), null, Collections.singletonList(input), byRow, round ) <START> ).collect(Collectors.toList()); <END> } </code><technical_language> Line should be breaked after ) </technical_language>
code&comment2code: <code> <START> public Optional getRequestAttribute(final String name) { <END> return Optional.ofNullable(this.request.getAttribute(name)); } </code><technical_language> add the type parameter even if it's object </technical_language>
code&comment2code: <code> <START> public static String reflogComments(List<ReflogEntry> entries) { <END> StringBuffer b = new StringBuffer(); for (ReflogEntry e : entries) { b.append(e.getComment()).append(";"); } return b.toString(); } </code><technical_language> this method doesn't need to be public </technical_language>
code&comment2code: <code> private static boolean validateName(String value) throws WSSecurityException { Name name; try { name = new LdapName(value); } catch (Exception e) { LOG.info("Validation of X509 Subject Name failed: {}", e.getLocalizedMessage(), e); throw new WSSecurityException(ErrorCode.FAILURE, "Not a valid X509 Subject Name."); } <START> return name != null; <END> } </code><technical_language> The return value is never used. </technical_language>
code&comment2code: <code> private static SimpleFeatureCollection parseGeoJSON(InputStream in, CoordinateReferenceSystem crs) throws IOException { Map<String, Object> geojson = OM.readValue(in, TYPE_REF); <START> in.close(); <END> SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs); return GeoJSONReader2.toFeatureCollection(geojson, schema); } </code><technical_language> Move close() to a finally-block? </technical_language>
code&comment2code: <code> private void refreshHostStorage(Guid hostId) { getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, Boolean.FALSE)); <START> } <END> </code><technical_language> Worth checking if we really need this method at all, although probably not in THIS patch. Regardless, why use Boolean.FALSE and not a primitive false? </technical_language>
code&comment2code: <code> public void openTestShells() { Display.syncExec(() -> { for (int i = 1; i <= TEST_SHELLS_COUNT; i++) { String shellTitle = "shell" + i; ShellTestUtils.createShell(shellTitle); <START> shells.add(new DefaultShell(shellTitle)); <END> } }); } </code><technical_language> do not create new DefaultShell inside syncexec </technical_language>
code&comment2code: <code> <START> public RangeColumnStatistics( <END> Optional<Object> lowValue, Optional<Object> highValue, Estimate fraction, Estimate dataSize, Estimate distinctValuesCount) { this.lowValue = requireNonNull(lowValue, "lowValue can not be null"); this.highValue = requireNonNull(highValue, "highValue can not be null"); requireNonNull(fraction, "fraction can not be null"); requireNonNull(dataSize, "dataSize can not be null"); requireNonNull(distinctValuesCount, "distinctValuesCount can not be null"); this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount); } </code><technical_language> I do not think it should be public. IMO it should only called from Builder. </technical_language>
code&comment2code: <code> public void close() { log.debug("Closing record collector"); if (eosEnabled) { streamsProducer.abortTransaction(); } <START> streamsProducer.flush(); <END> checkForException(); } </code><technical_language> Sounds reasonable to me </technical_language>
code&comment2code: <code> public static FileSystemContext create(ClientContext clientContext) { FileSystemContext ctx = new FileSystemContext(); ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf())); <START> ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled(); <END> return ctx; } </code><technical_language> set this in initContext instead? </technical_language>
code&comment2code: <code> private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo) { <START> return uriInfo.getBaseUriBuilder().replacePath("/v1/statement").path(queryId.toString()).path(String.valueOf(resultId.incrementAndGet())).replaceQuery("").scheme(scheme).build(); <END> } </code><technical_language> Replace scheme first since it's first in the URL. Let's also wrap this since it's getting long: java return uriInfo.getBaseUriBuilder() .scheme(scheme) .replacePath("/v1/statement") .path(queryId.toString()) .path(String.valueOf(resultId.incrementAndGet())) .replaceQuery("") .build(); </technical_language>
code&comment2code: <code> public void commitToFile() throws Exception { afw.write(expectedContent, 0, expectedContent.length()); afw.commit(); <START> assertTrue(Files.size(af.toPath()) == expectedContent.length()); <END> } </code><technical_language> java assertEquals(expectedContent.length(), Files.size(af.toPath())); </technical_language>
code&comment2code: <code> public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) { this.columnWidthConfig.setPercentage(columnPosition, width); if <START> (fireEvent) <END> fireLayerEvent(new ColumnResizeEvent(this, columnPosition)); } </code><technical_language> add { and } </technical_language>
code&comment2code: <code> <START> protected void connect() throws IOException <END> { mbeanServerConn = null; jmxc = null; ssProxy = StorageService.instance; msProxy = MessagingService.instance(); streamProxy = StreamManager.instance; compactionProxy = CompactionManager.instance; fdProxy = (FailureDetectorMBean) FailureDetector.instance; cacheService = CacheService.instance; spProxy = StorageProxy.instance; hhProxy = HintedHandOffManager.instance; gcProxy = new GCInspector(); gossProxy = Gossiper.instance; memProxy = ManagementFactory.getMemoryMXBean(); runtimeProxy = ManagementFactory.getRuntimeMXBean(); } </code><technical_language> Don't think any method is going to throw an IOException. We can get rid of this. </technical_language>
code&comment2code: <code> private void sortPositions(int arrayLength, Comparator<Integer> comparator) { List<Integer> list = positions.subList(0, arrayLength); try { list.sort(comparator); } catch (IllegalArgumentException e) { <START> throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Lambda comparator violates the comparator contract"); <END> } } </code><technical_language> To clarify, this does not catch the PrestoException thrown from comparatorResult? Do you wan to include the thrown e in the new PrestoException created here? </technical_language>
code&comment2code: <code> public void deactivate() { try { httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME); } catch(IllegalArgumentException e) { <START> logger.info("LgTv Servlet '{}' was not registered. Nothing to deactivate.", WEBAPP_ALIAS + SERVLET_NAME); <END> } finally { logger.info("Stopped LgTv Servlet"); } } </code><technical_language> debug </technical_language>
code&comment2code: <code> public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException { long ticketId = 1; ObjectNode json = Json.newObject(); ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME); node.add(ticketId); when(mockedBody.asJson()).thenReturn(json); Result result = ticketsController.free(); assertEquals(Helpers.OK, Helpers.status(result)); <START> verify(mockedTicketsInteractor, times(1)).freeATicket(ticketId); <END> } </code><technical_language> times(1) is by default in verify </technical_language>
code&comment2code: <code> private static <E> View<E> load(JobContext jobContext) { Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext); Class<E> type = getType(jobContext); String outputUri = conf.get(KITE_OUTPUT_URI); <START> DefaultConfiguration.set(conf); <END> return Datasets.<E, View<E>>load(outputUri, type); } </code><technical_language> Should this be done in OutputCommitter#setupTask instead of here? This method could be called more than once, but we want to ensure we set up the environment config just one time per task. The setupTask methods seems like a good place, unless you have a reason to do it here? </technical_language>
code&comment2code: <code> public boolean validate(Map<String, String> optionsMap) { if (shouldSkip()) { return true; } if (!super.validate(optionsMap)) { return false; } if (!validatePrincipalLogin()) { <START> System.err.format("Principal login test failed.%n"); <END> return false; } return true; } </code><technical_language> if the principal login test will already print the root cause, do we still need to print this here? </technical_language>
code&comment2code: <code> <START> public void createEdit() { <END> Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true); buttonBar.pack(); } </code><technical_language> Done </technical_language>
code&comment2code: <code> <START> public E read(String line) { <END> try { return builder.makeRecord(parser.parseLine(line), null); } catch (IOException e) { throw new DatasetIOException("Cannot parse line: " + line, e); } } </code><technical_language> This should probably just call read(String line, E reuse) and pass in null for reuse rather than duplicate the method. </technical_language>
code&comment2code: <code> public void centerOnCurrentLocation() { followMe = true; <START> if (getMapController().getLocation() != null) { <END> findMe(); } } </code><technical_language> Why would this not be a part of findMe method? instead of the a wrapper? Like here where the call to getLocation happens: <LINK_0> </technical_language>
code&comment2code: <code> public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider) <START> throws IOException, JsonProcessingException <END> { generator.writeBinary(sketch.toByteArray(true)); } </code><technical_language> JsonProcessingException is not necessary. </technical_language>
code&comment2code: <code> public String toString() { StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('['); <START> for (MqttTopicSubscription subscription : topicSubscriptions) { <END> builder.append(subscription).append(", "); } if (!topicSubscriptions.isEmpty()) { builder.setLength(builder.length() - 2); } return builder.append(']').toString(); } </code><technical_language> please keep old "for loop" style to reduce GC. </technical_language>
code&comment2code: <code> private Field[] getFields(Class<?> currentClass) { final List<Field> fields = new ArrayList<>(); <START> if (currentClass != null) { do { <END> fields.addAll(Arrays.asList(currentClass.getDeclaredFields())); currentClass = currentClass.getSuperclass(); } while (currentClass.getSuperclass() != null); } return fields.toArray(new Field[0]); } </code><technical_language> if you change to while (currentClass != null) {} you can avoid the outer if clause </technical_language>
code&comment2code: <code> public void setDecoderResult(DecoderResult decoderResult) { ObjectUtil.checkNotNull(decoderResult, "decoderResult"); <START> this.decoderResult = decoderResult; <END> } </code><technical_language> nit: you can merge both lines above as checkNotNull will return the given argument </technical_language>
code&comment2code: <code> protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) { <START> requestData= request; <END> return prepareResponseDocument(context).html(); } </code><technical_language> suggestion requestData = request; </technical_language>
code&comment2code: <code> public void start() { for (int i = 0; i < numProcessingQueues; i++) { processingExecutor.scheduleAtFixedRate( new SegmentChangeProcessor(segmentProcessingQueues[i]), 0, <START> config.getCuratorCreateZkNodesRepeatDelay().getMillis(), <END> TimeUnit.MILLISECONDS ); } } </code><technical_language> Just wonder how high requests rate we are discussing, 1mln/s? The Coordinator balancing process will choke to halt from such amount long before the discussed queue will show a mere slight latency. I'm sure a single queue will manage the current request rate of Coordinator, besides threads don't need to call *drainTo()* as they can perfectly consume calling *queue.take()*. </technical_language>
code&comment2code: <code> <START> protected void doc(Class c) throws IOException { <END> open("tr class='TableRowColor'"); open("td"); around("span class='modifiers'",getModifiers(c)); close("td"); open("td"); link(c.getType()); tag("br"); around("span class='doc'", getDoc(c)); close("td"); close("tr"); } </code><technical_language> Indentation here looks crazy! I'm thinking this might be some mismatch (between your IDE and github) in the number of spaces a tab is worth. </technical_language>
code&comment2code: <code> public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i) { if (shapedReverseLookupTable.get(i) != null) return shapedReverseLookupTable.get(i); <START> return new ArrayList<Pair<AbstractIngredient[], Float>>(); <END> } </code><technical_language> internal cache, or just return null from this. </technical_language>
code&comment2code: <code> public boolean exists() { OverriddenBooleanValue overriden = null; if ( decorator != null ) { <START> overriden = decorator.decorateExists( this, new EventMetadata( ) ); <END> } if ( ( overriden != null ) && overriden.overrides() ) { return overriden.getResult(); } else { return provider.exists( resource ); } } </code><technical_language> At some point we will probably need a variant of exists() that accepts an EventMetadata parameter, in case the existence decorator needs to know if a path has special properties within the scope of some package type. Not critical now. </technical_language>
code&comment2code: <code> public void startIndexPopulation( IndexPopulationJob job ) { populationJobs.add( job ); <START> scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) ); <END> } </code><technical_language> I think there is a race in IndexingService between createIndexes and shutdown where population jobs can be added after IndexPopulationJobController.stop is called. Result will be that we can leak population jobs. It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in IndexingService. </technical_language>
code&comment2code: <code> public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) { String value = options.get(option); <START> return value == null ? defaultValue : Integer.valueOf(value); <END> } </code><technical_language> Integer.parseInt </technical_language>
code&comment2code: <code> public void releaseBuffer() { if (serializedCache != null) { serializedCache.release(); <START> if (serializedCache.refCnt() == 0) { <END> serializedCache = null; } } } </code><technical_language> should this be thread safe ? </technical_language>
code&comment2code: <code> public Credentials.IdentityProvider getProvider() { String nativeProvider = nativeGetProvider(nativePtr); String id = identityProvider.getId(); if (nativeProvider.equals(id)) { return identityProvider; } else { <START> throw new AssertionError("The provider from the Object Store differs from the one in Realm."); <END> } } </code><technical_language> Good idea , but this checking should IMO be moved to AppCredentials. The Os<X> classes should generally just expose the Os interface and then we do the mapping on the "upper" layer, i.e. AppCredentials </technical_language>
code&comment2code: <code> private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) { if (symbolicValue == null) { return Collections.emptySet(); } <START> HashSet<SymbolicValue> result = new HashSet<>(); <END> result.add(symbolicValue); symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv))); return result; } </code><technical_language> minor: rely on interface rather that full type. </technical_language>
code&comment2code: <code> public ClassLoader getClassLoader() { <START> return this.getClassLoader(); <END> } </code><technical_language> This method recursively calls itself, which will result in stackoverflow. Is that ok? </technical_language>
code&comment2code: <code> public Integer add(Stream<E> entities) { return delegate().add(entities.filter(entity -> { <START> boolean permitted = isOperationPermitted(entity, Action.CREATE); <END> if (permitted) { createAcl(entity); } return permitted; })); } </code><technical_language> Shouldn't this throw an exception instead? </technical_language>
code&comment2code: <code> public void canIgnoreInvocationsWithJunit() throws InterruptedException { DelayedExecution delayedExecution = createZeroMillisDelayedExecution(); DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution(); delayedExecution.allAsyncCallsStarted(); <START> twentyMillisDelayedExecution.allAsyncCallsStarted(); <END> verify(mock, timeout(50)).oneArg('1'); verify(mock, timeout(50)).oneArg('2'); } </code><technical_language> @lukasz-szewc I'd rather propose  java delayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('1'); twentyMillisDelayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('2');  I agree with you however the name of this test is wrong... </technical_language>
code&comment2code: <code> public final boolean isExtendedLifetimeValid() { if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) { return !isTokenExpired(mExtendedExpiresOn); <START> } else { <END> return false; } } </code><technical_language> > else { [](start = 10, length = 6) you don't need this else block. </technical_language>
code&comment2code: <code> public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) { BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument); try { emailService.sendMessage(message, false); } catch (Exception e) { <START> String errorMessage = new String("sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# " + iWantDocument.getDocumentNumber()); <END> LOG.error(errorMessage, e); } } </code><technical_language> Redundant String constructor. </technical_language>
code&comment2code: <code> <START> public void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) { <END> storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId, infosByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()), buffersByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener)); } </code><technical_language> minor: can be package private </technical_language>
code&comment2code: <code> private static long doubleToSortableLong(double value) { long bits = Double.doubleToLongBits(value); <START> return bits ^ (bits >> 63) & Long.MAX_VALUE; <END> } </code><technical_language> Add clarifying parenthesis. It's easy to forget the precedence rules for ^ and & so that will make the code easier to reason about. </technical_language>
code&comment2code: <code> default int getGroupedJobInitializerCacheSize() { <START> return 10; <END> } </code><technical_language> It's probably a bit low. I doubt GroupedJobInitializer use much memory so we could easily increase it a bit by default (like 100 maybe). Would need to check how many nodes are created after a few jobs are run in XWiki Standard. On extension side there is the root "extension" node and then 1 per namespace (so in practice 1 par wiki). It's potentially a lot more for the refactoring module since you have the root "refactoring" node and then one node for each element of each EntityReference which is manipulated. </technical_language>
code&comment2code: <code> public DefaultCompactionPolicyTest() throws InterruptedException { Pair<MockBlobStore, StoreConfig> initState = CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE); <START> this.config = initState.getSecond(); <END> this.blobStore = initState.getFirst(); this.mockBlobStoreStats = blobStore.getBlobStoreStats(); this.messageRetentionTimeInMs = config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec; this.compactionPolicy = new DefaultCompactionPolicy(config, time); } </code><technical_language> minor: this qualifiers not required. </technical_language>
code&comment2code: <code> private boolean containtsOnlyValidXMLChars(String stringToValidate) { <START> String pattern = "[^" <END> + "\u0009\r\n" + "\u0020-\uD7FF" + "\uE000-\uFFFD" + "\ud800\udc00-\udbff\udfff" + "]"; String resultString = stringToValidate.replaceAll(pattern, ""); if (resultString.equals(stringToValidate)) { return true; } return false; } </code><technical_language> Why not simply iterate over the array of chars and not check if stringToValidate.contains(character). </technical_language>
code&comment2code: <code> <START> public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException { <END> super(changeLogFile, resourceAccessor, database); this.dataSource = dataSource; } </code><technical_language> It's a pity we have to change the public API, but I guess it's reasonable in this case. Let's hope not so many folks wrote custom migrations commands. </technical_language>
code&comment2code: <code> public CtfTmfLightweightContext(ArrayList<CtfIterator> iters, ListIterator<CtfIterator> pos) { fIteratorPool = iters; <START> fCurrentIterator = pos; <END> fTrace = iters.get(0).getCtfTmfTrace(); curLocation = new CtfLocation((Long)null); collisions = 0; } </code><technical_language> Might as well remove these fields if they are not used. Perhaps just call the other constructor with: this(iters.get(0).getCtfTmfTrace()); </technical_language>
code&comment2code: <code> <START> public void testIsAdHocAutostart_true() throws Exception { <END> String id = UUID.randomUUID().toString(); AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess(); adHocSubProcess.setId(id); CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE); tested = new AdHocSubProcessPropertyReader(adHocSubProcess, definitionResolverReal.getDiagram(), definitionResolverReal); assertTrue(tested.isAdHocAutostart()); } </code><technical_language> The Exception is never thrown. </technical_language>
code&comment2code: <code> private BroadcastTrimmer broadcastTrimmer() { return new ScheduleResolverBroadcastTrimmer( <START> null, <END> scheduleResolver, contentResolver, contentWriter ); } </code><technical_language> Remove the parameter completely, the other constructor will initiate the publisher as null. </technical_language>
code&comment2code: <code> public void disconnect() throws IOException { if (forwarders != null) { for (LocalPortForwarder forwarder : forwarders) { try { forwarder.close(); } catch (IOException e) { log.warn("Error closing forwarder", e); } <START> } <END> } trans.disconnect(); super.disconnect(); } </code><technical_language> clear the forwarders list after the loop? </technical_language>
code&comment2code: <code> public void close() { super.close(); if (mRefCount != null) { <START> mRefCount.decrementAndGet(); <END> } } </code><technical_language> NIT: is there just a plain decrement()? </technical_language>
code&comment2code: <code> public static String getParameter(String key) { try { return getConfig().getString(key); } catch (NoSuchElementException e) { <START> e.printStackTrace(); <END> throw new NoSuchElementException("No configuration found in " + CONFIG_FILE + " for key " + key + "!"); } } </code><technical_language> Use logger instead of printStackTrace() calls. </technical_language>
code&comment2code: <code> public List<Option> getOptions() { <START> return unmodifiableList(options); <END> } </code><technical_language> This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller? </technical_language>
code&comment2code: <code> public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) { this.input = input; this.initialOffset = initialOffset; <START> } <END> </code><technical_language> Do we need to set the input position to the initial offset? </technical_language>
code&comment2code: <code> protected void onMethodInvocationFound(MethodInvocationTree mit) { ExpressionTree argument = mit.arguments().get(1); Type type = argument.symbolType(); <START> if (type.isUnknown()) { <END> return; } if (ExpressionsHelper.isNotSerializable(argument)) { String andParameters = JUtils.isParametrized(type) ? " and its parameters" : ""; reportIssue(argument, "Make \"" + type + "\"" + andParameters + " serializable or don't store it in the session."); } } </code><technical_language> So it means that an argument with unknown type is considered as not serializable? Should we consider making the unknown check inside isNotSerializable and provide the same behavior for all rules using it? I'm saying this since the other rule (S2118) using isNotSerializable is also reporting an arguable issue with a similar message if we run it against an unknown type. > Make the "!Unknown!" class "Serializable" or don't write it. </technical_language>
code&comment2code: <code> public Predicate createPredicateAndJoin(String filterString, Root<T> root) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString)); LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer)); parser.addErrorListener(new OsiamAntlrErrorListener()); ParseTree tree = parser.parse(); EvalVisitor<T> visitor = new EvalVisitor<>(this, root); <START> return (Predicate) visitor.visit(tree); <END> } </code><technical_language> Is this cast still necessary? </technical_language>
code&comment2code: <code> <START> public Privilege[] getSupportedPrivileges(String path) throws PathNotFoundException, RepositoryException { <END> return privileges.listOfSupported(); } </code><technical_language> Remove the exceptions, since they're never thrown from the method. </technical_language>
code&comment2code: <code> protected AbstractSessionPresenter(final SessionManager sessionManager, final SessionPresenter.View view, final Optional<? extends ToolbarFactory<S>> toolbarFactory, final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory, final NotificationsObserver notificationsObserver) { this.sessionManager = sessionManager; <START> this.toolbarFactory = toolbarFactory.orElse(null); <END> this.paletteFactory = paletteFactory.orElse(null); this.notificationsObserver = notificationsObserver; this.view = view; this.hasToolbar = true; this.hasPalette = true; } </code><technical_language> I'd have thought preserving the use of Optional in the class's implementation would be nicer than just using Optional on the constructor and then reverting to null _inside_ the class. </technical_language>
code&comment2code: <code> <START> public void prepareToNewMarker() { <END> drawerLayout.closeDrawers(); setLongClickListener(true); setToastMarkerInfo(); } </code><technical_language> czy to musi byc publiczne? </technical_language>
code&comment2code: <code> <START> private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) { <END> if (cacheEntry instanceof MVCCEntry) { MVCCEntry mvccEntry = (MVCCEntry) cacheEntry; updateMetadata(mvccEntry, providedMetadata); return mvccEntry; } return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true); } </code><technical_language> The skipRead parameter isn't used. </technical_language>
code&comment2code: <code> public SERVICE_FAILURE_ACTIONS getFailureActions() { Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS); SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer); <START> result.read(); <END> return result; } </code><technical_language> You should make the read() call part of the SERVICE_FAILURE_ACTIONS(Pointer) constructor. </technical_language>
code&comment2code: <code> void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception { new File(strPath); new File(StrParent, StrChild); File parent = new File(uri); new File(parent, StrChild); <START> File.createTempFile(prefix, suffix); <END> } </code><technical_language> I would add the other createTempFile method to enforce the fact that we explicitly target this one only. </technical_language>
code&comment2code: <code> public ValidationResult vmNotHavingPciPassthroughDevices() { for (VM vm : vms) { if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) { return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES, <START> String.format("$VmName %s", vm.getName())); <END> } } return ValidationResult.VALID; } </code><technical_language> I see that VmName in not included in the error message.. not sure if the right thing to do is to include it in the message or not to set it here </technical_language>
code&comment2code: <code> public void onError(Throwable e) { <START> e.printStackTrace(); <END> try { FileLfsServlet.sendError(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage()); context.complete(); in.close(); } catch (IOException ex) { LOG.log(Level.SEVERE, ex.getMessage(), ex); } } </code><technical_language> did you want to log this exception ? </technical_language>
code&comment2code: <code> public String pop() { <START> String value = lines.remove(lines.lastKey()); <END> return value; } </code><technical_language> Return could be simplified: return lines.remove(lines.lastKey()); :) </technical_language>
code&comment2code: <code> public void onDestroyView() { mapView.onDestroy(); mapboxMap = null; unbinder.unbind(); unbinder = null; <START> WikipediaApp.getInstance().getRefWatcher().watch(this); <END> super.onDestroyView(); } </code><technical_language> Shouldn't this be in onDestroy? </technical_language>
code&comment2code: <code> private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) { SampleTissueProcessingDto dto = null; <START> if (from.getClass() == SampleCVSlideImpl.class) { <END> dto = asCVSlideSampleDto((SampleCVSlide) from); } else if (from.getClass() == SampleLCMTubeImpl.class) { dto = asLCMTubeSampleDto((SampleLCMTube) from); } else { dto = new SampleTissueProcessingDto(); } return dto; } </code><technical_language> getClass comparison is required for Dtos because of the way their inheritance works (analyte is also a tissue and an identity for the purpose of including parent data), but instanceof should be used here (and typically for the non-dto models), and check vs. interfaces for flexibility. e.g. we could add another implementation of SampleCVSlide that this method should still work for, or we could subclass SampleCVSlideImpl (however unlikely) </technical_language>
code&comment2code: <code> public void testMakeTimeZone_NoOffsets() throws IOException { <START> <END> int[][] times = {}; int[][] offsets = {}; try { createZoneInfo(times, offsets); fail("Did not detect no transitions"); } catch (IllegalStateException expected) { } } </code><technical_language> Unnecessary new line here and below: why leave the first line blank? (unless there's a wrap in the signature, in which case it can help to differentiate between the signature and the body). </technical_language>
code&comment2code: <code> DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations, GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage, RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) { this.nodeNamingConvention = checkNotNull(namingConvention, "namingConvention").createWithoutPrefix(); this.locations = checkNotNull(locations, "locations"); this.osImageToImage = checkNotNull(osImageToImage, "osImageToImage"); this.roleSizeToHardware = checkNotNull(roleSizeToHardware, "roleSizeToHardware"); <START> this.credentialStore = checkNotNull(credentialStore, "credentialStore cannot be null"); <END> } </code><technical_language> Since the constructor is package private and only the Guice injector will be able to call it, you can remove all the null checks. The injector will already fail if any parameter is missing. </technical_language>
code&comment2code: <code> public AsyncContext startAsync() throws IllegalStateException { if (_asyncNotSupportedSource != null) throw new IllegalStateException("!asyncSupported: " + _asyncNotSupportedSource); HttpChannelState state = getHttpChannelState(); if (_async == null) _async = new AsyncContextState(state); <START> AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse(), false); <END> state.startAsync(event); return _async; } </code><technical_language> I wonder if you shouldn't keep the old constructor here, and not use an extra boolean argument. </technical_language>
code&comment2code: <code> CompletableFuture<Void> getFailureOp(CommitData cd) { <START> return CompletableFuture.supplyAsync(() -> { <END> try { rollbackLocks(cd); } catch (Exception e) { throw new CompletionException(e); } return null; }, env.getSharedResources().getSyncCommitExecutor()); } </code><technical_language> After throws Exception is dropped from rollbackLocks, seems like this code should be : java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); } </technical_language>
code&comment2code: <code> private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) { return symbol.owner().type().is("com.google.common.base.Preconditions") <START> && ("checkNotNull".equals(symbol.name()) || "checkArgument".equals(symbol.name()) || "checkState".equals(symbol.name()) ); <END> } </code><technical_language> symbol.name() called 3 times? maybe worth a dedicated variable. </technical_language>
code&comment2code: <code> public void loadTrace(ITmfTrace trace) { <START> cancelUpdate(); <END> super.loadTrace(trace); initializeDataProvider(); } </code><technical_language> We had that cancelUpdate() at the beginning of updateContent(). Now the UpdateThread doesn't get cancelled with TmfXYChartViewer.windowRangeUpdated() and TmfCommonXAxisChartViewer.setNbPoints(). </technical_language>
code&comment2code: <code> public StringInputRowParser( @JsonProperty("parseSpec") ParseSpec parseSpec, @JsonProperty("encoding") String encoding ) { this.parseSpec = parseSpec; this.mapParser = new MapInputRowParser(parseSpec); this.parser = parseSpec.makeParser(); <START> parser.startFileFromBeginning(); <END> if (encoding != null) { this.charset = Charset.forName(encoding); } else { this.charset = DEFAULT_CHARSET; } } </code><technical_language> StringInputRowParser is used by parser options that aren't file-oriented (you can use it on streams etc) so this isn't a good place to put this. imo, this should replace reset() and be called in places that reset() is currently called (like FileIteratingFirehose). With one addition: it needs to be called before the very first file too. </technical_language>
code&comment2code: <code> public Object getNegotiatedProperty(String propName) { assertComplete(); switch (propName) { case Sasl.QOP: return selectedQop.getName(); case Sasl.MAX_BUFFER: return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer); case Sasl.RAW_SEND_SIZE: return Integer.toString(maxBuffer); } <START> return super.getNegotiatedProperty(propName); <END> } </code><technical_language> The superclass only repeats the assertComplete() call. I don't think this PR adds any value. </technical_language>
code&comment2code: <code> public static BooleanExpression asBoolean(boolean value) { <START> return asBoolean(Expressions.constant(value)); <END> } </code><technical_language> this is inside Expressions, so maybe just asBoolean(constant(value)), the same with the others </technical_language>
code&comment2code: <code> public void startPolicyEnforcement() throws IOException { if (m_pbd.getUsageSpecificLog().isDebugEnabled()) { m_pbd.getUsageSpecificLog().debug("Starting time based retention policy enforcement with retainMillis=" + m_retainMillis + " for PBD " + m_pbd.getNonce()); } m_reader = m_pbd.openForRead(CURSOR_NAME); <START> scheduleTaskFor(m_pbd.getNonce(), ()->deleteOldSegments(), 0); <END> } </code><technical_language> You can do this::deleteOldSegments for the callable. It is more efficient lambda form </technical_language>
code&comment2code: <code> public void afterRun() throws Exception { if (recordStore.isWanReplicationEnabled()) { CacheRecord record = recordStore.getRecord(key); if (record != null) { publishWanUpdate(key, record); <START> } else { <END> publishWanRemove(key); } } super.afterRun(); } </code><technical_language> Do you need to guard against null here as well? </technical_language>
code&comment2code: <code> protected String getConfigRoot() { <START> return ClientConfigSections.HAZELCAST_CLIENT.name.toLowerCase(); <END> } </code><technical_language> toLowerCase </technical_language>
code&comment2code: <code> <START> public synchronized int getCapacity() { <END> return capacity; } </code><technical_language> Does this method have to be synchronized, considering that capacity is final? </technical_language>
code&comment2code: <code> private Set<IArtifactType> getAllArtTypes() { Set<IArtifactType> allArtTypes = new HashSet<>(); if (artifactTypes == null || !artifactTypes.isEmpty()) { <START> allArtTypes.addAll(artifactTypes); <END> } else { getArtifactTypesFromWorkItemTypes(); } return allArtTypes; } </code><technical_language> why add 'null' to allArtTypes? </technical_language>
code&comment2code: <code> public void testContextListenerIsSet() throws Exception { try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class)) { tester.initialize(); Assert.assertTrue("Wizard is not on a valid state", tester.isValid()); Assert.assertTrue("Listener is not set", listener.isContextInitialized()); tester.execute(); <START> Assert.assertFalse("Listener is still set", listener.isContextInitialized()); <END> } } </code><technical_language> This should be moved outside the try block </technical_language>
code&comment2code: <code> <START> private Later(F0<A> producer) { <END> this.memo = P.hardMemo(producer); } </code><technical_language> package private </technical_language>
code&comment2code: <code> private boolean isRunningFromCommandLine() { boolean runningFromCommandLine = false; Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class); Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator(); while (optionsIterator.hasNext()) { OptionProcessor processor = optionsIterator.next(); if (!(processor instanceof CommandLineOptionProcessor)) { continue; } runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine(); return runningFromCommandLine; } return false; <START> } <END> </code><technical_language> Codacy flagged this method for "Avoid using a branching statement as the last in a loop." I think that is a reasonable call by Codacy and the code would be easier to read if runningFromCommandLine was set to true in the loop, followed by a break, and a single method return of runningFromCommandLine on what is currently line 136. Alternatively, one could also do away with runningFromCommandLine and have a return true statement in the loop, but I think the first alternative may be a little easier to read and will make Codacy content. </technical_language>
code&comment2code: <code> <START> public Boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) { <END> for (CordovaPlugin plugin : this.pluginMap.values()) { if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) { return true; } } return false; } </code><technical_language> Unless you want this to be tri-state, then "Boolean" should be "boolean". I don't see the need for tristate, so go with "boolean" </technical_language>
code&comment2code: <code> private String createAndGetLockPath() throws InterruptedException, KeeperException { <START> if (zk.exists(lockPath.toString(), false) == null) { <END> try { Util.mkdir(zk, lockPath.toString(), ZooDefs.Ids.OPEN_ACL_UNSAFE); } catch (CloudnameException e) { log.log( java.util.logging.Level.INFO, "CloudnameException while trying to get lock path " + absoluteLockPath, e); } } return lockPath + "/" + lockName; } </code><technical_language> lockPath is already String </technical_language>
code&comment2code: <code> public Tuple getTuple(EntityKey key, TupleContext tupleContext) { Entity entity = getEntity( key, tupleContext.getOptionsContext() ); if ( entity != null ) { return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } <START> else if ( isInTheQueue( key, tupleContext ) ) { <END> return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } else { return null; } } </code><technical_language> What I mean is, your dialect does not implement BatchableGridDialect, so items will never be put in to the operations queue. </technical_language>
code&comment2code: <code> public void invoke(ClientEvent event) { try { method.invoke(listener, event); } catch (InvocationTargetException e) { log.errorInvokingListener(method, listener, e.getTargetException()); throw log.exceptionInvokingListener( e.getClass().getName(), method, listener, e.getTargetException()); } catch (Exception e) { throw log.exceptionInvokingListener( <START> e.getClass().getName(), method, listener, e); <END> } } </code><technical_language> Isn't it enough to throw the logging exception instead of also logging locally ? </technical_language>
code&comment2code: <code> ConfigFileConfigProvider(@JsonProperty("configFile") String configFile){ this.configFile = configFile; <START> loadProperties(); <END> } </code><technical_language> can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general. </technical_language>
code&comment2code: <code> public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException { <START> System.out.println("### DefaultAddImageTaskIngestStream - addDataSource " + dataSourceObjectId); <END> } </code><technical_language> No println's, please. </technical_language>
code&comment2code: <code> private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite) { for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) { <START> Path path = declaredIntentionToWrite.getRootPath(); <END> if (declaredIntentionToWrite.isTemporaryTable()) { deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path); continue; } if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) { continue; } recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup"); } } </code><technical_language> I don't know if they should be put inside this method or not. Should temp table be considered as staging directories? </technical_language>
code&comment2code: <code> public void edit() { if (getWindow() != null) { return; } <START> EditDiskProfileModel model = <END> new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId()); setWindow(model); initProfileStorageDomains(model); } </code><technical_language> format </technical_language>
code&comment2code: <code> public void setUp() throws Exception { super.setUp(); gitDir = new File(project.getProject() .getLocationURI().getPath(), Constants.DOT_GIT); testRepository = new TestRepository(gitDir); testRepository.connect(project.getProject()); <START> testRepository.commit("initial commit"); <END> } </code><technical_language> Please remove that line. It changes the tests. </technical_language>
code&comment2code: <code> protected long getParentDid() { long deckID; <START> deckID = getCol().getDecks().selected(); <END> return deckID; } </code><technical_language> should look like this but without the declaration above - they should be on one line suggestion long deckID = getCol().getDecks().selected(); </technical_language>
code&comment2code: <code> public static String getFileExtension(File file) throws Exception { <START> return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); <END> } </code><technical_language> Actually this part does not throw any Exception. Just remove throws Exception and we should be good. Beware of spaces vs tabs. Prefer using spaces for indentation please. </technical_language>
code&comment2code: <code> public void shouldPurgeAnAutoGenerationOption() throws Exception { <START> assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); <END> MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + "/" + getUuid()); req.addParameter("purge", ""); handle(req); assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); } </code><technical_language> You do not need to call Integer.parseInt(getUuid()) more than once in a method. </technical_language>
code&comment2code: <code> <START> private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { <END> String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded); driver.get(standalonePerspectiveURL); BusyPopup.waitForDisappearance(); ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT); } </code><technical_language> Any chance we could make this test @Parameterized? To test 35 different perspectives from within one test case seems evil. Alternatively (as I'm sniffing potential problems with the annotation and Arquillian.), can we at least make the looped code its own function and put some logging around it, so that we know when was it that the test actually failed? Of course, we could also have a different method for each of the perspectives - which would be the "cleanest" solution in this situation. But I sort of see how that would be overkill. </technical_language>
code&comment2code: <code> public default IVariableBinding[] getSyntheticOuterLocals() { return <START> null; <END> } </code><technical_language> THis should return empty array </technical_language>
code&comment2code: <code> protected void executeCommand() { AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId()); if (profile == null) { setSucceeded(false); } else { sessionId = getParameters().getSessionId(); <START> sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); <END> sessionDataContainer.setSessionValid(getParameters().getSessionId(), false); setSucceeded(true); } } </code><technical_language> Both should be initialized even for failures </technical_language>
code&comment2code: <code> public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) { if (TextSecurePreferences.isNotificationsEnabled(context)) { if (visibleThread == threadId) { DatabaseFactory.getThreadDatabase(context).setRead(threadId); sendInThreadNotification(context); } else { <START> updateNotification(context, masterSecret, true); <END> } } updateBadge(context); } </code><technical_language> Sure you shouldn't do this if the thread is visible? This way, the notification will not disappear when the thread is visible for some reason. </technical_language>
code&comment2code: <code> protected void fillOptions(Map<Enum, String> options) { options.put(EnumModel.VAL1, <START> EnumModel.VAL1.toString()); <END> options.put(EnumModel.VAL2, EnumModel.VAL2.toString()); options.put(EnumModel.VAL3, EnumModel.VAL3.toString()); options.put(EnumModel.VAL4, EnumModel.VAL4.toString()); } </code><technical_language> not sure if makes sense, but instead of putting the toString() as values, I probably would use the Enum's name() method, as the toString() is usually been overridden... </technical_language>
code&comment2code: <code> public boolean removeQueues(Queue... queues) { <START> removeQueues(Arrays.asList(queues) <END> .stream() .map(Queue::getName)); return super.removeQueues(queues); } </code><technical_language> The same Arrays.stream() can be applied here as well. </technical_language>
code&comment2code: <code> private static Object castIntegerToObect(int value, Type type) { if (type == INTEGER || type == TINYINT || type == BIGINT) { return (long) value; } if (type == VARCHAR) { <START> return value + ""; <END> } if (type == DOUBLE) { return (double) value; } throw new UnsupportedOperationException(); } </code><technical_language> String.valueOf() </technical_language>
code&comment2code: <code> public void testXmlConfig() throws IOException { EmbeddedCacheManager cm = new DefaultCacheManager("jpa-config.xml"); Cache<String, KeyValueEntity> specificCache = cm.getCache("specificCache"); validateConfig(specificCache); KeyValueEntity entity = new KeyValueEntity("k", "v"); specificCache.put(entity.getK(), entity); <START> cm.stop(); <END> } </code><technical_language> stop() should be in a finally block, or you could use TestingUtil.withCacheManager(). </technical_language>
code&comment2code: <code> public boolean equals(Object o) { boolean equals = this == o || o instanceof <START> URIEditorInput && <END> getURI().equals(((URIEditorInput) o).getURI()); if (equals && o instanceof SessionEditorInput) { EObject input = getInput(false); if (input != null) { SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o; return input.equals(otherSessionEditorInput.getInput(false)); } } return equals; } </code><technical_language> Shouldn't this be SessionEditorInput? Here equals() can return true for instances of different subclasses of URIEditorInput which point to the same URI. I have not checked, but maybe it happen could if have my aird opened at the same time inside a non-Sirius editor. </technical_language>
code&comment2code: <code> private void loadChildEntities(LibraryDilution dilution) throws IOException { if (dilution.getLibrary() != null) { dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId())); } if (dilution.getTargetedSequencing() != null) { dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId())); } <START> dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); <END> } </code><technical_language> This will cause creator to change on every update </technical_language>
code&comment2code: <code> GdkColor getContextColor () { long fontHandle = fontHandle (); long context = OS.gtk_widget_get_style_context (fontHandle); GdkRGBA rgba = new GdkRGBA (); if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) { rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba); } else { <START> int styleState = OS.gtk_widget_get_state_flags(handle); <END> rgba = display.styleContextGetColor (context, styleState, rgba); } return display.toGdkColor (rgba); } </code><technical_language> No need to have the styleState variable at all. </technical_language>
code&comment2code: <code> public Subquery parameter(String listId, Object... values) { if (values == null || values.length == 0 || values[0] == null) { return this; } where.setToNormal(); where.setToIntersection(); where.addParameter(listId, values); <START> return this; <END> } </code><technical_language> These 2 can be called just once. </technical_language>
code&comment2code: <code> public int hashCode() { <START> int result = (key ? 1 : 0); <END> result = 31 * result + (path != null ? path.hashCode() : 0); return result; } </code><technical_language> Minor : parentheses are not needed </technical_language>
code&comment2code: <code> public boolean doSynchronousPing() { MerlinLog.d("Pinging : " + hostAddress); try { <START> int responseCode = responseCodeFetcher.from(hostAddress); <END> MerlinLog.d("Got response : " + responseCode); } catch (RequestException e) { if (e.causedByIO()) { return false; } throw e; } return true; } </code><technical_language> Is this only used for logging? </technical_language>
code&comment2code: <code> public T hasThisElement(final Object val) { Assert.parametersNotNull("val", val); <START> return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); <END> } </code><technical_language> Is that bug reported? If not, it should be so we can track that it's getting fixed. Also, ensure that the bug fix should be done in a separate commit from the new feature work for elemMatch (I didn't check). </technical_language>
code&comment2code: <code> public Builder setSSHDirectory(final File sshDirectory) { this.sshDirectory = sshDirectory; <START> return this; <END> } </code><technical_language> Since this class overrides the equals method, it also needs to override the hashCode method. Let me know if you have any questions on this. </technical_language>
code&comment2code: <code> public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException { List<Attribute> attributes = new ArrayList<>(); for (Service service : services) { <START> getRequiredAttributes(sess, service, facility, resource, user, member); <END> } return attributes; } </code><technical_language> I believe you want to add result into the attributes list. Also, what if required attributes of passed services overlap? We probably should gather them into the set before returning as list. </technical_language>
code&comment2code: <code> public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min, final int offset, final int count) { <START> sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset), <END> toByteArray(count), WITHSCORES.raw); } </code><technical_language> parameter sequence swapped: max, min is correct. </technical_language>
code&comment2code: <code> public void write(int b) throws IOException { mSingleCharWrite[0] = (byte) b; <START> write(mSingleCharWrite, 0, 1); <END> } </code><technical_language> write(mSingleCharWrite)? </technical_language>
code&comment2code: <code> public void deallocateFlow(String flowId) throws FlowNotFoundException, ProvisionerException { try { String netId = getNetworkSelector().findNetworkForFlowId(flowId); <START> getNclController().deallocateFlow(netId, flowId); <END> } catch (Exception e) { throw new ProvisionerException(e); } } </code><technical_language> this method expects flowId, netId as parameters. Be careful with the order! </technical_language>
code&comment2code: <code> private String _encode(String strVal) { try { return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString()); } catch (UnsupportedEncodingException e) { <START> return e.getMessage(); <END> } } </code><technical_language> Perhaps in this case the best is to just rethrow the exception as a RuntimeException </technical_language>
code&comment2code: <code> public boolean contains(Object o) { <START> boolean contains = super.contains(o); <END> if (!contains && o != null) { MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true); contains = me != null; } return contains; } </code><technical_language> if o is null, should no we just return false ? </technical_language>
code&comment2code: <code> public boolean provides(IOperation operation) { if (!(operation instanceof CreateDecoratorsOperation)) { return false; } IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget(); <START> View view = decoratorTarget.getAdapter(View.class); <END> return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view)); } </code><technical_language> The cast should not be removed to avoid compilation errors on Eclipse versions which do not have the generified getAdapter. </technical_language>
code&comment2code: <code> public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() { CuratedContentPageObject ccp = new CuratedContentPageObject(driver); wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC); ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE); MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY); <START> <END> String oldUrl = driver.getCurrentUrl(); ccp.clickOnCuratedContentElementByIndex(2); Assertion.assertTrue(mercuryAlert.isAlertMessageVisible()); ccp.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl); } </code><technical_language> remove extra line </technical_language>
code&comment2code: <code> private void testUpdateInterface(Guid interface_id) { VdsNetworkInterface iface = dao.get(interface_id); iface.setName(iface.getName().toUpperCase()); iface.setQos(newQos); dao.updateInterfaceForVds(iface); VdsNetworkInterface ifaced = dao.get(interface_id); <START> assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos())); <END> } </code><technical_language> I would use a couple of assert equals since they give better output in case of failure. (Remember that the expected value should be the first one) </technical_language>
code&comment2code: <code> public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException { if (patientProgram.getPatientProgramId() == null) { sessionFactory.getCurrentSession().save(patientProgram); } else { sessionFactory.getCurrentSession().merge(patientProgram); } <START> CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); <END> return patientProgram; } </code><technical_language> Shouldn't this be done before the patientProgram is saved, instead of after? </technical_language>
code&comment2code: <code> public UploadDirectoryToCDN(String username, String apiKey) { Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule()); BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER) .credentials(username, apiKey) .modules(modules) .buildView(BlobStoreContext.class); storage = context.getBlobStore(); <START> rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); <END> } </code><technical_language> Does unwrapApi not work for some reason? Just curious...it would make a nice example of the new call, that's why I ask... </technical_language>
code&comment2code: <code> public SslContextBuilder keyManager(KeyManager keyManager) { <START> if (forServer) { <END> checkNotNull(keyManager, "keyManager required for servers"); } this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager); keyCertChain = null; key = null; keyPassword = null; return this; } </code><technical_language> The forServer == false flow looks wrong. If null is passed, then KeyManagerFactoryWrapper will throw (and we probably want the keyManagerFactory to be null in that case). </technical_language>
code&comment2code: <code> <START> public boolean isTypeSupported(Class<T> clazz) { <END> if (String.class.isAssignableFrom(clazz) || Integer.class.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)) { return true; } return false; } </code><technical_language> Should this be protected, or do we really want to allow to call it outside this class? </technical_language>
code&comment2code: <code> private List<Person> createModel() { List<Person> elements = new ArrayList<Person>(4); elements.add(new Person("Tom", "Schindl", "tom.schindl@bestsolution.at")); elements.add(new Person("Boris", "Bokowski", <START> "Boris_Bokowski@ca.ibm.com")); <END> elements.add(new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com")); elements.add(new Person("Wayne", "Beaton", "wayne@eclipse.org")); return elements; } </code><technical_language> Replace Boris? </technical_language>
code&comment2code: <code> protected void updateIteration() { <START> refreshIteration = refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE; <END> } </code><technical_language> maybe better to separate the incerement and then check </technical_language>
code&comment2code: <code> public void add(E newInterval) { super.add(newInterval); <START> fListeners.stream().forEach(l -> l.elementAdded(this, newInterval)); <END> } </code><technical_language> you can do fListeners.forEach() directly on Collections </technical_language>
code&comment2code: <code> public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) { this.docsToCheckAndEvents = docsToCheckAndEvents; <START> List<String> docs = new ArrayList<String>(); <END> docs.addAll(docsToCheckAndEvents.keySet()); setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs); } </code><technical_language> new ArrayList<String>(); -> new ArrayList<>(); </technical_language>
code&comment2code: <code> private static String getTestingAlias(GoImportSpec testingImportSpec) { String alias = GoConstants.TESTING_PATH; <START> if (testingImportSpec != null) { <END> alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : ""; } return alias; } </code><technical_language> alias variable is redundant </technical_language>
code&comment2code: <code> public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) { <START> this.populate(source); <END> } </code><technical_language> This should be using super(source); instead of the populate method (I know it was like this in ComplianceStatusDTO, and it is wrong there too). </technical_language>
code&comment2code: <code> public MapOperation() { final ILogger logger = this.logger(); final int forcedEvictionRetryCount = getRetryCount(); evictions = new Eviction[]{ new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new AllEntriesEviction(logger, this), <START> new PartitionAllEntriesEviction(logger, this) <END> }; } </code><technical_language> We create a new map-operation for every call, so moving evictions here doesn't make any difference. </technical_language>
code&comment2code: <code> private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); <START> if (timestamp instanceof String) return Instant.parse(timestamp.toString()); <END> return Instant.ofEpochMilli((long) timestamp); } </code><technical_language> We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces. </technical_language>
code&comment2code: <code> <START> public AggregatorFactory[] getMetrics() <END> { return metrics; } </code><technical_language> Do all of these getters need to be public ? I think except getBytesInMemory(), others can be default package access. </technical_language>
code&comment2code: <code> public void prepare() throws IOException { e = SQLExecutor.builder(clusterService) <START> .enableDefaultTables() <END> .addTable("create table t (" + " id integer primary key," + " qty integer constraint check_qty_gt_zero check (qty > 0)," + " constraint check_id_ge_zero check (id >= 0)" + ")") .build(); plannerContext = e.getPlannerContext(clusterService.state()); } </code><technical_language> suggestion  Please don't add tables that are not used. Wastes CPU cycles. </technical_language>
code&comment2code: <code> public void setUp() { <START> jUnitCore = new JUnitCore(); <END> testListener = new TestListener(); jUnitCore.addListener(testListener); } </code><technical_language> In JUnit4-style tests, you can assign variables where they are defined (and make them final if you want :-). JUnit4 won't create an instance of the class until just before it is run, and it will make it eligible for garbage collection right after it is run. </technical_language>
code&comment2code: <code> protected boolean validate() { if (!canRunActionOnNonManagedVm()) { return false; } if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) { addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE); return false; } <START> ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, <END> getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils())); return validator.validate(); } </code><technical_language> I tend to agree. I mean the validator should not be used in other places, as its name indicates, but several times we extended the use of validators in the past so it may be the better approach to simplify its instantiation </technical_language>
code&comment2code: <code> public TrustManagerFactory getTrustMgr(String serverName) { try { <START> KeyStore trustStore = trustMgrMap.get(serverName); <END> if (trustStore != null) { TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); fact.init(trustStore); return fact; } return null; } catch (NoSuchAlgorithmException | KeyStoreException e) { throw new RuntimeException(e); } } </code><technical_language> I would prefer this code to be done in the KeyStoreHelper constructor and keep a Map<String, TrustManagerFactory > so can be detected at this moment and this is also like how we do for the SNI key manager mapping. </technical_language>
code&comment2code: <code> public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) { boolean tmp = this.isInModuleInfo; this.isInModuleInfo = true; TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator); <START> this.isInModuleInfo = tmp; <END> return edit; } </code><technical_language> I suggest putting this into a finally block. </technical_language>
code&comment2code: <code> public <K, V> RemoteCache<K, V> getCache(String cacheName) { <START> RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); <END> if ( cache == null ) { throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) ); } return cache; } </code><technical_language> Should this become a property? </technical_language>
code&comment2code: <code> public static Object valueForStringWithType(String value, VoltType type) { <START> if (type == null || type == VoltType.NULL) { <END> return null; } Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value); assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType())); return retval; } </code><technical_language> do we allow type == null? It doesn't make sense to me to take a value without type info. probably add a precondition check to forbid that. </technical_language>
code&comment2code: <code> public void testContructor() throws IOException { String code = "S2020-04-04"; ReportingPeriod period = ReportingPeriod.from(code); assertEquals(period.getClass(), SinceX.class); <START> assertEquals(period.getClass(), SinceX.class); <END> } </code><technical_language> doppelt? </technical_language>
code&comment2code: <code> public void testGetConnectableFileStorageConnectionsByStorageType() { List<StorageServerConnections> conns = dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS); assertNotNull(conns); assertEquals(1, conns.size()); for (StorageServerConnections conn : conns) { <START> assertTrue(conn.getstorage_type() == StorageType.NFS); <END> } } </code><technical_language> please user assertEquals </technical_language>
code&comment2code: <code> public static void setOverrideFileName(String... path) { fOverridePath = <START> (path == null) ? null : path; <END> fOverride = true; } </code><technical_language> path </technical_language>
code&comment2code: <code> void addChanges(Collection<String> filesToUpdate, Collection<IResource> resourcesToUpdate) { synchronized (lock) { files.addAll(filesToUpdate); resources.addAll(resourcesToUpdate); } <START> if (!filesToUpdate.isEmpty()) { <END> schedule(defaultDelay); } } </code><technical_language> Small style nit: We don't use braces around simple statements. </technical_language>
code&comment2code: <code> public static synchronized String getEncryptionKey(String name) { <START> final String keyString = getUniqueId(name); <END> if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) { generateEncryptionKey(keyString); } return CACHED_ENCRYPTION_KEYS.get(keyString); } </code><technical_language> Why not use name as the key in CACHED_ENCRYPTION_KEYS? </technical_language>
code&comment2code: <code> public void init(IEditorSite site, IEditorInput input) { super.init(site, input); TaskData taskData = getModel().getTaskData(); if (taskData != null) { GerritChange change = GerritUtil.getChange(taskData); final ChangeDetailX detail = change.getChangeDetail(); try { review = GerritUtil.toReview(detail); } catch (GerritException e) { <START> throw new RuntimeException(e); <END> } } } </code><technical_language> That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead. </technical_language>
code&comment2code: <code> public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { <START> return new SnapshotInfo(EMPTY_STRING); <END> } </code><technical_language> This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field). </technical_language>
code&comment2code: <code> public long getEntryLastModified() { if (modTimes == null) return 0; Long cutOff = Long.valueOf(super.getEntryLastModified()); <START> SortedSet<Long> head = modTimes.headSet(cutOff, true); <END> return head.isEmpty() ? 0 : head.last().longValue(); } </code><technical_language> headSet(Object,boolean) is a Java 6 API. We need to define cutOff as super.getEntryLastModified() - 1 instead. </technical_language>
code&comment2code: <code> public ParameterizedSqlFactory(String initialSql) { sqlStringBuilder = new StringBuilder(initialSql); <START> parameters = new ArrayList(); <END> } </code><technical_language> Initialization of the list should use generics. For this case, you can specify an empty generic-type placeholder and the compiler should be able to auto-detect what type should be used. </technical_language>
code&comment2code: <code> public long getReadyTimestamp(Constraints viewConstraints) { String normalizedConstraints = getNormalizedConstraints(viewConstraints); Path signalPath = new Path(signalDirectory, normalizedConstraints); try { try { FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath); return signalStatus.getModificationTime(); } catch (final FileNotFoundException ex) { } return -1; <START> } catch (NumberFormatException e) { <END> throw new DatasetException("Signal contents were modified to not be a number: " + signalPath, e); } catch (IOException e) { throw new DatasetIOException("Could not access signal path: " + signalPath, e); } } </code><technical_language> Is this needed? What throws NumberFormatException? </technical_language>
code&comment2code: <code> private boolean hostHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); if (cluster == null) { return false; } ArchitectureType archType = cluster.getArchitecture(); return <START> (archType == ArchitectureType.ppc64) || <END> (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle); } </code><technical_language> Use equals instead of '==' as follows (And do the same for the 2 other conditions): ArchitectureType.ppc64.equals(archType); </technical_language>
code&comment2code: <code> private static String getExtension(String name) { int ext = name.lastIndexOf('.'); return 0 < ext ? <START> name.substring(ext, name.length()) : <END> ""; } </code><technical_language> name.substring(ext) is equivalent and shorter to write. </technical_language>
code&comment2code: <code> public void checkpoint() { <START> throw new UnsupportedOperationException("Checkpoint is not supported in NoopJournalSystem"); <END> } </code><technical_language> more consistent to make this a no-op like other methods </technical_language>
code&comment2code: <code> private void recalculateMacsCount() { if (!validate()) { setAvailableMacsCount(-1); return; } if (macRange.getMacPoolId() == null) { String from = getLeftBound().getEntity(); String to = getRightBound().getEntity(); <START> Long count <END> = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1; setAvailableMacsCount(count.intValue()); } } </code><technical_language> macToLong returns 'long' </technical_language>
code&comment2code: <code> public void setup() { <START> buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents); <END> } </code><technical_language> Is this cast necessary? </technical_language>
code&comment2code: <code> private boolean filterInvalid(Position position) { <START> return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180; <END> } </code><technical_language> It would make sense to check minimum values as well. </technical_language>
code&comment2code: <code> public Set<Location> getAllowedLocations() { Set<Location> allowedLocations = new HashSet<Location>(); allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <START> return allowedLocations; <END> } </code><technical_language> Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); </technical_language>
code&comment2code: <code> <START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> TransactionSupport.executeInNewTransaction( new TransactionMethod<Void>() { @Override public Void runInTransaction() { createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); return null; } }); } </code><technical_language> no need explicitly open transaction, only one save to DB, transaction will be open automaticly </technical_language>
code&comment2code: <code> public Sheet getDataSheet(File file) { stream = new PushbackInputStream(new FileInputStream(file)); Workbook wb = null; try { wb = WorkbookFactory.create(stream); } catch (Exception e) { <START> Log.error("Workbook creation exception:" + e); <END> } return wb.getSheetAt(0); } </code><technical_language> It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error("Workbook creation exception", e); ? Is there a reason behind using 2 different ways of logging errors? </technical_language>
code&comment2code: <code> public void updateAttributes() { OperatingSystem operatingSystem = getCurrentOperatingSystem(); if (operatingSystem != null) { OSProcess process = operatingSystem.getProcess(this.processID); if (process != null) { copyValuesToThisProcess(process); } else { <START> LOG.error("No process found: {}", this.processID); <END> } } else { LOG.error("Unsupported platform. No update performed."); } } </code><technical_language> That's not much different than the current getProcess(int processID) except with an optional rather than null. (And the API for that is fixed so we can't change it.) That's not the problem I'm discussing... the problem is that someone writing new OSProcess(1234) will definitely get a Process object unless we throw an exception. We could throw an InstantiationError, for example, and require them to handle it. Or a MissingResourceException. Or return a class with the pid and essentially zero data. Perhaps I should have thought about this dilemma before suggesting the feature! </technical_language>
code&comment2code: <code> public boolean isMissingHookConflict() { <START> return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); <END> } </code><technical_language> avoid using this in these cases. </technical_language>
code&comment2code: <code> public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups( final boolean recursive) { if (!recursive) { if (isResolved()) { return Collections.emptyMap(); <START> } else { <END> return Collections.singletonMap(getGroup().getGroupUUID(), this); } } else { return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>()); } } </code><technical_language> Nit: My pref would be to eliminate the unneeded elses (117,120) since there are returns. </technical_language>
code&comment2code: <code> public boolean nextBoolean() throws IOException { requirePeek(); boolean value; try { <START> value = parser.getBooleanValue(); <END> } catch (JsonParseException e) { value = Boolean.parseBoolean(parser.getValueAsString()); } clearPeek(); return value; } </code><technical_language> Can you use parser.getCurrentToken() to detect JSON type ? </technical_language>
code&comment2code: <code> <START> boolean closeOnProtocolViolation() { <END> return closeOnProtocolViolation; } </code><technical_language> why are all methods public except this one ? </technical_language>
code&comment2code: <code> <START> public String getSelinuxEnforceMode() { <END> if (selinuxEnforceMode == null) { } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) { return constants.disabled(); } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) { return constants.permissive(); } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) { return constants.enforcing(); } return constants.notAvailableLabel(); } </code><technical_language> This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties. </technical_language>
code&comment2code: <code> public void startThreads() { <START> if (!this.threadStarted) { <END> synchronized (this) { if (!this.threadStarted) { int nbThreads = this.configuration.getProperty("mentions.poolSize", 1); for (int i = 0; i < nbThreads; i++) { startConsumer(); } this.threadStarted = true; } } } } </code><technical_language> Sounds like you forgot to remove this one </technical_language>
code&comment2code: <code> public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } this.layout(); } </code><technical_language> Why do you perform this test on FeaturesProvider's class? This really looks strange and I do not see how this relates to the goal of this commit... </technical_language>
code&comment2code: <code> public List<Annotation> getQualifiers() { return new ArrayList<Annotation>( <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ); } </code><technical_language> I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList. </technical_language>
code&comment2code: <code> protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { <END> public Void run() throws Exception { remoteCacheManager = new RemoteCacheManager(config, true); return null; } }); remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); } </code><technical_language> It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration </technical_language>
code&comment2code: <code> <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); } </code><technical_language> Shouldn't this copy in baseSelectors? I know it it currently empty, but the code implies you want to add another selector to the base selectors. </technical_language>
code&comment2code: <code> protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } } </code><technical_language> there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to. </technical_language>
code&comment2code: <code> public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); <START> return new DecoderResult(cause); <END> } </code><technical_language> nit: merge lines </technical_language>
code&comment2code: <code> private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); } </code><technical_language> Why 5? Just use the default unless there's a good reason not to. </technical_language>
code&comment2code: <code> public Collection<String> getNames() { if (names == null) { <START> names = new HashSet<>(named.keySet()); <END> namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); } return Collections.unmodifiableSet(names); } </code><technical_language> Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field. There's only one place calling this method now, so the caching doesn't buy us anything. </technical_language>
code&comment2code: <code> public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.error("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; } </code><technical_language> Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it. </technical_language>
code&comment2code: <code> <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; } </code><technical_language> This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused) </technical_language>
code&comment2code: <code> public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; } </code><technical_language> This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE. </technical_language>
code&comment2code: <code> public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } } </code><technical_language> CompletableFuture<Boolean> to avoid raw types </technical_language>
code&comment2code: <code> public void testIsExternalVM() throws IOException { try { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> } </code><technical_language> <LINK_0> In other words: throw the exception upwards and fail the test if parsing the XML fails. </technical_language>
code&comment2code: <code> public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> if (fileList == null) { return false; } for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; } </code><technical_language> Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files </technical_language>
code&comment2code: <code> public void addWhiteListPatterns(String... patterns) { <START> this.whiteListPatterns.addAll(Arrays.asList(patterns)); <END> } </code><technical_language> Collections.addAll(whiteListPatterns, patterns) can be used here. </technical_language>
code&comment2code: <code> private Long getRegistrationMillis(String playerName) { <START> if (!isRegistered(playerName.toLowerCase())) { <END> return null; } PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; } </code><technical_language> I think that this check can be avoided as we already check if auth != null below </technical_language>
code&comment2code: <code> public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (numSegments < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; } </code><technical_language> typo: capacityFactor instead of numSegments </technical_language>
code&comment2code: <code> public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } <START> allocateCurrentArray(); <END> } </code><technical_language> This is not needed here </technical_language>
code&comment2code: <code> public WorkspaceItem build() { try { return workspaceItem; <START> } catch (Exception e) { <END> return handleException(e); } } </code><technical_language> The return statement can never throw an exception here. So please remove the try-catch block. </technical_language>
code&comment2code: <code> <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); } </code><technical_language> Why sorted map? TreeMap is sorted already?! </technical_language>
code&comment2code: <code> protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); <END> } </code><technical_language> [minor] Split into two asserts or add a message showing what the offending value actually is? </technical_language>
code&comment2code: <code> public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); <END> } </code><technical_language> Please call ArtifactToken constructors without guid. </technical_language>
code&comment2code: <code> public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> } </code><technical_language> I think the deprecate is sufficient. Why also log a warning? </technical_language>
code&comment2code: <code> public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); } </code><technical_language> When will this be false? </technical_language>
code&comment2code: <code> public void close() throws InterruptedException { <START> close(false, false); <END> } </code><technical_language> the second parameter can be removed </technical_language>
code&comment2code: <code> protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb); } <START> } <END> </code><technical_language> This class has a member variable called indent which will incur a data race in recursivelyPrint. This is easily fixable though by just making indent a parameter to recursivelyPrint. I realize it's debug-only code. </technical_language>
code&comment2code: <code> public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> if (logger.isDebugEnabled()) { <END> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); } } </code><technical_language> if condition not needed. </technical_language>
code&comment2code: <code> private int getNextPosition() throws CoreException { <START> if (nextMemberPosition == -1) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; } </code><technical_language> Better: nextMemberPosition < 0 </technical_language>
code&comment2code: <code> public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; } </code><technical_language> nit: make bulkRequest.numberOfActions() a Supplier so it is only called if trace logging is enabled. suggestion logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); </technical_language>
code&comment2code: <code> public int size() { int size = 0; for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; } </code><technical_language> isn't the iterator() excluding the expired and Tombstones? </technical_language>
code&comment2code: <code> public static File getDiskCacheDir(Context context, String uniqueName) { final String cachePath; <START> if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) <END> && context.getExternalCacheDir() != null) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); } </code><technical_language> I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE. </technical_language>
code&comment2code: <code> <START> String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); } </code><technical_language> mark this method private as this is only used in this class. </technical_language>
code&comment2code: <code> private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) <END> : new DefaultMustacheFactory(new PerClassMustacheResolver(key)); } </code><technical_language> I think we could make this initialization more terse if we initialize MustacheResolver with the ternary operator and pass it to DefaultMustacheFactory. java new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)) </technical_language>
code&comment2code: <code> public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && <START> !SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && <END> !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; } </code><technical_language> If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition. </technical_language>
code&comment2code: <code> public void testLogin() throws Throwable { <START> InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); } </code><technical_language> Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of "SaneAsyncTask" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it. [0] <LINK_0> </technical_language>
code&comment2code: <code> public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), <END> ClientDnsLookup.USE_ALL_DNS_IPS); } </code><technical_language> We don't need to call toString() </technical_language>
code&comment2code: <code> public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.getStats(); <END> } </code><technical_language> I would like to remove the method getStats and would like to make the aggStats static. </technical_language>
code&comment2code: <code> private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId().toString())); <END> writer.writeEndElement(); } </code><technical_language> toString() is not needed here, AFAIK. </technical_language>
code&comment2code: <code> public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = checkNotNull(ImmutableList.copyOf(series)); <END> } </code><technical_language> You shouldn't need the checkNotNull </technical_language>
code&comment2code: <code> protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> } </code><technical_language> can this case be given? I mean having an entry for the given uuid but with no registrations? </technical_language>
code&comment2code: <code> <START> public synchronized Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); } </code><technical_language> @manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed. </technical_language>
code&comment2code: <code> public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == android.R.id.home) { toggle(); <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; } </code><technical_language> Could we get brackets around this if {} </technical_language>
code&comment2code: <code> public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> ex) { <END> throw new UncheckedIOException(ex); } } </code><technical_language> super nit (okay to ignore): Here and below: For consistency, consider "e" rather than "ex". Typically we only use "ex" for nested catch blocks where the name "e" is already being used by the enclosing block. </technical_language>
code&comment2code: <code> private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); if (prefix.length() == 0) { return null; } <START> return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; <END> } </code><technical_language> Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ? </technical_language>
code&comment2code: <code> protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> m_os.write(bytes); <END> } </code><technical_language> what about the null case? </technical_language>
code&comment2code: <code> private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } else if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END> </code><technical_language> extra else statement, please remove </technical_language>
code&comment2code: <code> private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), <END> sourceSelfTime); mergeChildren(destination, source); } </code><technical_language> - space after comma - you need to pass the source duration as well </technical_language>
code&comment2code: <code> @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); <END> } return null; }); } </code><technical_language> Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete. </technical_language>
code&comment2code: <code> public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; } </code><technical_language> if (!isExplicit) { // ... around the try </technical_language>
code&comment2code: <code> C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.put(t, child); <START> return child; <END> } else return children.get(t); } </code><technical_language> What about thread safety here? I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive false from the contains() method and execute the above code block. That might be the reason the blocking putIfAbsent method is used here? </technical_language>
code&comment2code: <code> public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.startListeningForDirection(); <END> } </code><technical_language> i'd maybe just "forward" the onConnect to the presenter instead </technical_language>
code&comment2code: <code> public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } <START> return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); <END> } </code><technical_language> yup, this is incorrect, seems I failed somewhere, this logic has to be in public ByteBuffer[] nioBuffers(), gonna change it </technical_language>
code&comment2code: <code> <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); } </code><technical_language> why the instance-level lock suggestion, vs. what's been implemented here. seems like overkill </technical_language>
code&comment2code: <code> <START> public boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; } </code><technical_language> Is this method going to be overridden in a subclass to provide a different behavior? This method can be protected if is not supposed to be overridden outside the package. </technical_language>
code&comment2code: <code> private ArrayList<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> } </code><technical_language> Casting to ArrayList is brittle. Could we return List<> from here instead? </technical_language>
code&comment2code: <code> <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); } </code><technical_language> Missed this one in the previous review, needs updating as well! </technical_language>
code&comment2code: <code> private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { throw new RuntimeException(e); } buf.writerIndex(buf.capacity()); return buf; } </code><technical_language> Is this a race or corruption happens all the time? Change looks fine, but I did not understand the actual issue with the current code on why corruption happening. </technical_language>
code&comment2code: <code> public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); } </code><technical_language> Is this the value we use for all other protocols? </technical_language>
code&comment2code: <code> void cancel() { super.cancel(); <START> if (callback != null) { <END> callback = null; } } </code><technical_language> No if check needed, just always set the reference to null. </technical_language>
code&comment2code: <code> public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new Error("Cannot cancel log4j watchdog", cause); <END> } } </code><technical_language> new Error -> new RuntimeException </technical_language>
code&comment2code: <code> public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> } </code><technical_language> Very minor: it's probably cleaner just to initialized ENABLED_LANGUAGES using Arrays.asList </technical_language>
code&comment2code: <code> private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 1; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); } </code><technical_language> Why is this hardcoded? and why is it 1 not 0? </technical_language>
code&comment2code: <code> public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); <START> Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); } </code><technical_language> This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it. </technical_language>
code&comment2code: <code> public void testCompareRanges() { <START> assertTrue(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10) == 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); } </code><technical_language> Use assertEquals </technical_language>
code&comment2code: <code> public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; if(build){ this.build = build; }else{ <START> this.building = build; <END> } } </code><technical_language> Verificar necessidade desse else </technical_language>
code&comment2code: <code> public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) <START> throws Exception <END> { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; } </code><technical_language> unnecessary throws (same for the constructor above). </technical_language>
code&comment2code: <code> public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> if (help) { <END> commandInvocation.println(commandInvocation.getHelpInfo()); } return CommandResult.SUCCESS; } </code><technical_language> print help all the time? the command > server alone isn't valid. </technical_language>
code&comment2code: <code> for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value().toLowerCase()); <END> } </code><technical_language> .value() returns .name().toLowerCase() </technical_language>
code&comment2code: <code> private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; } </code><technical_language> Why don't you change getAction() to return a Collection<ContributionItem>? </technical_language>
code&comment2code: <code> public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME); } </code><technical_language> In all assert method, the first argument is the "expected" value while the second one is the "actual" value. Can you swap them in this file to match that definition? </technical_language>
code&comment2code: <code> public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { <START> return (ModelAdaptor<T>) adaptors.get(attributeType); <END> } </code><technical_language> suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType); </technical_language>
code&comment2code: <code> public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey}; <END> } </code><technical_language> If you override accountId then the parentKey is automatically a member, and this needs to only include the patchKey. </technical_language>
code&comment2code: <code> public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START> <END> } } </code><technical_language> If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all? </technical_language>
code&comment2code: <code> <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); } </code><technical_language> nit: Could you have Override in its own line. </technical_language>
code&comment2code: <code> static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(ImmutableList.copyOf(list)::get) <END> .collect(toImmutableList()); } </code><technical_language> Drop this ImmutableList.copyOf wrapper. It reduces clarity and we do expect random-access lists here anyway. </technical_language>
code&comment2code: <code> private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error) <END> return getRealException(cause); else return re; } </code><technical_language> CacheException instanceOf RuntimeException, I guess you can simplify here. </technical_language>
code&comment2code: <code> public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; } </code><technical_language> What does this change do? </technical_language>
code&comment2code: <code> public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; } </code><technical_language> We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects: addAttribute("blah").setNillable(true).setLabelAttribute(true) </technical_language>
code&comment2code: <code> public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); <START> if (conversionService != null) { <END> evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; } </code><technical_language> So, maybe just remove this code for now? And keep in mind it. However I remember this one: <LINK_0> I mean to rely just only on 'system-wide conversion service', not from endpoint. </technical_language>
code&comment2code: <code> public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); <START> JdbiUtil.closeIfNeeded(h); <END> return result; } </code><technical_language> I believe we shouldn't close the handle here. It will be closed in the afterCompletion method. I think also it will probably be ignored because the handle is still binded to the active transaction. </technical_language>
code&comment2code: <code> <START> public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); } </code><technical_language> In this case, shouldn't we getrid of the project parameter here (if we know the project, we shouldn't specify an extra initial path, or we should explicitly use the initial path. </technical_language>
code&comment2code: <code> public String getReplicaPath() { <START> return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator <END> + partitionId.toPathString(); } </code><technical_language> minor: would prefer that Cloud_Replica_Keyword comes before mount path since that would order the path from least to most granular </technical_language>
code&comment2code: <code> public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); } </code><technical_language> Why can't we add this parent->children listing cache even if the parent status is not in the other map? </technical_language>
code&comment2code: <code> private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } callBackExecutor.execute( <START> () -> executeCallbacks(segmentHolder) <END> ); } </code><technical_language> Pointless two level submission. executeCallbacks() submits each callback to itself another one time (this means that it's valuable to annotate each method in this class in which executor it's supposed to be run. Given that there are two different executors, plus "external", client code execution context (which we kind of shouldn't know where runs) </technical_language>
code&comment2code: <code> public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(this.transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } } </code><technical_language> Is this needed here? If not, consider dropping it. </technical_language>
code&comment2code: <code> private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression)); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; } </code><technical_language> useless parentheses </technical_language>
code&comment2code: <code> protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(q -> q.getActualName(), q -> q)); <END> } </code><technical_language> Queue::getActualName ? </technical_language>
code&comment2code: <code> public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; String name = myBundle.getSymbolicName(); <START> return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name; <END> } </code><technical_language> Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString </technical_language>
code&comment2code: <code> public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else if (o == null) { <END> m_sourceGraphControl.setSourceText(""); } } </code><technical_language> The test on the "else" case isn't needed -- if it's anything but a TextSelection the text can be set to the emprty string. </technical_language>
code&comment2code: <code> <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; } </code><technical_language> This could be private if you move the field creation to the holder as i suggested. </technical_language>
code&comment2code: <code> public boolean hasChildren(Object element) { <START> return ((MyModel) element).children.size() > 0; <END> } </code><technical_language> Use isEmpty() to check whether the collection is empty or not. </technical_language>
code&comment2code: <code> public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> try{ <END> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); }catch(Exception e) { e.printStackTrace(); } } return propertyList; } </code><technical_language> I believe we can remove the try/catch wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating? </technical_language>
code&comment2code: <code> private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); } </code><technical_language> Remove this ones </technical_language>
code&comment2code: <code> String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == null) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } } </code><technical_language> This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item. </technical_language>
code&comment2code: <code> private WikipediaApp getApplication() { <START> return (WikipediaApp) getPageActivity().getApplication(); <END> } </code><technical_language> How about WikipediaApp.getInstance() instead? </technical_language>
code&comment2code: <code> <START> public boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); } </code><technical_language> Should this be public or private? It is used only in the validator </technical_language>
code&comment2code: <code> <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } } </code><technical_language> Same here, JavaDocs for this method please </technical_language>
code&comment2code: <code> public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return actions; } </code><technical_language> Immutable </technical_language>
code&comment2code: <code> private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); <END> part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; } </code><technical_language> This code raises two more (previously existing) concerns: 1. Which iconURI has higher priority the descriptor or the part? 2. What happens if the iconURI of the descriptor is changed? </technical_language>
code&comment2code: <code> private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> } </code><technical_language> This will throw redundancy warnings in IntelliJ </technical_language>
code&comment2code: <code> <START> public String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); } </code><technical_language> why is it public? </technical_language>
code&comment2code: <code> protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> setReturnValue(new ArrayList<>()); <END> return; } setReturnValue(filterDisks(diskList)); } </code><technical_language> Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty </technical_language>
code&comment2code: <code> public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); } </code><technical_language> Oh, is this why we don't need thread-safety on filter hashcode methods i guess? This seems kind of a funny way to prime them with the cached values, I think maybe the supplier.memoize pattern would be a little cleaner and make this not necessary? </technical_language>
code&comment2code: <code> protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); } </code><technical_language> there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ? </technical_language>
code&comment2code: <code> private Object[][] finderSupportedResourceTypeData() { return new Object[][] <START> { <END> { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; } </code><technical_language> You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation </technical_language>
code&comment2code: <code> public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null); <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); } </code><technical_language> We actually don't need this line at all. The test check something else </technical_language>
code&comment2code: <code> public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> Assertion.assertTrue(topBar.isLogoVisible()); <END> topBar.clickWikiaLogo(); Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); } </code><technical_language> I think if it's not visible, click should fail, so is the assertion needed? </technical_language>
code&comment2code: <code> private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; } </code><technical_language> Should this be initialized in a static / thread-safe context? </technical_language>
code&comment2code: <code> void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals(surveyList.get(0).getName(),"1.10.36 all questions"); <END> } </code><technical_language> This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "," have no space after them. </technical_language>
code&comment2code: <code> public GroupScan clone(List<SchemaPath> columns) { <START> HBaseUtils.verifyColumns(columns, hTableDesc); <END> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; return newScan; } </code><technical_language> We should replace null columns with all_columns before verification or we will get exception. You have changed initial order of statements. </technical_language>
code&comment2code: <code> <START> static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); } </code><technical_language> Can be private method. </technical_language>
code&comment2code: <code> private void rematchAllNetworksAndRequests() { final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, <START> oldDefaultNetwork, now); <END> } </code><technical_language> hmm, I don't think this can get build pass. </technical_language>
code&comment2code: <code> public String getScroller() { <START> return scroller == null ? DEFAULT_SCROLLER : scroller; <END> } </code><technical_language> wdyt if we replace it by  return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER) if you agree you will have some adaptation on 10.10 (java 8) </technical_language>
code&comment2code: <code> public String getMessage(){ <START> return this.message; <END> } </code><technical_language> Nit: unnecessary this. </technical_language>
code&comment2code: <code> public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType.toString()); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType.toString()); } return lvType; } </code><technical_language> no need for .toString() </technical_language>
code&comment2code: <code> <START> public void clear() { <END> this.domainsVisibility.clear(); } </code><technical_language> this should be synchronized as well </technical_language>
code&comment2code: <code> public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> Long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); } </code><technical_language> Since you are at it, can you please change this to long primitive type? :) </technical_language>
code&comment2code: <code> private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (context) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); } </code><technical_language> I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor. </technical_language>
code&comment2code: <code> private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength + 1); <END> } return message; } </code><technical_language> This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace "maxLength + 1" with just "maxLength". </technical_language>
code&comment2code: <code> public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated();; <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); } </code><technical_language> double ; </technical_language>
code&comment2code: <code> public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); } </code><technical_language> unnecessary linebreak </technical_language>
code&comment2code: <code> public static void runJSTestSuite() throws InterruptedException { int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 60; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> } </code><technical_language> Why not just bump it up to 180 across the board? </technical_language>
code&comment2code: <code> public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> HashMap<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); } </code><technical_language> Nit: declare as Map </technical_language>
code&comment2code: <code> public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { new ThriftAccessLogger().log( String.format("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation)); <START> } <END> </code><technical_language> I thought it would be something like  LOG.info("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation);  and ThriftAccessLogger.log would just go away </technical_language>
code&comment2code: <code> public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getActiveInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; } </code><technical_language> getActiveInstance is deprecated, please use good old getInstance. </technical_language>
code&comment2code: <code> public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> synchronized (lock) { if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } } </code><technical_language> As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency. </technical_language>
code&comment2code: <code> public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new LinkedList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); } </code><technical_language> If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster. </technical_language>
code&comment2code: <code> public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } } </code><technical_language> We have a large number of tests that don't use TestHazelcastInstanceFactory at all and call Hazelcast.newHazelcastInstance() directly (in combination with Hazelcast.shutdownAll() / HazelcastInstanceFactory.shutdownAll() / HazelcastInstanceFactory.terminateAll()). Shouldn't those be checked as well, somehow? </technical_language>
code&comment2code: <code> public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> getReturnValue().setSucceeded(true); <END> } </code><technical_language> please change to setSucceeded </technical_language>
code&comment2code: <code> <START> void validate() { <END> } </code><technical_language> Interesting wrapping style :) </technical_language>
code&comment2code: <code> private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } } </code><technical_language> deliverEvents does not handle interruptions, so this is essentially a no-op if previous is already executing. </technical_language>
code&comment2code: <code> private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); <START> rollupNode.put("timestamp", rollup.getTimestamp()); <END> SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); } </code><technical_language> Why do gauges get timestamp twice? </technical_language>
code&comment2code: <code> public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); this.addAbility(VigilanceAbility.getInstance()); <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> } </code><technical_language> this doesn't need to have the ability and effect both be optional, just the ability is fine. </technical_language>
code&comment2code: <code> private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } } </code><technical_language> markDead doesn't need to be under a lock. The caller should call tryRetain() after receiving, which will either prevent markDead from having an effect, if it is called before it. </technical_language>
code&comment2code: <code> private static File getDefaultFile() { <START> File netrc; <END> File home = new File(System.getProperty("user.home")); netrc = new File(home, ".netrc"); if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); if (netrc.exists()) return netrc; return null; } </code><technical_language> no need to declare this here, instead declare the type in line 141 </technical_language>
code&comment2code: <code> <START> static synchronized ServiceContext getServiceContext() { <END> if (serviceContext == null) { synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); } </code><technical_language> I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block. </technical_language>
code&comment2code: <code> public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); <END> listener = new Slf4jLogListener(); logService.addLogListener(listener); } </code><technical_language> remove this line </technical_language>
code&comment2code: <code> <START> public void testDeserialization() throws Exception { <END> for (Short version : versions) { composedBlobIdAndDeserialize(version); } } </code><technical_language> I don't understand the need of this test. We have the next one which tests serialization and deserialization if I am not wrong. Or does this tests something more than the next one ? </technical_language>
code&comment2code: <code> private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> List<VMWithPlugInfo> vmsWithPlugInfo = <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); return vmsWithPlugInfo; } </code><technical_language> should be just return , no need for variable </technical_language>
code&comment2code: <code> public Jedis createResource() { <START> Jedis jedis = new Jedis(this); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; } </code><technical_language> @nykolaslima How about handling selecting db by constructor of BinaryJedis, as authentication takes place? </technical_language>
code&comment2code: <code> public JSchUIConnectionManager(IRemoteServices services) { fConnMgr = (JSchConnectionManager) services.getConnectionManager(); <START> fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() { <END> @Override public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) { return new RemoteAuthenticator(conn); } }); } </code><technical_language> Please keep initialization code out of the Activator class. </technical_language>
code&comment2code: <code> public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null && !conf.isEmpty()) { <END> component.componentConf.putAll(conf); } return this; } </code><technical_language> Nit: I think putAll is a no-op when the conf is empty, so you probably don't need to check. </technical_language>
code&comment2code: <code> public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); } </code><technical_language> Its a heavy read that bug! When you check if breakpoint applicable probably better reverse instanceof check and call. Instanceof is cheaper </technical_language>
code&comment2code: <code> protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { rt.getGarbageInformer().stop(); rt.getGarbageInformer().waitUntilAllTasksFinish(); <START> while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) { rt.getGarbageInformer().gcUnsafe(); } <END> logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); } </code><technical_language> Put this logic into GarbageInformer together with waitUntilAllTasksFinish as we discussed. </technical_language>
code&comment2code: <code> private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } } </code><technical_language> This addition is pointless </technical_language>
code&comment2code: <code> protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); <START> con.setAutoCommit(false); <END> } </code><technical_language> Please remove that </technical_language>
code&comment2code: <code> public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); } </code><technical_language> These null checks will disappear if using a multimap </technical_language>
code&comment2code: <code> private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; } </code><technical_language> What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run. </technical_language>
code&comment2code: <code> public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; } </code><technical_language> Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest. </technical_language>
code&comment2code: <code> private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.info("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; } </code><technical_language> log.debug ? </technical_language>
code&comment2code: <code> public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); } </code><technical_language> We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well. </technical_language>
code&comment2code: <code> public static String toHexString(byte[] digest) { <START> StringBuffer buf <END> = new StringBuffer(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); } </code><technical_language> Use StringBuilder please. </technical_language>
code&comment2code: <code> private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (!lastKilledQueryIsGone) { <END> ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } } return lastKilledQueryIsGone; } </code><technical_language> Invert this so it returns early </technical_language>
code&comment2code: <code> public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; <END> } </code><technical_language> Is this change that makes batcher immediately execute after create new instance of Batcher and then added tasks smaller than capacity size? </technical_language>
code&comment2code: <code> public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); <END> responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); } </code><technical_language> This line should also be removed. </technical_language>
code&comment2code: <code> private void validateAndClose() throws Exception { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } } </code><technical_language> no Exception is thrown in this method </technical_language>
code&comment2code: <code> public int size() { if (currentOffset == NO_VALUES) { return 0; } <START> return maxOffset - currentOffset - 1; <END> } </code><technical_language> Consider: return currentOffset == NO_VALUES ? 0 : maxOffset - currentOffset - 1; </technical_language>
code&comment2code: <code> <START> public void updateEditorPages(int activatedPage) { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { setActivePage(0); } setPartName(getPartName()); } </code><technical_language> activatedPage is not used anymore </technical_language>
code&comment2code: <code> public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename != null) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; } </code><technical_language> Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided. This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur. </technical_language>
code&comment2code: <code> <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; } </code><technical_language> Another non-permissible change </technical_language>
code&comment2code: <code> private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost.replace("mn", "min")); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor.replace("mn", "min")); } return drf.linearWithOffset(linearFactor.replace("mn", "min"), linearOffset.replace("mn", "min")); } </code><technical_language> @ivandalbosco I see that you just copied this piece from JS, but it's not perfect there :) We can drop .replace("mn", "min") everywhere (3 places). This was done as many RSPECs had legacy mn for minutes. It should be fixed now. It there is still some RSPEC using mn and plugin fails, then you better update this RSPEC </technical_language>
code&comment2code: <code> public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; <START> LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " <END> + "<LINK_0>" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { analysisCache = cache; } } </code><technical_language> I find it very unintuitive to find this here... I'd suggest moving the log to PMD.doPMD, which is guaranteed to run once and a little more natural </technical_language>
code&comment2code: <code> private static double sortableLongToDouble(long value) { <START> value = value ^ (value >> 63) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); } </code><technical_language> Same here. Add clarifying parenthesis </technical_language>
code&comment2code: <code> public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException)) { return e; } Throwable cause = e.getCause(); return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause)); <START> } <END> </code><technical_language> if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause);  How about making return statement simpler? </technical_language>
code&comment2code: <code> boolean isEmpty() { <START> return (validIndexSegments.isEmpty()); <END> } </code><technical_language> minor: braces unnecessary </technical_language>
code&comment2code: <code> Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; } </code><technical_language> Please do only whitespace changes in this commit. </technical_language>
code&comment2code: <code> public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File <START> children1 : <END> children) { delete(children1); } } return file.delete(); } </code><technical_language> child </technical_language>
code&comment2code: <code> public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; } </code><technical_language> Why do we call authenticate to log out? If we aren't already authenticated, why do we need to log out? </technical_language>
code&comment2code: <code> private double cleanNumber(double dirtyNumber) { <START> double clean; <END> if (dirtyNumber < 1) clean = 0; else clean = dirtyNumber; return clean; } </code><technical_language> Could be simplified to: java return dirtyNumber < 1 ? 0 : dirtyNumber; </technical_language>
code&comment2code: <code> public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> } </code><technical_language> Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments </technical_language>
code&comment2code: <code> <START> private static Map<String, String> readMessagesFromBundle() { <END> try { ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); Map<String, String> messages = new HashMap<String, String>(); for (String key : bundle.keySet()) { messages.put(key, bundle.getString(key)); } return messages; } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } } </code><technical_language> why do you need to convert the bundle to a map, instead of using it directly? </technical_language>
code&comment2code: <code> public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; <START> if (getClass() != obj.getClass()) return false; <END> BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); } </code><technical_language> Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...) </technical_language>
code&comment2code: <code> private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); <START> if (control.forUser(user).isRefVisible()) { return true; } <END> } return false; } </code><technical_language> [optional] this could be shortened to: return control.forUser(user).isRefVisible(); </technical_language>
code&comment2code: <code> private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] ); <END> } </code><technical_language> please use == for enum comparisons like its done 2 lines above </technical_language>
code&comment2code: <code> <START> public String getConfigFile() <END> { return configFile; } </code><technical_language> You can make this file File </technical_language>
code&comment2code: <code> <START> void close() { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); } </code><technical_language> Probably won't be used, but you should implement AutoCloseable, since you implement close() anyway. </technical_language>
code&comment2code: <code> private void completeInner() { if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { unsubscribe(); } <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } } </code><technical_language> Wouldn't this be an if/else? If we just unsubscribed in the previous lines I don't think we should ever go through this flow. </technical_language>
code&comment2code: <code> protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from " + opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; } </code><technical_language> suggestion logger.error("Found one or more vector errors from {}", opName); </technical_language>
code&comment2code: <code> protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); Reader reader = null; try { reader = new FileReader(fileName); resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } finally { <START> closeQuietly(reader); <END> } return resultLineNumbers; } </code><technical_language> We use Java7, so you should use the try-with-resources feature. </technical_language>
code&comment2code: <code> private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); } </code><technical_language> Missing final (was indicated on the previous patch as well). </technical_language>
code&comment2code: <code> public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> Preconditions.checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); } </code><technical_language> static import </technical_language>
code&comment2code: <code> private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> else { <END> return false; } } </code><technical_language> A redundant else statement </technical_language>
code&comment2code: <code> <START> private void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); } </code><technical_language> Wouldn't it be safer to make this method synchronized? </technical_language>
code&comment2code: <code> private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return new Supplier<StorageStatement>() { @Override public StorageStatement get() { return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); } <START> }; <END> } </code><technical_language> No need to expand the lambda </technical_language>
code&comment2code: <code> <START> public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; } </code><technical_language> Can be package-private? </technical_language>
code&comment2code: <code> public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); } </code><technical_language> Minor: use AssertJ org.assertj.core.util.List.list and static import for readability. </technical_language>
code&comment2code: <code> public void viewInfoUpdated() { <START> this.reinitialize(); <END> } </code><technical_language> * Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); } </technical_language>
code&comment2code: <code> <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens; } </code><technical_language> This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class.  java this.refTokens = refTokens.clone();  as it is now, I could do this:  java Builder b = JSONPointer.builder().append("key1"); JSONPointer jp1 = b.build(); b.append("key2"); JSONPointer jp2 = b.build(); if(jp1.toString().equals(jp2.toString()){ throw new Exception("Oops, my pointers are sharing a backing array"); } </technical_language>
code&comment2code: <code> public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; } </code><technical_language> coudl be just ArrayList since now it is imported ^^ vv </technical_language>
code&comment2code: <code> <START> long consumerLag() { <END> return consumerLag; } </code><technical_language> Would suggest to make it private. </technical_language>
code&comment2code: <code> public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx)); <END> this.groupIdx = groupIdx - 1; } </code><technical_language> In most other places we suppress boxing warnings by manually boxing in the code with Integer.valueOf() around the expression. This is especially true in MessageFormat.format invocations, which are very common in our error paths. I think that is the general approach preferred within JGit. </technical_language>
code&comment2code: <code> public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * random.nextInt(10) + 1; <END> fillChunksAndAssertSuccess(); } </code><technical_language> missing braces ? blobSize can end up to be 1 if random.nextInt(10) returns 0. </technical_language>
code&comment2code: <code> <START> EapAkaAttributeFactory() <END> {} </code><technical_language> Suggest protected to signal that this is for the subclass </technical_language>
code&comment2code: <code> public byte[] toByteArray() { <START> return ByteBuffer.allocate(8).putLong(valueLong).array(); <END> } </code><technical_language> I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize. </technical_language>
code&comment2code: <code> public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> } </code><technical_language> there is no other way of getting article name? </technical_language>
code&comment2code: <code> public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return result; <END> } </code><technical_language> @vilchik-elena Why not simply returning bitSet? </technical_language>
code&comment2code: <code> void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { <START> outer.setUnresolvedCompact(true); <END> } } </code><technical_language> Not required </technical_language>
code&comment2code: <code> public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> } </code><technical_language> hrmmm, is this required? Will this happen already with the cluster teardown? And, is there redundant closing with the after() call? </technical_language>
code&comment2code: <code> public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); } </code><technical_language> What If I give the empty string as an input of that method ? </technical_language>
code&comment2code: <code> public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> ret.put(node, null); return ret; } </code><technical_language> spell out ret </technical_language>
code&comment2code: <code> public int getStreamIndex() { <START> return streamIndex; <END> } </code><technical_language> should not be this private? </technical_language>
code&comment2code: <code> public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (Exception ex) { <END> if (ex instanceof IOException) { throw (IOException)ex; } throw new IOException(ex); } } </code><technical_language> simpler:  } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } </technical_language>
code&comment2code: <code> public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); try { if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } } catch (IOException e) { <START> throw e; <END> } } </code><technical_language> please remove the try { .. } catch ( .. ) block altogether now. </technical_language>
code&comment2code: <code> private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> IStockOperationType operationType = WellKnownOperationTypes.getAdjustment(); <END> operation.setInstanceType(operationType); Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; } </code><technical_language> Remove these extra variables that aren't used except in a setter. </technical_language>
code&comment2code: <code> <START> public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; } </code><technical_language> not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type. </technical_language>
code&comment2code: <code> <START> long getTokenCount() { <END> return tokens.get(); } </code><technical_language> nit: I think we generally prefer to explicitly state the access modifiers. </technical_language>
code&comment2code: <code> public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> e.printStackTrace(); <END> return null; } } </code><technical_language> printStackTrace()? Isn't it better to use a logger? </technical_language>
code&comment2code: <code> void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() <START> && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); } </code><technical_language> This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does. </technical_language>
code&comment2code: <code> public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); } </code><technical_language> Please remove unnecessary brackets: return Config.<Integer>getValue( configValue, compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue() </technical_language>
code&comment2code: <code> public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; <START> updateTagFilter(); <END> updatePlace(place); } }); } </code><technical_language> this is incorrect place for command </technical_language>
code&comment2code: <code> Context prepareDefaultContext(boolean parseAsFlume) { Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); <START> context.put("offsets.topic.replication.factor", "1"); <END> context.put(TOPIC_CONFIG, topic); return context; } </code><technical_language> What does this change bring? Did we need this to get the test working? </technical_language>
code&comment2code: <code> private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return "NA"; <END> } </code><technical_language> Should probably return null </technical_language>
code&comment2code: <code> private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: return DateTimeFormat.forPattern("yyyy"); case simpleSum: <START> break; <END> } return null; } </code><technical_language> Constant simpleSum could even removed as this constant is never used outside this class. </technical_language>
code&comment2code: <code> public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(); <END> for (Object key : Collections.list(defaultProperties.propertyNames())) { this.defaultProperties.put((String) key, defaultProperties.get(key)); } } </code><technical_language> I think this could be a one liner: java this.defaultProperties = new HashMap<>(defaultProperties); </technical_language>
code&comment2code: <code> <START> protected <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); } </code><technical_language> Can this be private? </technical_language>
code&comment2code: <code> public String read(String key) { String data = dataManager.read(key); <START> return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data; <END> } </code><technical_language> I would flip this for clarity: return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data)); </technical_language>
code&comment2code: <code> <START> public void setUp() throws Exception { <END> super.init(); } </code><technical_language> super.init() method never throw an exception. </technical_language>
code&comment2code: <code> public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = Optional.of( indexNullAs ); <END> return thisAsS(); } </code><technical_language> null is not an acceptable value for indexNullAs. You can use null to represent "no value was selected", no need for an Optional. </technical_language>
code&comment2code: <code> public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> Assert.assertEquals("<LINK_0>", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); } </code><technical_language> import static Assert.assertEquals() </technical_language>
code&comment2code: <code> void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); <END> } } </code><technical_language> How can a set be of a negative size? </technical_language>
code&comment2code: <code> <START> public static String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } } </code><technical_language> Package private should always be enough for testing. Use the same package for tests. </technical_language>
code&comment2code: <code> public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> if (originalType == OriginalType.UTF8) { <END> return ((Binary) min).toStringUsingUTF8(); } else { return new String(((Binary) min).getBytes()); } } return min; } </code><technical_language> Had an offline discussion with Aman, we can remove this check and serialize everything using getBytes() </technical_language>
code&comment2code: <code> public int hashCode() { <START> int result = name.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; } </code><technical_language> fullName should be enough here too. </technical_language>
code&comment2code: <code> private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); } </code><technical_language> I think rather than checking > 0, it would make things clearer if you had a static value like DEFAULT_TIMEOUT = -1 and then use that in createHttpClient and change these checks to be socketTimeout != DEFAULT_TIMEOUT. Or something along those lines. </technical_language>
code&comment2code: <code> CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create().set("className", <END> DiffTable.style.range())); } } </code><technical_language> nit: line break after ( or before ".set" here. </technical_language>
code&comment2code: <code> public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> ; <END> new FinishButton().click(); } </code><technical_language> This is pretty lonely semicolon :wink: </technical_language>
code&comment2code: <code> public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { <START> log.infoFormat("process VM {0} that went down", vmId); <END> ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } } </code><technical_language> do we really need this log? now that it is a command we should have a log for running a command, no? </technical_language>
code&comment2code: <code> public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); Preconditions.checkNotNull(defaultFilter); <START> this.defaultFilter = defaultFilter; <END> } </code><technical_language> nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter) </technical_language>
code&comment2code: <code> protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); } </code><technical_language> Actually I don't think this is how it should work? We do not expose jackson directly to the user, and all the encoding and decoding happens on the spring side and not with the SDK itself.. shouldn't this go into the mapper/converter logic instead? </technical_language>
code&comment2code: <code> public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; fetchTopologyFromClusterManager(); <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); } </code><technical_language> Just doing updateTopologyConfigID is not enough. While process a topology change event, the discovery service does more work refer to processTopologyChangeNotification. While combining two events topology change and leadership change together, it is a bit complex. Would suggest to not call the fetchTopologyFromClusterManager. First, the topology change is a notification API from clusterManager. Even with this call, it will fetch the cached value from clusterManagerAdapter. Second, it just add more complexity and doesn't completely solve the problem. </technical_language>
code&comment2code: <code> public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> } </code><technical_language> Normally you just return mClientModeImpl.getSyncDhcpInfo. If you really want to introduce a local make it final. </technical_language>
code&comment2code: <code> public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); } </code><technical_language> why do we use strings here? </technical_language>
code&comment2code: <code> protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); } </code><technical_language> You should use HttpServletResponse.SC_... everywhere, no need for HttpStatus here. </technical_language>
code&comment2code: <code> public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", <START> volumeId) <END> .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); } </code><technical_language> Same for detach </technical_language>
code&comment2code: <code> public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) { <END> continue; } httpMessage.addHeader(header); } } </code><technical_language> As a paranoia sufferer, I would invert the equals to avoid the remote possibility of a NPE: java if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { </technical_language>
code&comment2code: <code> public String getServletMapping() { <START> if ("".equals(this.path) || "/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; } </code><technical_language> this.path is initialized to a value so this is not necessary. </technical_language>
code&comment2code: <code> private static InetAddress toInetAddress(Slice ipAddress) { InetAddress address; try { <START> address = InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } return address; } </code><technical_language> Now that this is a standalone function. You can just do return InetAdress.get... here, and remove the temporary variable. </technical_language>
code&comment2code: <code> public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> } <END> </code><technical_language> EqualsVerifier test please for equals and hashcode </technical_language>
code&comment2code: <code> protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return null; <END> } </code><technical_language> Can we return an empty list here instead? </technical_language>
code&comment2code: <code> protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; } </code><technical_language> Seems like there's a spacing issue here, two spaces instead of 4. </technical_language>
code&comment2code: <code> private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.info("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; } </code><technical_language> log.debug ? </technical_language>
code&comment2code: <code> public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> request.release(); <END> } </code><technical_language> who releases the request if an IOException is thrown? </technical_language>
code&comment2code: <code> public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> containsInAnyOrder("poolName", "poolMember", "poolAddr", "slotNum")); <END> } </code><technical_language> Can we revert this and keep the order deterministic? </technical_language>
code&comment2code: <code> public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getMessage(), "Unknown app 'id'"); <END> } </code><technical_language> I'd then check the exception class plus parameters, not the message that isn't even sent to the user. </technical_language>
code&comment2code: <code> public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: recordChannelId(ctx); NotificationPollService.start(ctx.getApplicationContext()); break; <START> default: <END> L.d("action=" + action); break; } } </code><technical_language> Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time </technical_language>
code&comment2code: <code> private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; } </code><technical_language> can this have an overloaded method please so we don't have to pass null around? suggestion StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); </technical_language>
code&comment2code: <code> void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } } </code><technical_language> and then you may be able to drop the options != null check. </technical_language>
code&comment2code: <code> <START> public void setSelectedChapter(@NonNull Chapter chapter) { <END> if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; } </code><technical_language> If you add @NonNull here than it's not worth checking the null again inside. You should safely assume that the client of the method is fulfilling the non null pre-condition. The IDE will tell the client of the method that a null argument should not be passed. So, either you remove @NonNull or remove the check for != null inside. </technical_language>
code&comment2code: <code> public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); } </code><technical_language> we always use parentheses, also for one-line statements. </technical_language>
code&comment2code: <code> @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); <START> synchronized (Boolean.TRUE){} <END> } </code><technical_language> Can we remove this? I realize what it was for but I don't think it should be kept around in the example. </technical_language>
code&comment2code: <code> private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; <START> mAfterKeys = new HashSet<>(); <END> } return values; } </code><technical_language> Please remove mAfterKeys while you're at it. It was only a workaround for the absence of ContentValues.keySet() on Android 2.x. Since we don't support Android 2 any more you can remove it in most places and replace by mAfterContentValues.keySet() where it's being read. </technical_language>
code&comment2code: <code> private Task<? extends Serializable> createDbTask(Database dbObj) { CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory, true)); <END> DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); } </code><technical_language> The parameter can bee removed </technical_language>
code&comment2code: <code> public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> } </code><technical_language> what is the purpose of maxWriteTimeInMs now? how is it being used? </technical_language>
code&comment2code: <code> static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); <START> if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); } </code><technical_language> exists check is not done for SNAPSHOT jars intentionally so that they get updated everytime. SNAPSHOT jars are to be used for testing only and are designed to get updated on each run. Or else there would be no reason for method 'addSnapshotJarToClassPath' to exist. i guess your failure is a result of running concurrent jobs with SNAPSHOT jars. </technical_language>
code&comment2code: <code> public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } } </code><technical_language> It's better to make the listener unregister itself at stop time instead of storing a boolean. See for instance WorkManagerImpl.init and the implementation of afterStop. </technical_language>
code&comment2code: <code> public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.debug("[{}] Task state {} sent to dispatcher.", id, status); <END> } </code><technical_language> Please keep it in info level. </technical_language>
code&comment2code: <code> public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { <END> currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } return currentBeanMetaData; } </code><technical_language> Why is it done lazily? Seems we'll need it in any case? </technical_language>
code&comment2code: <code> protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(true); <END> } </code><technical_language> Given this is configuration, wouldn't it make more sense to show the parameters in the output, accept them in input, and then fix validation like it's done in the UI? </technical_language>
code&comment2code: <code> private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> hashedPayload = sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; } </code><technical_language> Return the result of sha256 instead of using the local variable. </technical_language>
code&comment2code: <code> public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return null; <END> } </code><technical_language> It's a little harsh to return null because the deprecated method should work as the original implementation, right? Can't this method read the StreamInputReader and get the information from there? </technical_language>
code&comment2code: <code> public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); <START> InstrumentationRegistry.getInstrumentation().waitForIdleSync(); <END> onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); } </code><technical_language> You don't need this. onView() will wait </technical_language>
code&comment2code: <code> Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> Mono.subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); } </code><technical_language> static import </technical_language>
code&comment2code: <code> public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> } </code><technical_language> This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked. </technical_language>
code&comment2code: <code> public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> new SilentMigrationProgressMonitor().NO_OP_SECTION ); <END> } </code><technical_language> There is no reason to create new instance if SilentMigrationProgressMonitor here since NO_OP_SECTION is static </technical_language>
code&comment2code: <code> public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { List<Tree> commas = Lists.newArrayList(); for (InternalSyntaxToken comma : commaTokens) { commas.add(comma); } <START> return new ArrayLiteralTreeImpl(commas); <END> } </code><technical_language> @vilchik-elena can't we directly use commaTokens? </technical_language>
code&comment2code: <code> public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> Arrays.toString(super.macs.toArray())); <END> releaseMacs(); } </code><technical_language> why not to rely on AbstractCollection..toString? </technical_language>
code&comment2code: <code> <START> SubresourceParameter(String value) { <END> super("t", value); } </code><technical_language> Make the constructor public </technical_language>
code&comment2code: <code> private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time; <END> } </code><technical_language> flip the order of the checks - more intuitive IMO. Something like saying "time is valid and is less than" rather than "time is less than and valid" </technical_language>
code&comment2code: <code> public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> print(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); } </code><technical_language> Please do not print to stdout/stderr. Please log instead so output can be silenced by the build infrastructure. </technical_language>
code&comment2code: <code> public View getTopContainer(final View view) { View topView = null; <START> EObject container; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; } </code><technical_language> The local variable is declared in bad scope. </technical_language>
code&comment2code: <code> public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> } </code><technical_language> I don't think this method should be called in a constructor. </technical_language>
code&comment2code: <code> public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { <END> oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; } </code><technical_language> Is this really necessary? AFAIK the scope and key should never be MarshalledValues. </technical_language>
code&comment2code: <code> static String left(String str, int len) { <START> if (str == null || str.isEmpty() || len == 0) { <END> return ""; } if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; } </code><technical_language> str == null cannot be true here as this was already checked upfront by <LINK_0> (it also correctly results in null there). We could also move this empty string or 0 length up under that check as it would be same for both functions. </technical_language>
code&comment2code: <code> public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { <START> if (roleForm == null) <END> { throw new RequestBodyValidationException("Empty request body", bindingResult); } if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); } </code><technical_language> It should never happen, since org.springframework.web.bind.annotation.RequestBody#required is default true </technical_language>
code&comment2code: <code> <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); } </code><technical_language> Minor: you can decrease the visibility modifier for some methods here and change some methods to be static. </technical_language>
code&comment2code: <code> NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { Objects.requireNonNull(vdsNumaNodeDao); <START> this.vdsNumaNodeDao = vdsNumaNodeDao; <END> } </code><technical_language> how about this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao) ? </technical_language>
code&comment2code: <code> public List<ClientModel> getClients() { <START> return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue()); <END> } </code><technical_language> getClients(this, null, null) </technical_language>
code&comment2code: <code> public List<String> getTokens() { ArrayList<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; } </code><technical_language> Coding best practices: Interface i = new Implementation(); </technical_language>
code&comment2code: <code> public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; <START> this.numLocalWorkUnits = 0; <END> } </code><technical_language> Not needed. By default it will always be initialized to 0 </technical_language>
code&comment2code: <code> public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } } </code><technical_language> Intentional change. Keep the originial. </technical_language>
code&comment2code: <code> public void onBackPressed() { if (projectListFragment != null) { projectListFragment.cancelLoadProjectTask(); Log.d(TAG, "Back press detected!"); <START> } <END> super.onBackPressed(); } </code><technical_language> projectListFragment is always set, no null check needed Please remove log output </technical_language>
code&comment2code: <code> private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime()); <END> } } </code><technical_language> not needed (the value is null and won't be used anyway) </technical_language>
code&comment2code: <code> <START> public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); } </code><technical_language> Should this be private? </technical_language>
code&comment2code: <code> private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443)); <END> } </code><technical_language> maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used? </technical_language>
code&comment2code: <code> public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> Page page = data.getDataPage(); <END> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(page); } operator.finish(); } </code><technical_language> We can inline these two vars </technical_language>
code&comment2code: <code> private Element timeZone() { <START> return textElement(BlogConstants.TIMEZONE, entity.getTimeZone()); <END> } </code><technical_language> Use import static </technical_language>
code&comment2code: <code> private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, true, true); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); } </code><technical_language> so do not resolve groups and no recursive as you going to search it anyway. </technical_language>
code&comment2code: <code> public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(new IPropertyChangeListener() { @Override public void propertyChange(PropertyChangeEvent event) { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } } }); } </code><technical_language> lambda? </technical_language>
code&comment2code: <code> public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } } </code><technical_language> I believe && should be here also </technical_language>
code&comment2code: <code> <START> Object getValue(Object obj) throws Exception { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); } </code><technical_language> Minor: can remove throws </technical_language>
code&comment2code: <code> public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> return result; } </code><technical_language> Except for debugging purpose, the "result" local does not seem necessary. </technical_language>
code&comment2code: <code> private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; } </code><technical_language> clientRegistration may be null. Please add a null check here. </technical_language>
code&comment2code: <code> public AddUnseenToBitmapFilter(BitmapBuilder seen, BitmapBuilder bitmap) { this.seen = seen; this.bitmap = <START> bitmapResult; <END> } </code><technical_language> bitmap. </technical_language>
code&comment2code: <code> public void testQuantileAtValueBigint() { QuantileDigest qdigest = new QuantileDigest(1); addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)", toHexString(qdigest)), <START> DOUBLE, <END> 1.0); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)", toHexString(qdigest)), DOUBLE, 0.6); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)", toHexString(qdigest)), DOUBLE, 0.0); } </code><technical_language> I see some surprising results here when adding additional test cases for doubles: * Double.NaN as the input value returns 1.0 (Edit: Double.MIN_VALUE is fine, I forgot this was just slightly greater than 0) </technical_language>
code&comment2code: <code> public boolean isOverutilized() { <START> return memoryManager.isOverUtilized(); <END> } </code><technical_language> I'm ok with either capitalization. But it needs to be consistent. The overutilized 2 lines above is capitalized differently. </technical_language>
code&comment2code: <code> public String explain() throws CouchbaseLiteException { <START> if (c4query == null) <END> check(); synchronized (getDatabase().getLock()) { return c4query.explain(); } } </code><technical_language> c4query should also be synchronized. Move c4query checks to the check method itself. The same thing for the execute() method. See <LINK_0> </technical_language>
code&comment2code: <code> public boolean isObjectFactory() { <START> return getTargetTypeParameter() != null || getParameters().isEmpty(); <END> } </code><technical_language> just return false here. </technical_language>
code&comment2code: <code> <START> StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories, <END> boolean fair) { Assert.notNull(factory, "factory cannot be null"); Assert.notNull(keyDirectories, "keyDirectories cannot be null"); Assert.isTrue(keyDirectories.size() > 0, "At least one KeyDirectory is required"); this.factory = factory; this.keyDirectories.addAll(keyDirectories); this.fair = fair; this.iterator = this.keyDirectories.iterator(); } </code><technical_language> Shound't this ctor be public or at least protected? Otherwise I don't see reason in all those protected methods below. </technical_language>
code&comment2code: <code> public void add(EntityType entity) { validateAddAllowed(entity); <START> createAcl(entity); <END> super.add(entity); } </code><technical_language> Tricky! validateAddAllowed currently checks if you have the WRITE_META permission on the entity. Acl gets created after the check. This breaks OneClickImporter </technical_language>
code&comment2code: <code> private ArtifactCoordinates getArtifactCoordinates(Path p) { <START> return ThrowingFunction.unchecked(RepositoryFiles::readCoordinates).apply((RepositoryPath) p); <END> } </code><technical_language> @adavid9 can you please add throws IOException here and use TrowingFunction at GroupRepositoryProvider.search ? </technical_language>
code&comment2code: <code> <START> public IPinUpdater<? extends ActivityNode> instantiate(ActivityNode node){ <END> IPinUpdater<? extends ActivityNode> updater = null; if(node instanceof CallBehaviorAction){ updater = new CallBehaviorActionPinUpdater(); }else if(node instanceof CallOperationAction){ updater = new CallOperationActionPinUpdater(); }else if(node instanceof SendSignalAction){ updater = new SendSignalActionPinUpdater(); } return updater; } </code><technical_language> To avoid accidental class casts, you can use the following signature: public <T extends ActivityNode> IPinUpdater<T> instantiate(T node) Then unchecked casts can be regrouped into this method (Rather than in each Clients) </technical_language>
code&comment2code: <code> public boolean supportsScroll() { StorageConfiguration conf = coreFeature.getStorageConfiguration(); <START> return conf.isDBSMongoDB() || conf.isVCS(); <END> } </code><technical_language> Please don't do cleanups in the same commit as bugfixes/features/improvements </technical_language>
code&comment2code: <code> public void onResume() { super.onResume(); addCachedDevices(); <START> if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) <END> removeAllDevices(); if (mStartScanOnResume) { mLocalAdapter.startScanning(true); mStartScanOnResume = false; } } </code><technical_language> Style issue: please use braces in a multiline conditional. </technical_language>
code&comment2code: <code> protected void upgradeNexusVersion() throws IOException { final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() ); final String previousVersion = getConfiguration().getNexusVersion(); if ( currentVersion.equals( previousVersion ) ) { setInstanceUpgraded( false ); } else { setInstanceUpgraded( true ); getConfiguration().setNexusVersion( currentVersion ); storeConfiguration(); <START> eventMulticaster.notifyEventListeners( new NexusVersionChangedEvent( this, previousVersion, <END> currentVersion ) ); } } </code><technical_language> Not sure i'd go with events (yet). Model upgrade was not emitting events either, and Status flags with this change would be properly set. Let's go with baby steps, and not introduce events for these yet (unless some other good reason mentioned for it's need) </technical_language>
code&comment2code: <code> <START> public DefDeclaration(String name, Type returnType, List<NameBinding> argNames, <END> TypedAST body, boolean isClassDef, FileLocation location) { if (argNames == null) { argNames = new LinkedList<NameBinding>(); } this.type = getMethodType(argNames, returnType); this.name = name; this.body = (ExpressionAST) body; this.argNames = argNames; this.isClass = isClassDef; this.location = location; } </code><technical_language> Can you make the old constructor call the new one (with a default value for the additional parameter)? </technical_language>
code&comment2code: <code> <START> public Waiter<HeadBucketRequest> bucketNotExists() { <END> return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>() .withSdkFunction(new HeadBucketFunction(client)) .withAcceptors( new HttpFailureStatusAcceptor(404, WaiterState.SUCCESS)) .withDefaultPollingStrategy( new PollingStrategy(new MaxAttemptsRetryStrategy(20), new FixedDelayStrategy(5))) .withExecutorService(executorService).build(); } </code><technical_language> Can we all add the generic parameters for the acceptors? (Like HttpFailureStatusAcceptor<HeadBucketResult>?) </technical_language>
code&comment2code: <code> public TextArea createWidget() { final TextArea textArea = GWT.create(TextArea.class); textArea.addKeyDownHandler(keyDownEvent -> { final int keyCode = keyDownEvent.getNativeKeyCode(); <START> if (keyCode == KeyCodes.KEY_TAB) { <END> destroyResources(); gridPanel.setFocus(true); keyDownEvent.preventDefault(); } keyDownEvent.stopPropagation(); }); textArea.addMouseDownHandler(DomEvent::stopPropagation); return textArea; } </code><technical_language> @jomarko A couple of question: 1) from the ticket description it seems that somehow both TAB and ESC should be managed (in different way) but I do not see that here: is the ESC managed elsewhere or in different way? 2) is this kind of interaction specific ot ScenarioSImulation? Is it not the same for other grid editor? If the behavior should be the same on different component, then it should be better to create a builder/getter somewhere else (some abstract/parent class) to avoid duplicate this snippet </technical_language>
code&comment2code: <code> public void testHierarchyView() { DockerImagesTab imageTab = openDockerImagesTab(); buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab); if (mockitoIsUsed()) { <START> setupDataForMockito(); <END> } DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab(); List<TreeItem> treeItems = hierarchyTab.getTreeItems(); compareTextInFirstNode(treeItems, "alpine:3.3"); List<TreeItem> treeItems2 = treeItems.get(0).getItems(); compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST); } </code><technical_language> Why is setupDataForMockito() called here when it is designated with the @Before keyword below? I have seen this in a few other tests as well. </technical_language>
code&comment2code: <code> <START> void doBadOffsetInputTest(String name, long offset) { <END> try { new Offset(name, offset); fail("Should have thrown because one of the inputs is invalid"); } catch (IllegalArgumentException e) { } } </code><technical_language> private </technical_language>
code&comment2code: <code> private void enablePhiro() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) { <START> BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true); <END> sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply(); } } </code><technical_language> why is the same code still present in the SettingsActivity? </technical_language>
code&comment2code: <code> private void verifyEditResultCode(EditingResult result) { <START> assertThat(result.getResult(), equalTo(SUCCESS)); <END> } </code><technical_language> Minor: consider replacing equalTo with is from Hamcrest here and below. </technical_language>
code&comment2code: <code> <START> public EnginesPreferencePage() { <END> } </code><technical_language> should call super(); explicitly </technical_language>
code&comment2code: <code> public List<AmbryReplica> getReplicaIds() { <START> return clusterManagerCallback.getReplicaIdsForPartition(this) <END> .stream() .map(r -> (AmbryReplica) r) .collect(Collectors.toList()); } </code><technical_language> Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in ClusterManagerCallback. </technical_language>
code&comment2code: <code> private String blockingSSLConnect(int socketBufSize) throws IOException { String connectionId = selector.connect(new InetSocketAddress("localhost", server.port), socketBufSize, socketBufSize, PortType.SSL); while (!selector.connected().contains(connectionId)) { <START> System.out.println("here"); <END> selector.poll(10000L); } return connectionId; } </code><technical_language> remove? </technical_language>
code&comment2code: <code> <START> public EDDifferentialPrivacy(double epsilon, double delta, <END> DataGeneralizationScheme generalization) { super(delta); this.epsilon = epsilon; this.generalization = generalization; this.beta = calculateBeta(epsilon); this.k = calculateK(getDelta(), epsilon, this.beta); } </code><technical_language> Why does this constructor not simply call the other one? </technical_language>
code&comment2code: <code> private final String getSessionIndex(Assertion subjectAssertion) { List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements(); if(authnStatements != null && authnStatements.size() > 0) { AuthnStatement statement = authnStatements.get(0); <START> return statement.getSessionIndex(); <END> } return null; } </code><technical_language> Can statement be null? </technical_language>
code&comment2code: <code> public void visitNode(Tree tree) { if (!hasSemantic()) { return; } MethodTree method = (MethodTree) tree; <START> if (!INPUT_STREAM_READ.matches(method) || method.block() == null) { <END> return; } method.accept(new ReturnStatementVisitor()); } </code><technical_language> I would switch those two conditions. </technical_language>
code&comment2code: <code> protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_login_view, this); loginButton = Views.findById(this, R.id.sign_in_button); <START> loginButton.setSize(SignInButton.SIZE_WIDE); <END> } </code><technical_language> Can't be set in xml ? </technical_language>
code&comment2code: <code> <START> private int encode(int bucketIndex, int value) <END> { return (bucketIndex << VALUE_BITS) | value; } </code><technical_language> static </technical_language>
code&comment2code: <code> public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) { <START> if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !uberfireDocksInteractionEvent.getTargetDock().getIdentifier().equals(TestToolsPresenter.IDENTIFIER)) { <END> populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier()); } } </code><technical_language> Are you sure that getTargetDock().getIdentifier() is always not null? I suggest to rewrite the condition as !TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier()) </technical_language>
code&comment2code: <code> public String getDocType() { if (Objects.isNull(docType)) { List<SelectItem> allDocTypes = getAllDoctypes(); for (SelectItem item : allDocTypes) { <START> if ("Monograph".equals(item.getValue())) { <END> setDocType((String) item.getValue()); return docType; } } setDocType((String) allDocTypes.get(0).getValue()); } return docType; } </code><technical_language> No, such a feature has not been requested so far. The current state is that each division can be the type of root element. It was discussed that we might later add a possibility that these types can be restricted. In the context, one could also implement the selection of a standard type. </technical_language>
code&comment2code: <code> <START> public boolean shouldUseCommitTemplate() { <END> return Activator.getDefault().getPreferenceStore() .getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE) && getCommitMessage() == null && getCommitTemplate().isPresent(); } </code><technical_language> why is this needed ? </technical_language>
code&comment2code: <code> public void waitUntilAllBlocked() { try { _blockersDoneLatch.await(); } <START> catch (Exception ex) { <END> } } </code><technical_language> missing exception. either log, rethrow runtime or rename exception ignored. Expand Exception </technical_language>
code&comment2code: <code> private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) { if (pathSegments != null) for (PathSegment segement : pathSegments) { MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters(); if (matrixParams != null && !matrixParams.isEmpty()) for (String key : matrixParams.keySet()) { if (key.equals(param)) return true; <START> } <END> } return false; } </code><technical_language> Why not if (matrixParams.containsKey(param) { ... } ? </technical_language>
code&comment2code: <code> public void setAttached(boolean attached) { <START> attached = attached; <END> } </code><technical_language> this is self assignment - please modify to: this.attached = attached </technical_language>
code&comment2code: <code> public void visited(RevObject o) { <START> lowestDepthVisited.put(o, Long.valueOf(walk.getTreeDepth())); <END> } </code><technical_language> Stupid question: why long/Long? walk.getTreeDepth() returns int, so why not use Integer (also in the Map, and intValue() above)? </technical_language>
code&comment2code: <code> private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) { for (Object[] item : list) { <START> item[index] = new Long((long) item[index]); <END> } return list; } </code><technical_language> Is this superfluous casting? </technical_language>
code&comment2code: <code> private void flushAll() throws AuthException { for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { CacheResource cacheResource = new CacheResource(e.getPluginName(), e.getExportName(), e.getProvider()); if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) { continue; } flushCache.get().apply(cacheResource, <START> new FlushCache.Input()); <END> } } </code><technical_language> No new for constant object in loop. Either pass null, or construct the instance outside of the looop. </technical_language>
code&comment2code: <code> <START> public static Map<String, IAnalysisModule> getAnalysisModules() { <END> if (fAnalysisModules.isEmpty()) { TmfAnalysisType analysis = TmfAnalysisType.getInstance(); List<IAnalysisModule> modules = analysis.getAnalysisModules(); for (IAnalysisModule module : modules) { fAnalysisModules.add(module); } } return getExecutableModules(); } </code><technical_language> I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ? </technical_language>
code&comment2code: <code> void validateValueParameter(String name, Object value) { Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith(); <START> if (validators != null && validators.length>0) { <END> for(final Class<? extends IValueValidator> validator: validators) { validateValueParameter(validator, name, value); } } } </code><technical_language> Spaces. </technical_language>
code&comment2code: <code> <START> public <C> Stream<Match> match(Object object, Captures captures, C context) <END> { if (previous.isPresent()) { return previous.get().match(object, captures, context) .flatMap(match -> accept(object, match.captures(), context)); } else { return accept(object, captures, context); } } </code><technical_language> final? </technical_language>
code&comment2code: <code> public ArticlePageObject savePage() { waitForElementInViewPort(editSummary); waitForElementInViewPort(reviewChangesButton); waitForElementVisibleByElement(savePanel); publishButton.click(); <START> PageObjectLogging.log("savePage", "The 2nd Publish Button is clicked", true); <END> return new ArticlePageObject(driver); } </code><technical_language> Global listener catch each click. You don't need to log it. </technical_language>
code&comment2code: <code> public void executeCommand(CommandSender sender, List<String> arguments) { Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers(); Set<String> namedBanned = new HashSet<>(bannedPlayers.size()); for (OfflinePlayer offlinePlayer : bannedPlayers) { namedBanned.add(offlinePlayer.getName()); } <START> purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[0])); <END> } </code><technical_language> Please revert. I know it's an IntelliJ warning but why should we tell Java to create an array generically by reflection when we literally know the size beforehand? </technical_language>
code&comment2code: <code> <START> public static Keyspace getKeyspace() { <END> return keyspace; } </code><technical_language> Why do we need to make this public? It should be package scoped, protected would work as well. All Astyanax classes in com.rackspace.blueflood.io.astyanax.\* should be able to call this method without it being public. </technical_language>
code&comment2code: <code> void setNewElementYPosition(final Element elementReference, final Element newElement) { <START> int referencePosition = getDndListComponent().getPositionY(elementReference); <END> getDndListComponent().setPositionY(newElement, referencePosition); } </code><technical_language> just for consistency, can we use final int? </technical_language>
code&comment2code: <code> public void layoutTopRight(CTabFolder ctf) { Composite trComp = getTRComposite(ctf); if (trComp.getChildren().length > 0) { trComp.setVisible(true); ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP); } else { ctf.setTopRight(null); trComp.setVisible(false); } trComp.pack(); <START> ctf.layout(true, true); <END> } </code><technical_language> I'm not sure if we should fix it in this way. Removing the CTabFolder.layout invocation is a part of the optimization process that is needed to fix the issue exposed by the "JRockit Mission Control " application. It blocks the similar applications to be migrated to the E4 (poor GUI rendering performance) Daniel </technical_language>
code&comment2code: <code> ByteBuf buffer() throws IOException { if (buf == null) { buf = Netty4Utils.toByteBuf(context.get()); context = null; <START> } <END> return buf; } </code><technical_language> Can we assert context == null here? </technical_language>
code&comment2code: <code> public String getName() { String name = super.getName(); <START> if (name == null || name.isEmpty()) { <END> return ""; } else { return name; } } </code><technical_language> Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0> </technical_language>
code&comment2code: <code> private void verifyInvalidValueSize(IndexValue value, String logSegmentName) { try { int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity()); ByteBuffer invalidValue = ByteBuffer.allocate(capacity); invalidValue.put(value.getBytes().array(), 0, capacity); <START> new IndexValue(logSegmentName, invalidValue, version); <END> fail( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue.capacity()); } catch (IllegalArgumentException e) { } } </code><technical_language> minor: put _only_ the statement you expect to fail in try. </technical_language>
code&comment2code: <code> void dispose() { if (semanticResourcesUpdater != null) { semanticResourcesUpdater.dispose(); semanticResourcesUpdater = null; <START> } <END> } </code><technical_language> session could be set to null on dispose(). </technical_language>
code&comment2code: <code> public void deleteByContentType(final ContentTypeIf type) throws DotDataException{ <START> final DotConnect dc = new DotConnect(); <END> dc.setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE); dc.addParam(type.id()); dc.addParam(type.id()); dc.loadResults(); } </code><technical_language> you can do this things in one line such as  new DotConnect().setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE).addParam(type.id()).addParam(type.id()).loadResults(); </technical_language>
code&comment2code: <code> public int getUniqueNotificationId() { if (uniqueNotificationIdCounter == null) { uniqueNotificationIdCounter = new AtomicInteger(0); <START> } <END> return uniqueNotificationIdCounter.incrementAndGet(); } </code><technical_language> Is the if block still needed? </technical_language>
code&comment2code: <code> public void run() { while (!shutdown) { synchronized (this) { try { if (isActive) { processQueuedFlows(activeExecutorRefreshWindowInMilisec, activeExecutorRefreshWindowInFlows); } wait(QUEUE_PROCESSOR_WAIT_IN_MS); } catch (Exception e) { <START> logger.info( <END> "QueueProcessorThread Interrupted. Probably to shut down.", e); } } } } </code><technical_language> How come not logger.error()? </technical_language>
code&comment2code: <code> public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; <START> new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_ENDIAN)); <END> } </code><technical_language> No need to force byte order when wrapping byte[] </technical_language>
code&comment2code: <code> public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(validate.isEmpty(), expectedResult); <END> } </code><technical_language> The expected value should be 1st, it affects error messages by junit </technical_language>
code&comment2code: <code> public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { if (currentFormat != null) calc(); } catch (GeopointException e) { <START> context.showToast(e.getMessage()); <END> spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); } </code><technical_language> No good idea. ;) </technical_language>
code&comment2code: <code> public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return false; <END> } </code><technical_language> why return false? </technical_language>
code&comment2code: <code> public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != null; <END> } </code><technical_language> Comparing with null is not enough. You might replace an existing attachment with a different instance in which case you should return true. In short if the return is different from the input then something changed. </technical_language>
code&comment2code: <code> public String toString() { <START> return Objects.toStringHelper(this).add("liveWorkerNum", mLiveWorkerNum) <END> .add("lostWorkerNum", mLostWorkerNum).add("capacityBytes", mCapacityBytes) .add("usedBytes", mUsedBytes).add("freeBytes", mFreeBytes) .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); } </code><technical_language> ditto: sort by name please </technical_language>
code&comment2code: <code> public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task)); <END> } </code><technical_language> suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); </technical_language>
code&comment2code: <code> private TreeLayer <START> getTreeLayer() <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); } </code><technical_language> The method signature doesn't specify the Exception which could be thrown. </technical_language>
code&comment2code: <code> public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; } </code><technical_language> return directly </technical_language>
code&comment2code: <code> public void differentUrlForPostsAndVideo() { <START> SearchInput searchInput = new SearchInput().searchInputValue(); <END> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "<LINK_1>"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); } </code><technical_language> ![MAJOR](<LINK_2> Remove this unused "searchInput" local variable. [![rule](<LINK_0>](http://sonar-s1/coding_rules#rule_key=squid%3AS1481) </technical_language>
code&comment2code: <code> <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } } </code><technical_language> I would deprecate it and add a new one. </technical_language>
code&comment2code: <code> <START> public static void validateHeaderConfigAction(String action) { <END> if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } } </code><technical_language> This should be package-level protected: suggestion // Visible for testing static void validateHeaderConfigAction(String action) { </technical_language>
code&comment2code: <code> private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length()); <END> } else { return variableMetadata.getName(); } } </code><technical_language> variableMetadata.getName().length() invocation is redundant. </technical_language>
code&comment2code: <code> private Long findFreeId(){ <START> while(personRepository.findOne(lastId) != null){ <END> lastId++; } return lastId; } </code><technical_language> [existsById(long id)](<LINK_0> </technical_language>
code&comment2code: <code> public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { <START> Assume.assumeTrue(mCameraId != null); <END> mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); mUseCase.mDeviceStateCallback.waitForOnClosed(1); } </code><technical_language> Move to setUp(). You can make mCameraId a local variable again. </technical_language>
code&comment2code: <code> public String getDescription() { <START> return getStatuteType().getName().getContent(I18N.getLocale()) <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); } </code><technical_language> Beware that invoking [getContent(I18N.getLocale())](<LINK_0> is different than just invoking [getContent()](<LINK_1> </technical_language>
code&comment2code: <code> <START> public boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; } </code><technical_language> Do this and the other method need to be public? Would protected suffice? </technical_language>
code&comment2code: <code> public String[] getGroupFilters() { <START> String[] result = null; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; } </code><technical_language> Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ? </technical_language>
code&comment2code: <code> <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } } </code><technical_language> some of the protected items here can be package private </technical_language>
code&comment2code: <code> public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> } </code><technical_language> Don't precompute selectedPositions.getPositions. It is unnecessary. And it makes the code harder to follow. </technical_language>
code&comment2code: <code> public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" <END> + study.getStudyInstanceUid() : null; } </code><technical_language> this ternary will not behave as stated in the 1. should annotation </technical_language>
code&comment2code: <code> private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declFromXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declFromXpath = decl; break; } } } } return declFromXpath; } </code><technical_language> ..and change as well the variable name declFromXpath to declCorrXpath also here. </technical_language>
code&comment2code: <code> public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> InvalidParameterSqlException, <END> SQLException { throwIfClosed(); super.setQueryTimeout(seconds); } </code><technical_language> the parent setQueryTimeout will throw a SQLException if the parameter is invalid, so this method now no longer throws an InvalidParameterSqlException </technical_language>
code&comment2code: <code> private List<Disk> manualAggregateSnapshots() { List<Disk> <START> Param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); Param.add(diskWithSnapshots); Param.add(diskWithoutSnapshots); Param.add(ovfImage); Param.add(cinderDisk); return Param; } </code><technical_language> Please use Java conventions - param </technical_language>
code&comment2code: <code> public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; } </code><technical_language> Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true? </technical_language>
code&comment2code: <code> private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> CollectionUtils .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName)); } </code><technical_language> dao will return either an empty list or populated one, but never null. </technical_language>
code&comment2code: <code> <START> private void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } } </code><technical_language> static </technical_language>
code&comment2code: <code> public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + (clientEnabled == null ? "default:" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + (contextName == null ? "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) + "]"; } </code><technical_language> How about the following to simplify the string construction below: java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); </technical_language>
code&comment2code: <code> <START> public void updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); } } </code><technical_language> I would recommend returning a boolean, true for a successful update and false for the "no-op" case </technical_language>
code&comment2code: <code> public void onSaveInstanceState(Bundle outState) { <START> if (backStack != null) { <END> updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); } } </code><technical_language> The rest of this class expects backStack to be nonnull. I recommend we initialize backStack to an empty mutable list and specify @NonNull in the setter. </technical_language>
code&comment2code: <code> public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); } </code><technical_language> Is this necessary? </technical_language>
code&comment2code: <code> <START> private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); if (assosciatedTask == null) { return Collections.emptyList(); } return ImmutableSet.of(assosciatedTask); } </code><technical_language> There can only be one associated task. </technical_language>
code&comment2code: <code> <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); } </code><technical_language> Override </technical_language>
code&comment2code: <code> <START> public static boolean isRoute(URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); } </code><technical_language> public static boolean isRoute(final URL url) </technical_language>
code&comment2code: <code> void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); } </code><technical_language> I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that. </technical_language>
code&comment2code: <code> public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); } </code><technical_language> Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods. </technical_language>
code&comment2code: <code> public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else return name.equals(other.name); <END> } </code><technical_language> please add braces for the else block. </technical_language>
code&comment2code: <code> public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = new ArrayList<>(bufferList); <END> size = computeSize(bufferList); } </code><technical_language> why do you need to wrap it in a new ArrayList? Seems wasteful. </technical_language>
code&comment2code: <code> boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; } </code><technical_language> I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything. If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere). </technical_language>
code&comment2code: <code> public void testStash() { try { git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); git.stashList().call(); git.stashApply().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> } catch (Exception e) { <END> e.printStackTrace(); } } </code><technical_language> Never catch exceptions in test code unless you actually want to do something use. Just declare that this method throws Exception </technical_language>
code&comment2code: <code> public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache"); <END> } } </code><technical_language> Can we include the information from e in this exception message? </technical_language>
code&comment2code: <code> public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { <START> con.rollback(); <END> } } } </code><technical_language> Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback. </technical_language>
code&comment2code: <code> public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); } </code><technical_language> Why do we have equality check here? it should have been done by the equals. </technical_language>
code&comment2code: <code> public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; } </code><technical_language> needed? </technical_language>
code&comment2code: <code> private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> if (++size >= threshold) { <END> resize(keyTable.length << 1); } } </code><technical_language> I think we don't need to check this, as we know that the resize will not result in the threshold being exceeded. </technical_language>
code&comment2code: <code> protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); } </code><technical_language> This isn't canModifyData. I think you've overloaded the variable for too many meanings. What we need is: * canModifyDescription * canModifyMergeType * canModifyAgreements * canModifyAccess The first 3 are true only if projectControl.isOwner() is true. The last one is true if projectControl.isOwnerAnyRef() is true, and is what you want to be using here for addPanel. </technical_language>
code&comment2code: <code> public static EncodeFormat checkedValueOf(String name) { try { <START> return Enum.valueOf(EncodeFormat.class, name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; } </code><technical_language> Why not use EncodeFormat.valueOf </technical_language>
code&comment2code: <code> public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) serializationService.toObject(entry.getKeyData()); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; } </code><technical_language> Minor: there is a shortcut toObject() method for doing the deserialization in this class and in DefaultQueryCache. Maybe that should be used to be consistent at all places. </technical_language>
code&comment2code: <code> public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> } </code><technical_language> also a tiny thing, but sometimes you miss a whitespace after the -> </technical_language>
code&comment2code: <code> protected void configure() { <START> DynamicSet.setOf(binder(), CacheRemovalListener.class); <END> install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); } </code><technical_language> This should be declared in GerritGlobalModule. </technical_language>
code&comment2code: <code> private void createDisabledImage() { <START> if (this.disabledImage != null && !this.disabledImage.isDisposed()) <END> disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); } </code><technical_language> This doesn't seem right: we're building disabledImage from image, so we need to check that image has not been disabled. I think something like the following? if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); } </technical_language>
code&comment2code: <code> public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.data.clear(); <END> mSamplePool.offerLast(sample); } </code><technical_language> Should probably be sample.clear(). </technical_language>
code&comment2code: <code> private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); } </code><technical_language> Looks like this builder just concatenate 3 strings without any loops. I guess, it is unnecessary here. </technical_language>
code&comment2code: <code> <START> public RepositoryObject getParent() { <END> return driver.getParentObject(this); } </code><technical_language> Since a Tombstone is no longer in the hierarchy (result of removing the proxy), this method should probably either return a null or throw an exception </technical_language>
code&comment2code: <code> private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) { <END> branchText.setText(lastBranch); } } </code><technical_language> no braces here, more occurrences in this file </technical_language>
code&comment2code: <code> public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", this.equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); } </code><technical_language> this is not needed? </technical_language>
code&comment2code: <code> private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.error("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } } </code><technical_language> Seems more appropriately logger.warn. </technical_language>
code&comment2code: <code> public Void visitFilter(FilterNode node, Void context) { <START> String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); } </code><technical_language> GraphvizPrinter (and all other plan printer) should not expect an Expression. Rather than having isExpression here, let's fix the tests if they are failing. </technical_language>
code&comment2code: <code> public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> Thread.currentThread().interrupt(); <END> logger.error("Thread interrupted: " + e.getMessage()); } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); } </code><technical_language> Move this line after logging the error, so in any case the error get logged. </technical_language>
code&comment2code: <code> public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".equals(getCodecA()) || "liba52".equals(getCodecA())); <END> } </code><technical_language> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA())); </technical_language>
code&comment2code: <code> ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } } </code><technical_language> redundant </technical_language>
code&comment2code: <code> public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(HTML); <END> } </code><technical_language> TEXT datatype would be more appropriate. </technical_language>
code&comment2code: <code> <START> @Override public Long call() throws IOException{ <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; } </code><technical_language> Space between IOException and { </technical_language>
code&comment2code: <code> public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = new ArrayList<>(asList(collectors)); <END> } </code><technical_language> Does additional list creation (new ArrayList<>()) provide any benefits when compared with the following? java this.collectors = asList(collectors); </technical_language>
code&comment2code: <code> @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(getApplicationContext(), "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } } </code><technical_language> to nitpick: just use this instead of the application. </technical_language>
code&comment2code: <code> private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:" + fg.toString() + "; background-color:" + bg.toString() + ";}"); <END> } </code><technical_language> I must be missing something. Why not simply buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); ? </technical_language>
code&comment2code: <code> <START> public static synchronized VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; } </code><technical_language> what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this </technical_language>
code&comment2code: <code> public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; <START> } <END> return state; } </code><technical_language> You can simplify this by reordering the states. </technical_language>
code&comment2code: <code> private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder() <START> .append(iOSVariant.getVariantID()) <END> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); } </code><technical_language> I know this is not directly part of this PR, but this could be changed to new StringBuilder(iOSVariant.getVariantID()) to avoid one useless append (the StringBuilder() constructor create StringBuilder with capacity 16, that we immediately expand with the next append) </technical_language>
code&comment2code: <code> public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> System.out.println("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } } </code><technical_language> Use logger instead for sysout for logging. </technical_language>
code&comment2code: <code> public void lockEdge() throws Exception { edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true); edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true); edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true); <START> edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false); <END> } </code><technical_language> can we revert back to using LockMode.X instead of LockResource.LockMode.X? </technical_language>
code&comment2code: <code> private String getClientId() { <START> return ( (ClientMessageBusImpl) clientMessageBus ).getClientId(); <END> } </code><technical_language> cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no? </technical_language>
code&comment2code: <code> private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure manamgent network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } } </code><technical_language> Are you sure VdsInstallException is the right exception here? </technical_language>
code&comment2code: <code> <START> public static Response newResetResponse(Header header) { return newRestartResponse(header, newNoServerError()); } <END> </code><technical_language> I think you forgot to change this to - return newResetResponse(header, newNoServerError()); </technical_language>
code&comment2code: <code> <START> private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; } </code><technical_language> Why does this need to be static? </technical_language>
code&comment2code: <code> public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> } </code><technical_language> This should be a constant, not a magic string. </technical_language>
code&comment2code: <code> private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> stack = s.prev; c = s.c; carry = s.carry; <END> continue; } break; } } </code><technical_language> can change the order to save a temp variable s. </technical_language>
code&comment2code: <code> private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert("" + String.valueOf(i)); <END> } return fhs; } </code><technical_language> Could be just ksession.insert(String.valueOf(i)); </technical_language>
code&comment2code: <code> public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> } </code><technical_language> This will create a new instance every time. Cache the instance in a member variable? </technical_language>
code&comment2code: <code> protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); } } } </code><technical_language> if (swingTransferable != null && getScoutObject() != null) {...} </technical_language>
code&comment2code: <code> <START> public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; } </code><technical_language> I don't see this called anywhere in the patch. Is there a reason to make it public? </technical_language>
code&comment2code: <code> public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level.intValue() + 1 ); <END> } MAPPING.get().put( source, target ); } </code><technical_language> not needed unboxing </technical_language>
code&comment2code: <code> <START> public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); } </code><technical_language> Remove throws MiddlewareQueryException </technical_language>
code&comment2code: <code> protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } } </code><technical_language> why did you change this? </technical_language>
code&comment2code: <code> public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_RENDITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Arrays.asList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); } </code><technical_language> Could you use List#of or Collections#singletonList? </technical_language>
code&comment2code: <code> public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); <END> setStrokeStyle(style, stroke); setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; } </code><technical_language> Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly. </technical_language>
code&comment2code: <code> public static void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> } </code><technical_language> All of the methods on this class should be synchronized. Otherwise this change looks good. </technical_language>
code&comment2code: <code> private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); <START> if (getVersionUnsafe() == timestamp) { <END> return; } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } } </code><technical_language> We return even if this is false. Should we do something in the else case? </technical_language>
code&comment2code: <code> public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<K, V>(options); <END> } </code><technical_language> Nit: I think new KafkaProducer<>(options) will work here </technical_language>
code&comment2code: <code> protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; } </code><technical_language> this must be disposed </technical_language>
code&comment2code: <code> public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } else { <END> return isRegistered(product.getProductUniqueIndex()); } } </code><technical_language> else is redundant here. </technical_language>
code&comment2code: <code> public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); <START> originSystemProps.forEach((key, originValue) -> { <END> if (originValue == null) { System.clearProperty(key); } else { System.setProperty(key, originValue); } }); originSystemProps.clear(); } </code><technical_language> You can call the value just value </technical_language>
code&comment2code: <code> private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.STARTED), TimePeriod.getCustom(30)); ModuleLabel moduleLabel = module.getLabel(); ServerState moduleState = moduleLabel.getState(); <START> assertTrue("Module has not been started!", moduleState == ServerState.STARTED); <END> } </code><technical_language> Are these two lines of definitions necessary? Isn't it shorter to just use module.getLabel().getState() in assert? </technical_language>
code&comment2code: <code> SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room); <END> } </code><technical_language> Oh please, no! Don't ship a null object! :cry: </technical_language>
code&comment2code: <code> private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { <END> return true; } return false; } </code><technical_language> I would move this one first. </technical_language>
code&comment2code: <code> static int staticFunc() { InvokeStatic f = new InvokeStatic() { @Override <START> public String func(int n) { <END> unknown(); staticFunc(); return 0; } }; return f.func(); } </code><technical_language> int func(); </technical_language>
code&comment2code: <code> private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; } </code><technical_language> But we are moving to UNJOINED anyway, so it won't affect the result right? </technical_language>
code&comment2code: <code> public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); } </code><technical_language> why you need this here? </technical_language>
code&comment2code: <code> public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); } </code><technical_language> Minor nit, declaring a new Random each time is not really good practice. </technical_language>
code&comment2code: <code> <START> public void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; } </code><technical_language> these 3 methods are public do you really need them? </technical_language>
code&comment2code: <code> public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } } </code><technical_language> Why are we setting it to true during indexing? </technical_language>
code&comment2code: <code> public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); } </code><technical_language> What is the Log.e for? </technical_language>
code&comment2code: <code> public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d("Logging EntityProcessor", "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d("Logging EntityProcessor", "after insert on " + entityAdapter.id()); return result; } </code><technical_language> Move the tag to a constant? </technical_language>
code&comment2code: <code> protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = status.mXAttr; <END> } </code><technical_language> This won't copy the map? </technical_language>
code&comment2code: <code> boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); } </code><technical_language> if repository is null, this will throw an NPE. </technical_language>
code&comment2code: <code> public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> } </code><technical_language> Let's use @CacheEvict(value="userSearchLocales") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway. </technical_language>
code&comment2code: <code> JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> } </code><technical_language> You can revert this change because you don't need it in this specific class. </technical_language>
code&comment2code: <code> public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; } </code><technical_language> will properties provider return the defaultValue in case of no network or value not found ? </technical_language>
code&comment2code: <code> public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI)) { return true; } <START> return false; <END> } </code><technical_language> you can simply return the result of anyMatch without the 'if' and 'return true/false' statements. imo, it would also be nicer to extract the "i -> i.getDiskVmElementForVm(vmBase.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI" part to a separate method "isVirtioScsiDisk" to make it easier to read </technical_language>
code&comment2code: <code> public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.replaceAll("\\s","").toUpperCase(Locale.FRENCH))); <END> } </code><technical_language> Is there a reason for using Locale.FRENCH? Also, why is it needed to remove all spaces? Are you just trying to do a trim(), or are you removing spaces between words? </technical_language>
code&comment2code: <code> private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } } </code><technical_language> close already done in Util.read(..) </technical_language>
code&comment2code: <code> protected void build(UnitVmModel frontend, VM backend) { <START> String name = (String) frontend.getName().getEntity(); <END> VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName(name); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); } </code><technical_language> can be inlined </technical_language>
code&comment2code: <code> public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); <START> allDrugs = conceptService.getAllDrugs(false); <END> assertEquals(resultWhenFalse, allDrugs.size()); } </code><technical_language> @mavrk one test should only be for one method and one combination of parameters. and the goal is that every public method in the service layer is tested. so you should write tests for the methods * getAllDrugs() * getAllDrugs(includeRetired) and for the latter you need one test passing true and one passing false. another case is also what if there are no drugs will it return an empty list? I know this is tedious but thats because when this was written [TDD|<LINK_0>] which would start with tests wasnt used. </technical_language>
code&comment2code: <code> public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> <END> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); return transactionHistory.getData(); } </code><technical_language> those inner classes make reading all of this much worse </technical_language>
code&comment2code: <code> public void addChild(String name, Long id) { <START> if (mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } } </code><technical_language> mChildren could be null </technical_language>
code&comment2code: <code> static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!"); <END> throw new RuntimeException(e); } } } </code><technical_language> nit: This will result in double logging </technical_language>
code&comment2code: <code> void resetLogic() { for (int i = 0; i < fieldSize; i++) <START> for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; <END> playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; autoGameEnabled = false; } </code><technical_language> braces </technical_language>
code&comment2code: <code> protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Arrays.stream(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } } </code><technical_language> Could you replace Arrays#stream by Stream#of for consistency ? </technical_language>
code&comment2code: <code> public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty()); <END> } </code><technical_language> Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size. </technical_language>
code&comment2code: <code> <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; } </code><technical_language> Why this function is public ? It will be used outside of this class ? </technical_language>
code&comment2code: <code> public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> progress.worked(1); <END> } } finally { monitor.done(); } } </code><technical_language> Not needed, delete. </technical_language>
code&comment2code: <code> private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> else return false; <END> } </code><technical_language> we can just use 'return false' instead of 'else return false' </technical_language>
code&comment2code: <code> <START> public void setUp() throws Exception { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END> </code><technical_language> Is the throws Exception needed here? </technical_language>
code&comment2code: <code> public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ <START> System.out.println(certControll); <END> if (certControll != null) { certControll.setAddToKeystore(true); } this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } } </code><technical_language> System.out? Booh! </technical_language>
code&comment2code: <code> public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> initFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> } </code><technical_language> instead of initializing filterSteps in initFilterSteps could you do the following?  filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); </technical_language>
code&comment2code: <code> <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; } </code><technical_language> Isn't this already present elsewhere in biojava? </technical_language>
code&comment2code: <code> public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this.classLoader = Thread.currentThread().getContextClassLoader(); <END> } </code><technical_language> Replace with this(in, null) </technical_language>
code&comment2code: <code> private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state."); <END> } } </code><technical_language> Add the cause to the log. </technical_language>
code&comment2code: <code> protected String getStateParameter(final WebContext context) { <START> final String stateParameter; <END> final String stateData = getState(); if (CommonHelper.isNotBlank(stateData)) { stateParameter = stateData; } else { stateParameter = CommonHelper.randomString(10); } return stateParameter; } </code><technical_language> Why did you remove the stateData? </technical_language>
code&comment2code: <code> public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> } </code><technical_language> This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. -c[space][space]test. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves. </technical_language>
code&comment2code: <code> protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); } </code><technical_language> Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both. </technical_language>
code&comment2code: <code> public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); <START> } <END> return nimbusInfos; } </code><technical_language> Again don't eat the exception throw it, and wrap it if you cannot update the interface. </technical_language>
code&comment2code: <code> <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } } </code><technical_language> deprecate this </technical_language>
code&comment2code: <code> public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); <START> return hash; <END> } </code><technical_language> Why not use org.modeshape.common.util.HashCode.compute(...) instead of this? Or better yet, why not just return name.hashCode()? (When can name be null?) </technical_language>
code&comment2code: <code> public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> callback.onCompletion(null, exception); <END> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); } </code><technical_language> this should be before the callback I think </technical_language>
code&comment2code: <code> <START> private IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); } </code><technical_language> static </technical_language>
code&comment2code: <code> public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> } </code><technical_language> update wouldn't work if the id is always a new id setting a new id is the job of add command </technical_language>
code&comment2code: <code> public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } } </code><technical_language> It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something. </technical_language>
code&comment2code: <code> <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); } </code><technical_language> Done </technical_language>
code&comment2code: <code> public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, SECONDS.toMillis(5)); <END> } </code><technical_language> SECONDS.toMillis(5) -> 5. Timeout parameter of assertTrueEventually(..) is in seconds, not milliseconds. </technical_language>
code&comment2code: <code> public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> boolean result = cohortMembership.equals(cohortMembership); <END> assertTrue(result); } </code><technical_language> I guess we could just assert without the temporary variable. </technical_language>
code&comment2code: <code> <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return new DynamicState(this.state, this.newAssignment, this.container, this.currentAssignment, this.pendingLocalization, this.startTime, pendingDownload, this.profileActions, this.pendingStopProfileActions); } </code><technical_language> nit, could return: withPendingLocalization(this.pendingLocalization, pendingDownload); </technical_language>
code&comment2code: <code> public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> information.isPresent(); <END> } catch (final AccessControlException ex) { return false; } } </code><technical_language> We could also return true here, which seems to be more obvious to me </technical_language>
code&comment2code: <code> public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("<LINK_0>"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("graph.gif", report.getIconFileName()); <END> assertEquals("<LINK_0>", report.getUrlName()); assertEquals(null, report.getTarget()); } </code><technical_language> duplicate assert </technical_language>
code&comment2code: <code> public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(null, event)); <END> } </code><technical_language> The null source looks odd. </technical_language>
code&comment2code: <code> public boolean isList() { <START> if (isProperty) <END> return prop.isList(); else return false; } </code><technical_language> Personally for all these simple things, I would simple it down to a ternary operation for code simplicity. Always keep in mind code size. </technical_language>
code&comment2code: <code> private GlusterGeoRepSession getGeoRepSession() { if (getParameters().getGeoRepSessionId() != null) { return geoRepDao.getById(getParameters().getGeoRepSessionId()); } <START> return null; <END> } </code><technical_language> I don't think we need this check nor this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result </technical_language>
code&comment2code: <code> protected Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); } </code><technical_language> Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point. I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement. </technical_language>
code&comment2code: <code> @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); int stopIndex = stops.next(); while (stopIndex > 0) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex)); stopIndex = stops.next(); } <START> return activeTripPatternsForGivenStops.iterator(); <END> } </code><technical_language> The loop fails if stops contains _the first_ stop (0). The method should be:  Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } return activeTripPatternsForGivenStops.iterator(); </technical_language>
code&comment2code: <code> public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE); <END> this.qualifiers.addAll(qualifiers); } </code><technical_language> This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry) and other places where this constructor is used. </technical_language>
code&comment2code: <code> public void setUp() { <START> jenkins.CLI.get().setEnabled(true); <END> Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); } </code><technical_language> Unnecessary; it is still enabled by default in core, disabled in wizard. </technical_language>
code&comment2code: <code> public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> } </code><technical_language> There is a lack of symmetry here. positionGap should be initialized in both ctors. </technical_language>
code&comment2code: <code> public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null"); <END> } </code><technical_language> ImmutableList.copyOf </technical_language>
code&comment2code: <code> public Double getValue() { try { <START> estimator.accumulate(cx); <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); } </code><technical_language> i'm not sure how getValue() is supposed to be called, but I would make it work correctly even if it is called twice. that is, set cx back to zero after you accumulate. </technical_language>
code&comment2code: <code> private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; } </code><technical_language> Hmm I think we should remove this line. Seems like it's not needed since close(null) will just do nothing. Maybe it's a left-over line from some previous version of the file where the result set got closed properly or something :-) </technical_language>
code&comment2code: <code> public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { if (!event.isPre()) { emitSessionDestroyedEvent((String) event.getKey()); } <START> } <END> </code><technical_language> those if (!event.isPre()) can be avoided by adding @Listener(observation = Observation.POST) at class level </technical_language>
code&comment2code: <code> public void invalidate(@Nullable String path) { if (path == null) { <START> return; <END> } invalidate(Uri.parse(path)); } </code><technical_language> Flip the if and move the invalidate call up inside </technical_language>
code&comment2code: <code> public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null && disconnectableRegisterer == null) { return this.withConnectableCallbacks().withDisconnectableCallbacks(); } else if (connectableRegisterer == null) { return this.withConnectableCallbacks(); } else if (disconnectableRegisterer == null) { return this.withDisconnectableCallbacks(); } <START> return this; <END> } </code><technical_language> could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; } </technical_language>
code&comment2code: <code> public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; <START> } <END> switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; } </code><technical_language> I don't like this code duplication. How about if (name != null) { switch (name) { ... } } Assert.isTrue(false); return null; </technical_language>
code&comment2code: <code> <START> public String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); } </code><technical_language> Does this need to be public? </technical_language>
code&comment2code: <code> private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = new HashSet<>( 0 ); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); } </code><technical_language> Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others. </technical_language>
code&comment2code: <code> public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> } </code><technical_language> I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions. </technical_language>
code&comment2code: <code> <START> @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); } </code><technical_language> If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here. </technical_language>
code&comment2code: <code> protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) <START> .getValue(); <END> } </code><technical_language> hey @manstis , quick looking at this seems that a potential NPE can be produced here? I mean for orElse(null).getValue()? </technical_language>
code&comment2code: <code> public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; } </code><technical_language> TAG </technical_language>
code&comment2code: <code> private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.pageTitle().getDisplayText()) <END> .setImage(card.image()); header(header); } </code><technical_language> Would encapsulating the underlying implementation of BecauseYouReadCard be better or do we need the PageTitle elsewhere? I'm thinking of my recent PageTitle.getText() bug where I meant to call getDisplayText(). At least the bug could only live in one place. If we expose a large object like PageTitle, we have lots of flexibility to do things beyond what a Card is really meant for. There's some notes on some of the tradeoffs here: <LINK_0> </technical_language>
code&comment2code: <code> private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString())); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; } </code><technical_language> DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString() -> String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS) now that it's an int </technical_language>
code&comment2code: <code> private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.error("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } } </code><technical_language> This should be a WARN instead of an ERROR. </technical_language>
code&comment2code: <code> public void testSimpleAnnotation() { assertGeneratedMatches( <START> Lists.newArrayList("import javax.annotation.Nullable;"), <END> Lists.newArrayList("@Nullable"), Lists.newArrayList("@javax.annotation.Nullable")); } </code><technical_language> I'd prefer ImmutableList.of throughout. </technical_language>
code&comment2code: <code> public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "GEOMETRYCOLLECTION (POINT (1 2))"); <END> } </code><technical_language> I'd expect the union of POINT (1, 2) and LINESTRING EMPTY to be POINT (1, 2), but this test asserts the result to be GEOMETRYCOLLECTION (POINT (1 2)). </technical_language>
code&comment2code: <code> <START> public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; } </code><technical_language> protected? </technical_language>
code&comment2code: <code> public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> } </code><technical_language> Seems the output name cache should be reset here, not below. </technical_language>
code&comment2code: <code> public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> set(format, line, hash); <END> } </code><technical_language> I would recommend to use <code>this()</code> in this constructor </technical_language>
code&comment2code: <code> public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; if (nalType == kFuA) { if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; } </code><technical_language> @mdaneshi, do you think it would make sense to have something like this in every static methods that you wrote?  if (buf == null || Math.min(buf.length, len) < off + 1 /* required array length for this method to work correctly */) { return false; }  I know this is not a common practice currently in libjitsi and we sometimes are a little sloppy when we access arrays, but I believe we should change this and write more defensive code whenever possible. </technical_language>
code&comment2code: <code> <START> public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } return new ResponseEntity<>(HttpStatus.OK); } </code><technical_language> @ResponseStatus(HttpStatus.NO_RESPONSE) Then you can change return type to void and remove the return statement </technical_language>
code&comment2code: <code> public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder()))); <END> } </code><technical_language> Use k, like you did in the other files </technical_language>
code&comment2code: <code> public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertFalse(validator.isConditionValid(conditionCol2)); <END> } </code><technical_language> In the context of GUVNOR-2821 I would expect assertTrue here, can you please update the fakeConditionCol52 method to achieve this? Let me know if you don't see my point. </technical_language>
code&comment2code: <code> public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); } </code><technical_language> does this need to be a class member? </technical_language>
code&comment2code: <code> BlobStatus(List<String> replicaList) { if (replicaList != null && replicaList.size() > 0) { unavailable.addAll(replicaList); } <START> } <END> </code><technical_language> minor: the replicaList.size() > 0 check isn't really needed </technical_language>
code&comment2code: <code> <START> protected MemcachedClientCallback createMemcachedClientCallback() { <END> return new MemcachedClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; } </code><technical_language> MemcachedClientCallback should be renamed to StorageClientCallback </technical_language>
code&comment2code: <code> public void clientId() throws IOException { <START> Stripe.clientId = "ca_test"; <END> chargeBody = resource("charge.json"); } </code><technical_language> Your tests don't rely on Stripe.clientId at all, so you should remove this line, rename the method, and get rid of tearDownMockAndClientId() entirely. </technical_language>
code&comment2code: <code> private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'"); <END> } } </code><technical_language> Maybe it would be good to include the causing exception so user knows why it couldn't be created. </technical_language>
code&comment2code: <code> protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules().isEmpty() || pom.getModules() == null) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } } </code><technical_language> You need to swap the order of nullcheck / isEmpty, otherwise it will lead to NPE (if getModules returns null, not sure that's possible) and this validator will fail. </technical_language>
code&comment2code: <code> public boolean isOpen() { <START> return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen(); <END> } </code><technical_language> When is mTransport == null? Isn't it always set to something in open()? Also, why do you need to check mBaseTransport? </technical_language>
code&comment2code: <code> public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); <START> System.clearProperty("org.uberfire.nio.git.ssh.enabled"); <END> System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); } </code><technical_language> why enabled? why restore those? </technical_language>
code&comment2code: <code> protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); } </code><technical_language> I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of: * A permanent group's name can *never* be patched. But, its description can be updated. * Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. So, at a minimum, it seems like we need different errors & checks here. Permanent groups can *never* have name updates, but can have description updates. Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered "permanent". </technical_language>
code&comment2code: <code> protected String computeMetricName(Message<?> message) { <START> String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> return counterName; } </code><technical_language> no need to assign to counterName just to return on next line. However, we probably should add a null check for the evaluationContext. </technical_language>
code&comment2code: <code> public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { <START> return requiredBindings.isEmpty() <END> || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); } </code><technical_language> Could you break this statement into multiple for readability? </technical_language>
code&comment2code: <code> <START> public <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; } </code><technical_language> this method should be changed to private </technical_language>
code&comment2code: <code> private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return config.getQueryCacheConfigs().size() >= 1; <END> } return false; }).count(); } </code><technical_language> Please write it as !config.getQueryCacheConfigs().isEmpty() instead of checking the size. </technical_language>
code&comment2code: <code> public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName = propertyAuditingData.getModifiedFlagName(); if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); } </code><technical_language> probably it is better to change it to  String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); } else { columnName = propertyAuditingData.getModifiedFlagName(); } </technical_language>
code&comment2code: <code> private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && conditionNotSatisfiedError.getCause() == null; } </code><technical_language> Why is this final and condition not? Same issue on line 130. Since final is normally not used for local variables in spock, I'd remove it. </technical_language>
code&comment2code: <code> public final RedirectAction getLogoutRedirectAction(final WebContext context) { <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); } </code><technical_language> These checks are not necessary for logout. </technical_language>
code&comment2code: <code> public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.info("setMainTabSelectedItem"); <END> updateErrataDetailFormPanel(selectedItem); } </code><technical_language> debug/trace/remove? </technical_language>
code&comment2code: <code> public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> } </code><technical_language> If we need to do this, I feel like we can at least do this somewhere else. A binding for something like DiscoveryManagerInitializer with dependencies on these Config classes might work. </technical_language>
code&comment2code: <code> public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context)); <END> } </code><technical_language> Right here (and in the equivalent 3.0 class) is the only place you're using "this" where a field isn't shadowed, is this intentional? </technical_language>
code&comment2code: <code> public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); } </code><technical_language> Drop this empty block. </technical_language>
code&comment2code: <code> private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> final String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; } </code><technical_language> Please, remove final modifiers as they seem to be redundant. </technical_language>
code&comment2code: <code> public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } if (downloader != null) { throw new IllegalArgumentException("Downloader already set."); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END> </code><technical_language> Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your newBuilder() desire. </technical_language>
code&comment2code: <code> protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity != null) { <END> final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } else { return Optional.empty(); } } </code><technical_language> Just a small remark feel free to skip it. It would have a nicer look if you keep if else logic direct like if (activity == null) { return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } </technical_language>
code&comment2code: <code> private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } <START> sortVms(affinityGroup); <END> AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); } </code><technical_language> Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary. </technical_language>
code&comment2code: <code> public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> assertThat(itty.hasNext()).isFalse(); <END> } </code><technical_language> Considering the expected exception for this test, it seems like the assertThat is superfluous, and all we really want is itty.hasNext(); </technical_language>
code&comment2code: <code> public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); } </code><technical_language> Cant the class name be included here so we know where this method is being called from. </technical_language>
code&comment2code: <code> public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); } </code><technical_language> Edge case of duplicate code ;) It could be extracted to a common private method with two params for id and type. Up to you if you want to change it or not ;) </technical_language>
code&comment2code: <code> public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertFalse("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); } </code><technical_language> Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage) Change to assertTrue </technical_language>
code&comment2code: <code> public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) skip; <END> return skip; } } </code><technical_language> shouldn't be the max() between offset and skip to avoid the pos to be previous than offset? </technical_language>
code&comment2code: <code> public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> s.cleanup(); <END> } </code><technical_language> You may want to put this into a try/finally block. </technical_language>
code&comment2code: <code> public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> statuse : <END> statuses) { add(statuse); } } </code><technical_language> rename to s </technical_language>
code&comment2code: <code> protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible(); <END> } </code><technical_language> how about moving logicalNetworkExists() after changesAreClusterCompatible() ? in case changesAreClusterCompatible() returns false, it will save one DB call :) </technical_language>
code&comment2code: <code> protected void reloadCache() { schemaMappingCache.invalidateAll(); Set<String> schemas = getSchemaNames(); for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { getTableNames(schema); } } </code><technical_language> any reason you can't just iterate through the values? schemaTableMapping.values().foreach(v -> v.invalidateAll()); schemaTableMapping.clear(); </technical_language>
code&comment2code: <code> public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals(User.class, configuration.getUser().getClass()); <END> assertEquals("24601", configuration.getUser().getId()); assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); } </code><technical_language> This assertion could be removed as it seems to test the Java type system rather than our code </technical_language>
code&comment2code: <code> private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) { <END> bw.write(str); } } </code><technical_language> No need to call file.toString() -> FileWriter can take File in the constructor as well. </technical_language>
code&comment2code: <code> private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); if (outerLimitObj == null) { return root.rel; } <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); } </code><technical_language> Minor: the two calls could be collapsed, since DimensionHandlerUtils.convertObjectToLong handles nulls just fine. </technical_language>
code&comment2code: <code> <START> public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } } </code><technical_language> nit - ConfigException is unused </technical_language>
code&comment2code: <code> public static URLConnection openURLConnection(URL url) <START> throws IOException, ConnectException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); } </code><technical_language> ConnectException is not actually thrown by anything... it shouldn't be declared in the throws </technical_language>
code&comment2code: <code> public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> for (VdcActionParametersBase param : parameters) { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); } } </code><technical_language> 1. let's replace with params.forEach 2. it makes more sense that this method will reside in HostSetupNetworksParametersBuilder - I don't see how its related to "ReportFailedChildHostOperationsUtil" </technical_language>
code&comment2code: <code> public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> } </code><technical_language> nm. I misread the diff. I thought getDatapointsForRange() only called getNumericMetricDataForRange() </technical_language>
code&comment2code: <code> public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES)); <END> } </code><technical_language> to be null safe on here, I would suggest using stringutils.equalsignorecase or start the expression with the constant </technical_language>
code&comment2code: <code> static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, <END> file.getFileName().toString())))); } </code><technical_language> Looks that works OK, but for me it's hard to read. I would rather see better readable return. </technical_language>
code&comment2code: <code> public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); } </code><technical_language> Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions. </technical_language>
code&comment2code: <code> private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } } </code><technical_language> I smell an incoming NPE here... </technical_language>
code&comment2code: <code> public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } } </code><technical_language> We could just call deleteIfExists(path) since it's same. </technical_language>
code&comment2code: <code> protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport == null) { <END> super.releaseTransport(transport); } } </code><technical_language> This could be even if (dedicatedTransport != transport) </technical_language>
code&comment2code: <code> String prepare(String name, Map<String, Map<String, String>> domain) { StringBuilder builder = new StringBuilder(name); while (domain.containsKey(name)) { <START> builder.append("~"); <END> } domain.put(builder.toString(), new LinkedHashMap<>()); return builder.toString(); } </code><technical_language> You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized. </technical_language>
code&comment2code: <code> public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } } </code><technical_language> is this a RuntimeException? In which case you probably don't want to catch it. </technical_language>
code&comment2code: <code> public void delete(UserEntityFile userEntityFile) { <START> getEntityManager().remove(userEntityFile); <END> } </code><technical_language> Replace method content with... super.delete(userEntityFile); ...as the underlying code will not only delete the entity but also fire an event about it. </technical_language>
code&comment2code: <code> <START> public void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); } </code><technical_language> If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say? </technical_language>
code&comment2code: <code> public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } } </code><technical_language> I find it even easier to read without the (...) </technical_language>
code&comment2code: <code> protected void selectedItemsChanged() { <START> super.onSelectedItemChanged(); <END> updateActionAvailability(); } </code><technical_language> Shouldn't this also be changed to super.selectedItemsChanged()? </technical_language>
code&comment2code: <code> public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; } </code><technical_language> Shouldn't this loop release memory of "discarded" arrays? E.g. intArrays[intArraysTop] = null? </technical_language>
code&comment2code: <code> <START> public Collection<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; } </code><technical_language> I suspect that you want to preserve order here and return a List? </technical_language>
code&comment2code: <code> public String getDeleteDescription() { <START> return getName() + (getAlias() == null ? "" : " (" + getAlias() + ")"); <END> } </code><technical_language> Alias should never be null. </technical_language>
code&comment2code: <code> boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); return true; } </code><technical_language> Is CouchbaseLiteException thrown from anything in this method? Or it should return void but throw CouchbaseLiteException instead? </technical_language>
code&comment2code: <code> <START> public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; } </code><technical_language> protected. It would be bad to allow end-user to mutate on this local property. </technical_language>
code&comment2code: <code> protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); <START> if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) { <END> return encodedFileName; } String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } return trimFilenameIfRequired(fileName); } </code><technical_language> In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think. </technical_language>
code&comment2code: <code> public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); <START> return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); <END> } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } } </code><technical_language> why the extraction to a variable? I would keep it inlined:  return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged(); </technical_language>
code&comment2code: <code> public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; } </code><technical_language> What is this property used for? </technical_language>
code&comment2code: <code> protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { if (!command.readsExistingValues()) { return false; } <START> if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) { <END> return false; } } else { if (!command.alwaysReadsExistingValues()) { return false; } } return true; } </code><technical_language> It seems this could be changed to return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) </technical_language>
code&comment2code: <code> public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) throws IOException { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); } </code><technical_language> ![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from constructor's body. [![rule](<LINK_0>](<LINK_1> </technical_language>
code&comment2code: <code> public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> } </code><technical_language> getEmailAddress can return null. </technical_language>
code&comment2code: <code> public void outjectRequestMap() { for (ValuedParameter vparameter : methodInfo.getValuedParameters()) { <START> result.include(vparameter.getParameter().getName(), vparameter.getValue()); <END> } } </code><technical_language> create a vparameter.getName() that delegates to Parameter </technical_language>
code&comment2code: <code> <START> public AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) { <END> } </code><technical_language> seems like these constructors should set protected properties on the base class. They're called via super below. </technical_language>
code&comment2code: <code> public void onStop() { super.onStop(); mGoogleApiClient.stopAutoManage(getActivity()); <START> if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) { <END> mGoogleApiClient.disconnect(); } } </code><technical_language> Maybe we can move the null check on mGoogleApiClient a level above so to protect also the access to stopAutoManage. wdyt? </technical_language>
code&comment2code: <code> protected Guid getQuotaId() { <START> if (getNewDisk() != null && (isInternalManagedDisk())) { <END> return ((DiskImage) getNewDisk()).getQuotaId(); } return null; } </code><technical_language> please remove redundant brackets (isInter...) </technical_language>
code&comment2code: <code> public JClogin() { <START> logger.trace("JClogin(constructor) called."); <END> logger.trace("JClogin(this={}) called.",this); } </code><technical_language> One of these two trace lines should be removed. </technical_language>
code&comment2code: <code> public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) { this.adaptor = adaptor; this.xenonEngine = xenonEngine; this.adaptorName = adaptor.getName(); this.connectionFactory = connectionFactory; <START> connections = Utils.emptyMap(1); <END> } </code><technical_language> I think using this util obfuscates the code </technical_language>
code&comment2code: <code> public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) { <START> this.prefix = Strings.isNullOrEmpty(prefix) ? "" : prefix + "/"; <END> this.layers = layers; } </code><technical_language> I really dislike how this confuses things. Most of the /s are in the templates, but then this one special slash is being added here. This is a really good opportunity for future mistakes. Maybe this is a case for changing from using String.format() with templates that all do essentially the same thing for varying numbers of parameters to say just using String.join(). </technical_language>
code&comment2code: <code> public void testLeftJoinMissingStats() { PlanNodeStatsEstimate leftStats = planNodeStats( 0, <START> new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), <END> new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); PlanNodeStatsEstimate rightStats = planNodeStats( 0, new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); assertJoinStats(LEFT, leftStats, rightStats, leftStats); } </code><technical_language> nit: I somehow liked the old, more concise UNKNOWN_STATS </technical_language>
code&comment2code: <code> public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException { PrintWriter printWriter = tryCreate(); if (printWriter != null) { mergeTemplate(printWriter); commit(printWriter); registerGinBinding(); } else { getLogger().debug("Jackson Mapper Provider already generated. Returning."); } <START> return Lists.newArrayList(getClassDefinition()); <END> } </code><technical_language> Didn't you remove guava from GWTP? </technical_language>
code&comment2code: <code> @Test public void shouldHandleSchemeInsensitiveCase() { String[] schemes = { "http", "https", "HTTP", "HTTPS", "HTtP", }; for (String scheme : schemes) { final Uri uri = URI_1.buildUpon().scheme(scheme).build(); final Boolean shouldHandle = networkHandler.canHandleRequest( <START> TestUtils.mockRequest(uri) <END> ); assertThat(shouldHandle).isTrue(); } } </code><technical_language> ah. a good reason to make picasso3 the package name, so long as it has common names like Request in the API. </technical_language>
code&comment2code: <code> public void populate(CoreSession session) throws ClientException { UserManager um = Framework.getLocalService(UserManager.class); Framework.doPrivileged(() -> { if (um != null) { createUsersAndGroups(um); } <START> }); <END> } </code><technical_language> if (um != null) { Framework.doPrivileged(() -> createUsersAndGroups(um)); } </technical_language>
code&comment2code: <code> public void stop(BundleContext context) throws Exception { try { Job.getJobManager().join(LUCENE_JOB_FAMILY, null); <START> plugin = null; <END> } finally { super.stop(context); } } </code><technical_language> Might be also in finally? </technical_language>
code&comment2code: <code> public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { ObjectUtil.checkNotNull(unit, "unit"); if (delay < 0) { delay = 0; } validateScheduled0(delay, unit); return schedule(new ScheduledFutureTask<Void>( this, <START> ObjectUtil.checkNotNull(command, "command"), <END> deadlineNanos(unit.toNanos(delay)))); } </code><technical_language> move null check back as first action to not change behaviour. </technical_language>
code&comment2code: <code> public Integer invoke() { Integer result = 0; try (InputStream in = cache.getViaStream(key)) { int read = 0; while ((read = in.read(buffer)) != -1) result = result + read; return value = result; } catch (IOException e) { throw new RuntimeException(e); <START> } catch (NullPointerException e) { <END> return null; } } </code><technical_language> I think that if (in == null) return null is a slightly better way to deal with this... </technical_language>
code&comment2code: <code> public CoreEvent process(CoreEvent event) throws MuleException { try { return processToApply(event, this); } catch (Exception error) { Throwable cause = error.getCause(); <START> if (cause instanceof RetryContextInitializationException && <END> cause.getCause() instanceof ExpressionRuntimeException) { throw ((ExpressionRuntimeException) cause.getCause()); } else { throw error; } } } </code><technical_language> check for cause != null </technical_language>
code&comment2code: <code> private static void addChildren(Map<String, List<PatchLineComment>> parentMap, List<PatchLineComment> children, List<PatchLineComment> outResult) { if (children != null) { for (PatchLineComment c : children) { outResult.add(c); <START> addChildren(parentMap, parentMap.get(c.getKey()), outResult); <END> } } } </code><technical_language> Missing a .get() here after .getKey() as the UUID is the key in the map, not the PatchLineComment.Key object instance. </technical_language>
code&comment2code: <code> public void dispose() { <START> LogManager.logInfo("Disposing", this); <END> fWindow= null; } </code><technical_language> What is this logging buying us ? Do we really need so much of it? </technical_language>
code&comment2code: <code> public boolean equals(byte[] obj, Object otherObj) { if (obj == otherObj) return true; <START> if (obj == null || byte[].class != obj.getClass()) return false; <END> if (otherObj == null || byte[].class != otherObj.getClass()) return false; byte[] byteArray = obj; byte[] otherByteArray = (byte[]) otherObj; return Arrays.equals(byteArray, otherByteArray); } </code><technical_language> the second part of the OR is redundant: byte[].class != obj.getClass() </technical_language>
code&comment2code: <code> <START> public EngineSearcherTotalHitsMatcher(Query query, int totalHits) { <END> this.query = query; this.totalHits = totalHits; } </code><technical_language> can be private </technical_language>
code&comment2code: <code> protected boolean processEntryForContext(final ILogData data) { if (data != null) { try { <START> final Object payload = data.getPayload(runtime); <END> } catch (Throwable e) { log.error("Exception caught at address {}, {}, {}", data.getGlobalAddress(), data.getStreams(), data.getType()); throw e; } } return false; } </code><technical_language> Why don't you push this down to LogData::getPayload ? (since that's when deserialize is actually invoked) </technical_language>
code&comment2code: <code> public boolean isQueryCacheable(Query query) { <START> return !query.isDescending() && !unCacheable.contains(query.getType()); <END> } </code><technical_language> any reason for disabling cache for descending order queries ? </technical_language>
code&comment2code: <code> public static boolean isMoeFile(IResource resource) { if(resource instanceof IFile ) { <START> String fileExtension = resource.getFileExtension(); return fileExtension != null && resource.getFileExtension().equals(MODEL_OBJECT_ELEMENTFILE_EXTENSION); <END> } return false; } </code><technical_language> Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()). </technical_language>
code&comment2code: <code> <START> public Property[] getProperties() { <END> return m_properties.toArray(new Property[m_properties.size()]); } </code><technical_language> could we change to List<Properties> or is this API fixed? </technical_language>
code&comment2code: <code> public void setup() throws NoSuchFieldException, IllegalAccessException { <START> instanceCountField = OpenHelperManager.class.getDeclaredField("instanceCount"); <END> instanceCountField.setAccessible(true); instanceCount = instanceCountField.getInt(null); activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get(); } </code><technical_language> No need for this. The tests must be independent, hence the instance count here should be zero. </technical_language>
code&comment2code: <code> public static Injector getInjector() { if ( injector == null ) { <START> injector = Guice.createInjector( new GuiceModule( emf ) ); <END> } return injector; } </code><technical_language> Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice. </technical_language>
code&comment2code: <code> public void serialize() throws Exception { String xml = serializer.serialize(header); <START> System.out.println(xml); <END> XMLAssert.assertXpathExists("/subscriptionHeader/contentUri", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader/name", xml); } </code><technical_language> We don't like System.out :) </technical_language>
code&comment2code: <code> protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos) <START> { <END> TileEntity tile = world.getTileEntity(pos); return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null; } </code><technical_language> Instanceof nightmare? </technical_language>
code&comment2code: <code> <START> public void setMethod(final ZonemasterRequest.Method method) { <END> this.method = method.getMethod(); this.id = method.getId(); } </code><technical_language> should be a protected method </technical_language>
code&comment2code: <code> <START> public Dimension getFloatingItemOffset() { <END> if (editPart instanceof FloatingLabelEditPart) { return ((FloatingLabelEditPart) editPart).getFloatingItemOffset(); } return new Dimension(); } </code><technical_language> Multi return is forbidden. </technical_language>
code&comment2code: <code> private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException { ITerminalConnector con = cons.get(irc.getAddress()); if(con == null) { con = TerminalConnectorExtension.makeTerminalConnector( "org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector"); cons.put(irc.getAddress(),con); <START> } else if(irc.isOpen()) { <END> return null; } else { irc.open(new NullProgressMonitor()); return null; } return con; } </code><technical_language> irc is not open if con is null initially. The logic here is a bit muddled. </technical_language>
code&comment2code: <code> public long getGlobalClassLoaderId() { <START> return (long) ClassLoaderIdentifier.GLOBAL_ID; <END> } </code><technical_language> Why not declare GLOBAL_ID as a long? </technical_language>
code&comment2code: <code> private int getCmasSeverity() { switch (messageIdentifier) { case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED: <START> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: <END> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE; default: return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN; } } </code><technical_language> Even though these two are "CMAS Severe Alerts", shouldn't getCmasSeverity() still return CMAS_SEVERITY_EXTREME? Spec says "Severity of Extreme, Urgency of Expected..." </technical_language>
code&comment2code: <code> public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException { try { if (keyStore != null) return Collections.list(keyStore.aliases()); } catch (KeyStoreException e) { throw new ScriptSignatureException("Keystore not initialized properly. Try again.", e); } <START> throw new ScriptSignatureException("Keystore not initialized properly. Try again.", null); <END> } </code><technical_language> instead of thowing we could return an empty list </technical_language>
code&comment2code: <code> public List<Expression> getExpressions() { <START> List<Expression> result = new ArrayList<Expression>(groupByAttributes); <END> result.add(expression); return result; } </code><technical_language> Type argument Expression is not need. </technical_language>
code&comment2code: <code> <START> public boolean isIdentityProvider() { <END> try { PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); for (ActivityInfo activityInfo : packageInfo.activities) { if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) { return true; } } } catch (NameNotFoundException e) { SalesforceSDKLogger.e(TAG, "Exception occurred while examining application info", e); } return false; } </code><technical_language> Could we keep this API private? </technical_language>
code&comment2code: <code> <START> public List<BlockedItem> getBlockedItems() { <END> return new ArrayList<BlockedItem>(snapshot.blockedProjects); } </code><technical_language> @olivergondza noted in the commit that this should not be public as it is for testing only </technical_language>
code&comment2code: <code> public IStatus validate(String path) { if (fTrace == null) { <START> return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TraceTypeHelper_ValidateNoTrace); <END> } return fTrace.validate(null, path); } </code><technical_language> I don't think it makes sense for the trace to be null here. We shouldn't have to create a new Message file for this case... </technical_language>
code&comment2code: <code> public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); <START> return isRTPFBPacket(baf) && rc == FMT; <END> } </code><technical_language> just wondering...is it worth putting the rc == FMT check first for a short-circuiting efficiency improvement? </technical_language>
code&comment2code: <code> private Result waitForCompletion() throws InterruptedException, IOException { Result result; <START> while((result = checkForCompletion()) != null) { <END> Thread.sleep(1000); } return result; } </code><technical_language> @bkmeneguello Are you sure that <code>!=</code> is correct? </technical_language>
code&comment2code: <code> public void testUnderlyingReaders() throws IOException, FormatException { FakeReader reader = new FakeReader(); FileStitcher fs = new FileStitcher(reader); assertNotNull(fs.getUnderlyingReaders()); fs.setId("test_z<0-2>.fake"); assertNotNull(fs.getUnderlyingReaders()); <START> } <END> </code><technical_language> Missing fs.close() </technical_language>
code&comment2code: <code> public void shouldGetDiagnosisByUuid() { <START> String uuid = "4e663d66-6b78-11e0-93c3-18a905e044dc"; <END> int diagnosisId = 1; Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid); assertEquals(diagnosisId, (int) diagnosis.getId()); } </code><technical_language> We can get rid of these variables if they are being used in one place. </technical_language>
code&comment2code: <code> public void setUpCallToAction(String callToActionText) { if (callToActionText == null) { callToActionContainer.setVisibility(GONE); } else { callToActionContainer.setVisibility(VISIBLE); <START> callToActionTextView.setText(callToActionText); <END> } } </code><technical_language> I don't think the logic is necessary. We can have the default visibility as GONE. </technical_language>
code&comment2code: <code> <START> public AbstractTableViewer <END> getTableViewer() { return actionContext.getViewer(); } </code><technical_language> Could this be protected as well? </technical_language>
code&comment2code: <code> <START> void start() { <END> if (!started) { log.info("Starting prefetching thread."); executorService.execute(new DefaultGetRecordsCacheDaemon()); } started = true; } </code><technical_language> This probably should be public, and in the interface. </technical_language>
code&comment2code: <code> public SymbolTableBuilder(String fullyQualifiedModuleName) { <START> this.fullyQualifiedModuleName = new ArrayList<>(Arrays.asList(fullyQualifiedModuleName.split("\\."))); <END> } </code><technical_language> Why new ArrayList<>(? </technical_language>
code&comment2code: <code> public long getNextTimestamp() throws TimestampIOException { long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT); <START> long maxTS = _maxReservedTimestamp; <END> if (nextTS > maxTS) { reserveNextBlock(nextTS); } _numTimestampsCreated.incrementAndGet(); return nextTS; } </code><technical_language> Double volatile read is gone. Can get rid of maxTS. </technical_language>
code&comment2code: <code> public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) { <START> this.mTileCanvasViewGroup = new WeakReference<>( viewGroup ); <END> this.mTile = new WeakReference<>( tile ); } </code><technical_language> please remove this. on this line and the next </technical_language>
code&comment2code: <code> public Response viewDataverse(@PathParam("identifier") String idtf) { return allowCors(response(req -> ok( json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))), false, <START> settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false) <END> )))); } </code><technical_language> @matthew-a-dunlap please update the docs on :ExcludeEmailFromExport. Thanks! </technical_language>
code&comment2code: <code> public ResourceNotFoundException(IdString id) { <START> super(id.encoded()); <END> } </code><technical_language> Should this better be: super(id.get()) ? At least in some other places [1] we provide the decoded id to ResourceNotFoundException(String). Shouldn't it be the same in all places, either always the decoded id or always the encoded id? [1] <LINK_0> </technical_language>
code&comment2code: <code> private AppiumDriver getDriverSafe() { WebDriver driver = getDriver(); if (driver instanceof EventFiringWebDriver) { driver = ((EventFiringWebDriver) driver).getWrappedDriver(); <START> if (driver instanceof AppiumDriver) { <END> return (AppiumDriver) driver; } } throw new ClassCastException("Appium Driver can not be casted from the actual driver."); } </code><technical_language> if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver) </technical_language>
code&comment2code: <code> public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException { BufferedImage tempImg = ImageIO.read(actualFile); File tempFile = File.createTempFile("print-test", ".png"); ImageIO.write(tempImg, "png", tempFile); <START> assertSimilarity(ImageIO.read(tempFile), maxDistance); <END> } </code><technical_language> You forgot to revert that </technical_language>
code&comment2code: <code> public URI getLocationHeaderAsURI() { try { return locationHeader != null ? new URI(locationHeader) : null; } catch (URISyntaxException e) { if (LRALogger.logger.isInfoEnabled()) { <START> LRALogger.logger.infof("LRARecord.doEnd missing Location header on ACCEPTED response %s failed: %s", <END> getRequestURI(), e.getMessage()); } return null; } } </code><technical_language> Good catch. I also just spotted that a few other log messages in tryDoEnd are attribued to this. It will be clearer to just remove the LRARecord.doEnd prefix I think. </technical_language>
code&comment2code: <code> public void setup(Method method) throws Exception { logger.info("test name: " + method.getName()); <START> KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME); <END> bundles[0] = Util.readELBundles()[0][0]; bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix()); bundles[0].generateUniqueBundle(); bundles[0].setProcessWorkflow(aggregateWorkflowDir); } </code><technical_language> This seems redundant to me as we are logging in as the current user in the base class. </technical_language>
code&comment2code: <code> public View getOverflowMenuAnchor() { View view = getToolbar().findViewById(R.id.menu_overflow_button); <START> return getToolbar(); <END> } </code><technical_language> Any reason not to check value of the view? </technical_language>
code&comment2code: <code> public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos) throws IOException { if (closed) { throw new IllegalStateException("The NetworkClient is closed."); } List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>(); for (RequestInfo requestInfo : requestInfos) { pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null)); } List<NetworkSend> sends = prepareSends(responseInfoList); selector.poll(POLL_TIMEOUT_MS, sends); handleSelectorEvents(responseInfoList); <START> return responseInfoList; <END> } </code><technical_language> I thought we will catch the exception and call close() here and then rethrow </technical_language>
code&comment2code: <code> public void handleQuotaColumnVisibility() { isQuotaVisible = false; SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem(); if (treeItem != null <START> && SystemTreeItemType.DataCenter.equals(treeItem.getType())) { <END> StoragePool storagePool = (StoragePool) treeItem.getEntity(); if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) { isQuotaVisible = true; } } onDiskViewTypeChanged(); } </code><technical_language> As far as I know, enums can be used with the ==/!= operators. It's a matter of style, but I prefer them (since an instance of an enum is really the same referenced entity as the enum constant). However, you can do whatever you like, either is fine by me. </technical_language>
code&comment2code: <code> public CompletableFuture<StaticResource> getResource(String name) { StaticResource template = templates.get(name); if (template != null) { return CompletableFuture.completedFuture(template); } return delegate .getResource(name) .exceptionally((th) -> { templates.putIfAbsent(name, null); return null; } ) <START> .thenApply( (file) -> { templates.putIfAbsent(name, file); return file; }); <END> } </code><technical_language> shouldn't you force the put? Otherwise, what is returned might be different than what's in the cache, it's also possible that doesn't matter. </technical_language>
code&comment2code: <code> public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable { assumeTrue(OpenSsl.isTlsv13Supported()); <START> assumeTrue(OpenSsl.isBoringSSL()); <END> testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false); } </code><technical_language> OpenSSL also supports it in a similar way on the server-side. See SSL_OP_NO_TICKET on this page: <LINK_0> </technical_language>
code&comment2code: <code> <START> public void setUp() { <END> TmfEventMatching.registerMatchObject(new TcpEventMatching()); TmfEventMatching.registerMatchObject(new TcpLttngEventMatching()); } </code><technical_language> a BeforeClass has to be static (it doesn't tell you until you actually try to run it) I was wondering why this passed Hudson, but then remembered the perf tests don't run, yet... </technical_language>
code&comment2code: <code> protected void updateTitle(String brand) { <START> if (brand != null) { <END> IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager(); setTitle(brandManager.getConnectorLabel(getConnector(), brand)); } } </code><technical_language> Would it make more sense to mark the brand parameter of setBrand as @NonNull instead of checking it here? </technical_language>
code&comment2code: <code> public static int getSegmentForKey(Object key, Cache cache) { KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class); if (keyPartitioner != null) { return keyPartitioner.getSegment(key); } <START> return SegmentSpecificCommand.UNKNOWN_SEGMENT; <END> } </code><technical_language> I'd rather throw an exception </technical_language>
