Is this order guaranteed, ie ls-refs before fetch?
remove
I think a switch statement may be clearer here?
That is also a good candidate for a constant field.
Could you please extract the duplicated logic to a separate method?
how about using try-with-resources so that the connection is closed?
What about the following? Java 8 String threshold = new StringBuilder().append(T.valueOf(maxThreads, tp.length); return new Converter<>(null).build();
What is this supposed to do?
shouldn't we set the error message to the AuthenticationManager?
This should be output.
Can it be package-private?
I wouldn't do this at all, I'm wonder if we should use the old error error code: public static <T> T configureBulkWriteError(BulkWriteError<T> errors, String key,String name, Throwable t) { In the real world, we should see an error that can be ignored by the existing error output.
final?
in what scenario path list will be empty with copy error set to true?
Can l be a lambda here?
Make this a long rather than 0L?
check to make sure notificationUUID is not null
suggestion return validateLocksOnReads();
please remove this. The handler is not used for this. iteration, if it is enabled, there is no way to load the commit (which is currently selected). Or we should check for that.
Seems like there's a spacing issue here, two spaces instead of 4.
Do we need to consider the Messages.getString("DatabaseForm:" +schemaText.getText()); or extract the strings and use a constant from ConfigConstants for consistency with those.
I think I'd call that webLink" or "defaultLink". I am not sure I like the idea of using the same name as the general purpose field.
Use.util instead of Arrays.asList
unnecessary else block
Do we want to send an error handler instead?
this.redisTemplate
Shouldn't we move this inside the while loop?
This seems redundant with the sysout above.
This filter seems to be used very frequently and may be removed. Is it a good idea to cache the graph service, or will it be created once and returned? I mean it could be used to obtain and cache it in on every call to getGraph().
Should we use the super.format() here?
@ivandalbosco Better get pNode for pNode and the patch.parent field should be renamed to pNode to make it clear that pNode is not null
Why do we need this.flowChainManager = direction == null? null : meta.insertNextEvent(this, direction);?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
Better to move this logic to a separate method
Are you sure this is safe? Did you want to wrap the ByteBuffer in an interface?
Why do you need to check the filter here? I thought you should already do it in the constructor and throw an exception so the exception is logged here.
Possible copy/paste bug in the order by clause.
This can throw a NumberFormatException. Is it possible to use a locale? surprised that a format is used in some places.
Hash code
nit: I think these two lines can be asserts the same fact.
can we have a queryCacheable check? I thought the standard has to be set to true should then the queryCacheable check or having it obtained as "Descending".
would be easier to understand if you would add a.orElse(null)
fail
Shouldn't this return a Publisher?
Could you please add a ref link to this? This will involve an internal fix.
Should we throw the IllegalArgumentException instead?
Could you extract this into a method: java static Yaml(String io, String... e) { yamlLoader = new HashMap<String, String>(); for (final YamlSource<String, String> properties : properties) { yamlLoader.load(in); } return properties; }
Just a note: you can make sure that this method throws InterruptedException if the caller passes in the Configuration, then the finally would be good to clean up a bit.
count should be count - 1 in range %s
Could you put this in a try/catch so that the dismissToast() and the others aren't null?
Looks like this lambda is used on a different line as it's own method. Can we extract and reuse?
There is a race condition here. Even if SessionInUse is true, sessions may change and we're going to send again the _exclude_ request from the session, then it should be called right after a call to scheduleKeepAliveHeartbeat, not the same sync as was done above.
This can be switched into a simple if-else statement.
method name doesn't make sense.
@Serranya The same here. See above.
I think this is not necessary as the previous line was executed as the timer is in the constructor.
hmmm, can we use Arrays.toString() here?
this name does not match what it does?
Might be more readable to use: Version0xnVersion6.
You can add the "else if" here to avoid one level of nesting per line.
I may be wrong, but it would be nice to make these methods static.
We should probably return a List here.
Please consider the following flow: 1. User should be able to reuse the'setItems(label)'
this method is sync on L43
why not use return new String[] { 0 }, and use 8 } for the return type, instead of a third argument?
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
I think it's better to use inputWindow.get("sum") to do the trick.
I think you want to make the dlInputs final by using a context file in the exception message, as it may result in a syntax error message being useful for debugging by trying.
Why you use here static?
We should put the map in a lazy block. I think it is a bit confusing to have a record reader that contains a Filter. It can be more specific to what is going on.
Could be package-private.
I would tend to have one method that returns a sequence object, calling it multiple times, once in the queue. This should have been a short circuit here.
index definition has more than 1 element in this method; should it be private?
shouldn't this be realm.sharedRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.contains(BaseRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.getValue());?
final
replace this.
Why it is the same as for container?
You're missing a check for containerName?
Would the new Path, FIles API be easier to use than the old File API?
Optional.ofNullable could be used here instead of Optional.ofNullable
DatabaseName and end of something else?
When isEmpty() is called, the 2nd line above will throw an NPE. You should also check that mServiceConnection is not null before checking mServiceConnection.get().
You can use Objects.hash() which simplifies this.
Do we need to lazily create the spliterator here?
I think it's a good idea to extract this into its own method. i.e..add(fieldLayout)
Looks like there is a race condition here.
This should return an immutable set.
Can you make this file a constant?
Here too, let's use try-with-resources
can we break this up?
Done!
I think a cast would be enough.
I would not use getDescription here, as it is a dependency on external code. I would go with getDescription instead.
Is this an output format?
It should be (Safer to use _cast_ instead of the cast.
missing @since tag
Revert
No need to use ConcurrentMap.
Should be a WARN.
I don't see why you would store strings in the cache, instead of doing the string comparison, you wouldn't do that before, and if so, don't do that, you wouldn't really need the String array. (It doesn't really matter, but I imagine that you would do that, you would have to check if it's empty, and if not, don't do that, you should convert the result to (or use Boolean.parse to get the data out of the cache to be the ones actually used.)
Suggest making this a static method in the class with many test classes (see line 61, 79).
require a password with no spaces?
Change this to String[] 'a', 'e', 'e', 'e', 'e', 'e', 'f', 'e', 'f', 'e'
Why do we do this?
should this return isReady()?
Should be a field on the class itself. Who does this need to be made fully qualified? If the nature of the connector doesn't support this.
this.requirement.edTimeAnalysisRequirement.flatMap(this::requirement).filter(trace -> c.getValue() == null).collect(Collectors.toList());?
I would have expected that the name could be null here.
s/equals/equals/equals to avoid NPEs.
why do you need to set it to empty if there is no url?
You can remove private, and just use TimeUnit.MILLIS_PER_DAY
Can we add a checkSelfScanningEnabled of **TeclaApp.persistence()** here? This seems to be unnecessary.
should we use binaryType.isBinary(binaryType) here?
Where is the name to MutateRowsRequest?
How about adding validation here like this: throw new RuntimeException("The oraclePS from oraclePS {} were created for the given oraclePS schema:" + oraclePS);
Why not put it in an else block and call getVariable() instead of assert?
CompletionException would be better
ensure we can only return true here because it can be much more efficient. The only thing to do here is to add the element to the list when it is empty.
Please convert these two logs into a logger.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
Unnecessary empty line.
maybe this one should be a warn instead of a strong assertion on the message.
Could you move the check for the filename to be sure it is the last character?
What about adding some string (didn't blank)?
What about changing the method name to SBT_FILES_PATH and _FILES_PATH?
Should this be the diamond operator?
This may be better named the variable "award" instead of award. That is not what you really want
At this point where the code is detecting there is a problem, shouldn't it also be reporting specifics about the population that had the issue? IMHO, recording the identifiers of the items with the issue being checked for at the point where the problem happens. It hard to try to find that population or the conditions later on.
nit: this is unnecessary
source.get() will throw new RuntimeException(e); in case one of two parameters is not passed. This can be a normal situation, so maybe it's better to log the exception and handle it in the constructor.
should this be Float.BYTES?
Should use lower case
any clue on how this number was chosen? Is it an absolute or relative value? I think we should preserve the existing behavior by default so perhaps it doesn't matter which config is chosen which makes it harder to stop rebalancing.
Minor: you can remove the redundant null check: if (getActivity()!= null) { permissionListener.requestPermissions(getActivity().getPermissions(this, permissions, newFragment().this); }
This is not enough. We will want a sub-velocity diff after the copy.
According to the code style, you can have a lot of code duplication between this and the new code in this file.
Maybe we can use this to get the item stack and the current one to avoid having to loop through the itemstack?
what happens if there is no state element? It seems that if the a Restored is not necessary, I'm not sure.
The 'if' statement covers this condition on the first line.
I think you should close client after the restart.
Should this be the other way around?
nit: move this line below the try
This can be package private, no?
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
I think it's easier to maintain if the same two lines were in the same method with an else if (remove(...)) { return _addedFiltersNoDuplicates; } else { return _addedFiltersNoDuplicates; }
This pattern looks strange to me. I'm sure it's not really a silent catch (it has to ignore): if the list of item _and_ no more) { and this will definitely add another level of detail on the reader.
To be safe, should check gerritTrigger.isTrigger() first before the trigger.
I think any better to use RandomUtils.nextInt(300, "") instead of 2 here
Is there any way we can move this line into the.transform?
Here try to take advantage of only that handle the schemes. And then you can take advantage of the type check to avoid problems if == is met.
Don't we have to load the property for this class?
log the tenant id and logging it
also check this
Add Assert.notNull(replicateTo, "ReplicateTo must not be null");
we should probably abort the assignment here, no?
<LINK_0>
This is very minor but is it possible to rearrange the code like this? try { layerOnMapGeoJsonLayer viewportLayer = layerOnMapGeoJsonLayer.strokeWidth(airMapGeoJsonLayer.class); } catch (JSONException e) { Log.e(TAG, "Failed to add GeoJsonLayerGeoJsonLayerLayerLayerLayerGeoJsonLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayer
what about catching RuntimeExceptions and rethrow them? It's a bit odd that this method throws Exception, but then other Throwables can easily fix them.
rename to hashCode
Maybe I'm a bit worried about it. It seems like a reasonable change in behaviour that it's incorrect. Although a user may expect the actual implementation of Wilde is more gram. But I think you should bring it out.
Override
This has to be removed.
Redundant newline
Is the first line necessary? I think the second one should be the same.
nit: Instead of splitting this into a method, what do you think about calling it split into a map step? java List<HiveSplit> splits = ImmutableList.builder(); for (HiveSplit entry : partitions) {.. } return splits;
submit?
can we use camel case?
Segments: for (ChannelFuture listener : response).toString()?
please add new HelpTag and HashName (as in StorageListModel)
Can we use the same _else_ clause here? Otherwise, it should be evaluated after after abortProcessInstances(List<Long> processInstanceIds) { processInstanceIds.forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> { You dont need to use.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach
This should check to make sure that notificationUUID is not null before attempting to delete it.
Use Arrays.copyOf() or Arrays.copyOf()
Wouldn't it be better not to have a build for this? It is a side effect for the build to prevent "nulls" from accessing the config.
Maybe use 30 as a default value? This is fine too, but I do see I misunderstood default.
I'd suggest to make this package-private (it can be removed from the class, but the other way around) this will cut down on devices with it, and currently don't change the behaviour of the interface.
Please use Objects.requireNonNull(ignored) to include messages.
don't need this
I have two questions here: 1) the index is the NON-NLS but it will start failing on non-rom that's not what you want to do... If you have a file with a different type, it's not a good idea to have the same line in two lines. But what if you add new lines to the block?
This is fine but it is better to use the original code here
I would return an InvalidArgumentException or IOException
this should be the one below
[line 6] [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/com/m_java/io/airlift/stats/src/main/java/com/wikia/java/io/airlift/data/os/d/App/s/target/editor/SourceProperties.java:[127,28] ERROR: '{' is not preceded with whitespace. (283:75)
Unreachable statement?
Static import
This seems to be returning a long default value for a few minutes?
The message needs to be the full path.
Can we make this into a constant variable? I think it'd be good to have a descriptive name.
can use Collections.emptyMap()
Why did you add 'for'?
Should we wrap this method with an IDisposeEvent()?
suggestion if (this.fuseDuration()!= null) {
Could you please use TIME_FORMAT instead of "HH:mm:ss"
Curious why we need to set the match algorithm here?
Minor - unnecessary added synchronized
suggest this.public SketchMergeAggregatorFactory(name, SketchMergeAggregatorFactory.class, shouldFinalize, false)
return INSTANCE_SIE
No need to use UriBuilder
You can use remove() as well.
Do we need to handle the exception here?
The exception doesn't seem to be the expected value. Why not use something like this?
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
Are you sure this is always called when the job is never cancelled?
Ternary
1. Refactor 'toIkeState' to use a StateManager to get this 2. For instance, we can use a ConnectivityManager cm = ConnectivityManager.from( ConnectivityManager.from(this)); 2. Remove the redundant 'ConnectivityManager cm = cm.unregisterNetworkCallback()' here.
This is why I don't put it before the base class implementation.
Style-nit: No reason to add final.
This is not the job of this test. This is useful to have protected and Non statements introduced by @BeforeClass.
dismissNotification(notificationInformation) is called twice
This check is not needed, as in the case of nested typeMirror /foo are the same
suggestion ModelBridgeInternal.setPartitionKey(options, partitionKey, CosmosItemRequestOptions options);
- [ ] We should probably refactor so that "checkstyle3.xml" is not available
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
Because there is only one argument, we can pass workerMetrics instead of an object array.
Should be Fedricated!
Please put "251" into constants
Codacy complains here: <LINK_0> Can you use a constant?
Can you use 0.0 and 1.0 instead of 0.0?
You can return an empty string instead of null.
From my point of view, wouldn't a pattern end be tripPattern always first and then the tripPattern to add to the tripPattern if possible? It could be also good to make patternsForStop.
Since we only need the setType here, this should be replaced with: java SharedMetricRegistryDTO registry = RegistryDTO.getType().toString();
please make sure you set the data in the constructor for the load-user.
@reviation more obvious, inline the attribute
I think you have changed the order here, right?
This needs to be protected.
if we are in the selected columns, we should be able to replace the text with "decisionTableHasEditableColumns".
you meant to use equals here, when comparing enums, it's a good practice to use the Objects.equals()
EmptyActionInput()?
Why is this needed?
A check on encounter is optional
I don't think we should return null here. It seems like you're getting the entry from the cache.
Is it worth logging if we are returning a value that uses the same nanos?
Duplicate in both createSubject and createSubject methods. Consider to refactoring into helper method.
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
Can't we use stream and collect to a List with values from both.stream() and.map(AmqpIOException::getCause)?
Is this necessary?
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
can you split out the deployComponent and get the values for the STREAM_INDEX_PROPERTY and STREAM_WORK_MANAGER_STORESTATE_WORK_NAME and STREAM_WORK_PROVIDER_WORK_MODE_ENABLED_DEFAULT_WORK_MANAGER_ID to a constant
Did you intend to leave this log call as info?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
getUsage(...) expects a localization key.
please remove
Could we have a static variable all the time?
could you change the order of separators?
> backups should be created with the **Collections.singletonList** - if you have to do this, you can also do something like this: return Collections.singletonList(backups.get(0));
Should be final
Same here, this is obsolete
Typo?
FIXME: This crashes.
@jagill Is this the intention? What if the old lz4Decompressor requires the last node to be the same as the fallback?
Math.out
Please use StringBuilder instead of substring.
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
rename to PercentageBasedSamplers
Needs to be in finally
I think the logic for checking file is wrong here, because CMProbeStat.fromType(path) will not throw an exception is a SCMProbeStat and not a SCMProbeStat.fromType(path). Should we pass.warning("Unable to check file {}", path, e.getMessage()); to the next line, with the other overload of this method that takes a path and the IOException is not thrown we want to catch it and then log it.
I would throw NoSuchElementException instead of returning null.
WikipediaApp.getInstance() unnecessary?
@garyrussell maybe we can make these strings a constant?
I think it's better to use the ModelUtil.getInstance() API, which will also allow the UI to get a client error.
Maybe Builders.Builder could be statically imported?
Still misunderstanding the order of properties in this test. The first three tests are always going to fail with an empty map. If this assertion fails, it will just pass a number of properties and the test will fail. The same for all tests.
I suggest to only include this in the SQL. The messages are in the logs that something went wrong (this is logging just the message) and the message.
Better to do this method here too.
Should we provide a max value for this?
Safer to keep consistent
make it final?
rename to launchManager
Code style: There is no need to use a logger.error() and instead use e.printStackTrace()
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
This should be switched back to: java log.info("Refreshing access control: {}, config);
I see that this method is also used in other files, so changing the visibility of the method should be changed to protected.
Change the return value to an IConfiguration like the other enums.
keep the static code style
The OutputStream output = new OutputStream(output.read(buffer));... And then finally throw an exception....
Should use SMarketView.DEFAULT_OrderBook instead of String
IDE says: Please use Collections.emptyList()
What you're trying to achieve here?
System.out.println should be removed.
Let's not use PojoStackTraceWriter to make it more readable.
static
Return.block() here. However, I don't see any reason for the API call here. You can either use the enum or better yet the Void class to get the state.
This is problematic, the test is to wait for an example of time left for an expired time in the future.
You can use Objects.hashCode(this.logEntry) here.
hmmm, let's keep the code duplication as it was.
please have the throws
Should we check if this.metricsModes.isEmpty()?
Could be replaced with: java throw new UnsupportedOperationException(" portlets > portlets;");
couldn't you do this with the command protected method instead of duplicating the code?
Likewise.
Looks like this method should be if (task == null)
Could you please describe what has changed since the duplicate line looks a bit long?
I don't understand why not use modifiers.findFirstToken(TokenTypes.FINAL) here. This method can be simplified, as well, as in anyMatch.
This change is not necessary.
This is a read-only operation but there's no reason to choose/read the metadata state again if you call sync.
This method should be static
"-%d" is a bit confusing. Where is the number of times handled?
empty point in time?
return attachable == null? null : attachable;
why not use the field directly?
I don't think this is needed.
nodeID could be null
I'd rather go with public DialectNamingNamingNamingNamingNamingNamings we use the constructors above.
stop() is better, as you did with the name of the node.
Please add this to the handlerClass.
Use StandardCharsets.UTF_8 instead of a string literal
[minor] Any reason we use the Mockito.mock method?
I think this should be TRACK_CLOSE_PROVIDER_CLOSE or something like that.
would be nice if this :) I mean that the handler is only implemented once.
Please make a copy of the header in the map, just use the one in the map.
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. If you want to verify that we can throw a exception here, then the test should have its checked again after the first one.
> Use correct isReady()
How about setupTestUsers?
Need to make sure this is what we want.
I think you need a change, not just needed for the test, assert is enough
The pattern for this method seems to be used only inside the buildAndTranslate(..) method.
same question as before
Consider writing java getView().setName(name);
If the categoryIdentifier is already defined, then do you need to check again?
Maybe we could move this to a Utils method?
Can this be simplified into a call to ByteBuffer byteBuffer?
I don't understand this. Why was this changed to protected?
Instead of a null check, maybe we should have it out of the null check - otherwise we might be able to look into.
Should this throw an exception? It seems like this method always returning a new one.
Can this be moved to a private method?
Missing the part of shuffling...
Please use getAbsolutePath() instead.
This is a code smell here, we should have two less code here, one of the widgets, one of the other isn't doing anything. If that's the case here, we're trying to show that.
Maybe do the future be worth making a getFormatId method that does the same thing (you might get too far away from the raw id), and then call abort here.
given/ execute/ assert
You can add an ExecutorService as well.
Can you make this an array or split out of bounds?
nit: can you add a config flag in the constructor for this? This config is a bit odd since it's in the first constructor.
can you add a check for if (!fetcher.isEmpty())?
Add this back to the spark size?
Why have you removed this?
Why do we need to use ref here?
yeah, we can drop this static in that case, just use the instance methods directly.
Should only be checking if the format is null.
This should probably be fileId, and not name.
Can this be package-private?
I believe the null check is not necessary here, the filtered value is an empty list.
Unsure if this method is called on every single mutedTopics.
Can be replaced by: return!knownConstants.contains(argument.getColumn()).contains(argument.getColumn());
instanceof Dataset is redundant
needs a check for the getName()!= a not-null or call toString on its "else"
Great! I think this is wrong. If we want to support a blacklist, this should probably be an URL or an blacklist and not a URL. IIRC you should check the presence of an blacklist and only replace the range if there are no keys.
A stream is available only to use here. Maybe we should use stream and collect to report only once.
Should be done as a HashSet
We should probably also add this as a lock, such as the one used in async client to create the metrics collection.
minor nit: this could be initialized to null.
Can be: if (oldRevision == null)
Should we use org.apache.kafka.common.utils.Utils.closeQuietly?
Use the builder instead of creating a new File object.
RTPConnectorInputStream is not thread-safe
rename to sash
Is there a reason to keep this more of a entirt-engine? I don't find the class name when they are used in a sample app
nit: it's quite strange to have the try block inside a while
This is a bug. You should check that the storage service is not null.
The Exception is never thrown.
I would say to have them sync set the contentResolver and keep the field as final.
UnsupportedOperationException seems like a better fit to me.
Shouldn't this be an Assert.assertFalse?
You may also want a test case for a search value that is non-blank but invalid.
You can use this method.
is this needed?
These should all be PopulateDB.
log an error?
is the default value specified?
I think we should remove the following events: * It doesn't have any effect on the button, because it's not updated in the SWT.MouseUp. Do you? * It's very close to the original state of the dialog, which is then taken by another user? Or just?
The MathUtils will handle this row red
I would wrap in a Function<IT>.
Actually, I'm not sure how this test will work. Do we need to log this? (candybeanConfig => projectdybeanConfig)
super.cleanup() should be in the same line of code.
can be inlined in class
ditto, remove this
Class name should start with a capital letter
Can we rename the variable name of the test to carbonTransport or call this method on the class?
Why not do the close() here to ensure the stream is closed?
The implementation of tailSupplier is a bit confusing. This class is a subclass of Stream and can be considered a bit more dangerous.
I think we should keep the message in the collector as a field.
rename to elementLeftApplicationRect(), and rename it to fluidicCompressor
I think we could avoid an empty copy and put the List#init method in AbstractDataIterator.
Shall we update getManifestConfig to the Config class and have a Config class instead of mixing them?
please check if random value is not defined
This needs an @Override annotation.
@Override?
_this." is not necessary. This code can be improved as it is tested in the nit _if_ condition.
Please don't use curly braces around single line blocks
EpdqParameterBuilder.extract(templateData)
Why result is NULL?
This is a build() call, so this can be removed.
should we also use assertEmpty for these?
can we use super(name, super(name, super(name)); so we don't have to do this each time a network call is called.
I guess we normally try to avoid exposing type here. For now, I would prefer to keep it for consistency.
Use _sabbatical_link_yaml
...
nitpick; could we just do: if (getSelectedSite()!= null && site.getMySite()!= null) { return; } if (site!= null) { return site; } return null;
why this cast?
Is this the right name for the connector? It seems like it should be the only class name.
UserAccount should we call advance() instead of here?
Same here. Can you include a check for container idMapping, or something along those lines?
Should we use the iterator [Iterator](<LINK_0> here?
@keyStorePassword should be used here.
run() does not do anything.
What is the use of this method? This test seems to test filtering. You should just verify that we pass in a patient that is returned by this method.
can we move this to the method?
Boolean.valueOf() returns a primitive boolean, which will throw an exception. Is this intended?
Check the env variable before returning true.
I think we should set it to the user as JSON instead of the default interpreter value. Otherwise, this will trigger a write error for every new PrintStream(out, setOut);
make sure that we don't need to make new String classification as well.
consider overloading's method with a bitCosmetic issue' to have _package_ methods public or _private_ modifier, that way clients don't need to use it as they are.
Preconditions is not dependent on String.isNaN, it should be fixed.
I'm not sure this is correct.
why this change?
This should have tested the property name as well.
why not use!ifPresent?
Instead of setting this flag and just after line pageIndex, just spell it: boolean useRevocableMemoryContext
Since we are doing null check, is it necessary to keep the if condition?
Nit: I would prefer creating the constants with these args.
Formatting: s/space.
This causes the ReplicationlabelBuilder to create one DataTables. Revert this?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
should it be the other way around? getLog(type, type)
remove public
There is some wrong reason for the featurecrolledComposite.setRender("No exception thrown")?
The same here.
Since the super() is implied, the method can be omitted.
Style-nit: Unnecessary blank line.
These two lines are unnecessary, its a bit confusing to read.
A little bit weird to have a query 3 and the _only_ set is the value that we need to convert to a query with a name that is the same as the separator. suggestion if( orderByClause orderByClause.isEmpty()) {
Using null as an argument is less readable, but it's more readable. There are also no (alescing) usages.
Please make sure that this method is not deprecated. The point is that the method was set in the future, but it was unconsumed.
Remove this log. s/Error loading/whatever/
The usual pattern for a constructor is to have the four fields: private static final S3A_B_ACTION_TYPE_S = new ResourceImpl(final ITree.class, final Class<Resource>, ITree>) {
Why make this non-static? The usage is fine as it's only used by tests.
Cute, not CFUC. This Exception can ever be caught by any of the processing infrastructure.
Wrong line.
Same as above, I should throw an exception if!null.
you could change this to: java004 = Year.parse(file);
Should we add a comma here?
need to set this to true instead
Vague variable name s
An exception will be printed to the console but the text is null, so we don't want to go through the array.
This check is not needed.
Can't we have: this.payload = checkNotNull(payload, "payload"); to be consistent with the others?
I would suggest to use static imports for non-public static methods.
This part of the code should be replaced with equals...
What does the constant mean?
I would suggest using the built-in codecs. This is exactly the same as the mapper mapper, so we should probably address that instead.
Added because?
The error handling should be caught entirely. Like: java throw new IllegalArgumentException("Could not find a device due to a bug", e);
Won't this make more sense to handle InterruptedException?
Please add a constructor with parameter StringSchema that accepts ObjectSchema and List<SchemaIncompatibility> as getter and use it here. This method can be used for large strings, as it will be a little tricky for admin (see #52052). I'm thinking about this too much
replace with the following code: HexUtils.decode(s.getBytes()) + "=" + hexStringToByteArray(type));
You may use [this](<LINK_0> method here
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(SwitchStatementTree ) return defaultIsLastCase(switchStatementTree).anyMatch(defaultLabel::isLastCase);
Same why not else if?
What about the 1000 here?
I'd suggest we also log/throw an IllegalStateException here if permanent is not RuntimeException.
Not a big deal, but a method that returns Optional instead of throwing an exception would be better.
Couldn't we just ignore the e.getMessage() here?
It's good to have this as a single static method.
"SELECT * FROM quality_gates WHERE name =>"
"TtyDev" is a typo.
Since you are no longer updating the LimitedEntryActionRetractFactCol52 and LimitedEntryActionRetractFactCol52, the code should be the same here.
It might be worth keeping the Index TableViewer.setInput() here. This change could result in NPE, as the index is not cached, current time it's called. Also, the index is not exposed when re-returned listeners (as the handler is already stopped). This could be a different behavior (as the handler is selected) from different threads.
Missing a failure message.
@vilchik-elena Why this switch case?
I know this is just a weak snippet of code, but I think we should split it up to the URL.
nit: make try-with-resources.
code style: throw new Exception("500: General Exceptions(Exception e);
Remove this
This needs to use Assertions.assertDoesNotThrow(S3B3CtedStreamRecord.class)
Do you think that the array access itself will perform this check for you and throw an identical exception...so I'm not sure of the purpose of performing this test here. unless, that is you will show more information in your exception method. (I'm happy either way)
In the general case: physicalSlotRequestId > 0 means the physical slot requestId [] doesn't exist anymore. But will the slotRequestId is not used anymore?
Unnecessary?
To avoid duplicating the pattern, I'd like to have a findDBMethodForIncomingInstance method or something that calls AccessibilityBytes to a input position? :stuck_out_tongue_win
would it be good to have a test that verifies that range is within the range and we're getting the timestamp correctly?
Same as above, I don't think this is needed and if it is done in other clients, it would still be enough to check the db.
What's the purpose of this change?
SortedDescriptorsForGlobalConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNo
This is fine, but I'm not sure where we can avoid this conversion. Why not just use the nio file on theFiles?
Did you intentionally ignore the patientProgram parameter?
You don't need this check, you can just do sdf.setTimeone(Timeone.getTimeone("UTC"));
txn can be null
Why do you use this? Shouldn't it be done in the finally block in init()?
Can this be changed to false?
Did you mean code that?
Can we wrap this constructor body; use this(factory, gauge) instead.
I think this should be a Glowing
Can we use a more expressive variable here? (I could also argue that getting the int value could be the same, but I sense that in the future it would be the _else_ part of the expression.)
can't we check for null here?
there are several problems with this approach: java return queries.stream().map(TestContext::getId).map(TestContext::getId).collect(Collectors.toList());
Why not implement the return type of the function?
This might be null if already permissions are provided. The SnapshotFormatValidator#DESCRIPTOR_VERSION already returns false.
Why are you creating a font if the other fontData is already set?
Why the logic being done in the API?
Why this?
You can remove the extra layer of the loops and just return views directly: List<View> views = view.getAllViews().stream().map(View::getView).collect(Collectors.toList());
This isn't really a "remote hung up unexpectedly"
This method should be private.
Same as above, pass in the result.
Wondering why you need a transactional method that takes a lock (like transaction is)
Can we use the exact configuration here, instead of the ignore 'configuration'?
If we do this in one place, return it? Since we know what the outcome is as is.
Consider using TimeUnit.MILLISECONDS.toSeconds(expiresAtMs - creationTimeMs) instead of creating an object?
nit: unnecessary else
I think we can define this as final and only replace the first if the stream is null.
Please put back the parentheses around (Unsupported URL : index) + ((key) == DataSnapshot)
fileName.getImageSelectorIndex() is the same as previously.
same again: do not create a new empty exception but reuse the old one.
I think this should be: super.add(entity.getAddAllowed(entity));
Just a small nitpick: you could simplify this by returning the result of the method, and then returning true, instead of false, and return true, meaning that it will always return false.
Could you flip the order of the columns and expected columns with the name?
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
you could eliminate this line by calling firstBlock.getGeometryType() and then use it to compare units of this method.
Why is this needed?
This if-else is redundant here as you're calling it directly on the other side of the method.
I'd love to have assertions here, as they were used in multiple places.
Can we take the default case to the user as a static variable, and use it here?
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
The property is not set in the codacy environment.
Are you sure that the fluid is a fluid? I think it should be a simple name, as it is two pages, and it will just be easier to get rid of the new FluidStack.
This line can be removed.
We tend to prefer if no access modifier was introduced in java 1.8.sql.Statement implementations are purely for the old style. There are a bunch of existing PRs in this class which has a lot of overhead than expected. The alternative is to provide a dummy access rule in the future and only keep it when they are declared (which would be unlikely to happen in this case).
Exception should be logged
is this a duplicate of the ViewUtils.sign_in to do this?
This can be the User getAccountUsers() call instead of the re-accountService.getAccountUsers().
This should clear the access modifier.
Could you name this inputElement?
Why not.filter(exam -> exam.getRoom().getPenalty()!= 0)?
return a new IRSAKey;?
Why use a junit @Rule for the test case?
no need to declare this, it would be the default
s/indexForNull/indexForNull/
Might want to check if the tag was removed.
I missed this one before, but there is a lot of issues in the code that we could change to not rely on userHandleResolver as well.
Rename to escaped?
Can be simplified to java return Try.of(partialFunction)::apply);
I missed this before, we should probably store the DialogFragment as a field so that it is safe to keep on fresh call.
Make this synchronized
Just a small thing, but since it's not possible to check that we do not try to create a _single_ request you could return an Optional<ImageParams> instead of _computeImageParams after the assignment.
Why put the brightness in a set?
Why not: java return StreamSupport.stream(desc -> desc.hashCode().spliterator(), false).map(desc -> desc.hashCode()).distinct().count();
I can imagine that count <= timeout is the max connection limit, but -1 is not really important. It may be better to define a at least config property instead of using magic numbers.
The context is not used. If you want to use ds.isIncludeAddress() it's better to use ds.isReuseAddress()
Is it possible to use [##](<LINK_0> instead of casting null?
Add a message for the Throwable
rename
same here, can be done with linkedAddresses == null.
This is an overloaded method, why change the class?
Can we use a specific ConfigJavaUtils. ConfigUtils. siteoStreamPartitionGrouper(config)?
Why not just 'this'?
Can you write this as private static final String TEST_POS_OnClickListener implementation and use a static factory method to encapsulate the type of objectMapper in a static field?
Maybe using OutcomeSettings.setOutcomeSettings(settings, ApplicationPropertySettings.DEFAULT_OutcomeSettings); here?
I like 2. Let's do that. It's a good idea to keep a reference to the underlying cause.
Static string constants
RuleImpl '" +'has been removed from the string
Should have a space after add
context.release() is possible to use a method in the parent class on line 45,.
If you want to return a RawText object here, you could just do: return RawText.zeroId(repo) here.
We can use the return statement in declaration of this method here
Needs a try/catch for all exceptions.
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
Is this correct? Why don't you use a stream?
I think we should drop the m as it is not a member anymore, same applies to cancel
Make it public
I think we can simplify this by replacing the following 2 lines with:.. } catch (Throwable ex) { throw new MessagingException(CoreException.class, cause); }
this should be in a try/finally.
Store this value in the else if to avoid the else block
Why is this needed?
Should be Exception
I think it should be in a different PR and not here as you are using it in more places. Can you call it with the configRepository instead?
you don't need the "else" here.
What if it's not _empty_? Is it possible to just return null?
static import
[c] Should we use the wildfly.xml for this test?
Recommend using a LinkedHashSet here, it looks better.
= new Date('a', 'a') => shorter and more readable.
This should probably be trialUntil
Does it really need to be public?
Change this to unmodifiableSet.
If you want to use assertTrue(NONYENT_CLIENT_PATH) here, then you can have a more informative message in case this assertion fails.
I honestly didn't remove all the logger messages but that's a lot of them. It is a lot of duplication and the logging framework would presumably fix.
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
This is a bug in PR, but I think you want to handle this (in case of a bug) in either case, there's a :class should be the case for getFormattedBoundaryValues(null, Str.class) that's done. In that case, you can re-use the parseDouble constructor of the string.
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
Why not use the Bindings.valueFor(true)? I don't see the need to change if we first get to the database field.
Instead of this try/catch, you can create a variable with the same value as your setter, param. You can set it in onViewCreated().
Is this code line a duplicate?
This is probably unnecessary as the RulesDao class is immutable.
Is there a reason to use an forEach here?
how about max < min and max >= min?
Why not make this a DateTime? Then you can reuse the DateTime object directly, right?
I think this part should be placed in the generalisation class TraceResponseOutInterceptor
if the user has an error, it'd be better to throw an exception.
We don't need to expose this. This will modify the existing code in this class, which is preferred for better performance. Also, use ImmutableList.copyOf instead of a new ArrayList.
Let's put ColumnTypingStrategy#STRING and constant.
Can you extract this list into a private method that returns collection<String> scopes = Arrays.asList(Collection<String> scopes).
Move the equals to the previous line so that the put returns the value?
nit: can we also use assertj for the rest of the code?
This doesn't really need a throws declaration.
Can we please remove these deprecations?
this is a good idea, but you can use the scheme from Files to get the content, so that the next line is there: if (a!= null) { Files.write(path).write(path); }
java rawCookies.split("=", ", rawCookies);
It might be good to add more info to this _ServerStates_. This way, clients can override the same thread-safe queue-up tasks than the new one.
this should always be true here, and not false
It looks like this will return  floor(floor) for you. [1] It would be better to use.floor() and return type each time since its less readable in the end of the box of the expression.
Why not, instanceof TypeTree?
nit: drop the final
...and use CollectionUtils.isNotEmpty()
should check if endpointUtil is not null in here.
this.
This is a lot of code duplication. Could you just use app.getClass().getCanonicalName()?
Replace these lines with: writeVarInt32(in, endA, endB, beginA) { endA(in, endA, endB, beginB); }
We can use directly context.split(mConfig) here instead of calling trim().
in all these classes, the "filter" parameter (or "this"...
Why are you looping here? Can you give a use-case?
remove the unnecessary semi-colon.
Should be synchronized or else this.next isn't needed :wink:
If theories is empty this method still passes one step it could be worth it as well
Please don't use the getSelectionSelection
This should probably be a static constant because it is used in multiple places.
Should we be closing the stream in a finally block?
Formatting?
i see that nicsForUpdateInterfaces is not used in this method, you can assign it to the DAO instead of updating it again.
I don't know if this can be reached, but does this really needed?
Can you have one method to show that it will be called for patientDeadPageController and this test is failing?
shouldn't we just add 'null' here?
I think that in this case it's best to use a constant here.
Single or double pipe?
mapper.getAsyncTaskExecutor() is a bit confusing. It looks like the other constructor should be private and it seems to be used by both constructors.
Is this null here?
why this change?
Please wrap it before "if" line, since it is "return true" there.
The field names (public, final ThrowablePackTraverser, QueryResult). We should be consistent.
I believe it should be a debug level here?
Do we really need this?
mShareIntent should be used to be the shared intent here.
static imports
Do we want to initialize actual values when actual name is not empty? If we are trying to avoid empty names, then we will get all of them when trying to add more than one name.
If we move this logic to grandParent, the code may be more logical. Or maybe we have a test for this case.
Should this be a switch?
probably not needed.
Please replace request.getRequestURI() with request.getRequestURI().
extension cannot be empty or /.
this is a bit too long. Could you please extract to a private method?
reopenAccount on purpose or try editing
action.toString() would be cleaner.
This is not the same as before, that lock.
Same as above, why not just Compare with FilterPath.equals(other.path)
1. Consider having a version with the key 2. If you use the default value in the view you don't need to override the method's implementation.
Should this be moved into the constructor?
Should this array include VIEW?
This might read better if we use servers.addAll(Collection<ServerHolder>) instead of the if statement.
Can we use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
Seek too?
Suggest moving this round to the normal configUri constructor.
This class has a receive method where we have a Consistent status and can be used to fetch the localClusterId. Can we just pass the localClusterId to the ReplicationStatus that was received and the server is from that path?
The message should be: "CassandraKeyValueService creating the config, found %s"?
Can we log that all instances are returned by logger.debug?
as there is no point in overriding this method, it is better to return true if there is no semantic device ID for the snapshot (public CreateAllSnapshotsFromVmParameters() { }).
I don't think we should need the credentialType. The credentialType is actually a CredentialAcquireSupport for a specific implementation. It's generally preferred to have a single endpoint type that extends the CredentialAcquireSupport, and thus handles the exception correctly.
Can we use the super constructor?
Why not let the default ResourceIterator API instead?
That is right. I would expect a localizable test to handle the case where the mSelectedNode is null or empty.
Consider extracting position.getStockSymbol() into a local variable to avoid duplicated code.
unique typo
Maybe this is simpler: if (!notification.getNotifications().equals(composite)) { this.logger.warn(String.format("Unable to retrieve the notifications of [%s]: [%s]", user.getType(), user); } else { this.logger = this.warn( "Unable to retrieve the notifications of [%s]: [%s]", user.getType(), user); }
<>
could be fTrace
I believe the length() call is not needed here as the next line will throw an NPE if there is no length bytes.
"filter" ->!isVerboseLoggingEnabled
That's not correct. Do you think we still need to be passing any argument?
This seems to be the same as annotation. Can it be a static method? If not, can you please return an Optional instead?
According to the configuration, it shouldn't be FileHandler, you should instead use the PropertyConfigurationLayout to save an instance of it.
Missing checkCallable() here
You can also call getWakeLockPermission() here.
What else are you trying to do with it?
Do we have only two ways to use GraphQLType here?
MergeViewerSide side, you could extract this check into a separate method for clarity
Instead of downloading a connect, could we create a Response in the context and then pass it to the background as an argument? That way we can keep the code readable and avoid the need for the getApplicationContext()
yeah, let's move this to a constant
nit: as above for cache
return id == null
is this anonymous class necessary/intentional?
But it does not matter.
The id is the id in the list.
I'm not sure if this is the correct approach. I have the method working on a gerrit-server.xml and it does not follow the pattern of the XML. The full Repository is a 'public static class, not the default one.
Check command and status null.
I wonder if we can have a more neutral term. This is a koiisable function. This is a structural class and we have a structural class in the public ones IFigure.
Why is base class called this when it is not assigned?
null!= settings.getBoolean(STORE_OPEN_TYPE_ID))
It should throw an IllegalArgumentException.
As per offline, we should avoid creating the map everytime the map is concurrent?
Why is the 'else' part needed?
I guess this should be ac/untype param rather than ac/value list. (It is probably way more natural for this kind of thing)
Might be better to add an else block since your arguments are of type param.
with.with click on the text, not this should be on the.onClickOnOK() but rather with.onSelectedMessage(). Is it really necessary to reset the click on the correct linq?
instead of a list, use.toList()
remove exception.
use context.getNormalUser() instead of this assignment.
nitpick: In theory the raw token and other have the same type, we are relying on the raw type.
We need to make this ApplicationContextAware and check the context. We don't want to react to events from other contexts in the hierarchy - maybe check the context is for this context.
@Gicf reads better than string concat
should atleast check o being non-null and instanceof IdentityExtractionFn.
Please add a limit = limit; here to avoid negative values.
To follow the conventions of Spring Security, please change to "Set<url>".
I would feel more comfortable with this if block. Could we change it to something like: if (ref.startsWith(oldPrefix)) { throw new IllegalArgumentException("HEAD"); } else { return " + oldPrefix + " does not start with " + oldPrefix + ".length(); }
final
This can be written more concisely as: return mgr.stream().filter(Objects::nonNull).map(Objects::nonNull).collect(Collectors.toSet());
here you can call readAndCloseQuietly() with the "old" path of the filename, and remove the other calls to readAndCloseQuietly()
"99999" not "get(). You should probably have a "long"
I think it's better to make this private and move the setter to the end of the class
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
Can we rename headers or properties to be more specific?
Nit: I prefer using a private final String here and in the constructor to avoid code duplication.
if (map == null) { return null; } else { return '=' + no? ((Map.of("null")) : '=' + Key.getValue()); }
I'd rather drop the defaults to the method itself. This is what is being used for.
I think we should move this validation to the jobBuilderFactory.start() method.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void...) This avoids extra sync objects (and saves one level of indentation!)
@weisebrazil all indentations should be 4 spaces, not 8.
dublicate biz
Please make submit an issue.
This is the same as [plunk issues](<LINK_0>
Shouldn't this be "Storage".equals(commit.getMessage()) || "".isEmpty()?
Should we use the passed in value?
I suppose this is safe as well.
I'm not sure this is safe. If the test is broken, I would keep it in mind that the test will fail (and return the same message).
what about location? we do not need LocationSerializer?
If you don't want to be closed after test methods, please delete them and create a new test class in the factory.
Should we enforce that the b-cing children aren't changed?
scheduled() sets a non-null value to null. I think this should be either initialized or it an appropriate exception can be thrown by the txn.
How about getServerMetricConf()?
This is a local variable, should be camelCase not fCamelCase
Is there a reason you use the MetricsManager instead of creating a new one?
maybe you can add a debug log here, in case it's conflict with the previous code.
I don't think this is needed.
Please remove extra line
I think this should be a ref
As I understand the bit is correct, we do not need to cast it to int.
What is the use of this constant?
Use instead of if (file == null) return;
s/occured/occurred/
Override
I don't think we want to check if this is present in the map.
Can you make this Map as a type variable.
please rename to edit
final
Should this be a trace level?
Can we use return new Class<T>(method).resolve() instead?
why not use StartupContext.FORCE_container.getName?
you need to use the info.exists() check here, right?
Is it worth assigning this to a variable (given that it is and then later call get()?
I'd rather not supply an empty list. Just in case.
missing hasNext()?
You should have a catch block just to close it.
Could this be max(1, parallelism) or Math.min(1, parallelism)?
I'd go for this.
Use "public".
It's better to make this new method on S1 with FULL_TIMESTAMP constant in many many classes.
I wonder if the reason this was so that we can't just run the workManager through the nbogate?
I think all "else" can be removed.
In debug, please
I think it's better to keep the call to vdsId (the vdsId is relevant for vdsId)
Nhinc specific thing here - I think we should extract this method under getProvideAndRegisterRequest(request) - to avoid duplication.
Why not just call the other method via this one?
@paulodamaso the braces and return are not needed here
writeAll() instead of skipBytes()
I'd drop this.
can use metric
suggestion log.info("Due to the {} files.", Streams.MAX_TASK_IDLE_MS_CONFIG, " + thread.getMessage());
I can't say I see the test test is taking without modifications. Shouldn't it be two? Also verify the returned value is the same as the expected value?
Please use a meaningful name for the variable name.
why are we making this package protected?
Since the screenMap is a MVC error, the old one is the event that is not a specific one. The issue is that the user doesn't care about the changes for the map. In your test cases, the target map is unputable and the issue is with incorrect values. The issue in the master (with any layers in the Interger UI). I would suggest creating the endpoint specific class only so that we don't have to use the transfancy for this class.
You can keep the message ("In the rule " + getClass() + ".
I'm not sure if we can replace this lambda with method to waitOnItemInContextMenu(): projectExplorerContextMenu().waitItemOnContexMenuIsNotVisible
check if the events are still less than 0?
Hum seems we are already setting this listener
I think we're using String.format() here instead of initializing them.
inline?
It would be nice to log when the result is used
Is it needed to use DEFAULT_PARTITION_TIMEOUT in a test?
use execute i mentioned above
Looks like both XmlSuite and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
The same is for the existing code, but the new one is always true.
toString() -> appendappend
Not sure about this'syncSession'.
space between ) and {
Custom
We don't really need to use the Multimap, just use a Map.of.
You can use fragment.setCallback(this) here.
We don't want to know when this happens - is there really a reason to change without the effect? I'd be curious.
How about to rename it to "addedEval" or similar?
I am confused with this. I have to read the code of the AbstractXAResourceRecoveryResource constructor now with a single instance of the IATL and the second one is about the flags that are about to be always. It would have to be: 1. Compute the type of the whole object 2. Make the map immutable and call the getRecovery method on the appropriate object (ie call it from here). I wonder if we can just store the instance of the AbstractXAResourceRecoveryRegistry and keep it like that.
If create-liceLibertyMojoDeploy _deployArchivePath_ method can be reused.
Please, rename method example example testRequest
Remove useless assert
Maybe better to use the org.apache.commons.lang.FINE.
You need this to be thread-safe, should be thread-safe
should this be renamed into something like KeyProperties above?
Should we log an error if the rd is null?
You can use a assertEquals here
Utils.validateArg
hmm, I wonder if the sorting strategy should be fast and here we can do something like: java TreeMap<String, Object> json = new TreeMap<String, Object>(); for (int key : json) { json.put(key, h.toString()); } return json; }
Can you put the getDeclaredConstructor call in the previous line, e.g. <code>public GeneralEnvelope</code>
Probably should crash if bad format string
You don't need this new VO as well.
you can clean up here a bit if the log is deleted.
Can we use different naming conventions for variables? This looks like an error.
This method is actually not allowed to be used in the context of a different module.
why not log.debug("Error during log {}", ex.getMessage());?
It would be better to call logger.error("", e)
nit: update STANDBY to LEADEREdit.java
I don't think this is necessary anymore, because in the current implementation, it's called automatically when no storage is paused.
Simpler: return GaussianDistribution as a max value of another Boolean object, otherwise we don't have access to the function parameters?
Do we want to make this method synchronized?
@dalifreire please use StringUtils.isNotBlank here instead.
Any reason why these need to be separate methods?
suggestion OnmsTopologyVertex createActiveVertex()? new OnmsTopologyVertex() : new OnmsTopologyVertex(id, is, new OnmsTopologyVertex(id, is, new OnmsTopologyVertex(id, is. "id is not available")
not all listener
@erikdw MEManager in case of problems with Windows, as this is now encoding to system property. Can you use.FS here?
This does not support implementation details. In my opinion it should be implemented like this: java Class testClass = new TestClass(default method); if (defaultDefault) { throw new UnsupportedOperationException("Method is not implemented"); } return new UnsupportedOperationException("Method is not implemented");
Should be: Assert.assertTrue(mView.addProperty("User should contain the same value");
I realize this was also the case, but is CUSTOM
You can use this method the DOWN type in the SOFT_DOWN property since you have multiple UPs.
Maybe for cases like this where the list is either empty or null?
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Here we know the result, but I would like to use the method directly I guess.
Are consecutive reloads necessary or will be one reload at the end sufficient?
I think it'll be more readable to wrap this code in a <code>else</code> statement: for (int i = 0; i < contentService.getLanguageCode()? ((RbContentService) contentService).define(); **same for the other cases below.**
Prefer StartStart.getId().longValue() instead.
Do we need to check for -1 here?
I'd prefer throwing a more meaningful exception here. For example: "AllocationConfigurationException with a policy: " + getName() + " is only available in this context."
is this try catch needed?
override this variable
I think it's safe to keep the old code and return a CompletableFutures instead of CompletionStage just to make it clear that this is safe to use in the future.
entry
This can deadlock if we are monitoring on the lock. The metric is not available via the ThreadSafe. Note that once we are synchronization, we can remove the synchronized flag and access to the underlying channels.
can we add a throw exception?
return object == null?
Shouldn't this be!isDeferJavaScriptLoading()?
how about threadFactory.shutdown() instead?
This should be bundles.getWorkbenchBundle(class)
Could you please add a message for this exception, since we are returning null on this method
should return false if the validation fails
I would expect this method to be called with the showUser method, not the endUser. Maybe that is better than here. I would expect this method to be called with the return value of sendUser.
Can be private or package protected.
I think it's better to change the use of null field access here: java JsonNode JsonNode = new JsonNode(jsonNode); return JSONNode.fromJacksonNode(jsonNode, JsonNode.class).map(value -> { return JsonNodeUtils.fromJacksonNode(jsonNode, JsonNode.class).orElse(null); } return null;
Is it really necessary to filter the FQN?
We should not be using String.format with values as the key name. Add it here too.
Can you make this more specific by making applicationContext a member variable?
Would this method stop the rebalance as well? I can not see stop call here.
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
I think it's possible to define a pass-user-type to indicate that you have access to some item that has 'public'. This will work with <LINK_0>
Should we use Arrays.toString(micro) here instead of the toString()?
Use a for loop and put into the queuedRequests list
Use startsWith instead of contains.
can be grouped with the other planner class from the same filter
I don't think you need the isNotEmpty here. The testNfsConnectionWithValidMountOptions is already tested, and it never gets false.
This can be simplified to: return Objects.equals(name, name);
I think this code could be simplified to just selectedLayouts.isEmpty()
Why did we make this public?
this is a bit complicated.
could be simplified: specs = StreamSupport.stream(refs.spliterator(), false).map(RefSpec::getName).collect(Collectors.toList());
should use LogUtil.DEBUG_MODE_ENABLED here too.
Do not catch this, it's not a good practice to throw an exception with specific message (e.g. any relevant message)
please revert changes in devel-only as they are related to Config.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
unnecessary cast.
Resource overflow
I think this condition is not needed, right?
Argument name
I believe we should be able to make this method final. We should be able to offer it.
+NUM_STRING_ARRAY_STRING + NUM_STRING_STRING - NUM_STRING_STRING + NUM_STRING_STRING;
log.debug instead.
It doesn't seem to throw an exception if imageId is negative.
I still think it is great if you could move targetNode.getBuildTarget() to a local variable. That will be invoked for every type of buildTarget and one time.
line 228 and line 223 are identical.
I don't think we want to have a test for the second or two, since it's a clear what this indicates.
Why the change? Let's keep the log messages logic in this method.
consider making the mapping a field with the value at this point (if there are any other fields that can be accessed by other classes)
I would put this in another method: assertEquals(LineItem lineItemDraft lineItemDraft, LineItem).withWait(new LineItem());
You can use assertj's iterator.
Please add a java Objects.requireNonNull(computation, "computation is null");
Can use StringUtils.fromUtf8()
Make an extra final
Redundant parentheses
Can we have a thread name here?
Please make a copy of the same class and use it in the constructor.
suggestion connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
I'd use!G straightawayUtil.isEmpty() instead of 'Compile'
Why not INSTANCE?
use ShellIsAvailable
Conflict event creation here as well
Check store RefundsResponse and see if there are pending transactions in the payment id?
I'd have expected a return value here (Reason resultType ("Not a true") and otherwise return true.
Is there a reason for this change? OutcomeParams seems to be only for internal outcomes, so it shouldn't be false too.
Can be replaced by logging.
You should use this variable rather than the it is _must_ be LOAD_PAGE_ActionListener.
I think this should be a check that the metric is a service metric
Can use Objects.hashCode or Objects.hash here.
I don't see the point of doing this...
Missing space between if and (
I don't think this is correct, but the descriptor should be in the name of the file, not the icon, and can be changed. But I want to ask myself if the icon corresponds to use the name or not.
Should use the Utils.validateError(String) method to show error.
It's hard to understand why we need to call toString on the value of getOverlog2 for both default and client. In this case, it would be much easier to omit getOrDefault check.
This is a synchronized block of a method, for example: public void addToList(View view) { views.add(view); }
use Assertion.assertContains instead of URLsContent
It looks like initializeRuleRuntimes should be initialized inside the initialize method, while returning the initializeRuleRuntimes, so it shouldn't be returning the initialize method.
1 should be done before the _nextTaskListener is _nextTaskListener_
This is a little peculiar - does the state represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
> I would use >T here.
Why first the connect, then the check and disconnect?
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
return Optional<ContributionItem>
Genre.getGenre() is an empty String. Can't we just call id3v2Tag.getGenre()?
It is better if we use here we want instead of \n, like this:\n\n".equals(? EOL, : "
It's the same class so we can probably remove that one.
if you have symbol already hasUnresolvedTypeHierarchy, you can get rid of this check and in the following would be enough: symbol.kind()!= Symbol.isUnresolvedTypeHierarchy();
This should probably be injector.getInstance(Resource.class);
I don't think there is a reason to use the camel case for the filter syntax, let's define what you're testing for
public
I know this is in your pull request but I haven't been rebased on this PR, but can you make this change by adding the service in separate PR, please?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "close" method. [![rule](<LINK_1>](<LINK_2>
I think it would be better to have a more specific error message here. For example, LOG.error("Unable to execute processResults. It is submitted because of class name.")
should it be coupons?
Why did we change to partial match here instead of whole string match?
I think using StringBuilder here is cleaner.
Might want to have this line use the WATCH_LIST_FILTER_REGEX + consistent use of the WATCH_LIST_FILTER_REGEX in order to keep consistent behavior.
should it be the public API?
Can we make this a static method in the parent class?
please use AssertJ.
.exceptions(CHECK_NAME)
I think we should skip the defaultReplicationFactor!= null check. Since it will never be false, we can remove this value from the default if there are no properties provided.
I feel like this should be else if (public_retentionPolicyMgr!= null) { RetentionPolicyMgr.updateThreadPoolSize() }
rename to listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need any code duplication.
Is it possible to avoid using WaitUtils.sleepQuietly(1); here?
suggestion final RecyclerView parent = RecyclerView.Adapter.onCreate(View view);
This should be private method, within the class.
The order of the arguments is reversed - it should be assertEquals("Test_scripts", result.getVdsUniqueId()); assertEquals("Test_123123123123", result);
Assert.notNull()
I think we should use method reference here, to reduce indentation and change code.
Use braces for all of the next blocks instead of only one line
You could use IOUtils.toString() or just use a try-with-resources
I think you should use the positional parameters.
I'm not sure about this. @daniel-beck proposed a PR to add assertJ - verifyCheckpointStart calls with @NotNull on this so that the AssertionUtil method can take the first time.
Use assertThat()
This is a bit weird. In blob, layers of disk stores are either on the same host or on different kinds of nodes. Also, you're not on changing the order of layers and performing operations on the same manager. It should be a separate method.
Can the delete of the doc be null?
Can it be just a static member of this class?
This should also check if the path is a string.
Could you remove the toStringHelper method?
Remove all "null" cases. There is a default case for that. Also, you can't really compare this for that.
This method is called from the previous line (at least in previous implementation) see TID as well.
nit: remove
Can you use the test method _verifyClient_ instead of the magic number?
So if you make this a method, you can simplify the code by pvdr.isEmpty() or pvdr.isEmpty() to pvdr.isEmpty()
This should be fine, if you set the file to null then don't need to be safe
Why has this been added? A struct { } should have been removed?
Don't add this here, it'll be a good idea to log the field in every operation.
All web contexts should be expose method like Objects.equals, so you can import it.
Please use logger.debug statements.
return "" +
Can you use the new LANG_getNamespace(Class) method instead?
This is the correct message, the blurred message is for retreived as're stripping out ':' and other tokens. This is how 'key/value/' are referenced in the other files too.
This is a lot of repeated code. It might be worth creating a private method that returns a boolean, and the name of the function should be changed to something like checkFieldToLogMessage(Ammt) or similar to the existing method that checks if the expectation is in this class.
I doubt this can be true, also if the assertion on the content is the same as the command, right?
this is 3.3 feature, not 3.2
This class is thread-safe and synchronized. boolean methods used in this class
Change to: "Finished Pending Tasks are already in the next line."
Is the initial state of the stack trace done by the caller? Seems like an error to me if I'm wrong.
Wouldn't it be better to change variable name to non-null?
It's beeter to used int type.
Why do you change the synchronized block here? As discussed it is not needed anymore and because you just don't expect the listener to be fired anyway.
Use a typed method here.
I would prefer for (int i = 0; i < matcher.length; i++) { }
concurrency issue too
If the state parameter is set, this could be UNSET.
MaxwellFilter has a test cases for these two
Remove this catch block and replace with: Lib.exec(system.bin/sh)
Should be synchronized
I think that re-throw is fine.
Add a message saying what problem is wrong.
Maybe we should rename this to storeToManyRelationDatabase.
Why should this be check in the patient id?
Log debug - not info.
Use try-with-resources so that they get an NPE if there's no ResourceGi64 decode.
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Can be replaced by Collections.emptyList()
I'd convert this method into a static method isExcluded(excludedGroups, groups) and having the constructor do the check for it.
This code is deeply nested. The code above can be simplified to this.stat = ((channel.stat) this.channel.stat) & this.channel.getHome();
This will do the same thing as before since you're using a default VmwareVmImplementer with a null value. Can you please add a null check here?
should we use logEntry in the property here too?
Please, use text "projectName" (Name was fixed after sending this pool request) thank you.
This can also be made static
Is it sufficient to keep an instance of DefaultAWSCredentialsProvider() and keep AWSCredentialsProvider() for null as well?
click on element
Not sure that this is the best way to test? :(
This method should not throw an Exception.
Please use AnonymousSpec which is general.
Should we be binding these to constants? Parameters are a bit dangerous to me.
It's better to use static import here to improve readability of code.
Why not String.valueOf(label)?
Don't print the stack trace of the test.
you can call endSuccessfully directly
Let's make it a factory.
extract as a constant
I would prefer to have the same unit tested methods again, and verify if the result is the same as the expected result.
Why is this needed?
You shouldn't depend on the prefixFormat and it should go there.
- Do we really need to timeout here? - There are no timeout and the operation timeout is zero.
Remove this.
Remove
nitpick; I was hoping for this style, but there's no need to do the null check inside the getLocalTableBlogId. This is a common pattern in other places where you want to use it here.
Should this be removed?
containerIDs.get(x) is not needed
Maybe rename this to cause it's not clear what this is doing
Please use spaces
Shall we throw an exception in this case?
Please not do that, check right now and use isEmpty() instead.
Rename -> CosmosDbFactory to CosmosFactory
Can we just do this?
Is it the only place these methods are used?
Why does the handler require a zkController, task concurrent? Same for the other one.
Use.orElse(atomic.Atomic() + get() instead of Optional.of(fetchAtomic(atomic.data))
IMO you should extract this line as a separate method getCheckCheckValueAndScanIncludes(actionBuilder)
return strMessage.startsWith("")
why not ccmd.userDefined(42, dictionaries);? It's more concise.
so the activateEntries and entries are not used by the loop?
I know this is just a nitpicky change, but this one is not really nice!
Pair<String, String>?
This is not a good way to call getLastIndexIdKv, but it looks like we are passing the actual index into this method here. If you need a IndexEntryTree.LONG, you can simply call the "match" method and call the method for the SortOrderUtil.getCodec().decodeLongViewIndexIdKv"
Please use openStream() as method to throw IOException
You can use [public static final](<LINK_0>,%20java.lang.String,%20java.lang.Object...)) to make these tests more readable.
.add(node); is happening
why public?
add braces
I don't see why element is needed here.
Static import AbstractCheck.class
Why do you make this query a string? It would be a bit more readable.
why the await? shouldn't the response be null?
please rebase, arik removed the lock in a different patch.
I'm not sure if this is a good idea. If anyone specified the field, we should set it to null as the first parameter. If not, then set it to null. I would just silently ignore the error.
Can you please merge this and the next tab with the following in terms of readability? java if (resultCode == RESULT_CODE || data.length() == 0) {
fNumericCompilerSuffixes can't be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the get method.
return valueOf(paramName);
Typo: UnsupportedOperationException
This looks like an exception.
Please use the SecurityBindAddressResourceDefinition.BIND_PORT" + ".resolveModelAttribute(context, operation).asString()" + ".resolveModelAttribute(context, operation).isEmpty()".
> Fix version is hard coded. > This should be the first version.
This could do a containsKey() check
Eliminate this constant and use the int version to indicate that the adapter is specific to the number of events, e.g. ints?
...this should be the URL to *also* the link.
This should include Ds3ApiSpec in the name.
Revert
please check here isSetPmProxies() otherwise you can get NPE
Why not make the test timezone-independent by either calculating the correct long value for "2015" and "intraHex" value?
formatter
This test doesn't check the actual result.
Fix indention (should align with following code).
Objects.requireNotNull(oldValue);
Check with suite == null
same here, can we use a final field instead of creating the field?
This is the third place to initialize a new map. Would it be better to initialize this in the constructor?
Looks like this PR is duplicated from above
Please change log.debug("Argument 'username' cannot be empty", e) instead of query.toString()
Why not this change to private?
1. do we need this? if the method is called with the same version, don't we want to check explicitly for it? 2. why don't we check just by using toString? do we?
Please add the test (using 'Remove from delete') before this change.
But why do we handle 400 differently than all other errors?
I don't think we should use final for anything
We should close the client in a finally block.
I think it should be wrapped in a try/finally block, to avoid the lock being added in the synchronized block.
Could you add another enum instead of multiple values?
why not just return toolVersion.parallelStream().map(toolVersion::getVersionsV1(i)).collect(Collectors.toList());
I guess the ACADE should be our own AbstractACADE. Reason is that you can use only SharedPreferences.FORCE_SNAPSHOT.
What's the reason for the lambda parameter? It would avoid the stream() and the collect() method.
I think a better implementation would be to use a regular object: return findById(type, count(type)).or(HUtils.findById(type))
We should drop the check here.
If this is called before flowIds, wouldn't it be better to use the return type?
rename to eventDelta
Use this.key
Hmmm... I feel that this should be in the opposite of what you're doing here. 1. fetch all the FBOs first and then generate the FBOs that are together 2. Get the FBO in the Set and check if it is there. This way the last node we will never be able to get to this node more than once. But it's not really important. Let's try to avoid refreshing the whole graph if there's no session to know what to do.
Assert.assertEquals(DeploymentException.getMessage(), "Bean class has decorators should declare at least one non-default");
Extra line.
why not use the MessageLevel type?
The query modifies the map passed as a parameter? Depending on how the query is called (from inside the backend? from the frontend via seiralization?) it may cause unintuitive behavior at best, and inconsistent behavior at worst. Why not get a Set<DiskImage> of the IDs (like this approach)?
Please, add a separate test that uses WorkbenchContext.createTest().
Let's replace this with org.apache.dubbo.common.utils.Utils
The logic to this method should be moved to SaxonXPathRuleQuery::getRuleQuery
Unneeded parenthesis
It should return ReadOnlyArray instead of ReadOnlyArray.
@rui-castro why do we need this?
Please adjust this to your patch.
I think this should be named DATA_CTX_Appended, as well.
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
This should not be needed. If the event handler is created by the EventHandler (that is an extension point), and this conversion will return true for the found event, which is a match of ID (event name)
Maybe add a message that is not convenient for this method?
Space before {
I think we should just throw a RuntimeException here.
This class isn't proxy, so, why is this object called other than the previous object?
DisposeEvent should be done either. You should block the runnable and only call run if it is not null.
Can you assert both are null?
Should we move this in ScalaMojoSupport parent and avoid code duplication?
Just make this comparison, and use FlexTable.setText("titleBar")
@ivandalbosco Why not using superTree?
We can use Arrays.asList("get(cluster)", zkClusterReady") here.
Why not use the constructor?
Do you think it would make sense to initializeMetric(final MetricsFile, final MetricsFile existing) constructor with a default value? I guess the "default" visibility is a bit unnamed.
Format this file.
This line can be replaced with: return Objects.requireNonNull(diff, "values");
I would like to check that the result is not null before executing the operation
please verify response on remove()
I think this should be moved into the doStoppable method.
Aren't you supposed to have a different defaults in the case where the min is used?
Command name should not be the command.
You are using a putIfAbsent rather than the implementation, I think this method is no longer necessary.
use String.format instead of concatenation
Shouldn't this logic be part of perEnvironmentChannelGroupUpdater(Publisher.getInstance())?
You can use assertEquals()
This variable should be removed.
this is going to always return a list. I'd use append instead of manually building the response body.
This test would be better if we use a test for both methods
s/public//
Can we move the check to the original if (sharedIDEContext == null) line?
Could we add a util method CacheCollection<V> explicitFlags = new CacheCollection<V>(explicitFlags, explicitFlags, explicitFlags, explicitFlags, explicitFlags, explicitFlags, explicitFlags, explicitFlags, explicitFlags, false);
Ditto re: operation.perform(aggregate)
This plays the current, not the next station.
We should keep the same format as the method static <LINK_0>
@antonini you can use TkPrint.assertThat here, as it's better to use static import
shouldn't be " instanceof" also? Since the cast will be checked first, it should be changed to instanceof check only if object is instance of VDS or not.
use  mountTableConfigLoader
catch with the same exception instead of 7?
These two could be simplified to assertNull.
shouldn't this be List<ERepositoryObjectType> toReturn = new ArrayList<>(...)?
Shouldn't this be an error?
you should call moveToState(state,... the same value for all the other handlers, not the same thing for each state
It works but it smells, I think this should be a separate method in DiskVmElement of this. (and the one below)
extract this string to a static final constant
shouldn't the return type be 'protected'?
can we reuse code in initSpanInterface?
Please use a separate log message for both cases (this is called every time the assignment is called)
I think this is wrong, we need to click on a new item with each click
Why doesn't this use Arrays.asList?
Why not iterate with the list?
Can this be done before the check for list.isPresent()?
please use querydsl instead (already in master)
Could this use different order than the other one? If the assertion fails, Line will never be reached,
Do we need to catch Exception at the places where you invoke it?
Can we use new File(path) here?
Is it worth throwing a RuntimeException here as well?
Never swallow exceptions.
missing braces.
You might want to check that the file exists (or simply catch it and do nothing in the PermissionService).
static import
any other error handling missed?
This should be: if (entity.hasEntity(PersistentEntity.class.getName())) { entity.getName(); }
Why is this needed?
You should not swallow this exception. just return TYPE_DEMO.TYPE_DEMO 0 if it's not equal to id can be null.
should we have a test that verifies that this is the right thingTypeIds_shouldSet be the new check
why do you use this instead of Assert?
Unfortunately, I don't think it's a good idea to keep these methods synchronized unless they are required. I'm missing something there's no guarantee that the order will be the same across threads.
can we keep the implementation with something else and assert on the status?
base is not nullable here.
Should have a null check here?
I think we should prefer accuracy over speed here, and use theradius should not be set yeah as the variable, and then the variable should be set to the value of the method.
Can you please also add a default value for limit codes here?
Why it is better to use the ThreadHelper instead of sleep for a single session?
Consider using XOR operator (i.e. JDT to fix profile and continue with 'public')
I get the feeling this is too simple. What about splitting the filters? What if they match? We could just have a single constant, and we could eliminate the risk of creating a new object.
is there a reason that this is done with Jenkins.get() instead of getActiveInstance()?
With the latest version, it's going to cause issues then.
> Sorry I missed this before, but should we add @Override annotation here?
@Godin Here I think it's better to declare the return type with boolean.
Can be simplified to: java if (classType == Type.classType.isAssignableFrom(classType)) { return Factory.classType(); } else { return Factory.classType(); }
This is not a good solution: byte[](byte) (byte) ( byte)(byte) (dataBytes) (byte) maxVertices))
Adding this to a field is good manner.
it will be non run but the code is not executed until we know the execution will be executed even when the interpreter context is not running. so I think this should only be executed if the running java job is not running
Does it make sense to go into KafkaTranslator instead?
If the FrontendRunAction() returns null, you'll end up with NPE anyway, but this can be simplified to Frontend.RunAction()
Just checking, for path.equals(new File(path).
Please define text as a constant.
Can the getter be package private?
You can do this: return super.PRODUCTION, autoConfig);
System.out???
I don't think you need this null check. Given that you have the assert above, this is fine.
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
can we use the integration-test module as part of creating new module and make the rest of the classes a bit more flexible?
This method should not be public, is it supposed to be here? If so, static access do not encapsulate the implementation.
I think the whole point is to combine the two lines above and return an if statement.
I think this check is unnecessary (instance of if we iterate over the metrics).
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
suggestion if (rowIdx >= rows.size() && requested > 0)
Can we use the ternary operator here?
This condition is hard to understand. I think the log message should be a bit more generic, like "Error occurred while sleeping for interruption status.".
I don't think we need this if block. We can always perform the conversion once if we're going to use ExpressionInterpreter. It will also slow down the ExpressionInterpreter, since the original will be serialized to a (literal) value, and that can be anything that should be handled. Is it going to be easier for someone to support com.facebook.presto.sql.planner.ExpressionInterpreter#evaluate?
same again: do not create a new empty exception but reuse the old one.
In the other class you use a JBMenuItem. Any special reason to use a JMenuItem here?
Let's use Guava's nullToEmpty() method to make it shorter and avoid the null check
This mapping should happen in the context of this class.
A SqlCall call with the correct super.unparseCall() method is the best place for this.
Sorry, I missed this before. Shouldn't there be a new method here?
Returning a null list is bad style. Make it final.
What if flow.getConnection().blockUntilWritable(LOGGER.get()); or something?
have you considered java Objects.requireNonNull(errors, "errors is null");
if it's null, then return appName.getPackageName() can be null. Otherwise return null. probably change it to this....
So, this is dangerous. I think we should have knxnSocket(final ClientCnxnSocket) for the krnxnnnnntype. The right thing to do is to add a constructor that takes 2 arguments and passes KClientConfig() that takes 2 arguments.
Why in RunListener? It would be nice to have a test case for the Reporter factory, but you can still invoke it in the tearDown method
Shouldn't the function signature be "Couldn't launch"?
suggestion this.licenses = licenses;
I don't see this as necessary. assertkeyPair(file, null);
How does this return (protected boolean hasChanges)
you can use this.int returned by the method to help reduce GC pressure.
If you are going to use constructor that takes a value and a fileName you can use here instead of passing a null value.
nit: you can avoid changing this to a Set.copyOf.
Missing 'this'.
I don't see any reason to add this method public
return results.toArray(ec.actions::toArray);
We should not catch this InterruptedException. I think that should be catched, not InterruptedException.
@njhill we need to check if isTraceEnabled() is not null here
Should this throw IndexOutOfBoundsException?
should this be "== getRight().getOutputType()"
@migrycc Can you add @Nullable to this method? It is intended as any parameter.
Is there a reason why you removed the 'org.hibernate.search.exception.Error?
I think we should be more explicit about the waitUntilFlowPreparationFinish() here, it appears to be invoked more than once in that scenario.
Isn't a HTTP BAD_REQUEST the HTTP Status 404 just enough? Do we need to write a json message as well?
You could use spritesheet here for this
Do we actually need to add the "255" literal?
Should this throw Missing?
Do we need to use this? if so, perhaps we can use suggestion return waitForPath(getCaCertPath() getCaCertPath() + "/etc/v.pem/v.txt", getCaCertPath());
can be replaced by a static method
Think it would be simpler to do java String key = System.getProperties(config); return properties.get(key);
Can we change the static variable to just be part of the CmdLineUtil class?
Why do we need a super. Same for other mocks?
is it possible to make a public method to return null for value as well?
Couldn't we check mCheckingDomainCreditsProgressDialog == null?
Instead of returning early if it's not null, just return with the server's content and log it as a Git instance.
iterator() should be enough - there is no need to do a loop to get the iterator...
Change to use an early return when you are changing the deadline.
do we need to pass timestamplockServiceWithBatchBatchUpdate, or can we just pass the timestamp service and timelock service?
use'return'
move this synchronized block to the next line?
Add a null check here, so that this points to the top of the method.
No need for.toString() in new tests?
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc...
I would expect the white-listing rules to have changed and match app id by the new property now
What about creating a private static class and using it from here?
this seems like it should be a try() with resources
Can we have a constant for the size of the cell?
This is not right. Please use "system.tallies[i]" in this version.
Maybe use OpaqueReport.parseBytes(...)?
I find it strange that readNext() returns an Optional<M>, why do we need to get rid of readNext() here anymore?
Can you make isExternallyInducedSource() return null?
How about getNoAlreadyRegistered().splitToList(Arrays.asList("No"));?
I think there are some places where this is called. Could we rename these to "getHeartbeatHeartbeat()" to be consistent with the others?
It would be cleaner to use a constant for the retries.
I think this is not going to work like it has to be an estimate of long or zero?
I think we should rename the future to startFuture and then wait for leaderElectorExecutor. This won't make sense.
needs 3 _arguments_, plural
Should this be delegating to a different method than encodeLink, above?
returning null is a bad idea
Should we return a Collection here?
Should we still log the error if the user fails to find out why?
I think a gpt is  param and return results if it is GptPageParams.
Can we use the.getUuid() method in FragmentUtil? Just to avoid adding further dependency on.getSpanId
Can you call this method after the for loop? To be very explicit in between: java AnnotationUtils.getJavaClass(annotation.annotationType(), annotation -> annotations.getJavaClass());
Please name it "image"
Can you please use a logger instead? I know it's a standard rule, but we should not have to display them in the failing tests.
Consider rename this to filterArchived, to make it clearer
With the default null check, is there a validate throttling to do the job?
can you clarify why the message is null and not the empty string?
This can be removed from saved list.
The super.close() should be in a finally block
I think it's better to remove the "isNotNull()" from the message.
Can maybe others not set the size here?
JUnit asserts are ok without them.
This is is a code smells like this can be factored out.
Isn't there some simple little library for generating JSON output?
I think we should only do this once in the callback when it's null.
This is not necessary?
This expression is unnecessary.
This looks like a leftover of debugging code.
Minor: you can simplify this as follows? logger.info("\n----------------WebSocket")
Can you please use PDataType.fromSqlTypeName to get a stream? PDataType.fromSqlTypeName(arrayPrimitiveType, elements)
Sound great.
as discussed i read up with the rest of the code base i.e. you'll have to change GatewayState to get the default value for the getter and setter methods.
I don't think this does anything. It's easier to read and understand what's going on.
can we change this to something like for (listenerToInterruptionCommands : runningCommandsMap.values()) { if (!listenerToInterruptWatcher.containsKey(commandsToInterruptLeader) { //... } }
this needs to be inside the if block or directly within the ExtensionHandler.
NullPointerException
I guess you meant to set the sShipper even if it's not being used.
minor: this is duplicated logic in private method, right?
overlay.toBack();
Was there a reason why you are removing the null check? The rest of the code is checking the length of the array.
This needs to be: java return new SimpleDateFormat(objectName); So that both methods are immutable.
super.toString()?
consider createContainerOptions
nit: one line is too long for line 61
This method should be org.apache.commons.lang3.exception.Exception, not a unit test (in which case the caller should use the new or none). If we want to test the case where the entry is a foo, then we can get a NPE (i.e. if the parent is null, we would get a NPE in the first place).
This line should be moved after line 94.
I don't think we should be using this to access the members of the Resource and not the whole class. This happens on the next line.
The constructor can directly call lease.get() only once.
Likewise..
You can use a Set on the size of the list.
nit: use EMPTY?
You need to have a TypeVariableName here.
Why do we have test for it?
Suggest to use _Logging_ instead of "You were Global.logInfo.forXMilliseconds. And actually this magic number is a little confusing, I think.
@inverno This is confusing. You should have a default constructor for Log, not an alternately using "log.level" since you are setting this to false.
not sure this should be 42 or something like that?
Please replace with: return getVds().getVds().getVdsGroupCompatibilityVersion().getVdsGroupCompatibilityVersion();
shoudl we only catch this exception if value is null? I don't think empty is the right thing to do.
Remove this line.
Can we use name as the second argument here?
The FactoryTransformer.factoryTransformer(factoryTransformer.factoryTransformer(factoryTransformer)) is already invoked in the factory.
We should avoid using Assert.fail since it really only checks the specific exception.
nit: do you mean getQualifiedName()?
It seems this method is not used anywhere. Could you please rename it to something more like "getSysProperties()"
I would prefer to make the name of the 0-9]+ object as a name.
suggestion private void instantiateSound(final Media Player app) {
Minor: since locateMember has been renamed to locateTests() to avoid creating too much unnecessary work, maybe downloadMember should be renamed, too?
I think here we should keep the old code as it was before.
The "implicit" is not a RuntimeException, so it should be ignored.
This should be logger.error(message).
Shouldn't this line be in the getMapFile() call?
Rename to DEFAULT_COUNT
Use a LinkedHashSet to avoid the risk of two being added to the list.
Do you need this check, or ifmntByAttribute is empty or not?
this is a breaking change, please keep it, for consistency
Why not use the client provided by the command name? s/new File(path).startsWith(NEW_DRAFT_CHANGE));
Why not throw new DefaultAuthenticationExtractorException("general", "token");
inline?
Is there a reason this doesn't use the getServerRoot(String, String) method name and used twice?
Typo?
This will add the same overhead as add() but would be neater
Move String values used more then once to a constant.
Minor: this.groupArtifact = checkNotNull(groupArtifact, "groupArtifact");
Looks like you forgot to check for null here.
what about just filter and throw organizations?
"this."
You can just do return start;
The last assert is different from the first 2
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable: ExpectException expectException = new ExpectException(new ExpectException(e.getMessage(), AssumptionViolatedException.class)); But I really prefer delegate or delegateStatement because that is what the role of the Statement is for the sut. The variable is declared one line up, so the long name isn't needed and makes the code harder to scan IMHO.
Can you add LOG.info to the logger?
Update the default implementation
This is a bit hard to read. Please use [SQL.standard.boot](<LINK_0> use it.
I don't think this PR is needed for this now.
You can have this.typeList = Arrays.asList(typeList.stream().split(",")); instead of the two lines
I thought mods had no collection in their names that actually set their input? It might be incorrect though, I'd actually check that it's not guaranteeing you actually set a non-empty list in the box with the error message.
This should be a notLong.
Should this be LON_DGS?
Yes, I see it is deprecated. Please use ResteasyProviderFactory.newInstance() instead.
missing else
you can use ToStringBuilder on the param version
Matchers.containsString is clearer
can we add here more descriptive name instead of element?
You should do: String msg = String.join(",", "baz", "bar"); assertNull(null, "bar");
I think think System.outs should be logged.
I don't think we need to change the logic here. As it is getting called "hasSubclasses" can be removed.
Can we use DaoService to get the load-time cache?
No need to use the.toString() here, just print the stack trace.
can be replaced with Jenkins.getInstance()
The above two lines don't work in the very next branch. If it's hard to understand correctly, putIfAbsent should return the bufferNode - it is not possible to replace it with the new method call.
remove?
This should be fail, with a message that fails the test
This is weird. (i.e. it's default to "abc" as null)
fields should be set in the config class.
suggestion LOGGER.info("deserializing here, is);
same here, synchronize on dimension
Should we use the logging framework instead of DEBUG?
nit: can we return null in this method?
Does this mean that confutch-site has to be set on the target cluster?
Add Override annotation.
There are no other subclass cases, this method can only be called by the super implementation.
Shouldn't be using session. manager.exist()
Should we use Objects.toString() here so that the product is human readable?
Will the slave be started in case of a single slave? If so I think this rule should be moved to a separate method.
sequential can be in one line.
I am not sure what this is doing. The whole file cannot be loaded from a File or Path.
return "this"?
Please use: return allValidationResults.entrySet().stream().filter(entry -> value == null ||!value.isEmpty()).collect(Collectors.toList());
Can't we just keep the old code style style, without duplicating code?
Minor: Seems we have two properties (or both) and shutdownAll. Maybe we should be consistent in the  release.
Do we need to skip the existing checks here?
nit: not sure if you need to use {} here.
In some cases, the default case is true for two different things, e.g. if the compareOrder method was called before the first time, and the last time the time the compareOrder is called. We may want to consider some kind of comparison that does not change the default (not on the metadata view) to avoid the problem in this case.
Please use the new assert() method for these cases.
return toEstimatedSize()?
you can use!= instead of && and then you don't need the getStatus()
Why do we need to keep a reference to the activity here?
No reason to keep the methods public except for the implementation.
you can also remove the debug message for the test if you do any good reason to.
This code is almost the same. Maybe replace it with assertEquals()?
I think we should also check isSignedIn!= null here.
it is the tenant ID and settings object
What does the reason for using the constant here?
why not use angleMap.keySet().stream().map(si -> angleMap.get(name)).filter(si -> ((Servo) si).moveTo(name)).forEach((Servo) -> { if (si instanceof Servo).get(name); }
Consider using StringUtils.split() method instead
Could you extract this into a constant?
This method should be private as well.
access flag
Should this be instrNum
What should we do here? We should likely log an error (i.e. this exception) if there is no exception we can't get here.
I'd go with the other "*." so that it can be a string resource, though not a string comparison is valid.
I suppose there is nothing wrong with this, but there is no need either, is there? (e.g., just a monitor.split(1)?)
Could we maybe use Collections.singleton(...) here?
Shouldn't this be: if (isInFlightRange == null || fTimeRange.equals(fTimeRange.getSyncObj())) {
Can we use Objects.requireNotNull?
What is the purpose of this.?
You should test for both instructor and student?
Is this really needed?
setErrorMessage
can u extract a final constant with a readable name out of "<[ ]*%s[ ]*>"?
Here you need to initialize the field in all the places. So, you can move this into the private method to initialize the field in all your classes.
you have to synchronize this with options - it doesn't really matter much (just like you're calling it that makes the code a bit more readable, especially if it did be there too).
I'm not sure it is ImageJ style. It won't be possible to use Path.getFileName() instead. This will just pass true on the File object. Our project will have a reference to the File object passed to it.
i18n
rename to "host" to better reflect the term name here.
Instead of clone(), we can use Checker.updateIfPresent() method.
nit: this.iterator() seems unnecessary.
Add a checkNotNull check.
I like that we don't have to define headers by class. What do you think?
You want to use the expected path to be "word2";"
this mapping should happen via public enum and not via mapping backend enum to string
calling endSuccessfully is problematic, I don't think we should filter out the 'log' method, because the 'endVms' method is called when the user presses the 'end' method. it should take the following condition: if (allVmsDown == null || endSuccessfullyContext().isisPrestarted()) { setPrestartedToero(); }
This shouldn't be a constant of a class. Either use the constant in the class or make it configurable.
this is overflows max througput = 1,000,000 if you multiply that by 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L *
consider simplifying this: if ( pkgType == null || pkgType.equals( entry.getKey())) {
Does this method need to return a new value, I think?
suggestion throw new IllegalStateException("Cannot terminate process with Not a UNIX system");
I think this make more sense as this.clientConfig = clientConfig.get(CommonClientConfigKey.DEFAULT_CLIENT_TIMEOUT);
please use [try-with-resources](<LINK_0>
Looks like these booleans are used in more of the be of the add call - containsKey if (!isSubsystems).is(esub.get(esub.get))
Is it guaranteed, so the order of siblings.size() is 0?
Remove this parenthesis
@SocketAddress is not used.
I'm not sure that's a good idea. I'd go with logging here, too
This should be: java return new SignatureFor(algorithm, secretBytes.getBytes(Charsets.UTF_8), payloadBytes.getBytes(Charsets.UTF_8), UTF_8)
needs to be synchronized (in case of exception)
Same thing here, I would prefer to use brackets even for one line statements.
I would not name it something like DataStore.coordinatess would be better
I would probably return Xid in a try-with-resources block.
nit: this definition looks really awkward
CommitOrgAction is misleading, it is not of any user requested/changes, but just about the creation of the containing project.
Rather than using a for each event handler, why not use a for each event listener?
I would say that no empty collection would have been added here.
Can we make this private and introduce a new method with a builder?
patt is never used.
I think all users need to save if they have the same role as the read-only flag. What is the purpose of these exceptions on all?
We can consider tocHandler.hide() instead of SHOW_HIDE_RESULT_SHOW_MU_NOT_READY so we don't have to start to use it in the listener
Collections.emptySet() should be all that is required
Since the buffer's corrupted stream is the Stormpath supports it, I think we should keep this in a try-with-resources block. A cursory reading is a bit too much and dislikeding it when the stream is corrupted.
This check should be done by the Assert class right? This allows us to get rid of this.fieldLoadingPolicy and the other.
What are the reasoning for having ProgressListenerWrapper a boolean param?
This method should probably be protected as well.
This looks like a switch-case to me. We don't want to handle rotation, are the coordinator* methods _are_ to noopOwner?
We should wrap this in a synchronized (to make sure we always get closed)
can be simplified to return response.getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getValue())
Should this be delayed_capture instead?
please rename to child
Other headers might be pre-existing to this method. Its probably not worth the complexity of the code to create a boolean should be used when both of these scenarios are added to the same thing.
I don't think this needs to be here anymore.
Timed out -> System.currentTimeMillis()
s/Fail
the following is more fix-only, you can avoid the call to decrease the number of calls to clients. the synchronized block is redundant and we can change the method without
ArgChecker.isOnlyNonNull(fixedLeg.toString())
call notFound
what guarantees the name of the password?
Why not use lambda syntax?
nit: test with a more meaningful name, like "targetStatistics for RocksDB."
This shouldn't be here. The return value is not being used.
Stream closing?
Small nit, but this could be null, and - may be it makes sense to do the check in the constructor.
It is file, not url. how about "file cannot be null"? that would be a completed sentence
Is it worth asserting that targetUriAsString is null or not? I find it more confusing to say that it's prone to error if it can return null.
should this be ImmutableList.of("brooklyn.size", "brooklyn.size()); instead?
Also, pool overflow is a good opportunity for performance (int) and a bit easier to read.
do we need to CachedConnection here?
add brackets to make this expression more easy to understand
Shouldn't this be return Util.isEmpty(propertyEntries.isEmpty())?
I don't think it's necessary to cache the result of caches. It seems we'll have to create a new object each time, right?
Not an exception
Could we maybe have a singleKeras -> InputType.VALUES? I would encapsulate this in a way that is a nit.
Please change equals to taskKeyToTaskIdMap to avoid NPE
What about otherId, EXACT field?
I believe that this test is not correct. It is required to use a8859. Will that work with the security service. test.
Nit: You can use the new MessageBufferInput variable here.
Can you add it to Builder method?
please do this
Should we have one static field for each value on its own instance of this GsonBuilder()?
It would be a good idea to put this in a constant (e.g. KAFKA_NAME_LIST_NAME)?
Cant we make this package private?
please use getVmPool() instead of getVm().getVm().getOs()
Would prefer a one-liner with TCCL and add the TCCL as the variable.
listeners are not notified?
Can be rewritten with a return statement.
Can we return name?
this can be in a finally block
Sporize this?
I think this should be GTK3 && GTK3gtkRequisition.getBlockCalculationsGTK3(). It has the same issue as the GTK/ML/PRs, but we don't use them on the widgets. I can't think of any issues if you don't use it.
Consider calling this method from within the base class (and another one) to get the context (which is not in a Audience class), as it makes it more sense to me.
Why is the getBeanAsJson() call needed?
I would have expected here to be sure that improving this test will pass even if the assert fails.
I believe the line above are are needed now.
I would move d to firstChar + 1 to the beginning of the method since this is a public static field
Question: if we have three times and isInitialized we should just check manager.isInitialized() && right?
Can be removed.
return this
can we use %s here?
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
This should probably also be part of the public API.
If the key is "null" then the following 2 calls can be simplified to assertThat(verifierNode, () -> res.get(entry.getKey()).is(entry))
why not use new ArrayList<>() here?
Can you rename this to shutdownPublisherAndReportMetrics and let the shutdownPublisherAndReportMetrics below handle metrics & shutdownPublisherAndReportMetrics.
The same here with the above method.
See the second question about accessing the reloaded meta data. Do you think that it will be useful to mention the second one? Or only the first one will be the last one.
Add a new message to this exception: throw new IllegalStateException( "The channel cannot be accepted");
The default is false (<LINK_0>
Could you please rename these to rFamLen, right?
Maybe you can add constructor which accepts a default value
The other doc partitions that use this this method at the beginning of this method are very confusing, can you keep it as it was? If so, how about we just have it in a different PR?
this method should return 0 if it does. The caller needs to know what the data source is being sent from here, which it seems to provide the wrong data type.
I think it would be better if this can be extracted to a constant.
I would prefer to avoid null checks by using Optional
I think this is an update. What about we have a bonus from Spring s array encoded as a base message?
final
The "future" is supposed to be the format of an enum and this is a typo in the request.
Just use getContent() here, as the default value is null and is not the corresponding parameter.
java try { base.close(); } catch (CairoException ex) { System.currentTimeMillis(); return null; } That way, you don't need to set closed unless you are sure it's not possible
I think we should add the exception as the second parameter to WARNING.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
This isn't the same as other. Use the fields on equals, so both classes can safely change with Objects.hash(Object, Object)
Missing white space
Be careful of nullable fields!
We should be able to use @Autowired public cleanUpWithEmail(userAccount) { Context userAccount = Context.getInstance().clearCache(); if (userAccount == null) { userAccount.clearCache(); } } return userAccount.clearCache(); }
return defaultBase
Do we need to synchronize on this? In the case of the addAll, you could just use the new JSONArray if you want.
And this one is good, but is it intentional to set child expressions? DiagramCallback - ScrollTargetCallback at this point?
if it's not required.
return Objects.equals(RequestParam);?
please use this one to navigate generic method
I get a warning here if this field is not set, can it be any more? If it can be null you should add a check here to make sure that the handler is set before invoking the getter.
Why not put the token type as a field?
ofNullable maybe, no?
You can directly use!SanityManager.isEliminateNots() instead of!SanityManager.isEliminateNots() &&!SanityManager.isEliminateNots() &&!SanityManager.isEliminateNots() &&!SanityManager.isEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.isEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!SanityManager.verifyEliminateNots() &&!S
expect string should be the first parameter in _if_!_
Is it possible that the lock isn't acquired by the first thread? I'm not sure why we're waiting on the timeout here, but just wanted to make sure.
Can we move this method up to the caller of starTreeV2?
I think we are missing a null check for autoProperties here.
position is not necessary, just add them in the order you want to have them there: baseActivityTestRule.launchActivity(new SetVariableBrick()); changeBrickPosition.addBrick(new SetVariableBrick());
This check and the previous implementation (and in the next commit) doesn't do anything?
Why do we need this?
I think this should be CrashlyticsCoreService.getInstance().CrashlyticsCoreService.setPlaybacklytics(true), as it currently is the only change in this file.
unnecessary (readContent)
Arrays.asList()?
Might this be clearer as: java return v == null || (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) && isSubscriptionBasedLicense();
Should this be marked as deprecated as it is in Page?
I think this is not an issue, but I think that we should be able to set this to the default stats.
nit: make it clearer to use switch and return null ||!new SamplerConfigurationImpl(iterator(), scannerSamplerConfig);
This is not needed as you can just inline the field directly.
What about throwing a RuntimeException instead of a SQL Object?
use lock if you're not using the sync collection.
use new RuntimeInfo(new SafeUnit() {
Why are all these methods public? It seems to be the only usages of the public API. I'd make them package-private if it's required for the two methods here.
It seems that these assertions are not really tested in the future. Can you please separate them?
Shouldn't we test the future if we may be able to write a precondition that makes this method risky, since the code path may not be non-null and is reliable?
Why do we need the CCC descriptor here?
Should we just fail if we couldn't get here?
This does not seem correct, as this is going to be unique by each stream... first, then the above will be going to be t -> t.requiresTransaction() which is the correct use case. Or maybe you could use the stream directly to avoid the anyMatch call here.
Is this necessary?
since we expect ReflectionUtils to contain only "throws Exception" in test.
This message should be updated for aliasProvider providerFor(ConnectorId provider)
This is fine, but maybe it's not possible to merge the whole thing into this, just make it a no-op?
No need for getInstance(), the container can be passed
Does this method need to be synchronized?
This might be clearer as a Set.
why not use the system default encoding in UTF-8 as the platform default encoding?
return default value
You can have Mem(queryResource) which can be reused by other in the tests and the code can be reused.
for the name, is this "sendMessage"? Isn't it just a copy of the result.
drop these 2 lines
you should transit to this message instead of using the ternary operator
This one needs to be private.
This is always null
can this be new ArrayList<>(config.getCause())?
This should be context.getCurrentAddress()
No need for this log message. The method should not be called _only_ if the parameter is false.
Do we really need this? I think its a debug message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
Please close the connection to the end.
Move String values used more then once to a constant.
Label should be reporting.parameter.date.
The loop is hard to read. Put each loop in a method.
I think we can improve the readability a bit here?
just use Optional on the [default](<LINK_0>
great cleanup!
please use NotImplementedException()
This should be: Matcher<? extends HasUser>, I think.
store the result in a variable and then just call this.size() in the loop.
shouldn't it be the first entry?
I think it might be clearer to use mapKeyToPrimaryAndBackups.
Please remove this. The same for the other setter is already checking runningMode.
Should this method be changed to MemberDao::getMemberByUsername to be used?
why do we need this list for sortedOrderInList?
should this be return 'public'?
This method is used when the instructor is course-free.
Change this blank line to just "= ")
Better revert.
I think it should be getRoot()
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Points to Points. I don't think this is possible. Suggest using BinaryData#fromPoints to make this method private.
It seems that you can safely remove the annotation and if possible you can use hasNext() instead of stop().
Maybe you could initialize lastSentBrightness directly in the line below, since it is also called in the constructor.
Doesn't the tooltip (I meant to say deletion events before you call this? <LINK_0>
Maybe it would be better to just return if the window is not null?
Could we change the signature here to have the @Event annotation, to have the symmetry?
I would rename this to isSupplierSoftAssertions, to make it clear that we are traversing the stream to immediately returning the result.
Why not: java try { bundle.saveTempIndexFile(workDir); } catch (IOException e) { throw new IgniteCheckedException(e); }
Is there a particular reason why you are checking for a particular range instead of the number?
Any reason for the builder? The builder is not coming from previous lines.
We should reverse this.
Are you sure about this? It's not visible to the JVM? If so, shouldn't the value be Double?
You should be able to store owner of a local variable here since it is not directly used anywhere.
Is there a reason not use.asType().toString()?
The list returned by serviceDAO.findMyEntries() is already sorted.
This is a nitpick. Why use just lambda?.map(label -> value.getValue())
Catch?
I am unsure we need check here too. Could be a different way around A getAttribute, get and pass a check on the attributes.
rename to bundleSleep
Would be better to use assertThat(count). I believe on the fly you have already existing Assert in hamcrest matchers
@dmzaytsev let's call it bytes for clarity.
So this could be: return (fValue!= null)? super.toString() : super.toString();
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
Will need to be changed
Can be inlined in the test.
Please don't use final for local variables. It's not really needed, because they are basically assigned a value and not null.
Instead of re-formatting you could call toString() instead
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
Do you need this check here?
Should those hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode() implementation.
> I am not sure the event is really a required event. It just means that if there is no event, the event will be fired so it is not available. > The event is currently being used. Can you explain why you did need to check event is (and getEvent is not null) here? I think the user can send a MaxwellAbstractRowsEvent event along with the events queue so you don't have to check the event in the list.
you don't need to assign PrimaryKey here.
isAlive() seems like a bad sign. I don't think this is right.
should it be a try-with-resource (see other places), to close the connection pool pool when we want to use the AutoCloseable interface?
should we use the same object?
java return "Abort and restart the build the build action" +...
This can be simplified by avoiding the local variable autopacklimit variable.
externalize
I think these two lines should be synchronized. They are still around the critical values.
Why can't the consumer acquire a lock, let's keep the code unchanged, and avoid the memory leak?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Shouldn't this be copingStreamToReturn
No need to cache a list of ruleId, just return null.
After trying to maintain the code, I think need to be in a method that uses AbstractBaseKafkaInputOperator.
I don't know if this is about to be public, but it should be just public
return Status.BACKUP_FAILED.equals(status) || Status.RESTORE_FAILED.equals(status);
I would say "Key passed by key must be 32B".
It's not clear which exception is thrown here, but this one is actually the one you wanted.
Missing @Override
If an Iterator was found then arts are to do it -- then the loop could be to do it like this: for (ArtifactId art : applId) { JSONObject message = arts.get(i); if (c == null) { continue; } // use the iterator instead of the iterator.
This else if case is redundant.
use ShellIsAvailable
throws
include KeyFilter filter and KeyFilter to to make it clearer.
Currently, value is Integer and not int, so isn't it?
Use QualityGateWsSupport#getOrganization (QualityGateWsSupport is already used in this class, and it is not necessary to make the parent class "new ProjectQualityGate52" string
please remove the resource mapping from the resource.
Change to Integer.valueOf(int)
Why not switch to enum?
can we store "gaAccount" in a constant?
This fix should not be necessary.
Previous implementation was DoubleStream.of(elements); and Revert all above?
Arrays.asList can be used here
Why are you blocking here? this should be async throughout.
Mark as final
Can't we just set without compare?
suggestion "Namespace is longer than "+MAX_NAMESPACE_LEN+" characters");
remove
Maybe "bbmri_eric"" makes more sense.
This should be moved inside the try block. Otherwise we may be getting a NPE in the else branch.
return prevValue; can be simplified.
can we use similar logic here - define util for that?
Good point! I think the issue was that GerritGlobalModuleContext#this. With this change you are relying on this class and it handles all other types of the same Object but with different semantics. Here the equals() and getClass() methods were already deprecated, so this line could be removed.
suggestion timer = new isSuccess().append(new Digest(ozoneConfiguration.getDigest().toString()));
Is this really needed? It seems that this should be instanceof Incompatible
Why not just pass in VmAnalyzer to the constructor?
This whole lambda can be moved to just one line (same for "this" below)
This condition will always true in the first place (such as if at all).
Should we handle error here?
preconditions should be in the cleanup list
you should use compareTo() and equals()
no need to use a Date instance here. It's already a mutable value either.
you don't need to show that we are sure that we print this log is the case. I don't think that we should show that we are deleting the db time if that is true or false, and we should show that we are deleting the db time.
rename this to method
Unnecessary line
I'd try to use Builder pattern to a things things like Builder.withState(true).withChangeForState(false).withChangeForState(true).withChangeForState(false);
Collections.singletonList()
missing a space after,
I'm not sure this is the right exception here.. it's the best way to inform the user that the operation needs to be configured. I would rather inform the user about the operation to be "e" (e.g., "e")
To be consistent with elsewhere, can we do a quick checkNotNull(second, "val", "index"); in the case of the null?
The order of the arguments is reversed - it should be assertEquals("", result.size());
How about instead of having multiple lines for the eviction index?
CAggregatedMemoryContext.this.delegate = requireNonNull(delegate);
I was thinking about the way to write this instead: return "Lambda" + 1; It seems that the nested class is a bit redundant here, as the class is package-private and the protected modifier is a public method, not the annotation.
If you use a Report - Merge View cell you get is repeated here, and it will be displayed to the user.
Nit: maybe call this the constructor on the test cluster and just directly the string?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
this would be an NPE if trackers is not empty.
Could the doFill be a field?
While I understand your question, this would end up with a "Analyzing" the end-of-line string. Can you use a StringBuilder instead?
Shouldn't it be public?
please assert this
ServerSocket implements AutoClosable, so try (ServerSocket socket =...) {} might be stylistically better?
Hardcoded file, added to the constant
Maybe just use a single quotes here?
Could be simplified: return Objects.hash(version, version);
Looks like a copy/paste error here. Here and elsewhere. I would recommend to put this in a finally block to make it clear what it is. Here and elsewhere.
Is it necessary to convert this into a Path and just use StandardCharsets.UTF_8?
I think we should have a test that confirms the error message here.
nit: can you rename this to be testThorough?
One of the code from line 3.10, and ERO_WIDTH should be moved, and I believe we don't need the separate if/else block here
Is it worth to check for null here?
here you do not need to do this, just return null.
And here as well.
should be done in the exception
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
Again, the next line can be removed.
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
Why not use this?
Shouldn't this happen in the parent class?
Use encodings.
It seems like the depth property is not used anywhere.
It would be nice to only log the exception in case it happens one item.
missing @since FolderPermissionLevel is set to FolderPermissionLevel and can be removed (same for the other methods below)
can we avoid code duplication by making the code below?
Add this to the FlowFactory : public FlowFactory _TODO_B_ALL = checkNotNull(flowFactory);
[x] I think the same is the same as before, so the delay is less than 10x
Wrong default clock provider should use the system time zone to 0 (valid default clock provider)
Add another assert that the page range is > 100.
this should return an Optional<>, right?
Test name says 'MultipleAssignmentException' but the variable name is actually assigned to the value of this variable. I think this should be named 'MultipleAssignment' or 'testMultipleAssignment'.
Just return jobName to be null if default is null.
Why synchronized?
Why do you need to bind the Context?
suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
Why are we returning WARN for the finals?
Is this change due to a merge conflict with the next major version?
This is a lot of duplicated code. Why not make it a method that isFileTypeValid and use that instead?
This should return the reference, not the interface.
are we sure it is always a clone?
Should be done in a separate constructor.
I see the act of this.sessionFactory.get() and remove the Config variable in this class. Should probably be above the remove method.
rename to signature
Why not use messageResource.getRelatedMessageId()?
Shouldn't we do an.show() here? It's not a good practice to manually set the activity to null, and will leak the activity if it fails.
You're not testing the fact that the transaction events are actually returned in the transaction. I think it might be clearer what's going on if you modify this test to return a valid with the (null) charge.
Would be nice to have a test that verifies that configService.updateConfigs(configList, null, configList);. This would allow you to get rid of configService and configList
again, better to log the error
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this expression read the code string for this expression. [![rule](<LINK_1>](<LINK_2>
Not sure if it matters, but I think we should be consistent to use the default case.
We are not removing these two lines. I would prefer to just remove them.
@manuelplazaspalacio maybe we could take this from here a TODO and see if there's any chance that a callback is added here after the async queries is finished?
nit: can you flip this around and avoids the 'this' keyword?
Could you call forEach on the segment "after" before the iteration?
I would use Tree.Kind.CLASS here as well.
You can use spmMap.put(spId, host);
should this be the default value (null) instead of the default value?
why do we need here roundtrip?
Please don't change the operands.
Pattern.compile should be a static field, so the matches can be updated only once.
remove the new line
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
Please do not use the ValidCommand. Synchronize on this.
Makes a function like the other examples.
I think we could use an overloaded method here.
We could also check that providedNamespace is not null here. (Same for other similar cases)
same here: Why is this needed?
And in the same line of code.
Should we change this to a defaultBrowserLanguageTag (perhaps not set via a defaultBrowserLanguageTag)? Otherwise we don't have to worry about null/empty case.
Now that you have the query string, I think you can use the URIBuilder API.
should this be the location of the PARSED_CACHE?
Will the volume be set in the constructor from parameters?
mSessionApi.jpg2 is not too much specific.
This might also cause a NPE if subject is not in the tracker but in its meantime, can you check for this?
Seems like we should "div" not "first".
judgmentSearchResult would be better here. The original code already explains why it cannot be null.
Isn't this returning false?
Is this method needed?
Could this be also simplified to: java return getFileOperations(type) == null? DefaultFileOperations.INSTANCE : null;
Why "true".
Better use INSTANCE.getString("This operation is not implemented")
Why can't we have a simple method to check the account name and compare it with the name in the else?
Should this be doing something similar to writeToTopology().
This condition seems unnecessary
Make this final
If using a byte array on the buffer, it will be faster to read and write directly to the byte array. A ByteBuffer can be the length of the file and would be faster to read it.
rename to methodOfType
Do we need to release calls before every test method?
nit: can we just do return queryString.get(timestamp)
Should be: ObjectId id = (RevWalk) storeCommit(parseCommit(parseCommit(id), flags, out.toObjectId());
Throw the proper exception if something is not supported: - NullPointerException if frameID < 0 or if frameID > 255.
Same as above for otherNonCodedConceptUuid
This should be removed
Maybe throw the IllegalArgumentException and return the same ha and return the values instead of the IllegalArgument
Best to use the enum value here since it's not the default value
MemStore is used for tests, so we need to implement this function.
waitForVideoPlayerVisible returns false so you can put the code in waitForVideoPlayerVisible().
You don't need to call.getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
Just an observation to think about if we didn't want to do a Optional.ofNullable, we could just use a if here.
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
Why not just write this as column?
This is aCFG patch.
You can use TimeUnit.MILITY_getCachedsKey() method to avoid the duplication.
The performance of having the partition field in a static field is slightly different from null to an instance field, but it's called twice. I'd suggest that you use the same approach to do the map toString(key) method.
I am not sure this is correct. Does this make sense? If the file is not "BEARER"?
This should not be registered on an HC.
Does this need to be public?
Why do we set invincible when exiting stargates? We don't have to know who is in the sender, but if its "unincible" there I think these two methods have to go away.
I thought this was supposed to be return the optional?
You should use Objects.requireNonNull(this.by, ""), this.argument);
Please change to LOG.debug
In this case, the current implementation might fail: <LINK_0>
This should be a logger.error("message occurred while publishing downstream message {}", e.getMessage());
if it should be public
I like the strings being in a couple of places, but I prefer to have these strings as constants for the strings, I like so much as possible.
This check is not needed
Minor nitpick: we could use the new LexoNumericComparator here.
Can you use Collections.emptyMap() instead of this explicit variable?
nit: %d
This should be a list of reasons: - No use to loop through a list of classes so you can operate on it with a single list - use the FlatTree containing  attrn
lastUsed should be declared in the try block, right?
other.jettyMaxThreads is a Composite of null and other.jettyMaxThreads is null. I think it would be better to make a guard clause for the other.
Should this be a static method? It's not used anywhere.
... = null Directly assign result of collect() and add else clause to setAdvice. Again here no need to set the advice chain to setAdvice.
please reuse the constant
don't leave the println from the generated body
@eg04lt3r we've talked about this approach before in #123
Same as above, store this as a field so that its created only once?
1. Can be simplified to 2.collect(Collectors.toList())
Why not using iterator.forEach()?
It was fine above, but I'd recommend using the beanName method to make it clear that this is not called twice.
You should be using enum constants instead of hardcoded numbers.
Was this change intentional?
i think it'd be a good idea to require the "this." reference.
maybe use this.messageStr("rdbc-channel") here
o
Please use the same message as in the other constructor.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Don't think the external_id is a valid refund.
do we need a @NonNull here?
please put rickAtPositionShowsString 2 into a constant since it's used 3 times.
@jvelasques, s3 Server Error, s3ServerException is better to use IllegalArgumentException
Nit: this should be getAndSet(partitionKeyLock) to avoid potential NPE, since the map can be modified by the releaseLock field.
This doesn't seem to throw an exception. Why not throw an exception and move the Handler.parse method?
Is the message useful?
I don't think "getDoc" is a good name here. It's not a good idea to use "getDoc" or "getDoc".
You can use File.separator instead of hard-coding the path here.
Don't use LinkedList, use an ArrayList.
value can be null
Should this be done in the constructor, or is it too complicated?
Can you use the try-catch for the Exception to force callers to handle the exception?
Same as above, please use builder.variablesSet(builder, null) instead of the empty one.
Can we provide the annotation in the constructor to avoid the need for the annotation if it's not null?
This fails with an ArrayIndexOutOfBoundsException when trying to delete it.
nit: s/targetSubpartition/targetSubpartition
Can we use the getBytes() here?
Should we be using a builder here? Same across all other places in ConfigurationBuilder.
use File.separator instead of "/"
nit: I would prefer that we use a constant line to wait until Martin is done.
PullRequest is not part of the link. This will throw an exception.
You can use a Set here.
nit: does this need to be synchronized, or did you invoke the next few lines elsewhere?
Please make it!( percentage > 100) < 0 || percentage > 100) < 0
I think it should be Integer.valueOf(inParameter)
Will this be really more readable? java env.map( Environment.Variable("CRATE_HEAP_SIE", StandardCharsets.UTF_8.name()));
Should this equalsIgnoreCase() be changed to equals() as well?
@lmontrieux Was this change?
Worth including the return type of the boolean in this method?
typo?
this should be the default implementation.
IMO it's a good idea to have verifyNoStorageVariablesAvailableInStatus(user, "testName", "org.apache.commons.lang.StringUtils.defaultString(user, "email")
Should the left over agencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list
this should use the same setToSuspended utility method instead of found a boolean.
Is this an error condition or just timing? When will it happen?
this is obviously a syntax error.
I think this should be in the finally block, to avoid a potential NPE in the other tests.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
That is a good question. Do you want to read this from json? I think you should re-use your new JSONArray for this.
Why not use the getter in the toString()? We might want to keep that here.
Can we change it to be the default one?
Since here we'll be consistent, would it be nice to move this to the _loadSavedFilters_ and then use the default filter automatically.
I have a bit of curiosity, why we need this, IoUtils.shutdownAuthenticationMechanismFactory?
Was this necessary? If so, we should have a separate CsvSchema instance.
There is no need for this.
extract private method boolean waitForOperator(Operator operator, Duration timeout): try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; } and build assertions around this method
[minor] Just removeActionFromTv.class.getSimpleName?
You can use LoadingCount as 0 and LoadingCount.
>>(<LINK_0>
This synchronized block is not needed, we can just make it at the end.
I would change this to this.script = new Builder(this.driver, script, null); this.inject(script);
can this be extracted to another method?
You confused "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file
Need to remove codec from here too, right?
Maybe we can use isGroupAdmin(groupId) here since it is true when everything is null
I don't think that cast to FlagAffectedCommand is necessary. Edit: Scratch that, I didn't see that the writeable methods are already there.
This should be a Vertex API. The active widget may have a quick/over of a parent, so you can test that this is a model.
same here, not sure if we need to add the same logic in both places.
Since this is async it should not be called in the executor. Can this be shutdown by the container?
This should probably use notifyListenersList() instead of notifyListenersList
code style: This is to not use braces around single line blocks
The rest of the code was pretty straightforward. I would prefer to use a helper method to get the slice and change the original position (which I don't know for anything else).
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified flag, and he selects "yes" on this option?
minor: I don't think this does anything. Same with below.
It should be unique across maven repo. Please change it to org.openmrs-sdk-server/server/server/server/{serverVersion}:1.0.0-SNAPSHOT.
:+1: this is better as: private boolean input.getItem(int i) { if (item!= null) { return (item.toString() > 0) && (item.toString().equals(item.toString())) { return ((int) input).toString(); } return null; }
Change this to LogicalServerStateMBeanImpl.class.
Can we add the max(message, _callToActions) to the _callToActions so we are left to a consistent thing?
Please bring the braces back.
There is no need to mock shell anymore.
This one seems unused, is it?
Use TreeMap here instead of Collections.singleton
Shall we rename this to "completed" or "placeholder"?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
I think you could just use allOf(...). It will allow the collection to return true as the value of getItem(EnumSet.class) and not return anything. That would avoid the problem in all the places.
same question as above
this looks like it should have been explicitly set on the class class (when there is a reference to the formController)
looks like this can not use any method
.. should be "-web-0.2" and "web-type"
eg. "BasicHeaderApiTokenAuthenticator." can be moved back to the secondary index.
Can we list the languageCode to be of the languageCode? This list is used to construct a languageCode.
This is really a tad mock so I think we should just call close in tearDown and don't need to do anything.
It would be good to have tests util methods for this.
Should we use d.getDisplayName()? (applies to all blocks below)
This is the replacement for [this](<LINK_0> We might want to consider using [this](<LINK_1> or [this](<LINK_2>
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
You can drop the.size() == 0 check, as this is already done in the following if.
You should probably keep the following line as it was: if (forLog) { view.showOrHideNodeActions(false); }
I agree with this approach, but first element.setSize(Options.getInstance().playSoundFileName()); is called on a null object, would make sense. Is it?
unecessary new line.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
I think the idea of having values in mutable is that if there's an issue that can be behind concurrent writes. When I originally added this code, I believe the following operations are guaranteed to be performed through the concurrent collections in the final list. It seems that this operation is required to use reverse order of concurrent collections, whereas in some cases the concurrent writes will be required.
You need to use Arrays.asList.
nit: could we make RocksDbPersistentStorageConfig.builder() to be consistent with the other one?
Is this used anywhere?
Can we use the name here to match the actual data that says what it is?
Overdid: if (read!= null) return getChannelNameFromMessage(JsonNode.protected, 0);
CopyableElementView to a variable?
Can we do something similar to what is done for this: java private static final SamzaException SamzaException.of(KafkaCheckpointLogKey key) throws IOException {
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return true;
Pointless return
Could perhaps be: java if (first instanceof Include) { return Optional.empty(); } if (first instanceof Include) { return Optional.empty(); } return Optional.of((declaringClass); }
I'd rather use assertThrows here. Also, it's much better to use assertThrows here.
Should this be these these entries?
Minor nitpick: curly brackets are not needed
I don't think this is good. If you call it, you're not checking for null twice. But maybe you can use the second static method
I'm not sure exactly what is going on here.
Why not this?
I think there is a reason to keep the extractor as package-private: protected HibernateValidatorContext(ValueExtractor extractor) { this.owner =............; if ( extractor!= null) { return extractor.apply( extractor); } else { return extractor.apply( extractor); } public HibernateValidatorContext(ValueExtractor extractor) { return extractor.apply( extractor); }
originalKey could be replaced with originalKey.keySet(). Also, it would be better to use the new upsertMode. It can be fine and remove the initialization if you want.
Seems like there is a doReturn() that you can do here..?
firstNonNull() for this
This should also be: PowerMockito.spy(KubernetesClient.class);
should be RateLimit
use more descriptive variable names
log a warning or something instead of returning null
Nit: you can use StringBuilder, just do: int prefix = 0; if (mWriter!= null) { mWriter.write(keyValue.getValue()); }
Consider wrapping the { and } within if statement.
return DPIUtil.map(zoom::getImageSelector);
should this be null?
Could simplify to: if ( bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length <= 1
Given that we have a findFirst() method, we can make it a bit more functional with a method reference.
Shouldn't this null be added to the handler?
Rename the variable to DashboardView or something. It is more clear that the style is'refresh' or 'traversal'
Can we define a common function for this? That way we don't need to define the android_view_view_view as a context.
I think we can use primitive type here, right?
What about to use regex and use replaceAll?
If the reason for this change, I would throw a RuntimeException.
formatting
Check for null.
Is it worth creating an Builder from the ordinal?
remove this System.out
Looks better to use single line for the empty string, else do the input/input for the next block
This should be a check instead of a!= null check.
Maybe we could use a proper message here.
CompoundJdbcEventListener.class should be used in the end of the test to use a listener which is actually a duplicate of the code.
I think we can flip the panels and abstract into separate method to avoid doing this for every call.
if theitem class is a class, then the compilation will fail with NPE here, since the whole class is package and only then the parent class can be checked.
PUT and POST are not needed here
use: import static org.hamcrest.CoreMatchers.instanceOf;... assertNotNull(result); assertThat(resultObject.getClass(), instanceOf(ClassName.class));
Can be removed.
There's no need to check for bookedStatuses. I think a cast might do something different.
I think that getClientInfo() should return a non-null value, otherwise the user knows it was already created.
Use strings equals function instead.
Log stack trace?
Capitalize Thrift (or remove the word)
final
Unnecessary cast
why public? Are we planning to use it outside of this class?
If the value is null, don't we need to set the value to the default?
Again, I like the idea of breaking the test in the menuItem button, but I don't think we should add new methods.
why dont you use log.info() instead of log.info()?
Make it final
List#isEmpty()
this.
I think it would be better to use dialog.dismiss() instead of dialog.get().
Can't you use the same formatting for the dialog?
same here. If delegate to the fail() is required
ResistanceCalculator can be null
Use same as above, with abstract annotations to separate method.
Collections.emptyList()
it sounds like a good candidate to return null if it's null.
In such PR it has been required.
please add curly braces
I'd prefer to rename element to element.isValid().
Pease extract expressions into GoInspectionUtil.getExpressionList(). And call it twice in GoInspectionUtil.getExpressionResult
I have a feeling that this is easier to read. synchronized(this) { if (public.nanoTime()) { this.public = System.nanoTime(); } else { // normal
I don't know the reason to use getPolicy here, but if it is not AbstractKind kind of Policy, I think this method should be changed to return thePolicy enum.
Please verify the flow here
note that the best practice for test is now to not use public.
Lets use kernalContext.kernalContext()
Should we close this before the finally?
Can be replaced with this.canvas = new SpongeEmptyCanvas.get(this.canvas()).get();
This is also nitpicking: the if isRequiredToUploadAtTime(topicFilter) check is unnecessary.
this line is redundant.
This seems to be duplicated: public Stream<RecoveryDecorator> getRecoveryDecorator(Class<?> parentRecoveryDecorator) { return RecoveryDecorator.supports(returnType).orElseThrow(() -> new RecoveryDecorator(returnType, RecoveryDecorator.class)); }
You could use JavaSymbol.flags()?
Unnecessary log level?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
I'd like to see an example of the: inlineGetInstanceField class.inlineGetInstanceField() that we don't need to add an instanceof check.
I am wondering if it makes sense to use putIfAbsent semantics in the UI, but check we want to do this and other places, or not?
There is no need to use Locale.getDefault() since Locale.ROOT is actually a local variable.
super.toString() is redundant
Set toString()
Please implement toString() to provide debugging state information for debugging purposes.
if (maybeServiceConfig.isNullOrEmpty(defaultSecurity)) { return maybeServiceConfig(isSslConfiguration(defaultSecurity); } return defaultSecurityConfig;
Create your own session to make the property to be true.
I don't think the permission check is necessary, and the attribute may need to be corrected in this case too.
suggestion EMPTY_VALUE);
Works anyways but a bit weird to have it set in the constructor. I would just have a single if-else block to avoid the overhead of creating a list.
nit: Add a space after the cast.
Can this be simplified to return a boolean?
I think it would be better to use "command.getName()" here, to have the 'executeCommand' method.
we should log a warning here so that users who have wrong permissions on /.gitconfig by mistake have a chance to detect the problem
Consider Long.valueOf
I am not sure which permission /proc/sys/net/getRequiredPermission, but why not do it in the builder?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
here you should reset the finish parameter to make sure that the topic's actually started
Unless there's a reason for it, maybe just have this return the final keyword this way?
This will be more efficient.
getParentNames() can return null
Whitespace
Please use UncheckedRuntimeException here.
Can you make this error message more meaningful?
Which file is this split? Try to do it in one line?
Using checkForRemove_Deleted() here is unnecessary as it has already been called in the update code.
Don't we need a change here too?
Did you intend to use [new TagName(13,y,a,b)](<LINK_0>, which does the same?
Looks like this will fail for null columns. What's the purpose of this change?
For consistency, this should come from the Builder
Please remove whitespace around the "="
It's better to call getSQLState(code).toString() instead of this.
Use StringUtils.isNotEmpty instead
Streams here, you can use toArray(Collection reference)
I think you can use a lambda for the if-else operator.
Please change to Math.min(..., bMin, bMax, bMax, (Min, MaxMaxMaxMaxMax))
Is this really the same as for the service?
I'm not sure why this constructor does the right thing since it's called from several places.
should probably log the error, so we can ignore it.
I don't think we should have a different name for the mos.
you may want to use "this" for variable
Are we sure about the more general approach here? I mean, v |= v < v >> 16;v = v |= v < v >> 4;
declare throws please
I mean an UnsupportedOperationException is a better option. I mean something like this is actually deal with with NotImplementedException.
Maybe put this in a new method int  exhausted, just like the fact that the iterator is exhausted, and you have to keep a reference to the same object as the method above (which is not a good idea). The memory footprint should also not increase, due to memory alignment I think a short takes up the same space as an int anyway.
tried to add warn maybe? and not sure if we want the exception. maybe just the message?
same here, throws IndexNotFiltersException
CPCount is also used in CPCount. It would also be better to change the return type to CPCount.
I think this should be packages.transform(fields,...); or in the first line of the list rather than the recursive call.
should we add Null checks here?
Please add the following before the NotifierToStringBuilder
return activeSegment.get();
What does this line mean?
nit: you could use Objects.equals() here to avoid the null check since it's null: if (obj == null || obj instanceof ) { return false; }
@ivanarrizabalaga why is this catch needed?
Please use other methods in the project
floorValue is redundant. It should be floored.
The result of this is used for test result.
add some message here to explain why it failed.
Since we're using this multiple times, suggest to make a local variable.
getCodecA()!= null && getCodecA().startsWith("dts") could also be replaced with getCodecA().startsWith("dts")
can be inlined
should we use instance of the websocket does not exist as SSLSession?
Can this be null?
I like this, but I would prefer to set default value on the object instead (I realize that we're expecting it to be a pain for a test that should be able to set if an encounter is null or has some value like throwing if it fails).
I think this should reference OutputFileData.getName() rather than OutputFileData.DEFAULT.
This is a URL thing. I'd probably use a constant for the URL here to make it clear what it actually does.
Why we need the else? Could we just wrap the line sanitization?
remove this
Can a warn be enough? Since we are going to allow a system with a longer names of the variable aScores file, shouldn't we warn on a filter?
@yingsu00 Can this method be implemented as assertThat(result.contains("value"))?
If you accept an Optional<Path> you could use a method reference, which would simplify this code a bit: return Optional.of(project).map(path -> "sources-jar-jar", project.getBspPath().toString()).orElse(null);
I don't see this being tested. The " track" variable is set on the first line of the method, so let's remove the variable and the return value of hasTrackedStartup.
Could we simplify this logic as: if (string == null) { return ""; } else { return string.substring(0, maxMessageLength); }
I think it would be better to do a ((String) name).toUpperCase() here, and in the next if statement, returning null for the limit, and throwing a RuntimeException that doesn't seem really helpful.
Is it possible to add a new Monitor method that can be used here?
I believe that's a try-with-resources?
AddressUtil.read
Why is this check necessary?
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task));
Can you keep the original instruction?
Assert.fail() the job already results in the exception.
Can you move this to the model of the variable?
we can not change integer value of tokens. It will seriously damage compatibility. Please explain this change.
I'd say "The player " + " is not a valid id."
Can you please put this to a constant?
I think this can be done within the cache, the result for each event being unique for a storable should be just before the loop.
move this to a method reference in the entity class
UnclearBits(value) is not a valid value for the given given the spec is only checked in the constructor. This is more efficient, but it is not worth in fact.
Can we use the version check to see if the config already exists?
Where do you use this.successfullyParsed.set(successfullyParsed.items);?
Could you define a constant for "destinations"?
getInstance is called twice. Can you put this at the end of the method?
The same Arrays.stream() can be applied here as well.
should be e.g. logFirebaseEvent(event) here?
Why not ctx.executor() == currentExecutor?
I think re-uses the Assertion in these two variables to start with, since they never be updated in the same thread.
I think we should use the name of the uuid and not replace this with the name of the uuid
This is only valid for CPPBasics the code. It looks like it will create a new class (i.e. line 94), but still can't we just use isConstRight().
Cosmetic: It needs to be changed by the new name before the list.
Minor - Safer to use "something <operator> null" convention
suggestion return (System.getProperty("OPENNLP_DATA_DIR.class.getName()).equals("OPENNLP_DATA_DIR"));
please decrease log level to trace or better remove statement
Remove
This isn't an exception, so the name of the exception could be misleading.
> //NON-NLS-1
please use parameterized logging instead of string concatenation
Why do we have scheduling the sleep times within a loop?
Why use the new SSLSession here?
if this.public String getName() is the default, it may be a different value than the one below,.
H-m. Why don't call ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead?
I would use the wordings of the Index_TYPE_NAME, instead of the +
This still looks like a change in Travis, is it intentional?
Should also include context and suspend
Can be replaced by an interface with no arguments
See the Sanitizer.sanitizeForRichText method that takes in the sanitizeForRichText, and if you can remove the dependency from the Sanitizer one of them, then we can just do something like: java TextAnalyticsDescription label = new Text(Sanitizer.sanitizeForRichText(questionDescription);
You can use assertNull
Since we are throwing the errorMapper, we don't need to log it here.
Is this check necessary? If the command list is empty, a command may have failed.
Why don't you just pass a normal wrapper to the top one instead of breaking out the inner for loop? No longer need to define a separate method for kurability.
If customers send retention value that is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days. For cases where they deliberately send test metrics and then want to delete them from discovery after a week. The check we should have is, to cap the retention period to the max_retention
I think this should be else if to be consistent with the other methods.
Style-nit: Unnecessary parentheses?
I'd recommend adding an.size() here.
not sure if incrementCount is more reasonable. do we want to keep it for all the other connections with size 0?
IMO the new TaskTaskFactory().getPresenter() should be invoked after the task task.
Could use port 0?
Are you sure about this exception? I think it is better to keep this in mind, but Errorhandler instead of Exception
This should not be public
Can devfileFileLocation ever be null?
Empty catch blocks? :)
Shouldn't this be 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60
It seems me that this line is not needed?
This is not necessary.
cost.multiply(bigCount()).add(bytes(dest, dest.getValue()) would be more clear
This should be updated to use the parserContext.getReaderContext(). So, get the index for the provider.
This should be assertEquals(msg, e.getMessage());.
I would add a condition for coll!= null
What's the intention of catching an exception and throwing it again?
style nit: we don't use braces around single line blocks
add () check with this.
getSystemMemoryContextSupplier() seems used only once. Maybe as deprecate it first, but it seems like getSystemMemoryContextSupplier() is an expensive operation.
I don't see how this method is supposed to be used, I think it would be to have it run after the check.
Better to assert that dependentFields is not empty. E.g.: assertThat( dependentFields).containsOnly( dependentFields.size())
Shouldn't you refactor the error messages to be more detailed?
@Override is missing
Please move this line to a separate method.
Please check if you need to verify the command being null.
This should contain the address that is not a cached endpoint so that it can be used to return what is inside of this method.
log.warn
sysout?
featureAttributeName(<LINK_0>
negotiate?
We want to check if the index is human-readable, like this.
brackets
Can we move new FormulaShifter(int externSheetIndex, long sheetName, int numberOfRowsToMove, externSheetIndex, lastMovedRowIndex, RowMove ) and reuse them?
I see a lot of potential concurrency issues being handled here. Before, we used the timeout to await multiple seconds for the constructor. Now, when the timeout is reached, the test will fail. Do you know how much time it is handled?
Please use -1 as the default value when there are other constants in the JSON file.
Can we use!= null && componentInfo.applicationInfo!= null?
Could we just compare the two projection types with Evidence? This is unnecessary, and it would fail later on.
nit: this message is a bit confusing if the hostName is empty. Perhaps you can do something like LOG.debug("self-defined message", hostName, IP address);
clients.remove(client)
you do not need InternalRecord (or at least you can use a simple ets_event_object_type_name syntax for PLu_object_value_object_value_name)
The other constructor too use this(). Would you mind removing it and making it final?
suggestion bean.setSourceSet(new HashSet<>());
can the generated code be avoided without affecting the safety - please keep'max' at the beginning of the method and avoid the final copy if expected doesn't change.
The first argument should be enqueuedWrites
remove the try catch so it is set to null
can we have a single constructor that takes a SelectorFilter directly?
Should be a string resource
Probably better to check if this is the right one to put with this
This method returns an empty path, which is not a HistoryFilePath. Can you check it for some reason?
The way I understand the confirmation dialog is mandatory, is that user can pass 'action' as the entity to the backend, and status should be 'null' as the second parameter in the "Action" constructor.
If we keep cache manager we don't need to support cache manager we can use. I think what we want and to do is to split everything into two using a different constructor.
Also check if getSession() is null and remove the close() call.
I think we can have a single method for this CompletionStage
so do not resolve groups and no recursive as you going to search it anyway.
I think here you could just combine the two lines and use scrollAndClick(selected, pages, exportElement.get(0).getElement(), 0);
This method is going to escape the same URI of the query and should be called append(int) and not output on the individual classes. I recommend to not call it with some kind of hacky approach.
Why FAILED_ENV_event?
Can we keep this.DirPath == null?
Missing generics
The sync method (and the checkExists(all) can be moved to the end of the check and not return true if the transactorId == null.
Java doc mentioned: can be used to check check context
Consider using the username field instead of the hard-coded string
Is there a reason you are not using the annotation?
This should return an Optional.
I don't think you need the create span name here.
I think this can be reduced to a single line: return StringUtils.isNotBlank(gatewayAlias);
I think this part is redundant with the settings in setupModuleToCMAAdapter below, isn't it?
> getValue()
I'd use RefreshDurationListener<IPropertyListener> instead.
No need of this. Its marked as @NotNull.
I know this was a lot of code, but can you please explain why this method is needed? It was deprecated in the old code and it was just moved to the new method, but would the refactor the tests a bit easier to follow.
It's better to rewrote the lines by using **String.format()** method.
WDYT about changing the method name to one method (and change one to one method call)?
Missing trailing {
Maybe log this?
see the point for not using try-with-resources
Does this work? It seems like you are creating a new serializer every time.
MessageQueue.RegisterBankAccount_PushMessage
I think this part is redundant with the settings in setup code.
Why are we catching an exception and calling pause twice?
Why are we no longer using the bundle here?
Does this need to be synchronized? If the caller knows the reader, it should be ok, but it seems this method is not used.
Isn't there a peek operation on the getRoles method, and the logic that if you have Stream<Privileges>, then the stream should be Stream<Privileges>.
this should be called test_alter_table
Why is this done?
Also having util/logger/safe string, you can simplify this: case ConstantOperand.get(APPLICATION_SUITEException.class).get("Unable/util/lang/Exception/"): case WE: case "This class must be loaded (and you can't do that)
A possible variant of this is: shape.stream().filter(id -> id.equals(id)).findFirst().getDMNDiagramElement().getId())).filter(x -> x.isDmnElement()).findFirst().orElse(null);
Shouldn't this be: java return detectLanguageWithResponse(text);
I think we should clean up the toasts here instead of being able to add it to the log statement.
I'm not sure this is correct. reassignmentsInfo may be the same as reassignment, meaning that reassignments is not yet assigned during the query execution. It seems that in theory, the previously returned false in ReassignmentSetImpl#reassignmentsInfo is not very reassignment, so the cache is not assigned to a new instance.
Should this be private?
The following two method calls can be refactored into a method, because they are always the same for all the cases.
I would suggest to factor out this line into a method resolved in the super class, e.g. public void setIngressTimestamp(String newValue) { return getIngressTimestamp(defaultObject); } This way if we apply this change other tests, the implementation can still return null anyway, so I'd rather see return value at the end.
just FYI, this class is now immutable so you can drop the check for null-check on startsWith
This is better than to have a regex instead of with \t. See getPre(regex2, Pattern, pattern) for example.
nit: Could add a message to the exception.
Should watching only be called by the RTLog handler?
Any reason we may want to use AssertionsUtil.assertNotThrowNotNull on the non-existent text?
Updating repository from remote repository, not just new Save
"0"?
No eventLoopGroup is ever present.
It might be better to use hashtag.getHashtag() instead of toString()
This early return can be simplified to if (!url.contains("_format=json")) { return URL.toLowerCase(); }
Do we need to call d3Loads() here?
We don't need this condition. _this_ doesn't have returned a private static.
Don't delete this, instead make them final.
Why not use fixture?
The logic added here is a high only checking for the status of the WellFormedRepoId, dRepoId should be moved to the RepoId rather than on the all the way to iterate
you can merge the conditional on ctx.onReturn() before ctx.customizeInvocation()
Don't use basePath, use String.format("%s://%s", basePath, "ChronicleLogTail"
move the calls to here, and remove the exclusive brackets
As with the previous patch set, this could be done like this: java if (this.entityConstructor == null) { return null; } // As we know that we don't have a Constructor with the first parameter of method, we could just have the following: java if (this.entityConstructor == null) { return null; } // We can replace this by: getConstructor(entityClass);
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
Needs to be done with other fields.
rename to video
Could you use a lambda here? It would seem like java return new PhysicalIdTableBuilder().withCreateSqmMutationStrategy(() -> { return createCreateRate(() -> { return createCreateRate(getSessionFactory()); };
to be consistent with this method, you can check with matching name in a map above.
Should we inject the List<poller> and apply it in Spring Security? And can we get rid of this from Spring Security code?
remove local variable
Maybe more specific: java Option.some(1); option.transform(null);.some(1); option.transform(null);.we have to make a difference :wink:
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
Throw exception if user passes in null
This should probably be done in a more useful way of error handling. Just to make sure the user can see what the group cannot be patched.
I think this should be protected
This creates a new random provider every time, is it needed?
I like the idea of using a string constant here. I think, that might be a good idea.
This can be repelaced by a UserReportingSettingsHelper call.
no reason to explicitly set to null, its default behavior
Not sure whether this should be done in the constructor.
Why not just use an AtomicBoolean and compareAndSet
Can we assert on the result and isnamedBamFormat?
We are sure, but shouldn't this method be called the same way?
I would suggest adding something like "Failed to find PMMLConstants.PMMLConstants.clearPMMLConstants"
I'm not sure if it is worth doing this before, because if a Buffer buffer is created by the caller, then this will be unneeded.
Could you change this to return clusters.getClusters() == null?
It would be much clearer if lawJournalEntryCreator had a method like lawJournalEntryCreator. It could be used here and at the beginning of each class.
If this condition is false, we should fall through the KeyboardShortcutsService instead of re-creating it on the KeyboardShortcutsService. I guess the methods are intended to be called from the KeyboardShortcutsService so that it doesn't get run in the initialize method.
casting isn't necessary here, is it?
Maybe it should be response.substring(0, response.indexOf() -'')
I think this should be the first : Also, how about making sure that the Map is enough - if the type of Map is enough - then the type cast will be needed.
I think there are 2 approaches instead of just ignoring the File path, we can just use getPath instead. I know the conf already exists in the list, but the logic is not need to get the path anymore.
This is the only place where we need to get the value and then do equalsIgnoreCase on it.
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
note: This will collapse all tables to at least one table reference.
This should be synchronized
Should be maxVote, not %s.
Why is this needed? I don't think this should be calling FBL
this initialization can be removed since PRStatusStepDslContext is only used in equals and you just want to be able to use the non-null equals method.
Add call to super() then.
And, too, there should be: setBetween(command.getContext().getTimestamp(), beforeCall.secondsAgo(1);
This can now be deleted.
Should be this.title = title
I suggest to check this for == null here. It is not possible to keep any checks, but I think we should also check this for <LINK_0>
we can make this a static inline method
it is the only value of this method. The assertion is not necessary.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to a method called toOrganization which really should be static
Log messages like this is almost flaky
I don't think we need that for consistency: we should consider having a null check in the factory.
final
please assert the return value
Isn't this a magic number? also, does this mean that if a element is CLOSED, you will have to continue?
I don't think you need to start with the line anymore.
Shouldn't this return 'public'?
Wouldn't it make sense to use the constant for the keyShortener.fromKeyShortener. Right?
You don't need to check if the set is empty.
Is there a test for that?
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
Move this to the the non-static method.
Call base32.base32().decode(base32()); directly.
Rename to m_
remove the 'public' modifier
can you revert this?
now that we have to create new list, getReturnValue(getReturnValue()) should be called, so you could simply do: return runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters);
Was this the same as warn?
Remove the redundant assertion.
I think it is fine to remove this one. They appear to be used only when the database was used during development and it is not possible to distinguish between it and it is fine.
Hi @filfreire use a more elegant solution, thanks!
No need to use SequentialIdentifierGenerator.
Unnecessary call to super()
Instead of reset i would reset the counter after 0 (and clear the probe > 0) and call reset method in all other tests in this class.
I didn't see a point in changing the order for tags.stream() to.collect(Collectors.toList()), can you make sure the project is the guest user returned by getGroups().stream()? I was thinking that it would be better if the group could be made a bit more generic and used in other places
Perhaps possible to put some code that in the block after the if block?
Why static? We should make a copy of the internal instance, e.g. private static final String getBytes("UTF-8").
perhaps vds load blanacer
final
I would prefer if we can make this method synchronized
same here, removed test
Why is it needed? You are right, in which case the log was false, right?
code shouldn't be here. TVAElementType. )
why 40 as a limit?
I don't think this would be the right way to map them to the Objects.requireNonNull method, which is where you can call the non-null object.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSourceIfRequested(), and you will end up with a method called disposeLookupSourceIfRequested() in fact. I would call disposeLookupSourceIfRequested() and disposeLookupSource()
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
You can do this more simply with java @Override public void testValidateField(final FormField field) throws; try { FormField field = mock(fieldStateValidator.class); when(fieldState.isRequired()); when(fieldStateValidator.validate(fieldStateValidator.class)); } catch(IllegalStateException.class); throw new IllegalStateException(type); } } The reason I think that you are going to do this test is because you have a mock in this class: java @Test public void testValidateFieldUnexpectedWidget() throws Exception { try { super.validate(field); fail("IllegalStateException expected"); } catch (IllegalStateException e) { assertEquals(expected, actual); } }
maybe use a logger instead of System.out
Rename method to fluxDB
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "Removed [%s]", path)
Can we use Trampoline.set(f); here?
why catch all exceptions and not Exception?
Is there any reason why this is needed?
I think it is better to make this change as a separate patch, if you want to have a few seconds check, like timelock, which is the thread id currently being used.
Use Context.getExternalContext;
Parsing an additional timestamp is a little too strong to separate it. In this example it would be a little clearer to follow the functionality.
Might want to rename this to shutdownThreads()
Would be better to have the context be null here?
you can use mapToLong here and then sum()
Oh and a compaction button is kind of a chromeless hover window on Mac (with black background), while it is a standard window on other OSs. As the text is inside a normal layout ( chrome to test Locals environment variables are kind of a chromeless hover window on Mac). So the text will be a little unclear.
+ desc
this should be seekCommand(false)
Can we be more explicit (like 'OnEnclose') in order to eliminate possible false, if possible?
I'm not a big fan of this. Why are you using a map to the map?
Can be a private static class.
This method should be declared private
Again, we should check namespaceBuilder.append('a') namespaceBuilder.append('a') to make sure the namespace is removed.
I thought this was to be debug to prevent unwanted data from appearing in the log.
please remove the explicit modifier
Use Collections.emptyList() here instead of Arrays.asList()
I think we can remove this method since it is not used anywhere else.
spacnig
Can return an immutable list.
What about creating the simple Set in the run method and then using it to check the result. The same here.
Create a constant you can use below instead of this (I know what the value is in the log output is always the same but it doesn't really matter).
You could have a resolve method that does the resolve and resolve it before the get call.
isValid() instead of!= null?
should this be able to add a membership that matches the patient?
This should probably return an optional.
How is this expression different from "this"?
I think Provider<MarkerSet> would make this method private.
s/public//
@tristantarrant Is this something necessary? Shall we rename this function?
Could you put the Misc.free(backupWriterPool) in a local variable and use it here?
Consider adding a new CheckpointType(..) method to KafkaIndexTask. That would save a bunch of squash the same thing every time.
Maybe we should use the 2nd argument constructor
We need to log exception here.
This whole method appears to be outdated. Could you move the suggested refactoring to the inner class?
Add this to the delegate.
getH method should return 2 different chunks as you didn't have the same value for getHammingDistance() and getHammingDistance().
null and casts should not be needed
Should be on(String arrowPath)
Hm, I think we should still throw exception in such case?
Why not to keep the implementation more flexible?
Collections.emptyList();
Similarly
Why do you need the handler here?
This is not needed. Could you please remove the first else and just return the value of getAutomaticIdSpec(Pattern.compileId(hardwareId)) );
Perhaps we should extract this logic into a method so we can call it twice in the pipelineFactory
remove.
I do not think we need to cast to MapEntriesEntries in this context, but on the other hand, you can inject it on getMapOperationProvider() instead.
actually Yair reminded me that we do have the method isInternalExecution() that is true when command calls another, because it (should always) use runInternalExecution()
nit: assertNull(bootDiskVm2, "VM2")
throw exception
Should be super(factory, "public SpongeBreakableData.class");
[optional] Why can't you use for loop instead of foreach?
Please use StringUtil instead.
expected?
I think we should depend on the fact that this is an instance of String which is not an instance of String. Since it's the class you can use getClass().getSimpleName() to check the member of this class, I think we should go with the getClass().getSimpleName() to the class at the end to ensure the exception is thrown.
toString() is not required here
Can we use NullBinding here?
If there is no difference between period and duration. I think the only thing that you can use instead of TimeUnit.SECONDS.toMillis(reNodeCount)
Can you make this more specific?
click on element
You could use the bench instead, but that is not what you say main action is bcd.
Just thinking if we could use tc.getTypes().stream().anyMatch(Class::getName ) here?
probably want a continue-fast here too, to either throw an exception or log a message saying that the client can't send past the server, it will be easier to remember to call the other method when a request is being sent to the client.
I'm not sure how this particular case is handled. The infinite loop would be better.
Return the object once is the same. We can use the structure of the new method: java return partitions.stream().filter(partition -> partition.getPartitionSet()!= null).collect(Collectors.toSet());
return getDescription()
final
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Can be package local
Why not @ScalarImplementation?
I think this line is unnecessary.
can we use comparison the other way around?
The while loop should be inside synchronized as well.
The same for every method
Object = myfile.findFile(virtualFile);
you don't want to keep this synchronized, it's not safe to keep a lock on the whole method
Can you have an @After method that unbinds this connection. This is more reliable.
I think this extra line is unnecessary.
Don't use morrow.
can you pass parameters.getGracefully() to the constructor as well?
I'm not quite sure about usage of find() here. If we are searching for the entire string, I would recommend using matches() instead. I don't see any test case which would justify using finding for subsequences rather than on everything.
nit: Looks like it's never used?
nit: maybe replace the cast with IFUE
I am wondering if it would make sense to use return literalTypes.values() here
Should we include typeAlternatives or something here, right?
Map<String, () ->.map(InstanceProperties::getName).orElse(true); am not needed
You should use the standard way of doing this, and you could use the @Rule ExpectedException rule
If these are Strings, this will be redundant with the next call to Objects.equals.
@ptirador why you need this check?
use Long.valueOf() instead of new Long() - always for performance reasons
Can you reduce this to the minimum?
Unfortunately this method isn't named a sort of Charge
The data source is closed in a finally block
Use isEmpty instead?
I know this is not test but it seems the test is wrong. The test is not asserting that the SslProtocolProperty is the correct one. I would remove the assertion.
Why can't you just call cr.toString() and then remove the,?
A flip!= null isORIENTATION_TRANSPOSF.
could we define a final variable that is initialized with the size of the API?
Why are you assigning 0 to a variable and then you assign to it in the next line?
what about testing here?
This should be public.
you should wrap the try-with-resources in a finally block
Same here, move this variable to the next line
Please, do not use Java 7 for such methods. Use <LINK_0>
style: we don't use braces around single line blocks
suggestion: new ForwardingGridDialect( gridDialect.gridDialect.getGridDialect( gridDialect );
It doesn't clear why we are deleting it. It doesn't matter that. Normally I would only clear everything. It's needed to clear the skipped records that this method doesn't.
not sure sure there is a difference between a list name and a Nullable Long.
> scope + start
Can you make this a synchronized method?
you could use method reference here: public static isAccessible(final HandleRenamedFile file) { return fileRenamedFiles; }
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
I would use streams here
I am not sure if negation is a slow operation and don't do anything with it.
Name it block? Three more characters won't hurt. :older_
I know that there is issue with {} class. I'm going to add this as deprecated {edit} in the future. This class is just a reference to the interface.
if you call the vmBase.getId() instead of '==' please suggest replacing the conditions with: VmDeviceDao.getVmDeviceByVmId(spice);
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I think the variable should be initialized at the end,, to be readonly a local variable of Kinds.
activity.finish() can return null
Did you look at this? <LINK_0>
Looks like too many element names. Impl could be a component, since that's the class name.
Mapper should be created in constructor
For consistency, change variable name to something more meaningful.
Might be better to make this protected instead of public
This is a bit confusing. Please use configRestartabilityAllowValue with configRestartabilityAllowValue, which requires a different config type to be updated in the same way.
Access static fields directly, e.g. AbstractUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowHandler. I think this should be prefer: java.io.concurrent.AbstractUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowActivity. I think this should be prefer: java.io.concurrent.AbstractUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowActivity. I cannot grasp the actual cache to be of the actual workflows.
final
Pager builder can be replaced by Pager.single().
You can have multiple nested loops in one line for readability by extracting it into a method like waitForJobContainsInFile or similar.
Can we use the name "cluster" instead of "cluster" since it is the cluster name.
typically there is a [lambda](<LINK_0>,%20java.lang.String,%20java.lang.Object))
It looks like we should have a create method to set the log. I think this should have one, because it is the default for'setServeReadTips'.
If this is not a String, instead use instanceof.
Please use <LINK_0> Also it's more readable to include both in the image.
This is an unrelated change I'm wondering if bundles.getSymbolicName() can be null, and if this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
Not sure if this will have to be done in sync with the async framework. If it is possible then both poll and pollOperation are called and then pollOperation will not get the same result. Thread.currentThread().interrupt(); will not be called.
Consider to simplify this method to: return obj.get(name);
253, why moving this line?
This if-else block is redundand.
Should probably use a constant for this.
I think this code should be: java /** * Use TeraMath.run(float delta) instead of this. */ public void updateValue(float delta) { double newValue = new double(); }
I think the gson should be created before the constructor.
I think this log is too long. Can you split the code so it it works as if (isPredefined) { LOGGER.error(event); } else if (pvcEnabled) { LOG.error( event -> LOG.error( event.getWorkspace().getId(), ex); }
What is this log statement for, exactly? Seems like a trace?
I think it should be pass in the constructor of _chunkingKeys.
There's a lot of "SearchDto{" and "searchResultDbId=" that can be used.
Can we just check that the customParams is not null?
I think this can be made "ext" and "openFile" strings. The user may have to explicitly add the java.lang.String, but that might be easier to do debugging with the compiler.
While you're at it, fix the log message to: suggestion setTicketEnabled(logger);
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Should we use UncheckedIOException here?
Is it worth asserting that field isn't null?
Why do we use random chars here?
rename to implementInterfacesContext
could you remove the getter, the setter should be one line above if parsedSources is not null (same for below)
We probably need that?
shouldn't this be polling?
This exception is not caught by another thread. Polling every single Mutation model is a bit too heavy for this class. I would keep it as it was.
Could you rename getBaseResponse to statusFlow
Avoid the use of _this_ instead. Normal implementations are preferred over java. applyTo() when attaching to a control since it is easy to forget that this is a simple return value. Change this to: GridDataFactory.BEGINNING, SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).
Maybe we can move this code into setup and reuse it in setup?
Does it make sense to have the MessageValues as a dependency?
For the settings like before, may be important in the write result here.
...
Please keep this method public
This and line 59 can be a global variable to clean up tests a bit
@dmzaytsev let's move this into the try and do something like baos.size() or something like that
As requested, I'd use the new empty string constant and refer to the current field for examples instead of reading the full field.
Please revert this change.
I wonder if this is equivalent to: if (address == null ||!address.equals(this.address)) { messageChanged = address; } else { messageChanged = address; }
Should make this private and have a constant for thePostgresToStart call?
Could return here, I think.
Why do you need this change?
I don't think this might be the right approach. I'd keep this method synchronized.
this is a bit of an odd pattern, but in the other CLI this is a config map, not the string.
return the list.
this is not the same as the previous constructor of CassandraKeyValueServiceConfigManager.createSimpleManager(). It will be the PR, but I would just go with a new CassandraKeyValueServiceImpl in the test itself.
better to use protected
Would be useful to have a meaningful name for this column in the database, instead of a hardcoded string?
These asserts are not really needed.
should be done with constant
nit: we are doing this only for _kafkaProducer, and what it did with the previous method. Maybe we can reuse the variable in _kafkaProducer final?
Should the data that was in the repositoryIsRequired() method, or something like that?
I would have added a separate method for this, but just call the method directly when the errorId is already a String.
I think we should write.subscribeOn(Schedulers.io()).observeOn(String.format("Maximum upload size exceeded ConflictException", e);
ParameterSendTime has to be a constant for this.
Please keep the style consistent - use the form given the rest of the test
Could you rename this, to statusFlow
I think we should keep this method private.
I don't know this code is affected by this change.
This code can be simplified to: java final String reviewer = Gerrit.isEmpty(); if (reviewer.isEmpty()) { Gerrit.getUserAccountInfo().name(); String reviewer = Gerrit.getUserAccountInfo().name(); if (reviewer.isEmpty()) { boolean reviewer = Gerrit.getUserAccountInfo().name(); if (reviewer.isEmpty()) { addReviewer.set(reviewer, null); }
I don't think this will work for the cols. Could you use visitSize()?
rPrec
It's more readable when part of deserializeValue call is replaced with method call.
@dilini is the order of fields in this class?
Convention is to use mannually with hamcrest.
I think we should use the existing registries API before returning the event
Wrong JSR number in validation provider.
Also requireNonNull that does not contain null
Why not private static final boolean checkIfType(IDataChartDescriptor<?,?> desc) { final Descriptor INSTANCE = DescriptorFactory.createChartDescriptor(configuration, DescriptorTypeVisitor.class); final Descriptor Descriptor<T> visitor = DescriptorFactory.createChartDescriptor(visitorType, visitor); if (isIfTypeVisitor()) { return true; }
Is it needed to return the list of users?
My guess is that Java 8 has thenComparing() method, so there is no need to check for the state condition here.
This message does not seem right?
Wondering if this should be an expensive operation. If the key is not an immutable, the hash code could be cached. I'm not sure if this is guaranteed, but it might be faster to do the comparison with putIfAbsent.
should be the default case
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
s/tmp/name/
is this the only reason that you add the trace?
Should this not put the clientAwakeStatus attribute in the same way? It looks like the clientStatusList will always be not containsKey() and not get().
values.isEmpty()
Why we need to extract a method here?
I don't think we should modify the message a bit, it is better to just print the message and the error message.
Could use this::updateNextScheduleTime() here to avoid the refresh() method call.
same logging here as in perform next operation
My suggestion is to use a boolean primitive instead of the'monitoring_', which is a much more efficient way to check.
Could you replace this with java StringBuilder builder = new StringBuilder(); Files.append(COPEPlugin.getLocalStorage()); //NON-NLS-1 //NON-NLS-1
Can we have this signature be private?
We should be able to use the getStoragePath method here.
Should be logged before this call
what do you think about changing this to checkLedgerHandle.this?
Should we use setProperty(key, band, band) here?
do we need the StandbyMode as well?
Are you sure that selectionToSelect will be null?
Why don't you just compare the values? I think that makes it more sense to just compare the values.
technically more efficient :) for (int i = 0; i < cpuId; i++) { } return cpuId;
can we add isError = true to else statement here?
database shouldn't be closed.
Could you please extract some of this code into a method, such as: public static String text(final String text) { if (text!= null) { return text.text; } // use "text" }
Can you log the exception, please.
To make the client-side, we wouldn't need this try-catch-fail-if-else.
Can use Map.of()
Can simplify this method. I think it is a matter of preference?
@lautarobock Here too, let's declare throws Exception.
Set defaultCustomizations
I am not sure why we need to use brackets here, just in case at all.
Missing {}
I know this is just a legacy code, but I'd prefer if we use the public interfaces for both the declarations, like in AbstractClientMessageTracker.
Should this be in the else branch?
At this point you're actually calling the backend here.
You can use the switch statement here
You are missing the null-check after the if
Let's fall back to the constructor.
toString()?
We _could_ replace the toLowerCase with a char.
Can you please put this 2 lines above into a single method?
Better to use Boolean.valueOf() to keep null.
I'd suggest to return a Map as well, not an ArrayList.
Same as above, we should use the null check and make sure that >1 call is unnecessary
we should probably log the error instead of just printing the stacktrace
please verify that the disk is not attached to the image.
keep both URLs in the same string, let's put them in the constants
Can you put this in a constant so we can test both scenarios?
Looks like there is no need to have an empty set from the given parameters.
You can use ipAddress.toStringUtf8()
Something like this: lookupSourceProviderFuture.isDone() && lookupSourceProviderFuture.isDone() && lookupSourceProviderFuture.isDone(), I think you should check for spillInProgress.isDone() == spillInProgress.isDone()
s/foo/bar/
I don't see why we can't set the exception to true in this case.
I think this is a good idea! I agree that it doesn't work as expected.
I think a good reason to switch to CandlepinQueryDTO instead of a List? We can use ofNullable() for all of the dao calls.
wpLoginLogout_USER_USERNAME_ID
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Should we consider using a ConfigurationKeys.logger.isInfoEnabled() instead?
Please use this: <LINK_0>
Why do we need the getClassProperty here?
The synchronized block here is unnecessary, the handler will never be called when the handler is not created, instead is just to create a handler that does the same thing.
why do you use this.guid?
please use assertFalse
We should log this
Do you think it's worthwhile to break this up a bit?
Can we make 1000 a constant, and maybe make it configurable via a system property? Similar to what we did with the pollInterval: <LINK_0>
I think there's the risk of making findbugs happy
remove this and use the actual logger instead.
If you're just doing this, then I'd prefer 1. I was created and mapped to the specific implementation. 2. If any of them are not equal to the default case of the switch case, then get()-if-else can be used here.
This method is a same as the original on the HostAndData(VNC_CLIENT_MODE)
Why is this returning a new set?
can we only consider the values for all buffer.
Is it good to put this in the map? Seems like it should be before the map creation.
Is there a reason to get an instance of the listeners twice?
Do you think we need sync control on all the map operations here?
please use brackets java if (m_objects[m_objects] < m_objects[m_objects[m_args]
Something is wrong here. This class has multiple scope of the same service name. You need to ignore list as the class name or something.
I don't think you need to check here whether the project is valid or not.
I think that you want to check that the wrapper name is correct now.
Unnecessary whitespace.
Could lastCheckBox.equals(lastCheckBox.getText()) check if lastCheckBox is null?
Similarly here, exec. should not be necessary.
Use the same style as the other ones.
This is all the setter on queryHeader, should we make it private?
Please use.submit() instead.
The tests in this class are with the same package but the tests still pass. Would you mind removing this line?
is always false?
Can you please use Guava's [Joiner](<LINK_0>.
INTENT_TO_ADD. And here, remove the first extra line
@vilchik-elena what if we reach this condition?
Do you have the akvo java formatting profile setup? Usually it would auto format variable names to start with lowercase...
Can you please move the applicationHome property to ApplicationHome so it is used in other places?
Formatting here?
Again, use IOUtils.
This line can be removed
suggestion ess.getLogger().log(Level.INFO, "errorCallingCommand %s", throwable);
Also include the row.
We should make this method private, could you write a method in the doc generatedDocFormCommand that does this for you?
Is there a reason you're creating this each time?
I am thinking about doing this in the code and getting rid of this block, which doesn't seem right. We should probably have a cache injected Lock<String, Object> and then override that internally.
you can use Arrays.asList
Should be.getRegistry().getText() (or.isEmpty()) here
This probably should be a try-with-resources, returning null will cause the server to fail. If there's a pointless response-requirement somewhere, the user will have access to the report_error (when currently no server is sent to the server).
no need to check for null again...
I guess we might want to keep this part of the code, i.e., the spinner policy is only about changes when the camera is attached to the *show* of the cameras
This null check isn't necessary. The super method already checks if the label is null.
You can replace this with checksum = getChecksumType(checksumName); and then use checksum instead of checksum.get(HConstants.CHECKSUM_TYPE_NAME)
@pynicolas Can we avoid code duplication?
Consider using == instead of.equals.
Can we use the interface? Maybe even have a method that returns the Visualization.Factory. As it is used in getVisualizationInternal as well.
nit: I normally use a Constant style nit on the same line as the getString() nui.
Would probably be good to have this property on the Kafka class not on the env vars... as well?
Can this be better java this.lossVariables = this.lossVariables;
Consider throwing an exception instead, for example "public void emitE e;"
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in branding.properties to point into the icon. thanks.
Move this to the previous line
url should be part of the URL
is this line necessary?
Out of curiosity, what would res mean to be res? Is it possible to define an empty list and the type of CompositeT?
Can we do this as a POST request with a non-url parameter?
Why is the extra "this" needed?
It seems that we should break out of the loop, after the first check, and then execute the status code.
It would be good to have some kind of utility class for encoding set to use Misc.checkNotNull(outputTypes, ProduceWindowResults)
drop the toString - it would be easier for people to read & understand the entire code if you were to use something like: return mIsValid + mIsValid + mIsValid + mIsValid + "0.0.0.position");
package private?
Can this be just Arrays.setAll()?
I wonder if it's worthwhile to create a secondary class with init method with parameters that returns the session and get the name from the session.
Why is this necessary?
The result of the call is 'accept-spans' in the failure message. Possibly something like "accept-spans"?
I think you should combine these two lines: logger.warn( logger.warn, ex);
Check not null? kBaseDataAccessor.get(helixNodeStoreConfig.rootPath) works instead of creating an ImmutableList.
flying flag not set to true
should be refactored to call unattachServoListener(this); here (and in the other places)
this whole method could be a oneLiner: return find(...)!= null
There is no need to extract this SocketConfig to a local variable. From code readability, it is not hard to understand what is it is.
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Use Integer.MAX_VALUE
I don't think this should be public, but can we have the final value directly in the samples?
Using == for object comparison? :)
The same is here for that include("value") and Map result
What is the benefit of returning empty values over empty strings instead of null?
This check should be done in the caller. That way, any possible failure would be handled and logging a warning.
please replace with assertEquals - it's more readable
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
Please rebase the code style.
I would just delete this since the global "exit" call isn't doing anything, and it seems we'll skip it here.
Yes, should probably use Option.Some_list() instead.
Shouldn't the first exception be the cause of the test failures?
This is the same as premature optimization. Use the constant MASTER_KEY instead of this constant.
This has any performance impact as you're accessing the same connection twice. Try not to use the same connection as the old one, or for this one as well.
.buildResult().hasNext()
Should we also check for null as well?
This name and the class need to be updated.
Too long. Let's replace this line with cfg.setClientMode(gridName);
public
nit: we don't need this, and the function calls are easy to read
We can extract a private method delete(String s) and use this method in a single catch block
Consider moving this line to line 118
so this will never be true? I think it's ok to have 5 minutes since the default time is Caffeine set by the cache.
same here, better not have it in one line
Can we use createDefault feed() here?
Same here, ByteBuffer buffer should be used rather than ByteBuffer.
Why the extra trim()?
UnsupportedOperationException seems reasonable here.
I think it's more clear to have { } around the body of the function body instead of calling OptimizeStatement.map(Arrays::stream)
this can be optimized to return the value of getMessageContentBuilder.add(messageType);
Same here. If you are not comparing equals on the other object you can get an NPE.
Can you elaborate why we need this line? It's not exactly what it's worth.
The check of instanceof checks is not needed anymore.
Remove?
Could we have a removeAll() method on SelectionService interface here?
Why not to use the getText method instead?
Have we checked this in AtsClientService.get().createChangeSets()? Since getArtifact() returns null, the format may be unexpected.
Shall we just use a constant instead of "submit-properties" it will be more robust to have a constant for the URL in this PR.
@whikrishabh-997 I'd also use the constants for the numbers, in order to be consistent.
Use faster methods, should not use data processors when possible.
Can you add an error message for the success code?
For the tests it's easy to assert on the batch size. That's what I expect it to be.
Is this method really needed?
If you're going to loop over the this.. then you can drop the this.name = name;
Even though it's better to merge these two conditions into one.
I noticed this is being done in the master, but is this needed?
You know what ISegment you are doing here, but you shouldn't have to block and make sure the trace is a set of the current type, if it is not a trace you can assume it is.
since this persist is triggered by the maxRows config, would it make sense to persist the max row count based on the max row count.
Could you explain what this method does?
This may cause NPE, in Eclipse and while you're here, giving a name that results in this method. Therefore why not do: java setIgnoredPlayer(ignored, user);
1000000000 is no need to put private
getCrepoKey() returns a new field, so it can't be computed once and cause performance. We don't need to make a copy of the data.
The namespace should have a constant value, right?
I think we should have an assert checking that the parameter is used for checking that it's not null before doing the compareAndSetMaxLong method.
Since this is the same in other place, please put it into a local variable
They probably be easier to reason about if we use the shift mentioned earlier as part of this PR. My preference is that intellij inspections are easy to run this way less than it seems: - result - deletion are easy to forget the guava tests - They don't use real time. Hardcoding them here is more of a convention not to improve. - They are used in the tests not in the Elytron testsuite, but they might be easier to reason about since they don't use the specific cars (which of them seem).
Can you make the method private?
Similar
I don't like this, maybe ConfigurableEnvironment?
Remove the public modifier
Use parent
I think it would be better to return sourceProcessingDetails here instead of returning the Set<SourceProcessingDetails>.
Is this helpful to have a test?
Import?
- Remove the unused method - there is no need for this - same below.
This is redundant.
Does this need to be in every callback? (i.e. with level 4/x)
Why equals?
Remove final.
explicit real ref?
This is wrong, should it be SessionContext's session's execution to stop?
Please use the context from the Command's class.
you can remove this.
Please implement equals and hashcode methods for debugging purposes.
Is there a case where this cannot be null?
You can write this as return GoalUtils.getGoal(BudgetGoal.class);
We should not be computing this each time.
Why not just call the ADVENTURE here? That way you can save a lot of repeated code.
This doesn't need to be "restart." as the handler is used for the restart screen, only read/write services.
Don't swallow this
Please use the same message as in BackendAuditLogByIdParameters.
it's better to use the trait set instead of assert traitSet.
I think we don't need the schema registry here. The underlying schema registry never returns null (it would return schema registry's cache injected via the builder).
@pecko let's use the same name here also: showRoomCapacity(driver).getAttribute("value");
Please remove this.
Can be use private to not add newTemplate
should it return null if queryStr is null?
Should we extract this logic to a private method that takes a boolean as parameter?
I don't think this is correct. The code will need to be: public boolean isFreeze() { return isFreeze; }
I know this was just moved code, but I'm wondering if we shouldn't also be calling activityAnalytics.setDryRun(true) here. The same check is used as if we'd have left another app, right?
negative logic
Should we be able to put this line into the getTopLevelLinks() call?
Shouldn't we use the old constructor and remove the deprecated object?
Cosmetic: Braces on new lines, please.
I'm not sure how all extensions are setting, but fetch all extensions via toString() instead of the string.
Is there any reason to use a separate public method for all actions?
There is an unnecessary reference to the metricFetcher in the constructor: java TaskManagerDetails metricFetcher = new TestingResourceManagerGateway(metricFetcher.DEFAULT, TaskManagerDetailsHandler.class);.create()..
getInstances is deprecated in a future version. Should this be public?
Why not use the Collections.synchronizedList(new ArrayList<II>());?
null -> size
Maybe for the exceptions we could add yarnClient.getApplicationReport().getFinalApplicationStatus()!= null check on the class.
Do we need the String.valueOf() here?
Do we need a test for this?
What is the purpose of this change?
Why this check?
Likewise..
Maybe.map(Map::toString)
can you make this a bit smarter too, and move the handling within the halt() method here?
If you"ll use generics you won't need this cast.
We should probably use the utility instead of in the abstract class.
Is this reachable? Seems like in your test mode, it is not an issue.
I don't think we should return true here. If the connection fails, we should return false and throw some exception, we will have the connection failed.
Can we add the DWServiceId table in the code?
This logic is different. observers contains entities other than players.
This seems to just an override, but can we put the boolean into the next line?
Why do we need this. here?
The permit will set these to the maximum capacity, which is wrong. Otherwise set to smaller memory.
Instead of using the context class loader, use the class loader of the first aggregate factory provided.
use equals() instead of ==
Why do we need it here?
log?
I'd rather return false here.
How about changing to a constant such as a timeout?
We can simplify this common to java /** * assertFalse(viewConnector.getBounds()); * <LINK_0> */ public static <T> List<Page<A> supplier(PageConnector<A, B> supplier) { return map.getDefinition(); }
I think we should change this to say "Arena block was flush memtable.". The message should be a bit more accurate, since the RocksDB will flush twice.
I think you want to log something if you want to know what table was deleted.
Can we use logger here instead of e.printStackTrace?
The method is never used.
Can be final
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Why depend on DiscoveryServices and not require extended services to register specifically under that interface?
Why are you checking the order type here?
Why not use assertThat?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
I think we could use the existing Diamond Operator here m: <LINK_0>
I think you can directly return the value of the conditions.
More descriptive error message please
Does this also work right? If so, you can just use if (s!= null &&!block.equals(true)).
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
use MapperFactory.createMapper() instead.
Just a nitpicking here: You could use this.protocol = () to make it clear that it's only the default value.
@kavinkumarks Thanks for your contribution! Instead, let's better use String.format and avoid string concat
This might cause problems if the underlying map of the LocalDateString used in advance, but it is not.
Seems like you can do app.getManagementContext().create(...) instead of its own Shell.
replace the if with checkIndex(toIndex)
I would use BitBuffer.EMPTY_BITBUFFER here, given that the size is the default, but for the sake of this symmetry.
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
{}
should we move the CCEs to a method called "sitDir" so it becomes "foo" and the test fails on Windows?
Formatting
Maybe Menu.NONE is clearer?
I think it would be simpler to just return the session state, and avoid that many times there are no active events (they have to know they're written at the time).
I wonder if it is better to pass the admin label here in getSystemAdmins()?
can we return null here?
I think this should be call on onData.
this is the same as service.getName().startsWith("eap"))
Do we need to have this on the next line? I think this line may not be necessary.
Please add an error message: "The value of the view no longer be null"
Could we flip the order of the two variables here?
I think we can move the declaration of the map outside the try block (by making it a separate method).
I think you can change this package scope.
Is this the case?
you are no longer grabbing the page from the test here.
Should be a unmodifiableList as you need to make sure it doesn't return anything.
:ant: I am sure this should be in a finally block.
This is the right thing to do, but makes it hard to follow.
This operator should be changed from a bitwise OR to a logical OR.
Is it really necessary to make this empty?
I'm not sure I would like to use the constructor of DefaultRemoteQueryEngine here. Callers should already have an empty collection of these methods, but they should not be initialized when the tests are executed.
Do we need this? All it does is assert that the message is equal
@tarun0 why don't you use <LINK_0>
No need to check for the if condition here. If you have the request it is empty, the if block here is not that much else and you have to do an remove below.
Wouldn't this be a good idea to create a constant for the number of unique values?
I wonder if it should be Publication NotRunning() because it catches fatal errors, and it's not fatal.
Is this the fix we need to do in the loop? I know the actual logic is a bit different from the one we have, but why it's not while?
Looks like this just declares a variable that's not used?
Why not use assertNull and assertNotNull?
Can we use _ instead of _?
could be removed as well.
Seems like a good idea to make it package private.
This should say "slaves"
Change to Map<Integer, Integer>
I think it would be better to throw an exception here.
Same as above, remove
Seems like this call can be removed.
toString() is not needed
I would prefer if you could use a method reference here: if(subscription!= null) { Subscription subs.executeBlockingSphereClient(subscription) }
For me, you only add the attribute to the superclass in this class after the test has finished, but that is why I assume it's the one you added above?
loadTemplateFromMap method is the same as above.
I'd prefer to not expose and prevent CompletionStages. If we don't have any behavior we could make create and stop using only one of them.
New PR looks good now.
clean up message
No need for the surrounding brackets (no break)
I don't think debug is enough here.
The count(*) should be > 1 since it seems to be the same as > 1 but it's the count(*).
Please remove System.out
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
Can be replaced with CheckForNull
unneeded check
seems like we can have a class for this.
mPublishedSequenceNumber == 0
Is this correct? AIUI the only thing that you're trying to use here is the loop. But I don't see any reason to keep the same behavior for multiple test methods.
can be simplified as:.map(Object::toString)
You can change the scope of this file to filters.add(filterId).
shouldIgnoreCase be null.
Should we be parsing a valid value here?
Maybe use message "Config job.name is missing"?
Is this really needed? If not, perhaps we should use a State class to auto generate debug state?
this should be moved to the getService method
assertFalse(...);
Why does the default constructor return null? I'm afraid the red flag is false here.
This log message seems unnecessary, we can call onShutdown()
should be key equals to hashcode unless key is not allowed
You could just do nothing if the endpoint isActive or true.
needs to be explicit
Are you sure about that? I think we should be doing the tenant check here. If not, rename it to checkUser and make sure that you are setting a permission or permissions, and then rename the retrieveUser method to removeUser.
mIsValid field is redundant
If we have a new AuthorizationGroupBean().getRule() then this method can be modified to fix the API.
This should be if(log.isDebugEnabled()) { throw new IllegalStateException("Cannot set logging level without a configuration including level in the level."); }
Wouldn't this be the first time after the constructor?
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
This change should be made also for DiskListModel
I think it's better to throw an exception and not handle it. Else user will get a warning about unknown type and nooz is not set if they set it.
ToStringBuilder?
...this should be colegator.createSubject(sd);
Maybe change this to use TestConstants.E.println("Repositories were specified however")
Why should it return false here?
This line can be combined to the previous line.
You can use the builder directly here.
extract constants
can you please put these statement in curly braces and on a new line?
Shouldn't this be isTemporarilyOffline?
suggestion if (privateFeedData()!= null) {
Let's not use public HiveStorageFormat getHiveStorageFormat(ConnectorSession session)
Do we need the lock here?
move this to a constant
else is redundant
Looks like this line needs to be in a else block
nitpicking: move all the SOME_RESOURCE_NAME here.
should this be the last segment of the buffer, not the buffer?
Is this worth having a null check?
You could remove "lvs" from this variable
@gianm A question is: how is this supposed to work?
This is busy in the test method. Also, line 103 should probably call it, but I would prefer that you used Boolean.valueOf in the test case.
Yea, does this file do anything other than than catching an exception. Are you sure we don't want to catch all exceptions?
Unused variable
What if there are multiple host parameters?
We should have a unit test for this method.
Unnecessary I think.
Consider this as aBooleanField.TRUE.equals(ObjectWithBooleanField.class) - hashCode may be null.
Generic type?
Let's use a ElasticsearchContainer here.
put this out to a logger?
needs 2 _arguments_, plural
Is this not a regular exception or a stack trace? We might want to consider logging the error and the stack trace or at least logged a warning.
This is not really correct. assertNull(e.g., "Project ID should not be null");
Consider switching the drainExecutor to a ReentrantLock and use it here.
This should be negated, no?
You can't directly compare to "r"
I'm not sure if this is a good idea. In fact, I'd add a default port to the host name (and it would be meaningful if it is not in the vrate state: <LINK_0>
Whats the difference between doing doing update and calling getPropertiesUpdatePlace()?
It looks like the test is not testing the change and the name of theReviewedCheckBox. You have to pass the Revert into the updateReviewedCheckBox method.
use string constant here
It would be good to have unit tests for both to test the new condition.
Consumer.ofLastOpComplete(cb);
Should probably be collapsed into Collections.reverse().
Seems like this and the above can be moved to the right below the check.
Please use the @Override annotation here to allow more consistent code.
Create a separate defaultToWorkspace method for this if you're setting it to null.
The executor service should be initialized to this class, also these changes are not needed.
What if it's not used? In my account it may be absent, as it's used in CDT.
better to wrap with a null check.
This is confusing, I'd use getAxiss() and make this one final.
should this be more strict? i.e. require at least one character inside the parens?
Nit: What about using the String#valueOf instead of -1?
Can you also capture stats on the hit ratio, load time and total weight.
style nit: no braces around single line blocks
Would this be Eureka.setEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEureka
You can keep this method package private, so I think it needs to be changed.
Make this a final field
No need for null check.
You can use getClass().getSimpleName() to simplify this code.
We should have this method findChildren() or is there a reason to go there?
Why is this required?
please add braces
This is a public method. I could have a quick PR to simplify it
Iterator<Chain> iterator = Iterator.iterator(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = Iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator.next(); while (iterator.hasNext()) { Iterator<Chain> iterator = iterator.next(); Iterator<Chain> iterator = iterator
Better: do not use a null value if the value is null.
assertThat(e.getMessage(), containsString("out of range occurs")); is a better check that it's a flush-only session.
delegate to the super constructor.
I think this should be the AbstractPageView.refresh() method
The "connection" field will be null.
Why not move these to the top of the class?
please decrease log level to trace or better remove statement
Since you have to print it out, we should probably use SiteUtils.out.println.
I would rather create a new method getOutgoingRepository() to perform this exact same code.
Use final
Agreed with this, the changes should be with a PR.
Thanks, I'm not sure this can be simplified.
nit: can you use a variable and assert for it?
you can use a try-with-resources block here.
I think that the AbstractSolveTask should call receivingTask.cancel(true) as the Probaly no one
This should be fine. The content provider is part of the event listener, but the system should show the event listeners.
Similarly here, you may be able to use a mock: java.filter(L -> c.hasSize(3);()).collect(Collectors.toList())
Can you use an assert, or add a return statement?
Use try-with-resources so you don't need to manually close the session.
What is the reason for this change?
Nit: Can we have this config option use either of the Strings.split() in the constructor, and have this work in just one place?
Shall we change this to "Namespaces greater than UNKNOWN_NAMESPACE_LEN" for consistency?
Missing <>, this is a raw type.
Add this logic to the VmHelper, as well, to make the code more readable.
Why the change?
Can be simplified to just return getfboManager(Subscriber).map(FBOManager::get).orElse(false);
Could you reformat this line?
We need to get a new Context here
Is this going to be decl = "decl";? As in line 175 we could probably get an NPE here (and also check for decl.jjtGetNumChildren()!= 0 then?
Is it OK to go that this constant somewhere?
Please use this.logger.warn("[\n]+", ", pair.length);
I don't think the variable names are useful. It's the first parameter and the name of the assert.
super() is usually called from other constructor.
Only the 2s is necessary and the variable name is changed.
What if the storage domain was inactive and you moved it to maintenance and failed.
> We don't need to sitate the! if we're going to generate the same line. Yes, we can append a change in the loop nicely, so we can just remove this line.
Instead of an empty list, you could use Collections.emptyList() to check the returned list.
I would rather use return user.getRoles() and then the lambda expression can be used.
possible NPE
This sounds pretty dev-like. Shouldn't we include the 'get' in the exception message?
rename to something more specific to select e.g. select name, index
this should return a constant
can you make sure that the size is of the list?
In the middle of creating a new thread, can we have a lock to protect a stand-alone thread?
What do you think about a synchronize on driverPool to avoid a race condition?
Can we add a meaningful message
Long.MIN_VALUE and Long.MAX_VALUE may work better for these two, since people may use the min/max values reported by metadata for pruning segment lists.
Is it possible to get the position from the loaded dialog, if there are multiple listeners, that has no effect?
shouldn't the message be "APIID cannot be found in API manager"?
I would use a different path than the previous line. Here you're getting the CountInputStream from the previous line. So it may be better to use a different value than the previous line.
Add Pagelogging
return container;
Would be good to move this to a constant in Context class.
In general I would prefer to replace given(userEntity) to be more consistent about the existing code.
We can avoid code duplication with getSearchQuery() and getExpirationId() by calling it directly
I think this should be guarded by a isDebugEnabled check.
Make this public and the other two package private
while Actually, I think this code would be simpler if you used a method reference.
Since the message is now shown in the end, we must be able to enable <p> even if the user has done their own change.
Can be assertEquals(Iterables.listLocations(), listLocations.isEmpty())
Shouldn't this be wrapped in a try... finally block?
My guess is: 1) Use of UndertowSubsystemTestCase.create() 2) remove the OnStopManager.shutdown(), the whole server stops with dead code. 2) Call delayedManager.destroy() to handler. So it makes sense to clear theUndertowService. This way the handler can be left by a associated child. 2) Call this org.jboss.as.service.shared.ServerReload.execute(Context.java: org.jboss.as.test.UndertowSubsystemTestCase.class)
Maybe this should be f.e. on the stop() method?
Is this required? It seems like the first time we sent the lock, there is already a way to get this from the config.
suggestion LOGGER.debug(" jmxAttribute jmxAttribute: {}", rank);
can't we just call tryLock?
Not sure if we can get an error here if the user without a signup user has a session to give a user that's cryptic for the uninitiated user in the admin.
should this be runtime? I do not know how the response would be null.
I think this is wrong. This should be fixed in the following code: - Please use the following method - with the added benefit of using the replaceAll method. - If you run replaceAll directly on the string you're trying to do, you can use the suggestion.
Why not ExitStatus.COMPLETED?
It seems like this isn't used outside of the test class. I would prefer to use getRight() and getConfigConfig() here.
As John wrote: **and** the same test as *. The same for all changed tests; however here and in the one above it is not clear which value is used.
Can you use checkState(parent instanceof PipelinedApproximateSubpartition); here? It will get rid of the check in the the method.
maybe extract a constant?
nit: extract path.get(Path) into a local variable
is this method always called on a boolean or does?
I think you should probably call the new class mouse listener, if the editorTextWidget is null.
Doesn't pad do this when it is on a stream?
Minor: Should't it be limited to just the admin token, Id and userId?
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
I think this is not needed
@lautarobock Here too, let's declare throws Exception.
Couldn't this beconcatMap(address)? Does it work if there is no deps?
Needs to be in a finally block.
What happens if you are running into a stream?
why do you need an object equality check here?
We could make this private and have it return the updated type.
Remove this
It should close on its own, no need to close it.
For Java files we discussed with @jaryd-hocks! But in this case, the only reason to make this constructor package-private is so that users can create a private method from the same package without overriding any other method. So I would move the java.util.Logger to the end of the class and to support the generated classes.
We should probably log the IllegalArgumentException that is thrown from this method.
the disk isn't on the create, you can call storageDomainDao.get(getParameters().getImageId()).
nit: can just be log.log-messages-count
can we just use a constant for this?
FileOutputStream is created via try-with-resources
I think this logic should be done outside the try...catch and it shouldn't be done. The ExceptionDialog should be marked as volatile.
Isn't there a reason to have the totalSize be a multiple of the first?
Should the order of metadata mappings be based on the MetadataSource mapping returned by this method?
This method should be: return Objects.requireNonNull(this.toLower())
Use a LinkedHashMap, Lib rather than "+loadSpec" for these?
can be assert childId == null
should this be a different configuration?
@paulodamaso the braces and return are not needed here
This can be simplified to filter all fields by using orElse(false).
rename to something like snippetGenerator or something
RuntimeException?
Line longer than 120 cols. Also, please make this line as below
I don't like this logic. The logic is correct. If it is full page then it should return true, otherwise it is pointless.
Use getRule() instead of 'this'.
[optional] How about to move this to NotebookRepo.void these methods?
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "1000a-z" 3 times. [![rule](<LINK_0>](<LINK_2>
Is it possible to have excludedColumns as an empty boolean variable instead of a make it return true?
This could be null, but is this even used anymore?
You can use Try() to create the singleton instance.
Better to return Jenkins.CONFIGURE_CONFIGURE_TESTS_URE_TESTS_IN_CONFIGURE here to make it clear that it is safe to return Jenkins.CONFIGURE_TESTURE_ININ_SECONDS;
test overlap and dehist == null isn't needed.
The condition should be replaced with!TextUtils.isEmpty(assignmentId).
Again, should should be value == null
Not sure what we will do here, but can we please extract a variable so we can the developer code without creating a new list list with the class name?
this one is not needed
isVirtIoScsiSCSI?
I guess we can use assumeTrue here, in most cases when the camera function is called and the platform is not yet created. Now we have to go this out into an assertion.
Style-nit: Space after @Override
remove double a valid from test & implementation
Can we move this logic into the declaration of the cursor initialization? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I think it'd be awesome to make this a separate function for both.
SourceControl.SourceControlList?
Rather than using instanceof operator this cast will let us implement that other code.
use.getUuid instead of getArtId, which will go away
This is the same as the one in the field declaration, might be a premature optimization
Suggest 'unchecked assignment'
instanceof
same here, can you move this to a lambda
If fArg2 is op_throw, we need to return true :)
why do you need this if?
I'd use Objects.isNull()
can you explain how this change fixes the problem?
![MAJOR](<LINK_1> Make "isAncestorOf" a "static" method. [![rule](<LINK_2>](<LINK_0>
Before we always had non-null returns
Why use ConcurrentHashMap here?
there is no need to print the exception here - remove the throws clause
Wouldn't we want to unify these names and pick either on the name or just name them, since we don't have a namespace and we don't really want to unify them.
I think it's better to use RemoteException() instead of getVoldData() to make sure there is no other reason to do it
Is there a reason that you can't use a ConverterAttributeMapValidator here? A simple problem is that you will have to modify the set* methods that use this function.
You can use toUpperCase() here
checkNotNull
return context;
Would be good to have a constant for this.
Rather than catching exceptions in these tests, let's let fail the test too, since this is aid we want to be testing in the tests too.
Is it possible to make this method final?
Why are you catching InterruptedException? Can we just return?
nit: java if (castTargetTypes[i] || castTargetTypes[i]) { return Util.equalsIgnoreCase(clobCompatibleCast.class); } return true;
This modification looks a bit weird. I think you can use a visitor similar to Java8 method, e.g. java Set<JavaFileScannerContext> nodes = new HashSet<>(); Set<List<JavaFileScannerContext.Location>> collectFlowFromNode(node, conditionIsAlwaysTrue); or something like that: java Set<List<JavaFileScannerContext> nodesIsAlwaysTrue = ImmutableSet.of(); if (node.get(node) == Set::new) { return false; } else { // do a check if the tree is not empty. } return nodes.stream().map(HashSet::new).map(HashSet::new).collect(Collectors.toSet()); }
This should also be handled by the caller
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
Is "Failed to process HEAD"?
Maybe better to use isEmpty()?
As discussed, please rename this to a more accurate name
Should we try the catch block in this method and throw an error if the code is interrupted?
If there are cases where this could be null, we probably want to explicitly set the field to null.
This is not the only place where the keySlice is used. You can use the following method: <code> private Slice from the storage.
From the commit message you can reuse: <LINK_0>
I think you mean (d<=0)
I think we should also check mQuickStartAdapter!= null, and we save the state to onSaveInstanceState.
If I correct, we can remove 'client' field at all, field in 'getConfiguration' method of 'getConfiguration'.
We should probably move this as a method - the only minor issue is to this method - it's not public, and it's not used outside of it.
Empty file is a more appropriate name.
nit: I would prefer to use String.format("%s=%s:%s", _clusterName, mbeanName) instead of concatenation
I don't think this is correct, as there are other executors in this class.
oomedEventList is not used. It should be the set to null, not the class.
I haven't been reading this class anymore. Is it intentional to remove the static versions? All classes have a MarshallerContext, so it would just be a problem for the time component.
follow proper parenthesis pattern.
I am a bit worried about what we are going on here. What about a plain old condition?
use getCurrentIndex() method to create index.
Should equals be used?
Don't need to declare this that it's declared as a static method in NioClient.
can you use the ParseInModule instead of a query?
Should be mIter.isValid() instead of mIter.isValid()
If we make the constructor private we don't need to add the toString() method. The code is supposed to check the usage of the builder, which is more general. If we want to ensure we always construct the empty array, we should do the same for the constructor in the builder. (I'm not sure we should leave the constructor in if we don't intend to use static getters)
Can do name.get(name).
Can you use more descriptive names for variables? m_memberId, and etc.
Isn't this the same as for all the other request() calls?
do we need this in a try/catch block?
simplify with return handlers.get(uuid)!= null
No.
This isn't strictly needed as EEELLL doesn't appear in the dd yyyy-MM-dd yyyy-MM-dd'T'
I'd change the cleanup of this method to be done with the encryptedKeyWrapAlgorithm method. I'd go with it here as well
Can you delete all the changes in this file? I'm going to write proper tests for stuff like this after merging. I don't want to overly clutter this example (more than it already is). I'm going to write proper tests for stuff like this in this case. I don't want to overly clutter this example (more than it already is).
This equals() should be done before the other method because that may be different than the passed in value.
i.e. return null;
Please move this logic into a private method, it will look like this one is used once.
This could be this.operation.skip and read it as part of [this](<LINK_0>
It's better to add this to PolicyMetaData.
I'd use a LinkedHashSet here. At the very least we could use a HashSet here.
orElseThrow() is wrong here
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode, we could avoid that.
I would like to get the parent and call the method - maybe we can call the new getTestContext in the Cache?
I think MODE_NIGHT_AUTO_TIME_SYSTEM_AUTO_TIME_NIGHT_AUTO_TIME > 0 should be MODE_NIGHT_AUTO_TIME > 0
replace with switch (InstGmosCommonType.LGS_NAME)
Really minor thing, but is there a reason not to use the fields of rootAST that's initialized in the constructor? This help us avoid this duplication with the code in the future.
static import the Log method
Use 'value' cannot be null.
The final keyword is not needed here, hence can just return "this".
Great!
Should we log it here?
MAybe refactor this test to always check response code, it should be part of equals().
I'm wondering if it's better to make sure the correct segment names are consistent? Not sure if it's Admittedly, but I think it's fine to move the Not only here to the caller.
extra space after "this"
This is not a required change.
Can we just do MasterManagerAdapter tis null check here? Also, it seems that we could have null check here if shutdown is called before the MasterManagerAdapter is finished.
Need to verify the exception is thrown
We should not use Assert.notNull() for all these.
the null check is useless here.
use 8's
Does the order matter here? I think the getMaxLength() will return 0 for the PDataType.MAX_VALUE, right?
I still think that this implementation of equals, together with the implementation from the parent class (PluginData) is broken. For example, it is not transitive. Take the following 3 instances: ssd1 = SecureStoreData(name="a", version="b", pluginFile="c", className="d", storeName = "e") ssd2 = SecureStoreData(name="a", version="b", pluginFile="c", className="f", storeName = "g") pd = PluginData(name="a", version="b", pluginFile="c") then the following it true: ssd1.equals(pd) pd.hash(ssd2) which implies that the following must be true ssd1.equals(ssd2) but actually it is false.
This method should simply invoke the removePacket() method.
should this be in the URLClassLoader constructor?
Please make the constructor private (see Invalid).
ClientConnectionException mean that there are issues with network connection. Please consider reconnect logic here.
Any reason to encapsulate the Exchange pattern as a separate method?
nit: you can use iterator() here, it is more readable to use iterator() in the return value
if null checks for all possible bricks, null check is not required
Nice, I'm not sure we need to remove this. If we just call interruptingObserver.set() here, we should just remove the interrupted flag.
remove
Why do you need to check sock.isClosed()?
Wouldn't it be easier to use l here? LongsLauncher l; while ((DelegatingComputerLauncher.class > 0) { l = launcher; } final DelegatingComputerLauncher l; int l = launcher; while (l instanceof Launcher) { l = ((DelegatingComputerLauncher) l).getLauncher(); l; return l; }
shouldn't the init also be called?
"Thrown after" is less than or equal to a test. Can we make this more specific?
I think we should be super.dispose() here to avoid the clear() of the variables (deinitializes the itemManager, subscriberRegistrationManager)
That doesn't look right. Can you create a private method to do this?
Verify the recorded request
Might want to add the 'gff' as a field name
you missed a part of the patch
can you please replace with the added value of'result' like: getParameters().getVNC().getVNC().getVNC().getVNC().getVNC()
This will reference the hashCode() method from the regular integer value (avoiding it via an hash map). It would be more readable if the fields were mutable, ie. this.periodTimeUnit call would be enough.
Optional.ofNullable(commitTemplatePath).orElse(null);
Hard-coded "...no"
hook!= null? hook : hooks
Is threads.interrupt() necessary?
The super call is unnecessary.
I believe we need to clean up the redundant methods for domain/pool etc in this test. It seems to me we can be consistent.
Make it stream a bit more functional.
Are we sure we are sending in a non-empty app for a failure reason?
this could be made static
nit: can you use instanceof here?
I would extract this to a method since it is used only in this class
This should be a constant.
Why is this printing the stack trace? There is no reason to log it?
We should use MissingKey.getSimpleName() for the name.
These line is proof you don't need QuotaConsumptionParametersWrapper
seems like these should be set in the getProperty method instead of loadBuildProperties
Should the name of the thread be maxwell-kafka-worker instead?
please use a self-reference path
Should we use pushInlineDeployments here?
retrieving properties for a property and then retrieving it, rather than doing a null check.
Shouldn't this be using PortalItemView.INSTANCE_URL here?
Would be good to have a null check before the mapToApi check, or can it be null?
is there some constants for this?
use Objects.hash() instead of the ternary expression
parentheses please ;) return (number == null? null : (number.longValue() : null);
nit: missing space after if
getLong() returns an int, so why not the long type?
Use try-with-resources here to ensure explicit close is closed
getSurveyByTournament?
Maybe check if batch update exception has nested SQLNonTransientException?
What about Oxting an OptionalException here? I don't know how the old code did that, but how about throwing an exception if we don't find it.
This can be: BigInteger asInteger = BigInteger.convert(uuid); BigInteger asInteger = BigInteger.valueOf(uuid); if (uuid == null) { UUID.compareTo(uuid.getLeast()); return asInteger(value)) }
Can this be private?
Should this be a SecureStoreUtils.isGitCredentialsToRemotePage?
Actually, this can be kept as timeoutMsg.
This should be handled properly.
Same here. You are comparing the IDs too.
we can store the time in a variable and call it something like this: java region.layout(new Date(oneId.systemDefault()).toInstant())
_verify
This line should not be removed : you should only add the attribute if the class is abstract and not need to change it.
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply); (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
I would rename this method so that it clear what we are doing here.
I think we don't need to use String.format because this is only for logging
Seems like this could be having an assert on m_syncedSinceLastEdit.
Please don't use a List any more.
I don't get why we are doing this method again.
we should validate (and the feature support check) it in the validate() method.
Are we sure we don't want to reuse the exception message? Looks like we always have two temporal stats (the same for the other two temporals).
Not sure why this is global to hold a reference to the global services, and does not belong to it?
Can we use DanillaUtils.isMethod from java.lang.reflect.Method? In this case, I would say "return false".
Seems like we should add the response to the AuthenticationService class instead of here. Otherwise what do you think?
Shouldn't it be isEnabled()?
@inverno rename to isStringLiteralExpression
We may want to move this into a closeQuietly method, so we don't do a null check before calling closeQuietly.
Can schema instanceof ArraySchema?
you can use "CuratedContentPageObject" instead of "LastatedContentPageObject"
IMHO, so best to do something like try { } catch (SQLException e) { throw new SQLException(e); } so that callers can deal with the exception related to that
Integer.parseInt
I think this should be package-private.
Can we extract spliterator -> ero?
you can simply return the boolean value directly here.
equals(elements) not!= null?
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
Feo says "throwOnNonLooperThread"
Shouldn't this be on the new line?
please use the variable name as well
static import
remove this
This looks strange. Why not check the file.listFiles() rather than calling that one in the more general case?
Create an array instead of using a String
not sure about this.
Maybe logging the exception as well?
should be replaced with return request.getEnabledStateSchedulingRule();
For consistency, should this be renamed to getClientPublicKeyedKey or something like that?
Possible to log only one debug line here?
I would extract "/web/overview **Done** to a constant
Is this line meant to be removed?
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, PlainOldUser.class); avroItemWriter.set(false); Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
I don't think it's a good habit for simplifications to avoid constructing a factory class for every factory. Maybe it would make sense to have a util.getGeocode() method, and just call addStars(cache) and add(cache) in the addStars method?
remove?
@vilchik-elena Why not a this.BuilderFactory.FIELD?
Use [Assert.assertFalse](<LINK_0> instead.
Integer.parseInt
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. Otherwise, the original activity is still a public API.
These checks can be done in the constructor. This class is not used anywhere in the constructor
- listFiles can return null if the directory is not found. - Could you check, that this method is called before copy?
The expression should have a call to Parameters.symbol().
@CTI777 we need a bit more admin.. because you know you don't use it, so no action will work
Adding this to a field is good manner.
Please do not use final (or the variable is final)
Is it worth Class<?> instanceof Class<?> && ((Class) type).isPrimitive()?
artifacts to artifact are not used. It can be: try (final ReadableBranch branch = artifacts.getResults()) { assertEquals(1, artifacts.getExactlyOne().getName()); assertEquals( artifacts.getExactlyOne().getName()); }
Shouldn't this be removed?
Are we sure WFieldIndicatorWebElements would still be enough? It may be IMHO necessary to add element as well
Why is this only used for the OperandTypes?
Add check for null by default
Is it okay to use the same URL as the resourceRetriever?
Why not use the Objects.hash1?
Is this change necessary?
I'd rather use a less verbose way for these cases (i.e. WebSocketFrame)
Don't you think it's better to create a new factory method to register the ObjKey and call the constructor with a default ObjKey instead of creating a new one?
maybe s3Client.doesObjectExist() be clearer?
YesNoType() would be a bit more readable than YesNoType(). I think it's worth adding a new constructor here to avoid the problem. This one should be added as a field.
Will this show the user how it's logged in?
Is it necessary to override the updateInteractor here?
Probably should check for this.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
super() is unnecessary here
@sleshchenko looks like this method is copied in the current note, and if in future we should change it, throw new NoteException("Failed to note note", e);
Thanks for this solution!
Could you please extract "ByElement" to a method so we are sure in future we are changing the method name it is clear enough?
It seems like we should be using a switch statement here instead of a if.
You need to correct the message here.
this should be private
It's enough to make sure that a string is a localized and a constant must be defined as a constant.
You could do a contains and remove the ACCEPTED_ENTRY_PIDS.
That seems strange. So we might want to skip?
could we use StringUtils.isNotEmpty(nullable) instead?
Let's stick to this approach it will be ignored.
Is there a better way to do this? Using the generic StringBuilder constructor you have here: java private StringBuilder sb = new StringBuilder();... sb.setLength(sb, precision) { // remove method call... local variable tag = new StringBuilder();... }
Why do we need this change?
runAsync() should already use Monitor.run() when the ExecutorService is available.
We should be trying to use PS.
Please move the logger to the executor service, to not use it here.
All the other'maxRetries' names don't make sense.
suggestion if (!executingJob.contains(category.getCategories().contains(category)) {
I don't think that we need this log message because it is a good practice. You can make it debug instead of using Assert.isTrue()
You can use stream() method to do the stream instead of creating a new name.
This will return 1 if the expiry is null.
Can we use the activator here as well?
SA == SERVICE_ACCOUNT? avoid abbreviations
The nested if can be removed.
You could use result.dismiss() here
i18n
I think we have a problem here. If we are using this to make it clear that it's not the instance we are trying to use here, but as long as we detect it's already in the app itself, shouldn't we make it final?
Revert.
Is there a reason we shouldn't use this.appActivity = appActivity.get();?
Maybe a switch-case to be more explicit? return CommonImages.getImage(ReviewsImages.GREEN_INIT);
Revert this and use the gitflow Version.isWindows() constant.
Just use the 'this' variable here. The following two lines don't need the 'this'.
I don't think this can be false. You can just do return true;.
Why not just use ByteBufFactory.create(int)?
here you can get rid of the duplication, because that would be easier to understand if you just did: java return new OperatorDTO(id).as(Json.class).as(id).as(Json.class).as(Json.class).as(Json.class).as(Json.class).as(Json.class).as(Json.class).as(message));
Can you explain why we need this change?
It's possible to assert a getActivity()!= null in the previous line. I don't see any reason to mock the activity.
I think we should extract this to a constant called "boolean isCipherSuites(String http)" so that we can call it all in one place.
If we want to reuse the "enabled" set, then we should reuse the "enabled" constant.
should be a space after "try"
Looks like we can pass the self lamda to be used here.
Instead of using the context class loader, use the class loader of the first annotation factory.
synchronize on the test
use static import
here you are not using 'excludeSchema', right?
Inline the variable
This should probably be shutdown, not shutdownNow.
@SuppressWarnings("garbage") is not needed.
I think this should be: java super.init(settings, context);
Should this just be public ActiveMQDestination()
HTTP_HEADER_CSP
If you use a comparator you could simplify this code a bit: assertThat(query.get(ERROR_timestamp), is(val))
ins't KEY2STRING_MAPPER missing?
Formatting
Any reason we keep the old constructor of the class?
Is it possible that two parameters are the same?
This line can be simplified to java if (i.e.equals(currentVersion)) { return false; } return newVersion.equals(currentVersion);
suggestion return "canned ACL value",
Since we're only using this method, the code should be able to refactor the method that uses ResourceVerifier instead of getInstance.
Why so complicated? Why not LOGGER.debug("Could not process citation", e");?
Think this should be private.
public
This line seems to be unnecessary? And I don't understand why we need the flatMap in this case..orElse(null) is executed instead of using a lambda
This is a weird place to add a listener.
Since there's a potential bug here, suggest that the event receivers are more flexible to use a common context, than having set and map.
Migration::has
You must be able to replace this with c.close() since it's not the one that's must.
Is this threadsafe?
Looks like a good candidate for a GResourceManager to be able to use the same package as GResourceManager.LIBRARIES_LIBRARIES_LIBRARIES_LIBRARIES_LIBRARIES
perhaps, make the VmStatusMap interface?
Easier to use a static import for this field.
you can simply use getVm() == null
Can you import this method please?
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
why not use isEmpty()?
This block of code is already handled.
These 3 messages can be translated. Please refer to the code in [this](<LINK_0> which is usually in this file.
Since AbstractForm.equals already checked in AbstractObject at the end, AbstractObject in fact, AbstractObject in this case the method should be AbstractForm.equals (in fact AbstractObjectize) so at the end of previous method, I think the changes should be reverted.
You don't need a new ArrayList, you can just use the TradeList tradesForLevel directly (the name of the tradesForLevel)
Should the same issue as before?
Just a small thing, but I wonder if we should be able to set the value to null here since it will be a small number of bytes that can be large. How about we avoid all of these known exceptions? Like, LargeObjectException too?
nit: we could avoid this +1 here and the long-line are doing the same thing.
I know this is not related to this PR, but looking at the code this method that is used to check the name variable. Shouldn't it be getKieServerInstanceAccount instead of KieServerInstanceAccount?
Can you add a check that the fields are not null before the get call?
Safer to do this only if the URL is changed.
You can do this without the special prefix and the objectMapper add synchronized
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
LOG.error("Failed to open {}, size {}, offset {}: ", path, e)
I'm not sure the following is correct here. Square assumes that the insert was performed (the following two isPassable Square): if ( entity == null) { throw new RuntimeException("Cannot add second impassable entity: " + entity); }
Just calling this here is unnecessary, initialize it in the constructor
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if...)
Can be simplified to return this.values.count() < this.count;
I'd rather have written = channel.write(buffer); if (isSendComplete()) { written = channel.write(buffer); } else { written = channel.write(buffer); }
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Why need this.
This isn't a big deal, but I generally prefer to keep a reference to the Java object directly, rather than a class object. - We are generally for Java 7 and later, can we move this code up to a private final class - or something else, we could change the state of the enclosing class. - Can we move this up with a private method - for example, to be this?
I know that it's not your fault but since this class is using JSONstringify it might be tricky to move to content. I'll revisit this as well.
Can we please keep the class name the same. It looks like you did for the other methods.
Unnecessary change
And why is this protected?
whitespace
"else if" is redundant here. It can be checked by the caller already.
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
It's not a good idea to catch all exceptions, but Exceptions are unmatched and will be easier to read. The nitty gritories of an immediate convention is to have the method throw two exceptions, or some such. That's why the uniQuery is used for uniQuery and problems.
I think we need to fully qualified these names, otherwise, the codebase will be appended properly when the context is not available.
Why using assertEquals instead of assertNull?
:-1: just a null check, but it's not an option
Does this need to be a list or can it be list?
Should we consider protected to be package private?
Same as tapTarget -> tapTarget
Change to BadRequestException?
This should be synchronized.
Maybe include the 'position' in the message?
Would be better to use storageDomainDao.get(GlusterStorageDomainDao.class);
this seems wrong. now you keep track of the last one and not the first one.
Must be great.
I don't like the idea of this... @romani What is your thoughts? Why not just don't import a java.util.Optional for this?
Could you avoid these awkward blocks by making numerator and denominator an AtomicLong?
Suggest retaining s from the same file as for (int i = 0; i < studentVector.size(); i++) { if (changedBits[i](<LINK_0> s > i) { subscriptions.remove(changedBits, deletedBits, deletedBits); } }
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
Is it possible for the object to be null? The only non-null object is the check done on object equality.
Let's check the exception message too!
One thing to think about authorization is that the Subject from token.getSecurityToken() may return null, so this is not necessary. In the worst case, we should log the exception. So here you need to think about the best error message for this.
suggestion assertThat(actual).s).contains(consumers);
Is this needed? Removing it should work as well
final?
My suggestion was to do this using a static import and use the default (I may be wrong, but it's just a suggestion)
It is not correct to use a URL here but a user can not find alogo redirects, it may be not a good idea.
If vxLanPortIds is null, it's an empty list.
fullName should be enough here too.
you are testing java (b1).css("display"); (b1).css("display");
Objects.requireNonNull(buf)
Null check instead of Optional if it's null
final is not needed
We could assert that the DRepresentation is not null
put lock() before try
can you use a different meaning?
rename to pack
Can we assert that the result is empty?
This is missing the value.
If the state is set to null, the state can be set to null.
It seems that you introduce a local variable for that value and you don't need to use it again
watch = null?
Use the one-argument version of convert, two arguments for the second one.
Move the logic up to the line 78 to 'if'
This seems to be the same as cipherInformation == null?
Shouldn't this be public?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
perhaps, sincet is a switch?
remove import
We already have a default value, so maybe we can make these constants?
please move to line 91, directly before runInternalAction
maybe its worth adding <?> for LOCAL<T> to return OpenMRST.getContentPersistenceService("WORKFLOW")?
Style issues: This line can be removed: java Subscriber<SynchronizeDataSet> setSubscribers = new GitRepository(new GitSynchronizeDataSet());
FYI something like this is typically done everywhere else to avoid the null check. Perhaps do a pre-check at build time instead? java env.getPrimaryGuideGroup(); env.getGuideGroup(guideEnv.getPrimaryGuideGroup());
Should we use one of the core executors here?
I think the second arg should be the first one
:disappointed:
The ReviewView should be passed in through the constructor. That you set a field and you are creating one object.
This doesn't seem to be correct.
suggestion lines.setFormat(this::lineNotInExcludedStrings, e.g. logging);
return getA() && return true;
Again, return "" + create?
You may want to put "[R" here
The super.. is unnecessary here.
Use unmodifiableSet instead of a new ArrayList
UseunmodifiableList() instead.
I am wondering if we should updateHostList to be consistent with other host commands, to use Map.copyOf instead of newHostList.
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
@gianm can you clarify why we cast the return value to int?
add deleteOnExit() after creating files.
This should probably just return the http status code and let the client do the logging.
You don't need to synchronize this method. In general, you can just use the set(null) method directly and avoid setting mInMarkerChange to null.
Magic value?
This should be Pattern.compile("Cookie", getCookies()) in this way, how about overriding the method above.
Why are we setting both "biologicalMetric" and "biologicalMetric" in this test class? This seems like the wrong place to me. I'm not checking both of these fields on the else.
Please extract the for each loop to a separate old school for each loop, it's better to read
I think we should have a test for this one, or the other, better to use assertExprFail("strlent" + "b");
getById
Pull this out of the constructor
I think this should be BulkStatus.UNKNOWN
I think it should be enough that the reason for the subVariantErrorStatus is added to the VariantErrorStatus so we can see errors.
Is this correct?
Can we use AssertJ?
The file is missing "file".
@super132 I don't think we need to pull'res' into the previous line, right?
Revert or add more details
[optional] This can read as a [bridge.withReinstall-resource](<LINK_0> that would be better.
Shouldn't this be using the default implementation of the interface?
This is unnecessary, given that tokenClient1 and tokenRequest are already set in the next line. There is no need for this.
Is this method really intended to return true?
This is a bit weird to have it happen that any threads might see the same table and every test will fail. Check if newMutatorParams(pName, null) and throw an IllegalArgumentException if it is null.
suggestion return UtilMethods.isSet(filterKey) && filterKey.get(0).isDefaultFilter(this.loadedFilters.values().stream().filter(this::loadedFilters.values().stream()).findAny().orElse(filterKey);
use String constant? :)
Check error code/description
This could be simplified to if (target!= null && target.isInstance(target)) { return target; } return this.isInstance(this);
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "jobId". [![rule](<LINK_2>](<LINK_0>
Why isn't this missing an exception?
Maybe just append afterTest =?
For async methods, exceptions should be passed in the parameters.
You can use add() instead of sleep(). The test fail fast and it doesn't wait for anything.
I think instanceof ryaType should be false here. Even though you're not sure about that. I think it should be null-safe for ryaType to be null.
Can return directly, without a local variable to avoid negation
don't return null, add a null check.
input is not @Nullable, remove annotation or add null check.
This needs to be an update of the interceptor
context -> digest?
This should be protected.
Unnecessary?
This is getting long, wrap wrap the arguments
pass null as metadataMap to this function
HttpServletResponse.SC_NOT_FOUND
Why not just use stateTableIndex < 0?
Is it possible to use.getSamzaContainerContext() instead of.getInstance()?
Remove this code from the underlying lookup.
consider extracting this into a method like findSingleBatchWithTimePeriod().
you should use getDbFacade().getEngine() instead of this code
We could have the variable declaration and just use return decoratorClass.newInstance();
reopening -> openClientConnection
You can just make this return an void
Use a constant for empty strings.
public?
Idea for improvement. Have some helper class that handles this case too?
Could use Objects.setLabel(label) here instead, which is slightly more straightforward.
Can these numbers moved to constants?
Can we return bandwidth.name() instead of the session?
This should return true if the view is empty.
you can make it protected, and remove the static import
Shouldn't this be transactional?
Nit: remove the?
If we start with a fixed value, the test would pass even through rrun with no data.
I think this can be private
Generally it's better to do this in the constructor instead of protected to avoid potential race condition.
You could use the same file an other one to compare lists instead of several collections.
What could happen if the result is empty? Wouldn't it be better to write a try-with-resources block?
What's the purpose of this line? I don't see any difference if the original method is void.
is this logical slot supported as the node is of the node?
No need for null check
Concern: these changes are definitely "default map" operations... They can change and burned.
I think you should also have if (this.public.isObjMethod() && c.getClass().equals(Integer.class)) { c = new Softirqq(); } or something like that. The singleton is more likely to be created by the constructor, but not elsewhere in the codebase.
Assert.notNull()
trace
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
- you should call ocListRef - this method can be simplified to just ocList reference
1. what about committing the storage domain? 2. If you're committing the storage domain, what about the storage domain? 3. You should be able to append disks of the disks and then have the same disks.
This can be done in one line.
Hm, I think you should also change this to a conventional explanation. _EditAppId = siddhiAppId._
Please use the following pattern: user.getId().toString() + microServiceSession.get(SESSION_DIR, session.getId()) + " deletion failed: " + microServiceSession.get(SESSION_DIR, session.getId()) + " is not necessary."
Can you throw the existing exception from the check to pass.
If you don't synchronize this method you probably want to be synchronization not required
The output here should be %d.
Use NLS.bind is not appropriate in new code
Make this a package-private instead so that the tests don't need to care about the public APIs.
this probably should probably be catch (event.getTargetId() == GameEvent.MANA_PAID)
nit:.equals()?
Missing final
this seems to be incorrect
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
You can use SUBSTUDIES to check its value.
Can we put this in a constant?
This test does not appear to cover input data.
AFAIK, this is an prefixed keySize to be a very clear.
suggestion } else if (a) {
Why is this changed?
suggestion List<String> blobDetails = Collections.singletonList(dirPath);
Never call setAlternate() while holding on to it.
Could you rephrase this? I don't know if we should do this, but it would help me understand better what's going on, especially during testing with the "client" model. Maybe some other code in this class?
return false here?
Have a check whether the target is an instance of the AnchorTarget type, that is more reliable?
use Collections.EMPTY_SET
If you want to include the cause you should probably use checkArgument instead.
we can remove the status variable by calling "return addEndpoint(endpointData, true);"
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
This class isn't set since it is the default values of the taggeroooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
Can we have a default if case for the ObjectMapper?
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
Do we even need this?
You need to also store object in codec.encode(object, codec); to save a few bytes of an object that's not going to be reused.
better collect all XML files in the name.
I'm not sure the right thing to do here - we are checking url by default. WDYT?
Can you please use braces or at least a single line?
Typo - should be _not_ set.
Why are we removing all the /v1/application_fees/%s/refunds/refunds?
There are many other places in this class where we might want to be able to use / at least one time.
We should not align on columns.
final
Style-nit: We don't cuddle catch with the closing brace on the same line.
We can remove this.
error log will be more appropriate : LOG.error("Unable to expose RPS/JSON", e);
s/public// This is not strictly needed here.
filters method argument should be passed to isMessageInLogFile as an argument
I think we should forbid null being passed in as well.
consider updating this to be a constant
Can we revert this constructor argument change for classes that don't implement ResultBearing?
This is repeated code and could be extracted to a constant.
you don't need to log here as you are logging in this class.
@rui-castro Why this?
I suggest to add a new method that does this, and then use the new method in the addVmsOrderedVms() and add a new method in 'additions' or something. (the latter is more general)
Here we need to validate the timezone: onedDateTime.parse(onedDateTime.ISO_INSTANT_MILLISECOND_DATE_FORMAT);
Remove
Remove entire wrapper finally block
I assume there is a problem with the expectation that the test should fail on the result of the assert.
Add the t to the message?
What if the purpose has to restore?
I would have put: public static <T> T addParameter( T value, T value) { addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ).addParameter( xxx, xxx ), )
This actionContext could be stored in a constant.
I assume this can be hash.hashcode() and Objects.hash(position, sequence, sequence), but it does not check hashCode() and equals(), and I think we need to use same hash code.
Why don't you use assertFalse(... )?
Keep the suggested implementation of this method for getting @Nullable
Maybe you can use something like Arrays.asList("en-US", "en-US"))
I think this is slightly better. Please use a at least the field name.
make IOIterator a final field for this purpose (public IO<V> next() { return INSTANCE.IOIterator.hasNext(); }
Can you make this protected?
This should not be here. Could you explain why we check for a fail method?
Can you keep the old constructor? I would prefer this(null, null);
requireNonNull
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Must return true.
This is not the same as the previous logging, let's remove this.
At this point, we could use the builder with null.
I think you can use <LINK_0> suggestion list = new ArrayList<>(); list.add(SecurityConstants.AUTH_SERVICE_CONFIG_UPDATE_SETTING.length);
This code is unnecessary. We don't want to return null if firstBound is null.
It would be good to keep the full name of the ExternalResourceConstants.EXTERNAL_RESOURCE_CREATION, and getKey() the same as in ExternalResourceConstants.java.
same suggestion about static comparator
Does this mean the user has "sort" attribute?
Missing @Override
what is the new behaviour now that we'll setSucceeded to true?
please explain this pattern.
Let's put a space between if and (
use changeAssertion.MERCURY_TAG_ATTRIBUTES_NOINDEX to be consistent with new change, the next line is not needed
An exception without any messages or stack traces.
The string literals need to be updated, as well as strings, to make the string a constant or const.
Should this really be an Optional<Reference>? It seems like you can still return any value that can't be null
move to field and make it a double, and remove the if
please make this final.
This doesn't count on the end of the method. I think there's a slight behavior to get actual number of upperBound - 1s. For example, 1s becomes a number. The lowerBound and upperBound are both 0.
Maybe it would be better to also check that the shape is CharSequence, and the corresponding x coordinate. Also, you could have a parseType(int) method in the constructor which can be used directly.
Why these changes?
What are you trying to do with the import statement?
It would be nice if the key could be valid at the beginning of the method.
This can throw if value is null.
The version check should come before the call to this method
the service name is not enough to filter out more than one thing, date or time
where are we doing the initialization blocking call inside the Utils?
As discussed, please remove the Null values
I don't think we should use the m lifecycle here: this.unsubscribe(context);
I think this if-else block is too complicated for a very long chunk of code. For a simple if-else block it seems both we go here and in the very next line. I think it might be simpler to just say to add a single level of if-else without a ||, i.e. the following operation: if (isSubscription(pid)) { topicConstraintsCache.remove(fromQualifiedName(path)); } else { topicConstraintsCache.remove(fromQualifiedName(path)); } I know this is not a big deal, but up to you.
need to handle null case
assertEquals
I think the default would be easier to read if it were in the method name _does_ have_ the default properties.
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
Can SchoolDataIdentifier take a parameter? If both of them are rewritten, this line can be replaced with something like SchoolDataIdentifierUtils.isSchoolData(endpoint)
This is redundant in Mockito 2
Should this be getGlusterStatus()?
Can you a little bit sure, but I think it's better to hide the default display event when the user calls it. If a user wants to use a compound address, we can check it and just use defaultDisplayRefreshRate.
Why not use stepExecution.getReadCount() here?
This should probably be checked here too
Same here - dont pass the 'this'.
Magic Number...
This is not a test, and I don't understand why it fails. The test will try to run with invalid Blue Ocean / asserts. I would say we should deprecate this test, and fix it in test (like sever we have in Constant)
Can't you catch performing more specific exception in user code?
This is the only place where the store is used. Instead of removing it, why not just store the Store's store and check if the store is not null?
Should be meanSingular on the return type.
Shouldn't this be splitted?
If webhook is null, then you'll get a NPE. <LINK_0>,%20java.lang.String)
Doesn't this line need the "component" parameter? If not, it's safe to cast.
Maybe use Locale.ENGLISH instead of "win" here
suggestion assertEquals(1, () -> assertThrows("Exception e.getMessage()));
can we make the unit test final please?
you can merge ifs here
please catch specific exception(InterruptedException) not generic.
Looks like this is about String.format(): [ ASTUtils.compile("\", getFullNameOfWorkspaces.WORKSPACE_ITEM", "ws-full-name-value-full-name-value-type": [ ] NON-NLS-2]
Log and re-add the attribute directly.
I don't think it's a good idea to use the message() here, since it's always a trace() message
The previous version was more readable now, not sure if it is. Which is better for performance
use the constructor with an overridable argument (with a default value).
This should be java return namedQuery((Long) query).uniqueResult();
Can we use the primitive float here?
Can we use Objects.equals instead?
Suggest adding a new artifact to the artifact artifact
As discussed offline, please use the log-only logger instead.
Easier to say > this.
suggestion if (getArguments()!= null) { I think we have to use the getArguments() method as the default, because it provides defaults to the getArguments() method. I know it's not part of the getArguments() benefit but I could think about having correlationId in the constructor. By having a real world, I would prefer this initialization of the getArguments() methods to avoid any confusion.
should the constructor do the check here?
I'd suggest to create a static method for VMStatus that's set with vmId (which is not in vmId) and use this code in the test
I think we can make the return type here: Set<Type>>> fields = getType(field);
New to always use 0 here, even in this case.
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData!= null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
this can be condensed to if (!chkAuthorization(...)) { return false; }... return true and get rid of haveAccess
This is an interesting pattern of returning the list ofAccessControlList, not the list ofAccessControlList. I think you can write: java return accessControlList.stream().map(AccessControlList::getAccessControlList).collect(Collectors.toList());
You missed this when calling keySet(). It would be faster and safer to iterate over key.
This can be simplified to: return value == null? Boolean.valueOf(value.intValue()) : Boolean.parseBoolean(value);
Typo: unlockSimpleLockServices -> unlockSimpleLock
no need to call this variable
Can we use a custom object for the associated object?
This should be a static constant.
I think you should return ch.parent() instead of ch.
remove this line
Maybe it would be nicer to return Optional<SessionEditor> here
You could probably use seek(seek(position) here instead of that last read.
Should be renamed to criteria, to be consistent.
either handle cocoa like carbon or remove carbon on the fly maybe change "cocoa" to "cocoa" by separate change before? carbon is unsupported.
Shouldn't we keep the old message as well?
specific equals method
If one of the two conditions is true, why not wrap notifyProducer() in a null check?
Please use getReader instead of get()
Please use Objects.hash() for consistency
declare throws please
please extract the?: operator to a separate field
nit: Can we add e.getMessage() instead of e.getMessage()?
Missing!isAwake() &&!isAwake() as same condition
Why not just have one loop to reduce the overhead of checking the questionNum? java return getNumRubricRows(questionNum).findElements(By.id("tm-detail", getNumRubricRows(questionNum).findElements(By.id("tm-detail"));
You can use fNextStateChangeAction == null to prevent the next few lines below.
Is it possible to use onLoad() instead of calling this
null
you should just do warn
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value to this drug's none coded value
Should we reset the postStop signal here?
Please put ArgumentChecker.notNull(interpolators, "impl"), otherwise the object will be a better error message
Can you put this on the same line as the method declaration?
Why do you need startsWith? AIDL_LAYERS_PREFIX here looks looks like it should be removed. Not sure why it is using the same pattern.
use an overridable getOperationTimeout() method instead
could be replaced with Objects.hashCode(projectUuid, ceTaskUuid)
Do you think this may return null if map is empty?
Should we use JdbiOptionals.findFirst instead?
seems to me that we should use the API instead of the API.
why do we need a printout here?
I think it would be nice to have a more descriptive name, like hasOptionsOptionsOptionsOptionsOptionsOptionsOptions.
This is something that should not be applied to the returned map. The labels map should just return a Map<String, String>.
Remove
Rethrow CompletionStage<T>?
Minor: remove this or use a logger.
Wouldn't it be more robust to use a predefined charset such as UTF8?
optional: can we rename the test to something like boolean[] assertTrue(Iterables.class, () -> assertThat(range.class, () -> assertThat(actual, is(not(-1)))
CCWL.x.kface.js
s/any(vmDao.getAllForVdsGrouped())/any()
Is this method supposed to return a list or immutable list? If not we should return an unmodifiable list and have a copy before the map to avoid a deep copy.
<LINK_0> > I am not sure that wait is required here. It uses [this](<LINK_1> as the waitFor wait button, so maybe you could use some code in the wrong way. The timeout is not too long, and the test is very similar to how it is done in other places.
UUID.fromString() could be replaced with UUID.compareTo(traceUuid)
which is the same as with severity.getIStatus()
we should remove this, printStackTrace();
Could you please give a tip in truth to this: if (fluid.getType() == fluid.STATIONARY_WATER && block.getType() == fluid.AIR) {
index difference?
Can we add this in a separate file as it is not sensitive to the user?
Could you rename baseUrl to getTaskOptions?
Could we add informationEntities?
The need to be synchronized here.
suggestion m.append("BuildRequires(); Cause maven-local-local-out");
Please use String.join instead of parens.
No need to check for the isnon null here, it is always false.
Should this method be static?
Remove this?
No tabs please.
This method should not be invoked before leaving the Overview.
Please use ternary operator here.
What do you think about removing the mean and deleting elements if they differ from null?
return new Object[] { new Object[ptr] }
can you write this and the following code a bit more readable: return dimValue == null? dimValue : dimValue;
Why are we doing this so?
Why not use streams here?
public
This is almost the same as isListEmpty(). I think that's the intention of this test, you should use just assertj's assertThat.
This does not look right. Nothing is totally about a non-functional/toImmutableList. Maybe the next line could be rewritten as: java return copy.stream().allMatch(underlying -> copy.contains(that.collect(toImmutableList())));
same as before, loop 512
Also need to put this in the constructor so we can avoid the final list list.
This date format is used in multiple places. Consider making this a constant.
s/public//
I think this should be setVdsGroupDAO().get(vdsGroup.supportsGlusterService());
There is no need to call cancelLongPress() here.
This can be simplified to just return bases[0] == '.' || bases[0] == '.'
I think you could use Long.valueOf(topString).
I'm a bit confused by this. All the other instances of this class use Builder are creating, but never the one you're using now. A future change would be to just do the builder.
Is this going to be called from after the server startup?
I don't think we need to Encountered old variable msg. I have a weird impact on how you would handle this.
Again, why are these casts needed?
The else if branch is not needed, because it is can't be that it is _also_ not visible.
can we use this(delegates, selector, extractionFn).optimize();?
@dskalenko yes I have the idea why we need to load all modules from this class? This means we should have a single single method available for all of the runtime config and only for the specific sub classes.
why this?
I'm not sure it is the right place to add the new version. It is the old one, why not just pass the cluster compatibility version in the migration?
I don't think you need the null here. If an empty model is returned from the DataObjectRemove/Refresh(), it will delete both the null and the DataObjectRemove/ClosedEvent classes.
'the' is not your fault, neither comparator nor the comparator. The logic is duplicated. If you have anyPLUS wrong, it should be a library, not the comparator.
How about "IOException should not have been thrown."
these methods should be in an Offline mode. they should be in an inactive user, no?
createFromEsriGeometry(new Point(x, y), SpatialReference.DOUBLE) looks like a method returns an int.
I don't think this can be removed since it was done in equals/hashCode methods.
Use StandardCharsets.UTF_8
@Override
suggestion METADATA_KEY_DURATION = new setDataSource(file, file, name, null);
These changes are required a few times, because @AddonDependency now adds an implicit dependency. Try it out.
I think this should be private
I think this should be index < length, index
Can/should we return an empty list?
I would remove the 'null' here
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
Call I18N.getString(String) (there are no parameters in the resource messages).
This method is public
I don't like this, we need to check if the uuid is not null (i.e. do we need to check if the node is not found or not)?
It might be better to make "address" a constant
It could be cleaner to directly use orElseGet.
shouldn't this be checked in tests?
you could return directly
I think it'd be better to use StringBuilder rather than concatenate and use _ instead of +.
I think it's not needed to check value.toUpperCase() here, because the contract is to have the same behavior as if (value == null) { return null; }
getStoragePool().getstatus()!= StoragePoolStatus.Up
Put braces around if/else/if/else for readability.
different audit message for the case only the key was updated is good :)
You already have the RankedAdapterFactory constructor, you don't need to keep the registry here. In fact, the reset() method is already called in the registry registry, so it could be thread-safe that this is loaded when when the RankedAdapter is populated. You could also *also* use the registry, but it is not the factory to load the Descriptor when creating the RankedAdapter.
Should we use parameterized logging here? LOG.trace("Getting file for {} with {} ", organization, url);
Is it safe to put as @ochaloup?
I would move this up to the end of the class, just to avoid the unnecessary intermediate class creation.
Perhaps we can use the LanguageSmartmeteringKeys.id() method instead of the parsing?
you can use StringUtils.isEmpty()
Why skip this if we don't have it?
Returning true would be better, no?
Why are there two methods (one, one for the same) that could be used for the same version of this class?
Could you please revert this change and make Year static?
suggestion UriBuilder uri = new UriBuilder();
Err with addTaskStatus.false but don't you think you need to add an if here?
Can we add a function on the interface String?
What would happen if the state is not a VisibilityGuarded with a RuntimeException?
can you mark this one as deprecated, with the old constructor and in the new one?
debug and trace
suggestion return unitsToKill;
Consider using the lambda syntax: LOG.info("LocalApplicationRunner will run with a APP nor task name: {}", taskName, jobName);
Could you please remove this line? I think it is generally better to read when you read the checksum.
A more specific assertion that simplify would be added here?
this should be a format()
I assume we can remove a warning if it is explicitly logged.
Nit: Would a break if (hasWifiEnabled()) {
Can we return Message<?> here?
This seems like a generic error. Why are you not passing null, please use the following: <LINK_0>
Could you please extract the common code into a method to avoid duplication? I'm fine with this case in the other class.
I think this should be a static string.
This needs to be done before <code>super()</code>.
should have a space before "and"
Why do we need this if we're doing the same thing?
Message here is incorrect - it should be illegalArgumentException.
I think this method should be private, as this method is in the subclass
in case of stackType, you could use equals method.
If we use the enum, than the key types, then it will be more interesting to have a list of supported entries.
Missing final
Please move this into a function to make it clear it is not called from two places.
I think this should be defined in the 'getConfiguration' method. When the INJECTED_TYPE is not defined, the resulting String should be the same as the other.
Since leap-day/year-day aren't part of any actual month, you need to return the zero-before-default values.
Replace this and make the tests use a reference to the OutOfBoundsException
This could also use the aggregateValue. No need to handle the exception.
Personal preference but I don't like the use of the java.util.Objects.requireNonNull
Please move this line inside requireDynamicFBO() - I'd say that it's incompatible with the FBOs.
Can properties be null?
Shouldn't they be disabled as well?
Since this block is used twice, perhaps pull it into a private method?
You need to include the time in the hashCode method.
Need to consider offset + 1
I don't think we need to store settings, can you saved it in private static final?
I think it would be good to be more explicit about the exception type.
won't this return?
I don't think it's necessary to repeat the two checks in this class.
This can be a bit shorter: return getImage().setActive(active) || active == active;
Same here. Couldn't you unlock the repository after the try-with-resources block?
This test is very specific about the role of "ref". I think you can't keep the original code and replace it with Platform. Also please keep the Metadata classes a bit more generic.
The message is in the wrong layer, but rather than the'magic numbers' limit (though I would expect the value to be in the database)
Some else if statements could be merged
Instead of using a concrete HashMap, could we use listener.getLargestPoolSize() here in the next line?
Please have a space between if and (.
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
This check is not necessary as there is already a null check in the command.
you don't need use replaceAll, because above you used normalizeJson
We call listModelOptions.getIncludeModel(this) twice, we are calling listModelOptions.getIncludeModelOptions().
Use Guava's [this](<LINK_0>
Better to use toString() instead of toString()
should it be the other way around and avoid the cast?
Shouldn't we put this in PageView class?
For the light of the contract, how about <LINK_0> if ( channel == null) { channel = null; } // do something }?
Please use Level.AGGREGATION_CLIENT_ID instead of RuntimeException. Failing to write to the log is not good practice.
Please use interfaces where possible.
@vkuchyn same here, why have you changed the return type of this method?
Second condition is unnecessary (checked in while loop below)
You can replace this lambda with the previous one
should we assert null; return Collections.emptySet();?
Static import
Could we assign value to 0 here instead of having to populate the byte array?
Can this method be private?
I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course)?
as with the others, need to "remember" the first via, not the last.
I always prefer setters on the SWT.setDefault methods where they should be private.
I don't know if this can be public, but it can only be used by subclasses.
This can be tested with error message: assertThat(ref, () -> assertNull(ref.get().getDescription(), ref.get().getDescription()))
I would move the actual column name into the 'csv', and make it easier to read.
duplicate regex as above, can we reuse it?
keep this to locked
It would be better to move this constructor to another class.
Are we sure about the null case or empty string is always non-null?
use CollectionUtils.isNotEmpty()
This could be assigned to a local variable for better readability.
Why include these before casting?
empty is valid address.
May be also good to use RuntimeException here?
would this be better called RestApiClientClient?
Should it be the same as the referenceSetId?
should be new DefaultParameterizedType(null, Block.class)
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
I think this might be cleaner as... Optional<FormStatus> form = new FormStatus(FormStatus.class).orElse(null); return Optional.empty();
nit: return new TimeThread<>(this.LineId, fromThreadId, consumerThreadId);
Remove the public modifier, and all the injection constructors should be package protected.
could we name it something more descriptive? something like "isTopologyChanged" or something similar?
missing { }
please remove (as with other logs).
maybe add populate() method to support Collection<LdapUser>?
Is sourceExtractIteration required here?
Please use TransportHeaders.getTransportHeaders()
Initialize to immutable if present.
we can replace that with findAny/findFirst as we don't really need to know those vms
Should we include the underscores in the field names?
Does it ever return null?
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
use ShellIsAvailable
Again this names names are a bit confusing, but why not give them one?
This should be a long.
Shall we change this to "Unable to resolve the hostname of the....". there are few other places as well.
Since init() returns an instance, wouldn't argsjectStatus.contains() be called with the Parameter.NONE check?
why not final?
Not your fault, but could you make this use a local variable instead?
why public? I still don't understand this class. They're not required by the base class. I think you can keep the name of the data file
Why two "else" blocks here? The "if" may be removed.
Shouldn't this do this now?
I'm guessing we're checking the cache type now. Shouldn't we use a.maximumSize here?
Maybe wrap the return value on the catch block?
pull the mapper out into a raw string so we can do something like hasSize=0
This can be removed
Typo here. should be service_type
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
A typo: looks weird
I think we should cache the credentials here, that was a token cache.
this should be this.operation.
Is this really intended to return true? If so, return " printer" instead of null (return true)
Add an assertion on the list before the length?
Could extract this to a constant for the exact purpose
same as above, can remove these two lines
should we use httpProtocolHandler?
String.format?
Do we need String.valueOf() here? Seems like this method will always be called first.
Same here. Don't put final
I'm not sure you can get rid of the CacheEntryNotStore and the type parameter directly.
I don't think it's necessary to synchronize on messages.
* Can we use showButtons() in this method? * getButtons(showButtons)/ showButtons(true); * That's what I think imo :)
xPath are so similar they're confusing. I would rename the list to list.
This should be Collections.singleton
this.tabFolder!= null is not required.
We should probably add the eventReceiverFirehose monitor as well.
no need for the new constructor.
I think we need to account for the actual properties.
Shouldn't this be getTest()? I'm not quite sure about the ctor.
I would move this if statements to the constructor and make it one line with a default value.
static
workflowStateDto::new is a better name than workflowStateDto
I know it's an extra _defaultValue here, but seeing null isn't really a bad idea but seeing null isn't an abuse.
WhyHtmlConstant was started in the constructor?
Assert. startDate and endDate should be copied before [this](<LINK_0>
Put in one line.
if (cursor!= null) {
Please add final to follow Spring Security's code conventions
Would be nice to pull this out into a function and call it from x and y (and maybe have a dedicated method).
I guess this should be an error?
Can you remove this since this is an explicit type.
I think this method should return an instance of UNKNOWN if i is not null.
what about return (selection == null || selection.isEmpty() && selection.isEmpty()) instead of checking null?
!formatString is not nullable
[minor] Empty method?
add a message to the assert
if (isMetricAttributeDisabled(type)) {
Torn down the line, I'd rather see a new RuntimeException(final Context action) method being used in the jclouds constructor.
The implementation of this method should be: private static List< getListFromSerializableCollection> List(Collection<String> iterator) { return Stream.of(new Object()); }
There is no need for initialize in this case - second condition is enough
I would maybe use static import for the whole class, so the test is easier to read.
How about using Fqn and what is the use of a message to compare?
Redundant tap with the same name.
add a warning message
Please put a space after if.
If you always use an Integer here, the check will be useless.
This may get logged as a warning, so it should only be logged as a warning.
IMO should be || u == UseNDT || u == UseNDT || u == UseNDT;
Bad copy/paste?
This is no longer called. Author can be moved from the base patch set.
FYI, can you add a check Objects.requireNotNull in this whole method?
Change log level to debug
just return value
"*to* throw exceptions" I think you could keep the original message and move the exception handling out of the catch. Or maybe the Exception that got logged in the IOException
do we really need this check?
why is this necessary?
Mecise: java return config.withFallback(path).render();
why is this needed? The test should fail by saying quayandand test.
I think we could put the field symbol in callExpression to avoid the override in the visitVariable method, in order to override the correct method name.
Can you use synchronized here? And possibly the other thread calls to check the state of the edit.
This should be public.
can be omitted
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an ArrayList method. (It is quite ugly but hard to follow up with you).
I think we might want to drop the entry. There's a couple of other update methods there.
We should use CollectionUtils.isEmpty() here.
The above code will do this.cached = true; and then the finally block will not be unlocked. It would also make sense to have a lock as well.
I believe this should be like Objects.requireNonNull(masterServices, "hbase.master")
Remove this
Please add @Experimental and @since 2.1.7 - experimental to all of them.
Put result variable in the try block.
The way I understand this is that if the interface is supposed to be changed, all the methods of the interface should have been changed to public.
return this;?
The action and the name is the same as the default and so could be simplified. I think the logic is clearer, so that it is clear what we are checking and whether the user is managed.
You don't need a transaction here
why are we creating this with the default?
This should be private.
Why not call deleteAll() directly instead of making delete()?
your PR, but now you're using the right path for getting a list-based data stores, maybe it's not very efficient. The current code seems more natural to always return a list of (instrumentedFiles) or something, that's only an list of service.
> I am wondering if we should add the class name to the exception message here, just in case. > Class<?> > (not a Class<? extends RuntimeException) instead of Class<?>?
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
I think this could be: return Objects.hash(listDelimiter(), columns, columns, indexed, columns);
This is always true, but there are no backward compatibility issues in this code
Use 'public' instead of 'this'.
style nit: no braces around single line blocks
Can we do try { 'throws Exception' here to preserve the stacktrace?
nitpick: I would prefer to have single exception for throw instead of DIST.
Missing parenthesis.
Is there a reason not to use the <LINK_0> here? I think it's better to use the <LINK_1>, which does "." check.
Can this be extracted to a separate method?
should returnJenkinsJVM.isJenkinsJVM()
nit: you can remove the else here as you return in the if
@dalifreire let's get rid once time used variable
nit: this check is repeated in L1204 for performance (if you want to save a second bit of indirection)
It would be better to check the two reconciler strategy here, or have a null return type.
(optional) this can be simplified to just Mockito.never(): Mockito.never(): Mockito.never() (in this case if you accept a null mock of Mockito.never() in the test)
I'm not sure silent catch is good as after that url is null and it will create exceptions
Why using getAdapter here?
I think you want to first check here not to use a PageViewStateCallback with a appropriate name.
shouldn't be SnapshotStatusOK.StatusOK be used here?
Please return false by using Objects.equals(obj) && Objects.equals(obj, other.getClass()) instead of calling getClass()?
nit: throws
I don't understand this. Why not just get the hashKeyHashIdentifier if its key is null and doesn't have to be initialized with something like KeyHashIdentifier lockKey = keyInSet;
Is it worth setting this to the button status here?
Since this is a CTOR, you should use Util.isEmpty.
What is the reason why you do so?
This is check in the overriden enqueue method. I think this check is extra here.
Could you add a guard check for isDisposed()
Should we keep a reference to the Bundle here?
delete tempTempFile
I think you should use Pair::toString() here.
Please use lowercase as it refers to the argument: disposables is null.
Use static strings.
Perhaps try-with-resources? And then the close() below will not throw an exception.
should this have a final field?
Let's put all this in the field declaration
please move this to within try
Formatting
What about this.public boolean isAnonymous() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication().getAuthentication().getAuthentication().getName(); return authentication == null || (currentUserHasRole(AUTHORITY_USER) || authentication.getAuthentication().getAuthentication().getName() + " is null"); }
Text is slightly better but I still think it is better to use File.separator instead of /.
Can you please make this variable also _protected_?
Maybe it would be better to use @AfterClass method which is used in other places in the test class.
"Max number of models that can be trained for this account"
I'd probably have this check inside the DataModel class, since the current event is going to be reset to a different user (and that could have a different View, save, and then override that.
should you have this method at the top of the file since you are ignoring the result?
<LINK_0>
It's better to use seleniumWebDriverHelper here
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void getTokenShouldSetToken() {
This is a nitpicky, but in the other words add a method called DEFAULT_FILE_EXT or DEFAULT_FILE_EXT, it should call this one.
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable?
You created forks and created forks in MkForksTest, which is not correct
the isImagesAlreadyOnTarget method is not needed anymore. the 'isImagesAlreadyOnTarget' has the same logic. Please consider to call it from here and extract 'getVmTemplateId' to a method.
Can we make the SubjectCache static and remove the default CacheFactory.CACHING_PROXY.
Fail the client with the default request endpoint name.
Can keep alternativeCache and the field name for both: java.put(countRelationKey, getSchema().get(), getSchema().get());
Throw an exception instead of returning null
Ditto, but since this is a standard library it should be deprecated, please use a StringBuilder instead.
You'd still want to tear it down. How about using a straight-forward if-else?
I think it should be more general. If @rskonn54852, I think you can add more types for ExperimentTaskResultRowMapper after a merge.
You shouldn't expose a static instance similar to how it's done in timbuctoo-instancev4/src/main/java/nl/knaw/huygens/timbuctoo/security/dto/Login.java
Can we use the default value in the refresh method?
I'm not sure we can have this code path, just check the code from VERSION to CODES.KITKAT implementation. It's a bit shorter and more readable.
shouldn't clusterId be null?
Shouldn't this be a field so we don't have to create one each time
@manuelplazaspalacio why do you want to move this line back to the new line?
Should we use the field in the first place?
Very minor: this can be simplified to java BigInteger capacity = BigInteger.ONE.shiftLeft(length); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); if (signed) { BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); return BigInteger.ONE.encode(BigInteger.ONE); } return BigInteger.ONE.encode(BigInteger.ONE);
Is it the same as the one above: > And it is "public RemoveWatchesType remove(String esType remove)"? I usually do it in a method of the "static" constructor
No need for try/catch here.
CONTACT_US_SUFFIX may be not always returning a URL.
I think we should move the request to the end of the method. If we break more than one page per page, it will be easy to read.
Missing "0000".
I am not sure the logic of getting a FileDueToThrottlingContext(false) here is really intended to setup a concrete implementation of Manager.stop(true) here. Any idea how that could be related to a regular environment instead of a concrete implementation? If the user of this code is requesting a concrete implementation of DueToThrottlingt and thus can interact with the extension.
Can you write createConnection() instead?
not sure why this should be in the same SanitizedText?
It would be better if you rewrite this like isQuery = isQuery? p.explain() : parameters; and take care of something more generic
This should be a WARN since we're not using a valid value to retrieve the new value.
suggestion ifGrowGrowTime(root, vineComponent.length < 20). Could also have a single space character
Is this really a good idea?
Add the stackService as the last parameter of terminateInstancesWithoutInstanceIds or something like that.
Please add at least of project in order to check that the result is empty because it return an empty list
use a final string, not a value.
Can the chunkCounter be null?
What is the reason for appending one instead of the above?
Should this be the same as this.public?
getAndIncrement() should be replaced by just ctx
tracker is not thread safe
maybe rename to IPV6_MIN_MTU
a bit more about this.failfail() message should be something like "Should have a valid schema: " + 'p1', \"p2',...);
Use a ternary operator instead of a condition to guard against null value.
Maybe we could return symbolName.estimate();
I think we need to do this in the IntegrationContextUtils.getEvaluationContext() implementation, because we don't deal with the bean's context.
I would suggest to use [this](<LINK_0> here.
Make this the method @Deprecated, and return the value directly
This should be the default filter param to singleMetricFilters.
Error message "layerGroupId == null"?
Use constant variable for re-use
why would you not callvoidExclusiveLocks()?
Exception again
@baStopResponse can you drop the return keyword? We're using String.format.
IllegalStateException is a bit misleading
Can we put this errorIndicatorValue = errorIndicatorValue.checkNotNull(key, "The errorIndicatorValue cannot be null."); Configuration errorIndicatorValue cannot be null.
uploadItem1 does not need to be public
Nitpick: return this.replace("[a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}a-z0-9]{16,}{type}. The defa-z0-9]{16}a-z0-9]{16,}a-z0-9]{16,}{type}. The configuration of this class would need to be considered public.
could probably inline, won't be null
options.setDefaultFlowStyle(datanode, options.dump())
I think you should keep this check because it's not missed if State uses StateMonitor for other reasons: 1. We want to use unregister(null) 2. This is done by mLock before we can set mLock to null.
should be able to revert this change
Can you please apply this to the PR description and make sure it's the right type for job name? The old job name and hyper-net, the new job name should be set to the job name, and the new job name should be set to the old job name, and the new job name should be set to the old job name, and the new job name should be set to the old job name, and also on the new job name.
This should be wrapped in another RuntimeException
Maybe we should keep explicit assertionPlatform.values() method to replace testPlatform.values() by assertPlatforms.containsString(System.getenv("SKIP_GENERATION"), so we don't have to do this automatically.
Can you also add the RATE_MULTIPLIER in directive_MULTIPLIER to Key_MULTIPLIER?
Don't you think that this line is necessary?
return openFile()?
Let's only use DsfDebugOptions... as mentioned above
isn't parameters already passed in the exception?
nit: return findAndDelete(query, options) >= 0;
The name should be printWriter, not used outside of the loop
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
what happens if there is an assert?
Maybe we could just always return true here, right?
I think the arguments are reversed, the constructor does nothing?
Should probably check it?
"A fault zone cannot contain more than 1 replicas"?
you import ByteBuffer, no need to use the full package path
Assert.notNull here
Need to go with an empty doc.
please just define on the next row.
You should not add the error. Consider logging as warning.
If this prefix is not a specific one then we should have a separate "String" method
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
Why not make this private?
getIpv4DefaultGateway() already checks for null and it is initialized above with the toString() of this.getHostName() here.
I think it should be that this variable is unused.
I think it's better to use original method to wrap the original call to an existing method that does what it does, and remove the original one.
use an overridable getOperationTimeout() method instead
I think you want to use setClientAuthenticationMethodAsString(auth) here.
is there a reason to check for domainNamesToRemove. It would be a little more clear to me that domainName is a substring of the domainName check is a dash
What happens if you just swap the arguments? Does it make sense to throw an exception?
getClients(this, null, null)
nit: not sure if we want to keep this.retries, what does it mean?
Use Guava Iterables.any?
Single statement per line.
I think we can add the value of the merge result, which will be much easier to understand. It is on the diff that the code duplication of the code.
In the other files we could use Locale.UKNOWN or Editor.
Consider using a lambda here?
duplicate method
Can you replace this with the lockSemaphore.tryAcquire method
Wondering if we should have a metric for ignored param here instead of setType, and then call the function with these arguments.
exception does not need to be caught.
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
sprint %s
This is the root of the view class. In my opinion this is more readable.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
Redundant 'this'
nit: Let's use assertThat for all exceptions. It is easier to read the better
I would factor this out into a separate method, and call it twice. The null check is already done in the if (humanTpService!= null) block
I think this could be done quite often. Could you pls use Objects.requireNonNull(tableId, "Added table ", tableId) instead?
Lets use kernal.activeResource()
What if we don't want to set it? How does the UI know that this has happened?
consumer.remove() is called twice, might as well perform this consumer for consumers.remove()?
You should keep this public and the implementation should follow the pattern of this.
The async client should be closed.
I think you should continue to merge the three lines into one single method returning early because of the two new commands
why need to log here?
Should this be printed out in a finally block?
missing {}
Please remove this catch and add the following 3 catches.
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds?
You can use ExpressionUtils.methodName(mit) for that.
please revert back this change and implement the required method in entity api if required.
nit: i think we could create a private helper method for this, like we do on the other places.
if we use the setEnabled above, we do not need this flag.
Would it be possible to define this as a constant at the top of the class?
unnecessary cast?
Looking at these 3 lines, you could extract you to a method and use that for the serialization code: final Output output = new Output(baos);
looks like we can do it in one line
One question here is whether it's a good approach to pull the code too? LC could get called get tagged with ImageEntryActivity and we'd get a plain ConfigurationActivity from that. Any suggestions/makes on the codebase to perform this check.
I'm not sure if we should leave this as is since it will add the "while" to the debug message
Move this check down to the top?
Why not initialize all of those constructors in the constructor? This way, you can remove the injector and initialize them in the constructor.
please remove TODO to add the following TODO: 1. do not use the target/template in the current patch
replace with: Mono.when()
Can we put this above the if block? I agree this is more succinct than the getInstance method.
Shouldn't this be inside the if?
if this is _ideal_ we have a method in CoordinatorAs(), it has to be used multiple times.
When will the student not be an instructor of the student?
You could give a CacheEntry as a parameter and use it in the cache...
A ternary statement is fine here.
Is Context.getPermissionsManager().getServer().getDistanceUnit(...) sufficient?
Redundant "factor" -> "cluster.getMessage()"?
IMO it would be better to use the builder pattern to check a isInitialized() here, instead of just checking its existence. I had to do the check there, because it could lead to unexpected results.
This is unnecessary. It's not used anymore and can be removed.
MetaTypeService and BundleContext objects are used for if statements.
@nvazquez you can make this more functional by replacing lines [33-21](<LINK_0> with java.lang.NullPointerException at com.google.common.base.ObjectsJob.safeNotifyOnLinux(MySiteDetails.java:113) at com.google.common.base.Preconditions.checkNotNull(n).
I'm missing something, which looks like a hack. However, does this method have any effect on the access of the attribute attribute? I have to read it to get it for you.
Why do we need a cast here?
space
I thought it was ms
please show me a new line.
nit: this.id = id
Same question as above. NumericBinding
This should really not be public.
1. Why not use Objects.requireNonNull(listBox)? 2. Why can't we use Objects.requireNonNull() to log an exception?
Are you sure about this? Its not a leaf standard and it is just the code base
I prefer to leave this as package-private to avoid a synthetic accessor.
hash = hash;
use the getter as well
Please remove this (and the following line) - this can be written as: if (prefs.getFeatureFlagID() == PrefKeys.ID) { return the map; }
both alarm and dataone are the same
this can be a single return statement
rename to action
A read-only iterator is missing here.
It might be better to declare a constant for the scannerThread and use that here.
runAsync is already implemented. You already have access to runAsync
this.public SecurityConfig() or copy constructor over the Set.
You can use trySlice for convenience method.
String.format() isn't needed
Implementation of this is not the same as the default one. Any reason? is it required to use ''?
can be static
Avoid the use of Objects.requireNonNull(path, "The normalized") and trim() are not necessary.
that's not exactly what is error thrown.. Can you make it "not found" instead?
This is a test.
nit: Now the methods are testing the same thing, consider asserting an expected entity (e.g.,'mock'). Lets check the methods for the objects. And when they return the same type, they also know which object are being returned from the method.
use strings like that, e.g. "nameDFNameDialog.apply(idDFNameDialog.apply("idDFNameDialog", buttonName), errorDialog);
same here with timeoutFactor
Change this to java for (JenkinsAdministrativeMonitors : Jenkins.getDisabledAdministrativeMonitors()) {
could be simplified to...equals()
Consider using a similar formatting like <LINK_0>
We need new File(temp.next(), existing code, it is always easier to read.
I think theSINGLETON value can be null, not an empty list. Is it really only to annotate the object in a static initializer by the class?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
This class is still beta--I would be OK just making this method non-static and using the registry
Could you explain why this actionContext.getEditingDomainForContainment() is used just for the sake of conventions?
Can use validatePrimaryLanguage here and below.
Can this ever happen?
Is it the same as getValue()?
This should be part of the public API
Could you mention this as well?
I think this method may be final.
Maybe use the version with parameter tasks instead of the DEFAULT_SDK_VERSION_CODES. DEFAULT_SDK_VERSION_OF_TESTING_DEVICE?
It seems like we should remove vanillaed too here.
My guess is that the constructor of ValidatorFactoryImpl is cleaner and it will also be used to clean the new constructor in this case. I see it similar, but I don't have a getter for the params to be honest we don't have to remember to call the factory. It's also a bit "factory". In this case it's cleaner and the new constructor will nicely add "public".
isPaused actually needed?
I don't think you need the extra + necessary.
I am not sure why you want to make this public.
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, Integer.toString(int) }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
Is this correct? It's the normal way to use the attributes from the Hierarchy object rather than its implementation.
I'd suggest using the FactoriesProvider in this method, as it's the one I don't want to override anything in the future.
I would do this as it is just a single field in AdminkClient.MODULEkClient.createTopic(). This may lead to some confusion in the future, but it does not really matter.
Could you also expand the URL for the ID checks.
Line wrapping is a bit odd here, could we avoid: Assert.assertNull(i.getMessage(), "Expected null value to be null");
Since this callback is only called from the listener, I think we should use a listener.
@andreyl nice to use the card type name here too
synchronized?
If this fragment is a simple replacement, you should probably use filter instead of _result_ to avoid creating a new View every time.
I think it's better to make this a containsKey() check before calling getName()
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
Can this be a bit more concise? And the same below
Should this be on the same line as the log.isTraceEnabled()?
I think the strings can be replaced by allOf() and should be good.
You can just call getWakeLock() here.
This isn't needed
Ah, I think that the 0s should be a constant.
Do we need this? The old method is not a good way to implement such an interface.
I would prefer if you can use -1L here
I would move this check into the checkNotNull
This condition seems redundant - you can just return the buffer == null.
same question as above
Don't return, just do a continue so other modules can still add their state systems as children.
again.
The code should be: if (urlIndex == null) {... }
Can we combine these three into a single line?
Could we use == here instead of startsWith?
This should go before the line 44 of line 160.
This should be replaced with a guard method.
This is repeated. And I wonder if it would be better to have a static constant for the rest of the retryPolicyExhaustionCause class.
We need a case where we dont want to clear the session since what we code those will change.
I think 'lockHostDevicesLock' is a better place to handle this.
Possible NPE here in case the try is not initialized.
Could you please move error message here?
Should we have this constructor?
@manuelplazaspalacio I think there is no need to log this, right?
Not sure if you can rename this variable.
better to have fail(); in the onSuccess()?
I think it's better to use fail("select * from ") here
Nit: you could use diamond operator: new ArrayList<MainType>
Should this be getNonNullRequestParamValue?
Please use the getName()-method instead of hard coding the prefix.
Why do you need this if/else block?
FIXME: This always returns 0.
This is not thread-safe, but you can simply remove the count variable and the set directly return value.
why?
Why do we need a super constructor?
Could you please explain why do we need to delete a container and a key, it is not deleted from the queue?
The spec says: As of JAX-RS 2.0, the participantStatus is still a local variable. We should still keep the same fix here.
Can you use logger.debug or trace to use the exception?
@ekondrashev > I'd like to see this constructor being used here, same as in other builders.
why have we use this map?
SwarmProvider doesn't know about, so this should probably be a config object, can we do: java ImmutableStorageProviderFactory desiredProvider = new ImmutableStorages(ImmutableStorageProvider.toString(), ImmutableSet.of(storageProvider, null)); if (Objects.isNull(storageProvider, storageProvider)) { throw new SwarmProvider( "url"); }
You are doing this by using a static method to make this method more readable.
Should be in a field declaration.
Should not be cloned
Why don't we just throw the RuntimeException? I don't see any specific reason to do it here.
Exception is never thrown.
In this case, we're going to remove the null check, if this has been added, we should do this.
Good idea. I think I'd rather we have a try-catch with the 'void' flag (or remove') almost all groups, and/or skip them.
I don't understand why you are doing this here. The logic is getting close from the producer isn't used for the partition object, but not for the partition id, is that intentional?
How is this expression different from "this"?
... encodings?
nit: merge with previous line
revert
Stringtt need this
Please check here also - require require non null checks
couldn't just be initialized with a single check here, since these are internal checks and already guarded by the get() call?
style: s/fsroot/fsroot/
Is there a metric to add this to runAsync()?
while toString() this :-)
Should we have a final bp = new AbstractBackupPath(file); and do the check within this method?
new indexed loop: new  wordCount is not used.
I guess this will be called defineClass above but not every time we call the method to get the Compression signature: We could have the constructor that takes a ClassDefinition<T> and call the method from here.
I shouldn't be magic numbers. Maybe this can be configurable? <LINK_0>
The two assertions here is a very long and easier to read. testNullPathWithRoot() is a very bad part of the code.
A better approach would be to add default setupListViewAdapter(...) to the view
reverse the second so that we don't need to copy
Asserting here if it doesn't match rather than silently ignore errors might save someone some time someday.
Isn't this the default value of the gw parameter?
nit: ignore case for config
I recommend using UnixResolver API, ie ImmutableList, and for Unix streaming, we don't seem to be able to provide a default charset (as that would be more flexible).
Should use a named constant for the name.
@lorobode Instead of duplicating the code inside these methods, you could call the second param null on the second line here passing null for the second param!
This seems wrong/redundant. The check! can throw an IOException here
nit: space between if and (
Need to be consistent with equals()
Add this.setTimestamp(long timestamp) to be non-null so that the setter can be set in the constructor
Is this persisting the update message state? If I originally wrote this entry, then I think it would be more appropriate to update the json file rather than the view.
extra blank line
Redundant permission, because the field is mutable.
use java.util.Objects.hash()
Shouldn't a cast to int be enough?
wait, do you have a better description for this?
@vmaletta add final
Why the need to test this?
Probably fail the test? Also please log the error.
Please add LOG.info("Source task attempt {} received at {}", attempt, attempt);
I would extract the updateUsernameChangerFragment into a function called something like isUserInitialized which is more appropriate.
To avoid code style changes this format is incorrect: "an abstract method with the parameters Reports errorReports"
NIT: I think we have the place where it is deleted.
Can we move this logic to a separate class?
why we need to check for getQuota==null? I don't see the usage of getParameters().getDiskInfoDestinationMap().get(diskImage.getId()) in the canDoAction message.
don't use a constant for this.
nit: this can be private?
Why change this?
Catching Throwable instead of just RuntimeException would be better.
please make sure you are rebased. this method was renamed on Feb 11.
This should be a nested if-else block, so we don't repeat it every time.
We should make this method private since its part of the TsBoundSortEnabled/TsBoundPersisterConfiguration attribute
I think I saw this line before, if you are going to create a new directory. Make sure the file format is correct.
Can the strings be switched with this.azkabanObj1 =>azkabanObj1 || strings.xml
nit: can you put the null check on the next line?
are these kems used for naming? I don't think it's a good idea to use the parser library here, in this case I'd prefer to have the kem term parsing logic only in kem is the whole program itself, not in a single program. In other words, it is a syntax that we have no reason to go for it, so I'm fine with keeping this.
... I don't think this is necessary. Let's discuss about it.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
It would be better to have a message saying "Failed to close the client. Host is not able to connect to WebSocketError".
isn't 1 or 2?
reduce to debug
I don't think we should use the assertThat and the error message here.
Why not use an Iterable here?
I'm not sure what timeout value actually does.
can use 'else if'
This switch statement should be in the switch.
Let's just put this in a synchronized block to avoid the potential concurrent hash map.
In onError or onDeletePlayer, we should show error message to the user after they are unable to get the player and he is able to look at this class.
Check if the bit is open in the new connection. If not, throw an exception.
I'm not sure this is going to work properly with this uniqueId. The internal state of this class is a simple contains() and I'm not sure we want to create a new instance for this, or have we considered a reference to the "Holiday" state. The uniqueId is the internal state of this class so that this implementation would never get executed. So, I think we should create a new instance of uniqueId in the internal state and use it to create a new instance for each check.
Also add message for the exception?
should we log to warn?
Shouldn't this be Ensures instead of getClass().getSimpleName()?
I think you can make setupChildren() private in the test class. And create a protected method in the Presenter whose implementations can override the default methods.
nit: should be called Capable canUpload the same for the non-standard git state
Please revise this statement
Is this going to be fixed? Could you change it to a logger instead?
This is probably wrong here, since you allow the item to be of type {}. But, if the item is not supported, item.
Shall we make it more readable as: String p = context.identTableDefinition(); context.identation();... ident
what about having the default method here? (I assume that this will be converted to a Java 8 lambda, so a new object for Java 8 is probably required).
Couldn't you just do System.exit() with the default value then?
I'd prefer to make this protected, as it is part of the public API.
I would suggest this to have one return type of some kind of constant, it will make it easier to debug.
Missing a bracket.
Shouldn't this be stream()?
is this method used for tests?
Why not Thread.currentThread().interrupt()?
Why not call the return value in the catch block for delete?
Check for null "" first.
This is super minor but you can use a variable for the action.
See isAccessible()
I would rename this to secondDiagnoses, as it is not an Encounter object
should be false, true?
I would remove the for loop here, since the addedNetworkAttachments call may remove the extra network attachment and the removal of existingNetworkAttachments, which is not the same.
This method seems to be missing a test case.
I found a bug in Presto.but not clear to me. I see that this check is needed here. And for long isNull (though I would always have no idea why). So, I think we should just always check for nulls.
I think we should update the logs here with the user preference rather than the the behavior of the user.
Revert?
Should be user.getName()
As the assert is not null in the order and the asserts are redundant, I think this could be assertNull
can use boolean parameter to avoid NPE
The following two test methods should also be executed in the [createUpdate()](<LINK_0>
Do we need this?
I saw this code in the app, but when I asked to roll back and it twice, I thought it was intentional.
This throws an UncheckedIOException. You probably want to use closer.register(() ->  UncheckedIOException.close())
Can we use StringUtils.isNotBlank here?
is it the reason for the test to return false?
I'd guess we can use an ArrayBlockingQueue, as in the constructor is not a good practice.
The /..*-with-resources-and-value are the same as the other one.
In Java, it's better to use Jackson (JSON) library here.
We have constant for this type: "mobile:mdunit"
The test method says that it creates two lists for one patient but not for one. Either you should check the result of the returned list and return them over 2 or null lists
Could use Objects.hash()
Can we use the Locale.ROOT to not worry about the charset here?
Should this be catch instead?
1. let's create JaxbJobReader and keep using it in the class itself for the constructor. 2. AnalysisJobRunner(InputStream) to create another class with given that the name does not need to be re-initialized with the set, when opening the class, the object will be re-used.
you can use String.format here
why we need to synchronize here?
Why these magic numbers?
Any particular reason that you published an Igneous Cluck? Remember that Dir uses the same config file, though.
Is this fixed? Why not use the default cal-tra parameter?
These are not necessary - the next test method body has been setup.
Add final keyword.
please use FileOutputStream instead
Optional
I would say that this would be a better place to make it more clear.
did I miss something as the method signature all fine? seems like it would be a better fit for a single IncrementableEntryVersion.incrementVersion() now that you have a non-IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
I think we should use Util.checkEmpty(length)
RESET_INSTALLPOINT, and getMarkerMessage should fail if setInstalledLineNumber is called on line 160.
The constructor should delegate to the new Path("file:/ ") method
Is it necessary to have this here?
there is no need to create aagreement from this line
It seems like this could be replaced by: java Set<String> mergedFields = Collections.unmodifiableSet(subFields); if (field.getSelectionSet() == null) { MergedFields.setMergedFields(subFields); } return newMergedFields;
Can we use the isEmpty() syntax here? java if (tail.isEmpty()) { return false; }
Should it be a LinkedHashMap?
java.util.Objects.hash(helper.getDeletion(), this.helper.hashCode());
Might want to strip or trailing whitespace.
nit: keep the order consistent.
nit: keep the order concise, and move it after the borderNodes
exception could be improved
Please don't use a local variable for this (line 98 and 21-64), the usual method for this would return a single value
Imho you may have to add a new method called on AsyncOperation to flush, like you can add a boolean to the 'performedWarning' and drop the 'else' clause.
I'm not sure that the correctness of this code is safe. Let's use the DbUtils.separator instead of this.
I guess this is OK, but for future reference, it is better to log the exception.
you could use constants from getField
java String courseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(courseName1); return desanitizedCourseName2;
maybe you should return a specific value instead of always returning null
I don't think this is what you want. Put the null check in the previous line.
nit: > 0, so the default behavior is to be consistent with the other implementations.
it doesn't work for multi reference + complete tests please.
Could you please use another name for this assertion? It's a bit strange to have a test.
it's better to have the viewer.getParent() as a parameter?
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
other.recipient_id can be null if it is not a OSCoreCtx
This is similar to Decryptor
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
I would use conditional on the digest like you did in USE_CACHE_MODE_LOCAL
Do we need to change this? It seems that you have a long time during construction, right? Can't we just get access to it?
here, we can only do if (costFunction.add(costFunction.add(costFunction))
Is this a static method (e.g. parse()? )
Should this be assertThat(conf.loadConfiguration(), hasSize(1));?
I don't think this is right. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
Change this to a single log statement, stating if the script failed to stop job with a null job.
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
Integer.hashCode(inputOffsets) will be the same as this.
do not use getters; just return in the middle of an appointment
If you have a lot of these methods, this method will return null if expires is not set. If you are sure this is the case, there's a null check before.
Can't we use Flux.fromNullable to avoid null checks?
Can be simplified to this: return invalidConfiguration
Same question
Can we please throw an IllegalArgumentException when the timeoutMs is greater than 0?
Why is the second possible mismatch between the results of expected?
This method should check for null just in case.
Maybe this.map(field -> REQUIRED == field.requirement)? Arrays.stream(q -> REQUIRED == field.requirement).map(this::requirement).map(this::requirement).collect(Collectors.toList());
I think this should be sanitized for start and end of the test to prevent confusing logs.
wouldn't it be more readable to do attributeList.size() - 1?
This seems to be repeated in OlaconnectionManager. Can it be refactored to a call it?
should use listeners.add(listener) instead.
Can we use MockProtocolServer.startTransport() instead?
negative logic
I'm not sure why this change is needed. The test only include the change of the segments isn't necessary.
I think we can simplify this code by using T value = Util.fixEmpty(value); if (value == null) { value = ""; } return value.toString();
.s/private//
We should not throw InvalidSettingsException, this way it's a fatal error.
Log and throw.
I think that the only thing that can be true is here is to put the test passing. I think it should be even done in the @Before method
Should this be in the constructor?
intellij suggests using streams/filters here.
Maybe add this check to the param in the exception message?
This can be simplified to return getSnapshottableDirListing(snapshotRoot, snapshot.getSnapshottableDirListing()); as the original code doesn't have a the logic to get the subnet.
style nit: we're using braces around single line blocks
.equals and fromGetter can be null safe.
Could this be private?
Can we check that there are other modes if we have to make changes in the future?
remove the use of the parameter?
Can you use isEmpty()?
Please remove this so that we can have a better name for the folder name.
Is it a good idea to use the constant from Character and add it to KIE_SERVER_MODE or something similar?
Can we remove writeLong(k) or use primitive int?
It's better to wrap with.deferMessage
should be ast2.setType(TokenTypes.IDENT)
Could be simplified to use Optional.ofNullable(groupName)
This seems to be a copy of the map, but it is not safe to use it to grab the map of the properties.
I don't think it's correct. the.isEmpty() check is required (the number of checks in this case)
There's a lot of duplicated code here in the test. I think you can extract a private method that does the null check and the null check in the test.
We don't want to use dynamic parameters for these kind of values, do we need to override these?
use this here, Collections.emptyMap() is enough
should it be ArrayList?
static import
I think this can be improved by checking for a size of the newArray object first and then adding it to the first ByteBuffer. Could you check the methods found in the current position and see if the first byte are the same?
linuxNameToOS would be nicer, even if it's not supported.
I believe it would be more understandable to do the following: // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Should be Override
URI instead of URI?
This is confusing. Where does it come from?
should we just use SVG or Collections#addAll()?
Please don't use lazySet here. It is only used in old code where it had fields.
I think you should add this to the remove method of put(). It will add the same update twice, but the remove method is not added in update() method. In this case, it would have been better to offer a remove(this) wrapper class and add the remove method of put(). Then add: @Override public void close() { if(!this.isDone()) { count = 0; } else { count = Integer.MAX_VALUE; // use ConcurrentMap.remove(this); } }
Please use diamond operator.
Should return getDescription()
this should be copied to the top. Could throw all these.
don't think this should be delegatingResourceDescription
use Files.newInputStream
Should this be a switch?
What if the key was not a ReentrantLock before? If you want to use it, then you can use getLockForKey instead.
This can be simplified to return networkSettings.isNull()
Enforce immutability. Also, as the data itself doesn't make a difference right, you should always return Collections.unmodifiableList(hits.size()); in the underlying data object rather than constructing a new immutable list.
Can regName be null?
use the default constructor which does this automatically.
switch on enum constants?
Can we use generic exception here? It's a RuntimeException already in this class.
Please add the type to the Map<Startpoint>
No need for public.
Remove unnecessary this
This seems to be obsolete
It seems like this should be a no-op as the id of the entity manager.
Should this be containsKey?
return only if there is an computeIfAbsent?
Think string is better to add method name to VillagerEntity.
Why false is used here?
Again we can use ArrayList for the list.
why public?
Ternary would be easier to use.
Is there a way to do this using replace(Base64.getDecoder().decode(base64.getBytes())? The advantage of doing that is that the Base64 encoding is different from the underline 24 (only the return value).
Could be replace with StringUtils.isNotBlank(text.isBlank())
Might be worth having a displayName?
mSignatureBitmap is null and mSignatureBitmap was set to null. So I don't think this should be null?
this doesn't seem to be testing anything.
Can we put the url in a variable? The url could be passed to the triggerConfigURL
So this allows an env prop to enable a feature that is not configured? Is this fine? I'm just curious, unless I'm missing something.
suggestion LOG.error("Failed to pop the queue of "+ counter.get();
Just an FYI, I'd put COL_ID_PROCESSNAME_PROJECT in constants, and I think it's better to use Map.of() (if key_COL_ID_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME_PROCESSNAME) instead of ArrayList.add("Actions_ID_PROJECT");
This should return Task, not Task.
Maybe we could use the constant here?
I think this is not necessary. We don't store the result in the metricAttribute.
[minor] You can remove the System.currentTimeMillis() here, since the constructor already does this logic.
I think this is not enough. If we go with the metric name, we can update metric and use both metrics collection.
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return statement.
IndexOutOfBoundsException
i would rather add theRuleName annotation here. It makes the rule instantiation more more accessible when the rule isRuleName.
We could also use this.data to be consistent.
we shouldn't be calling userkeyPreference.setToolTipText(url); the user store.user.url
What would you mind about the following? java SetViewClass<?> aggregateClass = flatten(a, b); return aggregateClass;
I think it would be better to use the builder here instead of a real index, as we are not changing the first character position for the content.
extra space.
singular
I don't think it's going to be enough to just return "show" instead of "hidden".
Can return null
this field name is confusing since the parameter passed to the constructor is a File but this is a PackExt. I would expect this to be a PackExt, and have the class name use it here instead.
There is no need to call super explicitly. Same applies to other constructors.
I think it will be better to create the corresponding recipeFileContentProvider instead of calling RecipeContainerConfig.devFileContentProvider.exists() : java @throws DevfileRecipeFormatException public DevfileRecipeFormatException createWorkspaceConfig( DevfileRecipeFormatException, DevfileRecipeFormatException, DevfileRecipeFormatException, DevfileRecipeFormatException, DevfileRecipeFormatException, DevfileRecipeFormatException, java RecipeFormatException, DevfileRecipeFormatException, java RecipeFormatException is IOException, java RecipeFileContentProvider.devFileToWorkspaceConfig(devfileRecipeFormatException, DevfileRecipeFormatException, DevfileRecipeFormatException, java RecipeFormatException, DevfileRecipeFormatException, not java. DevfileRecipeFormatException, because it will also be thrown in java, not java. DevfileRecipeFormatException is the right thing
Could we use Message here?
This test checks topic creation. Why do you call replyTopicStubs?
Should it be!JavaVersion.class.isAssignableFrom(major))?
Maybe we should use a more descriptive variable name?
Leverage on Files#exists and Files#isDirectory
Why need this change?
same here.
Did you take a look at this? <LINK_0>
Looks like this can be simplified to : java return pageName.toLowerCase(Locale.ENGLISH).toLowerCase(Locale.ENGLISH).substring(1, pageName.length()).toLowerCase(Locale.ENGLISH);
This could be made more compact by assigning the options parameter directly, and then returning a Collections.unmodifiableList just in case there is no one.
@fanifieiev put the same content to share this in the same local variable.
This should be done in OnChangeProgressValue, not on the local table.
I would prefer assertEquals() or assertThat().isNotNull() but that's more informative
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
I think we could simplify this check by taking the boolean value of the securityLevel class and a String.
Following the implementation we're duplicating the lock here. (Ronce we have to read a lock once and reuse it for all the time.)
If the repository is null, this method can be called from more than one place.
This method is not thread-safe. I think it can be done with write.
just curious... why would we need this method?
can we do this only if debug is enabled?
IMO, it's better to name the list first and avoid a confusion :/ )
It seems like we should introduce a new method here that accepts both currentUser and securityAuthConfig, wdyt?
Same thing here, we can avoid the loop if the reference is not null.
The max number of events > 0, so maybe we can just pass a 60 * 60 * 60 * 1000 to avoid delaying the max length.
Shouldn't this be new SecurityExpressionRoot(SecurityContext)?
Is it required?
Are you sure that it matters to be working?
I think that innerList is an internal class, so you should not have to use it here.
No need to use static.
Why the previous line? I don't understand why we use a string. For example, suppose there is no exception, that should be the same as the original exception.
The switch statement seems redundant.
Be careful here. I see that you have very good reason for this, and the previous one here will end up with two Setup operations: 1. You have two options here, one for better user experience I think. 2. you have also "String" in xml file, use this instead of spaces.
Why was this change needed? This test probably wasn't supposed to be necessary.
please move expression in parentheses to make it clear that expression is not always true.
We can simplify the logic here to just "return boolean. true;" without skipping "if" to determine whether the boolean is false.
The exception could be warn, so the message can be more useful.
suggestion "The future must not be cancelled.");
Is there a reason why this can't be done with printout?
What is the purpose of this change?
This constructor seems the best use the new constructor to call this(public)
Please use a logger instead of System.out
By composition, do we need this?
OOPS!
The second parameter is the sash view, not the sash pane?
Can you please revert this to the next PR and fix it tomorrow when both channels are different?
I don't like this.marshalSingleMessage. Let's make the squash the common location.
should probably use a custom Url builder to create a FormValidation.
space between ) and {
Please replace the assertRequestObjectType with a proper message.
Would be better to throw IllegalArgumentException here
Do we really need a check here?
Should throw an exception with valid = true;.
Can you just use id.getObjectForNodeId() instead?
Why the set?
wrong formatting - every parameter should be in new line
This synchronized is unnecessary.
nitpick: change this to FinFSState.newAccount().
Should this be done in a different PR?
Why does this method need to be called from the registry, which means you could have  registry and getStyle()?
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
Can't we just do return instance.values().orElse(null); here?
This one can be static
you added synchronized to the method here, wanted?
@vrushaliwaykole @dhanasp -- There is a null check inside updateWorkspaceEntity() method and we have one in there. Is that really required?
same here, perhaps globalId should be renamed to lookup?
Why not add @NonNull for all these arrays?
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
And this one
I'm not sure we need this. I would prefer to rely on the MethodInvocationTree constructor, so you can directly do: if (!visitedOnly || thrownExceptions.stream().anyMatch(c ->!visitedUnknown && thrownExceptions.add(c))
suggestion territory.add(new Point(1, 2, 3, 0);
Please use a Typo in variable name.
This has to be a problem on this. You have to look at the command line: DiffCommand diff = new DiffCommand(numberOf, DiffInfo); DiffCommand.call();
why not performActionForServicesOfServer.
It might be better to rename the variable to currentConfigForEdit; here would be clearer.
Consider using the qnNumberDownloadIndex method to take a String argument as an argument.
Why not call this(value, null, false)?
Should be logged in user
Please use StringBuilder instead.
The problem should be somewhere else :-)
this appears to be duplicated, might be worth extracting them into a separate method?
Remove else clause.
I think the start and the cache can be read for one local variable.
Use computeIfAbsent
Please make the shell final.
Use Guava Streams.stream(entityType -> EntityType.getSheet(entityType)) instead of StreamSupport.stream(entityType -> EntityType.get(entityType.spliterator(), false)). Maybe a static method that can be used to decode the bit stream and specify it as EntityType.isSheet(entityType) instead of StreamSupport.stream(entityType.spliterator(), false).
Can you explain this change?
The refresh() method will only do this. isVisibleToUser is not needed.
Can you use File.separator instead of "/"?
You can remove this else block instead and set the default function return to false.
typo "my://"
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully handle exceptions that allows users to manually skip their own Jenkins build. What they need to do is: @Test(expected = IllegalStateException.class) public void parseSignatureAlgorithm(WK source, Algorithms from remote JWK set) throws Exception { if (jwkSetUri!= null) { return Collections.emptySet(); } return Collections.emptySet(); }
please decrease severity to "info"
This should be INFO since it's not a "m_getCurrent truncation handle".
I think it's better to use a warn log here.
From <LINK_0> I'm not sure this can be part of the Type member.
[Checkstyle] INFO: '200' is a magic number.
If we have a Umbry data directory, we wouldn't have to update the index, at least change the method name to upsertMode (as opposed to CachedsertConfig)
sourceFormats is an empty string, so the null check for blank and empty string is not needed.
List<WebElement> equals = notifications.stream().filter(notifications ->!notifications.isEmpty()).collect(Collectors.toList());
java.get(() -> batchContext.loadPluginClass(JDBC_PLUGIN_ID))
probably better to have a log message here.
please add a null check in the super class to avoid a NPE
not sure why you removed these?
change
Firing event in finally block? What if it does not happen?
This can return the value of this method, not the test.
Why do you need to catch RestServiceException here?
this is already called in the test above, just call it once.
why do you need to define the default keyword here?
Why not getSorizedData()?
We should also clean up server as tearDown method of GrillServices class.
What is this checking?
do you want to addPickupStatus only one item?
Instead of this.skip, use the provided SkipRevFilter constructor to ensure that the SkipRevFilter can't be called again after the skip
Can we use the constant from DiscussionsOperationsAction.java instead?
Use StringBuilder
Is this really needed? A getAlias() already does the owner of getName()
Revert this change please
Is it in purpose to not use brokerRelatedInfoLogging? Because having brokerRelatedInfoLogging += Login... is the same for both brokerRelatedInfoLogging and brokerRelatedInfoLogging
why this has to be public?
You can use Preconditions.checkNotNull for all arguments.
@Dimowest What does the module URI do? For example, shouldn't it be <LINK_0> or Shall we extract the module name to a constant named "rootDir" and refer to the getFileName? This is done in multiple places throughout the code
@gianm > Any reason for this line? I would test it with @Test(expected = Double.valueOf(actual)).
nit: you can use assertEquals?
Can you add a note to the method, that @dgoguzkocerires Please avoid this.
Hmmm, I think this would be a bit cleaner as a 'final' variable? Avoid duplication with the variable names.
i18nfcNfcNeverMessage as the message is useful as the 2 lines above this is not an error (but only the message could be useful for the user).
is there any reason to use the form CommonModel? I think it's a bit easier to understand.
Maybe you can use Completable.fromAction(latch::countDown) instead.
why not using the join() method?
you can ignore public
I would call this(intervalBiFunction, this.intervalBiFunction)
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
Could we use articleContentString.sanitizedContent() here instead of \n so that it's only called once, if articleContentString is not null.
I would prefer to orElseThrow with an appropriate message instead of returning null.
This is unnecessary
I'd prefer to name these methods more specific like: boolean hasAnnotation(String annotation) { if (descType == null) { return false; } else if (descType.equals(annotationType)) { return false; } }
can we have a a constant for the "(" at the top of the file?
I think we can help ourselves when debugging if we include some information about the displayName?
requireNonNull is redundant here
File.separator + ". This does not work in Windows. You can use new File(prefs).
I think you can replace "package1" with "package2"
This does not seem to be tested.
use final
Why not print the stack trace? This test won't print it.
I think you can get rid of the the way the test is supposed to be the same when you just copy the old format. So java.overwrite_existing_partitions => assertNotEquals(immutablePartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTableOverwriteExistingPartitionedTable
I would have created a variable for Function#identity and use isIncrementOrDecrement() within this synchronized block.
I would make this "return {"null, to make it "return file"
The idea of the "template" parameter is that you can pass an object that will be created even if the feature is not found. at that point, the generated feature will be initialized to a single instance, so it will be initialized twice and it is not necessary to create a new one.
The field should be protected, not package protected.
Any reason why this is needed? This should be a method, String msg, String t = SUFFIX;
Why not use System.arraycopy(pn, 0, qn, 0, qn.length);?
Gary for testing. I think the implementation of this method should stay as it is if getItems() is empty. Otherwise, you have to deal with the Iterable implementation.
I think search operator expects a String which can be potentially null. This can lead to an NPE.
Please don't use Stream.of() in tests.
Typo:'quoteString'
Is it possible to use same serializationStrategy instead of creating new one?
I think we should make this message more explicit, e.g. "AnalysisCacheFunctionalAnalysis: " + version.isIgnoreIncrementalAnalysis()
I didn't know this is going to work in the case where a config is with null it is absent with the current logic.
This may be null, I think, a user is allowed to be able to retrieve the user without creating a message (with a null entity). Could you simply break the API on this (perhaps the user has deleted) and make the check for null?
And for query, parameters, and queryWithParams, are not null checking for params parameter.
command.getId() here instead of 'getEntity(container.getName(), output)'
API breakage errors. You should declare another method and mark for deprecation this one.
Minor: it could be replaced with a function reference instead of creating a new list.
Maybe it makes sense to add this before we start initializing
Why not just'returned'?
suggestion LOG.log(Level.INFO, "Failed context failed", failedContext);
Verify that the body contains the expected body?
instead of undoing you've done method which has to be changed in another pull request.
Have we used this(true) but now we have to create a new instance of this? Does it make sense to have a statically initialization of the options?
Shouldn't this just call onSelectedItemChanged()?
oh, I see, you need a static import for this.
In Imapmap, there is no need for the field.
Can we log the same message as LOG.info("Repl policy is not set for database {}.", m.getParameters(), replPolicyId);?
if the log level > info should be added as part of GetBlobInfoError, then the size is the same as the one with numet right?
remove "this"
I think this else block is not needed as we use the constant.
Can we add a method to the getQueue() that does this work? The downloadr cache is the node count that is not specific to any node release. The result is the same but the check can go away.
please add @Override annotation here as well.
So it's not needed to run the VM?
wdyt if we could have the same indentation in the beginning of the method w/o prefix?
I'm not sure, but good practice for the test. I suggest to use a simple @Before annotation.
same question
should it be all the other way around?
I can't understand why you are doing this
this appears to be unused
Why use Integer and not int?
Do we need this case?
The method actually determines if the given processor starts with ephemeralPath. The reason is that ephemeralPath is not named "ephemeral".
Should be null, not getGroupedJobInitializer()
this is no longer needed
1. Do we need the empty line after the if? Maybe it is better to have a default value in the error message.
Is there a way to get rid of sleep?
same opinion here :) (though break logic here seems correct)
can it be a constant?
revert this string
[optional] Use a shorter lambda here, e.g. java if (world.isRemote) { return tickets.stream().anyMatch(ticket -> ticket.isRemote); }
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
I don't like the idea of using spring injection in a constructor.
I think the request() and the 'this' is not needed.
you may use Smart.tag instead of json() here
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
No spaces
Declare this variable final
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Why the empty parent? With empty nodes, the parent node won't be empty.
why not put this line and avoid the cast?
I don't think we should assert anything here... It's inconsistent with the logic done in addSpan() - but it seems to me we don't support it if we never want to.
Could we combine the two methods together with an Transceiver class?
are you sure this makes sense? Does the view need to be @NonNull?
have a format 'O: ==1' is not a good idea, as this is re-least
Java Boolean.toString() over java.util.Objects.equals. The constant could be used in the same package
Should we do an Assert.assertTrue on the return value of verify()?
@guiseco here as well, let's add this method to the interface and annotate it with @Nullable
Can be simplified to return AccountLinkingStatus.ENABLED.equals(status);
Why not do this(x, y, false,...)?
getChildren() should return null if it is not of type internal.
Definitely restricted, especially if we consider moving JDK installer into plugin.
Can we make it a constant?
@norea Suggested to add a method like this: java public MFilter(final K filter, final K filter, K filter, final K filter, K filter, final K filter, K filter, t) { return ((predicate, predicate) predicate).test(t); } public MFilter( K filter, K filter, K filter, K filter, I) { return ((predicate, predicate) predicate).test(t); }
Doesn't account for new code stand-alone Ambry CacheManagerEventModified() will always return a CacheEventModified() which isn't the right type of the cache. I'm not sure what the cleanest would be to initialize the listener, rather than creating a new one each time.
As I wrote in patch set 8- you should have the same validation for moving the network to a new commit.
use the random stream instead
Take the limit (50) as a parameter, this will be useful for later
These two lines probably can be combined into one.
I'd rename this variable to memberValue.
Can we use selectHyperLinkLabel.setEnabled(false); here?
I think it would be nicer to go with the RmfTraceStub to be a static constant and use it in the tests rather than the "Blaine" one.
Check if credential and registry are null before creating the Builder.
Couldn't you use this.key.equals(Object) here instead? If so, you can remove the if and use this method.
@Restricted(NoExternalUse.class)
I would prefer to keep the bean object first.
OneOrigin that have a OneOrigin that doesn't have a OneOrigin.
This can be simplified to return the key to the cache.
you can remove throws Exception
redundant lous comma
Can you use key instead of value and do something like: ruleConfigs.get(key).map(String::getDefaultValue).collect(Collectors.toList());
can you please also add method WaitUntil(new JobIsRunning(false)) and then try when waiting for shell completion.
A lot of this logic seems to be reused for each handler. Is there a way we can generify it to save some code duplication?
I don't think we want to do this in the synchronized block.
Can you add: // on the Fragment to show stop polling mechanism the activity? Application.getInstance() : onAttach()
We can put this before the if statement in process
this is the wrong way to determine if a trace is a standard trace. Your implementation returns a trace (possible an instance of a trace), so you should use the trace name as a second argument.
The getValue method is only called from the Symbol and it seems to be used in many places. Are you sure it's worth it?
How about using a configurable timeout here?
@mTopic may be a good idea to use util method/stream since it is used in other places.
doc
Could be inlined
Any latitude == MIN_LATITUDE's not allowed in this method?
What happens if it doesn't rename the window?
should it be a constant?
The following code would also help to implement this, as we are using the [JavaScript](<LINK_0>
Thinking about it, is there an alternative than for creating multiple instances of this?
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
This is wrong. It means if someone gets a trade time or a date, it has more than one time. This is about the case where the TradeDate is passed as a parameter which is later in Trade(..).
Can candidateService.getCandidate() be null?
I think we should be consistent and let the exception bubble up the call to session.isOpened()
You can push this directly to the frame so you don't have to pop it manually.
Let's keep the same code as the original.
Remove the unnecessary parentheses
why is this noncompliant?
Would it be better to just use a reference to the main Activity?
Why synchronized?
use [try-with-resource](<LINK_0> to ensure that they are closed in same try block
when would it be problematic to have a query that returns a query (not in the database), as it needs to take care of it 2) it returns null.
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
This is not really a good idea, because these are collapsing into a constant
I don't think you need to check for partitionedSplits here, since it's a table.
Is this the same as in the other place?
I'm not sure why you need to have this config.getAutoTeleportEnabled() here.
Should probably use a different exception text, like "Unable to send a notification to slack error" instead of a stacktrace describing the exception
suggestion if (interceptorManager.isPlaybackMode()) {
Why not make this change? This doesn't seem to be unrelated to cube size.
This variable is useless. Please just use return in your if/ branches.
Could be simplified to if (!customPageMap.computeIfAbsent( cpType, Boolean.class))
nit: check if the variable is actually non-null before performCheck()
Is there a reason not toString()?
Multiple indentation issues here.
The field name is misleading; it is a bad idea to have a meaningful name for a field; I would say it is not an instance variable.
Let's not use the earlier mkdirKey here. Instead, we should just check if the directory exists and if it returns false.
You don't need to check theTCCL, just pass it through.
return value.get(key);
This should have a static logger method with a code
Why are there two log messages being logged?
s/type/col/
need to do this for the validate and print the message too.
We are using a for loop here?
should be wrapped in a try-with-resources block.
Doenix, Doenix, since this has a separate method to do about DMLTableInputSplit. Can you make sure there is only one class?
s/ NativeInterface.MessageType.DELIVER_PENDING_ID
Can you make this method synchronized?
I believe we try to run it the way to suppress the warning. Otherwise you have to create a "normal" error in case it only throws clause.
Missing @Override
We should probably check if the message is correct here, just like "should have happened since message is not yet defined"
Just catch Exception.
InternationalizedString is not a Context. I think a lot of the code is getting out of date. Why not return a language-length string?
I don't think this check is relevant
I think it would be more readable to use Set<String> filteredFolders = new HashSet<>(); for (String file : untracked) { filtered.addAll(trackedFolder.substring(folder.startsWith(folder)) }
It's better to use a specific class.
This shouldn't be here...
nit: No need to add InputFormatSourceFunction<RowData>, please use the name of the function.
final?
Either use a Preconditions.checkState to take a message.
Should we chain the zeros?
This seems wrong - a test with a wrong place where one would overwrite the index **less** - a deck name without any name. The index may be null but the other one can be found.
you need call addColorSettingsListener on the new instance.
Should we use an argument instead of the getter here?
I'm not sure this can be simplified. This method was supposed to return all the futures, right?
shouldn't you use lower case?
it is not necessarily a good idea to have a listener in order to make sure the PodPath is the correct one before the async call.
objects.hashcode()
Well, but just use the exception message to compare the result to do what I think it is (max or min) and no need to check the result.
should this be done in the synchronized block below?
We do not need the long value. Just use the long value.
org.junit.Assert.fail("a", null);
suggestion return getStats().getStats().getStats().getStats().isEmpty();
Argument name
You can use Integer.compare() to avoid KEY here
java.map(service::getClass)
Can this be moved to after the first line?
We can't do this, but I think the oneId.of() should always be used. (there is a lot of comparisons in the repo that's what I would suggest before the user did the same, just return the timezone if the user doesn't change.)
Please, add the following code: - List<VM> vmsToImport = Arrays.stream(disksToImport.get(0).getClusterArch(), vmsToImport.get(0).getClusterArch(), vmsToImport.get(0).getClusterArch(), vm.getClusterArch(), vms.get(0).getClusterArch(), vm.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch() is the default. I think it would be clearer if you call the 'null' method instead
I'd say addAwaitility to the message, this is a little more verbose.
This can be final and will be consistent with the rest of the codebase and avoid the need for final resource set in the resourceSet and ResourceSet.
I would use the new api. No need for this since it is not overridden.
We have unit tests for this method
ProgramState.Kind.OK?
For consistency, looks like there are cases where one of these would be an integer division.
Why not use the get(0) here?
I think this should be outer.
I'd recommend moving the "templates" to "Messages".
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
I would suggest this instead: @VisibleForTesting protected Builder<BlockState> getBlockState() { return this.protectedBlockState(this, PROPERTIES, UNLISTED_PROPERTIES, UNLISTED_PROPERTIES); }
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (int) tileCount.
please use logger, not System.out.
static import?
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
Do we need to update this in the init method? It seems like this method is being called in the onBefore method in DataDataSource.
missing check that vm exists.. (getVm()!= null)
It seems that this.TouchScreen.NONE can be removed, and it's not used anymore.
It's better to make a LOG.debug message. In case there were more than one, it might be good to log the exception.
So what's buggy about the CopyOnWriteArraySet?
This catch isn't needed anymore.
suggestion assertNull(pherf.defaultString());
This should probably be a type safe, as you're using service.startPoolManagement() below.
should baseName = null; and below using NAME_ROOT_GROUP; in case it is null or empty.
Can be package private?
spacing here looks off
You can use a list here
This is not the right approach. On the other hand, the Targets --> UiHandler.refresh() i.e. super.refresh() should be called and force evict() the last time.
please inspect checkstyle
Can you update this to java doc please?
I think it's better to move this code into an extra method.
should it be this.beanName?
I would put this in the Processor#initializeConsumer() method.
when you make this a non-final variable, you don't need a local variable
Looks like this can be simplified to: while (inClosed == null || inClosedClosed && inClosedClosed == null) { while (inClosed == null) { Thread.currentTimeMillis(); } }
same here as for Check other classes.
Remove.
use the interface, the editor is much more flexible.
This should be an exception, because it does not happen?
Should it also throw if the rulesProcessor is not initialized with some value?
Let's make this assertion fail more than once. We can define a constant to be consistent with the other tests.
Is this triggerable? I think it should be set in the constructor instead.
Static import
Is this null check necessary? workflowDefinitions.values() is already a forEach. I prefer your solution but you can take a look at the [this](<LINK_0>
Style-nit: We don't put this in a field.
Why not use new ArrayList<>() in the constructor, two lines below?
new Double is redundant here
return getQueryUri(Query);
I don't think the getFactoryIds() is necessary?
use same type for instanceof and force casting
Do you need this?
do we need this?
Should be moved to the View and hide section, e.g. GONE.
it would be more authenticated to be set to true in the AuthenticationToken constructor.
would it be easy to interleave a bad exception with good operations and ensuring that the good ones are not affected?
> PrimitiveLongArrayQueueWithRandomCapacity( 7 ) -> new PrimitiveLongArrayQueueWithRandomCapacity( 7 ) ); was this the issue?
This makes me think of what you're trying to do. The actual invokers should be provided, not the method.
Can be written in a different way: verify(processor!= null)
Make this a private static final field
how about adding getByName(name) as a parameter in the setActiveEditor() method and then leaving this as null? It feels like it's a useful behavior
in case closing one grouper throws ex, we would still want to close the remaining?
Shouldn't it be an IllegalStateException?
What we are waiting here on?
I think this should be done in every test method.
qry -> query
Let's throw an IllegalArgumentException here if the parameter is missing.
In this case, I think it would be better to go with SpecialNewPages.openSpecialContent(articleTitle); java ArticleContent articleContent = new ArticleContent().openSpecialNewPages();
It may be better to put these in the map method: java this.output = Arrays.asList(JwsAlgorithm, expectedJwsAlgorithm);
Can you use HashCode.compute()
retrieving result is OK
Why is the ChannelInterceptorBean not a ChannelSecurityInterceptorBean?
SyncSessionWithConfig is synchronized, but we should lock to this like we do in other getters.
I would have thought you will use I18N.tr here.
Are you sure about the stack trace?
You can merge this if with &&.
This isn't quite the test you wanted, I think. Shouldn't it be "0020.".
what is client used for? Can we keep this method private?
you should have it be the class name: super(ClassReader, StreamInputReader.class)
This is more readable using Java 8's magic 4x
It would be nice to include the original exception as the cause, e.g. throw new InetSocketAddress("localhost: replicated");
We can have a race condition here: the thread needs to be re-set and schedule to the same thing we had before. The value is set to 0, which means the thread calling startWithFixedDelay() after the thread has been interrupted. I don't think the Scheduler should be that much.
Should this be synchronized?
I don't think you need this variable (this is a producer for this)
It might be better to return directly, so that we don't have to load the same media twice.
Adding this to a field is good manner.
Can you add a space before the comma?
can we create the feedRange object outside the lambda expression and use only once?
Consider replacing this as a constant
I would prefer not to use public String copyModalStatusMessage(String current) { return copyModalStatusMessage(driver.findElement(By.id("feedback-copy-modal-status", WebElement.driver).getText(), WebElement.class); }
This is perhaps a good idea to call indexMapper.closeAfterCompletedRecovery. Would it be possible for the index to be zero?
It may be worth expanding this to include say: + "'Push' rights on " + GitRepositoryManager.REF_CONFIG
I am just wondering whether this should be the case? I am just wondering whether it shouldn't be a problem when we have a new host.
I'd use the ternary operator here.
Boolean.TRUE.toString() is used for enum values that are not supposed to have a null value. This is a change of equals negate that.
please keep the order or change it to private.
Perhaps this could be a simpler method of SqlUtils.appendParsingUtils(filename, extension)
Returning a List directly feels problematic. Better than returning an empty list.
Can we just use a single line lambda to avoid the need to define these variables?
Same here, return ImmutableSet.of(this.resultStream, this.resultStream);
remove.
state.getTime()
Fsbes :-)
assertFalse(...);
There is no need to convert 2 to Strings, just use builder.charAt(index ) == )
should we return a querySpec instead of params?
"PE" is a very unusual word for the version.
can we write this as if (session.getCommandHistory().isEmpty()) {... }
Why not simply Arrays.asList(name)?
for the sake of consistency, could you change the message to "candidate not found"?
nit: could you please use { } around if body?
can we have null checks here, and if it does, we should return null.
This could be even more readable with a if (page == null) { return; } _
Just use toLowerCase
publishEvent() is now performed for each event?
java if (ENABLE) { FMLPreInitializationEventRegistry.registerEventForgeTick(BlockFire.class); }
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
Suggest log.info("getBankState() to bank state to a non-null state", to avoid noise.
@ivandalbosco Why not to use tree.getResourceResolver(tree) here?
Use the JSONCountResponseTypeResponseType?
can be removed
Thinking about it, that the log at the warn log-level is printed.
isn't this breaking backward compatibility? If the reload() method is called from the start() method, then there is no need to return a CompletableFuture<Boolean>, I think we should instead use CompletableFuture.all() and fail() at the end of the method.
Looks like it's used only in one place. Why not have it in one place?
I know, but I would like to say this (IIRC currentPos) if this is a boolean, so I would suggest removing this (check currentPos) and just check for isATERLOGGED.
I realize that the color is not a good hash function. It will always return a value in the range [0..255]. Why not just treat RGBA as a single int? ((alpha << 24) | (blue << 16) | (green << 8) | red as in org.eclipse.swt.graphics.RGBA gives a much better distribution.
Should this be synchronized?
Can just return the result of the reserving user and not do anything with the same user?
You can use HandlerDataList.getAllContacts() here.
Nice attempt to use a constant, in case you want a more link period, I think it's not really appropriate here, since it's not a configurationValue, not a configuration value.
Remove else clause.
Is it possible to account for the currentAccount?
Please avoid unnecessary wrapping lines
Might be better to put this into a properties file, given that there is no client.
Collections.singletonList?
Thoughts on putting a null Intent.ACTION_VIEW first?
@antonini please name it user
Can you add instanceof check?
I'd use << 3 to match MemoryTrackingExecutor#COUNT.
Is this the right place to call this(public UserPortalConfigModelBehaviorBaseBehavior
Same here, check for null and empty string?
wrap with Collections.unmodifiableMap()?
I'd go with comparison the reason and the check happens before a ||.
Is there a reason why this is public?
Why this change?
Please use constants for the name statement and use constants.
in this case you can write this: if (argNumber == MIN_LENGTH || (argNumber > MIN_LENGTH) { context().arguments().get(argNumber - 2 >= MIN_LENGTH_OF_HARDCODED_PASSWORD) + ""; }
suggestion numberOfSpecialChars[count] = 0;
Could be good to close the stream. Please make sure to close the stream.
Why not just use < 3)?
Could use a path and path for this.
I am not a PrometheusMetricsTracker in the same package.
What is the reason for initialize date and time?
NIT: this can be shortened to final Duration.ofSeconds(10).
static import it, ScrollRequestBuilder.getInstance().setScroll(scrollTime).
what about replacing with "} "
Should this throw a specific exception instead of silently catch? Or should we throw a RuntimeException?
Can you add query that will be sent at the end?
please don't write final for the variable.
optional: this only asserts that this entry exists at the end.
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers'motif' also as Linux, along with 'win' that motif' is a motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
This does not compile.
Another option would be to set the flight flag here if the next line makes sense.
Shouldn't this be connect to the SCMManager instead of the EE_DELETING_LIMIT_SET?
Move the Preconditions up to the checkState chain?
You can also use the default size here, as it's not used anywhere in the code
Can you assert that the correct text is changed?
negative logic
mStatus!= null && result.mStatus.mCode == mStatus.mCode.mCode);
should it be return streamConsumer? I don't see any other reason for returning a list?
assertThat(map).doesNotContainSize(new HashSet<>());
It seems to be missing @Override in a different file, not sure what is the correct one.
HttpServletResponse.SC_NOT_FOUND
If we can use a switch statement or if condition we can use two-case
Do we really want to handle the case where we have a obj? In this case, i think we should always skip. In any case, we can use either jsonObjiC or AERIAND_Translated
this again looks like other parsers
Use Config. OkHttpClient instead of TimeUnit.MILLISECONDS.
Nit: remove "public"
Do we need to use the containsKey()?
We should not fail the test here. In case of a Exception it's not a RuntimeException and tests will fail.
why are you using!ambiguous instead of!ambiguous?
It's more correct to return the variable value instead.
Remove final here.
Returning a raw Object is pointless
This is not equivalent, it tests that the "real" trace is enabled.
Should the caller to close() the reader?
static imports
I think we should dispose all the labelControl; then dispose() in on dispose.
Could you add a method to the quarksPacket object? That way, you could call queue.offer instead of this.
Not sure how that would work this way for this, however you have a lot of code that does this method inside of the parent class, which seems very dangerous. Could you try to do this instead? :+1:
You should be able to use assertCopy and assertCopyWithMessage.
Check if the first terminal is open.
It might be faster to use append instead of StringBuilder.
So, we can do that for consistency?
Should make this constructor final, here and below.
.. this is not necessary.
Null check is not required here
Please add message to case when the server is not found.
This code can be simplified to a simple: return options.equals(option.observable, option);
:)
can you please keep the assertions in one of the inner classes? it's easier to read and understand.
This method should be named addOsTypes
Can you change back to private for the purpose of the class?
This variable does not need to be at all.
Shouldn't this be a static?
I would keep this class and call the method from time
this can be converted into a list to set the userRoles variable
it can be initialized to -1
From what I see, this is changing from public to public, and changing only public methods to public. If you want, we can keep <code> public String getFileAsString(String orig, EventType.class, Path orig, EventType.class)</code> declaration in the code base.
I think that we should always have that one, so that we can't change the null can't be recorded here.
I don't think there is a reason to have a public
Use InvalidArgumentException instead
Thanks for the fix!
suggestion Messages.InsertBlankSpace_cmdName = "";
I'm not sure this can be done in ctor. Just a Let's use targetFolder = new Builder().targetFolder();
I'd take a look at how we're doing it in the patch of this change.
... and better to use P.M.NO_GATHER
I thought the previous check was on the isEmpty but this could be made more stable.
Leftover debug statement (we can remove it)
Please use "enabled=" for consistency
IMPORTANT This is not a pure function, or another another boolean expression.. Can this be a subtype of the above method? Just a thought.
I am thinking if not better to get this explicitly. You can use something like getInitParameters() instead of getInitParameters() and enumerate extract what is prefix schemes.x sorted. not critical, but will allow comma within name...
This looks wrong: you need a list
import com.google.common.base.Preconditions.checkNotNull;...
I think I'd do this in other places too.
This will unnecessarily wrap RuntimeExceptions with another RuntimeException and should be fine.
solveSymbolInType is already a variable and you don't need to call it twice
This is a breaking change, right? We have [doExport](<LINK_0> for now.
why this call here?
return ratingDao.get(id).map(listener -> rating.delete(id)).filter(Optional::isPresent).map(accountParameter::get).collect(Collectors.toList()));
nitpick: This seems unnecessary, if you want to resolve the certificate you should just return the same thing.
I think the ENGINE_END is also a literal ENGINE_END, maybe the code should be extracted into a constant as we have that in other places.
Minor suggestion: you could use Objects.equals(this.className, other.methodName); here.
Does this method need to be public?
You need to ask the chart viewer for the chart viewer, as it is done by another thread
should use {} instead of string concat
In the original code, you had a method synchronized on the Level class which returns the executor. This synchronized block is not necessary.
I think the CosemDateTime class is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
Can it be final? It is only used for initialization. Please remove.
This is not really needed.
Not sure what is the best way to identify the revision, but if this is true, then make it returns false, and change the implementation after the other revision is broken.
Does this mean that banner service is gone by default? e.g. check for all custombanner?
nit: removeStyleName
Why do you have to change this?
return filter == null;
why public?
I think we should assert that the exception is not thrown as well
Missing a regex here, this is a bit strange.
This can also use covariant return types
Extract common error codes to constants.
Can't you reuse the same adapter here, too?
THE PROBLEM!!!! Look, it needs to be final
If we need this, I think it should be fine to go the the K config first.
@kuujo is it ok to make it public? If no, then make it public
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
can we remove: declare-response, useless-assign and just return the object from the method-call?
Minor readability suggestion suggestion alarmCounter = new AlarmCounter().addPropertyChangeListener("alarmCount", ignored->{
These 2 lines can be made private. Also if you really want to change the name of the class, you could simplify the code like this: Set<IMethod> parameters = new HashSet<>(methods.size()); for (IMethod iMethod : methods) { classes.add(iMethod.getDeclaringType.getName()); }
Nit: Don't requires Format. Format this file. Please change to something like: checkConfig(file, google);
Won't be better to restore file options actually.
whitespace
you can just use "x64".equals(arch.get64())
Would be good to have a test case for this.
if we have a method for this then-return the TemplateId. Will be nice.
I think we don't need to keep line 133
s/Data mismatch/expected
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
These two statements could be simplified to one for each of the cases.
same here. can we use this instead?
Use Display.DEFAULT_INITIALIE_ASYNC instead of the GTK.
use a plain null check
Why is this needed?
This seems like a unnecessary log.
nit: I think it would be better to do!iterator.when(public ValidationResult.BIOS_TYPE_INVALID_CLUSTER)!= null && cluster.getBiosType() == ValidationResult.failWith(EngineMessage.BIOS_TYPE_INVALID_CLUSTER); so in case we create a new cluster, we can avoid checking nullness.
You can use the same format for the above. TmsGroup is a little more descriptive.
consider inlining the value of isNulls, e.g. isNull(includeValues, valueCount) to make it clear that the supplier is always non-null.
Please add curly braces around "if" clauses.
Please remove the return type.
I'd prefer IllegalStateException instead of Throwable.
I could see a lot of this if/else
It would be great to have this in the transaction in the getTaskData method, to be sure it is private.
s/medic/medic/medic/medic/g
Could not be this.protected = null;
Why are you changing this?
return throwable;
Should this be warn instead of TAG?
you can use the below overload and pass the kv to the backend thus passing the SnomedNamespaceAndModuleAssignerProvider
I would prefer to have the builder variable inside the loop.
Is shutdownNow more appropriate (which would interrupt running tasks)?
@candrews Please put a space after if.
Could you please check the scheme too?
Can you rename published and publish?
Redundant brackets suggestion return tryActivateAndGet(e, item)!= null;
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
The empty string in the error message should also be printed as a constant.
Any particular reason why we are using  0.5f, but not from the Center.
Needs fixed filename
rename to path
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(smartRequestBuilder::setState);
Can you remove this condition? It would be great to have a default value in the configurable group name, but how about default to DFS?
Remove this.
The position parameter is in NatTable coordinates and could be out of range in the scrollableColumn. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(viewportPosition.column); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
How about this.path = Objects.requireNonNull(System.getProperty("secor.data.path.path"));?
Why not make this method synchronized?
Make this private and add a @Override
Data context = toData() should be Data.
nitpick... this should be renamed to simply gammaId, it's not necessarily new.
Please extract the matcher into a new MediaType class. Then we can call this from the other tests.
assertFalse(...);
It feels like there's a debug state where this data was read.
Please create a constant with an empty array with a single element instead of re-sorted array.
This kind of breaks the really clean streak of "new Client()" calls with no arguments. Could we make it adhere to this pattern?
Please use ==, it can be Objects.equals(): return TestHelper.getCurrentDialectType().NEO4J_REMOTE.equals(TestHelper.getCurrentDialectType().NEO4J_REMOTE ) || TestHelper.getCurrentDialectType().equals( GridDialectType.NEO4J_REMOTE )
nit: This should be a constant, and not a magic number. Can't we use a constants for all these values?
KafkaSystemConsumer has a new variable KafkaSystemConsumer. But you can remove the contextName and devConfig.getKafkaSystemConsumerConfig
Integer.MAX_VALUE?
Should use 'equals'
This could be done in a teardown method, instead of at the end of the database module (see line 67), but I think that serverUtils.cleanup(dbManager.destroy()) will cause issues in the DBUtils.cleanup method, so I would suggest to move the setup to the parent class and put it in the parent class here.
Can we rename this to targetObject?
does superclass installs one?
uri == null &&!cls.equals(web.getContentHandler().endElement())
So why does it have to be a string literal here? Shouldn't it be a constant somewhere?
Could use StringUtils.isNotEmpty to check for null
This can be done much simpler.
Should this be a asyncExec?
Is this test really necessary? Isn't the test you can do this before you test the plugin?
It's really a good idea to use CRYPTOGRAPHY_STATUS in separate method. Also please use CRYPTOGRAPHY_STATUS instead of TYPE_KEY and FS_STATUS in separate methods.
This is not doing anything. The check for inflight state is now redundant.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
Can it be empty?
I remember that there was a change in this file, but I still don't see a reason to have this change from int to long. I'll review it right now.
This line and the next should be omitted.
Why it's here? Please have it in OHOENIX-5942
This variable seems unnecessary.
can just catch LockRefreshTokenException?
Return bytes.hashCode() instead of bytes.hash()
I think you can also use the DEFAULT_BROWSER_HEIGHT constant here.
Minor: We could use.forEach here instead of.keySet() since it's more efficient.
log lvl rather to trace here?
Use variable name instead of Context
You can probably use LOCALE_CACHE.name().toLowerCase() instead of toLowerCase(), but you don't need the toLowerCase() here.
I would use Objects.equals here, but it's fine to keep this explicit.
I'm guessing the call to LogTransactionMergeFailure() would be better for this.
is this method no longer used?
toString() is unnecessary here (and could be replaced by String.valueOf() from the string
Rather than casting, can we ensure that the adapter is a Draggable(isAttached)?
public?
This is the replacement for superWeAreN above. I don't think it's necessary.
we don't need this handling - the ModelLeaseTime should be part of <LINK_0>
For non-public methods checkWidget() is not required.
It might be better to use Objects.equals for comparing
This doesn't look like it belongs here.
I think you should not use the constants for these assertions.
Let's move this line below the FBO initialization to just before the FBO is initialized.
Maybe we should use a superclass, in this case, and remove the 'public'.
I'm a little worried about this one. It seems to me that the other CTEs are duplicating the same code. Perhaps it would be better to make them abstract and return a constant.
So AIUI the basic problem is that one or more of the threads that called task.run() when paused == true is executing findForcedTask and has drained some tasks from taskQueue into the'storage' list. And at the same time rc.run''storage' list is not null besides this one
why not an instanceof MockScatterChartDataModel?
Shouldn't this be printed out in the finally block?
Is it possible to have this return an exception, instead of a specific one?
couldn't we simply fail the TenantAware tenantAware?
inline bloomFilterWriteStore
I know this isn't your change, but it should make it public here. And it should be package-private (not public)
Can you please revert to the new RuntimeException here? I don't see it in any other way.
Why is it public?
Shouldn't this be false?
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
What does getCDSExonRangesForward mean? It doesn't make sense to use twice, because it has to be used twice.
This should be replaced with <> on the declaration right? <LINK_0>
since bookkeeping is not obvious, also log it in case of failure
s/Remote installationEnabled/install
@ivandalbosco please use CheckUtils#asString instread of toString (+ one more case)
I think isClient() can be replaced with isClient()
exiting, so STDERR
Why use nextBoolean() here?
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
Maybe remove the condition and throw the exception?
Inline this object
I'm not sure if the logic is the right place to update the pre-existing cache if we're in the registry directory. What if we end up doing an pre-existing cache here?
currentBuffer -> currentBuffer
Just use the PAD.
Same here and above.
this function can be private
can you call toString on it?
I don't think 'this' is needed, we use 'this' below.
Why do you need the 'else' here?
You can use Locale.ENGLISH here
Is this still the right exception? or just use the parameter?
nit: what about returning is(String) and then just use is(String)?
should filterUnpublish, not filter/save the data
I would rather keep the old value assignment only.
Can you please use getStorageDomainId() here?
+":"++":"+private="]>" instead of "private"
> I think it can be removed as it is not needed later. The only non-nullable stream is in the constructor, so it is easier to read as an empty map.
throws
Minor: Should this assert that the file and the result are a duplicate of the System.currentTimeMillis()?
Please revert this change for "this PR"
Why?
Was this change intended?
![MAJOR](<LINK_1> 'Severity: MAJOR') Replace this expression which is supposed to be used to determine the "[![rule](<LINK_2>](<LINK_0>
Can you make this package-private as well?
""?
Add link to the warning message, it should use that.
We need a null check here to make sure that the fields of the query builder are null.
Nit: could you please use assertFalse (byte)
This call will lead to an NPE if no thing is found for the thing.
Can be replaced with foreach loop.
I think we should have an equals check instead of ==. Same for the other methods.
Can we use ArrayType here?
@bdragan this constructor needs to be removed
This is needed not overriden
You can use the if expression in line evictedCount % maxIterationCount = 1 and move the if logic to the while loop.
MetricsInterceptor ioExecutor.shutdown()
It would be better to log the exception stack trace and print the stack trace.
I'd prefer to use "isGlusterSupportEnabled()"
This is a bit of a nasty way around the exception handling. I'd prefer to do the try/catch instead. It's a little cleaner to read.
Is this the same as in testToExpression()?
You can store the value of the task as a field instead of the class.
You can use iterator.values().stream().filter(BondMode::getValue).forEach(mode -> { return BondMode.values().stream().filter(p ->!bondOptions.equals(b.getValue())).findFirst(); }
Minor: there's a default method in the resolveNodeToBinding which can be used to return null.
Is there a reason to keep the order here?
I'd prefer to have this as two-arg constructor. This is to only invoked by the context and we can get rid of the new context.
Why switch on the theme? It is more readable if we use switch case
It looks like we can get rid of the public API
You can use findFirst().orElse(null) to avoid the unnecessary else block
extract constant
s/public//
This could use.get() instead of.getSpellA()
You can extract the map.map(BibEntryType::getType) into a local variable to avoid repetition.
Is there a reason why you don't use this method?
Let's use a capital L to make sure it's the start time.
times(1) is the default for the times(1)?
I think this is where I asked for an automated build with my proposal but not sure I see the my changes in the PR. The intention is to clear the concepts of the map if they want to be cloned so they can take a more general long time.
I think it would be better to not use e.printStackTrace()
The second parameter doesn't seem to be necessary since metacardImpl is a raw string.
loadTrackers is called twice now since the property set to be set to false (if there is a property set to be set to false)
I would probably drop the tmp variable and just call the tmp variable here.
if this is used more than once, please consider extracting it to a protected method.
Is this the expected behaviour? If it isn't we should leave it in, not in the API interface.
This check is not needed, we do it in the constructor.
please verify that templateUuid is not null
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
Can you add these listeners to the CliOption class?
I'd go with a constant, like 'validatePort'. It can be called in one place now.
The filter is not needed here, just do filter = filter.
To be honest: I would prefer to have a DAY_COUNT cached inside a local variable for the dayCount.
Hm, is this OK to call on the same line as WINDOWS?
I'd use diagnoses for the above ones
should be e.printStackTrace();
Remove this line
Wouldn't getCurrentDataType be a better name?
Can this be 0 instead? Just say 0.
What if we undo the update of job?
File.separator
here you don't need to add projectClient.getface method.
Pull this into a static final variable
Do we need the following? URL.toString()= 1: return baseURI; As it is, URI is always null.
Not sure if we want to include this. prefix, the path is overwritten, so this would be in the previous if statement.
May be rename variable to maxOptionOptionByVersion
this should be in the doPopulate() not in deprecatedPopulate()
@smanstis I know your opinion, but please, fix indent of code
Shouldn't this be >?
Use ChargeDTO in return responseEntity instead of?
Perhaps you want to set the following instead of the empty string? java public static String Assumption.assertNotNull(Assumption.assertTrue(paramName, "initial" );
Is this append operation redundant?
Why not use tree.is(Tree.Kind.CLASS)?
Use entrySet instead of a map.
VariantType.MNV can be extended to make it clearer
It's confusing to create a new instance of Sleep but it doesn't generate latch. Is it possible to give a timeout, e.g. java while (true) {... }
You can use TestConstants.DEFAULT_FWIDTH999999 etc.
I think this should be a recordAwareNRecord.
I think you should generalize this code a bit, too many times.
return ansiSupported && ansiSupported;
We need to add this if condition also to be consistent with other code in this class. I will stop the kieContainer reference still here and we won't do that check internally.
same here
This seems to work, but I didn't write it to the whole store, so you can call it 'ToInstance'
You should change the error message here.
this is the only place to catch Exception.
I would rather check whether the newText is null and not every part of the text.
I think these 2 statements should be DbCacheManager cacheManager = tempDir.getCacheManager();
I wonder if it would be better to have a static method in sendMessage and use that?
If the anonymous context is provided, we could call new permitAll()
nit: We could do the same by using JodaUtils.sanitizerUrl(version)
shouldn't it be assertQueryIsFrom()?
Don't use printStackTrace() here, instead of printing the stack trace.
could these be simplified to just apolloEnabled = true?
you could use  as the id of the parameters class.
Should be getX().getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount() - wrapper.getPreviousNodesCount()...
I see what this is meant. Can you please add getServiceConnected() to the superclass?
Why not just use memberId == null?
As discussed offline, I think the new name should be new File(type, data)
This is kinda a smell in the code, as we already wait in the page object? A method that should be extended to wait in the page object.
Could just make lambdas here since LOC is relatively rare
/translation//
We probably should explicitly mention that this is the first language param.
Could we have a test that confirms the case where the table is active and the visibility is different?
can use smallestReadPoint.
Typo: Unable
anyRequestConfigured = true; assert setText(anyRequestConfigured)
Does this need to be a constant?
Wouldn't it be better to do Long.valueOf(actual.longValue())?
If you need to specify the text here, you can use 'Illusion' instead of hardcoding 'Illusion' as its id.
hell no
Can you use the class name here? It will be much better to have the pool id in the pool.
shouldn't you convert the logType.getAuditLogType().get... into a duplicateEventsIntrvalValue?
Check the env variable before returning true.
Can we have a method in SpiTransactionManager like the DownTransactionError? This would be a cleaner way?
Do you have a test that peeks the next sequence number?
either make this method private or use a Set<TestInfo> TIME_UNIT_FOR_DIRECT_UNIT_FOR_DIRECT_UNIT_FOR_AUTH = ImmutableList.of((float) TIME_UNIT_FOR_DIRECT_UNIT_FOR_AUTH) ); or make TestInfoPriorisationComparator<TestInfo> and remove the TIME_UNIT_FOR_DIRECT_UNIT_FOR_AUTH property.
This should be java return getArrayUtils(CharSequence), s, event);
I think the change is wrong - it should be true if the bond is not present, and then the bondOptions is calculated. It should be false if it happens.
Should we add logging for this here?
This can be simplified to java if (instant == null) { return new SimpleDateFormat(instant); } else { return df.toString(); }
We don't need to keep this method since we're not using it in the service.
I don't think we need to have this, but should we put the host name into the initializeData method?
I suggest dropping this exception since this is the only place in this method.
I don't think we need this class. TranslatorUtils
Should this be 'public static'? Because it looks like the test is not using the same package.
should use the same hashCode here as in the other classes?
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
Can we use java.util.Objects.equals? Also possibly an intrinsic in JDK9.
Why do we not throw an exception in the constructor if we are not parsing an exception?
Prefer new LazyValue<>(preserveHeadersCase) instead.
Can rename the method name
Is it possible to suspend the node before suspending it in the future?
result is a list, I would use.sorted() here.
Don't we want to keep this deprecated, create a new one if required?
I'd just keep this method. It seems like you can move a lot of the logic to populateOffset() function.
Please make this a static variable.
I think this could be done by dmnContext dmnContext.set(name, clazz).
I don't think you test the case where the undefined dataModelAttribute could be null. It looks like your tests are failing on the null check but the issue is that the file is wrong.
Can be simplified here.
This is a main test. Could we maybe have a unit test for this subfolder? suggestion Keras -> GenericTypes. The classpath would have to turn this output into a unit test.
minor: use parameterized logging java logger.info("Blob {} is removed from StatsManager", PartitionId.removePartitionId(), id);
if close is called twice (see line 96)
Why do we need to override the set?
I'm not sure this will work as expected if the injector is still binded in the listener injector by doing this.provision(LifecycleListener) which will never get registered as a result in a listener's provision method. In that case, I think it's better to synchronize on provisionListener. That way we could just check whether the listener is managed to do the job and do it themselves.
if the DTO changes, the DAO will handle the general case of a non-admin, should the consumer_level____________________________
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error when revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
System.out is no longer needed.
If you need to go only to the end of this method, it will probably be left there.
Why are you using 'this'?
final
I am unsure about this one. Will DLNAThumbnailInputStream.toThumbnailInputStream still get what it wants after this change?
all of these is Optional.of(T) should work? it's used to be a function. Perhaps the zone name should be the same here, but with different names.
use reflection, for private
Would not this be always true?
I think this can be inlined.
Formatting seems off, this would be hard to read
It's not good practice to swallow exceptions, especially when you should be passing in a null object. Please make sure that it is not null, and change the code to that.
You can use jQueryHelper.getFieldValue(selector); here.
The else block is unnecessary here - we're already checking for whether we can track the event and continue to the main thread. I think we should have a condition to do the list of updates to be in the main thread.
can we use the boolean as mentioned above?
final
toLowerCase
In the fragment, you can just set a field m_run_history_type to _view_
shouldn't it be 'equals'?
I think you meant "10000000 as a timeout" I think? Is there a reason you intended?
Please replace with dbFacade.loadDbFacade() which is called by DbFacade.loadDbFacade() which is a static method.
can be simplified to stream().map(r -> r.getKey()).collect(Collectors.toMap(p -> r.getValue(), p -> r.getValue()));
Do we want to treat this as a cancel as well?
This is not the same as the previous if (templateOptions == null) { options = HelixOptions.get(templateOptions); if (templateOptions == null) { options = new DeployVirtualMachineOptions(); } return options;
nit: remove this space before (
we need to make the mVariableNames synchronized
Just return prop;
I think that if a new output is just a constant, the code will be easier to read.
should the type check be one of node and return (JsonNode) node here?
combine line
can this be changed to schema.getFieldNames(fieldNames)
Wrong method name in the error message.
should we call telephonyRegistryManager only once
you can use the return type here.
why is this not using the custom severity?
As this should be removed
Style inconsistency: space after if
[Form class] Why can't we make this a concrete class for the piggy plugin to use it in the lagura plugin?
You should remove this block all over the place.
Why have a TableManager for the handle?
I think we should change the method name the same as in the Log.ept algorithm.
You can put a new FileAudioException(key, fileName, sink) here.
Can we use the constants in directory and this on one line?
We should probably use "this" for all the proposal providers.
same here, we don't need to have a hard coded KafkaLogAppender here. We can just set the message as the first command (no need to take care if the topic is already responding to the user)
You can write this as: java assertTrue(viewNameMethod.invoke(viewNameMethod.invoke(viewName, "Browse_items_name", "file:///file/", getViewName, view));
Why not 'null'?
I wonder why we need to keep this and it must be done BEFORE rc?
So this means you need to use delimiter as the default value if the delimiter is a CSV file name. I think it would be better to store the CsvParser.
Evil
should be equal to other.equals(other)
Why?
Should this be continue?
Please add this to the logger and not do it in warn level
Lines 34-36 can be extracted into StageConfigDetails
Can we use empty string as the parameter to avoid the empty string?
I would suggest you mark this method as volatile
I'd expect this to be false by default, in case of a disk in backup storage and not check the disks on the passed disks.
Missing a space between ) and {.
Is there a better way to throw a Exception here?
throw new SamzaException("key " + key); would be better
Is this a param?
It should be fixed in a different PR for this.
move this into its own method
Same as above regarding the method. No need to set the to true.
Can this be private or at least package private?
You should check VOADMIN layer if VO is not a READ.
I am not sure whether we need to catch this exception. Can we just let it throw so the exception is helpful for the user to know what to do with an engine?
java doc please:
no need to create a separate array for size
I think it would be better to use Java's Objects.toUpperCase() here, to avoid the risk of NPE.
pass reportedConfigurations as an argument
See above.
Can't we have this variable is redundant?
the name of the class is also the super class?
Consider removing the return type from the method signature.
Why the cast to Optional here?
This doesn't seem to be used.
Do we think that oversizedMediaWarning is enough? As far as I know, I think we should just always use both?
Maybe max here is too big?
suggestion log.info("Loading plugins to load plugin configuration for plugins to load plugin configuration", pluginConfiguration);
This is not used.
This would be the defaultApp member of a class, so that it is seriouslyed here. I'd assume defaultApp.getAut() returns a NullPointerException if the defaultApp argument is an instance of cli if it's not the defaultApp.
parent.getTime()
@jfanifieiev please use Objects.equals(techName) instead of creating a new Technology(UUID.equals(techName)); in case of code style.
Should the null case be added to the styles interface?
Why do you use a constant for "HTTP" and 0 if it's not present? Im wondering if the field will be reset to 0 or a constant.
Why is this line needed?
Here you can use orElseThrow
can be inlined as below the check.
@xupyprmv wouldn't it be better to store a real result of the above line in a constructor?
ITmfTrace is the same from this method below, but you could have a different PartialSS class that extends AttributeNotFoundException and PartialSS into it's own method. You could add a getter Value to the state system and call directly on it.
Shouldn't we check the waiter. If this is _queue_, we do not execute correctly?
"This call can be done with an empty statement on the right line.
I suspect this isn't necessary, in this case i would replace Calculator.setGameData(this.data); with this.data = data.data.pickGameData(this.data);
Is this type of mistake?
nit: No need to print out organizationDiscoveryIntervalMillis.
Could you please change this to something like sslFactory.createSSLContext(sslFactory, sslEchoServer); to avoid the need for this test.
why not use r0? this will be a failure
log the exception?
Could you please make this constructor private?
You should move this whole to a real @perf thing.
should return t;
I would delegate to the new method directly
Is this needed? You can do just stripe.add(stripe);
There is no need to catch Exception since RuntimeException is checked inside of Rule
please remove final
could be sorted by Comparator.naturalOrder
This should be a RuntimeException
See ByteByReference.java
value.matches() should also check for null.
Can be replaced with a for loop here.
i think we had talked about swapping the order of these so we can short-circuit?
It seems that any time an index file is created, we will have to acquire the lock for both the data and the if (config.storeKeepIndexInMemory) { persistBloomFilter = true; }
add: import org.ovirt.engine.core.common.utils.Pair;
I think you can keep the new output size in the Populator constructor, otherwise the other use is not the same
ContextCompat.onOpened(screen) You should be able to use the same pattern for all actions.
Shouldn't we be checking for isEnableAddIdP instead of!isEnable in this method?
I'd move these checks to the constructor of PrestoException(CONFIGURATION_INVALID, "Selectors could not be fetched from database.");
I think this should also allow something like: java ALLOWED_ANNOTATIONS  annotationType.stream().anyMatch( annotationType.getClass().annotationType().equals( annotationType.getClass().getSimpleName()); //NON-NLS-1
you can use this instead of regex
Could you add a check for nextElement!= null?
I would log the remote peer address being set.
override the pipeline when the pipeline is selected,
space before the {
I assume this method should be private.
I wonder how we should make this a warn since it is not really a failure.
CHANGE it to TypeConstants.JAVA_LANG_RECORD
SWT methods should have protected visibility as Density, not
You can use the new ParameterHelper.randomString(stateData) here.
Nice call to the @To annotation on ShadowActivity.
Mind fixing the copy and paste error, %n
This is the same version as UNIXFS. The StorageType is a storage type, not an HFS. The only supported operation is here...
suggestion return new Object[] {id}, idParam = idParam.replaceAll("id", idParam);
Only one should throw an exception.
I think we should use the backward compatibility check as well. The support for the plug-in options is / special concerning, but the logic of the format is more flexible.
you don't have to do iterator
Why not use if ( connection!= null && connection.isOpen() || connection!= null) { return false; } else { return currentConnection.isOpen()? null : 'null'; }
Since there are two places using "qe-menu-Resource-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-on- those fix fix your fork-api-site one.
suggestion: rename to asyncCommand
Points could be a static method on the top of this class, no need to create an ArrayList here.
We could just reuse the VersionRangeType variable and avoid the null check on the next line.
extract a constant ModuleUtil.getMandatoryModules() to make the code more readable.
Surely the index should be restored?
Yeah, here's where I was thinking of using the custom exceptions. IdpResponse.fromError(...) to check that the intent is null.
Why not use @Rule-test-test-test-test-test-function?
This seems a bit unrelated to that.
I'm not sure how I didn't intend to use multiparts here. Are we expecting doubles here?
Please use the setDataSystemIdentifiers method.
Is there a reason to use e.printStackTrace() instead of e.printStackTrace()?
you should again call initElements() in finally block
The replace above 3 lines with: java if (consoleProxyUrlDomain!= null) { return ""; }
Remove
Do we need this? This config is 'this' in the constructor
can you please add a helper method for this? this code is repeating itself in all of this patch edited classes.
I am not sure this is correct. Why not use java temp.get(temp).get(JOBS_KEY) to help users, and it's just a nitpicking here?
I think this can be simplified to call JacksonUtils.readEntity(Response.class);
I am not sure this is the best place to update it.
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
The same here. In the other hand, the createInstance method is responsible for calculating the hash from the totalStrategy's totalStrategy's totalStrategy' property.
Why not store this in the buildAndTag method?
Can this be private? It is only used by tests.
Makes sense to fall through the upload() call below, with a little more neater, but you could also use perform(String filename, String filename) here.
Lets fix the naming. "Unable to move to start because the attribute for that" is very confusing.
Probably this method should be private?
again, assertion for response in the ':80Scheme.setPassword'?
If we make this one configurable, could we make this one configurable?
I might as well use thecontrols instead of a local buffer
Minor: exists -> contains()?
This is a bit strange. Can we say if (list.isSelectionEmpty(list)) { return (list.get(ArrayList.empty())?
should we use this for the return value of the method?
check if art is an instanceof art && (AtsUtilCoreException)
Probably it would be good to put this inside the for loop
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
This doesn't have to be public. Is it package-private?
Use Math.max()
Maybe it would be better to have a single log.getLogger(loggerName, rev, suffix), so it's all who cares about the output
This should be part of the decoder
Add requireNonNull for parameters.
Please revert this change. The map is not used anywhere as far as I can see.
I think we should have this constructor as well.
My preference would be to use else if here.
Better to use KDatabaseException here?
no need for cast int
assertNotNull
Why do we need to check here if we have to add the same content here? The code seems to read the whole view in a new scenarioGridPanel.java already does it.
I think we should avoid changing the method name to something like EXTENSIONList<String> FormsMigrationConstants.BPMN_EXTENSION
nitpick: This could be extracted as well.
This is more like a code duplication, <LINK_0>
I would prefer to break the loop over it for each free variable. Then we don't need this on a separate line: free vars = getFreeVariables(); freeVars.addAll(varName); return freeVars.addAll(varName);
public?
Better use STRING.equals(...) (and in the other similar classes as well).
@tumijacob Rather invert this logic and throw if the user is an invalid one instead of returning?
return true would be enough
Use a null guard here instead
This may not be needed since you are setting the auto-generated value
These assertEquals() calls the correct assertion. Therefore in the general it is possible to use the correct parameters to assert the output in one call.
I think we should use circuitBreaker.getName() and circuitBreaker.getName() instead of the single name.
No need for this.
I was thinking what you mean by this method. If you don't have a CompletionStage type, I would prefer to keep the old style and make it final.
I'd do a newArrayList on the list.
we should get rid of logging in this case
You don't need the filter method of this.
use 'this' instead of the string '.LightboxHeader').css(<LINK_0>
This is an unexpected exception.
"hey" there's no space here and below
Is this line correct?
Can you rename this to warningsSeen ->...
You could use!nulls.isPresent() &&...
Remove sysout.
instead of new GoraException() you can remove this and just add the new boolean flag that toggled between DataStore.createDataStore() and RequireMissingType.
Can we add a message to the exception message?
This is a constant symbol.
Can we extract this into a little more readable to clarify the purpose of the "shouldAvoid transition" in any of the existing transition I think.
We should probably catch the RuntimeException here too.
I'd like to see more a way of splitting this method into two methods - one for early return and one for the both
This is what I would expect us to return the currentScene value: either _de_ or _this_ reference is wrong. I think we should not return the currentScene since the context is an instance of _Object_ object.
No need to initialize current implementation here. We try to avoid current implementation if PMD will complain about it.
I would use a different query to retrieve the DiskImage at the end, this is the new way you are using it
The while loop is unnecessary.
Is it correct to use connectedTokens instead of refTokens?
Will this be a sublong?
I think we need to move this method over view to a view rather than create a new view and add it again.
**USB**
final
You do not copyRepresentations into new DAnalysisSession
I suggest to use only one "Page" variable, and put it in a local variable. In addition, I think it is better to use only one variable. It will be easier to read
I don't think "Commons" is necessary here.
you can use assertEquals("You shouldn't be able to put the value " + expected, e);
why we need to wait for this?
@dalifreire this single task is static, so just add a single call to Href("<LINK_1>").
Windup/Discover/Java?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Instead of Boolean.parseBoolean you should just check if the properties are passed directly to the constructor.
Fantastic coverage, thank you!
style nit: no braces around single line blocks
I think english should be the messager.printMessage( Messager.Kind kind, message )
why 1024 * 1024?
Can we check if the object is a dynamic id of the current host, and that is why we do not create a new instance of the table for that type of the object?
This can be simplified to java nearCacheStats.incrementInvalidationEvents(); if(removed) { nearCacheStats.incrementInvalidationEvents(); }
We are missing the case where the user press the 'theme' instead of 'all'. I think the theme should use the selected icon as the 2nd image and not the imagePath_all option.
mationkey % 17
We should not be able to retrieve the whole ClaimException here. You should be able to do something similar to note the problem if the original issue is still thrown, but an invalid claim.
foreach
requireNonNull(key)?
@lautarobock Here too, let's declare throws Exception.
Should this be in GctoCluster.takeOutGarbage()?
Not good to have the configuration in the API version for the API version
Shouldn't we call this addExecuteStatement.execute(function) first? In any case it could throw an exception if the element is not found.
the put will remove the previous mapping
This is probably better handled with a socket.toString() instead.
Should these be assertSame? Might be worth failing if we got a line to make sure they are set instead of failing if no exception is thrown
c --> connectionlessProtocol
It's inconsistent to call valueRdnForAttribute(mapping, StandardCharsets.UTF_8) instead of creating a new ObjectSet object for each call
This variable is unused, so remove the need to convert it to string.
house style is to put the braces at the end of the previous line.
What do you think about taking the max size in the queue and then just a byte[]?
Can we use ArrayList constructor that way?
i'm not sure if it's the right term to use "token_hash" as token.
I think it's better to remove the "Trying to start" part
retval not validated.
use String wikiPath = url.getUrlForWiki(wikiName);
maybe use the same message?
Instead of checking for null, you can use the ItemTypeConfigTypeAmbariToOriginalPattern itself.
replace with fType.NUMERICAL to match the size used in the caller of this method
Is there a reason why this method doesn't return an unmodifiable list?
This getString() can be called from multiple places.
you could use the other format method
Wouldn't it be better to use MessageBuilder for the message()?
the @NonNull annotation is missing.
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
This is redundant with the next line.
Use __TS("typical") here
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
We should be consistent here, I think it should be create URI instead of instantiating a reference.
Could you please add a message to the exception
Does this line need to be done again?
Why did you change the method name? Also, can you rename the variable to just pipe?
Could you please throw RuntimeException?
Can you check if shutdown is invoked?
You can avoid new line by using softly.hasSize(1) and isTrue() from the set.
If this was at the PaymentAutomatonDAOHelper you can use here Utils.validate(telephoneChargeCreateRequest) and it could be passesValidationForNullCardExpiryAndCreation(telephoneUrl) and then it could be passesValidationForNullCardExpiryAndCreation(telephoneUrl, and it could be passesValidationForNullCardExpiryAndIsNullCardExpiryAndCreation(telephoneChargeCreateRequest) and then it could be passesValidationForNullCardExpiryAndIsNull* (which there are other tests - but it's probably not needed). For other validator tests - they're not at the deepest validator level (which in some cases seem either impossible or difficult to do), and there is no general test for CreateTelephoneChargeCreateRequest, so checking for the actual not null violation should be a part of them.
remoteViews.hashCode() could be enough here.
Let the user pass invalid data without a crash suggestion m = requestVer!= null;
You can write this shorter: int buffer = buffer.length(); buffer.length(); buffer.length = 0; for (int i = 0; i < read.length; i++) { buffer.read(buffer, read); }
why not use runVdsCommand here?
Hope you will refacto it in future, and will return valid Object instead of string and allow Spring do all work about marshalling to json for you
Can be inlined
missing {}?
Please add.trim() to the previous line.
You should return the selected trace with the current time
Redundant calls.
Suppose makes sense to convert value to lower case before comparing.
Is this really needed?
the getTenantAsString() could be extracted to a constant
nit: could use the empty iterator() here to avoid the need for the cast: java return (context == null)? null : map.put(type, object);
Same question about losing all precision here instead of during formatting %.1f
> What about the difference of the message here?
consider moving the compiled pattern into a static final field. Regex compilation is a slow process to be done on the fly, specially for constant patterns.
throws RestApiException not necessary.
shouldn't it be "" +
what about import static org.eclipse.core.runtime.Assert.isNotNullOrEmptyOperation(ResourceDelta delta, boolean equals(Object)
why are you not using the new method reference?
This should return a String, not a NON-NLS
please replace with verify(adminDAO, never()).executeSQL(null, never()).executeSQL(null, never());
Add checkState(lifespan == null, "Lifespan cannot be null"); return new JoinBridgeAndLifecycle<T>(lifespan analysis, consumer) to be clear (state cannot be null).
I think you want to call the new method which gives servers based on glusterPeerStatus
Are you sure this is needed? The lines below are not needed
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
s/send/mon threads are not used/
Can we put @Override on a separate line? I'm not sure that 09/05/05 may be clearer in the future
Please use the explicit assert (not null)
It's a bit strange to have a deterministic component to do this. I'd prefer to keep the default constructor clean(Charset) and use that in the test class instead.
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Maybe this will already be immutable. And a list.
Please use the super.visit(e) as the super call.
Seems like you're doing this multiple times.
I think that you need this extra copy constructor
this one can be empty
Could you extract this code so it is repeated in the 'getConverterLookup()' method?
This method can be extracted to a common method
From <LINK_0> > I don't like the form of regex manipulation of string should come from baseName. When baseName does not contain '-' this code will fail. @haozhun any thoughts on this style-fast will fail.
If you're changing the background anyway, why not just read the code from the background thread?
Nit: I think the OracleDataContext constructor is not needed here. And I think it should be OraclePropertyRewriter" and the text fields (and not in OraclePropertyResolver).
This syntax seems way more clunky
suggestion return (verbose!= null &&!verbose.isEmpty())
To save a context for a reference comparison with SSLContext() on the classpath, you should use a dynamic SSL context for the keystore types here.
"Maximum tag length is exceeded". So it seems we should only use "MAX_TAG_LENGTH_TAG_LENGTH
I think that if the first parameter is the stream, then return (first is true) OR (first is what you have), it would be better to do the rest of the codebase and not use braces for the ifs.
This method doesn't do the job, because it will throw NullPointerException if the owner is null.
Java does not contain the keyword null.
I don't like this arbitrary limit of scrolling. I think you need to look at the bottom of the cursor, and that's why I was looking at the bottom of the last visible lines of the bottom line, and if it was line shorter then you can have a few lines below.
should specify an expected exit code
Can you use Integer.MAX_VALUE instead of Integer.MIN_VALUE?
kStateChangeListener:: A; is missing something?
Same as above, please move this line under the SetViewport line and add an empty line after it.
Shouldn't this be protected?
Could you extract a method for plural resolution? kEventThread.handleHexSessionId(String id) or add a new one?
And here.
nit: make this final
I'd rather see more than one result, because it's most common code. Can we throw an exception here? Then we can drop the else altogether and just use remaining = the - variables and the remaining field.
I don't think we need this log.debug(String, Throwable) - should the exception be the fourth argument to the method so that it is logged as it is indicating that the method is being called.
@paulodamaso the braces and return are not needed here
Is there a reason you can't use the String literal directly?
Revert the changes here.
@tmarzeion This is a pretty long. Can you move the braces around the body, to be the same line?
we need to also support the "NRecordUtil.checkDataSizeLimit" here?
It's the table that this change is not necessary. Is the constant here intended?
Test is a test class, so please assert that the test is annotated with @Rule.
static?
Why not assert?
I'm not a big fan of this particular thing. The key value from the activationKeyCurator. So it's useful to tell the server to update this section, but they currently are not that important. I don't think this is necessary. Note that the activation key does not appear in the activationKeyCurator. So I suggest you use a new activationKeyCurator.update(this, "Update next toUpdate", new ActivationKey(serviceLevel), and update the activationKeyCurator.updateState(this, "Update next toUpdate", key);
Again, move the MergeMode.DEFAULT
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Typo: event_id -> event.
Make this private?
Should we have the other assertEquals() methods?
would it be better to use the lifecycle name for all these methods? I think not all the other fields or the state must be in the same order.
Can we please use JPA criterias?
Call the super. onResume() at the top of the file instead.
When will this happen? Let's pass a Evaluator to theEvaluator constructor and use it here.
equals
This exception is only for invalid address. We should probably use String.format() for all parameters.
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
...and again...
Can't this constructor be private?
Let's say "Cannot initialize routing table for block % numTotalBlocks" here.
In the case where the field is assigned to a field, we don't need to read the array. It's not safe to keep the it public.
suggestion mAnnouncementFragment = mAnnouncement.makeDeleteRequest(mAnnouncement);
This is not needed.
If you make this package-private, it should be a private constructor.
Code style: Do we need a variable here?
when address is null, it should be empty
Can you change to List<Property> ret = new ArrayList<>(property);?
I think it would be clearer to use Integer.valueOf() here rather than refundAmountAvailable
suggestion return DbSpace.getBdbStats(environment, sorted);
create a buildServingTrucks method or something similar in the Trucks class instead of doing it here
Shouldn't we add a default value for queuing so that users can use it?
delay is already completed.
Is there any reason for this change?
If you have a pre-existing bug, there will be no need to create a new query block with labels.
As I see, I have an other opinion on this PR, I think we should use the enums as the storage type instead of the storage type.
Can we throw an exception instead of returning null? It would mean caller should have explicit this not called on the caller (or throw a NPE).
Is this check needed? Does it mean that three threads might be able to run this code simultaneously?
Needs to be logged at the end
naming this variable doesn't seem accurate
Shouldn't it be a warning?
Please check for the invocations of this method
try block.
this is not good practice.
I think it should be the first parameter in the getSourceAttributeFriendlyName() method, because I am not sure how to name it.
nit: return getExtractedType()
Is this calling.get() on an instance of ApplicationReadyEvent? This would prevent the "new" error from being sent to the new one.
This should have a default value, i.e., add if you want.
Please remove this exception.
This could be assertEquals("expected, actual)"
How about: Commander commander = commander.commander.setProgramie(commander);
Should we read outStateNonce?
Can we make this private? Since there is no public API, just make it package-private.
I see the same logic as createWriteAdvHandleWithoutWriteAdvHandleWithoutWriteAdvHandleWithoutResult(String)
Is it possible to rename the field to SimpleName to distinguish the purpose of this class?
I guess you could put the key on the query?
Could be static?
same here, do we need to make sure that we do not match what settings in this method to convert?
Use else if here instead of two lines.
Please add this check inside xxx to avoid xxx as this is only for xxx node type
J) scope=%s is --> access_token or refresh_token
not sure if we want to expose this?
The Builder method doesn't support setting the default rendering.
This should be a String, so we can have something like this: >  inventoryId = "}";
log.trace
Agree. DataRadioStation station = DataRadioStation.getInstance(); if (station!= null) { DataRadioStation station = radioDroidApp.getFavouriteManager().execute(currentStationId); } else { RadioDroidApp = station == null; } DataRadioStation station = DataRadioStation.GetRealLinkAndPlayTask(allele);
modelFieldsMap.get(factName, modelField); return toReturn;
We don't need this.
This line is unnecessary, given it is called in the constructor.
I think it should be possible to move this into a method (and then call the other method) that returns the currentRequest.
You should close the connection after exception is thrown
Is this a message a bit of a cost?
Shouldn't this be index.get(index) instead of mapImpl?
Isn't there a reason to have the totalSize be a multiple of the first?
nit: remove "this." in the if statement.
Multi return is forbidden.
We could have this directly moved to the new declaration, to make the test more explicit.
Can you remove this?
final
This should have a return statement... no?
Shouldn't we have this as RestView.
Is this really better than a swagger specific exception? [example.org](<LINK_0>
Should we also check forbearing on the ".jar". We already have an answer, but it seems we'll come to update the bearing on the ".jar".
I think this should be a shut down than the scheduler
I think you can use a stream/map of the response if the status code is not member level.
Should be final
Can the return type be List<String> instead of String? If not, then the.toString() is redundant.
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
We can use static imports for Preconditions, but we are doing this nicer.
suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
nit: can be final
Prefer getHeaderFiles() to wrap with getHeaderFiles(). I think the getHeaderFiles() should be equivalent: java return Collections.unmodifiableList(Arrays.asList(unistd.h>));
Use InjectableAttribute.INSTANCE.getServiceReferences().equals(serviceRef.get()) instead of creating a local var you don't need to check it again.
I am wondering if using -1 would be better. What if metrics could be printed?
Shall we use a consistent approach? "return JsonValue#value;"
You can put this line on top of the class, right?
What about authorization gutSystemEntry? I mean, it can be moved to jdoc-only.
Is this used anywhere?
Can we use the t.add(t) method here?
IPath.SEPARATOR
I only see that with the field names are used. I don't think the field names need to be set?
Should this check if countss are empty?
what about initializing with a copy-paste error?
please use the same for tests (other than the other method)
I think it should be disposeSessionAction(this, null); and also the dispose method in this class.
This line should probably be removed
INSTANCE.get(project)!= null is enough
Use OpenShiftConnectionFactory.getOpenShiftConnectionFactory() to retrieve OpenShiftConnectionFactory.
Why it returns a string?
I think this if/else is redundant. if (useTimeout!= null) { return Optional.absent(); } else { Optional.of(Deadline.from(contextDeadline); }
why not use a ConcurrentChildCommandsExecutionCallback()?
Missing a logger.
@vilchik-elena Minor: we should also use TestUtils.waitForFile(logTester.with("OR") to make sure that the return value is not in "public" (or maybe the same as not currently).
Instead of asserting the inputs. I have been trying to avoid using the deduplicating code. Here you could use assertThrows to ensure that the re-done stripe message gives the "test timeout".
Can this method be synchronized?
maybe add a log.info here?
can we move this string to a constant?
use {} to remove warning
Sounds like a defensive copy/paste. Is it really necessary?
I don't think this is atomic.
InvocationStarted seems to be a common place, but it's not necessarily a problem. May be we should add a createInvocation method in StandardInvocationTracker.
Can return nit, not a blocker
I am concerned about the three calls to the getters in a Builder.
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Why don't you want the prefix to be color instead of dur?
It looks like this more or less takes us to a context where we retry auto update every 2 hours, right? Server load-wise I think that's quite often if we're presuming that we tried to contact the server, succeeded, and saw there was no update.
Consider using String.valueOf(uriHost.toString())
I do not like the backporting change. I agree with this one at some point it's a bit different from the one used to be annoying, but I agree it's a bit odd to put in condition.
The CAS was pushed for the MMV resolution failure and you do not need the new fix.
Is this line necessary?
Is the BSIIndex file going to be copied as well?
I don't think this check is necessary...
I think it's better to use spaces, also trim() *.
Note that it's not the [this](<LINK_0> If you think it can be done more than once in the ctor of this class as we are using it in one place. In fact, the map can be newly created by super.getAssociationRowFactory( row )
This should be a separate method
replace this with createContent() method
Can we put the indentation in the return Arrays.asList()?
Unfortunately there's no need to wrap this in a RuntimeException so you can use a LoggerHelper.log(Level.ERROR, e)
This magic number is not necessary.
This method is called only if the feature is not found. Consider removing an entry from the list and just add to the'supportedFeatureSupported'.
I would use a different path than the previous line. Here you're doing something else, but that can make the code more readable.
This should probably be java if (log.isTraceEnabled()) { if(log.isTraceEnabled()) { isTraceEnabled(); } else { if(satisfied) { > " satisfied = null"); if(mAccess(ctx) { continue; } } The logic itself is now that the caller already calls checkAccess().
... It turns-out this is a very low-level constant, but it might be more appropriate to use R_DATE_FORMAT instead.
Let's make this protected to avoid exposing methods that consumers of the API do this.
why do we need to catch a RuntimeException here?
Please keep this TODO
This is unnecessary since it's already synchronized.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Shouldn't we still log the exception message if the level level is WARN? There is no guarantee that the message does not make sense to me. The message should be: "ReplicatedCachesisReplicatedCachesis"
Can you extract these loops to a method?
Use the same logic as in getTaskIdList()
The docs and day of one, could we make this more readable?
Minor: creating a local variable instead of calling isEmpty()?
Please use Objects.hash() instead of building your own HashCodeBuilder from hashCode().
This can be made more compact.
this should be inside the try block as well.
I think vmBase.isAutoStartup() is already called before the 'isAutoStartup()' call. The 'isAutoStartup()' method is already called when vmBase is unavailable.
I think we should use Collections#addAll
please refactor
It seems like this line can be removed.
Can be simplified to java return an empty map instead of null?
i'd log the snapshot id and just add vdsnNonLogging
I think to be consistent, the code is correct, but you need to use Exception to underlying token
add a message here?
Should be warningFormat.isEmpty()
Shall we move this to a checkNotNull so we don't have to call super.init()?
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/.... maybe make the test do foreach(String zk : new String[]{"localhost", "up");
That's not the contract of hashCode.
getGeometry call here is redundant, because on line 125 can be replaced by sans like this.
What about the following cases: java if (parentMethods.isEmpty()) { return childMethods.get(childMethods); } return childMethods.stream().map(childMethods::get).collect(Collectors.toList());
Would be better to use the static returned instance rather than the method directly. (The same suggestion as in the other class.)
Does this need to be moved to TransportMode?
Please rename factoryUrl to url
Was it worth making a constant? I think it would be more readable
Slightly more readable: java if (s.equals("0") || s.equals("1").equals("1"))) {
Why both "FTP Job Trigger.getNode" and "VirtualFile")
I would suggest we simplify this logic: java private static final String PROTOCOL_HTTP_HTTP = "this.protocol"; private static String PROTOCOL_HTTP_S3PublishingEndPoint(Auth2Transform<PublishingEndPoint> protocol) { if (protocol == null ||!protocol.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(protocol); } else if (logger.isDebugEnabled()) { return new StaticPublishingEndPoint(protocol); } else { PublishingEndPoint.PROTOCOL_HTTP_S3.equalsIgnoreCase(protocol); } return new StaticPublishingEndPoint(protocol); }
This line is strange, isn't it?
Assertion seems to be missing?
@vilchik-elena Should we use instanceof instead?
.toString() not required, since this will be always equal to "System.toString()" in log output
Is there a reason to do this check? I think Preconditions.checkNotNull would be better.
Why are we passing the value into the waitForElement object? In this case, we have a object that is used will not be the same as waitForValueToBePresentInElementsAttributeByCss
This test can never happen.
What about adding the value of Null. I think it is better to use MyLoginException.isAuthorized("api/v4/user-id") in My account metadata?
nit: no need for the new check as it can't happen if has range is greater than zero.
There are utility methods in graph operators to get the kind of an operator invocation.
Can't we just return ServletUriComponentsBuilder.fromCurrentRequest().build()?
It can be removed, right? Also, it stores a number of queries, so that multiple concurrent queries can never be returned.
- first of all it is a map, not a list :) - I want to say that in this case the VM sub-projects will stay in the same list
Does this need to be public?
I'd suggest renaming this method, e.g. kJobCoordinator.init(System.currentTimeMillis(), config). This change is a little odd. But I don't see why you need two methods to get the same metrics and the one that the metrics format is a config.
This looks a bit strange?
looks like in the client code path where we use the one in place?
Should this be Path or String?
Too long
Should we have a version of createSearchURIEncoding that takes a String argument and use it in the rest of the code?
Ah, lightweight way to use isSet(PRESERVE_AUTHORIATION_KEY) here. I think it should be done in the isSATION_KEY column, not equals(PRESERVE_AUTHORIATION_KEY)
didn't you want to override the 'public' class?
+1 to condition width
Cool that seems like a good solution
extract variable for the array type to be shorter than the variable.
Feel free to ignore: Do we really want these this there?
"private" is not important and I think it would be better to put this after theNeighbour.
Is it a valid b.
I'm not sure this is correct. The LayoutEditor would need to be reset when you're done. The LayoutEditor would need to be reset.
"VN" -> "EN"
i'd add "perform"
I prefer fail-fastso first == null, but not strong feelings
It could be just check for initialSchemes == null, and then throw an exception. Why is it necessary?
mFamilyName?
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "set" in com.vaadin.flow.demo.registration.ui.RegistrationForm.java:[rule](<LINK_0>](<LINK_2>
This null check is unnecessary, File.getFile can return null.
Is it possible to return false here?
Same as above:.getAllOfType(VDSType.forValue(-1)
Probably worth to put this as an enum. Like: DiselinuxEnforceMode.PERMISSIVE.
could be inlined
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
rename to target
please break this line into two separate methods.
you may want to use ParquetFileWriter here since it's a non-final field
Why is the default method still keeping the Registry and not null?
I'd move the algorithm parameters to the vanilla code so we get it from the DB, we are correct that the consumer of the library can change later on.
No need to create an empty file here since this can be moved to the finally block
This can be replaced with UVCDialog.setArguments(args);
I am concerned about how you delete this method. At some point I feel like to have a single method that performs a stream to remove the optimisation of removing them. It would be easy to have a single method cleanup in a parent class that doesn't have to be tested with the old implementation.
this should be: return Ticker.class.getName();
I'm not sure this check is sufficient. The port itself does not check the port itself.
onVideoSelected() should be called here since you are onVideoCompleted().
(also change to)
what are the reasons this is null?
Where is this constructor called? I don't see the input in the index being used.
Use the util method of ValueWrapper.
Isn't this the same as the other commit?
Should this be: log.debug("Stopped %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure.
Why are we using a final field to make it final?
Should this be [this.organisationIdentification=" + ",messagePriority=" + this.messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", messagePriority=" + messagePriority + ", message
Ccan we default to a more modern version?
We need to keep autoGenCompilerOutput
I think this should be 'public static'.
why introducing the blocks?
You should probably use synchronized here instead of synchronized (this)
We should use assertThat(value, is(not(value())); (you already have a string which is null and has isEmpty() standard checks)
We should probably move this to the context variable, so it's not duplicated.
Do you want to test that the sender is valid
Is this still needed?
use Map?
Maybe add a check that close() is not called?
@tristantarrant Is this something that is meant to be a copy here?
Is it really worth doing this change? Should it be ((klass) never be equal to what's going on? )
Add the shutdown hook to the'shutdown' field, to avoid any race condition.
I think it's worth both of these.
Would you mind extracting a.getId() method to make it more readable?
I guess we can do it this way?
this can be declared private.
You can use AssertionUtils.unencode(value, value)
Can you make this message more specific? like Ignoring not supported operation
I think we could get rid of the empty line in list.
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
Why are you using a <code>this.getVaultUrl</code>?
Remove this.
Use an String[] and avoid the pattern of the library
Can be @VisibleForTesting
Can be simplified: this.tx = new ArrayList<>();
Isn't the task parameters still field?
I'm not sure this is really needed as compressedSize will grow as an array on every invocation. Do we need this?
You can use a custom value for this
What is the purpose of this change?
use containsKey
nested objects can be factorized to avoid code duplication.
typo: of -> or
You should use the old method: return new ITimeEvent(fEvent, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fDuration - Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) );
It might be better to filter out an found exception than to crash if so.
Probably better to do eventPosition!= null, because it is creating a new EventPosition object. And then here one could be used to initialize eventPosition and eventProcessor in the next constructor.
I'm not sure this is correct. Could be if (obj instanceof BackendApiResource) { ((Object) obj).getRSDLDL(ApplicationApiResource.class); }
elementSizeInBytes > 0?
oldValue should never be null; otherwise the merge function wouldn't return the same reference.
Consider moving this for-loop to the previous for loop.
> return V2 * V3
Can we use this?
A better approach would be to check whether the list is empty, not in this case.
Probably should be closed in this case?
Why not use org.jboss.as.test.Assert#deleteHandler? This way we don't need the debug method to control the access modifiers on the org.eclipse.cdt.dsf.gm.debug.ui.debug.g. the method should be on the tracing side.
use new names?
Please change the type to use the == operator pnd iteration. It will allow us to merge the 2nd patches between the patch and the bug fix.
variables not needed.
Why always true for the current track?
I don't think this is necessary for.orElse(null) and we can just do: return child.getIndex() >= offset && child.getType() == tokenType.values().length();
Please move "org.myprocess.myprocess.DefaultDeployment(PROCESS_ID)" into a local variable and use it in constructor.
please split into 2 lines
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "this"; it is deprecated. [![rule](<LINK_0>](<LINK_2>
I am not sure if it is necessary to clear the map. I think this is the best place to do it, so I'll leave this code as it was.
I would prefer that this method will be called only once, save the result to a variable and re-use it in multiple places.
I think that the connection is never closed. For this reason, we should probably use a try-with-resources
I think you meant to do!isTrim() || defaultValue!= null && defaultValue.trim().isEmpty()
Why are we creating a new list? Wouldn't it be better to just return a variable?
I'm not sure how this method does it, since the default DC is returned in validateParametersForValid() part of validate()/validate()/...
"==" should be intended further to right, as it is not the same level of execution as "&&"
please remove [Symbolic](<LINK_0>
Not sure what this means here.
maybe you should also use UMI_BASE_LOAD_FORM_UMI_BASE_EXPECTED_UMI_ED_UMI_USER_FORMLY_UMI_BASE_EXPECTED_NMI_ED_UMI_ED_UMI_USER_FORM);
Remove
This test is duplicated below, but I'd prefer to avoid duplication.
You can add this error log statement to the row too
This adds the caps a second time.
What about using a constant instead of "GlusterHost"?
You can use Long.valueOf() instead of new PollingTaskRunner(this.pollingInterval)
should be the parentId, not the name of the parent, it's a different method for construction, so that the quark could be used and the parentId, and the sub-quarks are created from the parent parent, while the new request is done.
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalsInstance?
I think this can be: return results.stream().collect(Collectors.toMap(this::address, this::getAll)));
I think we should use this.clazz = checkNotNull(clazz);
Is it necessary to use debug level for this?
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
This should be getToken()
Is it okay to ignoring the returned locations?
This is repeated multiple times, could be worth making a method that does the same?
Can we add method canContinue(cruiseConfig) to check the result?
I think it should return Array here.
I would suggest using ConverstionPatterns.LIST_PATH instead of intValue()
You can use cacheManagerMock.getApplicationContext().getCacheManager().getCacheManager().getCacheManager(). That will remove the need for cacheManager form.
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "kie-deployment-descriptor". [![rule](<LINK_0>](<LINK_2>
Use a constant
Can check if this is the right name.
@vilchik-elena Why is it needed?
Consider using String.format()
I just don't know why we do not need the getErrorMessage() anymore. We just need to keep that logic in the sendToAffected method.
unrun -> id
I think this could be removed.
Why are all checked and unchecked exceptions being caught and ignored?
this should probably be checkState
do we need to add a null check for LocalService for a Module? I'm not sure what this code is doing...
Please extract the braces into a method.
The currentRowFilter is not null since we are comparing a whole set of RowFilter.
Should we filter out the map? It is kinda hard to read since one file in the future.
Why not rename this line to maybeGameProfileData?
Should be "Security service is closed.", though not related to this patch.
You can use FiltersHelper.Constants.HEADER_AUTHORIATION here.
This line should be removed
Codacy has a NPE here, I think it is better to have a throw IllegalStateException than to rethrow it (in this case).
This is a Multimap, we perhaps don't want to use the key
Return a SlaveDescriptor here
Here's an element.
I would use warn.
can we avoid running the sleep in a loop and avoid a race condition for the number of messages?
This is still possible because the current assignmentFailures will be empty at this point. In the first call of blacklistSendWindow.
Please remove this
Should we log the potential error?
this can be collapsed to a single if statement
Why not just pass the empty string?
s/public//
It would be better to catch RuntimeException and rethrow as IllegalStateException
You can just call this(public StandardBuilder.
I think this can be private, so it could be overridden outside the class
add a message saying that exactly was invalid
While you're here could you change this to: FileTokenizer.DEFAULT <T extends Throwable> String { return getClass().getName(); } use FileList.toString() as is
I think you can use 'final static String 'final'
why do we need to check this?
I think this will be better written as: File f = new File(string,dat); File f = new File(string, file, tdat); File f = new File(string, file, tdat); t.add(string); return f; Also, this method need to be static and can be removed.
Why has this validation been changed? Please check the error message too.
do we need to filter out the roles?
You can use path.endsWith("/")
HQL/JP-QL
Is it possible to extract this into a method?
Should we do an Assert.assertTrue on the path returned by.hasRouting()?
Can we use these from the Apache Commons Lang library? The implementation of these methods is in the first place, since they are in other examples.
That's a small difference. Why not we don't do it when we call this( now,Timezone)?
Extract method and reuse
Please keep the style here.
we should not validate the hashtoken on client since we don't know the system password.
**subRule**
nit: can we make this private?
The AbstractInstanceFactory is also often injected so it can be used in the constructor. Its probably not worth to use assertFalse(resultManager.get HazelcastInstanceManager().getConnectionManager())
Please have a constant for this string. [StringUtils#isNotBlank](<LINK_0>
dup.
don't use a constant (or constant) instead of new RuntimeException("Connection type: is removed on zookeeper"));
IIRC, fboName is null the first time the fboName is null. We need to rename the field of fboName to fboName.
Is this supposed to always reset the crypto status? It's hard to check if phrasing is the same.
StoreMode.DEFAULT_Mode and here as well.
You should use the method restartQQ() to get the connection.
You should special case for nonJavaObject using TypeName.equals(typeName)
I'm surprised it works on Travis, because of this.getEnclosingElement() == null -> equals - why is it used?
This should be updateMarkInfo().
any reason for this method to be public?
I think it would be useful to have log line
remove debug log
If these are all the same, shouldn't we use -1 (or even don't define the version) here?
Can we please extract this into a method?
should this be note.getNote(newNote(position), note.get(0) instead?
It is better to use switch case instead of handleDateTruncationViaDateTruncation?
should it throw exception if nothing is emitted?
i don't think it should be the responsibility of the caller
Should use a final static variable.
This needs to return an completable future. You could use a static instance of this class for your use case.
please use createdVolume
This test does not seem to make sense.
Could you add a constant to this Function<oneOffset, TimeoneOffset, TimeoneOffset.UTC?
remove
Lots of duplicated code, so code here is a duplicate.
here we have GraphByTypeResolvingVisitor - it should not be here.
"for "
add assert - when the test fails?
Can't this be done via a framework?
If its used to have single bld=rs it would be better to move this one to its own line
Do we need to create a PrintStream as the message may be something to be used to pass in the parameters?
this is a normal test. Just use Assert.assertEquals(image.tar(), "Can't find image after a tar archive has wrong tags", imageId, "test-java/test-resources/...")
is this method called onActivityResult? Perhaps consider using Workbench.getDisplay() instead?
This is changing to use @Test(expected = IllegalStateException.class)
[minor] "container" can be renamed to "container"
same here, and again:
This should be called on L176.
same here. if BusReceivedMessage is null check will be more expensive.
You should use [minecraft.getId](<LINK_0> here.
This kind of beats the purpose of being explicitly set to "SkullOwner". It was probably a bad idea to move it to a new method in SkullOwner.
Minor thing, but if we decide to keep the THS, we would then just add info.getCustomValue(null)
I think you can do away with this new code: timeSinceTelescopeService = DateTime.now().plusHours(1).isBeforeNow(); Then you no need to startReporting()
please use AssertJ
Is this cast necessary?
Add null check here
nit: By.id("session".equals(elementClassNamePrefix)) could be a better name.
super.stop() on serverInventoryLock
s/r/if/
I'd make this return deserializer, without if (null!= deserializer) { return deserializer; } if (null!= deserializer) { deserializer = new RequestBodyDeserializer(); }
use a static import here?
there is a NPE in the Eclipse environment.
Will this need to be fixed in general?
Same argument as with the DeadlineJob.
I'd probably do the following:.findFirstToken(TokenTypes.LITERAL_PUBLIC)!= null && modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC)
Can we use the new TestingServer(boolean start) method to keep the test clearer?
The constant for this? If you could change it to something like : java static final int parseInt(String key, int position, int offset) { if ((arg instanceof Configuration) || ((byte) m)) { return; } return exists; }
I think it may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
Why use a StringBuilder here?
I'd like to see the code of getting the directory argument and adding it to the existing call to deleteRecursively("/tmp directory cleanup", "staging directory cleanup". Maybe we can extract it as something like deleteIntentionToWrite = "staging directory cleanup"?
Should we verify that we never call externalID?
This will be NPE if the field is not set, in which case the constructor will be null
Make this: fail(printInvalidFunction(String textPattern, StandardErrorCode.class));
java foreach ( (AnnotationMapperReference) mapperReference : mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
Consider to use same code as in the equals method.
Should we define a constant for this?
I think this is not the right place to catch this exceptions and log it
I think you should use Double.MAX_VALUE for this method.
@jdgarresonn Please fallback to Assertions.assertThat(this).isApplicabled(metadata)) as it's the intention.
throw NullPointerException with Objects.requireNotNull(value);
Please throw explicit message.
Please change the name of the variable to error.
It would be better to move this line into the MesosGenerator constructor.
you can use method getUrlForWiki (so you don't need to add empty string for article path)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
It's a blanad thing that we use here.. no need for TRASHED_ON GAM type ;)
@Serranya There are many ways to use /private methods in the same package. What do you think @Serranya Please rewrite this class so that it's easier to debug.
Add one more indent for start of 2 for loop
This fails the test, we're checking the ImageType directly. Also, assert that the ImageTypeScript is not equals to ImageType.GENERIC_IMAGE_ORIGIN
iirc it's initialized in the ctor, check that it's not empty.
why not search for "empty" user?
Why do you need the previous check here?
The existing putAll method is missing.
Why is this needed?
@dunningning This code is the wrong place for this.
I'm not sure if usingkillArgs.Capability makes the difference since it's in an endpoint of killArgs. Why not use a prefix for these?
All above should be static.
Consider adding else if given that it's not necessary.
This was also removed in master
Can make this an else if since you are doing if'return' at the end of the method.
the original version suggests that there are spaces in the tab
==
Add this.download(null, null).
The clear() call seems redundant: you are already storing a local variable that's value.
suggestion List<String> results = results.stream().filter(this::isExtra).map(RecognizerIntent.EXTRA_RESULTS).filter(this::isExtra).findFirst();
What about the case where the surface rotation value is null? The logic should be something like: case s: return new SurfaceRotation(s.ROTATION_90); case s = new SurfaceRotation(n); default: return new SurfaceRotation((s) s);
This logic could be simplified to return hasParent();
Please use containsOnly instead of contains otherwise looks good.
should this be: newTime=" + baseTime + (it's the old code with spaces after +?
if (signed) is enough. We try to avoid the "switch" block below.
I would prefer.toString() for this value, as this is also the value of AttributeSet.attributes().forEach(name -> value.add(value));.
Can this be made into a constant?
_nit: The same goes for every method on the same class.
Don't put BundleContext call. It also causes issues when the BundleContext context is created, but it's not worth either.
warn
This should not be public
Please don't use Optional
Add a message to the exception to fail.
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
You forgot to add this eventLogger.showDialog(...) to the end of the code, and the previous should be this.
Since this is a testing wrapper, I'm not sure we want to make it public, we can have two implementations: 1. these two methods can call the other constructor directly. 2. We may want to make the client thread-safe (e.g. a IdToken) of the idToken itself. This way we can safely set it to the token itself, in the constructor and we can have two constructors: one to retrieve the token directly and one with the token.
please use VmBase.libvirtName instead of getVmBase
Now that I have two concerns, this won't evict same DB twice. We should be able to do that in the following way: 1. removeSucceeded - from the execution flow we're checking if the log is enabled, and then in the end we will be executed inside the process
I guess you could add a method getVariablesByProcessDefinitionId(processEvent) directly since it calls the getVariable() as well
please change this to store the replacement of vmId, it should be done in the client
The statement is confusing here - we are logging the failure, right?
Do we need to make this method public?
You changed the behavior for this method, so you should declare endpoint as a static variable.
can we use url for this?
wait for element
I think you can keep this as TYPE.DECLARED_METHODS on the matter of taste, but I wouldn't worry about adding a line break here.
And this one
I think you need to catch ErrorCode.FAILURE here. It will be made in the code.
suggestion assertThat(got).contains("Description");
I don't think this is the right place to do this. Can we make a method like compareAndSet(false, true,false)?
please use assertEquals instead of assertEquals
Parsing xpath expressions is not error prone. Could this be simply done so that it does not break the loop later?
We should not use assertTrue here, as it is a failure message.
no need to cast the method backing
As you already need to touch this file, I think this empty line could be removed.
Long Long
close() should be in a finally {} block.
As we're going to use streams, I think it'd be better to use StreamUtils.stream() instead of a stream.map. That will allow a single stream to be used here.
What is an error message here? Should we really use the full text found
Same as above, just put the ______TS("Not enough parameters");
Does it make sense to use a parameter or use Paths? Then we don't have to worry about the _replacement_, but this feels like it's already more related to the RelNode#RHBaseF function.
Maybe a few problems with this is the same as createEmptyArray below?
remove
Shouldn't this be set to false?
Should this method return stringValue as it's not a boolean? I mean it should use the context.
osRepository is not used - please use getVm().getVdsGroupCompatibilityVersion() instead.
Please, reuse your extracted method for checking if a file is an Erlang source file.
Just to make the code more readable, I'd move the common logic that you have here as well..buildNext(chargeEntity).from(chargeEntity) to separate method and then could be a separate method.
1. Please check if this method is not used. 2. Remove it and use generic types.
The try-with-resources aren't needed here.
It would be better to make this constructor private and have clients use the other constructor. That way, if we ever need to change the constructor, we don't need to public constructor.
Is there a reason why we are checking here?
Should be replaced with with lowercasePolicy
Can be && size == 0
"assert false" will always fail. I think this is because this is a mistake.
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push"."
Please do not use Long here. I think it makes sense to return null.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
I don't think this is necessary, as the callback is already called in the callback.
we can move this to the init() method in line 119 - 98
Same question as above. Just a detail: Why not collapse the method with a method like: java final Path linkTreeRoot = new Path(Path.class); final Path headerSymlinkTreeRoot = Paths.get(Path.class);
If it is not private, do we need to log it here?
Check error code/description
Small nit: This construct may be unnecessary.
You could use directly create the list to save at the next iteration.
I think this exception should be removed.
I am concerned that we might want to add a stream here, when the stream is closed?
This should probably be containsKey()
Your changes should not be necessary.
why do you use a mock here?
please use the following syntax: assertThat(result.getMessage(), is(VdcBllMessages.VDS_ALREADY_UP));
I am not sure if I have isDebugEnabled() here.
Can we wrap this with Bytes.toBytes(slice.getBytes()) or should it be > 0?
Nit: "Creating ephemeral nodes..."
protected?
why is this public?
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
nit: this.json = checkNotNull(json, "json");
this should be WebElement.deleteLinkByLinkByLink(...)
return a more specific exception than IOException
I'm concerned about the purpose of this line. The else statement above it is right?
@bdragan The name "s" is not a File in general, I would have put two new methods with the name "s".
We need to also test this product.
can we use logger here
Is this parameters really mandatory? I thought its default was false.
Missing validation for epochMillis.
1. please use 'guid' instead of new GuidFromString(model.getReturnValue())'. 2. We can take in the mapper for this (user for id) and filter the query from here...
This test is wrong, check that the expected value is actually the one you expect and you are testing here
I think it would be better to make it protected (and any other method below) to avoid code duplication.
Is this keeping of already modified by a copy of the buffer?
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
All text points to user_id in name should be updated after the restart of next VO, but they are not necessarily different from the other method.
You should also lazily initialize the exclusionList in L8 and shared until exclusion and as such, as it should be called when the data is not during initialization.
I'm not sure if throwing an exception is the best place to catch it. The code will fix the checkstyle, I think it's the "caused by" thread pool size. I would expect that the queue size would not be the'size' queue size. If it's the case, the list would not be in queue size.
Can't we just use object.isMergeable() here? Or are you sure that the former code is more reliable?
Is the anyMatch condition really needed?
I can't think we can do this: String render = getSizeInGigabytes(sizeInGigabytes); GB = Py; // Get the size of  GB. I think it's integer instead of GB. I'd use the setTimestamp to change the sizeInGigabytes (instead of /  GB). I think it might be a bit faster to use the builder pattern when creating a GB.
Is it possible, that the context is null?
more precisely: java static String substring(String rawMessageHref) { return rawMessageHref.substring(rawMessageHref.lastIndexOf('/') +substring(rawMessageHref.lastIndexOf('/') + "\\."); }
Other braces are unnecessary.
So - /var/tmp/src/test/java/org/apache/resources/user/conf/util/FileUtils.java:1581
I don't think that to be set to null here
Is this the default implementation of LiteralExpression?
since fields are provided, simplify this class, Objects.equals() will also work: java return Objects.equals(this.getName(), other.getReference());
@vilchik-elena We should not is a abstract method for this.
You could remove the empty line
Shouldn't this timeout be value in a constant?
@fanifieiev the same above.
final
Is it really necessary to use dynamicParam.getType() instead of dynamicParam.getType()?
Not sure that it matters much, but the scheduler is very generic. Perhaps we should call it directly when the context is not initialized?
In the original version of the code remove the public modifier, and mark it as @NonNull
Use Logger instead.
Consider making this a method. It will return VdsEventListener.getAllVdsAddressForOverriddenHostsAreMismatchedVds().
Exception#printStackTrace goes to stderr by default.
The else is redundant and should be removed.
sb.append("PICPICPICPICPICPICPICPICPICPICPICPICPICPICPICPICPIC");
it is better to call it all the time
This is (relatively) costly, and could be moved out of the for loop
I'd simply use the property changed event in the propertyChanged event rather than the setter.
scaledData, thread safety and all
Should it be null?
If gpIn!= null is enough, the second assignment will fail.
I think it would be simpler to have dedicated class for each pair since it could be on a single line.
I think this should be a set.
You don't need this, StatusType is a Status.BAD_REQUEST
@cvrebert why we don't use it here?
rename tempVar
You can use the default value of darkThemeDisabled.
Extra trailing comma.
String
Does this need to be a string?
Revert this - please rebase, <LINK_0>
This seems to be removed.
The else if block returns true - the result is true. This should return false if the expression is a precondition. However, if it is false, it is true, otherwise it will return true and is false.
To follow the rest of the PR, I would suggest putting the ByteBuffer.slice() in a util method that does this and then can decode the ByteBuffer directly.
Could you change this to NormalizeFunction<NormalizeFunction>?
[minor] I'd rather rename this var to lineOffset to make it clear what it does.
String.valueOf() is unnecessary when the replacement is an array.
Could be reduced to private static final at the top of the file.
could you make the end of the sentence a bit more explicit?
@demsey shouldn't this instead be: [thread-safe](<LINK_0>
Why still need to handle synchronization here?
Java 7 only - inline.
should be the same with the one on the config
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
The error message should probably be more accurate, something like: final boolean otted = (Void) locationDetail.reason().isOneOf(MUTABLE_TYPE_TO_FIELD); if (reasonDetail == null) { return true; } else { return false; }
An alternative way to look for a string stored in a local variable
1. After rebase, you do not need to modify file.delete() - that is the case, so you could simply delete the file
inline
There are two places where this method can be called. Is it worth checking if there are more than one value or the other?
Why JobStartupDependentResource?
You could have implemented the generic way in GerritCallback. No need to pass the options in!
Minor: Should we create a Validator to add the ParameterProvider?
extract the name to 'private static final String '
nit: you can use Collections.synchronizedListCasts() here
Another occurrence of data is added here.
Shouldn't this be changed to "createApplication"?
These tests should have an @Override annotation.
should we also synchronize on this and have the properties that return void? I was hoping to move the option around this as well (in what ways do we need it to be a class that can never change)?
I don't think this is a good reason to use virtualHost
- [x] Remove the try block?
Can we catch the specific exception here?
I might have missed something here, but I don't know if this is a problem, so I must be missing something.
This single-line block could be simplified to just: if(getWindow()!= null) { model.init(); }
Does this need to be static?
Multiple method(*) methods
Can you check that repository is not null in this method?
This condition could be simplified to if (!currentSystem.isenithCharge()) and then we don't need to check if currentSystem.isenithCharge() is not true.
You need to assert that unvoid is not null
nit: <LINK_0>
This is wrong, we can't use Runnables, don't need 'this'. It is for me to have fCursor(cursor.moveToNext()) at least once to call the method
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
Maybe s/new UIActionCenter().getInstance().getConstants().centerName()/templatesTitle-1/disks/yyy <action> <storage-api/> </action>
I think it is safe to call flushIfNeeded(flushPredicate, flushPredicate) here. Let's discuss offline
rename to element
Why do we have to use entityConfiguration here?
this line could be reverted
This is a bit weird. We shouldn't create new TextData with every request. "Selecting TextData" returns an empty string and throw an exception. I think that we should handle the composite part in the tree.
No need to use ConcurrentMap.
FIXME: I couldn't find a crash. WPMainActivity.getSelectedSite() should return null in any case.
the magic number here can be simplified as return new AppiumDriver<>(builder, serverCapabilitiesSupplier, () -> serverCapabilitiesSupplier.get().get(key).withAppiumJS(props));
Can you extract a method : createNoGoalConflictMessageSent too?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_0>
Can you make this into a constant?
getCanonicalName returns null if the class is not a valid class. It needs to be more precise to check.
I think we should rather throw an Exception here. That way if the repository is not configured to be created by the GitProvider, e.g. if you let the EnvparseException be thrown.
nit: remove empty line
I don't think this is a test case. This is a test case for an error.
return ImmutableSet.of();
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
I think it should return 10); which is a bad thing here
Consider to replace with "an allowed command".
Nitpick: This is way less than 120 chars, I don't think you need to separate the parameters in different lines. Even when you have a different line, I don't think you need to separate each other.
Why are you not passing the publishers as a parameter of the method?
I think we should avoid passing the MonitorUtils from the emit() method. It's used a similar strategy to emit metrics, but not having them overloaded.
When would the field be null?
I would just add a method in the asyncHttpClientMap to the method, this one does not really need it. The logic is the same as in the asyncHttpClientMap.
Should use Util.fixEmpty(result)
Can we make logHistogram rather than createHistogramSpan(i)?
Please use static import
IMO, url in a constant is misleading. I"m not sure how can you get to this point with url, but if it is, how about just return true/false. (And if it is false- don't you want to return?)
This is not really needed. The token is already a token.
Why are we creating a new instance here?
addAll
Can you please log at debug level here ("Wiping form ID: {}", classTag);
- It'd be good to use %d instead of %d here. That way we detect this in the next div/scale code. I don't have the same logic with using next %r
Can we define this a constant please?
I think we can use migrateContent method here
Please remove
This is pretty expensive, could we use the getSceneOfCommand pattern to take the benefit of checking this?
1. I wonder if there is a bug here. 2. Currently there is no way to get an ChargeStatus from a collection that failed and then happen to use it. 3. A question a Is there any other state in the submitted state and that failed? Is it not in this case that a task will be submitted to the DB?
Should we make this method much easier to read?
Should be: accountingLines.stream().forEach((AccountingLineBases) -> sb.append(line.toString()));
we may be able to use a for here instead of a for loop. E.g.: java final List<Something> out = handle.get(() -> { if (input == null) { return null; } return out; }
So I was thinking about an error-prone approach (Iterator<Relation>) to getModelClass()? If yes, no need to keep the null check.
Doesn't make sense to have this method return a String instead of a getColumnName(Column annotation) since it returns an array instead of a String.
replacing this with helper method would be great
Again, use IOUtils.
Please add the code to the test file for Java 7 and more readable
I don't think we need the null check.
I'd prefer we make the string a constant.
actually not sure why do we need this method?
I think we should add a getStorageDomain method so that we don't have to specify the Domains
If it's not started (see org.apache.w3c.test) you may use org.apache.kafka.common.utils.Utils.isWindows.
Use a stream() method instead of a collect.
It's wrong. The test doesn't specify any fields.
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
I think the volumeFormat string should be private, and only use the @Nullable here
We should move publishingTasks to toString()
Forgotten empty line
isMatrix()?
Shouldnt this have some logic instead of performed multiple times?
Can you throw an IllegalArgumentException instead?
s/on null/in/
This is redundant. The updateTissueMaterialDaoDependencies method will only update the other dao once.
Shouldn't we keep the!workflow.exists() check?
Could you replace with a ellipsis that you're using the StringUtils method, or just the String method?
Shouldn't we have a CompletionException here?
Maybe return an empty string here instead of null?
I think it would be better to use o1.equals(o2.getId()) here
Shouldn't we check for 0 to avoid a NPE?
Time for a helper method?
This variable is not necessary. And as the below one should be below static.
If you need to iterate through the chain, you can just iterate over the entries in these and check if the URI is returned instead of just a keySet.
Could be replaced with ternary operator
nitpick: can be Lists.newArrayList( Iterables.get(data, "user_id"), List.of(ServletContextVs.USERS));
return this.
This is a new target and not actually return an emptytoolchain. To get a whole target you need to wrap the target/ target/log toolchain.
Please add @Override annotation here and change the method signature.
@dmzaytsev let's call it bytes for clarity.
You could use checkNotNull(this, "position"); only.
Same here, it was the same as in the other methods.
move this to xmlLoader
Needs an @Override annotation.
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Not sure if the extra space at the beginning is still needed though. Better leave it there and eventually tackle it in a refactor to uniform the set and make it in a different okButtonFixture variable.
Should this debug message be updated in the else block?
Should be "DataCloud"
Why are you creating this correlationID? Shouldn't this be defined as a static field in the CoreEvent?
Raw type?
Should we skip setting storeName and getJob() here?
suggestion final String lookName = lookSettings.getString(selectedLookName, position);
Fix aliases = aliases =...
(but with the no-arg constructor) you can use a logger instead of System.out
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
Isn't it better to fail the test?
Duplicate code. Could you keep the code concise? I know it is not super elegant, but just to be able to understand how to use the code.
This is just a whitespace change; do you have a different formatter?
Do we need to wait to see this thread to finish?
could we solve this better by overriding sendTimeStamp() in the TracingActor? I'd like if all this trace and message could be in the same class.
Why do you need to send a new ByteBuf? This should use some new ByteBuf, you could use.release(deserialization).
why not keep the name of the variable and use it in the next line instead of here?
Let's use a more meaningful name here like "ctx.gridConfig().getDefaultQueryTimeout()" or something similar.
The ID is used to restore old files (from an older release) so this must not be changed!
1. Do we need to put this? 2. If noVNC_PAGE_URL is needed, we can fail with aVNC_PAGE_URL + "/rest/novncPage.html" and have noVNC_PAGE_URL + "/rest/novncPage.html#novncPage.html#novncPage. Please replace with: String noVNC_PAGE_URL = "rest/novncPage.get(NOVNC_PAGE_URL + "/rest/novncPage.html");
Try using a string.next
Can you assert that the objects are not null?
you could do a lot of work on both lines for instance's
suggestion return fileName;
This validation is redundant since it's already done in the validate()
remove this line
Why this?
why return the exception?
qout was added to the main pull request, is it?
As I think I mentioned previously, we don't have any test case which is not a typo but should be /
This could use the same block, and then return the result.
@Am I lost a ref to this method, just one thing - I didn't test it that we're using it instead of creating new RqFake here.
change the name of this method to channelId
I guess this is better than throw an exception.
nit: you could probably use SymbolReference.fromVariable(...)
This should be this.sizes == 0?
we can do away with the local variable here @rishabh-997
State.state instead of this.state
if the Resource is declared as a member, the caller should handle it
Why not synchronized?
avoid the wait variable and use a string for the start?
please elaborate the need to set the tasks to false and then set the macs to true. it should be set to true if the snapshot is plugged to false. also, if that is not the case we will have more than one vm set to false, please set the pool id to true.
Minor: it is required to check the type here, since it is a type and not a Type.
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do findFirst() with a very simple method that encapsulates the logic?
Here you should just let the DateUtils.addMinutes(now) method.
better do property module.getOriginModuleUrl()
nit: can use the StandardCharsets#UTF_8 constant here.
can you add the exception in the print?
Don't log and throw.
This will be faster if we use the set directly to compute the page's content.
is this the best place to do this?
This is a clear programming error, right? If so, suggest throwing NPE instead.
Can you simplify this logic? indicativeSentencesGeneration.DEFAULT_SEPARATOR!
Doesn't this condition always evaluate to true?
Use the constant
Add a "user" field to com.google.gerrit.core.request.IdentifiedAt(UpdateStatus)
Throw the exception using a more specific exception than NotConnectedException.
Do you really need this?
remove
Please shorten selector.nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN to something like getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If selector.lookupName(index) returns null for the first time, you can immediately return null for the first selector.lookupName(index) returns null for the dimSelector, so getValueCardinality() might return an Optional, but getValueCardinality() returns an Optional, so it seems better to use Optional.empty() here and return null.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
This whole method can be replaced with: getBinding(stack.getOwnerName()).add(new TextComponentTranslation("this.auto.currentOwner", binding.getOwnerName()));
I think we can use the findNotEscapedQuery(); like we do with currentIndex it's only input2 and not the other findGroupStart methods
Rebase error - should be used Helper.getCurrentUser.
I see it is set by our existing code, but you have the form name in the message. So when we display this, we are updating the text in the ui test, right?
Maybe use the constants from GravityData.
I would suggest to remove this log.info, this is a debug message
why are we changing this?
fix workspace name if you're using workspace instead
Same here, using double.
Are you sure this.public. I was thinking.
use unmodifiable list
Why not use the original code like: action.setMapping(settings, OPENSHIFT_ES_MAPPINGS_MAPPINGS_KIBANA_MAPPINGS_KIBANA_MAPPINGS_KIBANA_MAPPINGS_KIBANA_MAPPINGS_KIBANA_MAPPINGS_KIBANA_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_KIBANA_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KIBANA_SEED_MAPPINGS_KI
nit: Indentation out of whack here too
This should probably be public
Use an interface for the non-private key.
Check main entry for bitmaps.
I mean to put this crash on a null object, cause if it's null here and also get NPE
is it better to use Collections.emptyList()?
What if theThrottlingIfHeader already contains a property named 'ThrottlingIfHeader' or 'boolean-method (without the ". and") here? If the check is true, this should be moved outside of the if.
Is this not the default value?
should we have a message to know about the class name?
This is a duplicate of the code. Can you extract it to a private method?
nit: use ImmutableMap.of()
Why are we returning the empty list instead of null?
requireNonNull
Hey @aville, could you please put a bump on this (and the tank)? Thanks!
this should be private.
this method is not a very clean way of doing it but it would be better if you remove the state of the consumerProcess; that would remove any element from the list after a job has been removed from the webProcesses list.
Can we assert the result of this method on the service names?
What is error message for? I would use equals over == to make it more obvious.
Instead of calling isDisplayed, it would be better to use here, to avoid any confusion.
You could compare directly instead of using values
I think you can't use the null check here.
If I understand correctly, DbFilter is no more used. So why keeping it?
That's a bit hard to read... wouldn't it be simpler to have a single call to 'homoglyph_norm()' here?
I would rather use isNullOrEmpty instead of just checking for null and empty string. This allows us to encode the url with a string that is empty.
Use a try-with-resources block with a temp file is not necessary
Perhaps we could use debug level here
Please add assertion for this.
This validation should be done in a private method that is called from the constructor.
Remove this.
replace with TestUtil.testRuleTester.test
Extra space after )
save an iterator by using index
suggestion serviceRegistry.getService(new LeaseDuration(serviceRegistry.class));
I think this relies on the cursor and a performCursors() which you can use to mock cursors after this. I think this should be addressed in another PR, but we're now making a change that tests some more complicated.
Should we validate that it's a Message?
Is there a reason why this is called in the super class constructor?
please move this to the previous line
Can you please invert this one so it returns always false and do return String.format(...)
nit: you could simplify this to java boolean ableCellRenderer = s == null? s/ s/ s/ s/ s/ s/ s/ s/ s/ s/ s/ s/ s/ s/filePath/g
ImmutableList.of()
nit: I think that in this context we use globalServiceInstance and keep metrics for services as they are property. Type is not mandatory in this context. So I would suggest to remove this line and add a method like: private Registration localServiceInstance; private Registration localServiceInstance; //... and from other side // Registration from this map is accessed by other classes // to prevent expensive filesystem filesystem //. Pull Registration from level to Registration from other services as well.
Why is this private?
add e to log message
@bdragan this.doc.index() is already an instance of this, so it can be reused here too
Should this be checked by other classes (like "isAssignableFrom")?
Should this return an exception instead of throwing an IOException?
I assume line.static line should be used here.
Is there a particular reason these shouldn't be.enableButtons(true);?
is it really necessary to use the super() here?
Could we use Collections.emptyList() for the empty list?
Here too, have to be fixed by #487
Why is this needed?
s/a/b/c/
It should be new TajoRuntimeException(new InvalidCastException(...).
See above. Shall we use our drillDownArray#add method?
properties.load() is duplicated
Use assertEquals instead.
Is this needed? This simply says "Create API with the name field, but this method is deprecated.
unused?
please use static Double.compare
Please remove.
Can we wait for this instead?
Scratch that is not needed (see above).
path.startsWith(pattern) should be checked with StringUtils.startsWith(pattern)
If we're not using the writePermission() method, you can remove the getMarshaller() and getPhysicalObjectQueryForRequest() from the super class.
I guess you mean to pass emptyList()?
return resource.getOrDefault(..., "null");
This should be a direct reference to ActiveMQWebLogger.LOGGER rather than just for debugging.
.applyTo() is shorter and easier to read
getServicePolicy shouldn't ever return null. It would be a good idea to cache the policy in a field and if it is null it would return an empty list.
This change should not be needed.
Since you have to remove this line, you can put a "COUGHS.getConceptId()" in a local variable to avoid doing it.
Beginning with the exception should be propogated immediately to the method.
This would be better as..toggling only on domain.
@lautarobock This test is failing on this line.
Global listener catch each click. You don't need to log it.
We can put the fragment's initialization code inside the DialogFragment as well.
Shouldn't this be equals()?
are these two switch statements necessary?
The order of the arguments is reversed - it should be assertEquals("Test_123", result);
should we also add a check here if the output is an empty?
Should return something here, not null.
Same question about unit conversion as earlier.
This default setting is MARKDOWN_ON_PER_DAY, so it would be best to put this back in a constant (so if we ever change the messaging, we should still preserve this for our own intention).
RefNames is re-used in other places. Having a Tag page and it is confusing to me. But the display name is not only about the tags that are accessible by the UI in the UI but the attribute defined by the user can change and it will be different. Maybe we should add a new method div[context](<LINK_0> and have there be a better name in this class?
The parameter can bee removed
Use BukkitTagContext instead?
I think it is better to use streams API here (and for the other method) instead of the concrete class.
here you should call assertrecoveryRate after calling assert asserts, right?
suggestion createUser("admin@nhn.com", "admin@nhn.com", "admin@n.com", "admin@nhn.com", "admin@n.org");
This needs to be wrapped in a try-with-resources
rename to mBranch
Let's keep the context.get(messageIndex) and use a regular if test for the return value.
I'm not sure this is correct. If this job is user run, this must be an NOOP
Please parse the URI to a local field, with a ternary to avoid the possibility of a NPE
concat empty str?
";" at the end of the file
We should add a message here
Thanks for changing this to a better name. I didn't notice this before.
This is a warning.
shouldn't this be cdPath?
The exception also needs to be modified a bit.
nit: Can you get rid of the nit, please?
As the only reason that mediaListMode is null is the default. Could we do something like this? // Duplicated functionality? List<String> mediaListMode = MediaListMode.LIST; return options.getType().equals(MediaListMode.LIST;
What are the callers of this method public?
unnecessary change
I would prefer that this is inlined as I think
Can we use method reference here?
suggestion return isBlank(queryParam.getValue());
if you rework this, you don't update the state system
Stray.
perhaps a race condition would be more visible and probably reset the dispose flag after setConfig(false)
CheckForNull
It's an error message, I'd rather use a different word than RecordsRetrieved type, so that we don't have to use the same message.
nit: should we just add a "path" to the name of this class?
LocalDate.format(Timeone.UTC);
Ouch, _n_ might be better to use try-with-resources. A cleaner way to handle this would be to close all resources inside a try-with-resources block.
Why it is null? If we have to go this route, then maybe we should remove the rule here.
I think it's better to use DEFAULT_FILE_NAME here instead of "/#replace('.', '/'".
There are no members defined for this message. We need to write this message to the CommonHelper.
java if (nextChild == null) { return; } parent.parent = null;
this should be if (encodings == null)
Suggestion: Consider using a ternary operator: suggestion if (server.enableNotifications()) { return!settings.isBindingEnabled() && server.enableNotifications(); } return null;
make it fail
we can do without zero rows, will the rest of the for-loop better?
Can we make this AssertJ ArgumentPreparedStatementSetter since OAuth2 is JSON Object and the right type would be OAuth2ndSetter so that we can handle the reading of the BLOB.
getPaddingLeft() is an int, but not really a big deal.
I wonder if this should be part of the callback?
This will override default visibility, you want to do something similar to what is done in importStorageDomainBackup?
This should be a User ID.
Still worth using Map<String, Object> commandParameters = Collections.emptyMap(); It's not a big deal, however in this case commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
use true -> false otherwise the matcher will return true.
updatePassword() method in UiCommonInitEventBase
can we have this as an inner class?
omit?
can be chained onto previous line's assertion
This won't compile. The lambda will return the property from the method, so I expect it to be null.
You can do getStartTime() directly on the start, and end coordinates in the parent class CTFStream. Surely you can have a dedicated method that does the same thing?
nit: This is not a good practice. Could you create a private method to create the TableName(String tableName)?
remove this
Can be simplified to "if ( smart notifications is available in the SonarQube edition, then the name of the class is available in the constructor"
logger.debug("Mapping: item name=" + propertyName);
It seems that this could all be written as: java private CallbackInfoPlayServer; I suggest this.connection = -1; I stumbled upon an NPE.
Maybe should be an NotificationChannel here.
Add Override annotation.
Should we update entry to null after setting entry.
there are no assertions here?
I believe we should also get rid of the exception from the catch block. If it's not there, then we need to modify it.
If the field was null, then it would be easier to read than that.
@exper0 please use this.VALUES_STR
Why don't we set bookmark to an empty list and simply call setBookmark(true)?
We catch not handle IOExceptions however.
please make checkExpType() method more simply to be sure that the right result is the expected, otherwise it will always be NULL.
Can we please extract this list into a class, please?
So this Mono may be used for chaining. A create(StartResponse) method would be better.
Unneeded parenthesis
Inline the variable
Why not just use a fixed message here, I don't think we need a new MessageConverter in the core?
Wouldn't this be enough to just wrap the EurekaClientConfig with a EurekaClientConfig with a eurekaClient and and treat them as an immutable if only they are used?
Consider making the strings a constant for this
Exception is never thrown
nit: this extra line is unnecessary
Could you please use append?
should this be clusterCompatibilityVersion?
Why did you change this?
Can we make this configurable like for the view?
lines 62-63 can be combined in the same line.
Maybe, we should check that the config is also set from system properties?
Why do we need to many operations, can't we add the limit directly to the array when we add them to the list?
backingStream = null might be better to have the dispose of the backingStream field and dispose them in the finally block.
@lmontrieux Wow... Strange. I think it can be final, but it works pretty well.
Please make the copy of inner argument to avoid duplicate code.
Why is this not assert?
put this in a protected method
@yugander I don't like this approach because it looks like more or less code than one. Why are there two tests using the same code to convert an array to a single Token and getTokens?
Unchecked cast.
This method is really long, please use isSupported()?
So, each sequence has its own declaration, we can have a different Facts and no need for the concrete class. And for the other cases, we should check if the value is a string or "default".
move up
Could it be SYNC_KEY
Shouldn't we return clientStatusList.get(reg.getEndpoint())?
Can we have a different name for this method?
test will be more realistic if no low?
This does not depend on any UI thread. Containers, which is a thread-safe way to do this.  synchronized (mLock) { if (mLock!= DOWNSTREAM_NONE) { mUpdateLock = true; } } if (setupNotification) { mUpdateLock = false; }
nit: missing this. in the if statement
Maybe a check here that getLeft() and getRight() have identical schema?
I like this idea but I don't think there are much need to modify the OperationTemplatePartial that can be used by anything else. In general, if an exception is thrown on the right hand side, the check is really needed. Just curious if there is a reason to keep this differently before using getResponseNode() and it is just a type that we are expecting to have getType() in the correct order.
elapsedNanos.
remove this redundant else
It should be config.getDefaultClockProvider()
it should be: verify(mMockCI).unregisterForIccRefresh()
The "brackets for single statements" cleanup
events are always registered. This might be be in the event queue.
Even though it seems the variable should be changed to mSite.STOCK_MEDIA_PICKER_SINGLE_SELECT, it's not a statement that is being used anywhere. I'd suggest removing the (like I did) around the intent and the unit tests. Wdyt?
Missing flush here.
Why do you use a LinkedList?
I would prefer to either remove the super.dispose() or just do nothing (as it is currently done in the super class)
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
What if build.getParent()!= null?
Use { } around if statement.
This needs to check the container doesn't exist.
Can we make this URL generic? It would also make it easier to read.
This can be simplified to: return Objects.equals(name, value);
This should never be true, the "show" flag should always be set by the setFocus()).
Please make it _package_.
This variable is not needed, the 'throws' is not needed anymore.
Don't use this.context.initializeModuleSources. Use a different constructor. It will require you to initialize setDefault in the BundleContext. Or even better, remove it.
why this three lines?
This is not a test. It should be just an email, not a email.
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
I'd change the logic to include "peakMemory" to "public". The change in is no longer necessary.
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
Why does the 1048576L then MAX_BASE_SIE or something?
Spacing
use buffer.remaining() when allocating the copy buffer
This should be updated to UNIQUE_{type}}
I think this should be removed if we add new Optional.empty(); here, or at least return Optional.empty();
Could we use <LINK_0> as the assert method, to get the Runnable instead of a count?
You can use a Matcher#replaceAll here.
you should change the foreach to a for loop
Maybe wrap this into logger.info?
else is redundant
use Objects.hash()
If the getCachedVm() method is invoked multiple times, it will result in a null pointer exception. In this case, I wonder if this is not the right place:)
Ensure the full stacktrace is logged.
You can use Optional.fromNullable().
Extract local variable for readability
You should change this to protected static?
suggestion logger.warn("Could not remove element: {}", element.getUID(), ex);
Can you do this in the constructor? Otherwise we have a builder with optional properties.
if the encoding cannot be null, it will lead to a NPE
Same again. There's a IProgressMonitorException constructor that does this check.
The meaning of this is that you are only interested in the transaction, and you don't actually need to request it
"{" is used to be a long parameter, but in all other object.toString methods "[" is used.
should be the enum?
Please remove this.
I don't think TM_RESOURCE_SPEC should be here.
If we want to store the latest Version of the bandwidth I believe we should call DataUtil.createINSTRUCTION.
Don't we need to do the caching here?
I think this should be removed, right?
we should test with the plugin name that is included in the test. the jira issue is that the plugin paths are different from the op:..b2 test(sadobe.acs.commons.common.server.Location(TestUtils.IS_HOME))
Shouldn't you use the new isEmpty method?
Please import the assert method
since we are also loading the whole Trace, I would prefer to avoid a call to the map.
Can be inlined to make it easier to read.
Could this be simplified to return Predicates.instanceof(public, name)?
I think we need to do this by context.getClusterConf(), cm. backend.getClusterConf().get(SarinHost.META_MASTER_POLLING_RATE
I don't see a change to this method. How about getting the environment name directly from the method: java return new RuleChain();
Wouldn't it be better to set AnonymousMessageListenerContainer to false in stop()?
Things look good. What do you think about moving this logic to the model class?
I think that in this case is a bad idea to try to stop the new user when we try to run the code. Maybe just cancel the current call, dispose, and use that in the finally block?
Would it be possible to put this to all the log statements at the same time?
deletes should be on the same line.
missing "commands".
If requestToSave is null, why we need this line?
Can we use this on the client side, and return a Response object?
Can be done in a single line.
You can use the following pattern: namespaceCreatableUtils.addDependencyLogs(namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, namespaceCreatable, EventHubNamespaceImpl namespaceCreatable, namespaceCreatable, EventHubNamespaceImpl::new)
Maybe we should use sizeInG since this is the only reason we have > 1 GB. I know it's a small size but then we are using GIGABYTE here. And I'd have thought this could be a GB or a lot of a memory leak.
fileName = "Factory.create(path.toString()).replaceAll("", ".") is used only once
I think there is a bug in the job builder, when boon you forgot to add a null value into the map.
Should use a constant instead of a raw String
You could also return that in the data you have a fixed L gui to avoid casting to int.
Can we remove all of this logic?
You have two DAO calls here, which is the same.
I think you can create an issue to the "presenter" instead of using newInstance() method.
I think that's enough to have executor and Timer stuff in all executors. We need to be some kind of mechanism for that.
We need to synchronized here too.
Can you describe the default machine name in the gerrit user?
Shouldn't we use the fileService.exists() method? This may cause NPE
Just a nitpick: I think it's better to move this line in the synchronized block.
Could we simplify this to return executor;?
I'm not sure if you are using this template as a parameter. Should we set it to the default value for argsParameter to be null or empty?
This is dangerous. A good example is to have a test that either all the fields in the global or none, but not one. (We should validate that the super.visitContext(null, null)) is set which would cause a race condition.)
There is a sub-base error here (above) It should be:.baseError() = (sub.baseError()).subPath.sub(base, ); It would be a line, which is a line lambda, and the code is not necessary.
Missing first argument of this method
nit: just do this: return environment.getArgument("disabled", true);
nit: missing a space after if
Minor: Please add a check for deprecation here
I think this should be asserting that the 3Q6c2@br99 is _always_ a _response_ of a _response_.
If we use lower case here, then we should get some kind of random toString
Should this be one line down after site?
I believe the second part of this call is not necessary anymore after. The second call to this method can throw a runtime exception, so the line below would be skipped.
Probably should be a slash, not a separator.
Shouldn't this be Flux.error(t)?
please put each parameter in separate line :)
Is this needed? I think this will store the buffer in its own field and that's not going to be modified each time this method is called.
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
1. I don't like creating new vm here, it should be exactly that the vm is not down. 2. why do you need to check that vm can be null here?
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface?
add "isSupported=" to the toString()
Make this a final field
This can be deleted, it's probably better to assert that it was deleted.
nit: can be removed
Please add validation on the parser.
Do we need a second param here? If we're only using the old config path, do we need to double check
Should we make testNoCloneCloneClone() to have some common parts of the file?
return value!= null && value.trim().isEmpty()
we can drop the LOG.error("Python Ready mergeinessChange(true)?
Please move the assignment inside the method and remove the one below.
Can we use a ReflectiveOperationException and the orElse should be false?
This is confusing. I don't know why we can't set queryAttr here, but it does work with the other variants.
Nit: This should be null
You can call beginFromRealm(int) with whatever it was called.
target could be null here
What if the list is empty?
Is this the right error message?
This method could be static.
static import
It would be better to store the Update_id into a field, then call equals on it.
since setting entity to void may be confusing, I suggest to go with params =..., and fix if possible, this method should return void, and fix if possible.
Since closeStreamAfterSend() throws an exception, we should have a try/catch around this.evaluationContextSet.forEach().
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
typo
If config is ConfigData then have to be populated with the config value and it is better to use config.get(config.getCageHeight())
Since the message doesn't say anything. The test needs to be changed.
@erimerturk why you're using RqFake here?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!getClassConstantOperand().endsWith("getPackageName().equals(getClass()) can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
If data is empty and data is returned by the getter, why not in this case?
I think we should be more explicit about the Context constructor - this should be an "Exception"
output.print(eventBody) is unnecessary
wrong formatting - every parameter should be in new line
I would add a call to repaint here.
please add call to populate: add(StorageConnections collection, storageConnections.StorageType.StorageType.class )
please remove brackets
I think we should use "1.0".equals(version) to avoid possible NPE
How about throw an IllegalStateException? Then we can remove the test, and we don't have to loop again.
wrapper?
If you have a request, it would be better to do that with the other parametrization, otherwise there's a chance of inconsistent behaviour in the buildAs method.
I think we should use Logger.debug("On index {}", i); instead.
the 'public' is not needed
As above: private, 100 chars, use error result instead of doOnError.
Sure we only do this when the scheduler is running? Otherwise we might consider moving this down into the eventListener which is only invoked when the scheduler is running.
Can this be extracted into a new method isBinaryValid().
Suggest this: if (userChoice == JOptionPane.YES_OPTION) { return CanOpenState.DISCARDIN_OPTION; } if (userChoice == JOptionPane.YES_OPTION) { return CanOpenState.NO_OPTION; } else { return CanOpenState.OPEN; }
Does it make sense to be getNonStrictParentOfType here? That will return true for arrays of assignment being null.
This looks good.
Is this a bug fix?
Why do we need above change? dbName and schemaName can be null if we don't set it in the DB. If this isn't the case, then this line should be moved into the next line.
Minor: "Connection for {} is missing"
Wouldn't it be better to just use DataTypeLibrary.getInstance().getDataTypesSorted()?
this should return the entire hostProviderProxyFactory which returned the providers?
Speaking of sanity checks, is this: (100 - minLastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
remove, Exception is not thrown.
Wouldn't it be better to just use "return reportDifference(o1 == null)" instead?
I think it would be better to use this format like this:.stream().filter(m ->!m.equals(d)).findFirst().map(c -> c.create(d)).collect(Collectors.toList()); I think that would be actually better.
why do we want to restrict it? the error messsage is relatively harmless and doesn't really alter the flow
This synchronization is unnecessary
I think this method should return RemoteCache<K, V>
Isn't pattern should be a the first ? (add extra  a the end)
you need to wrap this.
Make it final static
nit: we could extract this into it own method or extract it as it's repeated on each callback.
why not just dir.exists()?
This method should return the interface (e.g. getDiagram()) not / fetchmp3
Can you change the return type to boolean?
Maybe we could add a check to make sure we don't have a PackingPlan object if the Plan is created.
This could be tweaked to return immediately, since the menu is not enabled it does not worth continue.
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
mListener should be outstanding requests. Otherwise, you have a listener with a listener that never gets called.
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
introducing double retrieval from thread local, unnecessary perf hit
Why the addition of this? This should be done in the constructor.
I find it a bit strange to define this in a constant
Please use log4j.id here instead of ignore-case
Can we use brackets now?
Can you please reformat this method with the same name as 4th argument?
The Class isn't a class context, as it is used to be used by other functions in this class
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
you may return responses; here, if response is null, return responses;
Should log an error and not silently ignore or not, or should we log something higher than debug?
I think that this field is used only once, it is used here.
Probably we can use a builder method here.
Can we collapse this to: checkArgument(!isValueTypeArgument); return lambdaInterface.getLambdaInterface() == null? lambdaInterface.getLambdaInterface() : null;
I think this method should be simplified to return (User) auth.getPrincipal().getSeatByUsername(user).getSeatByUsername());
nit: this.min = Preconditions.checkNotNull(bucketCount, "bucketCount"); this.weights = min(bucketCount, min);
This should be the type to the dictionary.
Can combine the 2 above lines and use the constructor which accepts disk-id
I wonder if this should be 'public'? For example, Object case = getResponseValue(); return null;
Would it be possible to also check the cacheCachingEnabled.isFileResolver()?
Hm, these two messages are not consistent. They are unnecessarily final.
Minor: Use this. consistently in the class.
I'd add a checkNotNull here.
minor: no need to check the configMaps here. Otherwise we may end up retrieving the value from configMaps if the value of LeaderInformation.
Can we have a check for hostAffinityEnabled before the refresh?
Please use the new message for the null case.
I think you can use hotfix.
Suggest delaying the delay to be after the delay has been passed.
Empty filter? The empty map does not filter for duplicates, which in theory depends on the filter (maybe hash it, or at least return a blank map). So, should we filter for an empty map that is missing or it's defeats the purpose of the map? (maybe just add a check for the empty map and if it's collapsed into a single map?)
I don't think this is necessary
public?
suggestion log.debug("Unsupported S3Select serde format found: {}", serdeName);
Perhaps click on the button too?
ISO-8859-1" should have a "ISO-8859-1"" literal, so it is just a typo.
Should we reset this field in the constructor instead?
suggestion Preconditions.checkState(runtimeConfig.get("Either Refreshable or Supplier of runtime config must be provided or none.");
@vilchik-elena I would make it a method
add { and } around if you like
resolveLiteral() can be private, I think
unsupported
Add a LOGGER.log(Level.INFO, "Restarted Listener will not be completed"); Use LOGGER.log(Level.SEVERE, "Reschedule Listener which is called during shutdown" + this.getClass().getSimpleName() + " doesn't interrupt the thread.");
Consider using the constant for this.
Better to use Java 7 String.join()
rename to viewStack
Is this a sufficient check? Should we test for the tag rather than working tag?
This could be made more compact.
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void shouldContain(String jedi) { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldContain(jedi, list("lightSaberColor"), list("name"))); }
I would prefer to return the result of equals to avoid the need for the comparison
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
This change breaks binary compatibility, but cannot be OK.
This is the same from the TTfield, so can just be!a.contains(Capability.TOKEN_UP)
The synchronized can be removed.
Add final keyword.
Map<TableScanNode, Void> result = new IdentityHashMap<>();
Just return getProperties().getSingleProperty( name, defaultValue);
Small nit, but could you build a style class so that you don't have to use the getURL() method for the parent class?
Don't we need these inside the try()?
please don't use getLastWatchdogEvent() == null
can this be private?
I think we should try to use fExperiment.init() here, like you do in fExperiment.init()
Include the method name as well?
I guess it would be better to add this to the ExpressionPresenter's functions.
should this be maxAllowed?
Why not return clusterId;?
Change this variable declaration to something with meaning in the context. map is unclear here
is this intended to be -1 for blobTimeInMs requests?
Same here, let's throw Exception instead of throwing Exception
Use GLOBAL_ROLE_PATTERN here, to avoid duplication
Please don't remove this. The method has been setText from the previous line.
FQN of class, is not very descriptive.
can't we use safe assignment if all listeners are initialized in the same thread?
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
- This should probably check that the Signals don't have this.
The cache mode doesn't care about the value from the cache, it is resulting in the client configuration.
This should be /library/file.proto
I'm not sure if this is a good idea to pull out all the common code from the util as a function. Should not use null, just return the same object. It would also be more readable (it's not related to this PR).
maybe use isEmpty instead of ==
This will create 0 connections. Didn't you mean <?
Why don't we just create a new GsonBuilder() here?
Is the KeyPairProvider not available?
Since the.is() is invoked multiple times, I would prefer to move it before the if.
rename to ascending
There are other places in this class which we may end up IdGenerationStrategy. What do you think?
Can this be simplified to Arrays.asList(o);
This seems to be quite complex! Maybe we can define a PanelDetailsMap element returned?
hmm, what does this mean?
Guessing this locks should be acquired here.
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
This code has nothing to do with a vanilla flag, isn't it?
I'm not sure if this combination is correct.. it seems that that you should use a try-with-resources statement instead of if (ReadLock), which is faster to read with the result of this method.
can be package private?
This should probably be && instead of ||
I think this part is redundant with the settings in setupModuleToCMAS, isn't it?
remove
won't this cause NPE?
Let's use java.util.Objects.requireNonNull(commandId, "commandId");
Looks good.
Redundant parentheses.
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());
Maybe put this on the call to the constructor?
Extra parentheses can be removed
suggestion log.debug("Unable to find default configuration: {}", DEFAULT_API_KEY_PROPERTIES);
suggestion if (keyedStateBackend instanceof CheckpointListener) { Since the instanceof operator always returns false for null, there is no need to have an additional null check.
I think it is better to use parameterized logging instead of string concatenation.
write nullable on the same line or don't write it
we have a race condition here. setVisible() is not necessary now.
"auto" -> "nomous"
Shouldn't conn be a finally?
May be worth to use startsWith instead of endsWith.
don't a need to check for null, it's true by default
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
better to set slaveConnectTimeout to true here to indicate a slave or intermediate timeout, to ensure that it can happen as expected.
I think it would be nice to keep this method unchanged (to support support for handling options in the map.)
please rename to source
What is the difference between create and buildAccountUpdater?
Should this be acid? And not acid?
Can you make this a method, and use the [this](<LINK_0> instead?
Typo: I think the default should be in the set as well.
Did you mean to leave this if, too?
can just define this
If we are going to change this class, why not make it static?
Consider adding a getFlows method to the criteria, i.e. noFlows
This log is redundant. Just use the class name, since it's used in many places.
why not use the Java conventions for variable names?
It could use the following style: java final PopupFlagCustomPageIndicatorMenu = ctx.getIdId();
could use the CommonUtils.toImmutableSet() method here?
The original might not be larger than t11 t11 t01.
should it throw an exception instead of returning null?
Let's keep this until it's completed.
We don't need to use a null key here. Use a DEFAULT_FS_FILE_NAME to make it unique to make it unique.
could be the same value with nodeStats.getPlanNodeId()
Shall we define this as a constant?
I think we should use entrySet instead of keySet.
are you sure about this exception?
Code should have -t been removed
null check it's worthlist.size() == 1
Use dataBuffer.getInt instead of write to dataBuffer.
Readability is concern here, If the id is not set, it will throw a NullPointerException. Other than that, getId() will throw a null pointer exception. suggestion createDatabaseInternal(database, context, Context.getId(), database, spanName, database, Context.get());
This should probably be languageName
Same issue as above.
Can we rename 'p' or 'p'?
There are other options available for this in allgamemode creative mode. I'd prefer to use the Java style, but only one tip is using it like this: <LINK_0>
This is wrong. If you use the custom Version all over the place, you should probably also use the resource string.
Do we need this?
I'm not sure this is really needed. All TranslationFormat should be format = format.getString("format(Format.USX, format)
Is there a reason for this to be a list of classes that aren't using?
This should be 8 bytes. See BytesWritable(byte[], int).
>byte[] authenticationTag
This can be static
Can we use Arrays.deepEquals here instead?
1. This can be reverted. 2. The case where each of these is equal but the other is defined, we don't check whether the classes are class is correctly defined.
There's no need to check for [] here, just return null if there's no substitutions specified, to differentiate between two.
Is it a duplicate the exception handling?
What do you think about undoing the process not introducing a new rule?
Can we call Arrays.asList(operands.getOperandList(), Collections.unmodifiableList(Arrays.asList(operands));?
Change to private
use assertEquals instead of assertEquals
I think this should also be in the case when the data has valid permission, not INVALID_TYPE_ARGUMENT
Use data.getData()!= null && data.getData instanceof Comparison is false
I think it's better to return doubles[this] == null || doubles[index] == null && doubles[index] == null]
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _context.getScenarioGridPanel().setFocus(true);_
&& super.untrackView(view);
This does not seem to be used in the tests.
use ShellIsAvailable
Please remove this. inbox variable.
This should probably be Log.e instead.
Please change to provisioned => provisioned
I'd suggest using a org.apache.commons.lang3.ArrayUtils.closeQuietly(Thread.class, "Closed internal ").join();
can the toString() be avoided here?
Please, don't use _spy when this code is called, code will be called every time the onResume() is called. Please, remove this line from the onResume() method and change the code to be called in onResume().
add InfoboxChoiceModal instead of UIPage
We can transform the time to a long end and use Math.abs instead of the delay.
Could this potentially be moved to the end of the method?
Remember to put {} around if/else/while/for etc.
change to asyncResponse
Why can't we use an iterator here?
This line can be removed
Make it private
can be simplified to int bondOptions = getParameters().getAdAggregatorId(); if (bondAggregator!= null && bond.getName()) { return true; } as well
Shall we make this "else" a constant, and use it here?
It is not an issue, but can we do the same thing in the updateTaskAdapters()?
rename 'child'
ImmutableList.of()
System.equals()
s/public Config<Object> getFromMetricsMessage
The loop iterations over the same elements is a bit difficult to read. Can we extract it to a private method?
Maybe use "proposalData" instead of "Transaction" here?
Should it be [this](<LINK_0>
If this is an error, then we need to log it. This is a warning.
Put this method on the client-side?
Static import getBytes(...) instead of getBytes().
Is it the same as in the getFilterBlobLimit()? If so, can we make this a little more consistent?
Multi-line if-blocks should also be done with..
Could have @VisibleForTesting annotation. Also could public be removed?
Can we make this protected?
Should be factory.xmlTest(clazz, methodName, null);
use new Guid(String) - this literal can't be null
initial capacity is less than initial capacity
suggestion if (getDefaultOrNull(formField.getValueType(), formField.getValueType())) { return null; } else if (obj instanceof PHONE || formField.getValueType() == formField.getValueType()) { return null; } // use the toString() method from guava
> 0 (/ 2 > 0)
maybe use ByteString.of instead?
will add constants, too much configs which nobody would know how to set those and will know how to set them
return regionGroupMap.get(regionAndId.regionAndId.name());
What happens if the timestamp is null?
I think the reassignment in the line above does not make sense. The code will clear the release of the promise chain, even if it's empty.
This filtering should be done in the consIterator of PERUNOBSERVER.
Can we put this with a mock?
I wonder if this would be better as something like: if (this.beanFactory == null) { this.beanFactory = IntegrationContextUtils.getIntegrationProperties(this.beanFactory); } and the with-line IntegrationContextUtils.beanFactory = IntegrationContextUtils.getIntegrationProperties(this.beanFactory); in the end of this.beanFactory. I don't see why it does blocking() here.
Should we use a reference to the ROLE_USER_store_name or Resize_?
Do we want to assert the output threshold?
This if-block can be removed.
This is implementation of the method use of the INTENT_SHARE. It should be moved to a method underlining/flow.
In this case, the test isn't immediately clear to me. The fact that the thread has started out of the package, which means that the thread interrupteds run. Is there any way to put a failure/assert for that? Also, this method has the advantage of delaying of the stop operation as well, and the test doesn't use it as the annotation. The method name should stop-all-execute for the such cases, though.
Style-nit: I think this should be if (gsEnvironment!= null)
typo: 'driver' parameter
I am unsure how to feel about the divider. I know it's in the dialog, but on this page, it just seems... off.
Should be lineRange
Local variable not required. You can directly populate the class level variable this.servers
Why don't you pass null instead of empty?
NPEs in this line.
Should this be a private static?
remoteList.contains(true)
I think we could have a simpler approach with a method in Utils, for example: private static void attemptOnIssue(InputFile issue) { if (IssueLocation location!= null) { currentLocation.endColumn(); } }
@fanifieiev move this outside of the for loop.
either change the method name to refresh or removing the storage pool - this should be done in a transaction
The index is so limited by my question. It's not necessarily "a". We have to make this change more in the base patch set by the line checkers.
map.put("duration", now - startOffset)
This can be simplified to expect exception.expect(IllegalArgumentException.class);
please use.equals instead of ==.
Should this be made into a constant?
Unnecessary call to super()
I think that instead of "varInstanceDesc" we could use a variable such as nodeInstanceDesc or similar, that is called "processInstance".
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().getIsValid( } remove union (like you did in name validation)
All of this can be replaced with an ExecutorService
CommitInfo is already being used in this method.
I would use the Java 8's Asserts.succeedsEventually(...) - that's an assertion that it is a public void testQuery() {
Do you really want a library reference here? I would suggest changing the log message to be more clear
@vilchik-elena Please replace the while loop with a single filter.
doesn't look like this correct an IllegalArgumentException
Use constructor with this.
I wonder if this change would result in a lot of extra paranoid. The PSQLState.tr("No IOException"), so if there is an unchecked exception, the error message will be logged, instead of e.g. String.format("No IOException thrown while the sbuf is copied", e); I think the following will work: if (ch == null) { sb.append('"'); } else { sb.append('"'); }
Why doesn't we use other executor here?
Same deal.
subsystem.add("cache-container") should be removed
Same as above: could use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty().buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }).test().awaitDone(5, TimeUnit.SECONDS).assertFailure(TestException.class) ;
StringHelper.isNullOrEmpty()
I think we can use.filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) here.
Why is this a String? It's not a static field? While we are a bit _not_ giving us a name to the log, this might be something less verbose.
This is two-space indentation. Since we are only using it, do we want to leave indentation for each space?
Response is a better name than dilution
Why do you need to duplicate this call?
minor: no need to move this switch statement around
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
are you sure this can't cause a memory leak?
Instead of using try-with-resources for closeSoftKeyboard, which can be explicit in the finally block
Use logger
Use this style {} syntax.
Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
this method is called in every test.
we should probably check in the canExecute whether we reached the end of the list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Could add a check here for the property type and call the method on FetchHints.
The Exception is never thrown.
LOG.info("Could not connect to : {}, timeout: {}", endpoint.getClass(), timeout);
The name of the data handler is not quite clear. It is only used in test.
nit: formatting
Again, since you are using a lot of SQL magic values, you should probably create a class with a named constant for the key generation and use it here.
Check a character to avoid clicking on unescapeIdentifier("self") implementation in the first place.
Do we need to define this?
Please add java doc
Basically the same issue as mentioned above, I believe.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
I would have put this into the first if to avoid the need for the last.
InfrastructureException can not be thrown here
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
Do the validate before calling this.instanceMetaData
Please don't use System.out here. Use logger.
How about extracting this to a method?
Just return here
I think test for the presence of "empty" expression is a bit nicer to read, as we are comparing a string with an expression containing no "empty" sequence.
space
declare throws DbWriteOperationsBlockedException
use it instead of reading sysprep config?
should this happen before matching the flare DNS record? If we give the result for all failed requests, we should probably do some DNS requests. Maybe a running DNS requests would be reasonable.
Could also change #859 to future.getAsyncCommitExecutor.failed(msg)
This is too broad and is swallowing exceptions that need to be propagated.
Small nitpick: I think it'd be easier to do the following: java AppLog.e( "note = " + note.getId(), "
can you pull '!' into a constant
Defining "web-auth" string as a constant will make the code clear, IMHO, and will allow to avoid duplication.
Do we really need to cast value to long here?
Are these files still required?
@ikhvostenkov please name it just json
Please add a null check for getActivity() as well. I think that we *do not want to use recyclerViewId here.
We should mutualize a hasTag (probably in stats)
Can be replaced with call to computeIfAbsent.
Isn't obs.getObsId() already tested on the previous line?
Please reformat: else if (result.getKeepPolicyPMEnabled()) {... }
I think this can be replaced with Stream.of(resolvedSymbol.get())
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I'd move this above the shader-related lines, as it is related to the FBO instead.
Shouldn't it be condition 'null'?
Is this if statement really needed? Because it's not used.
method returns null
This is not a closed stream.
FakeVertxSession and DummyVertxVertxVertx messages should be updated to reflect the new expectations (return null if metrics are disabled)
I think it's a bit too verbose to use the listener for a second time, isn't it? Seems like it's a listener to get the cache for a sec, which is pretty non-blocking.
There are a few places in this class and the others. Can we use the constants instead?
I'm wondering, what do you think about: This will always be true since HAProxy is non-null. So, instead of returning here, you can just do.equals() on the return value.
simpler to say about "if (component.isPresent()) {"
I think we can just use stream here, no need for the variable.
I think we can use a dedicated stance around Executors.... utility methods can be made private static final as well.
Shall we move the newBucket variable out of the for loop?
ProductInfo is immutable, and we'll use it elsewhere
Call this function directly after Desktop.
would the CRN in the exception message be more descriptive?
Can we remove this block?
Is this exception caught in the catch block? If this is a test block, wouldn't it be better to have it fail and throw the assert?
@cagryInside Could you also please provide a more. It is proven to work its work, and it's not displayed correctly.
instead of the hard coded value "key" you could use an actual value for the key
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
prefer String.isEmpty() as it is used above.
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
Should we throw RuntimeException if encryption strategy can not be found?
Needs to be in a finally block to make sure that the server is correctly taken.
Why do we need to do this? Needs a catch block.
Could we use a standard import for the rest of the codebase?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
Java return new WidgetAdapter(ElementAdapter.class, CSSValue, element).setSelection(@Nullable int element, int value)
This is a bit misleading. What about "Returns failed".
rather than catching this, shouldn't we create a new connectionId in the constructor?
Are we sure this equals() will not return true if the server doesn't have the oldPost value? Maybe just remove the isPost field and just call it if the value is null.
I think this one is not needed... baseline is still null.
you're creating a new ArrayList for each element. Use the for loop instead.
PLz, do we want to keep the exchange plan before we merge the 2 maps?
The statement is incomplete, because CommandCoordinatorUtil.getCommandEntity(commandId) is really confusing. What about using the command entity entity to keep it?
[minor] ImmutableList.<Toolchest>of should also work and avoid the cast
Is this needed?
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
maybe worth adding a method getSourceMenuType() that returns the empty string.
I must be missing something here, but shouldn't it be composed in the loop?
can we not sleep for a random number?
Can we use either Arrays.asList or Collections.singletonList() instead, I don't think we'll need to consider performance here.
should we do it here too?
iteration over the list is enough
Shouldn't we throw an exception here?
Do we really want to always assume Latin-1?
Again, I don't think this should be necessary.
Can we have a separate config instead of de-duplicating the code?
Why are we no longer controlling the authorization of the next authentication realm? The fullname should get checked exceptions, but I'm not sure it's needed.
No need for this.
This is overly broad, we might have more then one place to do it. Is there a way to refactor it, so that the old client is not added to client configuration?
Consider extracting the response.getRequest().getPropertyValue() call, since we are now doing the same thing with different headers.
Extra parentheses
It is bad to have a modelField for the field. You can use the TYPE_TEXT constant here.
@v-stepanov I believe you can inline this variable
I would suggest to rename this to srsType to srsName or something along those lines. The URL is not clear what they are trying to do, I think.
please remove this line
Same here; recommend using {} or place holders if possible.
Please leave the try with resources to place the file needs to be closed.
I prefer to keep the static import.
Check the result of new ArcGISMap.
Isn't there a risk that we don't allow this? Maybe we should be using base state?
set to null don't go
"Reporting some" or "Source licenses with the missing data. Will be get rid of these lines (where the final word t) :)
Probably more explicit to use log.debug("Config SlowQuery < 0 || startWithTimeout.write( log.getStdout ) )
I would move this to a method of the base class, so we can use the standard Context type.
Do you need to return a Optional or a null?
If we create an entitlements map, does the list of bindings also contain a certificate on the EntitlementCertificate itself? This list is going to be reused every time the content is pulled.
I think this is a little bit too long and complex. It might be easier to read if you put the cursors of the whole thing into a method.
If we are going to have this logic in the init block, should we log it somewhere?
same here regarding a function
Why is this Runtime just typed?
Shall we move this to a private method? Do we need it?
Please use debug statements to make this much easier to read
- spell out colStatsList - null assignment is useless
We should have a condition for this (i.e.!Branch.hasLaunched()), which would guard against it.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
You can just create a createParallelGroup (and add it for the vertical group but with a createSequentialGroup. The undo call could have been removed by a createSequentialGroup but with the setText.
formatter
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
We could declare message in the try-with-resources, then move the null check inside and delete the finally block.
Pass the value of Discrepancy as a parameter.
Can we create a private method and use it in the class?
This method is used from from 9 to codePoints except for the length of an array. ByteStringBuilder is probably better.
getNodeInstanceContainer should be of type NodeInstanceContainer.
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
child modules should not change on each loop but the list of modules is the same.
Shouldn't this be source!= null && source.get()?
Should this also have a check for the oldFirstName_NAME_LEN.
check if volume is null and log and return.
Should we log out the exception if the file was deleted before deleting the file?
why is the default value?
This should be a try-catch-finally block: java WorkflowJob action = new WorkflowJob(jenkins); action.setOlderThan(new DataFolder(...)); action.save();
That should be IntervalQualifier
Unintentionally. In other hand, a.project should be made to a constant.
Can we just use instanceof?
please add logging in here to keep the message to the exception
in the static block I'd rather fix it (static)
It seems like we could have a null record for this.
This is in Travis CI. Please move it to a constant.
This is currently not the same code as in the method above.
Add a check here to verify that the serialDataReceived method was not called.
I think this message can be both an AxonConfigurationException...
Better to use the exception equals the host, so that it will be handled by the caller.
invert the condition to avoid having an extra variable
Format this to : {}
This message should include the namespace in the message
[Entity::v](<LINK_0> always returns a non-null Vector. I wonder if this if test can be dropped to simplify the code (and perhaps future proof it).
please remove alias setting (should be encapsulated in addManagedDevice
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
I think you should keep the try
{}
I wonder if the message should be localized as a constant (even though it is not a user error).
The timeoutMs can be set to 0
you're synchronized on your "this" object. Do you know that it would be thread-safe? I'm assuming that is also synchronized on the _this_ key.
nit: Could you please extract the Component component to a variable called assertFalse(list.get(0)); before the change?
@mderamos modify the assertion description appropriately
nit: maybe it's better to just throw ExceptionUtils.firstOrSuppressed(e, exception) here?
If the config object is initialized, aka ial effect should be initialized with the config object instead of calling RxSharedPreferences.
rename to child, fChildren, child
Can it be replaced with getType() == null?
Why not just write it out?
ReborObject.
No need for isEmpty() check since the previous code was more explicit.
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
using a listener could be used here instead of using a single field.
I think we should have a more robust message here, like getComponentClass() declares that it provides the Cause class.
maybe a way to support initiators
Why do we use Uninstall of the deviceProvider here? It will be more likely to happen.
Please put the "ms" in a constant.
No need for else, just return isSymlinkHasAttributes(path, attrs, partialName);
"unifyWindingOrder"
Maybe we could use panelName.isEmpty() here.
You should actually check if it is null and throw a NullPointerException.
Surely we will need to add the annotation or interface?
why lockKey is not set?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
For consistency with the rest of the codebase, we usually use the.filter( StopFilterFactory.class ) method instead of the end of the source.
What if there are many files in it?
Small style thing, but we usually don't use curly brackets around single line blocks
Might be better to use the.putExtra() here as well.
For consistency with the rest of the code, remove the throws Throwable.
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
It's better to introduce a new class method here, e.g.: public static class Builder { @Override public String xssIgnoreUris; public String xssIgnoreUriPatterns; public String xssIgnoreUriPatterns; public String xssIgnoreUriPatterns; public String xssIgnoreUriPatterns; }
same question here, do we account for the colo with single replica?
Why can't this be done in the constructor?
nit: can simply use equals here.
I think you may want to go into the map once you're registered.
You can create a local variable f with the same name as the return value (e.g. missing/extra parenthesis).
Hm, we can keep the old version as a constant and store it as a static final constant (i.e. DEFAULT_VERSION_COLUMNS)
If this code executes on a "Translateable" screen, then it will result in good.
You can run this on the project xml level (BTW, I personally prefer 4 spaces for tabs, but this project is standardized on 2 spaces for tabs).
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
not necessary to add "due to"
The mergeSequences method is never used.
We can use Objects.requireNonNull() here.
in order to explain why do we need to print the arguments?
These listProds already have the string representation of the iface. Can we just move it out of the loop?
i18n
Could use a mocked Model to avoid the need to create a new object.
Might be worth checking the result of the operation so we get the full URI, rather than using a boolean flag.
Should we define a default value to be the HIGH_NONE field?
Would be nice to put the logger.error here in order to get the actual issue?
I don't think this is a good idea, but are the agencyKFSConstants being a valid agencyKFSConstants. A better default agencyKFSConstants for this?
This is a side-effect.
Why not use the url.isEmpty() and move the check to inside of the if block?
Again, I would prefer to have more descriptive error messages.
Is it possible to create a constant for this?
I would change this to: checkState(completed, "Empty lookup source for outer join already exist");
I don't think we can simply use.equals here, we don't need to be safe. What is the point of this stop method just to be able to be executed on the tests method?
i like the logic you added in the MavenProjectArtifactControllerImpl. Why don't you use it instead of the null?
This is not the image.
switch should be able to set the player's t if ent is null.
This will still keep the code refactoring which is original but should be moved to a separate method.
NPE on line 105.
Either make this an instance of nanos (to be whatever the last modification time) or use System.currentTimeMillis()
instead of hard coding the path, could we just use inline instead of creating a new line?
Does it really need to be throws Exception?
You don't need to do this Optional.
This part can be moved to a method.
I don't think we can check for a task running: - Does it still work? But it's rather than doing so. A server side cannot determine whether a user has a task or not.
It is store and then let the cmd.get() call the same way as the command, but not the encoding of the byte array.
Please use the assertEquals(expected, actual) method, so that the test fails the build doesn't succeed.
I don't think we should have this catch block here
Magic number - maybe a constant?
This needs to contain, return invoiceDetail.getSeqNo(getDate()).getSeqNo(), invoiceDetail.getClusterName());
HealthMap
Shouldn't this be debug level?
Can we keep this field?
why not check for null?
This test does not seem to be working. The case where two files could be encrypted, tmylyn.e. " quantity=" and "getQuantity" are null.
Could you extract this try-catch block to a method for this, just to be sure to resolve the error message?
I think this might be frustrating to update since you have to remember to increase the pass count here whenever you add a pass below. How about just putting the number of entries in the queue instead?
if you use empty list instead of null here it's not good practice which should be
how do we know (which of course) but how do we know (because they're always looking at the first element in the list)?
This NETWORK_IP_CHANGED message is not received. This may be confusing.
Can't we use IndexOfCapability here? It seems like this might be changed to include the squash in the commit message.
rename to editorTopIndex and editorTopIndex
why did you change to final here? should be outside of the scope of the patch.
can use CollectionUtils.isNotEmpty(paramValues.get(0))
please use VmDeviceUtils.VIDEO_of_monitors
I don't think we need a try-with-resources here.
I bet it should be in another pull request <LINK_0>
Actually this condition would always succeed when there is a transformation, because getLayout would return true when there is no entry. That is probably not what you intended.
Why are you using randoming deprecated now? Exceptions already generated in next methods. Should it be a private static final field?
I think we should log the exception here.
I think this can lead to NPE when called the same method with a common size - which is the default height. I would suggest: playQueueAdapter = getCurrentInt(); if(playbackSpeed!= null) { playQueueAdapter.dispose(); }
Please remove this.
Why leave the capacityMap read logic outside of the validate()? Note this will diverge the behavior of the check API and real rebalancer API.
Do we want to log requests for every request?
I think it's better to perform the conversion in the linkType itself instead of here.
We should have a banner implementation.
Is this a bug fix? If not, can you please try to use.trim() on the next line?
Use Double.MAX_VALUE instead of Float.MIN_VALUE.
should be this.user = false;
Can you move this line into the getClientParameters method?
Is there any reason to use the same listener twice?
Extract the payload to a variable for better readability
can be put "getProviders" and not "getImplemented"
I guess you don't need this check. If group is not empty you will get NPE.
"service" is handled as a utility. Wouldn't it make sense to use it in TableMetaUtils.writeMeta()?
you can probably replace this with a lambda + call to the method below.
I think this check is redundant; it is already taken care of by the PollStream class.
Hardcode not always true.
I think it would be better if you could use Collections.emptyList() here instead of Collections.EMPTY_LIST because this change is not really cached in this context.
If this method gets called with a block that is smaller than the packet header size (28), we could get an exception. We should be throwing an exception.
object -> function?
uee is already included in the file, so this is probably wrong. Same as other resources.
This is not correct, as you need to assert before computed version. I'd prefer not to expect methods to have their version in the first place.
@manstis could you add a @EditorHandler interface and has the package name as static? I know that this is not part of the interface, but, I'm not sure we need to move these code to the interface.
eventBus.get() is always called anyway. If I think the eventBus check is useless, the eventBus check is always executed and it will never get invoked.
s/joinAddresses/size/
Not sure where this would work, but I think that authorities.stream() is the only _Collections.emptyList_.
CompressionCodecName compressionCodec is not used?
Should use Alate.
we should do a cast here and cast on <? extends IResource>
I think it's better to do this in one line
Please return NPE
When we merge operation, it's more readable to have a localOutput variable.
Here is another one.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
Should the following catch block be removed? because it is shared with the same try... catch block there.
grpId = grpId.stream().map(this::getEncryptionState).filter(Objects::nonNull).collect(Collectors.joining(Rs.Collectors.toList()));
With the requireNonNull, the null check would be redundant... I think...
@dmzaytsev Now that I understand this change, I think we're making pose a major problem. Let's define these own test cases, as we can see about what is actually testing.
I think we can assert the the result of the expected call instead.
I would prefer if we would use findByName method.
'this.time' should be visit.after(time.getStopDatetime().before(time))
![MINOR](<LINK_1> 'Severity: MINOR') Make a constant of " defined". [![rule](<LINK_0>](<LINK_2>
I'm not sure why we need this test here. If we have some specific advices on our recent CR/LF/s not all, then I think we should use a _Integer_ (no >>)_ or _when_.
you can mutialize this code
I would use LeadingMargin for '@' character.
If we want to use Id rather than Id.redisStreamMessageProducer.set().
This line should be moved to line 501. After: File entry = fromClient(projectInstanceResource, i);
No reason to trim it, but is it possible to trim it?
doc
i'd prefer to write it as: BackendVmsResource.getVmPreview(Snapshot snapshot, String vm) { return vm.getVm().getstatus() == null? new IdQueryParameters(asGuid(org.ovirt.engine.core.common.businessentities.Disk.class), () -> Backend.businessentities.Disk.NOT_FOUND.businessentities.entity.getVmPreview(xx.class,...))); }
You don't need a variable here
I'd suggest here to rename priority to priorityOther, to make it more clear. The user can choose the priority while generating the priority.
The "Assert.assertTrue(condition)" should be before the for-loop body.
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
Instead of modifying this method, what if we change the class name to be static?
Could we use request.getElements() here?
Minor: use of constants :)
We should be able to directly call ServiceRegistry.getServiceRegistry(true)
why did we use cast here? can we change it to -1L?
this should be closed as well
Can we change this to getMetaData().size()!= 0?
Isn't it enough to mark the RealmChangeListener interface with @ChannelHandlerContext rather than delegating to this?
style nit: add a space after if
This variable is not needed here.
useless
why not instanceof?
should we also allowing to do this in the constructor, in cases when a PII information is provided?
any reason not to use equals here?
check against errors too
Should we put this in the try/catch block?
exists() is never called,
what if "logUtil.w(address)" is used?
Would a regex be better? // Needs to be a constant if the folder name is a folder.
Given the cost of mapSize and map size, I think a better option would be to use mapSize instead of map size.
I don't think this will work if the view is in the UI, doesn't handle the case where its set is not shown, if a user calls setEnabledEmptyPane() which also includes a second condition. So either both should be true or false, on the same side (e.g. to setEnabled(true) and only set its value in the view, if a user has left permissions to the change and doesn't call setEnabledEmptyPane() at all, or false to set the checkbox the leftSide value.
Nitpick: move this assignment to the previous line since it's not needed
assertThat(secondBuild.isInProgress())
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
Why is it better to use more than one scope to test?
Shouldn't it be in the last line?
We can throw the exception to the client. We can throw the RestAPIException for an own exception.
are we guaranteed the correct values to be null?
We shouldn't reformat this. Just return true when we know it's a single item.
1 -> numInputChannels?
Integer.parseInt
Missing final
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
I'm not sure what the code is doing here. What if one or more query is provided, and the other is always in the request?
we already have a list of supported VirtioScsiEnabled from this.xml (the condition is true only if isVirtioScsiEnabled)
I'd prefer to use Arrays.parallelPrefix()
The logic of using getContent is not part of the DML. We need to also use the base class of the interface for this.
For exception(String d) {
suggestion assertTrue(listener.hasBeenFiredEvents());
java try (FileOutputStream fos = new File(zipFile.getRecommendedDirectory(), length); ipEntry l = new ipEntry(relativePath.replace(length); ipEntry(file); ipEntry(new ipEntry(file.getAbsolutePath())) {
why not add if (tokenItem == null) { return false; }?
This needs to be upper case.
Need to provide more debug information about this message.
Better to close this dialog in finally block
I would have moved this code to the new method and call it from setFirstDigitsCardDetails.getAddress().isPresent() instead of calling getCardDetails.get().isPresent() three times for a new set
final
assertThat(entries).hasSize(2); the same for several occurances below
This can be done without StringBuffer
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
Why the new line?
replace with persistCommandIfNeeded
please don't modify this code, here we are trying to duplicate the same logic.
This should contain the following line, because it's too long. java ParcelUtils.IS_US_ASCII;
If this is a catch we need to log the exception. Otherwise, it's a warning.
This can be converted into a List: int remaining = 0; for (int i = 0; i < page.getInstant(i)) { if (remaining == null) { return; } } }
Add a new utility function to addBlockEncodingFactory, and change the default constructor of DefaultBlockEncodingFactory to addBlockEncodingFactory.
nit: missing "TLS"
We have has removed.size() == 0.
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
resolvePrevious date stuff will only work for year-day. I'd recommend to have a test case where check some year-day/leap-day, and just bump them to grace period.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
Also note that input channels have been empty.
@dskalenko please reformat this line.
Can you correct the exception message?
I think it would be cleaner to make computeIfAbsent and add a TODO here.
These two lines should come before the if. (Remove in the other branch.)
Minor nitpick: return HtmlProcessor.getDatatype().equals(millisProcessor.getDatatype().equals(val)).toRawValue(fieldtype);
and we should probably store the value as a constant since we are sure that the key is correct
I don't think, the following is correct: final long a = solverStatus!= null; final boolean 157 = problemFinder.apply(problemId); if (solverStatus!= null) { CfgService.apply(problemId); } }
should this be done in getIndexUpdater() since that is the only place that calls firehose instead of log.info?
Please do the same for the other variables.
nit: put the lines after the second line
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
Magic number
I would add the following to the methods: MetricRegistry.name(name, name) ); public void onTimerAdded(String name, String childName, Object name) { remove(name); register(name); } @Override public void onTimerAdded(String name, String childName) { register(name, name); }
ms
Just want to make sure: do you really want to use stringbuilder for anything?
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
You prefer having a if / else if instead of a or in the first if?
I know I am in favour of isEmpty() but not instanceof is less efficient, but a if (_cluster == null || that._host == that._pod || that._pod.getId()!= that._pod ) { return true; }
nit: what if there are multiple concurrent calls to this method and the field names, and some other potential, but not others? I see the difference the behavior at the beginning.
Consider using a distance here.
Why not use our own util library here?
Could you refactor the catch block in a separate method? Also, are we doing in / 1000ms?
should this be warn?
This should be the GatewayUtils.isPluginFor26x() method.
Cached.Size can be reduced to debug level.
@bxf12315 the same as above, please use assertThat from the AssertJ library.
May be better to use org.apache.dubbo.config.ConfigSleeps.setConfig(...) here and from other tests.
I guess.append("ipv4") is more readable.
It is correct to have a fast path here instead of this.
Is this file always valid? I tried running a mvn package without /a/b/cFilename was invalid. It was /a/b/cFilename was loaded by /a/b/cFilenameUtils.java in Java, not a java file.
Why are you using a different result for each block?
We need to support that on streams here too. The superclass also uses a nice interface for async deserialization.
Catch Exception instead of Exception? The general practice is to catch NullPointerException, usually we use a logger.warn("Exception", e) instead of ExceptionUtils.getString(...).
highlight this and extract maybe into a method that return bool
make this test shorter: getFileSystem().getJava()
@pynicolas Are you sure about this method name? As I know it does the opposite
please double check that marking the end of things are being done in the right place (seems97 for an example)
You should probably have a test that checks for null
Log the event here?
I'm not sure what is going on here. This method is called before the first try to scan the log-only mode and when it is executed the whole connection should be shown. I would suggest to instead change isFinished to check whether the first-block is executed and return false (and do the remote debugging).
s/active/ --inactive options are mutually exclusive.
this is not the same as the requestBody, you should be able to use the same JSON object.
why not indexStoreAdapter.clear()?
nit: this is redundant. I think you can reduce the log level to debug.
Let's move this line below, just before the requiresFBO line.
page returnVal = OpenShiftPort
I think this is a perf issue, but as you have a valueOf(Long.valueOf(SECURITY_ID_FIELD), why not just use the longValue()?
Formatting issues : [Use the matcher](<LINK_0>
Please add.id(...)
this is wrong - diskToUpdate.getDisk() will be null if we're not plugged to the disk
assertNotSame checks that the updates are in the same order as in the other tests?
Has this 3 any relation to the one in calculateNumberOfBlocksUsedForTemporal? If so, or perhaps even if not, then introducing constants is a good idea and really aids readers of this code.
Shouldn't this be in a finally block? The caller might get AttributesNode set and it would not be closed.
This whole test is very badly formatted.
also these *meter* the same as the other one.
Should be i18n
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
Please correct the indent here
again.
should be removed now?
Must return false on this case.
Can you elaborate on why we need this case? I guess it will be a bit hard to understand what's going on here.
same as above, this loop could be replaced by assertEquals(host1, scores, vms);
I don't think this is correct, as all other cases need to be replaced with the MY_PRIVACY
I wonder why did you remove this for loop and use the getCRFDAO instead of changing the list?
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
I would rather see a method called getResourceClassLoader(), which returns null and have that return the same method
I think this should be Splitter.on(",").trimResults()
What are the hints of values here?
It is not necessary to use try with resources.
Do we want to put message into KiePolicyHelper?
I don't think this optimization of repacing.equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
hmmm, I think we'd need to check the logArg and logging here to avoid one-timeregular publications too.
Doesn't this mean the constructor should be updated only in the factory?
why not put the size inside the try/finally block?
Maybe put this in the if block after the switch? It's just easier to read and less error prone.
How is it related to the broadcasts? If you have some kind of error they need to be logged, I'd probably add a new method on something like something that could be called on the BroadcastService.run() and something like it could be a more useful error-level or something like that.
@empyerimerturk this this block is not needed, is it?
@Serranya same here. See above.
Please fix the assertion for valid package name.
Shouldn't this be when the user have to read the prefs from?
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is easy to mistake for "hadoop" when someone is reading this code
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I think this should be a guarded by a check if the file already started in the queue, or both exist and is there (in the else case, may be some other reason to do this?
could this be a setUp method?
this is done once, can you avoid the else with return in the catch block?
I don't see a value in this method. Not sure how simple it is to add the future.
Why does this use a different boolean?
my little thing, why do you need the default for the 4s? What does it mean?
This needs to implement isComInitialized().
As it's the Looper thread, you should set the exception when rethrowing with the Looper.
This variable is never used.
This if and else clause seem useless.
Use foreach
Just an FYI, checking [first point](<LINK_0> makes sense. No need to convert everything to string and then into a String. It would be a little cleaner (i.e., "first", and "Source".)
Use string format?
How about a few simple tests for this condition?
logger.warn("Current floor: {}", property, currentFloorName);
This might be easier to read if you switch to the existing handle method.
This remove will not occur if the underlying Collection is a Set.
Let;s use: if ((pubKey == null) || (((String pubKey : null)) {... }
Can we change this to serverOption.SO_BACKLOG and have the 2 changes you suggested?
Might have accidentally lost a newline here?
These values should be constants.
assertThat(response.getFeature(...)).isInAnyOrder();
Can you extract this to a method? There is code duplication here.
baseId +diagram
Let's use the same approach as for update. What do you think?
Not sure if instantiating the attachmentList is a good idea.
GitHubSCMSource<?> kind = allArrayList.select(all, Messages.class), NamedArrayList.withAnnotation(Selection.class)
just use a try-with-resources idiom
Why not set the estimatedRecordCountForAlignmentGroupSize to be greater than MINIMUM_RECORD_COUNT_FOR_CHECK_COUNT?
Why are these changes required?
Could be static
I think we can use Shall we call Shall we move character '|' to a constant?
I think it's possible to do that more elegant by streaming one list and using iterator of another list in that stream.
Log the exception here.
Since you're testing, does this assertion make any sense? I guess it does not matter for tests.
Can you please fix this so you can not use id in the message instead of getGroup()
don't you want to add a/b?
Please put this tout on the same line as the LOG.error statement.
double check that the group is still here
Use localization parameters
renameChange instead of importChange?
did you want to remove this throws IOException as well?
Can you rename this to be more specific?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Worth wrapping this in a ScheduledExecutorService?
Changing this to sth like LOGGER.error("Error filtering the grammar on index < HIGH>", fileName); seems to be a better fit for this condition
nit: drop the.
OK, I think these two lines could be merged into one. That's probably the simplest solution to do is to wrap/all the if-else block - if you think it's clearer.
Here it is going to depend on the resilience strategy... so hard to say. I would drop the operation result assertion though.
nit: a more reasonable way to test the mutated. but I'm not sure if the difference is that the mutated is not the original
The same like in the other methods. Please remove them.
super.execute()
v == null means array.size() == 0
Do you need to break line 91?
Needs to be removed now.
looks like is this lambda's logic to determine if a more stream is included?
New, we use File.createTempFile
If it doesn't exist then we would have a check for it (AscendingLongIterator iterator = iterators[0].getIndex(); long currentMax = iterator[0].getIndex(); while (currentMax == 0) { index = iterator[0].advance(); } }
I would "Could not create the marker"
@mykelalvis please, rename to server. s is meaningless :)
Here we have to find a better name than join. But you can use Pair.of
This is duplicated logic. I think the constructor should be extracted to a utility function
same reserveFile for  size
This is only valid for GameMap, unless speakerName is true, will this skip?
I would test the following: - value is an instance of the referenceChange. - display the reference on the actual value (for example a trigger it has been added) - display is to the trigger "getMatch" - display is 'null' and get the reference change is done
this can be rewritten as: public static void addJoinField(JoinType property) { String parent = joinTypeRelation[1]; if (children.length > 1) { builder.startObject(parent, children[: Queue.class); builder.endObject(parent, children); } } and the same in the 'else' clause.
We should be consistent with the check above
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
I think we should not touch this much - the scheduler is a door to have a find issue.
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
I believe this if-else should be removed. DownloadBatchMap will create a new DownloadBatch if you set NO_OP
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
getOnlyElement again, no need for a loop.
Please move the logic to Optional.ofNullable()
If someone calls offsetMark == 0 then this will fail, and returning 0 otherwise. I think you need some logic to detect the offsetMark == 0
we still need this snapping logic if the property is not divisible by the step size
same thing here. remove(taskId) does not allow you to get one task, loop over and over.
You need to call Companion in the string
Should you define out the Const.java.util.ListAllowedProperties in this class, so that it will be more readable?
What about Arrays.asList()?
I think we can avoid parsing the ID for each entry, or just use the size. <LINK_0>
I think this is the new logic right? Also, it might be a bug if remoteHost == null.
You can just call oldBehaviour.apply here, is this intentional?
This is probably better than the logLogManager fallback. Check the IProgressMonitor is not a reliable check for [eventLogManager](<LINK_0>
Please separate into two lines. One for getLineIndex() method and one for "Y".
Should we really have a constant for the _!=_?
I think we should try to use the samerestartServer() method.
getBigtableScanValueProvider() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider. Might be a good idea to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider.
Can we add a debug message here, like "Thread [c] should be removed from the string".
suggestion if (publicId instanceof AddRequestId) {
content -> url
The  here is notipaddress with the bridge.
I don't think this variable is needed.
Unnecessary empty line
Typo in log message
if you are going to add them, please add them to the one.
blank line
This should be a boolean, it will default to a blank string. Also, please make sure you are using the same password as the user name.
Pattern.replace(]*, character.toString())
"due to".
Same here, better if we return false and throw an exception.
do we need to have a LOG.info for this?
![MINOR](<LINK_1> Make "get" a "static" method. [![rule](<LINK_2>](<LINK_0>
you're setting timeout = 1 second here in the synchronized block. If the 'wait' throws an exception, it will be returned from BaseCommandCompletionCommand.log(Level.error("Waiting for timeout of BaseCommand"), so it would be clearer.
there is already a method, that you can use to determine offset and limit if cursor is not already set, which would be nice to avoid that, a method which is already implemented at line 51.
getPathsToExecuteBashScriptsToExecuteBashScripts(getLogDirPath(), path)? dirName : Paths.get(getLogDirPath).toString(), dirName);
Remove this line
Minor: we don't need this else.
The message could be extracted into a method, will be much better.
equals for comparison
We should be able to take out the index of the list and then increment it on the next of the list.
This statement should be removed; use callback.
Is this needed? It's already overwritten in the next line
Please use {} for this if statement
We could optimize like this by calling BasicAuthCache authCache = new BasicScheme(); HttpContext(uri.getHost(), uri.getPort()); here.
Ah yeah it is a set of KeySet and stores it in the same class. I am wondering if we should rather use a set of KeySet instead of a set here.
Is this fixed to 20 seconds deliberately? Why not use the default from the testOut to verify that the configuration is not generated?
I would avoid a pod lookup, if the label does not exist. I would suggest to use a different URL for the given label.
Unneeded parenthesis
Does this need to be a user-friendly attribute? The [A-B] header should make sense for this to be [region-b](<LINK_0>, and the that it is [myTenantName](<LINK_1>
One more times(1).
You can use assertNull("Should have barfed") instead of CACHE_NAME
It's not the case that preTask is null, but it has a null pointer. I don't see how this can be null.
This retry-after-ms should be wrapped in a try-finally so that it gets closed in the finally block.
Can you use a more relevant variable name?
please put the code in its own method.
s/hasIndexes/ could this not be here?
lets remove this and use a lower case to match the rest of the account
I guess we could not just add this line here..
Shouldn't we be creating a new instance of LatencyCollectionResourceDTO for each call?
Use slf4j formatting syntax instead of string concatenation.
this is a new validate method. It will be reused by the validate method below.
We should probably log what is the exception we're trying to get.
Please add the "newTaskAttempt" check here.
ProcessBuilder.KEY.endsWith("heron-shell-pack-utils-shell") can be used instead of the full String comparison. The test is a bit hard to read in order to understand and the change in the test is a bit more robust.
- Shall we wrap the "debug" code in a "finally" block, to avoid the need to put the session id in the log?
I think we could avoid forEach on the messageBody itself, and add a note to the park (but before this line)
I think there is a better way to do this. As for the other tests, the PageStripButton should be closed, it will return a 404 (as well as not a blocker)
The original exception for the renaming is redundant.
Looks like we want to keep the old method.
can you create a test for this?
The moved above cGroupsMemory should be moved to a separate method.
so the link does not exist? should it not be hiding that entity.
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
Is this still needed if the value gets overwritten in the next line?
Would it make sense to move the history class member of this class that was created during init() and re-create()?
Boolean on a literal please
nit: I'd probably put all the other UUIDs in the assertion (which we don't care what the migration is being done).
This code will only get called once at startup as far as I can see, can the game thread will no longer be loaded until all other things are loaded?
nit: line 59-62
This method is used only once, I think this is better: private static List<String> DiagramCategoryRegistry;
This log is a little strange here. Should it be a session or something similar to -C <LINK_0>
I'm going to trust this is doing the right thing (I understand this code is basically just copied and pasted from Apple's examples)
We should use Integer.MAX_VALUE as the size of the array. Using Integer.MAX_VALUE is a bit faster.
Suggestion: extract to variable and use for possible parameters
It's possible to move the variable declaration to the start of the method, so there is only one return statement in the if clause. This is more readable, and you don't have to check for a positive condition here,.
Why not just use an iterator?
suggestion /** * The file exists when installing a path The ip server */ public static ip(SourceResponse upstreamResponse) throws CatalogTransformerException { try (FileOutputStream fileBackedOutputStream = new ipOutputStream(fileBackedOutputStream)) { resourceMap.putAll(getAllMetacard); } catch (IOException | InterruptedException e) { LOGGER.debug( "Error occurred when initializing/closing ip {}", ipOutputStream.parse(zipOutputStream.class)); } } catch (IOException e) { LOGGER.debug("Error occurred when initializing/closing ip", e); } } }
Nit: Should be resCat.equals(resCat.getCode(), "...")?
I'd put it into the same commit as above: if (limit!= null) { return context.rewrite(Sort.class, rewrittenSource); } else { return node.isPartial()?
@maria-farooq we should provide a description to the log message
Single pass is needed here.
suggestion if ((host == null) || ns.getInt("name")) {
I would prefer the format to use id next to the entity type, like log.info("{} removed attribute {} from {}",...
There is a [File.deleteOnExit()](<LINK_0> method instead.
If you ever make this public this _ will break the JavaBeans specification.
Unnecessary parentheses, the error message should just be character-to-be-declared
Not sure about this, I am not sure about that. The configuration setting and configuration files should be the same. For the same reason I see the start of the stop. However, I don't think we need to modify the getSite property, just add the default to the ViewModel.
Please use a more meaningful variable name. Like allowedOrigins or something
I think a map is needed here, since we do not need the map
If we want to move this to KubernetesClient.java, we could still expose it to KubernetesClient. If the auth is not SslAuthEnabled at all, not just use this as getKubeConfig().
What about using a static var for the seek method?
Style nit: please always use {} with if statements: if (with always { }
getMessage() is an internal type, so do not set the name
This static helper class is repeated in many places. This should be extracted to a helper class.
I think get was more approriate here
In some cases, sleepThread calls should be sleepThreaded. Maybe. 10ms and sleeps?
Can you just: java try (File tree = new JsonParser()) {
this could be shortened to java return new DirectDebitConnectorCreatePaymentRequest(directDebitConnectorCreatePaymentRequest).withMissingLink(directDebitConnectorCreatePaymentRequest).withDescription(directDebitConnectorCreatePaymentRequest.getPaymentProvider())).withDescription(directDebitConnectorCreatePaymentRequest.getPaymentProvider().getPaymentProvider()))
Why.toString() and not just sendTrace?
This whole method could be replaced with return value!= null && lhsVals.length < lhsVal.length;
This could be replaced with something like: java String dataString = Helper.quote(dataString); dataString.substring(0, dataString.length() - 1);
final is unnecessary here
Could you please add clear message for case when assert failed?
That's just space
We should move this to a synchronized block in TransactionalLock
Won't this break if stage stage already has been deleted and stage is also available to the stage?
You need to also update the end time here?
![MINOR](<LINK_2> 'Severity: MINOR') Do not forget to remove this use of "totalCost" local variable. [![rule](<LINK_1>](<LINK_0>
The new method ParameterContext.register can be removed, otherwise it will get called twice for the same parameter value.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
Stream
why not initialize it in constructor?
just use context as synch obj
can we use the common name for this?
nit: break up this line.
suggestion.inflate(rect -> listener.getMethod());
Maybe encapsulate this in a method?
I think you should use a finally block that throws an exception, to ensure that the thread is closed even when an exception occurs
Again, the relay on the configured value - is this intentional?
I don't think that it's best to keep this method simple. I think I'd prefer to keep it as is if tradeInfoPropertyName is null.
Spacing.
Here I would prefer to use a different method such as BioCodec which is less similar to what you have here.
Why is this constructor using DB_TIME_FORMAT?
We should use a static import for the exception message as well.
is this is defined for the Holder's Info.
LOG.warn("Terminating in Redis RECONNECT_TIME", ex);
Need to exit the function here if the table was null.
Can you make this a private method?
I think it's better to close the input stream in a finally block.
Why a comma?
Tests also need to be context-aware unfortunately, otherwise they end up testing against globally defined sites.
Can the Name be moved to the inner block here?
Same as above.
Use lambda syntax
If it's not my idea to open a browser again, it's a bug that fixes it. :(
If the GeneratedClass is already wrapped in a try/catch, this should be taken into account the listener.
Could just be LOGGER.error(jParser.nextTokenLevel).
Use context.getResources() instead of context.getResources().getColor(R.color.edx_brand_gray_base);
please remove the variable.
Can we throw a more specific exception here, like Exception in the method below? This way it will be handled by the caller.
I'd rather not catch this, but I think the proper message would be: "Invalid auth config from EC2 instance " + credentials, e.getMessage(), e);
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded?
Can we move this line to a method?
This code is duplicated in deleteOnExit() above, so that it can be well implemented.
Worth checking that the string is a valid JSON string, but that's not a valid JSON string.
maybe lets use a _seq_no, or _seq_no, see the other 2 assertions?
Wouldn't it be good to have timeToLiveInSeconds.getcreationTime return the actual value of serviceId + timeToLiveInSeconds? Or you could move the serviceId assignment to timeToLiveInSeconds. Otherwise, the constructor is easier to read and understand.
I don't understand the cache manager, but you can use the default registration flag.
I am not sure the CASCADE should be used here but with only a PITAbleed value in the repo. Maybe we can use CASCADE?
Prefer'return', i.e., only the last param.
As long as we switch to using Java 8 you can move to a long.
add final
should be in camel case?
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
I'm pretty sure we're including other versions of BlogTable. Can you move this code into the else statement?
I think that this works as if you extract a method to addBulkWriteError, which accepts TransactionUpdateException and you can call docUpdate.setBulkWriteError. This should be improved to this: - create an error in the filters and add warnings, persist the existing error log as one. The error could be misleading.
same as before, use var names instead of var
This check should be done by sSelaction?
No need for a string rename. The error message is the same as the one below.
Why don't we just pass the name of the tree?
Nit: This should be perform-return ORIGINAL.getPdfPdfPdfJavascriptBridge()
Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with.
when would this be null?
Use try-with-resource.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
@Requian mentioned above
This can be done in the constructor. java List<String> allUrls = Arrays.stream(eurekaServiceUrl.split("eurekaServiceUrl", serviceUrls.get(eurekaServiceUrl)).filter(serviceUrls::getEurekaServerUrls).map(eurekaServiceUrls::getEurekaServerUrls).collect(Collectors.toList());
Please, use NodeUtils.valueOf(item)
Should we do an eic?
Could you please use the hamcrest matcher, as it allows the output more easily (and for the failure message)
it looks like you've copied the methods in the Class<? extends Thing> for this new task
on the catch, let's add a servere logger
I think we should prefer a setter here rather than member variable access.
I think this should go after the loop and have a break. The "if" branch does not go outside the loop.
If I understand correctly, this will always return true (ie. because new ArrayList<> will do nothing) - so, it's better to do "int[] item = new int[nextQuery] = (flags [...]"
I wasn't sure where this is coming from, but can be larger than the other is this change added.
nit: simplifying it to java logger.warning("Ignoring received members from all suspected members!", sender.getMastership().equals(new MemberInfo(MemberImpl.N])) : "
Shouldn't need to use mockito to verify the behavior change in the unit tests. Since mock is a no-op, you can use the mock instead.
A specific exception is not thrown, so you can just catch the specific exception
maxKeywordsSize can be null
Now you have the stuff on the executor above, I'd suggest <LINK_0>
Would be nice to use AssertJ for assertions.
Perhaps also desirable to call track(Node, Context) directly. (For BindingStep, just inject a Node; for WorkflowBuildWrapper, use the autobinder method.)
Should this comply with our formatter?
It might be worth the error message to mention that "Expected the provided portion of the format" is a special case.
This is not really a JsonReader. You can take a class that you can actually use. Not sure what you want.
It would be better to use Boolean.valueOf(vmDevice.getSpecParams())
Sad times, but I don't think we can easily work around this.
Why does this need to be done in the constructor? If yes, the panel should handle it.
null is redundant.
Nit: this is duplicated at line 48, I would get rid of this line.
I think you can write mapBlockBuilder::resetBlockBuilder into the try block. And also in the other places.
Is it possible to move this to a separate method?
Not sure whether the all of these /Chicago really matters, but that's a major city in ticago.
Can be simplified to if (log.isDebugEnabled())
@marchof I would use a different @Rule for those methods.
This code could be simplified to: java return Objects.equals(planName, that.planName) && Objects.equals(this.catalogName, that.phaseName);
Maybe we should use the following when we have: java Set<Long> tag = session.createQuery(new Guid(id), (SessionData) -> { entityManager.merge(session, sessionData_id, poolData_id)); session.commit(); }
These 'all' blocks can be combined with the one above
Maybe this is a little cleaner as a switch statement? java return ""; } else if (i == 0) { return ""; }
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownNodeUrl' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
typo _start_ -> _stop_
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceInformationGetNameMethod - resourceInformationGetNameMethod
@szczepiq Would you mind setting the value of sOnPreferenceChangeListener's?
3 seconds... I'm guessing this is fine with the current code, but wouldn't be better to have a constant for the 'root'
well, the probability is very low, I know, but shouldn't be >=? in terms of readability I would prefer to have if (fetchTime - vmManager.getVmDataChangedTime > 0){... } else {.. } - but that's subjective I guess, so for your consideration
So you have default settingsfor userId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
The check item.getUrl()!= null is not needed.
I believe this logic is duplicated below. In the create case you can extract it to a method to reduce duplication.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Why do we need AtomicInteger if you already have this method?
If you are setting the position to this Integer then the value will be confusing. Any reason you can't use a trick "while" here?
This should be done before the check. And not here.
this method may return null, so the case can be simplified to Optional.ofNullable(name)
This is the job of receiverTree.remove() which is called for ignored type. It would be great if you could extract receiverTree.getTree() to a local variable and use only call isMethod.
Not sure, but we want to distinguish between the two classes: IPackageCoverage = new FileFilter(entity); if (modelLevel!= null) { return; } provided = (IClassCoverage a) go;
Do we need to check for duplicates here?
Suggest you use a Vector here?
if (mDebugMode == null) { logger.debug("View class '{}' with class name {}", name, result); } else { logger.debug("View: {} with name: {}", name, result); }
This should be removed
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
Maybe have a single setter for parseType that takes a hasChildren and has an extension point?
Maybe we can replace this with: java Objects.requireNonNull(values, "values is null");
both here and in the same method, you could have one assertion statement.
What would the previous code have returned?
I don't think System.out is necessary here.
I think this is a little bit too strong to understand, but why can't we use java this.request.TruncatedScriptHash(WORKER_STOP, STARTED), key(NULL, STARTED), key); Paths.get(String.class, STARTED), key.get(exchange));
Why is this method public?
May not work well if canvas changes are not preferred.
os.arch should probably return null. App may not be set.
Why is this if in getName()?
Replace timeouts by IOW and the ones that are needed by IOW, but the ones that can be flaky. Or you can perform.get(0) and.put() directly.
code dup. would be better to move it to private saveInternal()
This test is a bit too much... I would not use a Method as a Variable and treat the same method as a explicit type. I think something like: private ExplodedNode currentNode(final OverlappingTree tree, final Method tree, final OverlappingdGraph::add) { return currentNode.get(symbol, currentNode.class); } And then remove the if statement.
The same problem with first test: add number of files as well.
Hmm. do we log tags? Probably a good idea but C Git doesn't.
Formatting?
Why are you doing this?
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem) value : null;
Shouldn't it be the opposite?
This logic seems a little weird to be in the same place as in buildText
a warning is only handled in putPhysicalId()? can we really ignore that?
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Redundant replicationSpec.
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
A amount amount is need to convert to Int. Double.
Should this be done in the else block?
@ALT, double[] is remain here.
I think! hashToInstances.isEmpty() can be used instead of the size.
keep variable order closer to where it used again.
Excuse me, it will always be equals to true due to NPE. The reason is that you can't use == for enums that most likely will cause == null to be used to compare the language
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
please use domain id instead of redefining the domain name
Do we need any tests for the changes in this plugin info builder and others?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
I am not sure about this. I think that keeping the UNKNOWN in the main class should not be null. Let's discuss that.
I don't think people will use this method to register a widget. This class has no listeners to do so.
I would go for a single return statement for the if statement rather than creating an intermediate stream.
The test for / prefix could be removed, or merged with a Path test below.
please remove.
This is a little bit too long. In this case, can you please wrap this with a new Integer?
debug/trace/remove?
And this one
This might be wrong, but the set of tables is always 0.
throw something if sqlCompatible
This cannot be removed. The scheduled task needs to be saved.
Because of this it looks like we are using the same configuration as the old configuration, but we could rename this configuration to be consistent with the other parameters.
This logging should be in the exception
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
computeIfAbsent would reduce the amount of code by re-use the method instead of matches.
Why do we need this?
The implementation will be modified.
this should be outside the loop? Otherwise it will only check for the first brick in the list
This assert is no longer necessary.
I would use the map data structure. Otherwise it is confusing and error prone to know which action you are using.
Please add a %s message or use proper %s.
That's an interesting trick!
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem in the new serializer paths that we need to address. Ideally the following line should work: ConflictOverrides overrides = ConflictOverrides.from(CONFLICT_OVERRIDES, ConflictOverrides.class) If so, the setter above should also change accordingly.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
This should probably be an error since it is fatal and that way it will be seen by apprunner
Can we have example format such as <LINK_0>
Why do we need the no-op: the parentRelationships.addListener(this);
I think a call to SQL subquery is more appropriate, like Batch? The query should be wrapped in a function to indicate that it doesn't need to be wrapped in a try/catch so we can include the feed hbase region server in it.
it looks like createMergeConflictInfo() always shows the warning, then adding the warning should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
This line can be moved inside the try-catch block to ensure we always close the element with the fallback buffer.
nit: you can use a method reference here. Something like shapeBounds.get()
do we need it in two places? The streamId is obtained from the Counter. I believe it's better to have it as a metric.
AJ, An encounter also has a time limit of 2 days set to close. Try to use [dateList.size()](<LINK_0> instead of 2 days.
Do we really need this loop? ComparisonConfiguration.getComparisonConfigurations() already sets the ref to null.
put {} around if/else/while/for etc.
Why do you use a separate mLockShutdown? I don't think its a good idea to do it after it has been called too much
Change getServerFactory() to use this?
why do you need to change the parameter?
I'd change it to: return "BIT NOT NULL DEFAULT".replaceAll( "?i", "BIT NOT NULL DEFAULT ) );
If we need to get rid of these dynamically, you could use org.apache.commons.lang.StringUtils.isEmpty/solr.getIntegrationTest(). If you are not using the default values for this test, then the master will need to be set to enabled.
Why?
You could leave the empty list here. This would save the null check on empty list.
This line is too long. Did you apply the formatting rules?
You should check if promotionBuilder is not null.
Instead of continuing, we can use an empty list here and avoid the else clause.
Why is this check removed?
Is there a test to validate that the input stream contains the expected stream id?
Can you define a private method to verify the collection collection is not empty and return it? I am not sure if it is helpful to define these methods in the service class.
shouldn't this be: if (nestedRelationshipEntity == null ||!isNestedRelationshipEntity.equals(Direction.INCOMING)) {
rename tochildElement
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
You can use the VmManager.isCreated() method. Check if you can get the Vm instances from the VmManager: <LINK_0>
Remove final as well?
I'd add a check for mPoint being null here.
Please use assertNotNull("line.separator")
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user)) &&!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) {.. }
Are we sure that we can't delete a batch here?
It would be better if we would show the user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessors(...))
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Same here; lowercase
I don't think you need to change this class and implementation. It is fine to leave this method unchanged, but I can be wrong.
What's the benefit of this? Datastream is configurable here (and a KafkaConsumerFactory per connector)
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond( Quaterniond);
static import graphvizPrinter (and all other pr)
This is not the right name. Please use the jclouds predicates2.retry construct.
Is it necessary to check the Function1 above?
Can you explain what problem this is solving? The jira does not tel much about leases.
Consider returning null instead of "null".
I guess the dialog will load the icon for the widget, is it? Why not just pass the view to the Panel constructor?
Please don't use String.format when using format
@idelcano The session is not closed anymore.
This check should be done in the listener interface to ensure that it's loaded when onViewCreated() is called.
@mykelalvis please, rename to server. s is meaningless :)
This implementation has to be in the interface.
I think you can omit this line and all the following ones from this method as they don't handle the same workspace for each workspace Id.
Why are you synchronizing on the interceptors to see the TM transaction before calling the interceptors? Maybe try to suspend the TM transaction before calling invokeAsync.
Same question for longs
SA_CLIENT_EMAIL_TOKEN param should be a constant in this class.
Can be replaced with for (Entry<String, Object> entry : vars.entrySet()) {
Should we create a default recovery file, and then let the job try to load it?
Can we make this an enum?
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. The _real_ provider uses a unique name so that the endpoint should be enough. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that is only called when creating the _any_ request. You should just wait for the API to trigger the API based on the endpoint and build the endpoint against that.
Lets use Guava's default value so this appears to be unused.
Might want to change this to a function call since you have a connection to the event.
This should be a check if it's not 0 or null.
Use entriesPositions.elements() with empty array instead of allocating new array multiple times.
This should be test in the listener
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the codePoint declaration without an initializer brought me up short.
null check
In all cases of this pattern, I would say throw an exception. Could we use a consistent method naming? Also, I think this would be better as two lines throughout the PR.
you could have the _last_ variable before the if/else
I wouldn't add the parens if it is not necessary for the very last statement.
I think that we should throw InternalErrorException, because that indicates an RuntimeException is not something about our role (and maybe error)
You can use Runnable as the type.
it should use integer parameter instead of true i think
This line has a typo in the name of the enclosing method.
You could avoid the exception here. This way you're leftovers from debugging.
This seems like it should be above a checkTableStatus, because the table is created in  table.
We cannot convert to boolean value, same reason
Just curious: why do you need this try-catch, and in the finally block?
@pecko @tsev This is a lot more readable if this ("if (lastFailure!= null) { return!Boolean.TRUE; } else if (lastFailure!= null) { return false; }
nit: more of the logic here (since we've been doing the same thing)
I wouldn't use the word "key" in this log message.
Use equals.
fieldValue should not be used here.
@rivera-zA-oow Can we move this condition to a separate method?
why this change?
let's return null from this method?
What happens if join result is a SQL request? It seems like it should be handled differently as a test failure that would help.
Findbugs reports this, as it is also incorrect. Please use a try-with-resources block instead.
You can use Guava's Strings.isNullOrEmpty() (this is a little shorter): java return input.append(prevState).append(timeline);
(not null)
Does this need to be a local variable?
Are we sure we want to leave this check in the default if the list is empty?
maybe it's better to use something like: "Can't load property \"..") + dialect.properties_PROPERTIES() + "\"...";
I'd like to see this produce a string with no whitespaces. I think you need to create a separator between the words and the delimiter.
This is valid I was trying to unify
there is no Exception thrown here
Write if (value == null) { continue; } instead
This is changing the behaviour of [Resource, methods](<LINK_0> which is bad. Maybe we should create a protected method FILTER_LIMIT_ROWS and put this number in a constants class?
initializeMod11ProxyAnnotation() doesn't need to be public, but it shouldn't be private.
why not use the logger for this?
Are we sure that we want to zero the yaw on initialization?
It would be good to figure out whether this is a race condition, when creating the bytes (by deleting a node), we could try to avoid duplicate the null check.
can you put the line before the loop and put the LARGE_OPS in a variable?
doesn't feel right be on the next line
You can use a variable for the column name
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
@Dyagioscalici this code is creating a Checker Framework object and not inside the Task. It should be kept in the code.
Nice! If you have a file with two partitions and one with the same name that comes from it, why do we need to initialize them in the two places? Maybe we should have a default and log statement?
Does not need to be public.
Shall we extract this to a constant, e.getMessage()?
looks like we don't need the resource URI here.
Can this be just one line?
Use already defined Constants
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
Can you replace this with a @NonNull? I think there's a typo in the implementation (e.g equals())
This can be removed? KinesisIndexTask is already using the connectionDetails.getCredentials() function
I'm not sure this is right. On the other hand, the assumption that the end is "class". What is that an NPE here?
Name is a horrible method name.
toString() not required, toString() will be always more than 'this'.
Probably it's more efficient to iterate over authToken. It's also more efficient to iterate over the credentials.
You need to pass the auth in the list as a parameter
Nice fix!
Can you please make this block contribute the the dynamic workspace to the dynamic workspace instead of simply'reg.getMethod()'?
Should this throw RuntimeException? What exception are you trying to do with BaseTokenStoreException?
This test only supports the first format of the file as some issue with the last parameter. Otherwise, we will not add "first" to the list of commands.
Why do we need to call EXTRA here?
I think this might lead to unnecessary calls to update the list while the first is processing this. Prefs.isReadingListSyncEnabled() is called when the list is non-empty, so might be my opinion to put this into a simple class.
Should read a cursor.close() call to see if an exception is thrown.
Use fail() instead.
acquisition of all the RHS does the same thing. I wonder if it would be better to have a guard on the start of the if.
Should this be moved back to constant?
Is it really necessary to put Assertions.merge(params1, "xyz") in the should be final?
Can you add @since 3.7 to use static factory methods?
I don't like that this is very much scope of a difference, but is it a mesgro to know its time for a second time?
use Guava's Iterables.getFirst() instead
Does this not need to be a warn level?
Perhaps move this logic into the if block?
is it OK not to put the segment location in LedgerSchema?
Can this be replaced with if (zkClient.removeWatches(client)) {
What if location is null? Might be an issue but I'm not sure it can be.
I would consider making the variable name more meaningful. Something like BlackboardAttribute param and return
Maybe better to return int.
remove
replace this with Logger.getLogger().debug( "Failed to login as anonymous user {}", e);
You can avoid code duplication by refactoring it into a new method reference. (it's not really the same code as your original code).
Shouldn't it be sqlInput?
Again, these should not pass validateInputs()
braces
The steps 36, 37, 38 are not necessary, please check this.... you should omit this steps
I think this will overflow if the span is an empty string.
which exception are you avoiding?
IgniteEx assertFalse(state.state(), assertFalse(state.state(), assertFalse(state.state(), INACTIVE.ACTIVE);
call this function : "NewApi"
instead of calling String.trim() multiple times here use map(), e.g. Files.lines(p).map(String::trim).forEach(...) You could also filter there too, e.g..map(...).filter(s ->!s.isEmpty()).forEach()
Is this really needed?
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Same here, should use the other way around: use the else here instead of the clause
Are we guaranteed that there will be a isEmpty method in AttributeImpl?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))).defendingUnit(givenUnit()).defendingUnit(givenUnitIsAir()).build();
is it possible for this line to be executed on an empty line?
Can you make these variables final and they can be used for both methods?
suggestion } else if (newName!= null &&!dotDavHelper.isEmpty(f))) {
This method can be private
Might want to use com.allian if we have a pre-production-up.collect.
Could be extracted in a helper method.
If the partition is not added, this line will throw an exception.
optional: can be merged
why userInfo.toUri() instead of the URI?
should it be eobjectArrayValue0 and testInteger?
Don't you think that set in a static field will be simpler?
Maybe a message could be helpful here.
We could use Thread.sleep(100) to make the test a little bit more clear.
Why not this.
if (log.isTrace() && seekEvent())
I think we should make this a constant, and put it in the getWidth()
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActive What does "status" actually represent in this parameter? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate?
use Map::computeIfAbsent instead
if (getApp()!= null) { requestGenerateBuildPlan(); } else { requestGenerateBuildPlan(); }
do we need this?
This would generate: "connector.gateway.example.dunit.live.worldpay.1234.AUTH_SUCCESS" ie. flipping the live and worldpay parts so that you've got all the live ones under one tree and all the test (and sandbox) ones under another tree. I think that's a more logical ordering as it then is a progression of "larger bucket" to "smaller bucket". Open to pushback on that if you or others disagree!
suggestion LOG.debug("The version did not change '{}'.", rawSize);
PagesIndex lazyCompactBlock.getRetainedSizeInBytes() < lazyCompactBlock.getPositionCount(), compactBlock.getRetainedSizeInBytes().map(types -> lazyCompactBlock.getRetainedSizeInBytes(), compactBlock.getPositionCount(), compactBlock.getRetainedSizeInBytes(), compactBlock.getRetainedSizeInBytes().orElse(null);
Consider changing this to: sqlTypes.values().put(PRECISION.getValue()); sqlTypes.put(PROPERTY_IN, null);
We should write a test for dropping connections.
If the error happen that early, can you map the error in early phase before mapping page result?
I am not a lover of the parameter... Let's add the parameter to the log.
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
if you turn.toUpperCase() and throw IllegalStateException, no risk to let user know about this
you don't need to do this. You can use reflection to enforce the fact that method is not called.
Extract method to descriptive variable name
This line can be more readable as well.
I don't think this is a need to be a list.
use SafeEncoder.encode(String, String, getParam(String.format("SafeEncoder", param))); as SafeEncoder.encode(SafeEncoder.class, getParam(String.class));
I think this resourceMap.getResource(URI.CONTENT_SCHEME) is a bit simpler.
Please don't remove this mechanism for changing the color.
space?
map initialization is redundant here, since igniteParameters.getPassword() is private.
formatting looks off here also.
Slightly confused by the message here. If "hToken" is not equal to HostToken then the pool should be equals. So in this case, i.e., "hashtag == null"
Why do we use iterators? I know the base class does, but why in the first place?
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
We could only check size == 1 here.
suggestion if (this.shadowanillaValues.add(this.shadowanillaValues.getLowestRidingEntity().add(this.shadowanillaValues.add(this.getVanillaValues()));
nit: (here and elsewhere)
I think that this should be a try-with-resources as well
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check Write, which is the ones you want in AbstractSession.
I feel like we can inline the entrySet.stream() into a single statement.
can we use!= null instead?
You can use assertTrue(file1.txt.is(file2.txt)) here
Not required.
Where do we have builtinMap methods for these?
Please use the count of 1 and 2 to be consistent with other messages in here. The timer is trying to start, with the name 1 and 2nd argument, so you can write something like: assertThat(onSuccess, never()).is(true);
I would include this as a constant value here.
Use logger?
4 spaces
is this really a "magic number" in a language like this?
"Gctop" is too general. "We want to know how to fix this kind of error". Perhaps the error message should tell the difference between "Gctopus merge" and "Gctop".
no need to add "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
Log level?
If the first attempt fails, this will log a 500 error, right? We should return a WARN when the fallback fails, saying that no further execution will be received.
You're missing some brackets here.
you can simply use Predicates.notNull()
does this mean that if you want to be able to add a selector that does this work as expected?
Why LinkedList? You can just use Map.computeIfAbsent.
This seems to be a dangerous method. It should be called once at the top of the method.
We could avoid cloning here? (The message is not modified by the view?)
Could we use TupleBatchBuffer.NO_ALIGNMENT_REFERENCE_NAME to make it clear what the left and right thing is?
The reason why the generic exception is here is so that we don't have to catch Exception. Just use e.getMessage() instead.
The last argument should be last.getAttributes().put(attribute.getAttributes(), attribute.getAttributes().get(attribute.getDeviceId(), attribute.getAttributes().put(attribute.getDeviceId(), attribute.getAttributes().get(0));
is this necessary if the next calls fail?
Could remove this generic error code? Also connectPort should already be a separate method, so we can at least move the implementation there.
Why should return directly.
I'd rename the variable to rowDetailField
For performance, I think we should assert that both values are not supported for the same things.
I'm not sure I like this idea but it would be a good idea to add a second deploy. blacklisted - in that case, an application should not know which one it is active and you could have a permission, in which case the project could be created and that would not be initialized. And if so, that method could return a boolean, that would avoid the problem at runtime.
nit: space around l
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in after testing?
Why are we shutting down the jedis connection?
I don't understand why you didn't use the variable name directly.
Combine the two lines with a else with the one above as it'll get a same error as the other error.
With the current code, you are calling getTag(), it will still throw an exception if the first image is not found.
Why not just pass the this.connection into the constructor?
This annotation is not required. I'd prefer to keep it as it was.
if you use else if?
Please update the style: true; while (true) {
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
wrap?
please change it to assertThat(v, is(empty())).to allow to create a string which is not same as v2.
I think you could still get rid of the iterator() and just do a remove() here, and the remove() method could be written as return getAuthentication().getAttributes().putAll(attrName);
I'd do it only if the profile exists, just if it is empty.
Do we need a retry here?
Please avoid using e.printStackTrace(). It would be good to log the exception.
1. Shouldn't we have the same condition as the group 2. in the map?
- spell out partitionName - Visitor - toString -> getPartitionStatistics
The difference between createOutputUpdateMetadata and updateMetadata should be removed from updateRule-specific tests. I'm not sure if we need to refactor this test.
You need to have a Preconditions.checkArgument() call here.
The indexNullAsValue can be null if the indexNullAsValue is not a valid field. Also the method is empty so "sortable" doesn't work on byteField.
why create a new array for it?
Redundant brackets; no need to put the { on the same line.
suggestion Throwable exception = new RuntimeException("fake exception 1").addSuppressed(exception));
Can this be simplified to java return "MCBlockState withProperty(blockState, propValue, propValue);
Let's make this shorter by also handling the FBO-related state change. This is probably a cleanup-time for the FBO-related state change.
Can you also log a message or similar?
Why the declaration and not int?
getLong?
Does toString() need to be called on MyriaJsonSerialization?
minor: you could move result_computedStatistics.getOrDefault(computedStatistics.get(NUMBER_OF_TRUE), and avoid the extra space in the row.
Missing nullcheck on AbstractPlanBuilder
Prefer using the pattern once, and save all the compiled pattern.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
Why do you need to null check here?
Extract private void assertion to ensure that the view and view are really needed?
suggestion throw new InvalidCastException("partNumber and partNumber", e);
Replace using Class.forName("minecraft").toLowerCase()
I think this is the only owner that will need to be sent.
I think this should be logged at debug level.
java //... }
assertThat( query ).assertThat( query )?
Minor: try-with-resources
This could be: if (input.size() > 0) {...
Should we filter for ClientTxAwareRequest inside a try-catch block?
log.error("Failed to prepare image {} on the SPM", getParameters().getStoragePoolId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImage
Is this correct? what happens if no token is provided?
Eeek, eatin away exceptions?
You could simplify this a little by using Optional<GlusterStatus>, then use forEach
use Arrays.asList(...) for short lists.
Why not just.next(new MkAnswer(container)
suggestion LOG.warn("The amount of the {} should be configured with a {}.", amount);
Add this logic into the certificatemanagerserviceImpl class.
please log in error
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
How about externalValues.hasher.hasher.hash(v.natural().min()).hasher.hash(v, stats.get());
Could use org.junit.Assert.assertj.core.IRule.execute() here. It will fail safe to test and verify that exceptions are thrown as well.
@hkalina The host parameter should always be 443 so this code needs to be 10 seconds. Otherwise this code looks like 'http', but port is 443 and it should be 80.
Missing final
Hmmmm... I just noticed this one Keyword call, and no need to addKeyword() here, because it's pretty much the same way you have below.
Set this only if session details not null??
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Context>, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
Probably should call storeDir.process() on each test in its own test.
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Shall we use this syntax for both getters? suggestion..(this.fieldLocation, fieldName, fieldDesc) && Objects.requireNonNull(fieldLocation, "desc is null");
This can be replaced with if (logger.isDebugEnabled()) { logger.debug("Valid signature found in SAML object:"+certificate.toString()); } else { throw new RuntimeException("The signature found in SAML object:"+certificate.toString()); }
Is it possible to define the parameter with 1 parameter of "in constructor"?
suggestion.stats().loadExceptionCount("loadExceptionRate", name)
You can remove the "!" and just swap the two clauses. You can keep the "!" and just return quickly with a throw
typo
You should probably use logger.
minor: you could move result_computedStatistics.getOrDefault(computedStatistics.get(NUMBER_OF_TRUE), (computedStatistics.get(NUMBER_OF_TRUE)?
create a log message for this
This should be split into two lines.
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
What do you think about the return value of _ready to _Salesforce_string instead of _ready_.
should be a method reference
Same nesting questions
Not sure about this fix. To me this previous indentation was correct
I think you can do a better and more readable way to read than log.log(Level.WARNING, "logEntry1 is more recent than the entry 5 are ms, not the first entry.
Maybe we should use a switch statement here?
Are you sure this is the url that is a class attribute?
I think we should have setType(ProjectConfigDto) method
Is this the same as the one below?
I guess you also want to close the stream after you close the stream, since you close it in finally clause
It is a little dangerous to use the builder to build a pools page, then the returned poolsPage will be the same as the first consumer. I'm not sure this is the best place to filter out a whole pool. Maybe here should be a method on PoolFilterBuilder
This test should actually check the saved interval is not zero.
Name it to externalize the string
Do we need to do anything with error handling for RuntimeException?
In order to prevent clients from being null, the client is null (no link to the default, which it should be null).
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
shouldn't this be an error?
Shouldn't this line be inside the for loop? If the is the case insensitive you could exceed the check and the loop: if (isFitnessFunction || altIM magicURL.equals(tempIndividual.getFitness)) {... }
This is where the if statement should be for checking the property for allowing for corrected times.
BTW you're missing braces in the previous lines.
encodings?
This is unnecessary.
nit: Should use _td_name + _column_name + _td_name + _sourceMaxSuffix to avoid unnecessary _all_s + _td_name + _column_
Here's an example of how it will be shown: The analysis didn't acted yet, the monitor should not change until we schedule the job.
Lets move this to a different method so that whoever uses this class will always create a class running groups and then know the outer thread groups list.
If you have the following expectations that user creates a Id attribute and ID stored in the DB, you will use EntityType#get
If the Title can be null here, we might just skip the Extra check.
weight += should be available as a static variable, see how getIntervalInterval() does it.
and this test is identical to the one above except for 1 line.
Let's use generics here and below...
Why is this needed? I think the entry and k1 must be in the same order as in the other classes, no?
can we use a regular for loop and use for loop for the builder here?
why send empty domain?
I think the when would be more reliable with the builder itself.
We can do this only if the user has been deleted. Let's change this to something like: if (!profileResource.getOther().equals(profileResource.getOtherClaims()) { userResource.clear(); }
Line exceeds limit.
I think we should set the time to localize() in this class, i.e. only when the trace is active.
Did you use our code formatter? <LINK_0>
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Again, here we are using java 8 streams.
move this below below try block, and put in a continue statement above instead.
please add new constructor
Filter into a DatadogItemListener#onEntity method
You can use org.apache.commons.lang3.Validate#isTrue(message.get(...))
We should use the handleResult.equals(result) method before returning the throwable.
Have you decided against a possible NPE here? If I set propertyString = "value".getSimulation().getFactMappingByIndex(selectedColumn) then you will get a NPE on line 96
I don't think it's interesting to see this. The metric is specific to statusFuture, so why are we doing it here?
If we're moving the branding to the page factory, shouldn't we make it part of the DAO?
part of the PR?
Log to lowercase?
"belonging" -> "which belong"
IMO getOne("pagination-id") is mutable
also assert the cause attributes
We could use: TimeUnit.MILLISECONDS.toMicros((K, V) keySerializer.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record.timestamp(), record
moduleRenderingInstance.get()
why causeOfDeath is empty?
It feels weird to have this check in the HTTP_HEADER_NAME string... I would change to that.
There is no need to assign this to a variable
I think this whole if block could be moved up a method, with a call to get() and before the call, so we don't have to set an path of the method.
since the second is important then the drop is not necessary anymore.
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
what if the acl is not found? we should skip metadata update in this case and return false?
Please consider making this more explicit (the check for lines YOU_ARE_OP)
Wouldn't this have two minutes?
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
It would be good to make this a constant.
rename contributorId
You can use a regex for the method to do this: <LINK_0>
Use anonymous class CallbackGroup implements onLoad()
This looks a bit strange to me
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
should be: model.isSetSsh() || model.getSsh().getPort()
please move this to the sHUB_target_schema method.
getBuildTimestamp
@jon6juna I think we should align this with the check below. The check will be good for us to have a null check somewhere in the cli service but it may be better to put it before the check
Needs to be removed.
use a constant
System.out.println("...... and path id (optional).......
Is this attempting to connect to any existing cached configuration?
I think it's worth comparing the whole stack with the same name, like you did in the other places in this class.
it would fit easily one line
Perhaps we should add a new logging statement to distinguish between these two cases: - a new proxy is created - the proxy is activated after passivation
How do you feel about your implementation of this method?
I would move this inside the if (sendTimeout) block.
This should be wrapped in a new method.
We should probably log this somewhere in this method.
Unneeded empty line here.
I think this is also possible. Are we sure that the generation is unique so this is not possible?
rename to 'Installed' or 'fatal'.
I think this field were in seconds, shouldn't it be here?
please use this instead: Cancel = ((XAResourceRecovery | flag) == AGEENDRSCAN)?
I know this is a code, but I guess it's not a good idea to throw an exception here. In any case, we have a code that starts the file without any path: file.getWorkbenchPart().getSite().getShell();.
For clarity it'd be nicer to have this method return boolean and store the view in a field
can we use lambda expression in registryAccountObservable.e.g. addEditor(String containerName)?
Could we instead have a static variable for the timestamp?
It seems like this filters were added to the right package. It's only used for this test.
I think this can be simplified to: java switch (metadata.getOperatorType().isPresent()) { case metadata.getOperatorType().isPresent(): return metadata.getOperatorType().isPresent(); case metadata.getOperatorType().isPresent(); return null; }
Not sure about this. It's the right way to hash a hasher. We better have all the hash codes be fast enough to justify hashes so they don't have to change how long the hash code is.
nit: can you assert that the response size is 1
On the setup, the communityId should be set to the new keys. I suggest we should use the values from the API.
You don't need it in every Exception since you have a finally clause that will get executed at the end.
Can you factor out ps.get(db, patchSet) into a variable? I think it would be better than to have it in 3 places now.
This should be spacing.
I think you can use assertFalse here instead of size comparison
Should we use isBlank() as well?
Is this really needed?
Will this cause a new config value? If not, it doesn't look like it's going to be used.
There is a singleton for OK Status: Status.OK_STATUS
If mReader is null, this will end up throwing an exception. The test should pass if mReader is null, and use the expected behavior instead of calling the other constructor.
Couldn't it be the same with Arrays.asList() as the the items are varargs?
Use Timber, not the name of the object.
The last question about maintaining type information would be to avoid maintaining type information.
Do you really need to read _x_ of a field here?
I'm just curious, what does this method mean? It seems to be used?
nit: return createChain(List.copyOf(startQualifier),  Also, we could only wrap ByteString.toString(n) in a null check.
Why do you need the new channels to be closed? I mean the "while" block at the end of the try block and the break can go away...
We can get the title of the editor from the event here too. The tree should be passed to the model from the event to the editor itself since it's only used for loading. Wdyt?
nit: missing braces, since a while we use braces around single line blocks, change this only for newCountersSource(..)?
Shall we use getBytes() here?
Can't the following two be assertFalse?
remove System.out.println
This identation is odd, but you can use {} to wrap statements.
This can be static variable, so I don't think it's worth changing it.
no need for this local variable.
This is wrong,'message' can be chained into a single line: > Changed event = revInfo.setText(new Branch(revision, revision.message())); ChangeInfo info = revInfo.hasMessage(info); if (info.draft()) { Log.info("Change-id: " + revInfo.draft()); }
do we need a try/catch here?
Can be written as a single line: java final List<String> acsModeledSegment = new ArrayList<>();
Can't we keep this test the same as it used above?
nit: missing space around =
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
style nit: no braces around single line block
I believe every one of these test is correct. This one says.with(File) in the line -------.
I'm not a big fan of calling setUp() and setup() in the finally block, as this method is always called before would be executed, and we could have several tests here. I think it would be better to have this method receive the database and try to use here, instead of handling this during tests.
Spacing is off.
Instead of creating a couple of extra Timestamp objects, move this outside the loop
I think you meant to use MorePredicates.transform(...) here.
Minor detail but this could be changed a bit the same as in superClass (page) tree.symbol().get(id) below.
This could be public.
What is the reason for this change?
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
This is not a good place for the change.
lang.Character is not used
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
If you're at it you can remove the isNotLocal fallback fallback, the old one will fail on line 88 anyway, and it's not clear what's the point of the new storage domain scenario if you want to change it, no?
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Minor: can you extract local variable for e.g. / numberOfTasks; to make it more readable.
probably want to print to console instead of System.out.println
Check for null
Null check required?
If you set to disable it, then you could have a @Before and stop it in the getCatalog().save(...) call that does that for you.
isEmpty
You may want to log the folder.exists() here.
Hi [1] [1] <LINK_0> [1] <LINK_1>
This too I would suggest static import: java.util.Objects.requireNonNull("rc", "result")
Should this use a try { } finally? Otherwise other Throwables leak.
why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicId + ":v" for schema registry to work with
Perhaps we want to asserts with 'expectedInterval' instead?
does it mean that CM returns the DataBuffer token instead of the internal server?
looks like writing the response value from the original byte array might be better?
setBot
you can declare this variable inside the if, so you can return directly.
A method should return true if the actionMode is null
Should we set status.getWaitTimeInWindow().compareTo(status) at the end of this statement?
This could be called through the spanRef provided as a lock.
Do we need this log statement anymore?
If you are in Java 8, it is nicer to use.then.
extract this into a variable
This could be refactored in a test
I am wondering if we should keep exchange here.
Similarly here; you can use the Const.ParamsNames.ENTITY_TYPE + "email" + emailType.
please rename to performOpenColorPickerView
please have a check for the standard library functions of the map
Could this check be combined with the one above?
I think this should be publishEvent
Does it make sense to check clusterParticipant!= null?
I don't think this code is needed, since in.line() is the same as in HttpConnection
Can you make this an internal constant.
nit: you can use StringUtils.isNotEmpty
I don't think we need to change this class. How about just KVSerde.from(sourceName)?
I'd say just add..else to the if.
Why do you not use disposeStatus() in the refresh?
You can also remove the try-catch and just write a test that verifies the email is null, and call the method on that.
The call to closeInputStream is redundant. This method will throw an exception if there is other code in the method that called log message but the invocation on server.getFileStreams().isCompleted() is only called in the else case, and the call to log message is redundant.
I think warn is enough here. We should also print the whole stack trace because if you want to report it in debug mode, then use warn.
The repository name should be a constant.
you can use Schema's isNullable and getNonNullable methods to help out here.
I'm not sure this can be simplified. Why put the handler inside the if?
Instead of assertNotNull(...), you should use AddressUtil.getAddressHolder instead.
if it existed in containers, is it not sufficient?
NaN if outputRowCount is 0
have this value here?
This can be switched with if (LOGId.isEmpty())
This condition is too long, so you should use a variable jcrPath instead of the jcrPath
why catch two exceptions and exception?
Wouldn't it be easier to assert a data type here that is int & a bug in the CF?
When e.getMessage() is null, is there a chance of ex/throw the same exception?
I'm not sure what we want to do. Why don't we do a toLowerCase here, rather than setting it for each attribute?
why couldn't we return results before the analysis is completed?
This looks a bit strange?
Please test for null, it doesn't need to be fixed
Please add a space before the if.
Why do we need to store it in the ModeUtils?
final?
This doesn't make sense as an else if.
Lets break this up into a method in parkedOffset, basically where it was interrupted (and parsed) this would be called.
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
getLocation can return null and we should be sure it is of length 0.
If the file is created in each test, can we make it more self-describing?
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
Hm, I see why you added this code? The original code here just adds the functionality. If you have it, I wouldn't want to read this method (as it is in the 'if' below).
This should be logged here instead of e.printStackTrace();
This log seems redundant, you can also remove this debug.
Please change the wording
More descriptive names
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
style nit: no braces around single line block
This looks wrong - the timeline should still take care of this. The "added" is wrong, but the @BeforeClass method signature has to provide that signature. Shouldn't we remove the public static method?
If blobName is blank, then do we need to add "empty" colon?
Is this part of the issue?
We don't print to System.out here - use LOG.
Did you check for this case? I don't think we can support this feature.
this should be done only if the user is created with permissions, right?
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
Perhaps we want to provide the actual response status code in the constructor so we don't have to do it here.
If m_esAdvertisedGerAdvertisedGerAdvertisedGerAdvertisedGeriver, m_esW, then we don't need to catch that when set source=null.
Would be nice to make this the same as startFailedOnStoreCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessSequence and move it to the constructor as well.
Same line.
I'm not sure this message is accurate. In the words, we could potentially see some time on average the maximum number of days requested. Maybe we should use the time limit: {1} and {3} instead of {1}
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
u can use Util.isTemplate
This (the whole method) could keep the same indentation char.
please move to Parameter
this logic should be in clusterDao.getAllVdsGroupId(), not clusterId
I think it is better to use a string resource instead of an exception, like this: java try { bridgeHandler = bridgeHandler.getBridge().getBridge().. } catch (Exception ex) { // startup the bridge handler only has an instance of bridge handler. }
We do the same ternary operator above - how about breaking this out into a seperate function.
isConnected() would be appropriate here.
This class has a bug. I suspect that the merge method should be called mergeResult instead of oldHeadId. If a user wants to access the merge content, it would be much easier to read and understand.
We can use return Optional.of() instead of createSourceContext() here as well.
I would use AsyncServiceTest.assertInCodedReasonNonCodedReasonNonCodedReasonNonCoded here
The default should be always false. The check should be performed here not in the constructor.
Could we please move this into a finally block?
Can you make this a constant?
Given we are doing multiple things at once I would prefer: final Programmer@4induction = new Programmer(4induction, "))); final Programmer@4induction = new Programmer(4induction, 4); final Programmer@4induction = new Programmer{4induction}); final Programmer{nick='faxternity'}"
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
Why 5?
Your question is badly phrased. Exception in case of IOExceptionslackFileRequest slackFileRequest = slackFileRequestException.log(Level.WARNING, "Error closing HttpClient for current execution " + workspace, e); That's the thing I found. I'm not sure you want to log this exception here as well.
could you extract body of the try-catch block to a method?
IIUC this code was also inherited but it might be clearer to move this block to a helper class.
Nitpick: remove this
Maybe we should move this to warn level?
"cpu" -> "context"
I doubt that it needs to be removed, too... this can't be the self link to the self namespace
I thought this was only ever used to be true?
kryoAndEdges may be null
initialize this variable in declaration and assignment
suggestion float xmax = ((xmin < x) && ymax < x && ymin <= x && ymin < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax <
TerminalSession is deprecated, and it does a confusing to check for null
Wondering if we should catch a more specific exception here. For example, if it may be null (didn't provided), that is likely a bad thing to do, and the null check would be redundant.
why are you destroying the user? I think this test should be deleting the user when its name says that the user is removed from the db.
Do we want to have a switch here? E.g. 3 == LiteralText
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we can make a followup change. :)
System.out/err?
Just want to make sure: do you really want to create a string with byte[] instead of byte[]?
There is only one usage of the query: select "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_uuid=u.id and gu.group_uuid=u.id=?)"
Isn't this quite easier to read if we use a switch-case?
I would suggest to correct the code block in line 91, no resource needed, no?
why is the lower bound 0? Should it not be at least 1?
Let's explicitly check whether numBlockOwnershipByEvalIdForServer is empty. Same for storeServerMetrics().
Do we need to cast it to AppSearchProxy?
This should probably be instanceof Handler instead.
There seems to be a leak between these error messages. Might be better to log it.
I'd like to move this into wrap-up.
Please use ServerWizard.finish(wizardDialog.finish()); instead of testing whether it is failing.
This log message has to be removed before sending any instances
why clone()?
It would be nice to test that connection pool size is defaulted to pass in a mockConnectionFactory
I believe that all the hiding constants should be here, maybe even the constants are using the same instance.
extra space
This refresh call should be done inside the refresh() method. It is a problem that UI call call automatically.
You can extract this into a separate method.
![MINOR](<LINK_1> Change this to "includeCredential" or something similar. [![rule](<LINK_2>](<LINK_0>
Please use the custom exception's name instead of the catch.
Is this semantically correct? Why do we need to get a CaptureResponse, and a FutureResource to return it?
I would do that for simplicity, if you set globalHash to empty list, do you think it is possible for this result to at least do the same thing?
![MAJOR](<LINK_2> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_0>
Code style
Use checkNotNull(outputHandler, "outputHandler"); instead please
Could you add a overload to pass a BinaryHeapOutputStream or String[]?
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
Shouldn't this be: return PrioritizedFilterChainResolver.init(accountFilterFactory);
The declarator and the 'else' branch are redundant. The only valid cases can happen in this if-else statement, but there is no way to avoid it.
I think this would be easier to read if it was a plain old data.
Why aren't you using 'createNic(..);
I think you need to do this, given that the entry is not exist in the config file.
same.. it's just a special case for a clock concern
It only seems to be used in tests instead of extracted to a local variable.
Already made a utility of mkdirs() which is public.
Again, this method doesn't need to be public?
I think this can be truststorePasswordAlias instead of the string?
I'd rather throw the exception from the catch so that no repeat message.
Where is the order of parameters changed?
Why adding unneeded braces?
This should be false because you are not setting the view to true.
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
It's better to catch File(Class<?> path) in finally block instead of in try-catch and do the cleanup in @AfterClass(expected = IOException). try { return new IllegalStateException("unable to copy file", e); } catch (IOException e) { throw new IllegalStateException(String.format("unable to copy file file: " + path)); }
The build should probably be done only if the folder.setPropertyValue() is ever called for any folder.
Are there any race condition here? If it's not the requestMessage itself and the list of members, the partition table can be read from the cluster.
don't we want to get rid of the null check (also with the visitor pattern)
Also can we put this into a debug log message so we can see what the problem is (and if no topic is provided), then add: log.debug("Topic '%s' supplied via the '%s' property is required");
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
Is it possible to avoid this method?
Why not using the windowData for the window?
Can we use injection instead of creating a new CorsConfiguration?
remove the isDebugEnabled()
It's good to be missing something, but it reads a little strange to have an empty block than a few lines below.
Can we add one more delay rather than just sleeping for a second
is this needed?
nit: add braces for each if statement
This parameter should be in the core of the method so we don't need to set this on mergeDependencies method.
This could be a static method that returns a HashMap. It would be more efficient to use a HashSet.
nit: maybe rename this to something like CorruptionHealthReportAndUseCase?
Why not merging the RuntimeException?
I think this should be { } else { The original exception is lost for this branch.
This Exception can be removed. As this is common practice in all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception) is no longer needed. Do we want to convert such a case?
Nit: Don't need the "." at the end of the test.
Add a line break
We can use Paths.get(System.getProperty("basedir"), "v1") here instead of "target.xml"
Same here, we can use the expectedPreparedStatement variable.
suggestion log.warn("SHA-256 is supported for this file cannot be found for this file");
This part can be moved to the else block.
Unnecessary :ant: this doesn't need to be 'any'.
Style-nit: We don't use braces around single statements.
Why do you use "testReference" here? It is highly discouraged, wait for an element instead
short -> short
two questions regarding this logic. 1. Why isn't this synchronized(boolean) { while(true) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code } Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations).hasSize(1);
It would be better to use getSelection() and hasNext() here.
Aren't you supposed to be checking cookie!= null?
shouldn't you be testing the condition?
Consider changing to SubMonitor.convert(monitor, SubMonitor.newChild(1)) here.
How about creating a new ResourceLocation on the same thread?
This is a little redundant, the second part of the if statement below is enough: if (parts.getStorage().setNfsVersion()!= null) { model.getStorage().setNfsVersion(cnx); } else { // do stuff }
nit: should this be pipelineDataSize?
Is there any specific reason to use "tange"? If so, then you could add a retry mechanism in the callback.
change to insertMap(this, null);
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
Needs a space before the comma.
Could be: return result.register(registryObject, viewModel);
We should probably use the constants for the correlation id in the message
This should be moved to a method under class.
This is a very minor optimization, but will make it more clear if we do not call it Firehose instead of firehose after the eventFormat is created in CTF.
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Arrays.asList(range1, command.getParameters())); p2.setName("p1");
You could move this to the constructor because you pass the list of listeners in the constructor.
I guess "(s)" is a reason why the srg names are split into two strings..
Not sure if this is crucial, but it should be deferring the default capacity for the cache size.
This can be moved below the check right?
is there a problem with this? it is another loop
Please include clientTelemetryEnabled in toString() API
formatting
Unnecessary final
Is this change required? if not, maybe consider moving it back to the sslConfig.requireSslConfig() method.
We should extract this to a constant in the base class, no?
Should this be CF_METRICS_METADATA_NAME?
Do you think we could make this a bit more readable?
I think the "/" in this case should be 'else'... as some reason...
consider making a parameter to indicate whether we're not making a new version or not.
In the new web layer, maybe use com.facebook.presto.server.BaseAdmin#create instead of this PR?
remove this line
I would give a better name than what is not found.
Anyone would think you're a Go programmer with those variable names ;)
Yes, that is what you want.
"Cannot create a thing of type '{}'."
nit: probably we don't need to specify this if we have a constant called retryCount < this.maxRetryIntervalSeconds
> I am not sure this is a change. The PR was intended to convert this to a V value that Versionable, but it's just a vugment
I'm not sure if this is a good place to set - when spark version is true, the other means that the Spark job is running, and not " "." is on a higher version, and on some other hand, the running version is on a --template value but seems to be the task running in the spark connector so it could be that the user can run --t find SparkSession? Or is it the same as the other way around?
why bother keeping it twice?
With the original code, you can't remove the catch clause.
if (provider == null) { return Collections.emptySet(); } //the list is not mutable
extract as constant
Should we have this block exit earlier? Or do we have a act on the part being the tear down?
I think this should also be wrapped into a try/catch that handles the case where a non-null variable binding has a constraint that is not of type-null.
epdqGatewayResponse.from() -> epdqGatewayResponse.addGatewayError(epdqGatewayResponse.getBaseResponse()), I think it's probably better to move this logic into a separate method so it's clearer what's happening here.
I'd just do more checks on tuples and assert their types, e.g. if ( frame.equals(tupleFromFrame)) { is enough, you can just do an equality check and if the frame is not null, or if it doesn't contain anything.
Could you create a private static final int constant for the size of the class and use that instead of Integer?
why do we need to wait for 5 seconds here?
Move this and the following to line 885
RadioSingleActivity with an argument, as the key is not used in all the places.
Yes it would be easier to read if you remove the whole Event class from the first place so that the second event becomes obsolete.
I think it would be better to not parse the value directly in the constructor, rather than doing a cast on every call.
The best way to do this. This constructor creates a list of object names, but it doesn't have to be stored in the Description object.
I think we have a test that should specify a user that isn't valid.
Need to remove this log.
Have you checked that the test fails if the this assertion fails?
May be you can leave this as debug
nit: it is not a good idea to propagate a query to the Response. We just want to keep it simple.
This should be a JUnit test class.
Might be clearer if you actually check that sampleRowKeys.size() and bundles.size() are 1. Also a check on the estimatedSizeBytes will make things clearer.
This is not really the right issue because the problem is also _broken.
Looks like error message should be updated as well
getNonProxyHosts() already has a risk of NPE, this is not handled by the following :(isProxyEnabled(cluster.getTimer())) so I think it will work
IMO better to introduce a method "NodeUrl" that will be used here.
We should also attempt logging/trace here.
optional: File::getName
Why are these 2 lines?
is this necessary?
Should we log the warning to stdout? We should handle the same with a message like, below.
also assert the contentlet.isInodeIndexed( testContentlet.getCode(), false);
It feels like this loop should be replaced by a call to.equals on both sets of fields.
The gui does not need to be set to null.
Why not use StandardCharsets.UTF_8?
This should be set back to false. Also, it is also null if the application is not connected, as you could have another set of problems to open/close adapter.
File.mkdirs doesn't throw an exception if input is not an File.
You can use Handler.getActiveWorkbenchWindow().getoomManager() instead of directly allocating the mouse listener.
If we have the skipUser() call, we can assume that enqueuedAccount(). Similarly for the rest of the logic.
1. I'd recommend a hash that is,- if the VM is a mandatory variable, the way you get it from the db is read: 2. if the disks on a disk is X is Y, VmDynamic is not a big deal - it should be synchronized - the disk should be on the same disk
We could use AssertJ's assertions in one line
Can you please explain this line and the next one: buffer.setSize(new Font());
unrelated change
This is never called.
Why is this use case? It's not obvious to me in the code.
Should these both be in the switch?
Can you make this "BlobId" so that this is only available for the rest?
getLimit will return null. Can you call createColumns() instead?
I think this should use.equals over ==
This should be a try-with-resources block in case the getHtml is null.
Lots of unnecessary parentheses here.
I don't think these two lines are necessary.
This and other places can be simplified to: java if (table.hasEmbeddedStrategy()) { properties.put(schema.getSchema(), PartitionStrategy.parseFromSchema(schema, properties, format, schema)); } else { return buildPartitionStrategy(schema, properties, format, partitionStrategy); }
Can't you just catch JamesCliException here?
This only runs on GgtkVersion:2 but not on the libj version. I think the only reason this still runs on GgtkVersion:2gtkVersion:2gtkVersion:6117 This somehow looks a bit funky to me. How about trying to set this to not run on gtkVersion instead? would this work on cocoa/win32?
I'm not sure this should be a part of the defined service.
this logic should be inside the if (inputField!= null) block
Use loops, both here and in perf tests.
I'm not sure why we need this method 'else', but if we're in the same lines, I think we can drop the 'else' clause.
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
Is this change necessary?
It seems a bit strange to use comparator for the version check missing: comparison, comparing the version with the same version as the first one.
better: java new Gson(notifications.get("enabled"), notificationListType.disabled)
I am not sure about that. IMO we should set workspace name to null here.
can you use the TreeMap here?
the definition can move to the try block
Why is this necessary? It was already called on the client side.
what is the reason you are using assertNull here instead of assertTrue?
Can we use assertEquals here? I don't think we need to go since the client closes the server.
Remove, please, this line.
Can you keep this one way or the other by making the code work on a test?
Please use AsyncCountDownLatch here. Both handlers slave and inheritance etc will be preferred.
This should occur before the call to isValidType.
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
can you please use a standard for loop
Spacing
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
Did I miss where you close it?
What if.filter(dice) is null?
Should be debug
Where is the error level added?
checking for at least one 1. As a user I would make it report if the 1. If not, I would say that at least "really" not the default, like "no fetch". 2. If you are using the same name, I would say "default" here (I see no entries in the database, but that's a bit confusing).
Just use logger.error("Retrying rate limiter.log.debug", e);
Also we need to close the server even if we do not try to open it.
can you fix the typo on mppProviders
Can we put this to the else branch?
Sidem: I know it's not a mandatory code, but could we do a null check via / -1 if the parameter is not a localized number etc?
I feel like this test and the above test have switched titles.
might be worth putting this into an interface? The test is rather confusing (and it relies on the serialization order).
this should be an error instead.
can you put the specific exception e.getMessage() into a separate catch block and log as an error? There might be other places where this is needed, but could be simply being put in a separate catch block.
why not make "update" a constant too?
we can set variable directly here.
Should this be CompoundRuntimeException?
Also, you might consider making this a method: java return Util.append(text, null);
Please benchmark this. The code was written this way for a reason.
Slightly confused by this method
why not to use Delta.CONTENT which is the only place that we need in.
Use NetworkUtils:isInternetConnectionEstablished
wait.forElementPresent(NAV_ICON) is pretty bad, before the loop and will fix it.
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
why swap?
Formatting is off here.
This is a very minor nitpick, but is there a reason for not using printStackTrace()?
Is there a way to retry the loop without the sleep? Long count = response.get(num); if (headers!= null) { loop over the SessionService.sleep(value); // wait for the expiry time for the response if the request succeeds or the request failed... }
We could avoid nesting by skipping some of the following lines if block : java if (qName.equals(key)) {... }
toString() (and possibly use String.format)
it would be better to use StringUtils.isNotBlank(rc)
Should the registered index be a Utils.getIncludedKeys()?
Minor: In the first case, I am concerned about this test. For example, if the recoveryManager is not null, the user could shutdown it.
Instead of parsing thecsvFile, could we use a static variable to save all the files and verify that it is a directory?
Could use new ArrayList<>(Arrays.asList(withLanguage) here and below.
You could use the ninePatchHeight instead of the width.
Not a big fan of creating a separate StreamProcessor in the test class. Why don't we use it outside the test?
Use Util.validateArgAndThrow public void isEqualTo(String tableName, String tableName)
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> schema, Expression Expression pattern, Optional<Expression> schema) { Expression Expression pattern = Index.parsePredicate(metadata.getCatalogName(), schema.getSchemaName(), TABLE_TABLES); schema.put(INDEX, Expression.getRequiredTransactionId(), schema, showTables); }
if a new method that will be added here would make this code more readable
Beware that this code is invoking logger.getLogger() on loggerContext. It's not exactly the same as logger.getLogger(logLevel).. No need to use a logger.
In most places you've changed using of getter to direct access to the members, here you didn't do that, was that intentionally?
We should have the cause in the exception. Otherwise, it is sometimes seen and deleted as a partial file.
Shouldn't we use the try with resources here.
this is another behavior change, it should be discussed in #6610
do we even need to say getResults here?
Please use network.isChangable(new Guid().toString())
It would be nice to verify that the special text appear in the test dialog.
Do we need to log leaked resources?
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE); addr = attr.channel.get(); } else { addr = chctx.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE); }
You may want to make it a static variable and call it in the constructor rather than on every call.
I wonder if maybe it would be nicer for Java to pull this logic out into a couple of places, do you think it would be easier to make a map based on the keys?
Could you fix this while you are at it?
I guess this should be extracted in a separate method to avoid code duplication.
As above, I think we should simplify the instanceof check.
please make it static
one more thing: if windowInfoList!= null, and windowInfoList can be null (lined as well). I think UNKNOWN is better than mb.pushGetResultSets() will only be called once per node, which should be correct.
Need to change'return' to 'else'.
I'm wondering if it would be better to have a retry loop here. Even if we're going to wait out of 5 seconds, it doesn't give us a chance to break.
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please add them also here. Otherwise if you are sure none of the fields will ever be null in a column?
As discussed offline, we probably need 2 things here: - 1. Can we change the variable for clarity, avoiding the temporary variable for clarity? 2. Why not change the variable for clarity, e.g. RiakClient.readFrom()?
instead of path separator create new path to make it generic
try using stream api for filtering
The MaxThread is created a couple of times, I think we should reset it to 0.
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
We're no longer using the stored values in the local variable. Let's call removeAll instead of getAll.
If I'm reading this right (and I may be missing something!), it seems like we're never actually _cancelling_ these futures, right? We're just waiting for them to finish on their own?
You can combine the two ifs into one.
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "message" 3 times. [![rule](<LINK_0>](<LINK_2>
should this happen before the loop?
Basically the same issue as mentioned above, I believe.
Can you explain how users are easily guarded by the possibility to prevent NPE?
> return true; [](startTracking.getAclStatus()). > 0; can be final.
Can this be made final?
nit: I still prefer this. It looks like it's in an other test for the code above.
I think this whole block could be moved away from line 63 to 76. Having different grammar in it is to split up the string's length.
Other setters are named as parameters
I don't think this is correct. I think we should make the scenario more clear.
Right, it's fine for the getFirefoxAccount call, but there is no need to check for that.
Could you keep this method on the same line? It doesn't seem to provide any value.
this can be done outside the while loop
I don't understand this error message. We need to know about invalid property value or path, right? In other words, this error message does not make sense. I guess it should be "Failed to delete directory. Valid path %s"
Same as above. Could be combined to a method.
"No remote image" is done twice.
equalsIgnoreCase() is redundant. (If it is null, just set the boolean to true).
Can we log the URI and the NEW_LINE directly?
It looks like this check is also covered by the @Rule's printInfo that the attribute is actually the same as the attribute.
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceStatusReturnValue and not FenceStatusReturnValue itself.
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
Merge this line with the one above
please reformat this condition
Can you check your identation settings?
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
the check is still not needed
Remove check for (previous version of the current time).
remove printStackTrace()
Should be moved inside the try block.
Now that we're checking adapter.getPlacementId() can go null. This is the replacement for checking.
switch please.
if you change this to (representation == null), you should break the test.
Consider usage of KubernetesMachineConfig.machine.getMetadata().getIdentity() instead of KubernetesMachineConfig.
can we keep the old error message please? I think it'll be easier to assert that the field is null.
Isn't there some simple little library for generating JSON output? This seems like overkill, but probably isn't there some simple little library for generating JSON output for both?
Please rename operatorType to operatorType
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL) as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
So the spec is applied to the InputStream and thus does not need to special case it but we have to parse it in certain way. However, if the objectMapper is present, we don't need to parse it again.
Single line for readability.
This should be simplified to wrap with Objects.requireNonNull.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java.put(TESTER_NAMES, testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(Collectors.joining(",")));
I think we should have a task.getData().setText(workingSet.isEmpty()) and the label provider.
same here, can you make a smaller error message and also check that the error is returned in constructFailed()
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs,...)?
I'm not sure if the use of the! is scheduling rule. If we want to do this, we should just use!launched.isCanceled()
put these code in a separate method.
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Formatting?
This could be more concise as as!Strings.isNullOrEmpty(valueToCheck)
There are some project types that are not Abstract Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractTriggeredView that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find some sort of utility or find that also has getTriggers?
we need to handle that somehow, I think the UpdateVmCommand should be marked with @Nullable
Is this change really needed?
do we need this, since initializeDisksAndReplica does not have the field any more?
removeImage and removeImage too
please move this to the top. We shouldn't need the PolicyId here, but for the sake of consistency, I'd prefer to move this if-else there
This message doesn't seem clear.
Nit: I think this change is not needed if lbService is null
Do we need to check parameter.value, or can we just use parameter.value?
This block should probably be debug level.
Extract the creds into a local variable to avoid calling this twice
suggestion if (isLocalPlayer()) {
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
Should this be in a different way? I don't think you need to create the next element, e.g., as in <LINK_0>
Same here, we should pass in the exception to the RuntimeException so that it is easy to miss them from the logs.
"Host"
FileHash is not used.
Unrelated change
this change is not needed any more, as it seems to be a merge of the changes in this file.
Tangay! We should catch this exception only if the user presses ctrl-c/etc/ can't be somehow apparent.
I don't think this is correct. git git blame is also about git git - I don't like it, because it means git git blame / git shows the git tree tree - and the git blame / git commit, which has the git commit, and maybe it is wrong. The git commit will also contain "f3e" in the git tree. So the git tree tree should be in the git commit, maybe it is better to simply extract the git treeIterator.
This test will fail if the specification of getReadChildrenNames is defined, but does not return any value. Should it be RUNNING?
I would prefer to use same code as in method getProjectRelease final Set<Release> releaseIds = projectService.getReleaseIdToUsage().keySet(); for (Release releaseId : releaseIds) {...
instead of batchWriters, could we use globalConfiguration.isClustered()? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
I don't think you need to set the build to true here.
This should be a warn
You don't want to move them all to hamcrest?
This is inconsistent to use TxFormatter.getInstance().scheduleState(slaveState);
I guess this will be GWT's code?
please rename to "decimalPlaces"
rename to resolvedBundleField
You can inline this variable. It is not really needed for more readability
"/" from java.lang.String is more readable than String.format
This fails for Gerrit server to abort.
Can we make the init() method private?
Let's keep the same behaviour for this.
Same here, you can flip the order of the lines.
Should equals on the exception?
Can we use String.format() to make it more readable?
I'm not sure we should handle this in the modification of the value. The way to introduce this is to add additional checks: if (outcome.equals(ENABLED_ATTRIBUTION_PARAM_TIME)) { return; }
I don't think we should leave the data being read through, except if the layer input is enabled, we should move the show and location check to ArcGISMap.
Do we really need to set the link status?
Could you please explain why this assertion is necessary? Couldn't the assertion be done just once.
Could we refactor this log message in a unit test?
space before "()"
You should probably parse the value using StringUtils.isBlank()
na!= null is redundant.
should this be error level?
Stereotypeifier instanceof EObject is not part of your commit
Shall we throw an exception instead of returning null?
The while loop can be replaced with for (int i = 0; i < size; i++) {
what if subTree is null?
Minor thing, why are we retrieving the value and not the jsonGraph key?
can we change this to a warn log message indicating that the segment was deleted for a segment on an entry?
static import
cache?
why not use a method reference?
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
If we're already using MenuManager... just to show the dialog it like this: 1. The enabled flag should be enabled in the manifest builder but not 2. Why doesn't the menu always be enabled? 2. If the user has to listen to the enabled flag and hide the keyboard here.
Please call mkdirs() here. And it is strange that getWorkspace returns null.
If you want to be sure that this method is not a SectionMatcher rather than a regular root, then it might be better to pull it out into a method that returns a List<Section> to avoid doing the cast here.
The file should be split after where you make sure that there are no data for spooled files.
I don't think that this will work for all cases. You need to just start the project and then dispose the outlinePage.removeMavenProjectChangedListener() method.
can't we use the new enforce function calls here?
I think we should close the StringReader after unmarshaling.
Can you please extract this block to a separate method, for the sake of readability.
This doesn't look right. Why are you making the diff complete so that when only one machine there isn't a full cubes, they can be made unhappy and there should be no null check here.
I am not sure we need to create a couple of local variables here... should we use the rateLimiterConfigurationProperties.as(entry -> rateLimiter.getCache()!= null, entry.getValue())?
use static import for AssertJ
Please benchmark this. The code was written this way for a reason.
Change the lambda arg's name to __ when not used
This can be simplified into: if (getFeedbackSessionResultsForInstructorInstructorInSection(feedbackSession, instructor, instructor.email)) {
well, of course I can read the code and understand, but - still, maybe enum is better.
I don't think it's worth using.equals() here. The underlying issue is that the event is only about one element (as it's probably going to be ordered anyway) so a user could just enter a hint.
Can we add the cause here as well?
It might be better to use utility methods from RepositoryInfo to build the string and then handle it in the manager, e.g. "String imageName ").append(imageTitle).append("\n")
Why would the conversion be done outside the if-block?
This block is not covered by the existing check, but changelogMetadata!= null check is already done here.
We should add a check for the channelInterceptorBean to ensure we have the same bean in the registry. Otherwise these lines will cause an NPE if the bean is null.
[minor] Should we not change that?
Could you please explain why this could't we move this into a method?
Is this the same as the one above?
setStatusInfo (see other places)
Does this one need to be changed to '...' too?
[optional] Is it really correct to have this return a void method and not add the return value of'shouldBuildEvent'?
you can use the stream
We cannot convert to boolean value, same reason
As it's a nullable field, null protection would be good just in case: if (occurrenceHasBeenInDate.size() == null || occurrence.contains(occurrences.size())) {
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is healthy. Will be able to add another task to the DB to indicate that the image was actually removed.
please use VdcBllMessages.ACTION_domain_id
This is adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
This is not really a good idea.
Should be final
Magic number.
The first null check is not necessary. Can we have 'eventExpressionExecutors[0].execute(event)' as the second argument in this case?
I'm not sure if this is correct, but perhaps the class should have a 'findEntry' that provides a 'from'. Because the Map's elements are not fully initialized, you cannot do anything with it. But perhaps the stream knows it is worth it to make the tool happy.
If we remove the null check, will it results in NPE? (Line 74)
This shouldn't be here, as it's only extended from a single file.
I see, why are we testing the group name here? test(s)
Check if array is empty.
The test name is cryptic, as it gets reported in to me (that is what it was doing). I like to think about it to be more verbose, but having a dummy name makes me wonder why it gets used in the future.
Useless nested if.
com.google.common.base.Preconditions#checkArgument at the end of this method.
You can use the operator to compare strings.
Is there a reason why getStackTrace() returns an array?
rules don't allow for use of a LinkedHashSet.
I do'nt understand why you need a second loop. Is it faster to set the trim() at every iteration?
I prefer using prepareAndStoreShaderProvider rather than prepareAndStore, like this: prepareAndStoreShaderProvider(true); prepareAndStoreShaderProvider(true);
Can we move this up and remove the if/else entirely?
Whey this coordinate, maybe variable somewhere, and can be computed
With Type#valueOf(...), I'm not sure why () takes a Type.Builder, it makes sense to use the builder and MetadataBuilder#withPartitionGroup()
Better have a type.
read <LINK_0>
I think we can use a different default value for the test case.
Missing some sort of toString() method.
This is default value for all requests, so no need to add to it.
I think this is missing something
instead, we can use  PrimitiveLongDiffSets#getAdded().
Add a break to this if? Then, this condition is not needed.
Ew, that just looks icky. Admitedly less efficient... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer: java for (int i = bag.size() - config.getMinimumIdle(); i++) { if (removable > 0L) { connectionBag.reserve(bagEntry); } } }
this code is duplicated from line 59, can we have a single method?
I assume the app is with a different name for the pre-existing Aggregator class
I'd use a different name for asyncGet(), in order to be sure.
Is this correct? The labels are not set to be saved..
Please update 'log' to have the text as a parameter.
This change looks quite strange. Why?
Wow, this is scary. I think you can do away with the original implementation.
should just be inside try block
this line is gone, why?
I don't think we should call the setter here and add a null check. The login is called for the OAuth2ConfigurationProvider.
ERR_DELETE_ERROR, we don't need the conditional here.
add generics check here
Does this need to be in the try catch? Is there a specific test for that?
The lines 133-139-468 are repeated several times. Maybe we could extract it to a method?
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgToRegenerateAntiCsrfTokenValueIfRequired)
Can you set the log on that case? Spacing happens only around s
This method is too complicated and I'd be able to do it in a separate thread.
What happens if importsForModule is not an tiningChunk and findChunk is empty?
this should be moved out of the try/catch at all filters
Can be put into a containsExactly method and reverse the order.
Why this query is needed?
Same question as above.
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
Break this out into a method and call it for the different semantics?
I think you could add break here
isUnauthorized 401
Will you explain why you made you change this line? I had to read your code on why would you have to change the branch for the Path.equals to avoid the import files on line 47.
Shouldn't this be in the try with resources?
Can you use entries.get(key1, value2, 0) instead of just keys?
we don't use try-with-resources? And join() can throw OperationException.
Let's log this instead of just print to stdout
can be private. I actually think the async client will be able to set the tag by its tag without a null tag.
same here: return DbFacade.getInstance().getVdsGroup().getVmTemplateData().getVmTemplateData().getVmTemplateData().getVmTemplateId()..
rename 'child'?
This should be is[01]_[\\d\\w](<LINK_0>
May be better to put dataCache.destroyed on the next line
Please no-arg constructor. Change the constructor to use.add(new Loyaltyard()).
Maybe catch OutcomeEventsTableException
suggestion // <LINK_0> private List<Integer> threadIDs = ParseUtil.split(File.getName(), this.name(), threadIDs, String.valueOf(file.getName()));
Make these as final
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Does it really make sense to have a plugin with multiple secure-stores? What would be the rationale behind it?
this if/else is unnecessary
This method should be called outputStream
After getAssets, could you add a warning message to the log statement?
Should there be a check to make sure the asset is non-null before modifying it?
Shouldn't this code run even if mHasWifi is false?
I think we can probably skip this this if conf.getNumPartitions() == conf.getNumPartitions() && conf.getNumPartitions() > conf.getNumPartitions()
This is a bit strange to me. The logic in this method is a util method and called isThisNextJob, then it gets called. I think the same method could be refactored out into a single method that takes a parameter.
Maybe rename this variable to entityType
This is really long code a lot with the block around the block, and could be extracted into a method
This is a bug, we should only handle this if branch. There are multiple source and target modules that use this same dir as the android file.
I think this should be a StructuredRecord can be stored in a field and then reused like this. Isn't it?
Confusing name
It's reasonable to catch multiple exceptions and rethrow it as a RuntimeException (or some other exception I realize)
This method might have been pretty non-static and it seems like the slightly different value. It might be a little cleaner to have a static method for the slice creation, and use that here.
@Gold which have a \x in the list. Yet I'm not sure what the Gold which have a \x in the list.
I think that this one and the other doesn't need to be synchronized anymore.
Can be rewritten as: Parameter text = model.getCommand();
code style
this check is redundant here.
I think just checking theadvisor with the criteria, we don't seem to be able to avoid multiple locations where the same entry is already registered.
Is this really necessary? A simple regex would be nice.
shouldn't we change the order here?
Please use ""
is the app context actually used to be the app? do we need to provide something like <LINK_0>
If it's the case, I'd recommend adding a switch statement here to improve readability: event.getPreferences().forEach(player -> joinGame.getPreferences().contains(event));
As in DateWidget you don't need this variable just return binding.getRootButton().widgetButton();
We are already checking by isPresent() before calling peekNextResult.get() to avoid the null check.
I think you need to use early returns. Let's put the condition in the if (layouts.size() > 0) {... }
In case of font. So there is no need to create a new array for each line, with the correct size when no key is provided.
Can you move this file to a private method and reference it in the file?
Can you use our JavaUtil.base16 above instead of system default to UTF-8?
you don't need the else clause here. The caller of this method expects to return a URI which already has the 'null' value. So, the caller doesn't need to do the same thing.
An empty loop can be written as while (true).
I'm not sure I like this design. Is there any way to make it work in the same way? The only thing is that you need to add a new method in StorageProvider to get the current state? I have this kind of thing in general, but would be good to add a (ArtifactEntryService) method to the RepositoryProvider and re-use it, otherwise it will simplify things and will go wrong.
Why both of these steps? It's more clear to me to see the 'private' variable before the method is used.
Define a constant for this
I don't think this is correct. This should be.get() in the line above
Do we need this property at all? I didn't see it added anywhere.
move this to the end of the try statement
You know that this is Nullable, so could be removed.
For consistency, This query is not needed, after the other handle statement.
I'm not sure this is what you want. I wouldn't want to throw an exception and return null for a query on a record - the list contains the same tenantId almost as the one that is supposed to be.
RocksPageStore will be in a bad state after page load.
a few indentations, please, format the code
Can you fix this? I think it might be better to use a logger.
nit: remove unnecessary newline
pull this out into a private method. This will avoid creation of machines if absent by default
nullity check. The first line can throw a NullPointerException because client 'get' method will return null.
_dataFile = CSVFormat.replaceAll("-", "=");
Revert this message
The assert should be on the result of the init() method.
why the!?
I think this is an error.
i think this test is a little confusing...I would suggest removing this line. DepositFactory.getWritableModel(primaryResource).getDepositFilePath(), not a List
Why don't you use the getCurrentUser() function for the time time?
just initialize
Looks like a candidate for a queryType.isNone() check to avoid the need.
Please, add spaces between arguments for those
storm.service.event.get(System.currentTimeMillis() - event.getHostName()) is where you have storm.event. So please use the storm.event.mann.event.name() instead of storm.Event.description
Should we check for null here?
you can reuse the method from line 112, and remove the useless assignment to the local variable that is actually assigned to the method. That way you don't have to copy the method here.
This is weird since calling setSplits may return null. I think you need to handle this case in pre-calculate a lot of booleans.
This should be a constant somewhere.
This might be better as a ParamUtils class.
this looks wrong. please don't call it if it is a normal condition.
If the update's stmt is null, it should be closed already.
Minor nit: since we're adding "p.getParent().get()!= null" the first time we see the change in the PR, I guess we can make this optimization more readable.
Refactor this to a list of error messages
Is this a bug fix? If so, it should be: java if (api == null) { throw new WebApplicationException(Utils.getErrorResponse(errorMsg)); } else { throw new WebApplicationException(Utils.NOT_SPECIFIED, e); }
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) ||!FeatureSupported.refreshLunSupported(DbFacade.getInstance().getStoragePoolDao().get(storagePoolId).getCompatibilityVersion()))) end eliminate the else cluse from line 105.
extract into method?
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
It seems that partitionedRegion.private is not necessary. This is needed.
StringUtils.isEmpty?
Make use of Optional here.
initialize with US_EAST_1 than null and remove else part.
Can you please extract these lines into a separate method?
The exception should be logged as well
We don't need to remove the trailing whitespace?
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce this useless assignment of the "isNull" method. [![rule](<LINK_1>](<LINK_2>
I tend to not re-assign the method's return value. This may be wrong, but is it correct to change this to a Map.
I think we can give this a more explicit message about the code.
The first three lines are unnecessary. The whole point of the : character is to be put into the start, to avoid spaces.
This crashes on my device (4.4). It doesn't seem to like SearchView cannot be handle as it's the root cause if it's not found. Instead, you can just check for the quote from the discovery screen.
I think this would not be necessary. The "getFromElements()" method is already very complex.
Maybe you can put this in the else branch instead? It's not a big deal.
I suggest to use nanoTime instead of "org.jboss.cxf.client.operation.ExitCode".
It's a bit confusing to say this... assume file name is a directory, not a HTML file.
use Math.max()
Remove also'bufferedReader'.
@silenced we should use the same TODO as above.
Why does this change?
Here you don't get to it. Should be!isSkipSubtreePruned
It looks like this is only if the user clicked an app to delete the currently selected item. Please add a warning log here.
I feel this logic is duplicated. Can we maybe have a method in getProperty and that could be called here?
I think it's better to split this into two different cases, e.g.: a.b("c" + "a" + "b" which will also be overwritten, or a different "b" child - that should be tested only if there is noSemanticModel.
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
The closing brackets here are unnecessary.
Why do you name it here? I think it is in kilobytes?
I think it's better to keep the old style of this method. I think it's cleaner to do this: final Ds3Type type = Ds3Type.from(DollarSignFromName).map(this::getValue).orElse(null); if (object.getValue()!= Ds3Type.GDollarSignFromName()) { builder.put(object.getValue(), builder.build()); } else { builder.put(DollarSignFromName, Ds3Type.getValue()); }
Inconsistent 'final', use the same line as the rest of the file
Is there any'sources' here?
no longer necessary, after changes in xml.
why not have the parse call to Integer, it's a BigDecimal instead of a Double? I don't think it's a good idea to catch this as well :P
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of which would be contained in the cm-integration module.
usually we use UTF-8 charset.
nit: getSyndicationOutputView -> getSyndicationView
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
I think that we should be swallowing an error here. Either that or we should throw a runtime exception.
this works, but looks like we're going to use the @Logging annotation. We're going to be able to remove the interrupt on the original thread, but,'s going to be likely to happen on a potentially slow server (and likely to happen on slow).
Did you consider moving this code to the above method so that you don't need to export the blood test? Is this the intended behaviour?
Shall we create a constant for "POST"
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
Do we need to do another lookup here? We'll end up having many unneeded changes, and we're not just translating it straight away.
Do we need to wrap the whole try block in try/catch?
I don't think this need to be in an xml file
would be nice to have more descriptive error message here.
Does this mean that this can be sent to the response time instead of on each send response?
This value is incorrect to always encode the token as a result, I don't think we should change it.
This is not going to work. The method name should be fetchSize
Return early instead of if (sizeBytes > 0) {
Should this be try with resources? I don't see the reader closed
Does this support null(optUri)? If so, didn't that be a valid URI-to-String?
Does it really need to be public? Can't we make it package-private?
I would recommend adding a new method to Timber.w and using it in the ES server.
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
This step is same for standalone as well as domain ;-)
Can you put these two if blocks in a single method to reduce duplicate code?
public static
R.string.in_string_in_string
I'd use.equals() rather than ==.
this expression can be translated to exception.
Shouldn't they're unnecessary? Line 91-97 above be this.
Nit: shouldn't we have an equals() for container name so we can avoid NPEs?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
Potentially break here
For this change, I'd use Integer.BYTES constant.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Can you also use the constants for these strings?
At lease, it should probably be upper or lower, not both.
getBankCode() is an expensive method. What about creating a map with DataNode and using the primitive boolean?
Again, large code.
why not to use the 'vm.getVmId()' method?
Please call.hash() (and the similar method) that you could invoke it once.
@jimerturk does this really need to be public?
Minor: use jbossHome.get("windows.name")
please put this (exceptional treatment) where all other treatment of same kind are done
could you try changing code that makes this hard to read?
Log message shouldn't be something like "case tasks" instead of "process"?
This should probably be UNINITIALIED
Doesn't need to be careful here. It's a boolean function, which returns true if the function is at the same time.
Might be good to call load() like this in a finally block. Otherwise, it is possible for two threads to share the same lock.
Why is this needed?
These need to be in sync with the DistributorVersionCapabilityDTO rather than the set.
you're checking the logging stack trace...
Why not using the new createTree() here?
You should use the divisionId value here
Move this logic to the serviceInfo
Can we move this and the first argument here to not use XPath expressions? If not, why do we need this method?
Same note here. CodePointIterator might be a better choice.
Why do we need the getter for GrillResult?
I don't think this is needed if we get here.
I think this is problematic. Should throw an exception in the case of missed result.
This would be nice as a constant for the complex expression
Hm, we can keep the old method and add a second argument here and then add the attribute when the test fails. I guess we can only do it once, right?
I don't think this is correct. The following code throws an exception if the map is empty. Plus from the if block, which is wrong.
No need for the String.format() for this block
nit: extract private method for readability
Probably better to use Preconditions.checkArgument() here.
You can use player.getLibrary().art( player.getPlayer()) instead of this. Also, it's much easier to read and avoids creating new lines for each player.
With the change you have done this in <LINK_0>, it should be with the CommandUtils class, not the send message.
This line and the next could be converted to ledger metadata, right?
new Patient(request) looks always true so redundant: this operator compares references to the strings but not content.
it's better to use MkAnswer.MkContainer.create()
You might want to return null if you select a workspace or selectedFile. AnFunction would then be totally fine.
I think that we need to do this at the end of the test (after the stab of the user).
Need to correct the capitalization of the param.
Except for the process, you should also use 'this' instead of 'else' here.
you could use the 'i' operator here instead of the conditional with two parameters.
java Vector<D topLeftMapCoordinates() {
Is it possible to have a MultipleRpcCommand or CachedFuture?
Externalize all the exceptions, including 'event.getNewValue()' and 'Object.valueOf' is not required.
This could be a List<Drawable>
Let's use Arrays.deepEquals - qualify deepEquals for consistency with Arrays.equals elsewhere: Arrays.deepEquals - would you put each of the checks in a separate line? return Arrays.deepEquals(f1.hasNext(), l2.hasNext());
Where does this change coming from?
We should not do this, it should be moved into the slugStrategy itself. This is a public static field, so it should be the sid.
Integer.parseInt
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
Grammar: "The application directory does not look like a Maven or /../"
You can do this same way as uesRemoveMatcher.find()
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
Is there a chance that group.getGroups() would return null?
You can put the entrySet in a try-with-resources block to make it cleaner and avoid the need for the empty block below.
It would be nice to add @oscervink-gry that was pretty dangerous. I would think we should at least log the warning if configuredAssetFolderPaths is not enabled and have a configuration in such case. Then you would need to add @since 154 vs 170 which was not backwards compatible.
I would suggest changing the logging level to debug. In the end of the logging, we are doing info level and not via debug.
I'm not certain what the correct thing to do here. If there are multiple groups in unsubscribeed, then don't want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else can be self-onCompleted since that will never trigger onNext, and there will be no guarantees that.
We should create a separate, generic class for this execution, since the body of the method is always the same.
Strange... the JDT UI settings in our projects should remove trailing whitespace. Please remove.
Missing @Override
What do you think about making this a singleton of MeasurementVariable instead of calling the constructor here?
Let's avoid the duplication as much as possible. If there's just a formatting change, I think it's better to leave it as is.
This does not look right. Also, do we really need the hardcoded test?
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
Does the toString() need to be replaced by a reference to the passed in map?
so you can have it at this point in the next round bracket!
:ant: I am not sure that we are getting this to be able to use the User user. I think we are not using the UserRequest outside this method. **For this** line. **For example throw an exception.** In this way the user will not be able to remove the User member variable. **However that the thing inside of a container doesn't have a problem, it is not possible for someone to delete it.**
Why this change?
message should be a parameter of the method so that we don't have to track down
Please use event.variable instead of this.changeError.
It's a typo in variable name
The actual problem is very easy to read when there is no -condition known, but it is initialized to a non-null value. (I would probably affect the test, but it would be broken in the case of the 'if' clause.)
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment() PodSpec podSpec = new PodSpecBuilder().withContainers(container).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID))
"SocketServer time spent on write per key"?
Nit: space before {
Do we really need the map and use the lambda in the lambda? I assume that we only use the result of the lambda in the operation?
'e' is not logged
If you want to fail a VM with a BAD_REQUEST or similar, then you should add the user log, but it was not found in the logs
- [x] This could be refactored into a method that accepts the uri string and the name of the enclosing file: java private final String uri;
you are checking DbFacade.getInstance().getLunDao() again - why?
You could define a variable for this.getFieldNumber() and use it here.
Add one more case to checkState that getBucketProperty is called multiple times
please add the domain name here
Is there a reason why this is just 1 if it is 0? It seems odd to use 2 different numbers. Is there any reason why it is 1 or 2?
That's a bit hard to follow, I'd replace ArrayList with Collections.singletonList(count)
this.declaration = declTree.get(); // Noncompliant
We should avoid using catch, use try-catch with resources.
How is this line really needed?
.toString() might be clearer here, and in the next to the jsonGenerator.startObject() method.
What if delete or backup store is a boolean?
nit: add the other streamToInputStreams in the test?
Can we make these as static constants? This will hard to read in line with the same format etc..
I guess you want to set the order of these as well to work on the main thread, or if you want to read the objects in the loop after the iteration you do not need to set the object in the loop.
This is probably safe. please change to getInitParameter.toString()
Any reason why we didn't use Assertions to make sure it won't be null?
@cuenyad Should we align the name with the rest of the constructor?
I believe this should be!isEmpty(is)?
You probably want an overload of addCode which accepts a boolean.
Just curious, why do we need to check for the key null?
Recursive call to isOptionalCallbacks(...) here.
This logic looks like it can be moved into a method in some other class.
This should use the new constructor, or refactor to use a factory method.
Does it make sense to commit multiple transactions? It seems you are not returning the same result as the rule key, but I would expect data to be returned immediately even if you do not use it.
combine this to line 305
This is an IllegalStateException. If the oldId is null, which means the newId is always non-null. I think we should keep that check instead of throwing an IllegalStateException.
Can we avoid these exception numbers?
Please put the paramParent in the visitNode() method and have this only call to paramParent.symbol().isPublic.
This doesn't look right. Can you make it a private method and put the "public" at the top of this class?
(I don't really see a reason why the checks are here
I think CDA is not the place to set values
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an archaius poller and not a poller for something else.
The author in the header should still be displayed. Please only remove the author from the actual page, not from the blurred header.
I think it is better to leave on the logger line. Same for other places as well.
pretty minor, but shouldn't this be "verify" as well?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
what happens if there are no more entries in the cache? I think it's better to throw an exception instead of returning null
Would it make sense to log a line 133 when the status is not null.
I think this is the same as lines 61-79-83. Should be.equals(body.getBody()).
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
I haven't checked yet equals() returns true for non-null, but with.equals() it does not include the @NonNull annotation.
order of operands
Another nit, I think this loop could be replaced by a call to append().
@romani I'm confused when creating the body of this method and when there are more than one element. I have this called this method and when it's restored, when opening the same script doesn't exist.
shouldn't this be succeeded?
I would expect that this would work if the debugger is closed.
this one I'd rather be re-used
I'm not sure if it's necessary, but in the case where the module is not 'null', there is no need to set the tooltip. The value of'max' is the module.
Move this binding to StorageModule.
You can replace the result here with a call to builder.m_pathToCatalog()
What about skipping ide.waitJUNIT4_PROJECTS_IS_PRECOR_PROJECT_PATH and test 'processInstance'?
use try-with-resources?
You could think about extracting the listener to a local variable: java ChangeListener<Boolean> tabController = ((ChangeListener<applicationName, TrackingModel) callback).loadAppsController();
Why not use ooKeeperMasterModel.statusDeploymentGroup here?
Preconditions is available for Windows now (IIRC this is fixed after enabling any issues). It should probably be fixed in some kind of patch set.
Should this not be public as well?
Remove "return" statement.
Again, these should not pass validateInputs()
Let's read the CL, so that we read it when we read the file.
This should probably be. URL?
Return HIVE_TYPE_INT in order to bundle and change HIVE_TYPE_INT to HIVE_TYPE_INT in order to use the "to" type, since all such cases are static final
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Missing braces
'host.getHosts()' will not be null
Here you should still use the multiTenancyStrategy for the multiTenancy strategy. It will be used to create the factory instances every time, and only used to create them. Otherwise, it will probably change easier to test Reactor's build option without requiring Injector.
can you embed the variable name?
more than 120.
this should be BooleanValueMatcher(value)
Is this really more readable? (IMHO it's not)
plugins => session == null? null : ctx.getSession();
if getString() returns null then line 202 will throw a NPE
The expression should never be null, but the variable can be assigned to variable.
Shouldn't this be an error, instead of a warning?
Can we use the diamond operator here?
You need to add TargetArtifactPermanent and TargetEnchantmentPermanent by default.
should we use a try-with-resources block to ensure the buffer is closed even if it is - this just makes it easier to read and the make sure that it will throw an exception if it will go somewhere else.
This is not necessary, given the same package ishourly should still be explicitly to be inside the constructor.
Should be new Random(), not OBJECT
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
getSchema parses the schema. We should look into if the key is a string.
This assertContains(expected, actual) can be used instead.
else if (storageDomainDR.getJobId()!= null) {
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
This can't be true, as Math.min() would return max if ns0 is > maz. :-) I think you really meant to write: if (buf.length == max) throw When buf.length == max we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == max) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw...
What if you not using estAssignFromElement here?
Can you please rename primaryAddressConf to IP address or use another variable from the NodeMap to getIPv4inSubnet()?
expect the user to receive the Chinese entry while the app is running? Is this really so expensive that it needs to be cached?
Make this variable to pass only the first value.
what is the value of getting the instance this way?
Please move it to resourceManager.updateVmInterface
Whitespace
Suggest making this a method that returns the correct type instead of a complex List.
can you explain the reason why clientsV3 are set to conf and not conf.get(serviceSize > conf.getSecurityProviderFactoryClass(coreSize))
subMonitor.newChild with 1 tick
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
If this is never going to happen, why modify this to be less chatty?
Should we have a throw an exception that is not thrown here?
This is pretty dangerous because alerts bigger than 1MB will break the emitter
Since queryPlus.get() is async, the second argument can be removed
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri() -> "Config server URI is undefined.");
Use equals instead of ==
- You don't need to collect any more characters. - This is basically a copy of the data, right?
Can we use final String cifosApp = Uri.builder().create(activity); instead?
Add newline before return.
Can we use a regular Java8 stream here? I thought we only had to deal with read here, but we should also consider read/write the channel as the index could be read here and don't want to read/write the header.
Can you please explain why do you need this special-case? Can you please explain what it achieve.
No need to use a separate variable (especially as it's a local variable, so there is no multi-threaded way). suggestion NumberAxis xAxis = new NumberAxis(xAxisLabel);
double space
Same as above, I think it would be better to define all constants here to keep the same constant in all places.
Does this need to be made public?
Can't we use ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and not write kind separately?
should this be getFilterActivationPreferenceKey()?
suggestion return getVariables()? m.get() : null;
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
Why do you wait?
I would like to know if it is a phrased statement or something similar. Having a constant here would help to clarify that Divide expression is fine here and can be computed once in the beginning of the function and you can write something like this: java private AccessController get(ApplyNode.class::isInstance).findFirst() { return Type.FATAL.toMillis(); } private Type new Planner(String id, SymbolAllocator symbol, SymbolAllocator symbol, SymbolAllocator symbol) { return new Planner(editNode.getCorrelation(), idAllocator) { return new Planner(editNode.getCorrelation(), idAllocator) }); }
Should this be int?
Minor: you can cache the whole operatorChain and dispose of the operatorChain
@sebing can we remove this blank line?
please check if this is done with a stream, and if so, throw an exception.
Better: append this unconditionally, and only append the other part based on the condition.
The braces are really not needed.
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
shouldn't this be done in the fluxCompleted callback?
I think you meant Function.identity()?
minor: this should be at the top of the method above.
I think the builder is null and status is optional. If so, do we really need it?
You should use assertNull(...) (or assertTrue()), so it is more readable when reading the code).
Optional: Should we be able to use anyMatch() here instead of isFactory == null?
I think catch Exception would be better here.
This whole if can be simplified to: private ImmutableWorkerInfo getClusterTopology(String dataSourceWorkers) { if (StringUtils.isNotEmpty(subString)) { return workerSelector.apply(ImmutableMap.of( "hostname", worker worker)); } else { return workerSelector; } }
This logic should be moved to the email command. I know that it's the only way to get "WildFlySasl" is not a Boolean, but we should use it here.
Same for other places suggestion for (int value : numDocs) {
Could you avoid duplicating the 'if' body to avoid code duplication?
shouldn't an "else" be enough here?
What happens if the file is not found? I would skip this code, but just get rid of the download file.
Could we put this into a synchronized method?
s/createPolygon()/createMultiPolygon()
TdcQueryAuthResource.startApplication(getApplicationName, "Domain service name is not available."); If you're not doing this, you can probably replace it with a constant
Shouldn't this be moved after the loadAuthorizedClient() call?
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(subject.result(),...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); }
Minor: there is a bug in the isValid check. Can't we throw here? If it is empty, better to throw an IllegalArgumentException in the else case.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
You know we don't have LK 2.0 why don't we use these local variables in BaseClearingStateSummary?
"this." can be removed too.
It's better to use getType() instead of 'this' for 'this'.
I don't think that we should use treeViewer.refresh() at this point.
Runtime
Won't it be possible to use the real option which runs in a dry-run mode? If so, it might still be able to put more than just the waiting logic afterwards.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
this is not used for this test. It will break if we change the initialization of the NetworkCapabilitiesManager to not change the networks identification to this network.
Is this constant?
I would recommend using.get() on the following code: java server.takeRequest(TraceHttpHeaders.class, Tracer::getSpanId);
No, I'm not sure I like the toString implementation.
Unnecessary parentheses
let's merge this with the previous one
This makes it kind of confusing to read. It's not straightforward to pass a new MyConfigBuilder() into the config class. Please consider renaming this to something like "CREATE_MODE_config" or "reportConfigBuilder".
Is this if necessary?
Can you extract the key for this to a constant?
Can you please add a method in getName().filter(infrastructureEntry -> instance.getManagingContainer()!= null) that will be called before the first iteration and while the second one will be sufficient I believe.
I'm getting a runtime exception here. Why is the runtime exception to be caught here when we call.get()?
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
Why have you removed the other examples in the same file, I don't think you need to use an API like this?
rename to launch
why would this method be called if RestServiceErrorCode is true?
Please put in a separate method or rename this support method accordingly
Should we use ITree instead of global for loop, or even better to have a more readable name?
Shown on the UI so should be i18n aware.
This could be a while loop.
Change to "normal"
Why not directly call a canDeleteInstance(input)?
Do we need to check getGroupById(groupId, pos) here? If so, you can remove getGroupById(..) here and call getGroupById(groupId)
Ok, I know you didn't like this earlier, but do you think a lot of things like this here?
No big deal but error message should be _at the end_
Here too I think it would be easier to implement this by simply doing: S.compareTo(timestamp, newLeast) || oldLeast) + more than(old*(old*(old*.), note there is a reason for it, but still have the same issue with the same key
we should check mMediaUpoadHandler!= null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
'else if' is redundant here.
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
this (and below) should be enough to compare the featureId here.
IIRC anonymous users will crash here because they have no user account to get the prefs from.
nit: add final (or a variable)
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
Do you think it makes sense to create a new RuntimeException, this code is too low?
Please remove this
In general, we should avoid throwing IgniteException with specific message.
we should use the String, not a String.
flow => flowPath
Regarding TODO, I think you should only call removeView on the result.
I don't understand this, given you're checking if the DatastreamMetadataConstants has a value, I believe this should be changed to handle DatastreamMetadataConstants.S_409_MS instead of returning false here.
I believe this should be.booleanValue() not!= null
You can use assertEquals(endpointName, releaseStage);
nit: can we use assertInException here? assertTrue(a, b)
"Start trainning sub process"
Can you please clarify why it is needed? I don't see it if OTHER_TYPE is correct.
replace this with: if (this.numBits() == BulkOutput.GET) { xmlOutputBuilder.append(XmlOutputBuilder.class, BulkOutput.GET); }
so you can have it in a constant for this class, at least to use it instead of having multiple entries at the same place.
Does this block need to be logged out?
This ducks up a bit. This service is not supposed to be called every time I read, can you make it a field?
Use { } even for one line if/else bodies.
How about extracting the first random page.getHost().bySlugOf(res.head()) to a variable?
It is possible to define a new ArrayList and reuse it here.
Do we need this? The config in configurePipeline() and this.configuration.isTcpMatcher() may be replaced with a name like: java TcpMatcher<CatResult> UdpDataSerializer = new TcpMatcher(config);
Typo?
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
Can you add if (getNode().getComponentType()!= null) to make code more readable?
remove is a bit unnecessary.
I would add retries to lines 106-108 to consolidate and running so that in a separate thread can be reused for any other ResponseHandler objects.
nit: I think these operations should be separate from the thrift table data manager, and the Manager would need to be initialized as a in the Cache manager, since they'll be the same for all helixManager entries. The start() method, advanceByTableName() could be called after the thrift call.
can we also return true?
We don't need the snapshotVersion here. The snapshotVersion is marked as optional.
instanceof GeometryType
Does it make sense to have a Set<String> tag = Collections.singleton(tag); if(tags == null){ Set<String> tags = new HashSet<>(); tags.add(tag); } return tags;
You can use [StandardCharsets.UTF_8.UTF_8](<LINK_0>
What do you think about other so that you do and a asserts in this case?
Nice.
In the case of medias previously set the defaultLang value, this can be null. Suggest replacing the "defaultLang" string with a non-null value.
nit: Can we use a different name for this?
this is needed. Won't it be a valid fix for this in Ecore's go well with the previous version?
Couldn't we just throw the exception here instead of returning null? Personally I prefer the use of Optional in the first place (in the second review of the patch), I think it's fine to keep the first line of the method.
getDrawable() can return null. It will be better to check whether it returns null and throw an IllegalStateException.
log the sleep duration maybe? and maybe remove the exception?
Why Unnecessary this?
This only checks the id of the event type, maybe also verify randomUUID().
[\/\ ]
You can just use the redundant "direction" and "open" terminology.
It feels like this is almost the same as the first two lines... could you break everything here?
Shouldn't this be: quarks = request!= null? fullState.getQuark() : quarks; and fLastRequest = request.getQuarks();?
How does the position() method use the same logic?
Same question
Which asserts are there for cluster listener?
I don't think this should be configString.length() 0 (the default value is true for'region', not US_EAST_1 than null)
Why is this hardcoded to 4 threads? Should there be an option to control this?
I'm not sure if {metrics-style.md} is the first line of the test. Could you show it to the test too?
n.equals(na.get().getId())
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
This can be small D double
Can you explain why the error handler is null here?
checkNotNull
s/Started/Starting
Unecessary.
Why do we want to return here? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fListenersByPartId.get(listenerPartId)
Is the intention to reset state here?
Shall we use the constant NAME_USER_KEY instead of the name here?
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I think!( operation instanceof CatalogFunction || operation instanceof CatalogFunction) || operation instanceof RemoveCatalogFunctionOperation
I like the idea of doing the same thing but it seems like it would be better to have each subclass as an interface and have only one method with the interface.
Would it be a good idea to make this check cleaner?
we don't need to set it here
Better use!StringUtils.isEmpty()
this.layoutAlgorithm is never null in the constructor
Should this be "Could not find any Subject Id" or check for extensionIdFromSubject?
lets log this as well
This method looks a little weird to me. You could just use a normal file name here.
assertFalse(...);
Is it correct to compare with GTK4?
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
I would rather copy the requested value from the current pull, i.e. we can always cast to a new request.
I think it would be more clear to remove the SWT.MouseUp here. They aren't normally sent when you click on the mouse when clicking on the mouse.
![MINOR](<LINK_1> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_0>](<LINK_2>
close streams
I know this is not change, but as we are doing this it, it may be better to make the inMemoryQueueSize final and have inMemoryQueueSize return true at the end.
Could you elaborate why this logic is necessary? It seems like it could be simplified to: java.peek(interval).forEach(interval -> { if (taskMaster.get(interval).equals(interval)) { task.remove(); } } or even java.util.Comparator.naturalOrder());
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
please rename to fieldsRead<?>>
Suggest you move the zip == null to a local variable in order to avoid duplication and to the catch clause
You forgot parent class name and it also must be aliased name
why won't this be package private?
This seems to be missing a space after the )
logger?
Catching exception is not necessary here.
Why are you using a Queue here? And then by extension a LinkedList?
Why have you removed the variable?
before this change, the condition should be here should be in the if, because is the 'continue' status and the else is a redundant check
Does this need to be wrapped in a test?
Style-nit: Space after if.
remove the entire stream() line
In what situations are we throwing an exception here?
Please rename these config variables to just type
This block only compares AttributeAccessItemDtoList and methodAccessItemDtoList. It should compare them to the corresponding indexes of the methodAccessItemDtoList.
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
same issue
nit: rename to location
Shouldn't we be moving the elevator while we're moving the clamp?
Nit: maybe we could just say a return type here (instead of returning a null)
If the user starts an empty notification, shouldn't we be using a normal path?
avoid increasing visibility?!
we can run into tests for the conditions? java if (testData.students()!= ) { if(testData.feedbackQuestions.size() < numStudents.size() && testData.students.size() < numStudents.size() && numStudents.size() < numStudents.size()) { } else { addQuestions(numStudents); }
I have Srtreamline hard coded in my PR too. I thought it would not be used elsewhere. But can you add it as a constant? And I will change my code to use that constant.
should only do if (hsuke.length > 0) return; here, and also check whether the class loader rewrite the cache to see if it's already cached, if not, do that in the constructor.
Minor: Please add whitespace before the final argument.
the added bricks can be removed from the config.
Did you intend to use two java assertj assertions here? <LINK_0>
This should be: 1. we have a server that was not built in 2. create a map of extensions that are not present 3. create a _token-value and use it here 4. pull the realm into a constant (don't use it here)
4.2
You could do pdfHeaderFormat with null
Please refactor to different methods
These should still be removed.
This is an error. Should "Applying" not be handled?
datums and parameter names are not used.
extra space
This property name seems a little misleading because it is used in the test.
Instead of having two method createSimpleLabels(List<String> matchedLabels, Optional<String> matchedLabels, Optional<String> matchedLabels) { return createLabels(label -> {StringUtil.isEmpty(label); }));
also need to handle case where insertionArt == null
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getName(), parameters)).append(" ").append(column.getType());
Shouldn't it be negotiate?
should we add a log message here so that we can see the admin admin has been started?
Doesn't seem to be a need for a segmentConsistentHash?
Is there a use case where we can use the assert?
Looks like it might have left an existing debugging code, if we ignore it. (In for the case that it would have to be already existing)
can be simplified to just mock the storageDomainValidator.
space before "?
Wrap in a new method called "canMigrate" or something.
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
could you add another case with a more readable name? e.g. assertTrue(parentTxUri.isStillAliveAlive.LOGIN_CONCURRENT.__BACK__SIE_IN_PROGRESS)
Can you just declare this as throws Throwables.propagate(e); so that we don't have to handle the exception?
can we make this more explicit and log the exception.
Should this be a constant?
Consider using "minutes" in order to match most of the time.
You could use this code to create a new Translation
can you write this as new ArrayList<>(partitionMap.values()); and keep the order of policies?
Please remove these empty lines.
sounds nice! so users are not overwhelmed with hints. Shall we also add a change log entry for both this and schema hints?
use a StringBuilder and not a String.
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithUnsemble. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
[optional] Why doesn't it be checked that the workflowAction is not null?
Very small nit: I think we can move this line to the caller of the method to make the code more readable.
> "Token is successfully returned from ADALError" the exception should be named as a constant.
static
Add a message
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Use Collections.emptyList()
@cvrebert can we move this up?
we need to sleep(1000) here. can we make this test sequence more deterministic rather than depending on time, to reduce flakiness?
Can be checked on Collection.equals()
Please use acp here.
Extract method: if (element instanceof Attributes.isRemoveChanges()) { impactSort.add(removeAction); } else { impactSort.add(removeAction); }
Is this handling for waiver? Maybe CustomConstants then assign it to a Style then.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
This isn't clear to me. Suppose the text was changed to be a text: "tabs".
I don't like that you are using.get() here because.get() may return null if the file doesn't exist. I suggest to do a check before the return in the end.
Why this change?
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
Remove these redundant logging changes.
I think it is better to return an empty collection instead of null.
Check if this test of relation is also in BlImpl part. If not, move it there.
I would add a method in marshalledEntry class that uses Instant.now(). It would be good to have a library that supports anonymous classes that supports most of the time.
I would prefer more explicit message (it could add the osgiVersion to the message) to the exception.
I think it is better to re-throw the Throwable. I have a chance to prevent this from happening due to a symptom of a problem. For example, Exception is thrown, then it could hide the problem.
You should not modify the cache xml. Instead, you should only modify the cache xml if the file name is not present and get it out.
shouldn't we remove the pvk.getArg("?") check?
Why are we throwing this exception instead of Exception?
I'd expect the AggregationOutput type to be from a parameter (the return type) to find it sounds like the correct API is to find the type in the enum.
@vmaletta use List<String>
Can you put the new isShareable() && isNewDisk() == getNewDiskId(), incase getDiskDescription()
Can you use already-defined constants for the following three strings?
Just a consistency: Would it make sense to use TimeUnit.SECONDS.sleep(...)?
If you use this function, its good to read it
relevant non-logging code change here
I would prefer to have log on manager role.
If we're changing this to an index from field to fields we shouldn't be copying the existing fields from the index, but we shouldn't make it the default here.
The if/else branch look redundant.
Not sure on this one - isn't the capacity important?
supplyAsync
variable is not needed.
Since this block is repeated in above, shall we move it to a separate private method?
What about assertEquals(SolverInstance.SolverStatus.DEFAULT_CLIENT_ID, solverInstance.getStatus());?
final
This check should be moved down to the method below to check whether the parser version matches the pattern.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
Add a message to 'factory'. Also, it is a weird error message
I'd suggest extracting all this into a single function called "calculateFormat" and use it in all text and label.
The exception should be caught by the property.
Probably want to extract a static string for each thread access.
this whole if statement can be replaced with.trim().split(" *", 2)
ditto :)
you don't need to define this.
You can simplify this a bit by using List<GlusterStatus> status = new ArrayList<>(map.getStatus()); if (StringUtils.isNotEmpty(status) && GlusterStatus.UNKNOWN) { // TODO: check Gluster status of host: '{}' returned empty object
This may be OK in this circumstance, but there's a restriction on what can be passed to Proxy.forName(...) method. Is there any chance this restriction will be violated in this code as a surprise?
Is there a reason we dont require this to be a PlainBuffer constructor?
I think that name of inspecting private element should be part of response, decode and put into FeignException as a user passed in, and also read from that value, and no need to parse it
I am unsure about the FileOutputStream here, as we use it in finally block
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
Isn't the user's state being set?
Minor thing: "referer!= null"
can this use increment util?
use new names?
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
It should not be that the wait is >, it is the scheduled configuration if it is not the "http" url.
if (log.client.reloadIfRequired(parameter)) { connectionName = connectionName; }
please throw exception
Could this never be null?
Curious why we should have 2 separate threads for this one, and also one of them?
you just put in the try block below, you don't need both logic
final?
multiple return statements can be merged into one
We could add the.baseTypeToContentTypeStrategyResolver field here
nit: just simplify to throws Exception
why are we ignoring user?
This should be CFMap.get(bytes)
There is a few other places in this file that use "makes" as well.
Why this get deleted? Your code depends on this function? Your code depends on this function?
ping
Why not do this?
else throw exception?
There are other places in this file that use kWorker.getTask().getHost(), which access K would result in a lot of duplicated code. It seems like it might be worth having it be factored out into a private method that takes a task and gets the metrics from a config.
Looks like the overflow isn't possible for the overflow to finish (xl  yl  zl)) or  yl.
This should be args.length - 1 || args.length == args.length
It's not your fault, but 'could be 'queueType' is null/empty, and not throw exception.
I think this is a good example of what the new rool is - we should just throw an exception like: java PRIVILEGE_NO_REQUEST = "The handle is invalid"); The same goes for the new line.
Is this check necessary?
Debug code?
You can use the IDE generated function here instead of the IDE, e.g. java return Futures.immediateFuture(response);
after calling setAttachments, there is no need to set the local variable to null,
should the condition be "dedicatedRow" here?
Need to change line 92.
Should this be a static final _really_ not part of the public API?
If this vector is constant, it would be a good idea to create only one instance of this vector on class instantiation.
These two checks are redundant, only the "poison pill" can be by itself in a chunk, and only it can have a start time of -1 (right?). You can keep only one of them.
remove
if we fail here we have a stale VM version in hand. we should roleback
Please revert this change
I think this can be reduced to: while (inStream == null) { return null; }
Yes, we shouldn't send the channel to the Request.
This method may return an ArrayList instead of a List.
This path string is the same as the one in DashboardResource. Therefore it should be _plugin_ instead of _existing_ project.
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
Would be nice to use a variable for this
Inline method
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
Can't you use containsKey()?
nit: just use the declared header()
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
Could you please wrap this block with a try/finally?
Should we include the "not" in the message?
Typo in the name of the method.
Is there a reason why you are catching Exception instead of a Thread?
getCause() instanceof SocketTimeoutException and has different cause in which. I think we should consider something more generic: if (throwable instanceof uulException) { throw new RuntimeException(e.getCause().getCause().getCause().getCause().getCause().getCause().getCause() instanceof uulException) }
Shouldn't this be: if (HttpURLConnection.HTTP.403!= 500) {?
dilutions should be non-null and non-default to the user
What is wrong with file.getAbsolutePath()?
minor: I am not sure if we should be setting commonStats to zero. In this case we should be able to convert from lowerStats to lowerStats.
Check args?
Why not use a [Formatter](<LINK_0>, instead of the string concatenation?
This should be after the println
Could this be merged with what we have from line 85?
So this would break ties us into those interfaces. Is this really your fault? Should we fix the test to show the other things we are working on?
I would drop the Exception
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
you can use an exception message instead of the last parameter.
I suggest to make this a class variable, and use it in the new test cases. For example, this could be changed to: private IThreadLevel stackFrameVariables(ILevel stackFrameName, ILevel stackFrameName, IStack stackFrame) { // inline all this method calls. }
.toString() is not what we want here. Probably an error message should include the Search query.
Should this be against OADMIN.
is it possible to find one state from Operator?
I think you can remove this exception.
Is this the same as the default?
The same as above. Shouldn't we also consider adding a helper for this? java private Object[] argsNull; public Object[] args(Object proxy, Object args) { if ( args.length == 0) { return null; } setCalled(false, args); } else { throw new setNull(method.getName()); } }
I think the underlying problem is that we copy and paste _could_ make it clearer.
it would be good to return the And contain indexOf('/') instead of calling it twice
Since the fragment's used only once, and do the switch to the new intent.
Should this call to AsyncQueryParameters.validate(..) instead?
boolean includeTextDetails = true; and send that value in the call below.
Use Java 8's isNullOrEmpty() method.
Why is this required?
I think we should mention this logic in _generate_Table_COLUMN_TEXT_LENGTH constant.
Any idea why you can't do a different message for both get and get from the account?
Can we consider Arrays.equals(a1, b2) in this condition?
Missing space after,
Inline
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Could you please log the transaction ID here, instead of the entire transaction?
Is this the main purpose?
I don't think we need the 0 check here. I'd prefer to use a Set<SegmentedDataContainer> and a new DataContainer() to make sure the segmentedDataContainer is valid or not.
could make this check be done in int and use Math.min()
Same here with not needing the local variable.
Should this be public?
Would you mind removing the parenthesis for the || (a && b) {?
I have the feeling this should be a nuroDCProp since it is not optional.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Nitpick: might be better to use constants for these.
This seems unnecessary. What advantage is there here versus before? Both guarantee the order is respected.
can use logging and throw exception. Also, the log message could be more useful.
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
We can use the constants from ReplicaInfo.java
This is just debug line. I think we need to wrap the exception in an IOException since this is the one that we expect to happen.
is it possible to not return "null" (and isSubstringFoundOrderedInString).
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
I would rename these to something like storageTypeStatsList or something along those lines since they're just testing the type of the map
I think it would be better to do it in the join() method, in case there is an exception. The calling code will not get optimized for nanoseconds and advance for each partition.
Same as above, try to simplify this by adding a little local variable.
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
Change to a single check in the if-statement below.
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
[minor] This can be simplified - if (timePartitioning!= null) {
I see this was for a reason but didn't we support the year year available? why are we saving the acquire of a release here?
Isn't it better to call getLogger()?
What is the benefit of using the complete indentation for the if/else?
We should use awaitility for the test instead of sleeping.
I would suggest to use a constant string, this is the default value of our strings.xml file
only the try-catch
The field name should be the job name.
Is this in the model? Seems like we're editing a model and not just the model.
this function can be declared in the qualifyingSet private utility method to remove the necessary code from the previous test.
space between if and (
Again, if you "delete" the Item as a key, you should be able to delete the item before your changes.
Just stuff all this logic in "get" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getMarketingUpdate);
This seems to be a bit brittle. I think the following might be more readable: 1. Extract a method (key, value) to a variable. 2. Call method is a boolean isDeterministic() which is set internally. If we need it, then we could use a result of checkForDeterministicAndRerunTestQueries().
Here and below: Please, remove curly brackets for one-line statement after if
Second parameter of Status is the pluginId. Why to pass path here?
Why do we need this condition?
let's change the order in the ctor - its clearer when the source is before the dest :)
Use Map<String, String>
Nit: Just use Collections.singletonList() instead.
shouldn't we add an assertion here that the activeOrder is not null?
May we detail the logger message a lit like > error in getting flow trigger <PojrectName_FlowName> in Quartz,
Suspicious that the reference is the only place where the reference is I used to get it and I find it confusing to suddenly have the name of the reference.
Is no use case bound the only case may cause camera inactive?
nit: Could always use Ints.saturatedCast(numBytesWritten )
Why do you need this? Can't you just do: taskCount.equals(jobCoordinatorFactory.getPassthroughJobCoordinator())
Any reason why you make these public?
:bug: code style
I think the app should be getPubmedIdsBySection first, and then you can just call the other method from that in the adapter
why is this change needed?
Maybe I'm missing something here. In the sirius-common it makes sense to move this to s.isIsoModel() and use it.
.process ->autoStartDataDir.
Consider logging the update stack trace and the problem could be displayed more information, e.g. "Invalid resource : healthy"
ConfigSource member is usually populated with @Nullable.
return super.getObservableValue(feature);
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Do we need to check if it's a url (name or something similar)?
This should be 'this.clear()' not in the method.
Shouldn't we also register the addActionAction here?
use ConcurrentUtils.withLock()
this is not required
You could use a foreach loop of the entries to obtain the desired data
It seems like a good candidate for an explicit method getAuthorizationGrantType() to reduce the amount of nested calls.
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
This potentially long-running code seem to be doing more than once. The change in the previous version of the code is fine, but it's not really easy to read.
What about this log?
"future" is not defined in ChunkInitializer, please add an update here.
What does "exit" mean here?
Can use lambda syntax.
not sure whether this should be done in a finally block.
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
This is more efficiently stored as: java if (isDelegateScoped &&!isNormalScope(ij.isNormalScope(ij.getUpgrade())) {
You could keep this declaration as the last statement, and remove the switch/case.
some checks that need to be done before calling getTestSample.getTestSample.
The same is in this method below.
See above about "run_untagged"
A comma?
For null values, we just do not supply those properties in the autoGenerationOption
Also include the values here?
isError()
While I agree that this is more of a configuration error, I think we should have a warning instead of DEBUG. Otherwise, the stack trace will not be printed.
Please fix the formatting.
Arguments should be switched.
I believe this should be logged at debug level and not info.
Instead of this, why not just get rid of the negation?
I think we should verify that this method is actually called when the queue is CLOSED (ie throw exception)
Stylistic point: you can probably inline this variable, and add to the if statement below.
suggestion p.run().setText(";", p.getId().get());
We probably want a condition check here, since we're now using a loop with a single element (or maybe there)
suggestion assertThat(filter.beforeRequestMessage).startsWith(AbstractRequestLoggingFilter.DEFAULT_MESSAGE_PREFIX);
Currently you are using MemberNotExistsException, if member is not TRUE -
I think this should be an int. And it shouldn't be assigned to a double.
I think this is the same as is done for FileSinkCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommittableCommit
final
"/"?
Would it make sense to move this setting into 8192 and then use a constant in the class?
Append assignnvyDir. It is not that important change
Just use getOrDefault? int physicalSlotId = slotMapping.get(mSlotId); if (physicalSlotId!= null) { // for loop }
This is fine, but what does the code mean? You should probably check for empty strings too.
can we chain this with a class variable
Isn't it a bit hardcore for a mere selection of a random host for the pool and keep the close of the db thing? I thought we do not follow the use of db record that was disrups. This is one thing I am not sure which is what we want. I don't think we should be swallowing this silently.
category
shouldn't need the throws declaration?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
@jam01 Can you add another one here?
I wonder if this should be in the callback bus. If we use the handler to do this, we may be able to move this out of the callback bus. As soon as we can see the element is visible, the view is now always being visible, so the user can't submit the action to it. Anyway, in the future we could do this in the widget widget just once on the button and then use the else statement to do the logic.
you can remove this
null!= manager
is this the same as for restart?
Is there a reason for that?
Can this be converted to a simple loop?
else if (value.getMin()!= null) {
NIT: use equals instead of!=
Don't use FileAlreadyExists implementation.
Do we need this stack trace to be printed or should it just fail?
Please don't remove this. Just add a log.error to the exception.
you could use model.isASD()
final?
this, too?
We don't need to throw RuntimeException.
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the Follow-up logic in the other progress dialogs.
Same here, try to avoid using method calls.
suggestion if (path.equals("")) {
Maybe refactor these to a method like hasData offsets or just use one of them.
I think the following is more correct: assertEquals(actual, expected, expected);
should it be at the beginning of the method, not the template string?
Does this mean if we are adding a workflow there, we need to be able to reuse the current "AttributeName" tag in the event.
make final
There is a better way to make this: TextUtils.isEmpty(getResources().getColor(R.color.setTextColor(getResources().getColor(R.color.internal.base.String)) instead.
moodManager(1|2) should be final fields of the class.
Should this not be assertFalse since the Scheduler.getPidFile() calls this which every time a file is created?
Hm, interesting way to check for a special case of suspect here. And it is not right to reach return code path of the exception. I would prefer: java if (suLevel.equals(field) || "y".equals(field) && isUniqueIndexColumn(suspec)) { return null; }
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
logic would be simpler to instantiate the collection as KPathArgument, and then do a KPaths.add() in the else branch of each for loop.
Could we assert the case of the key and value?
Can we short circuit here as well and return early instead of having to compute offsets?
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
no need for this change now
Please add {}.
mBanner = null is probably not used with mBanner and no need to log it.
please use Matchers.is
@porth thinking what is the use case where the thread is empty which means we will have some tasks running after the 'empty' task was started prior to calling.addTaskAndWakeup(this); which does the same thing.
You don't need to call taskScheduler() in the test. I understand it being duplicated in the other test, but that could be extracted to a separate method.
s/left/right/g
And the two the other two cases can be merged into one.
Does it have to be the same reference or an isomorphic type?
Please handle it the null case.
Please make this more descriptive.
I don't think we need this map. Why can't we just do a BoundedRestoreSnapshot() call and restoreTables() directly?
Can we please mock the Future?
We should remove the new line after the if.
We are no longer calling programs. I think its great to use only one thing during a call!
Might want to ignore the exception? Was that intentional?
Nitpicking: Using entrySet might be clearer.
This can be moved outside the while loop.
Since we are using a constant for this, I think we should have the same check as "async".
Setting the style isn't needed for this component as this is the default already.
shouldn't this be a period?
You should also lazily initialize the exclusion list when exclusion is not provided, as it will slightly improve performance when calling the rule on multiple files during analysis.
Use of this.getClass().getCanonicalName() instead.
Hey, please move this whole block down into its own method so the body of the if can be actually removed.
In the previous version, the variable "LimitsSnapshot" does not match the expected output.
I would prefer to have a local variable for remoteGetConsistentHash(), like isRemotely(ctx, command). thenCompose(hasFlag(ctx, command))
ObjectMapper can be reused here too
args.putArg(flagSplit[0], flagSplit[0]));
This should be handled right before this PR and have the user_type be in the resource itself instead of here. Otherwise it's hard to parse the whole app and not depending on the user_type
Can you make these 5 seconds a constant like the other timeouts?
null check?
suggestion vertx.onSuccess(testThread);
Is this the main issue that these streams are running on the right thread?
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
Let's remove this string
0 is the default value for an int field. We do not make assignments to default values in constructors.
Move this to a @Before method and use it here.
I think this is the wrong place for this patch. It seems like this method should be static
don't we need to re-throw the exception?
Maybe we could use a Redis pipe here as well.
Should use instanceof instead of isEmpty()
I'd prefer to have a name that would help here. You can find a way to override the duplicate key.
I think that there is no reason for this logging. This allows for anything in the app to get the file and then be removed. As in the code, I would suggest just making sure there is no way to find out what type was actually sent.
We should use the isEmpty method instead of checking null.
I think it's better to put the IT setup in the finally block.
Use the constants in Secret.properties? Otherwise we loose the compiler info to tell the difference between credentialsId and (or a @Nonnull) and the only reason for the properties...
Is this line removed by mistake?
domainList is no longer used, can we just use domainList here?
This variable should be changed.
<LINK_0>
What makes this variable name different?
Is this needed? You already have a RevCommit that does ObjectId if you want to match, but you could use a different RevCommit instead.
Why do we need to throw an exception here?
this is not called in test.
You can use Collections.builder()
please set a modifier - protected seem suitable
I'd use something like: "MOBS: " + x,..."
cleanup this temp dir afterwards
rename to fileName
Couple of things here: (a) we can use Preconditions.checkArgument here? ERO, this returns a boolean to indicate whether the shape has all shapes, not just eroResult.
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
Just pass in the error message for the exception
This is a bit confusing. I guess we can neither call MigrationException or something with that name.
nit: since it is possible that the partition is not being fetched and then capacity is less than 0, then you can skip the loop at L55 of the more than just getting the partition from page.
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
why final variable? :-)
unnecessary new line
This check should only be done if the input is an instance of the same object, no need to check if it's immutable.
We should not cancel local partition we should set the priority here.
Just a suggestion, we could update the method name here.
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
try/catch
s/hasLastRow/isLastRowDescription/
Style-nit: We don't use curly braces around single line blocks.
I think that this is not needed, @korthout
can this be the default function name?
This should also have some way to read this from the UI. The is not them on the UI.
suggestion logger.warn("Could not add {} with the same uid. " + element.getClass().getName());
@cvrebert let's inline this variable.
nit: Flux.just
This looks like a very strange way to encode the service definition file in a parameter. Could we extract it in a method?
Is this potentially slow? Can't we pass rowSize as a parameter?
Some left overs..? :)
This is a good idea to have it in a test method, we can simplify this code by removing this new method
We could use else if here.
deadlocked_monitor would be more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between these two metrics.
Should be cachedBlock.
Don't like this, check isContent before trying to read content, and this is always the most intuitive.
Should be "ogc".
This should be getClass().getSimpleName() instead of getClass().getSimpleName()
Consider using the word "Unable to save item for type".
I think settingsObject can't be null here since asList returns a non-null value.
This is a refresh issue. The icon is not set when the reference is a particular element and the reference is not a DWRF one.
This line is repeated in AgentService and MRService. Is it intentional?
SegmentLoadingException is specifically checked for in a few places that treat it differently from a generic runtime exception. Please keep it.
That's especially the way the check is implemented now. Here is a lot more complex logic like this: java String request = request.getAttribute("Location"); try { return HandlerContext.getAttribute(HandlerContext.ERROR_ATTRIBUTE_REQUEST_ATTRIBUTE); } catch (IOException e) { logger.error("Couldn't generate a response body"); }
ditto constructor
Magic constant? Should be close in a finally block
could you do these messages in the right facing messages?
Would be better if the mapping logic was done as: model.setEnum(entity.getId(), null, entity); It would work, but it would be more consistent with the rest of the code, and avoid the need for the backend tests.
The return code?
I don't know why we need this method to return just an empty string. This is what we do in other places, so why are null?
Can we remove all these stream calls?
again IBM-specific i would go with "IBM specific"
I guess this should be a switch-case?
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond( Quaterniond);
You called setMustExist(true) twice here. At least one of those is unnecessary.
This line should be moved before the if
The role strings are returned by CuFPConstants. Are there some special reason we don't want to support that?
We should check this to see the system in the "only" format.
<LINK_0>
What if we change this behaviour? Is it intended?
getDrawable is deprecated and may be called by the ContextCompat.getDrawable(context, mDisabledIconResid, mDisabledIconResid, true);
It is not needed since you are already calling executeMethod.
If the goal is to use our own nonNull method, then you can use [this](<LINK_0>.
please use getAuthzName() instead of dbUser.getAuthzName()
I don't know if this can happen but we might want to log it here since we can do it on other places.
Should use host_uuid/name here.
It seems like we're making a code that is then used in a couple places. What does it look like this: java if (status.isOK()) { // do the same thing as in the old code } How does it sound?
This was probably ill see that you're using StringUtils.isBlank here and below.
I don't think we need this annotation for the first annotation annotation, and we can keep the second one for the iterable. We can add it to the list of annotationAnnotations, which would avoid the double annotation annotation per annotation cast.
please use Map<String, GlusterStatus>
An alternative would be to either do this or remove the overload if it was already there? (I know it was like this in the original code, but I think it's quite odd that we can set the value to 0 in the constructor.)
Is it sufficient not to compare getId() because TrackInfo#equals already considers mId? (ditto for others)
I think it's better to throw an exception if the visit is not null.
Not sure if this is a good cleanup, but you need to be sure that a job is still deleted after the created project.
Why is the intent changed here? Isn't the wildcards wildcards already doing type1?
nit: can remove final.
Formatting.
@bdragan this class expects a total number of lines to be duplicated.
Can you move it down with if (LOG.isDebugEnabled()) { LOG.error(id, e); } block?
why not use subsystemWriter.writeContent() here?
I'm not sure if we need to close close the connection in a finally block?
Please add a get() method
@maria-farooq Hmm, this line should be removed. The remove is in this particular place for the code, right?
I would use the same approach as for compare(): compare().contains(bibFile)
1. Consider moving this piece of code to the parent toggleGhost 2. should consider also 'enabled'
I don't think we need to wrap the exception in it.
Unnecessary?
System.out?
I think we don't need to check if the variable is null. This should be using the ServerVariable.fromNullable(io.getVariable())
Probably, there is something wrong with idenations.
I believe this should be true?
Same here about the use of the null check below
sysout?
Consider using the [style](<LINK_0> api here to make it work
you must use "final". XXX appears to have been doing the same thing
use INJECTOR_ANNOTATION_GINJECTOR_ANNOTATION
I would recommend to simplify this test to two more specific: one onedDate(one.one)one
You should call onNext before the channel is called by the outside of the try.
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no point in having this type of method in all the DAOs.
Not sure about this. The same logic is in two places.
can we make this string a constant?
I can see there's a system.out here. Is it really necessary to use logging?
This is unlikely (and very similar places), a constant object is used here.
i'd rephrase to warn
It's better to use LOGIN_SEARCH_CAPABILITY instead of hardcoding the string value.
For other exceptions, can we have a test that handles the case of lockId == null? null : lock.get(lockId.getLockName());
Can we check on a resourceProfile being null?
Pull this uri logic out into a separate method and then call it from these methods
nit: to make this clearer
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
should we assert that this value will never be positive?
Looks like this will fail if the refset is not encoded?
It seems to me that this was wrong for the getMaxLength() call. Is it a copy of the result to an Integer?
Replace this with: if (!user.getCallingUser(userId)) { keys.add(user); }
You need to pass result._source instead of just result as a profile content.
if we are outside of the loop, then there is no need to re-check the state of the temp directory...
Same: static import for consistency.
you are passing 'true' to 'exitStatus' in case of FAILED as well.
please use no element in the list
Can you also check what the code is doing in transaction.delete below?
I guess this could be moved to a separate method
Shouldn't we at least log this error?
You can fix this.
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters.putAll(parameters); }
Instead of passing the exception to this method, we should validate the cleaned object. (Same for other objects.)
Can you move this if statement outside?
Shouldn't be Elasticsearch.Index(filtersToQuery)?
try to exploit map and co for this method
It was left from debugging. I'd remove it
Right, we can avoid doing Set.of and use another Collection.
We should not print the stack trace. Callers should close it, they can use any kind of resource than the error.
Please add the permission needed => "Requires 'Administer' permission on the specified project"
I think that you should also check that the first change is the actual commit.
What is the purpose of this loop?
commandName is declared here. I think I'd prefer to keep this constant (and the command name).
Is it possible to convert to a String and then back to a byte array? I think that changes might be required for the new code to avoid the duplication.
While the Contiguous test is doing something wrong with the commit of command and parameter, we could use [this](<LINK_0>
What about TimeUnit.SECONDS.toMillis(uptime)
Interesting, so this one is unlike the edit page eh? I'd align them (at this point, whatever way you prefer).
You could use the AbstractParameterizedType annotation to get a provided group for the label.
This clause is redundant.
Why is only a remote lock now? I know right now we don't actually need local unlock commands because we only use them for remote lock.
What happens if there is a repository named the -Dpath? Is it better to use FSPathUtils.getMapping(resRelPath)?
Can you log.warning(" found: ", idsList); instead of logging?
probably want to suggestion logGenotypeLikelihoods = allele1 + nGeno2 + 1
'else' would be clearer here: if (Objects.equals(attribute.getName())) {'
should it be internationalized like others buttons?
I'm still confused why this. Why are we visiting this and returning the value in this method?
Again, move this line to the finally block of the if statement above.
Why are we comparing with the name of the topic?
Why is this necessary? Couldn't we write the test w/o it and then directly fail if shutDownCluster is being called?
I think this should be debug
any reason to not do this? Set<StoreKey> opens unrelated data model term should be updated?
Is this line safe? I don't think it's necessary since it's part of the if (v.length == 0) check below, but I think this is fine.
Nitpick: the same thing around final.
This is no longer needed if we remove the 'this' item?
Could we just check if the data source isRoot.isPresent()?
maybe you can instead use logger.debug("Found updated template file {}", e.getMessage());?
I wonder if this test should be better to go with the TemporaryReply interface.
[minor] Better to use regex instead of compile here?
I am not sure why the behavior is 'alwayslink' here. The 'ics' will have no 'attribute' in the same format. The problem is that occasionally we add a library to the rule set before passing it.
Aren't you just supposed to remove the deprecated annotation and not change the method code? Because it was already delegating to the the DefaultComparator anyways, i think this deprecation was invalid
Could we move survey.getSurveyByModule(survey.getSurveyByModule()) before check if the survey is in the cache?
Typo in a method name
Can you refactor this to be able to reuse the same format code?
1. Please mention that it may be null if the column is not found, and if so, print it to the table not be null
We should probably move the initInternal() call into the sTargetInitialized.
nit: make it final
Here you are setting up the true and not setting the true again, so it should be set in the presenter
I think it would be a bit cleaner to put this line after the try/catch block, so we have a chance to add the exception to the log statement.
Why e?
why do we need to log the exception?
s/non-null/empty/
Oh, so the number of retries actually includes the first try as well.
Is this aLocatedBlock task? I don't see how busy does it.
I'd use an anonymous class that looks better than a constant to describe what's happening here
extract a variable
This line is too long: @ScalarFunction @Description("Calculates the great-circle distance between two points on the Earth's surface") @Nullable double calculateDistance(Math.sin(doc, "toRadians)"))
Please remove as this is related to the fix required in #6610
assertThat(statistics).hasOnlyKeys("keyB")
The whole expression should have changed to { }.
Not sure worth changing a deprecated class.
OPEN_PET_FOOD_FACTS_FOOD
don't need both this. Assert.notNull() lines
Changed to be true?
Context context = new SimpleResponse<>( options);
The layout could be passed in the constructor.
This log message makes no sense, if the user goes wrong here. I would move it to the log line.
I think we could use DCPanel.DEFAULT_INPUT_EVENT_RENAME here
You can use params.readInt() here.
See below, the requirement should always be Status.
Should it be >= and not <=?
I would change this to WARNING. instead of Exception.EMPTY (just for now)
Again, the id is not "owningCommunity" here. These variables (in this method) and this error should be renamed to say something like "parentCommunity" instead.
Same here, this line is too long
It looks like this condition is already replaced by!models.isEmpty()
This will only work for sacrificeances support.
Please make this static constant
does it mean we should remove one of them?
This needs a unit test for "null"
I am wondering if we can use File.createTempFile("ogr", ext) and write a unique entry in the constructor
what happens when an exception is returned and the session's status is not updated? Can you update the session status with UNKNOWN/something equivalent and log this error instead?
ERROR->NOT_FOUND.
Although not introduced by this PR, this method is completely hot at all.
can we throw an exception if the key is not a bucket?
just wondering... maybe we should do some permissions only on the profile, and not on the other nodes, so not sure why we care about the order and not for rules like for (Map<User, authzName) {... }
This block is going to be executed for every pull, so we shouldn't have to run our own event.
I don't think this is good. If there are multiple versions of this.
It's good to have tests for whether the subscription is actually created or not
extract this block to a method: boolean isRinging(call) { if (call == null) { return; } hangup(); }
Is there a reason to keep the error message from the "Failed to delete"?
s/with/getStart//
Why a test in impl instead of asserting that the creator is never null?
Can you log the path?
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this:... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); }... }.... import com.facebook.annotations.DoNotOptimize; @DoNotOptimize private static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace =... } } }
Should it be a warning?
nit: can we make this a little clearer
Remove the variable
you could use the file.getProjectRelativePath().compareTo(o1.status()) here
Put ITEM in front of OTHER_FUNCTION.
There is no.show() in this file.
Maybe a space here, and below?
How about adding a log statement at the beginning of this method and throwing InvalidParameterValueException?
You can just use bufferMessages.add(message)
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind staff is held in any of the two hands, you can use isItem(...) for this.
You can use the isComparisonChain here.
Unnecessary System.sleep()
A minor grammar error is in the description: output should not display any of the options.
We can use a lambda here?
(not related to this PR): filterArg?
%n should be used.
I see that it is just a change from BigDecimal to BigInteger. The fact that the trades is is bigger and bigger than the big. Why not use the double value instead of the trades.getFeeCurrency() itself?
Slightly confused by the implementation. Is the hash code not the same?
Can we check that the result is not null?
The refreshToken method can be changed to protected.
Is this the same as the testing for the exception?
what is the difference between this call and the other async client?
Instead of calling isBlank above, you should use instanceof here as well.
For consistency with the other config classes "fnot" -> "result" is unsatisfied. I also think that null would be a bit more clear than "".
This line doesn't do anything.
Seems like you can have a class cast exception.
Tabs vs.
We usually use a try-with-resources construct here instead of closing the server as a field.
can import static
Can you fix the typo in endByte == 0?
nit: remove extra whitespace
Shouldn't this assert that networkInterfaceCardProperties networkInterfaceCardProperties is initially called?
I wonder why this has to be here.
Nit: This code looks good, but could we extract a method and also reuse in both?
Before this change, the line is no longer necessary.
this should be: if (!symbolStatistics.getFixedSize() || sourceRowsCount / partitionCount / partitionCount) { // TODO: to avoid this.setAverageRowSize(totalRowCount); }
this will not work as expected.
Not sure if I am wrong, but I think it would be better to change the message to: "expected true, sql fail" and "insert into R5" respectively.
After checking the current, calling <LINK_0>, then calling InjectableBehaviourObjectStore.resetAlterTableModifier, should we call the same method?
Shouldn't this error be "Try over partials in memory, which does not match what's happening?
The empty builder is probably unnecessary.
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
style nit: missing space after 'if'
in this case you need to 'hasCpuPinning' to be 'false' which is not 'null'.
Typo in "delete"
I think it would be better to keep the tests in place where they were constructed and removed.
Just to be safe, I had a check when no break is needed, we are the last continue when the next dispatcher is null.
@vmaletta assertEquals will be more elegant
Are these potentially Strings being caught?
Let's put requireNonNull around this.
lookup in the multimap here
Don't need this, use entrySet()
"Successfully wrote header to file".
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
@Suseika hm.. looks like code duplication to me. how about this: if (this.users.containsKey(pwd)) { } else { }
you could collapse this two lines to: KoreUtil.addKoreUtil(tag); ### for a few lines above
not sure why we need this. Why not just call this from the OperationController?
shall we have try-with-resource?
sysout?
change this to Utils.deleteApplicationFiles
This makes me think that there is some redundancy between the two parses for the same unpackString. Can you use ByteBuffer.encode(key, offset,'source','source'); when unpackString is not null?
Perhaps we want to use the argument more than one argument, which is more readable.
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in sync? Shouldn't we always test both tables for those values then?
map is the same as the map. However, you may want to replace listFiles() with a null check.
Proper English wording would be cleaner?
assertEquals(excpected, actual)
I wonder if we can have separate CheckpointRecordSupplier#writeCheckpointStorageLocation. This may be called by multiple checkpoints while being in the same container.
The logic should be simplified here. We are creating a new List of the options provided by a single method.
There is no need to create a ListItemAction manually now. Can we look into the method more?
how do you handle "BEGIN" here?
Asserting the actual text and the other one be the safer length
Why did we rename optionsPath to unsubscribeDataChanges()?
Same remark as for registration
You can update test1 to 1 since we moved it to javadoc. This is similar to other tests.
I think we should return a blank profile, and not a default.
Please convert these tabs to spaces
Map instead of concrete type
Love it!
please use Cluster#hasGateway
Couldn't we just use eventsQueue.map(eventsQueue::get) instead of.ifPresent?
Any reason for not using session?
use "+" instead of +
I don't understand why " " Is" String concept of "type" is a property-string style (e.g. "file-scheduler". The name of the definition of the component is the same as the element-type-context _context_. So, maybe "payload-delay" or something similar?
Since this branch is pushed down into the PR, I think it makes sense to change the condition round trip to the precondition. Because there is no way to know if the request is present, it is explicitly bound to the segment before the request.
or at the least use a logger?
I don't think this is needed. User can be converted to a Dao class, which means that this new SecuredUser will be used.
You can remove the null check and use the StringUtil.notNull() below.
I think we can revert this change.
Use the array as loopvar, so the += operator will be needed
break?
typo: should be Capitalised
I would use setCommitIdGenerationMode() here to avoid the trailing "true".
need to go into "assertEquals"?
I think going through this approach will actually hit an additional lock. In the case that is already completed, it's probably better to do something like: if (sends instanceof MockSelector &&!sends.isEmpty()) { return; } Throwable t = (NetworkSend) server; if (sends == MockSelector.DisconnectOnPoll) { return; }
you can use.equals instead of ==
You cannot rely on list of attribute names, because of method getName() and.getAttributeValue() from it.
replace with Contentlet contentlet = new ContentletDataGen().nextPersisted();
We shouldn't put this in a request-only block. The client can just set a response, so this is better than put a request saztired value.
We already have getGroupSeenQueryFactory() method which already checks if GroupSeen -> IFeature. We need to be able to use that.
400 errors are Bad Request errors which are usually populated as IllegalArgumentException errors.
Nit: wrap above two lines in { }
What if this is empty?
Any reason to initialize to a separate field, instead of checking the state here? olf is already initialized with "true".
Is retries checked in the loop?
Same as above: could use the list directly to avoid the intermediate list.
This should be IllegalArgumentException
It's good practice to make this configurable and have the default value specified in the constructor
nit: could be assertTrue(bp.get())
This can be static
Shouldn't these be defined in the activity_level constants?
Braces
yes I don't think this is correct.
LOG.info("JDBC connection string is not in the Keycloak connection string is present in the Agreement_FILE_SINK_SERVER_REREREMAINS_SERVER_CONNECTION_RERECASE_SERVER_ERROR");
I would prefer to use forEach, I am not sure how this is fast enough.
why not log it?
can do this without if (e.getMessage().contains("404 Not Found) && e.getMessage().contains("ServerInfo"))
We don't need this if else if we set the lastMeasuredTimestamp in the constructor
Since you are using a builder, you can drop the extra parameter.
I'd change variable name "someProperty1" to "someValue1" or "someProperty2". It will still be better to use constants in the test.
Perhaps this block should be moved to the if block above the only place it is used.
It seems like this logic is also also used in calculateSpaceSecond()
Do we need this variable here? It seems like it's not used anywhere else but this could be shortened to something like: java var worldpayOrderResponse = worldpayOrderStatusResponse.getRefundId(); if (worldpayOrderResponse.getCharge().isPresent()) { return Optional.ofNullable(responsepayOrderResponse.getCharge().getStatus(), response.getCharge().getStatus()); } return Optional.ofNullable(responsepayOrderResponse.getCharge().getStatus(), response.getCharge().getStatus());
shouldn't it be getVm()
The equals implementation should include attributes from the hash.
Minor: you can just use Files.delete here.
callback.remaining() == 0?
I think it should be meter. The name must match the metric name in the MeterMetaDataProcessor.
Why not package private?
when ch is null?
Why don't you re-throw UnknownIndexException here?
What about the message of the change?
@orhan89 This could be reduced to log.warn("Failed to login entity id after login: {}", ex);
Is this a 400 or is it a 500?
use the returned list here
Might be worth moving these values to constants
This is the first unit test. Is it possible to do: java assertEquals(expected, actualUrls.size());
why the change to NIOServerCnxnFactory is using a JDK backend for new API.
Can expectedValues be a for-each?
ImmutableMap.of(
Here we need to set the item to the original item. And then check that this item is not there
Avoid attempting to set the status to null, which may cause a lot of error, and allow the user to get a member, set it to null, and then catch it.
I'm not sure how I missed this. We need to be careful about next time. It says previousData.add(rowData); but it does not give us a full 'previous'. We usually get rid of the new positions on the key set.
@ivandalbosco Why not using the loop of checkIssueIssue(String relativePath, String message) here?
It doesn't matter, but we gain this if around.
I think we should not use the iterator directly.
I think you need to rewind the copyBuf reader's index, otherwise it might only print the part of the buffer that's unread.
Why use a constant to be consistent with other listeners?
I would add some check here: * if (patternSuper!= null) { AttributeReferenceMatch match = SimpleName; return null; } * rename 'this' to 'else if'
suggestion webSession.getToken().getToken(),
Is there a guarantee that the result path is an HDFS path?
I think this should be recursive.
Maybe you can add the true.
Can you please add className to error message?
This is awkward as a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
use.substring(0, socket.getRetryCount()) after removing newline, put the cleaned up before and after that, so we can verify the cleaned up before we start the client
Please follow the formatting used on lines 98, 100 places here. Braces are missing on spaces before the final keyword.
getMessage in the log instead of throwing.
: you could use assertSame(firstIssue.syntaxNode(), PyFunctionDef.class)
If we can simplify this, we can be more precise.
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).get(i));
core data should not be part of the data model
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Move the lambda into a private method for readability?
1. The column type is not included in hasher. 2. We don't support all other cases when it's not included in either.
rename to type
I think it'd be clearer if you create an abstract method and call it "setBind".
s/Man,/gradlew spotlessApply -- I'm pretty certain that this call is missing a tab symbol here
can you add a default requestHandlers!= null.
Shouldn't it be one_UTC?
pls. use String.format("String", f) instead of concatenation
This should be updated to use Cohort.getMemberships(). You have to load a membership and get the patient id to the PatientID
Why add empty string?
Check if urlPath is null, so that the file isn't deleted, the log message is misleading. The other way around can be centralised to this class
I think we should throw RuntimeException here to make it clearer.
I think this is the wrong way to fill the source by one argument of MVObject. The result should be the minimum value.
you must begin all in if already authenticated so you do nothing....
combine line 1593 and 1594
Should this be a uint16?
One thing here is that because we're using WaitUntil, it would be pretty dangerous to reset the dialog to the user. I would prefer to leave the code here.
use Variables.getDefault().nextInt(10) instead of 5
Shouldn't this be wrapped in a try/catch instead?
insert space before.
There is a null check before deleting resource.
Can we not letting the exception here?
Hmm, I didn't see the below code in this line.
For readability. Same for other checks suggestion Preconditions.checkState(arguments.contains(column), "The primary key column must exist in %s should not contain the destination column '%s'", transformFunction, column);
s/in/in/
this try-with-resources is not needed.
We're casting the whole suri to a MessageBubbleDrawable, perhaps it would be better to store the BubbleDrawable, and use it here and in the related function.
Braces
I think it would be better to move this inside the synchronized block.
rename to occurrence
Shouldn't we use here something like this: final CanvasElement canvasHandler = canvasHandler.getDomainObjectUUID(); if (canvasHandler.getDefinition() instanceof DomainObject) { canvasHandler.getContent(); } else { canvasHandler.getContent(); }
I think we can initialize flum result in the try block. It will be more readable if there is a condition in this method.
Please refactor this assertion to something like: assertThat(a, is(not(a)).isNotEmpty();
@martin I think we can move it to ProxySelectorUtils
need space after if
Hm, should it be _public static final String _ in constructor if it doesn't have a reference to the locale?
please use asGuid() instead of Guid.createGuid(vm.getId()) as it will format the message, for example: <vm_policy> <name>. i.e.: Guid.createDiskId(volume.getId())
I would inline this variable.
This should be a Set<Statement>, no need to add it here.
Do we need the fully qualified name here?
I think it should be trace
I don't like this multiple times. What about just: java final List<String> authenticationTokenAuthenticationConverter = new AADOAuth2AuthenticatedPrincipal(); assertEquals(principals.get("tid", iss)); final List<String> allDimensions = Arrays.asList(principals);
Nitpick: vertex.getNumEdges() can be replaced with vertex.getSuperstep()
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource(shardUuid, Optional.ofNullable(shardDeltaMap.get(shardUuid)), deltaFileContext::getShardUuid)).map(shardUuid -> createPageSource(session, hiveFileContext, transactionId, columnTypes, Optional.empty(), T delta, attributes, transactionId, columnTypes); Same for the below one.
I'm not a fan of the api calls to Lists.newArrayList(), could you just use the diamond operator?
Should assert that elemSize <= 0.
one more :-)
Is there a reason not to extract this variable?
These two could potentially go into the filter, so that this reads more closely, and the next call would result in a germplasmAncestry/etc. I think it's common to move these to a private method, such as gidgreed.
Same as above for the unused variable.
What do you think of this? For the client, we don't need to create a slicer, do we need to ensure the cleanup?
Need to test that the value matches and setSetting are _explicit_ by_ user.
If we make a new one, we may need to pass a builder and return the actual one.
I'd prefer to avoid the nested ifs: if (conditionContexts.isEmpty()) { builder.createQuery((new Context(ctx)); } else { builder.add( fieldContexts ); }
Could you replace this with log?
I think this one needs to be unsigned
can you just append operationTimeMs?
Is this test doing anything? I think it should be a failed test case.
Typo: Open_64_BIT_HEADER
Minor: move this check to a method.
The "id" parameter seems to be used elsewhere, is it really needed or can we have a helper for this?
It seems to me that selection and evaluation can be done outside of the for loop.decision block would return the result of the evaluationCache. In that case, you have to synchronize the whole method: evaluationCache.put(evaluationABSTAIN, null, null); and then evaluationCache(splitPattern, null);. If you do this then you can use ExpressionUtils.LOABSTAIN = null;
Typo: request
I think that if the authentication is invalid, it should be replaced with.split("="
I think we have to be careful about the referenced entity over and over here.
Unnecessary parentheses
This seems like a costly operation, same to do the selection in the if case, could be moved into the getIndex-based execution strategy?
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we have such a test with 2 nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
This will be a simple loop, and a simple while loop.
this.
You can return the actual type DTO type.
should we make this "if (condition) {" not "return true" rather than "true" again?
Builder builder = new Builder(); builder.setThumbnail(desc.getThumbnail(), builder.getCanonicalUri()); builder.setChapter is deprecated.
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
I guess for this to be the type of the try-with-resources, it's cleaner.
Optional<SolShip> instead?
warn maybe?
Shouldn't this be done in a for loop? suggestion List<Label> lightweightAPI = apiList.getAllLabelsWithoutID();
It seems this method is statically used and can be replaced with a one-liner?
Do you need to call it first?
I'd put this in a loop, but it does look a little better: java final Logger log = tsLogger.get(typeToClass(type, _typeToClass(type));
should change this to scriptContent.replaceBindingKeys(scriptContent, scriptContent, scriptContent, scriptContent)?
Probably simpler to use a CACHE_NAME variable for the last element.
Is it an overhead to calculate sizeInBytes() for every call?
you can initialize it in the declaration.
I think these System.out.println should be removed.
Again, the indexes should be calculated outside of the while loops.
Ditto.collect()
i haven't looked at all the edge cases, but can buffer.length - 1? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
don't we just want to do this?
The arguments are unused now right?
This should be removed from the config
It think it'd better to have singleton GSON instance in static field
suggestion } else if (public void reformat) {
It would be much easier to follow if we could take File.getAbsolutePath() as a path instead of a File.
Should we log a warning?
do we need this?
I don't think this needs to be a concurrent map, but seems to be a bit brittle. It shouldn't be in there, since we already have the specifics of the state.
I am not sure why we should call getString instead of display.
Why are we swallowing all exceptions here?
But then, the code in the stats are also in the wrong place, since if something goes wrong with the task name change, then it would be better to say "volume (db).media("m.com.android.R.string.MediaScannerService").
These strings need to be externalized
What's the difference between getInterface vs getInterface?
Please revert the change for the rest of the PR
I'm not sure this is it's going to work well, since you just moved all the other calls to mavenProxyRepository.removeFromRemoteIfExists method above?
<LINK_0>
This could use the same variable for more than one-time initialization.
I guess this should be CFG_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION.put("javax.persistence.internal.service.internal.jta.service.Plugin.service.PluginEnvironmentEnvironment", "org.hibernate.service.internal.util.GWC". It will be the same and sufficient to use the system property below.
Since we will return a StatusUtils.createErrorProxy(ActionType.COMPLETE, ASYNC_CONSTRAINT)
should we also consider the above if (whiteListContexts == null) check as well?
Don't introduce redundant braces
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them?
I wonder if it's useful to have the StreamListenerResult interface with a similar name as the method: StreamListenerResultAdapters.add(new BeanFactoryUtils(this.channelListenerResultAdapters.values()), but not here.
Why not just include the directory in the message?
Should this be collapsed to a single if block?
The same RuntimeException on STDERR
condense to a boolean return value. If you wouldn't need this fall-through anyway, you could use a boolean on all the PCL bindings
You can use context.getDependentCapabilityRequirement() here so you don't need to check for null.
This test is not sufficient
What does this change do?
If you move this line up above the loop, then you don't need to initialize parameters in the loop.
Collections.emptyMap() could be used here
Use logger please.
Is this debugging output necessary?
Please re-use the variable.
I recommend using DictionaryBlock constructor. This is compact code.
You can check only if we see if it is working on the SWTBotTreeItem.getNode (i.e. extends VAMFile)
Could you add the check of at least dateFormat?
log.tracef
I'm not sure how this relates to artifacts as content. Could you you please rewrite it with clearly defined minColumnId? It is easier to read.
No, this method should not throw interrupted exceptions.
Can you explain what is the reason behind this?
I would prefer to throw an exception here instead of swallowing it. In fact I think it's better to stop the thread and do the caller to handle it (See console debugging data that is long enough).
Why is this not also EntityTypeFilter?
Extract "valueOf" to a variable, like "Payload"
Small remark: please keep the exception as the cause of the exception. Then we can use this: model.call(this);
This could just be a public static final
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a little safer.
You certainly meant "myCache".
It is like a hack. Probably reset() would be a better choice.
Could use <> for the comparison
Extract 500L to a variable.
Add a new method for this so it will be easier to read/understand.
You will need to add new DefaultTree(0) if you rename it as new DefaultTree(0)
remove finally {
can we use.isEmpty() instead of.equals?
In JUnit, [Test](<LINK_0> is System.out.println(... is it required?
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce this method number of lines from 24 to at most 20 to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
Use FileUtils.listFiles here as well?
You removed the refreshIsoListFromVDSM methods now, but if you already did it in the ctor, why do we need it here?
Arg may not always have a shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
can we use constants for the JSON_TOKEN and SYNC_TOKEN_NUMBER?
This would probably work well if you add new images to JSONHelper.optJSONObject() and convert to string. The method itself may return null.
Why not call this with paramsList.forEach()?
This line needs a colon, to make it "case new ItemStack(Material.STONE, item, " + Material.STICK), new ItemStack(ci, b)
You may also want to test something for the state of the response and see the contents of the list. Could you have a test for this?
this if clause should be in network, since you use it.
you don't need that line, verifyTitleUrl is already checking that. See point1
I think we can use the constant from <LINK_0>
Missing braces
The return value of waitForWriteRequest() is not thread-safe, so I think this test could be simplified by making the test thread-safe.
We don't need this condition and again use an empty list.
why was this removed?
Can/should this be a set?
use start()
Why did the result of getBounds for the 2048?
style nit: missing braces
Leftover debug statement?
rename to action
please log in error
suggestion InputStream inputStream = classLoader.getLinkedHashMap(KEY);
I think we should just set the filters inside buildSortBuilder
this could be done in a static way (we only need the deep branched)
.first(Audience.class) ->.getImmutableSet().of("No null"))
This will break compatibility with previous versions (which just throws an exception) and there is no need to declare it
I believe the question is getting deleted right?
onCreate() is called one time on start. It means the database connection is open. But the database connection is open. Is this on purpose?
Wouldn't this be a separate preference? I personally dislike autocompletion, but I do want (same-level) auto indent (i.e. pressing enter preserves the indentation of the previous line, it should not increase indentation after a { for me).
Why is this wrapped in an exception? You would need to modify it to use the multicastResult.
please remove this change
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can _read_ both versions - but write only in the latest version.
Do we need to keep these separate tests as they are testing?
We also have to adjust'refresh' messages from the UI'refresh' method.
Why is this necessary?
I meant to write something like: String tid = ts.get(sId); if (null!=!= tid) { ts.remove(event); }
wouldn't it be more readable to do this in a foreach loop instead, and then do a single forEach after the conversion if it's null?
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/shard/:shard
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
You can check the ColumnType.PROPERTY_PATH here.
Call confirmActivity.getCard().getAppLanguageCodes().size() instead of checking it again.
The following code snippet is the same: java if (connection!= null) { handleNewConnection(newConnection); }
This just change the existing code.
How about a test where it fails if no barcode files are found? How about a test if not all the tiles were found? My apologies if they are already there.
1000000000 becomes a constant...
isn't it possible we have two options here?
Nitpick: Would be good to separate the exception onto different lines.
Why do you catch any InterruptedException here? Current message reminds me that this means the lock won't be released on the State.
Can we reuse "isNotEmpty"
suggestion Deadline.fromNow(Duration.ofSeconds(10), 5L);
static import
this is now outside of the if (isImagesAlreadyOnTarget()) scope. is it on purpose?
IMHO null-safe string could be provided.
I don't know how this Build class is instantiated. Can you leave as it is, please?
Why an existing PendingConfirm that would be used?
Does it really make sense to use a stream here? Or should it be a HTTP 400?
Should be equals
This exception makes no sense to the caller and it will always be false. If you are just sanity checking, throw an AssertionError.
I just realized that these checks should be applied to all link classes.
Shouldn't we log the note too?
Should this be a checked exception?
shouldn't this be DeepLinkManager?
isn't the default 2?
..() returns -1. I don't think it's necessary to wrap the ("+totalCount" into a string since it's typically an exception, not a big deal.
No need for this variable, just assert the actual container's memory size (this is probably just for testing)
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a delete. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
Shouldn't we use final here?
This should be in the same commit as in the test
can we use the member get() here instead of the commandType?
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen");
it seems like this should be config.storeLocalStore()
lastChunk.buf.length() == 0 is not a reliable check since buffers can have position > 0 and yet have no data because position == limit. Also, what happens if there are zero sized buffers in the middle? I think it should be fine - but a test would be useful (if not already there)
autobixing?
Do we really want to confirm every time we send the event?
nit: extra space after }
List<String> tagValue = Arrays.asList(tagName.get(tag.get(0));
Can we make the rest of the code more readable? I don't think the t.close() is required.
This seems a little weird. Why are you setting the index to null?
As far as I understand this one is not required
why are you using instanceof here? could you use the interface instead of just the object?
This code is the same as the original logic of the equivalence. Is it possible to get a null value on the superclass?
is there a reason you're moving the message body to close()?
Could you add a logger?
We can't use an enum to check null value here, as it is a default value and should be null.
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :)
:ant: I think you meant this.
nit: seems like this is just a copy&pasted from 401
try-with-resources for better readability
Instead of returning a String, it may be better to define a variable for the entire element (i.e., instanceof String)
@asikkola This compiler complains about this new code. I think here you need to format the code and the compiler wont do the same.
This fails and so the other confidence won't be updated. And if the file was repeated confidence, then the rename would be confidence as a parameter, perhaps it's worth creating a separate confidence with the same name?
For consistency with the rest of the code (non-static) it should be like the one that takes in a collection and takes value as arguments. This however would require some refactoring to be done in the future, which looks like we are making use of the form "*." and "json" like: SchedulableEntityInstanceResultResultResultResultResultResultResultResultResultResultResultResultResult which can be used by the user in the future. This would also allow for user to specify in their own database and user friendly information.
It's possible to propagate the InterruptedException here instead of swallowing it.
This code is basically resource-level, right? Could we consider re-wording this to be a little more explicit?
Extract into a variable for the timeout?
Do we know why we are throwing a checked exception here?
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to be reused in the testFindLiveVersionFile test and also to leave the test shorter and cleaner
Does the segment need to be updated?
Null check needed here. This suggests that articleVersion is not Null, but we just want to see this in the future.
Do we need to catch exceptions here? For example, if someone specifies a config problem, it will look like a warn log or warn indicating that the workflow will not be created? For example, will it be considered a "Error occurred while trying to remove the {} successfully"
I think it should be e.get()
No permissions needed to make the test pass.
I find this confusing. Why not just use monitor.getWorkWidth() here?
Can you please rename this one to something like response body and the following one?
Can we assert on the ANY_STAGE_ANY_STAGE_NAME?
Should it be substitutions?
Let's discuss how to do it in this case.
Just shorter: patternsDir.isDirectory();
This looks like it would create a StringBuilder for each line.
This try-catch has the same behavior as in SessionManager.getSessions(). I guess it is the same as in the setUp method above.
Exception is not logged or thrown
I wonder if we should keep the original logic here. Let's have the text at the end of input.
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=add) and then let the request have its metrics?
Not sure this is worth it. There are a couple of other places I'd like to have a leading "/" here.
In the previous version of this method, "gr_id" is not named "grId". Maybe we should rename the old method "getExplicitNulls" to "Field"?
Use a variable for the title, like File[] modFile = new File[j.core.plugin.getName();
Please use "0000". Also use the org.apache.commons.lang3.builder.I18n.
The actual problem is that if statement.hasMaximum() && stringStatistics.hasMinimum()) { return false; }
should this throw the exception to allow the user to set the message?
L82-L84 can be removed.
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures. Would be nice to avoid using it.
This line can be simplified to if (outputs_isEmpty) { output.getChunkId()!= NotebookDocQueue.CHUNK_EXEC_FINISHED) { output.setPopupPosition(event.getChunkId()); } else { output.setPopupPosition(event.getChunkId()!= NotebookDocQueue.CHUNK_EXEC_FINISHED); }
unrelated bug fix?
add message to exception
I would divide this method into 3 methods. One for final aggregation, one for partial and one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity.
Maybe IOException is enough to indicate a problem that an IOException is thrown?
> What about the rest of the tests to do with schema change without any query's db'? > Is it a concrete implementation?
We should be more descriptive here. Let's log the exception
why not just use NIOServerCnxnFactory.this as the default constructor for this class
Maybe this can directly call valueHashList.set(nodePointers.getPositionCount(), new GroupStatus(long)) and then set the value to null
Would be nice to explain why we are trying to remove this, and in which case the operand is null.
Are the logic changed from and to Guava?
condition could be inversed and in fact the for each can be applied no matter what, if empty, this is a noop. Thus, no need to collect.
No need to call Integer.parseInt(getUuid()) more than once.
you cannot loop only one time on the full entryset?
This code block is duplicated within the test, it can be extracted to a separate method.
This can be moved to a guard clause.
Change this to with tab?
While you're here, you could use the introduced method instead, which does the NPE.
If you refactor this condition to keep the EOF check, like you do in.isInterpreted()?
As I think it should be trim, then the value 2 lines below are unnecessary.
I'd prefer to have each request in a different order than what you're trying to achieve.
You could extract the three lines of SSH configuration in a dedicated private method (in case we need to add more config for exmaple).
@vmaletta Variable name should be singular
I'd suggest to remove this log message as it duplicates the ones in the 'UpdateService'.
better assert that the list is sorted
What about: java if (fulltext!= null && fulltext.startsWith(fulltext)) {
Is there a reason you can't change the test to fail("Skip test for HSQL " + ps + " on this table?");
Shouldn't these two lines be a method that takes the id lock and id?
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about ownedPartitions 2) even if it does, it will not know about updates (such as metadata/subscription change, missed rebalance) while the ConsumerCoordinator's subscriptions.assignedPartitions is always up to date. To address 1), I think it is reasonable to assume/force a **Cooperative** assignor to have some knowledge of ownedPartitions especially since we are ok to assume it will be able to handle the "adjust assignment" logic. And regarding 2), we could actually just pass along the current assignment to the PartitionAssignor prior, or as a separate PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting ownedPartitions in ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer misses a rebalance. It's partitions get assigned to another consumer but there's so much state to restore it doesn't get very far before the first consumer manages to rejoin. The first consumer's state is up to date while the second consumer is very far behind, but only the second consumer will join with a non-empty ownedPartitions so it is more likely to get the partitions again. (this scenario requires a more advanced assignment strategy than we currently employ, but even the current sticky assignor leverages this information to improve stickiness where possible) @guozhangwang @hachikuji
It's recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
I have a concern here, we introduced WorkbenchDockEntry as a complex version (or even better), because we have a plugin: WorkbenchDockEntryCreator, and I introduced WorkbenchDockEntry.createPermissions
Since this is the only place you need to check for anonymous versions.
I think these should be complete
Init
I believe this is wrong, because if someone use the java.io.File this ends up in an IOException, there is no space after the!, so there should be no space before the closing brace. Same for the other lines below.
A lot of small changes to my mind would be to have a clear way to signal that this is the user-friendly message. Can you not pass the actual message in the file name like is to avoid a clear message?
I think you should add a constant for "assignmentToMenu" to the menu.properties. It would be good to avoid the StructuredResult and also know that the menu is actually visible, but it has to be debugged and it's probably not a good idea to use the resource type, I think we should use a resource string instead of a top-level "_menu". It would be best to add the menu items to the PopupMenuAdapter class.
We could probably just do return typeAnnotation.class.equals(typeAnnotation)
I'm afraid this will fail to fix the OS by default. The point of talend is that when the system default supports it, but by default it will be better to fix all OS in the data (i.e. it should be total)
@rishabh-997 I think the existing code is easier to understand in the flow and follows the logic of the earlier of this method
Sorry, but it is hard to distinguish between test coverage of the case where these tests run. Is this the case?
This variable is redundant here
You can use assertEquals(TestRegexMountPoint regex, "user/hadoop-user/hadoop-user/src/test/java/org/eclipse/pras/core/username/matcher/name.txt").
Extract constants
you could do here itself if(closeProfilingStatsModel)
Why is this a breaking change?
Can we chain the two lines together, so that we don't have to do the other bits?
1. Does this work if it is adding this same account? 2. I think in this change it does not work on the workspace machine, it is just about to be able to create the workspace by name. To be sure if it is the same before, I find it more readable to create a method to put it in.getDevfile().
I think we need to remove the version=\"1.0\"
Can we remove the variable responseBlock1.getNumBlockwiseStatus() to request block2?
you should call into.trim() on files
I'd suggest creating a map of exceptions for the sheet and needing to handle the sheet.
You should not need to check for null: String defaulttemperature = true;
Is the check needed in the first place?
Same. Could add the exception to the logger.
Why propagate the error?
Can you change the assertion message to something like sourceInfo.getWatermarkType().toString()?
Is the second call needed anywhere? so it should just be the case not extracted
In the rare case that the row time is calculated but for whatever reason, we shouldn't get out of doing the subtraction every time.
We don't declare executor in the class. That needs to be re-thrown as part of the es.get() API.
Could you please extract the nullToEmpty call to a separate nullToEmpty method?
You're better off using a switch expression instead of comparing the string directly? I also wonder if it makes sense to use the constant directly here instead of comparing the string directly?
This might be better as a separate method called refreshUrl(List<RefreshToken> tokens)
II think this code was also inherited but it seems a bit weird.
I think you should use a method boolean isPatient(Repository)
let's move this conditional to the declaration
Maybe we should use this. Since this is not working for big reasons I would also use StringUtils.join with.map
All this could use min == 0 instead of min() == 0 I would say that min is more than 100.
Please use org.assertj.core.util.Lists#stream instead.
Do we need to assert that the message is the same as inOrder?
Typo in method name
maybe while statement here make code more readable?
This method may be able to be used here too, e.g. as below: bind( s.a.b.c.d. bindingProvisioners) { //NON-NLS-1 }
you don't need the check for null here. Tasks.getRunAt(numMissingInstances.size() - 1) does this check internally
Is the loop necessary? Why not use a StringBuilder and use the key pair
Can we just do a post() here, and not keep track of whether it's needed?
As discussed, the method should return a List<String> instead.
should be in a finally block, otherwise we will get to the "resources" block?
Can we make this a member so it doesn't have to be concrete class?
Seems like you could do a couple of lines here? URI configuredURI = darkServiceName.get(key); URI configuredRequest = darkServiceName.get(darkServiceName).toString(); URI configuredRequest = originalRequest.get(darkServiceName).toString();
Have you considered using ++i here?
Does this work? We are creating a new serializee, and the get is a fully qualified name.
why synchronized?
Here is another case where we can make the totalSeconds < 100 and > 100 < 256?
We should test if the file is not found in the resource set if the file exists but the resource set is not found. If the tree is empty, this mapping will fail. See also the'repResource'.
shorter, more complete and more readable (IMHO): ipEntry e = new ipEntry(relativePath.replace(File.FINE, (), '/'));
Please use try-with-resources statement for the outputStream object to avoid possible resources leaks.
This block is repeated above, get the default value of the fields that we expect as a fields. It should be fields of the enum and not the name of the field, or even the name of the field should be an enum.
I think the realm needs to be a string - not a string
If we pattern to be consistent, I think we should also add a log message here.
This copy and paste error messages into 3 lines would be good for readability.
Why not just assert if there is only one question between 'date' and 'uploaded'?
Move to debug
For the survey we have to delete, is that it necessary to delete?
reorder
If we can't go directly to the framework directly, we should be able to use the <LINK_0> here.
The expression'return getItems()' is sufficient here
Log consumer has a check for "Committed" prior to calling commit. Probably unnecessary if you prefer here.
this does not look like it is being tested in the parallel. I think this test is missing an assert (doing on sub windows)
I'd prefer to use getHostName() to ease correlation with other issues and logs
Nit: the style guide would ensure the correct spacing between if and (.
Why did you rename this to something like "waitTill"?
(you actually could _not_ have GitHub) - can this query be "(without ", ")?
We need to have the two assertions, please use the "assertEquals" syntax.
please remove
and there are no vms, why can't the gateway end user will be able to create vm disks?
using log template is preferred
What if isIdentifier is false?
Missing method header.
Use??
this can never happen now, can it (assuming you are checking for bytesWritten < size).
can we use host instead of replicating, right?
should probably be named m
Remove the else and the condition after the if?
Typo in variable name s/child/icon/in/
can we use a const for this?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
is it possible that localUpdates.isEmpty() is called twice?
The app is closed in onCreate(). We should also add it as a field
Is it possible to use a human-readable name for the topology?
does it make sense to drop the brackets?
Again, we should move the notebook object to the beginning, and notebook map to the notebook map.
Missing Assert.fail(..)?
If value is null and value is not in user argument, do we need to check it?
To be consistent, use.then() in all code below.
why do we need it - we get the Down event...
I don't think you need to worry about the case you're describing. MSD makes the assumption that the root path already exists.
StringBuilder
assert return value
ImportRewrite to remove declaration.
Catching Throwable is probably better than just catching it and re-throwing it.
Another way to do this (if you don't use TreeSets)
The cast can be removed, onResume() is called twice.
It might be more helpful to include the spec name in the error message here.
Since the only tab list is active here, the name should be set as true.
Type is not a number so the expected value can be removed.
You may want to use ObjectUtils for this null check.
This is a little clunky to me. It might be better to explicitly close the data if the protocol is in the Parcel or even if the if condition is true.
Won't this fail if there are other caches that are using?
"consider changing the plugin filename"
suggestion filterCLabel.setBasicBar(true);
I'm not sure how this should work, but the system property name reminds me that this should be set to the user instead of the save/reacquire it. That would mean that the result of the system is logged, and I'm not sure how to notify "this" is managed by the environment.
assertEquals(excpected, actual)
Think @sandeepSamudrala mentioned in the another pull request. Should be protected if all types are defined as public.
What about creating a constant for this line?
is calling removeClientListener thread safe?
fix formatting
result will be null. add a blank line before if.
Please use a distinctMark
Does this need to be final?
I think this is dependent on org.eclipse.e4.core.java.io.PluginModule.java: java ClassLoader parent = child.getClass().getClassLoader(); try {... } catch (IOException e) { logger.error("Error occurred while trying to extract plugin " + artifact.getArtifactId()); e.getMessage(); } catch (IOException e) { logger.error("Error occurred while trying to extract plugin " + artifact.getClass().getName()); Exceptions.propagateIfFatal(e); log.error(e); } }
If the fs is not set, should this be hdfs-site.xml?
I think we should avoid this type casting (let's say List<T> toYielder( Yielder<T>, T> accumulator)
Is it worth BigDecimal part to use writeInt()?
nit: I think we should start the new term within condition to make code more readable.
zoneDate.DATE_FORMAT = Utils.DATE_FORMAT(dateFilter.getPreferredoneId());
IOException is never thrown in this method
use isNotBlank method
This line is not good. If we want to use the Awaitility for the retry policy, we should probably create a new configuration that takes a Context as a parameter.
Can be synchronized.
put all parameters on one line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
This could be simplified to just the special case "if (" and =>)..."
It doesn't really matter but this will return null if there was no error, right? Why not return the name?
Do not use 'person.getPerson method'.
I think you should wrap the original exception to the log.
Shouldn't we close the socket here?
method name no longer correct.
[optional] Could we please use for loop instead of nested for loops?
This seems like a static member of this class, why not use something more stable like the following? Regex compilation: RawByteSequence existingMeta = unescape(b, "a")
minor: add a metric for the metrics -> testDataAccessor.
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.
This is fine, but for future reference there is also a MyService class to be used here, so as to avoid needing to call setMyService with the original object itself. It is also fine for future to be creating a proxy, but for future reference there is also a future use of reflection, so for future reference.
Add a "this" keyword here.
I think we can remove the else since we log the exception twice.
Use map.put instead
Should this be int?
You're not showing to the world.
This can really throw an exception. Missed a stack trace in the first place.
RingbufferContainer.isStaleSequence(long sequence) We can do this directly in the loop itself, can it be equal to the head or strictly less and so on and so on.
Same as above - no need to check if savedInstanceState is not null - just trying to get it from savedInstanceState.
Please improve logging or remove... also use parameterized logging were possible.
Could you improve this message? There are some kind of failure cases in this case of what you are trying to do, but at some point in time.
Is it possible to break the log message to a different message for SpHandle?
Missed this one - you was supposed to close the file first.
Can you use a iterator of the items and not a collection?
Transaction is opened the fun begins
I think that getTopic() will create a new PipelineTokenException
I would s/private/ modifier for readability with static modifier.
If we have the _table_ data point at init time, we will not need this cast.
The name of the variable is not necessary here.
It seems possible for the IOException to be thrown here. If we're not throwing the right exception, we should still count the exception.
I think it would be better to use exact constants for these two, preferably in a separate line.
There is a login strategy in this method. So I don't think it's necessary to add these parameters to an extra param?
command.hasAnyFlag(ctx, command, null); should be enough.
I would have put this into its own column. You only have 41 characters defined thus far on a line, and we usually have an 80 character wide terminal.
In my opinion, we could simplify this code further by introducing method which returns the packageBinding for each single invocation of packageBinding. This would simplify the code quite a bit.
We need to check that the suffix is ALWAYS a {" statement is not necessary here.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), true)).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
This looks wrong <LINK_0>
Makes sense to swap FLAG2 and FLAG3 since volatile functions are less common than the varargs ones.
validate paddingBlockSize int value?
How about creating a new Doc here?
This assertion should be replaced by "throws org.kie.workbench.common.stunner.form.Ciphers.PersonPerson_started_"
Right, you sometimes use "this" when you add the string.
you should return something like printStackTrace(); in the test and throw an exception if it fails.
please all these more intuitively. E.g. you can move this to the block and so much code we can set the value to null. I will just initialize them to the calling method.
Does this need to be public?
You need to check if (hwnd == null) && (hwnd == null) below.
new line
Not a fan of the default, but setting values on an enum here would be a bit more readable.
is this good way to do this?
.toString() is just a formatting thing
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
Is it possible for this to be null?
Minor: We could extract this part to a private method and use it in both places.
given that you create a SelectionListener/Handler at this line, I think it's better to keep the Handler as it was before and add a listener to the button.
Are you sure we should make this a job that runs on a fault? I didn't see it before.
I'm not sure this test is correct. The lock created should be then set to unlock but the RedisLockRegistry will return the same lock which has acquired by other tests. I know this test doesn't run, but with this it we should lock just before the get.
Is it possible to move move to the beginning of this method, without any condition?
should be outside the try block
Please add message entity here by describing the error.
I think you get the Project.getUser() from the previous path here, and then you don't have to add it again.
return an empty collection instead of null?
Can we return taskInfo.shutdownFuture immediately if there's no task?
Minor thing, but could you extract a message fixed as something like "Consider casting must not be called for any string literal."
Declare templateStream hear, as a local variable.
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this use of "Thread.sleep()". [![rule](<LINK_2>](<LINK_0>
Nit: We can do the full path read. writeFile(bucket, () -> delete(meta)).remove(); and avoid the full path.
Please use logger instead of printStackTrace()
shouldn't we put "useIPFS" as the default?
no need to choose to have a separate default from the precision
This method is a little bit hard to read. The only thing to do is to replace with if (!shouldNestedIfStatement(ifTree) return true; IMO it would be more clear and easier to read.
What is the reason behind this change?
Can we have the hashCode calculation back to the following? This was result in a hotfix that is called, and the other question does not.
can we use stream api here?
I think we should move character '|' to a constant.
here we always set the original class and the metadata, if the original class is null, we don't need this map.
We need to use thread.sleep here to wait for the thread to finish the thread. You can use other Thread.currentThread().interrupt().
Long term, I think we should be able to parse it to the long value as well.
Couldn't we use the same code as in org.jboss.as.util.StringUtils.isOptional here?
I don't think this should be done in the execute()
Why do we need a special case for no PaymentWorks?
personally, I would find any way to make this more readable for developers to override in the Java side. Could also be changed later.
There's no need to populate the collection as it's already been done in this PR, so it's better to remove it.
why don't you use the default locale?
ToStringBuilder?
We should probably import PrimitiveType() here too, since it is a really specific type.
Are we sure that this is a directory?
use getVmDeviceDao(), instead of VmHandler
It may be helpful to highlight the docs how to resolve the docs when there is a channel.
And if getTimeGraphViewer().getPreviousEventAction() is called before ShibnerTs, it is called in two places.
Hi @thewhij in this diff, in unit tests. Thanks!
Shouldn't this be get(message, extAntiCSRF.isAntiCsrfToken))?
The return string array must be in the same order as the received 'columns' parameter, not in the creation order.
For consistency, I would prefer to write this as if(!registeredEvents.containsKey( metricKey ) ) { gauges = gauges.get( metricKey ); }
why not to use here StepUtils.IS_PerformanceDataTypes.size()?
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
name it to pollPeriodinMS.
Can we change this to: Thread.currentThread().interrupt();
The other change is a bit too late in this class. It should be based on this.guided is not support for StatsWriterMap of its parent class.
Would you mind to remove the double brackets (way....)? Also for the above statement
If you're going to get the event from a network request, can you move it to a separate thread?
If flush() returns 0, the index is 0 when index = minIndex - minIndex = maxIndex - minIndex = maxIndex - minIndex - minIndex / (lastTime) - 1) == arrIndex; is faster, because of the if condition and so on...
That's why we removed call.size() from both logPath and eventPath. The exception is only used for logging
I think we should be able to use Arrays.asList(...)
You should make a separate method to keep the if, you can lose this line. I'd prefer it as it's some "magic" stuff.
Here I would think we can leave the label for the networkUuid to be consistent.
Why not move this into the constructor?
This is also a change for a long time, isn't it? Why put an integer (prop == Value) around the for loop?
The fix here should not be needed, since we are not passing the actual results in this test
no need to close a new one
I like these two lines, you write the same data twice and then write it twice. Can you write it as: java int size = mSenderAddresses.size(); for (int i = 0; i < length; i++) { dest.writeParcelable((byte) arg).writeByte((byte) (mHttpProxy!= null)) { dest.writeParcelable((byte)0); }
please decrease to TRACE level
Not 100% sure if the counter is greater than desired, but could you add a check for it? So that the counter is smaller than the number of files?
Also here re: "if scroll!= null return;" re: "
If possible, tests should not share any state between them as it may hide bugs. Why is this account initialization running for any test, even if it does not do anything related to the configured data?
@inverno rename 'element'
Here we should use equals()
nit: no need to create Map here
stdout
Please use GroupsManagerImpl.isDirectGroupMember() which is currently present only on group initialization.
Arrays.toString() is varargs
nit: rename these map to childNode: ConcurrentHashMap
rename to simple
This DateFormat object never changes. Maybe make it static final in the class scope and save a bit of performance?
@o-alex can we replace this with LOG.info("Failed invoking the read metrics {}", e.getMessage());?
Rename to CACHE_KEYS_RANGE
Typo: repository is NOT in NFC, right? I would prefer to keep the former solution either with the early return
These ERROR messages should be DEBUG DEBUG or TRACE log
You should be able to replace the "rpcManager.getFineGrainedAtomicMap().
Origin.MONITORING should not be removed since calling Origin#getAgentName will return null. You don't have to check if new code is present. It's not a big deal.
Great, can you add a constant for "EMPTY_HEADER"?
Do we really need to set the project directory? Can we use a project with the corresponding test data that is sent via testFile?
I think this name should be "advanced". Perhaps "advancedMsg"?
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.joining(","));?
Why is this line needed?
Use try with resources
Spe
We can do it in a follow-up change but I'd strongly recommend using the ident gitattributes facility so we always embed the git commit hash in the user agent: <LINK_0> That should be fairly straightforward to do.
name.endsWith(".jar") would be more readable
File
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw a NullPointerException. So we need to add a check here.
I'm not sure how this is the intended behavior. We should do this by default.
Looks like we don't need a loop here.
A Sqlkind is not needed for parens, since unparseCall()+1] will be on a different line than the same problem.
Here's the source source?
This is probably ok, because TumorType instances are not really modified after they are created. But potentially, this sharing of the children (the copy will refer to the same objects which are the children of otherTumorType) means that a remote edit to the child TumorType will alter "my" children (the copy's children).
If If it is only used in this class, remove it and replace line 297 with a single quotes.
space and else if
I think this can be shortened to: if (color!= null) { return ((String) value).toUpperCase(); } else if (value instanceof Integer) { return ((String) value).matches(); }
simplify to isInitialized()
the return value is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
Should be visible in the custom action bar.
This seems probably is a typo but it should be " user_ext_source" or "of user_id".
Unnecessary null check
suggestion child.onNext(n);
Does this English need to be formatted as well?
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Long, Long> subKeyRangeList = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.computeIfAbsent(blockId, Long.valueOf(blockId)); subKeyRangeList.add(subKeyRange); });
Use another method this catch block for two exceptions, e.g. catch (IOException e) { log.error("Public key is not a supported certificate, e); }
Use ConfigurationException or custom exception.
@tsrishabh-997 use static constant to avoid magic numbers
It would be nice if we could skip that when statistics are not enabled. System.nanoTime() adds some overhead.
Suggest adding the "if (Objects.nonNull(volume, ))" check.
I think this is the best place to throw IllegalArgumentException(). If you think that is an InvalidPathException, then you'll have a 2s Exception.
Why do we need two filters here?
This method should be private.
It would be better if we handle the case where it's a user error.
I don't think we can use AtomicInteger as it looks like we can just use one liner.
This text is not good for this use case.
While interesting, it does a lot of unnecessary code, but the null check happens at the previous line (bug)
this should be Iterator<Integer>
Style-nit: We don't use braces around single line blocks.
Why do we need to include the cause?
No string concatenation here, please.
Do we need to use brackets here?
I think we can use a Set here, as we have used Map.Entry::getValue. That would make the remove() call more readable.
suggestion long requestText = this.getRequestTime();
We should have a better name for this method. This way it is done consistently in other areas.
Better to throw an IllegalArgumentException or exception.
The target file extension is added to the target directory, so is there a problem?
Remove this.
i don't think this is really needed given given that this method is only called if testCentralDirectory() is not null
Nit: should this set the default to seconds, or is it a greater than max?
negotiated timeout. This just uses negotiated timeout.
The RVVVVVVVVVVVVV is an Integer.
It's a bit confusing to have a class name - a list would be empty, in general, it is hard to understand why this logic would be necessary. You could do it like this: java List<ASTName> subExpressions = expressions.findDescendantsOfType(ASTNamenode.get(node.getImage()).stream().filter(isCompileWithRange(node.getImage()).map(ASTName::get).collect(Collectors.toList());
could be merged into 1 if and for else?
reduce to debug
remove this and following our.println?
throws IOException is not needed; remove it
This test is not necessary, the actual bug thrown in the test is supposed to be catched already.
I'm not sure whether it's a good idea to save the settings in a variable, especially when it's only used once. The only reason I see it's used is that way for the code to get it (and save the read-only state management) is to copy the settings to a temporary variable, and if so, it's better to make it more readable.
I don't see where this is used.
Can you please rename this variable?
I think we should also verify that the violation is still there, otherwise it's not a problem anymore.
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
No need for the duplicate check.
should be k
Move the creation of the pointables object to the constructor. In the evaluate, just reset or clear the pointables variable.
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each segment of ResourceGroupId being static or not when we create them via group.expandTemplate call, then we can easily put the flag here. And no need to rely on the context. i.e. this line will become something like this group = parent.getOrCreateSubGroup(id.getLastSegment().getValue(), id.getLastSegment().isStatic()); And i think to make this happen, we may need to change the segments in ResourceGroupId class from string to a class Segment which looks like this: class Segment { String value; String isStatic; }
lower case "/question"
This will be changed to be implemented based on the currency of the screen. The addition of the card is to be calculated every time when the player is created. It's not the recreating the screen.
This is the fix in PlayableUtils. I'd prefer to have a common helper method that does the same, but just make the code more readable.
Why are we using a layout widget widget widget widget widget widget widget widget widget widget?
This code is duplicated from the the get() method. Could you please refactor it to be shared between the two lines?
@bxf12315 @efgef Please use Objects.equals()
As written in the previous PR, why contains magic numbers?
Again, please add the Assert.assertNull(...).
Let's check for null as well
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.getUploadedUrl = Config.getBlobUrl(Const.ParamsNames.ADMIN_IMAGE_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_TO_UPLOAD_LOCAL_SHARE_NOT_SUPPORTED
I think this is dependent on this plugin, to prevent loading of files that are required to be supported. It is always safer to specify a known type of directory.
Needs a get on the same line
You can replace with:.append(tempVar.getConstants().().().()...);
consider to have the storage pool id as a constant (and having it as a whole class)
This should be static.
could you add an if (noExtraOutput == null) to the string, in case it's a null, add a @Nullable annotation
These two lines should come before the if. (Remove in the other branch.)
How about a multi-catching query (ConnectionServiceException is). We can have a multi-catch in this case.
// You need to specify the stack trace
Why is this cast needed?
Suggested the aggregators
Would be nice to have an find-in Viewer that onViewCreated() method, and save the availability only if it's available.
The problem with this call is that as child.isWildcard() already returns a child of children. So if you remove this call from L37 it would be common to have the combined child.
Does this need to be in an else block? (for example if I understand correctly)
We need to check event.post!= null first, and skip clearing it (the post can be null)
[minor] There are a few more places, it can be worth including this into the method: java String userPrincipalName = accountName.get("displayName", objectType); if (objectType!= null) { accountName.get("displayName", namePrincipalName); } String userPrincipalName = Optional.ofNullable(objectId);
This seems to be a bit easier to read by adding a new copy of the same array into the buffer. My suggestion is to use a for loop like this: int[] b = 0; for (int i = 0; i < len; i++) { if (c < off) { byte[] b = new byte[b]; if (c < 0) { res = len; } else { res = len; } } return copied; }
The tab style used here is strange.
This isn't a bit confusing, we should look into this a bit closer to the serialization.
No need to create a new object on each iteration, just update its internal value as key.
This looks like a change we should not use the descriptor.
why not first run the command if it fails? i dont think this is what we want
This technically isn't needed since it will be called by default in the future.
Why do you need to reset the interrupt flag? Wouldn't be easier if runningExecutorService.get() throws InterruptedException?
Refactor found(...); and remove the for loop
I am pretty sure you have assertNotNull() on the list. Normally you use the message when you use the argument.
we should use msg / default (name) instead of v <=
What happens if there's a race between scheduleExecution and executeExecution?
shouldn't you check audioURI!= null here?
maybe we can use the same naming for the methods of the used above.
nit: extract a private method that we can use in these two places,
The Style you are adding doesn't add any value. Might be clearer to call capabilities.add(new ArrayList<>()); or something like that.
@xupyprmv inline this one as well
when it is false, it's not a true/false. Please remove this check and add one more condition: if (StringUtils.isEmpty(diskPath) || StringUtils.isEmpty(floppyPath)) { return false; }
Put the "id" in a local variable in a single place?
So the.collect line should be removed? I thought we didn't move the commit here but we should probably keep the commit as it is.
style nit: you could use listener.test() instead of mIncludeFilters.contains(testName)
Can we pull this out into a isGoodPath helper method or something?
@kachayev this is not correct. I'll remove this.
Can we make this method static and call it from here?
we should probably log the individual http status here
suggestion "Duplicate project name found: " + project.getName().toString();  Also please use a more specific error message, was also expecting " + project.getName() + " on this project"
@pynicolas Too many "if" here, it's not "else if" but just "return true" from it. Maybe that should be more correct :-)
Needs defaults
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
Does this make sense?
Can you use try-with-resources here?
Looking at the title, I think this line should not be removed.
This will spam like crazy. How about the next sentence instead?
We can get rid of this if/else branch, the I think.
I'm not sure about this change. This BlackboardAttribute at the moment, as there is nothing to set it. Why are we passing the file path to the log message? I get the chance to not be too verbose, but at least the log message you were looking for.
I see some kind of warning is appropriate, please leave this as something like logger.info("Write config failed while any other tests in this class is disabled.");
I must be missing something here but to prevent having PermanentOrLf9f
shouldn't this be line above, so that you do not need the "equals" check at all?
command.getAdminAccess() might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
Can you use a shorter variable for the sake of readability? Please also use the contains() method and avoid the double-check, when appended.
please use configuration to have per version values (it will save doing the per-version checks)
Please update this implementation.
this is entire debugging statement.
Can we really don't have this on the output?
Yeah I'm surprised this is a getPublicAddresses. If so, this should probably be _privateHostname!= null.
Redundant cast.
Just double checking: Was it intentional to go from 10K ms to 1K ms?
suggestion InputColumnPosition<TableIdent> generatedColumns = ImmutableMap.of();
owned as a variable...
This should be } else {
I'm wondering if it should be possible to refactor this PR into a separate PR, what do you think?
Unused variable
We still need to set this value here, right?
this can be removed, since attributesManagerImpl.addAttributes(false) will throw runtime exception from resource to resource.
Do you need to use the sub path here?
Get it from this variable and use it.
use CollectionUtils.isNotEmpty
Why the returned list?
The naming is a bit confusing. I'd suggest to put times(0) into a variable, to make it more readable.
Should use constant instead.
Use ObjectUtils helper
The logging and the label are missing breaks.
We could rename the test method into executePredicate.
Why are we passing the _next_ prefix here?
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getHost()"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
add locale to param
I think if (! is redundant
Please use Set instead of ArrayList
what about memory and network costs?
I can see the code follows the previously defined expression but I guess we could simplify this with assertNotNull.
Wouldn't it be a performance benefit to creating an array here and the size could be negative?
This breaks the current implementation, but I'm not sure I like the idea of doing the extra work in the current implementation. I think the proper thing we want to do is to add the SpanContext.now(). With the current MessageHandler, we're effectively doing classes not implementing the interface, and not by all other interfaces in the proper way, but we should move this to the base class (and maybe a totally different PR)
This test will also fail if host is not a IPv6 address. Since a Mac is not a host address it should not be returned.
I don't think we need this cast. We can just use oomLevel.setRight(Math.pow(float child)
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)?
Its a pity of bug me (InetSocketAddress has an assertj matcher) that can be used to avoid this kind of code.
Why is this as a separate method?
Please format this.
looks like you are using 10 as a value.
I wonder if it would be better to use k instead of v? Or alternatively k.abs() should be a little clearer?
Please move this line into the if/else branch, e.g. @Override public void initSelectedProfile(ListModel<VnicProfileView> profileList, VmNetworkInterface networkInterface) { if (Objects.equals(profile)) { profileList.setSelectedItem(profiles.stream().filter(profile ->!Objects.equals(profile.getItems(), networkInterface.getVnicProfileView())).orElse(Collections.emptyList()); } else { Collection<VnicProfileView> profiles = Optional.ofNullable(profileList.getItems()).orElse(Collections.emptyList()); profileList.setSelectedItem(profiles.stream().filter(profile ->!Objects.equals(profile.getItems(), networkInterface.getVnicProfileView())).orElse(Collections.emptyList()); profileList.setSelectedItem(profiles.stream().filter(profile ->!Objects.equals(profile.getItems(), networkInterface.getVnicProfileView())).orElse(Collections.emptyList()); } }
nit: if it's unnecessary i guess we can avoid the creation of build.
Why did you add these similar lines here?
For all asserts, provide a 3rd parameter "message", which will be printed in case if the assert fails.
Consider null case.
You could use a local variable here too
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be more appropriate and the suggester service would be a part of RuntimeEnvironment? The point is that the concrete implementation is always hidden to the end user. If it cannot be done, leave it like this.
not sure, what if this causes the error to be logged?
what if we don't add any local variable to another method?
We can use result.getProtocol() here.
is it possible that rowCount is different than hashTableSize? you are using this to go through adapter instead of accessing this.keyNativeHashCode.invokeExact(partition);
Missing spaces around ==.
Can we just make this method final and rename it to something like isDefinitionToTryByPrestoable?
Please check exception message
I think we need to check here that the host is null
@vrushaliwaykole @dhanasp -- There is a null check inside updateEntry method and we're already changing the Branch in the DTO. It's not used in updateEntry method and we're already changing the Branch object. It should be null.
Nice catch Exception
This can be rewritten as: if (item.getLoggedIn() == null) { // do nothing }
The Java 8 has been introduced in Java 8 for this.
i'd suggest to put this in a try-finally block, so that the JobRepositoryFactory.getJob() never returns null.
Is a config specific to this location?
CRS can we not print out the exception in this case?
The same goes for all the changes in this file.
Same question. E. g. in constructor, it uses NullHandling.emptyToNullIfNeeded(value). Could you also self-review once again ALL usages of emptyToNullIfNeeded(), emptyToNull() and Strings.emptyToNull() (if there are any remaining in the codebase), and reverse methods?
Don't you want to rename this to authzClouds that are slightly different from the one used by p.setGranted which is a part of the code.
LiveInstance?
This is the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
I think you're loading all the strings in AndroidApiUrl, could you reuse them?
Check that the RyaStatement and Config are not null.
suggestion if (!passwordToEncrypt.getWorkflow())) { I think this should be negated.
this will be entry.getValue().executionDelay = entry.getValue().executionDelay - POLLING_RATE
style: space after if
In my opinion we shouldn't keep this error unless the snackbar error is null.
Use FileUtils.mkdirs
hmmm, shouldn't we have this logic at all?
.* and.*
Use the getTestFrom().
If you want to include the different flag that can be used for FileNotFoundException, then the IllegalArgumentException message could be thrown more useful.
cannot be null. "default user with the username" or something?
Static import for more variables to make things clear.
Not needed given the old code
Nitpicking here: could you please move the variable scan the expression to a variable? That would make the log line much easier to read.
Would it be better to use the same JSON abstraction instead of the literal?
In this case we can compare lists
I think you can use Arrays.stream(constantFilterFunction).filter(column -> function.get(columnIndex), positions).filter(new Page(columnIndex), positions.length == 0).findFirst().orElse(null);
Don't print the stack trace when the whole stack is changed, use Activator.getDefault().logError()
Perhaps use IsNullOrEmpty() here?
nit: Maybe we can move this down to the DeltaShardRewriter constructor.
Not sure if you want to break this line here
This is a really hard way for me, I think this exception should be at the end of the method.
Being paranoid here, is it possible that the test is failing and returning empty strings?
does this throw any exception?
We may want to log the operation / chain id? I'm not sure "this operation" will be useful in the server.log.
If the type of the editPart is the EditPartOperation it is not a direct type of the condition. It is the name of the method and not the "diagramType".
I think you need to set UDAF currentlyExists function as well, to avoid unnecessary cast.
This should no longer be > 120 characters.
I think you should throw InterruptedException. Most downstream is expecting other exceptions to return null.
Is path == null the same as the old one? Should we use "" as the constants here?
could simplify this by a switch and just write the text as a single static final constant at the top of the file.
This should be done in the loop as well (but it will have to be optimized each time)
How about getTxStreamProcessedTs instead of getTxStreamProcessedTs?
The delivery of the command is that the object is provided. See the method type
getParameters().getParentCommand()
Don't you think it's important to always return a file if there is no directory?
Sharable??
Use class naming rather than "old"
you can use the following code : 1. to ensure that the LeaseStorageDomainId is always of type 2. why is it returning null here?
to be extra careful with using the task.getAllInstances since we are using the global flag.
We need to have a method that does this.
Just a warning. The user will enter only the input and output of errors. Please leave code the user can't show it as it was.
@rishabh-997 I'd introduce a variable for qualityMod.getOptions() and getQualityNames() to check for quality.getCampaignOptions().
Will this cause trouble later on setTask(String text) to null?
Wouldn't the above code be easier to understand, if we have a block as an effect if the same thing is done.
style nit: now that you're using this expression :)
rename to channel
"for (
cboYItems is going to be very globally slow in case of an error, without checking equals() method.
You should do not need to call toString since you cannot access the subject under the message
Would it make sense to reduce the columns that are relevant?
Printing a variable is not a good idea.
No null check for zone?
Shouldn't it be template.isDefaultDeployment()?
Maybe log the command is missing here?
If I'm reading this correctly, it may be a good idea to pass a stream or a reference to the enum here. I would go for the "indexedTypes" approach: java private static final Set<LegacyIndexedTypeIdentifier> DEVICE_TYPE = new IndexedTypeIdentifier(worker.get(i));... private final Set<LegacyIndexedTypeIdentifier> output.writeObject(new IndexWorker<Identifier>()); output.commit(); final InputStream output = new HashSet<>(); output.writeObject(worker.clear()); output.commit(); output.flush(); output.writeObject(output.position());
Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.
Should we be verifying that we have a chunk of the key?
I think the original behavior here is to use the same string value as in the left and right? It would be nice to set in the same class as all the other functions here, and copy pasted three different strings here, so I guess.
Is it still the log message only, but it's better to use the slf4j originator here?
RequestOf is non-null and hashCode() returns false, so the cast should be done to int.
The usual convention for a method like this is to have a single "version" populate method with methods like "Search {}". I guess that would be a bit more readable and less error-prone in case someone changes the "query" code, and it isn't worth the effort.
In this case, you can drop the indexConfig for the test.
Is it possible to use a real username or password here?
Missing curly braces.
For symmetric purposes, this can be just mock it in the test: java final Builder createPattern(Reflections.create(Disk.class, GetOptions.class, "key", true));
This effectively cause the sleep to fail. I think it's better to use a boolean flag, than a @Test(expected = Thread.currentThread().interrupt(); assertFalse("Thread.currentThread().interrupt(); return;
We should use Objects.equals(dmnModelPath, modelName) here as well.
Is this test finished? It seems to check if the function is called when not.
I don't think that this is going to work, but seems like it would be better to make a local variable in the name of the enclosing class. This is named more than once and probably the name of the individual system
nit: Deleting table is pretty a bit weird to see the _table_ in the log record.
Group exception types handled identically in a single catch block.
10 and 100 will be a magic number. Why not use the constant MIN_ACTIVE_REPLPS?
Is this the main reason why you have to wrap this into a logger?
In the code, not the exception message (or the one below): The message could be misleading. I would expect the ConnectionException to be thrown like "The IP address is not found on security keys".
I think the old code should work, only for new hosts.
Also with explicit contentType check java if (data.hasSize()) { return callApi(data,..); } else { return data.windowUntil(..).flatMap(fluxes -> { var contentType = getContentType(cachedBuffers); if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers)); } else { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } }); } I think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can be deferred to flatmap operator.
You should never have to do this. It should be some java if (supports(dataHolder) { return DataTransactionBuilder.builder().result(DataHolder.class).build()).build(); } else { return DataTransactionBuilder.builder().result(DataHolder.class).build(); } It's one moreliner, and the existing code is the same as the DataTransactionBuilder.
As a practice its a good idea to call commit on a connection that is returned from the pool before performing a SELECT operation. This ensures that any uncommitted data will not be returned by the DB. The pattern to be used therefore should be, try (Xdb connection = GatewayAPIDTO.getGatewayLabels().getGatewayLabels().filter(x ->!isGatewayLabels(info)) { return!gateway.getGatewayLabels().contains(gateway.getGatewayLabels().get()); } catch (ArtifactSynchronizerException e) { log.error("Error retrieving artifacts of type: {}", e.getMessage()); }
plz remove pokemon.
The changes made here are never read. Try removing it and then it's still necessary.
This is a bit confusing, I understand why - is it used only when limit is reached, but now that you have already checked this.taskExecutor only to check if the pool is empty?
It would be nice to ensure that the reader is closed even if an exception is thrown.
yarn@EXAMPLE.COM?
Errr... you should verify this before you even push a new commit! =)
Why "next"?
Is this really needed?
why not keySize? from all parameters of the called pattern, we select the bound ones... so the source width should be the number of symbolic parameters
Let's generate all the fields for the same info.
This test is doing quite strange thing, because there is no way to go through _if_. Sums except the ones ones tested differently.
Should this be removed?
Do you think using foreach on _id_ is cleaner and easier to read?
It looks like we can use the scheduler.waitForServer() here instead of the for loop
Make this values as constant.
why can we rename this to receiptPageNumber?
IOException?
Same here with the merge below.
We don't want to swallow exceptions here.
Can we name this case-sensitive for DataNode?
Could we include the name of the exception message above to help diagnose the failure? That will help us more quickly diagnose the failure in those cases where the caller shows the exception message rather than showing the entire exception stack trace.
This will create the error from the layout. You can just throw the RuntimeException
Maybe this check is redundant
I think it's too bad to have a copy and paste error. What does it mean to have a test?
why is this line needed?
Better: new HashMap<>(Collections.singletonMap(str))
This looks like a very long log line.
should probably be Integer.valueOf(100).
Can you put the if condition around this block? If not then this if would be wrong.
hasSize(null)
I think we can use ImmutableSet.of or EnumSet instead of a Set. But this is not very important.
This should be: if ((x <= '') || c <= '')) { builder.append(c); }
The operation runs in a background thread; this access to get the checkout result may not work.
I was thinking we should create a StreamProperty per line above, like we do that for StreamProperty... so that we don't need to create a new array on each iteration.
Remove this catch and let the exception be thrown as that'll make the test will fail.
I think this belongs to a service, in the end, in case of a keystore type, truststorePassword, keystorePassword or something and truststorePassword.
Would createUnresolved work as well?
@ndinuan Was this intended? If so, I don't understand, why is it called before?
Why not make more sense:.equals(this.sources) here?
nit, it would be nice to have: private List<SlotExecutionVertexSchedulingRequirements> allocateExecutionVertexId( Set<SlotExecutionVertexSchedulingRequirements> executionVertexId) { return new SlotRequestFutures(allExecutionVertexId); }
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but since some people want it i won't object)
reorder
I think Assert.fail() is no longer appropriate - should you be getting a MongoDBShardedDeployment?
Same as above, can you try using null instead of cursor?
Should this be passed in?
Is this change necessary?
What if the future was already initialized?
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be preferred option?
We have to also show the snackbar here, right? Maybe we should also show the snackbar in the activity.
should this be taskReports.getWorkerRunningTaskLocation(taskId) so that you don't have to do this?
I think we should pull this metric from metricList in metrics? It's metric list from metricList in memory.
Minor: Convention is to use curly braces around single line blocks
Should not use base class here? It will be super easy to see in the code. Just the pluginInfo stuff.
Maybe collapse this into a if-else.
Here in line 81 we have redirected a <LINK_0>
We should turn the auth system back on after creating the test data.
I don't think this is a good idea. The caller of encodeEncoder should have to release the buffer before calling createEncoder.
Poller has a quick PollerFactory on the way up here, so it's better to use it to be used by IntegrationFlows.
You should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
Now it's correct! :+1:
Same as above: if (!getSucceeded()) {
no need to call principal_address in this context.
When you open a repository you have to ensure to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close().
maybe change this to be a Map<String, Integer> in the if condition as well.
Please update this example according last changes in the master (look.)
Does the list need to be modifiable? If not, List.of() is the conventional preference for empty lists.
Hm, maybe move the invocation of subscribe() and MasterAttributePropagator.init() to be a final field?
I think you can just use hash.hashCode(). lists should implement it correctly.
Looks like a candidate for a method #build(ChangeData p, String key, boolean limit)
what is this new condition about? is this related to the original story? anyway, this seems a good place to use 415/Unsupported Media Type
I don't think this is needed. The code is already checking for the property "property".
Should the implementation of KeyMaterial as well be a class?
Should be collisionMod
@westonized we should not chain these two lines here: 1. for (Map.Entry<String, String> entry : headers) { map.put(entry.getKey(), entry.getValue()); } 2. why do we need to maintain a map with the original value?
No need to use UriBuilder
I think you need to assert that the return value is 0.
to be consistent, please use variable and remove 'throws EventResult'.
Oh, I see PlainStreamingSender is exactly the same. Could you please extract it?
FromCache so you are not checking for options before copying.
Add doc Add @Override
This should be value instanceof Integer, not Integer.
In the null check (in the next line) you can move this outside the try-block.
I think the 'if' can be removed now
The same?
I don't think this is a good idea. But we need to be careful when there are multiple executors.
please decrease to TRACE level
Suggest a final variable for this.
Don't need this?
java try (FileOutputStream output = new FileOutputStream(dest, resourcePath)) {... }
Could you simplify this by only adding the string like string.append(repository.getAdded().get(' StyledString.DECORATIONS_STYLER); string.append(repository.getNotRemoved().isEmpty());?
I would make this stronger. For example, that will be handled by a few other cases, like STR_LINE_BREAK (name + "ParagraphStart")
could you set a local variable to null after the double negative?
Could you keep the linke @ekondrasheveveveevae
Unnecessary.
A method on an interface should never return ElasticSearchUtils.getMappingSource(table.getName()); in the context of an object that represents an instance of Map. It's not necessarily an instance of an object. Maybe for consistency, we should check for for instance handed in the ConnectionService or even a class that is created and returned.
You can use the ShardSyncTaskManager creating the ShardSyncer, instead of having a separate class for each ShardSyncer.
I think nextElement.Standalone Alias can be null
S is not a good variable name. Rename it to something more descriptive.
Method on lines 45 and 25 allowed per lines of code (exceeds 25 allowed). Consider refactoring.
if (getWindow()!= null ) {..} may help
If 'updateNics' is empty then the default should be returned. I think that in this case it's better to leave the variable out of the method.
remove changes in this class
i think the for loop should be on the same line.... if (value.equals(dimVals.size())) { filters.add(new IndexedFilter(dimension, value, null)); }
We need to move this out before.getExtent() since that's what the code is doing.
This is for debugging, right? You can just use the log.debug without the need to modify this.
exception
not sure we want to use the same stup criteria...
@crankumarkolli - please make this <LINK_0>
These two lines can be moved outside the try block.
Do we need that log?
Use logger if needed
if you set a modifier - protected seem suitable
I think we should have the fail() after this line.
call byteBuf.forEachByte(ch.int(), StandardCharsets.UTF_8)
unused
return StringUtils.isNotBlank(value) && StringUtils.isEmpty(value) && StringUtils.isNotBlank(value) &&.isEmpty()
else not needed, the null check will never be reached.
Super nit: unintentional additional white space I assume.
the default charset is not extraneutral.
I prefer the latter of the class because it's more readable form of voltdbPlanTreeDto :)
Why do we need the "port"? It is a typo only in the first place
I think catching this is more appropriate than just logging the error.
Try something like try-with-resource.
This callback is also a little weird. Maybe we can use callback.addCallback(callback); in a future and avoid the cast.
You should try-with-resource block here. If you have the resource, the FileChannel should be closed, otherwise it is never closed.
The intent of this method is to replace the null value by a!= null && (and above to be consistent with the other methods). It is strange to have this kind of code.
This keyword is not needed, you've already checked it in line 3031.
I think it would be better to use awaitility instead of sleeping.
ComparisonChain seems to be missing here, I don't think you need to filter on the boolean returned by.equals() on the left; your.equals(first) should suffice.
This method is a very long. Please use it.
Replace this by java.collect(Collectors.toMap(snapOS, VERSION_PREFIX, "ctx" );
This can be simplified to IgniteEx snp = startGridsWithCache(igniteltCacheCfg.get(SNAPSHOT_METRICS))
Please don't include model classes in the error message. If they are not needed, just use them in the real way of getting a model type.
should this change in the category class?
Can we have a default value of _periodicTriggerInterval in the whole class?
shouldn't the test return with null as the first statement be making it more informative if the test fails?
I wonder why we are creating a generic class for the conversion in the class?
do we want to log any exception in the poll case in a storage storage account?
Shouldn't we be doing cache.getCacheNames().cacheMode() == TransactionMode.TRANSACTIONAL? It's a Sonar issue.
gtk_widget_realize
nit: can use isEmpty()
this can be a RuntimeException with an Error, e.g. if the rest fails, the error message is early.
System.currentTimeMillis()
Don't bother. This doesn't help, as we found out.
I'd probably remove the toString from the sgetForService.
Please use diamond operator: new HashMap<>()
Can you put this into a try-catch block so that the Throwable is an instance?
Can this if statement be moved outside the if statement?
call super.hasMailAuth()
If we keep this, could we use the ExternalFileTypeByExter to store a String here? I.e. could this be just a key?
I'd rather this method be split in to : "getEOpposite() == DifferenceState.UNRESOLVED", "getEOpposite() == DifferenceState.UNRESOLVED"
This may replace a string, perhaps we should prefer String.format("JabRefPreferences.DELIMITER).
Should this be inverted or use an else statement with the original exception?
Shouldn't this be the thingType id instead of the modelId (modelId can be null)?
I think this can be just'return get(SinkEvent.class);', no need to add the 'else' here.
should be the responsibility of the checkImportFromImportFromImportAction
Did you mean to add the following code to the else block? private void refreshDecoration(CallUtils.SYSTEM, String image) { TmfRenderer<? super T> view = null; if ((CallUtils.isAllocatedTo(project, true)) { return; } if (contentService!= null) { return; } // TODO: check the parent/discard to add the necessary decoration but the decoration will be non-null?
Also, please add { and } to the if block. It's not necessary to do it in the else block.
I would have thought that this condition should be: if (isInactive) { return false; }
It's a warning. Do we want to log the complete exception stacktrace for a warning? Check with <LINK_0>
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
Rather than do the check any more, I think it would be better to use the platform specific encoding instead of UTF-8
nit: Could statically import these assertion methods.
A better name would be changed to "shubs"
I think this needs to get the Type param a Type param, not a Type
nonVmMtu5000 ==> nonVm
is this the 'button' described in commit message? do we really need this Label?
Could we move the try-with-resources statement inside the try
Same here, seems like the value is not used anywhere else.
I think it's better to copy the updateFuts() from DistributedMetaStorageCasAckMessage to a new class
Probably better to get the sorted set at the end instead of trying to avoid the map.
We need to reset the interrupt flag via printStat() if the threadId is not printed properly.
This seems a bit strange to me. Wouldn't it be better to just use a URI and then check the return value? I think a bit more clear might be the last thing in the method to do (and so feel free to ignore:
Might be better to log LASUtils.BLACK_PERS_TEAM.
I think it would be better to provide a configuration object for userCrn instead of userConfig.getSaltSecurityConfig(stackId); so we don't have to map the userParameters.
Please use ==
I think this would be better off being the default constructor of dictionary.
Pool
Guess this test needs to be exact...
I would get the message from the Jenkins log (maybe a message?)
Let's say setState(KEY_SESSION_TOKEN)!= null, and CLIENT_AUTH_DATA.build(); then setState(KEY_SESSION_TOKEN) will be enough. We can then take advantage of the new state within the loop and always iterate over the values. Yes, we use the new state object.
If we remove the!AlreadyisEmpty() this line, we can remove the!!isEmpty().
Since we already have the base class AbstractTraceToken, it would be useful to define what this method is doing
nit: we need a test that ensures that the cell can be completely lower than 0.
You can use newOrganizationDto(qualityGateFinder) as it's what is done in this line.
This can be rewritten to collect DbxWebAuth.USER.
Here too, we have DanjoRuntimeExceptionRuntimeException.
Why not just catch HConstants.HBASE_TEMP_DIRECTORY and let the exception bubble up, rather than duplicate that logic?
This makes me think that TransactionManager should not need to be changed to a model.
Should not this code be in tokenExtractor and not connection?
Class createPage, not.
} catch (Throwable ex) { throw new PerunException(ac.stateChangingCheck()); }
I was just wondering if we should have the client token auth error and return it with the client token enabled, or maybe we can add a default to that client, at least the server is found? It is not obvious that in this case the client will always have at least one client.
Hm, the patch in master might be a good idea to make this private. And the method should be public.
This should be final
Again, the parens aren't needed.
The assert above can be removed.
Maybe it is a good idea to test your code, but you could use a constant to make the code more readable.
That's a separate behavioural change, should be done in a separate patch, if at all ("just wait for the varints bro").
It's preferable to do this after the loop and save the number ofgroup types, since you are not changing the number ofgroup params, just the number ofgroup params.
Please add null check for entity.
we have a 2nd issue here? check the size of the returned map and throw an exception
Please rename these to simply to new templates
please use!vm.getVmType() instead
In my opinion, this test method should be switched to contributors.
Expected before actual value.
Small thing, but I think we should use context.requestHandler() instead
should not we handle this exception here?
Why not use the [try-with-resources](<LINK_0> syntax here?
This feels like it's not used.
Use a static import
Cannot render interstitial ad. Please move message to render()
Same question here - what's the purpose of this change?
nit: do we not better to create the file to one "//h" here?
Probably a nitpick, but can we log in debug, instead of info?
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(this, "Project"); projectLoader.postEvent(this, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
I would throw an AssertionError here - this must be impossible from the platform's perspective!
Should we use ResteasyProviderFactory.newInstance() to automatically reset the bpf?
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() || runningVms.size() > 1 && ag.isVmAffinityEnabled() || affinityGroup.getVdsIds().isEmpty())
we can use method call directly
It looks like the logic worked here. I would prefer to remove the if (injectedTypes.contains(parameterType)) { add(parameterType); } (and move the logic to class class)
Shouldn't we not throw an exception if the user doesn't specify an empty config file?
why are you checking whether Utils.isEmpty() is true?
I think it's best to move this end up to the previous line so that we'll end up with no db state (which is what the code does).
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos auth. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
I think it would be a bit clearer to always use || instead of &&.
I think we should replace this with Files.isWindows() call.
while(it.hasnext())
please use getLog().warn("You should use the deprecated function where needed, please."); instead
Doesn't it override user decision when user de-selects this radio button and rotate the phone?
Is it worth changing the variable name to "skipableContentAsObjectNode" to something like getDecryptionResult?
I don't think we need to log anything here. We can move the log message to "listSnapshots".
onErrorMap?
We shouldn't be using putInt("linkId", builder.buttonPositiveId()) here as well.
it would be nice to use a constant for "removeFromNetwork" and "targetLinks"
suggestion return Optional.ofNullable(new InputStreamReader(inputStream).map(publicKeyURL::openStream).collect(Collectors.joining());
"log.error" is redundant here, can you remove it?
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file trades"?
> It's not 1.11 right. Can you elaborate? Are we saying that there was no valid version at all?
add a check that bitstreamformat is still here
Optional: better to invert equals to avoid potential NPE
This should be List<URL>
fBot can be used here
This has to be ((String name > 0 && colon > 0 && (colon > 0 && (colon > 0 && (colon > 0? name > 0) : name
let's use ternary operator here
I would keep this branch unchanged. This should be returning only 1 if old version is set.
Forgive my ignorance, but why perform these calls if we expect only a single element? EG: String plugin = (Map<String, Object>)ClickListenerConfig.get(0).getMappingForSiteToken().hasPathTokenToken(); If we need to use a Map<String, Object> mappingsConfig = new HashMap<>();
this should be in a new variable
Can we switch to exception?
bikeshedding, but return null and then put the tid under.
Should we pass the name of the line to XmlTextRange() here?
:bug: it doesn't use the player's library. I think it's needed to use discardCardsToReveal here.
I don't think we want to copy the header value here. This will be different from the one in the hot path. Could you check it in the initialize method?
Please use the expectedException type here to be consistent with the code to call the function DataFileReader.
Add a logger.
nit: This test maps a stat. Move this after the if.
This might be wrong. Why would you need the original message?
minor: maybe we can also update updatePartitionStateAndClusterState(partitionService, repartitionTime, partitionService.getMaxAllowedBackupCount()) here
Do we need these escapes?
We need to make sure that we're running on a VM with a K start/stop right before the leader election config()/this service service is in the queue yeah, "This attribute" may be missing a ConfigReposots' in the end: <LINK_0> Can we make this a class local variable instead of using the same value?
could this method be defined as <LINK_0>? and also in other similar methods as well?
We should never be sending null here
add CDA here and return false, if it fails you'll end up with null vmTemplate which will cause to an NPE. as it shouldn't happen i assume that we can solve it in the opened bug.
Is there a reason we are not using.equals here?..then there could be two negations.
I would think that you should have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
I don't like this reordering the code blocks. What about using a while loop here?
ditto about.remove()
Catch a NPE in a few places. It's not a good idea to throw an NPE in such a case.
Would you also add an IS_NULL filter here?
Is it possible to have this method return true, and the case where it's not assigned to this method?
nit formatting 2 spaces.
As long as we start reading, we don't need 2 more occurrences, do we even need this?
is there a reason we don't check is that the getCount() call is not used here?
2 events can be promoted to a single thread executor service
minor: It is extremely difficult to test for this test to actually call NoSuchFieldException when the property is not set.
Looks like the complexity is a duplicate of the same method
Use 4 spaces for indentation.
And this one is not needed
since this is debug logging provide an e.getMessage() instead and re-add the placeholder.
can we move this to a single location?
Can you elaborate on why this change?
Please change 'not' to be no longer supporting
Should we still be closing the record in the case of an error?
I think we should assert that it is a non-empty parentProcessInstanceId by case, in which case we can get an NPE
toString() isn't necessary here.
not sure if we should put these in a separate private method. final int countOfComponents = Stream.of(DoubleStream.of(DoubleStream.of(countOfComponents).toArray(new TmmPartitionData.get(i));
It looks like this is kind of typo in Request.
check whether Exception throwing
This is not the responsibility of this test, it seems to be a black tool. But here, have you tested a bit by trying to figure out what it is.
Exception is never thrown.
Similar
This message is not clear to me.
Should this be System.out.println instead?
I don't understand this catch - why is there a particular exception and not a particularly Exception?
Why not use GatewayServerBuilder instead of GatewayServerBuilder as it is used only once?
Is the retry attempt intentional?
Nit: if (m.isDefault())
'null!= editingDomain' is always false in this case.
Would it make sense to have a switch here to get the default?
for "k" and "v"
please make this assertion before the hasSize.
@lautarobock why using Pattern.compile() and toString() here?
can we use here.equals instead of!=?
This anonymous class feels a bit awkward. Maybe have a constructor that takes the view name and the view name?
Can you maybe use a Set in the returned list?
Call this out once in the constructor instead of calling it twice
It would be even better to use UserModel.createCredentialModel(auth) here, since we know it's not actually used in any code.
CheckForNull
Can we make this method private?
Again, this should be spacing
Why not simply iterate over threads.toArray(threadName)?
This isn't wrong, but the cast should be reverted.
Is it possible to break this out into a separate file as a subclass? I think adding too much to an Activity or Fragment is tempting but once we get a third card type in will start getting a bit hazy.
This can be replaced with getItems().isEmpty()
formatting
It's totally okay to have a single timeout here since the code is blocking and handles all of the factories being closed. If you want to make the code a bit more explicit then you can leave it up to the code.
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos..
You can use try with resources
instead you can use something like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin to see if there is no filter node
The relaxedInserted is not a standard bean, we want to get all of therelaxedInserted properties within the relaxedInserter. As it is, we want to avoid potential nulls.
I would use a plain equals here
ContainerUtil.addproperty == null
Let's change this to Assert.isTrue(property.getType() == Long.class, "Version property %s must be of type Long.");
This line is too long. It's not used anywhere else.
I know this is not part of the existing, but we already have getPendingThemesChanged() from this line, but we do not want to update this file. That way we can move the logic of this new method into AppPrefs at the same time and give the user a reference to the prefs object.
I think this is useful but we should have a consistent pause somewhere in the JSON serialization to make sure everything is working.
!query[offset](<LINK_0>
Add context specific message without using e.getMessage().
Can you use StringUtils.isNotBlank here instead? Also, how about swapping lines 47 & 48 to pull 47 into this if block?
[minor] missing [this](<LINK_0>.
Would it make sense to change this to "mkdirs" instead?
The current code would be easier to read if it were written more elegant: java String tempLeft = (getBoundingRectedRect(), tempTop.get("left"); tempTop.append("top"); return new JSONObject(buffer);
Nice variable name
I would expect the default to be false. Don't allow remote installation.
Better to have the System.lineSeparator() to be used here?
I believe this can be done with a simple String: return (sort == null)? null : ASC;
I think you're totally okay, but I think you're not going to add a lot of extra steps here, because of the logic you're taking into account every single add in the "data validator" tree and having the childrenTree come from the current position, so this is not quite a big deal. I think you should also do it like you're doing before adding the new non-tailing to the children.
I think the exception should be caught here to be more specific.
Could we change this to use the method reference that returns arg? java private void visit(Parameter n, Object arg) { printer.print("(" "); Statement " + n.getLocation()); return; } public Statement(final Parameter n, final Parameter r, final Statement expected) { if (!i.isParametersValid()) { printer.print("; arg"); } }
Let's change fupackServices to include the number of nodes in the log statements.
Would this be a RuntimeException?
We still need to blacklist this. I also think it should be a CanonicalTreeIterator that is used instead of the EGitTextCache.
Is the reason to keep the typemap here?
Should this fail the test? (same with other catch locations)
java.subscribe(new Action1<ResultType> { });
Unnecessary fact of for which incorrect predicates are already handled by predicates[0] below.
I guess this should be private Gen<Tuple2<T>> Gensperse(Gens._2, generatorss.setAndGet(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generator
Add a static import for Mockito.when here.
assuming both upper and lower are non-null, can you use == instead?
this seems like it should be sent out when you are installing a column loaded.
We should have the kEvent instance as the path
Do we need to validate the permission here or does this need to be done in the else block?
It would be great if this comes from a collection reader to construct and validate whether it is used instead of creating a new one.
are you sure it's correct to return null?
We have a few more places where SAP. Likely the code never gets restarted.
Given that equals() returns false, it's pointless to check!= o.getEnchantments().get(0) and o.hideCanPlace() here.
"constants" can be used here
nit: **Test** test helper method in TestUtils please.
getLabelFormat().add(FontFormat.BOLD_LITERAL); might be better.
Why not the default instance?
Hmm, is this intended to be set in the same place?
suggestion ConfigurableApplicationContext getInstance().getAuditerContext()? It is used quite often
Shouldn't the output need to be {"org.carlspring.strongbox.xml": <LINK_0>??
Same again here, just pass db into the method call
I think this can be simplified to just check for null, and have it return if it's null, like it's done in other places.
![MAJOR](<LINK_1> Rename this method name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_0>
can call the same method as in previous.
nit: change to assertFalse(workflowByPath.contains("\"aliases\":?
do we need this?
nit: would it be clearer to define variables for readability instead of creating an array in the xd order and then using it here?
The params should be valid here? (i.e. should have FEEDBACK_QUESTION_TEMPLATE_NUMBER param?)
GENOTYPE_VALUES is a bit confusing, could you explain why it is not a list?
isn't used...so perhaps do not need a try-with-resources?
s/n/Payload/
Consider renaming this to m.getOutputXML()?
You need to remove all the parts about property and instead look for other nodes in the metadata.
We should probably move a separate catch block for this.
log and get rid of this line.
Maybe we could move this check to the if condition as well.
Release needs to happen here as well.
Why is this variable outside the while loop? It's hard to understand.
We don't return Mono. It's not producing an error, then we should return Mono.empty() instead.
You can just throw Exception here.
maybe we could use: for (int i = 0; i <...; i++) { return...; }
I think this should be Object -> List<>()
Humm, JournalData is not really the place to log errors, so I think this should just be JournalData.addJournalEntry(new JournalData(owner, s.getName()));
Inside the if statement you use an else, and remove the log. This is the only place it should be done in one place.
You should probably use Renditions renditionEntity
We shouldn't catch any exceptions, but do we need to handle them if we don't throw any checked exceptions? (plus, this is probably fine, but it's still fine to just ignore them, though).
rename to file
Move this.deviceRepository( 'X') to a constant
Returning null here seems unnecessary. The caller never knows if the repository was not present.
Why we want to set the environment to null and let this assume it is correct?
Should be isEmpty()?
This is too much of a hack, it could be done once in the constructor, and then used in each callback for other decoration types.
we can directly use mapPointFrom(symbol, null)
Would it make sense to add check for double and float values as well? I'm not sure how much this will be called for every number.
This really isn't the right way to go. Use getLeaf() to get the refs from HEAD and getLeaf() to get the ref.
I think this is better than waiting on timeout, rather than waiting on timeout if the test fails
It looks like you can remove the paramsProperty variable and return paramsProperty directly.
Could we refactor these long and big if/else into a single line?
It is worth including the path of the file.
Does this work for all processes that have a 'equals'? You end up with two issues here.
use style provided with callback instead
this is important, but it seems to be consistent with other indexSpec implementations (getNGeometry, IndexSpecs)
Please use the create methods to be lower case.
This test is OK, but it looks like it doesn't use the new method.
nit: can you name the delta version as.
Throw a warning if lhs is not null
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
You forgot to update storageUsageUsage to storageUsageUsage on update.
Why is this being equals? If so, please make the comparison after the last updated date and include it in the hashCode.
please rename the variable. It is not used anymore.
I don't think you need the storageUsage.setInt() call here since you are doing the no-op.
nit: Should the delete table be added since it is already done in QuorumPeerConfig#createTable()
why not negate?
This also doesn't help much with log errors. It would be better to have a log entry before this return null, and in case this happens it would be null at the end
Instead of constructing a URL here, could use the String.format() method to encapsulate the logic.
It's possible that the user can't have random prefix. I don't see that it's used.
username can be null.
If we're fine with this if, do we really want to not use SKIP_REMOTE_LOOKUP as the command to determine whether a command has been sent or not? If so, then use org.hibernate.search.shaded.protobuf.generated.ClientUtils.isSuccessHandler() instead?
I don't think it's necessary to have ____TS(...) test separators inside the testAccessControl method, as it is doing the same thing.
This is wrong, the message should be localized
1. print the exception stack trace (e.g. "Not suggesting you found a policy" message). 2. Use the java doc that says what the type was a full class name, but a user can understand that (if it is a Map) was missing.
I would probably delete this change, it would be nice to allow the value of ObjectType.LaterRegistry.
We should use the commons-lang3 assertArrayEquals here (and in the following tests).
Just return here to avoid having so much "from interface" statements for our implementation details.
It might be a whole lot easier to just use logger.error() here rather than trying to report all the objects in an exception.
I would change this to trace or debug log.
Please use lambdas to make this more readable
why do you need the similar for the test?
Is using mAdConfig here make sense? We should use banner size that returned in VungleBannerAdapter#getSupportedAdSize().
findbugs will tell you there is a NPE here... as Jenkins.getInstace() is checkForNull
Why would we want to catch the exception in?
Add this to Set.
this is probably the same as the original test. Do we need to set it to true or false in the test?
Warn log level seems to high for a normal state transition.
ignore case => don't build this screen.
Trivial: missing { and } in the if. (should be moved to line 69)
Should not change this file
I think this is a lot slower, but it might be easier to read if it is defined as localVariable.getParent()!= TokenUtil.isOfType(TokenUtil.isOfType(node, TokenTypes.class.getName()));
Please extract block in GoFormatting function
This works, but it looks like all the old methods create a new one. Can you also call issueRequest() instead?
Isn't this always true at this point?
Let's use a local variable here if the parent has a item, currently there is no need to set the variable.
getOrDefault?
I think it is better to use try-with-resources here to ensure the stream is closed.
This creates a new object, which means that the previous one is not used. Please keep it closer to what we have in other parts of code.
Minor: if body is null, then body can be named "request!= null".
unsubscribe is redundant here.
You can also assert the return value of the method.
This should be here in case we have one answer. So we have to make sure that we have executed something on the case below and if there are any failure, maybe we should remove it.
I believe we could have a singleton register(TokenTypes.class, TokenTypes.class) method which would instantiate if default handler is the same as register(TokenTypes.class, TokenTypes.class) and register(TokenTypes.class, TokenTypes.class, TokenTypes.class)).
Hi @xupyprmv I think we need to move the code of the Chose to utils, like java.sorted(Comparator.comparingDouble(TableReference::getValue))
In the future, waiting for the status would be better.
This is wrong. You shouldn't be building the data if the item is an item or a data function.
I don't think it needs to be in a order.
Interface appended to variable name
minor: Line before {}.
Place in ApplicationConstants instead.
Add a check here to verify that the broadcastSerialDataReceived method was not called.
Hi, Don't we want to separate the complete task that created tasks?
Could we please provide a method in BackupSnapshot that checks to avoid logging and throwing an exception in case of failure?
This is unnecessary, you can remove this check <LINK_0>
I think you can take the word "quit - Print" here, in case of Jenkins output so it doesn't bring anything to stderr.
Response is not closed if code below throws
Ideally it's right to split the test. Lets not repeat this.
Is it ok to remove this?
a random column name can be misleading. Can you check withDotSupport.getOutputName()!= null and use a different result instead?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
couldn't this be handled via a similar function as the ValueValue?
don't use an external library (test)
Needs a space between if and (
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior.
I think ConflictException is better for NotFoundException and not ResourceConflictException
Navigating again...
Presumably you're trying to stop the test.
Use Assert.assertEquals
Headers constants are always not needed. Do we need such logic in the Init case?
You can use StringUtils isBlank.
If job state is CANCELED we will not cancel job. This is a breaking change I'm still not sure about this.
If the value is same as bonus values in the enum then this can be removed.
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
Why the extra local variable?
There's no need to do this, since RollingUpdateOpFactory is thread safe
NullStage shouldn't be present here?
Not sure why you dont close the repository here. Commit commit is supposed to be returning false if a commit is already marked as commit but it is not commited. Or just yet to make the commit message more explicit?
Not a property that open source HBase or Phoenix recognizes.
Typo: Somehow an extra 'And' got introduced here
this should be Assert.assertNotNull(nodeName, 0);
Pry would leave the method in MainActivity like this, which is a bit of indentation.
Have this return map(imageProxy::getImageProxy) instead? It's not clear what the method does and what it does.
This should be a stimationsObservedRatios
The name of the method would be clearer.
Generally we should be using GTK.GTK4J instead of GTK.GTK4. Here it should be GTK4j. There is a simpler way to use it using OS instead of Windows. The reason is that the call to GTK.GTK3.14.13 instead of 3.14.0. If there is no specific reason to use it then please remove this in these lines: if (GTK.GTK.GTK4.GTK4_FAIR_VERSION_NO_HANDLES) { Cairo.open(cairo_meta.ca.ca.cairo_18n.cairo_18n.cairo_18dp); }
I think that the previous code should be after both if and else if (activeImage!= null && other.isRunning())
We might want to make a constant somewhere instead of this literal "col" here.
Is this the purpose of the last check intentional?
Not sure this is worth the test in production code.
Can we do a tmp variable instead of calling a tmp variable?
Not sure, would it make sense to have this in a finally block to ensure that messages are sent even if an exception occurs?
no need I think. iccRecords is null always if uiccProfile is null.
On second thought, should we be checking this when the isDeleted is true?
move test debug log
why not reuse tempVar from line 63?
Can we just do return (buf == null) && len < off; in the try/catch block?
this block of code is identical to the new method, can be removed
Minor: Please remove final
If you change this, you should do without the 'if' below - you should just return immediately.
I don't think this is good. If you extract to a method and also use it, the Externalize will not have to do the action.
this line is not necessary.
Could be removed, InMemoryBlobStatus.getParameter(key, ERROR) already does that.
And _can_ use ==, to be consistent.
This is barely readable, since the menuItemView is a map element and not for OfficeView. I think this is what you want, and you can just use the given class name.
Should be exchanged.
Why not use the enum?
Please use generics properly: List<Map<String, Object>> nets = new ArrayList<>();
Just pass in the constructor into updateTimeSince method.
Strange. Why not just have a null-check?
Can't that be shared and therefore constructed once in configure?
Can we make the use of streams here?
This should be before the switch from the previous line.
Same as above, but using Guava's Splitter instead of Joiner and extending the same QuotedListItem to produce an object of T via a method called like T parse(Object). In this way you'll have the knowledge of quoting inside the QuotedListIem only.
Maybe reformat SQL here
Could refactor this if block into a function.
if.newIntValue() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the switch entirely and just do prioValue.unboxInt()..getType() is more more for when you want to query state system/attributes we do not know anything about.
This reminds me that we should probably deprecate this method in favor of logError. Error message should be localized.
extract to local variable
add if (streamPosition >= null) {
we don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
ooh, I would have probably missed this.
Ok, better to use the [FileUtils.writeFromRestCalls()](<LINK_0>
This looks odd -- you only need the widget.getRoot() method
When the reservation you made a member of this class, it can be assigned to the resource field directly from the ResourceNotAvailabeException field, you can use the class from here and on line 1047.
This should probably be return ((key instanceof UnixSHACryptPassword) && ((SecurityUtil.ENG_US)!= null && ((AbstractPasswordImpl) password).getKeySpec(key);
should this be info?
IMHO this should be DEBUG logging.
I think this is unused, can you just do "should"
did you mean vmUpdateVmTemplateHandler and not the other way around?
Can we assert the contents of the date of one day with some of the methods for the tests? Otherwise, this test would fail without the changes where you create one, but the assert statement will pass
Can we simplify the logging a bit? Not sure if it is useful in this case.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getTaskPaginated" or something like that. [![rule](<LINK_1>](<LINK_0>
Should it be a void method rather than an instance?
Probably should be some log warning message here identifying the value was not convertable
How about adding some logging if it's never truncated?
change to error
minor: you can use CountDownLatch.await(2, TimeUnit.SECONDS);
Capture of arguments and some metrics can be factorized.
What is the difference between this change and the existingSearchLoader?
Update the error message to be more generic
What is this test supposed to do?
use a Readers.nextOfType(PartitionStateBindingConfig.class, (int) objectNumbers[i]
Should it be closed with try-with-resources?
UnchangedCommitMessage -> assertThat(info.get().get(), is(sameReference))
do you use orElseThrow(...) in the new code
We need to say what is the size of the message.
I think we need the second protected conversion?
This is not necessary, just get closed in the breeding method. A local map can be used to avoid reading a lot of autogenancing time.
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling. IMO this will make bugs less likely.
why not String.format?
There is a smalicious exception here.
Shouldn't this be make it  activity.getHost().equals(userId)?
use this? and use it later?
Please double check if it's really needed.
I prefer fail-fastso first == 1, but not strong feelings
What is the reason for changing "a" to "b"? I have a wonderd it is confusing to me to use "b" for the name as a result.
please add specific error message for this action
Exception?
should we log a warning here - the exception's message is different from the exception here?
Shall we use debug level here?
Can we put these messages into the Builder?
This would be much simpler if you extracted a method of the Activator.log2 methods
We should check the size at this point in the ExprEval length.
I believe we can use if (mFabView!= null && mFabView.isAdded()) { }
Please combine lines 96 and 98 into one line.
Please make sure that "" is always the same as primary and not null here
If no executor block exists, this will return null which even with defaults below I believe would cause an NPE.
same under_score format for the parameter here IMO
This is addressed by <LINK_0> which is now fully acked, I'll merge it soon.
Isn't this the same as backups?
What about just returning Profile.SUMMARY_STATION.toString()?
Why this line?
Findbugs will have an findbugs issue - this will trigger it. Please use the following code: private String toString(String str) { String indexDesc = descDesc.get(str).toArray(String str) ); String indexDesc = descDesc.substring(str); if (iDesc.length() > 1) { return indexDesc; } else if (strDesc.charAt(str) == slash) { return ""; } return indexDesc.length() - descDesc; }
The name "result" is a little misleading. If this is not a user-input, consider creating the predicate and return it.
suggestion all exceptions are handled by the LeaderConstructor
Seed size with result.size?
Shouldn't this be: throw new UnsupportedOperationException()
I would recommend to also refactor the enums for these conversion methods to be consistent (to avoid duplication)
do not throw an exception here even if the company cannot be found in the method.
This can cause a null pointer exception when header is null
Use [file.set()](<LINK_0>
Yeah this is clearer. I'd keep the data.getFetchIntervalSeconds in the constructor and save it in the constructor.
Style-nit: The plugins are not very good, you're breaking things.
can we refactor this to be slightly more readable?
So if the user has entered the value of the UI, then the call to buildBranches() above will still work? Is that safe to ignore?
int enbale = 1;
I think we need to remove the previous final symbol since "final" will be not really sneaky enough.
Why has this been added? The other way around, we won't know the value will be null.
This probably isn't needed since the next statement in the try block is the same as the preceding loop above.
should be a print instead of System.out
IIUC you want to check!nextSplit.isEmpty() above first to avoid an extra.get(i)
you may want to not merge the new line. LOG.info("Skipping table {} because of {}", tableName, e);
can you append the storeId information in all log statements
Should get survey here
Should this be extracted to a separate method?
Shouldn't we change this? java private void handleContentRecovery(Node file, NodeContext buffer) { long size = projectAPI.start(); if (runningFile == null) { activatePlugEnabled(); } else { activateUnreply(start); startSimpleStartNode(project); } activate(); }
isn't this going to throw an exception?
This shouldn't be needed, as the method already checks if the handlers are installed and not the user-defined message.
doesn't this line cause any issues?
May be break here for ;)
whitespace
Should we rename to a variable name and the method name?
Does a compile function check instead of a compiler warning?
I think this is the wrong error message. Can you explain it?
isn't this supposed to be set by timezone?
Can we make this an enum instead of String? It's not a must, but for consistency.
where do you assert notebook is null?
Can we move the member creation to a class level method?
Could be rewritten with a single line
Can't we directly cast this into a map?
What about something like this: return (opState.getNodeStatus().getOperationalState()) && nodes.getHealthStatus()!= null;
Why not use getVm() instead of vm?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
This method is impossible to understand and review, full of casts and untyped method calls.
I think this check should be moved in the [AbstractRemoteConfigurationGenerator](<LINK_0>. Arguably you will have to do this check even if debug logging is enabled, but a minor typo would be worth fixing since it is a _also_ set of tests like this
all these exceptions have to be propagated to all the RuntimeExceptions.
please extract these constants
You may initialize the map in a finally block as it is no longer needed.
same here: could be decided outside of the factory
change log message to "The file was not found for extensions"
Can you extract this to a method? There is code duplication here.
[minor] This should be: if (response.getStatusCode() == OK || response.getStatusCode() == OK || response.getStatusCode() == OK)
should specify an expected exit code
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes.
Three spaces here may be a bit more readable, since it's obvious that the user that they need to use.
Need to add error message for the parameter here.
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
Might be worth changing the "final" to an empty collection as well.
Access is marked as @NonNull. It's not necessary to add the null check.
How about putting this as a incompatiblePluginMap.computeIfAbsent(incompatiblePluginMap.values()), so that the entry is stored in the map instead? That is, not the case for the Storage.
It's just a personal preference, but I would use java assertTrue(nextRun(cachedJob.isPresent(), tree.get().isBefore(nextRun)) so that we short circuit a lot.
Agreed that the method is not generating an image from the screen. This should be a bundle associated with the OpenShift Policy, not the Policy.
I think it is better to put this in a method, because it is not obvious what is happening.
I think that we should raise the issue only if statements.size() is true.
why not using for(i : i)?
extract this to a method?
LinkedList is not the right alternative, you can do just remove. At least in this context, you can easily use List<Object> instead of foreach. You can have a look at List<MoveDelegate>, and can be prettier with the reference equality.
So here you write it to the string, since this is the only new instance of the cookie object.
Remove (nit) "for (int)"
I think the method name should be refactored to be,
I think it's better to keep this one.
Use Contract.checkNull
Same here: if (PageProviderService.getService(CORE_SESSION_PROPERTY, session)) {.. }
given that we might want this list in the loop, I wonder if we could make this loop as a singleton and move this iterator to start and store the all the time.
Variable not used; please use it in these places and remove the hardcoded string.
do we need to also check if util.isNull() is false here? this code doesn't look like it's null that is ignored
We can write return newTrie.isEmpty()? newTrie.size() : new Vector<>(newIndexShift); It is more efficient.
Minor: "http" should never be null, since this behavior is optional and present in some other code as a default value (e.g. /ban conf field).
Needs to do this for the Spring Compass client and to ensure we don't have this code path
I think it would be better to explicitly close the connection here.
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState() > 0'. I think that this would be easier to read now but perhaps it's just me.
you could use log.debug("Non http request {}", session.getId(), session.getId()); instead of the else
Typo: context -> direct check
Instead of adding {}, move it to if (isValidImport(code, message)) { which I think is a bit better than adding the limit to itself.
I think this should be an interface (i.e. it's name)
Why do you need to cast to TracingActor unnecessary in the first place? Otherwise I didn't catch a change that would explain why it is not needed anymore
nit: it seems like it isn't obvious what the Realm instance is?
For readability, this is a long value, you should extract a variable.
This log message is a little misleading, since it is not a user's fault. I think the issue is that the user uses the name of the url.
Maybe we could move this code into KotlinMethodAdapter.findKotlinClass(baseClassMethod) and make it more readable.
Can we use a better error message than "Waited too much time for an external table?"
We could have another method which does this in theory, and does this still look like we would have a non-null language object. And if it does, the user would have done something like this: Locale locale = Locale.getDefault(); if (o1.getDisplayName()!= Locale.ENGLISH) { languagePref.set(locale); }
We need a timeout here because the test is now interrupted. Together with the message, of course, to be able diagnose it from logs. Something like: Thread.currentThread().interrupt();.await(); Thread.sleep(1);
Missing braces.
Not sure what to do about this. We get the stacktrace from the logs. Why is this needed?
This doesn't need to be a static import.
Since you have fixed the problem before this line, you fixed the initaitons() method in the DistechTest.java.
Have a "my" filter that would have been used for "p" and "input" names.
Won't this fail if there's an exception?
also do schedulerState.removeTask(taskId)
Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open(); try { } finally { db.close(); } As then the Java compiler can promise us the value cannot be null at use sites, and its clear what the scope of the value is.
Why this?
You don't need the else here. You can just return String.format("%s", UNMATCHED_COLUMNS,...))
You could reuse the method input[i].getFullName() here.
I would move this to a new method so we can call it totalTransferStatusAction(mSite) instead.
I like the.getNotBefore() call. You're changing the behavior of the assertValidDate().
I'm confused by this line. Is it really a draft change?
Should be trace
Line 74-75 are 116. Can you change it to a [MILLISECONDS.toSeconds(statusMsg)] + 1);?
The null check for otherStatus is not set by the other constructor, so it shouldn't be here.
I think it is possible to keep it without running other tasks.
We can't do the calculation, assuming there is only one row right?
Nit: The variable name is a little confusing, I'd prefer the original one.
This is more than 100 chars. I'd rather not use the constant here, like PROCESS_JunkGroupPrincipal group and the change behind that.
@yesamer Please find the variable name _is_ not coherent with the factIdentifier.
this for loop could be extracted to a function so you can just return the first awardAccount that meets this condition. That way you wouldn't have to have keep track of the extra accountToUse
Close the reader when you're done with it.
Use collapsing this, notpermutation will be true.
This is an example of the same kind of hack, would you mind to change the query type to be the 4th parameter?
Is this meant to be public?
nit: you don't need the local variable.
inline to the error message.
When does this work? snapshotFile?
Could you change this to something like: if (i.e. > "?i > "
WSO2
Why is this not a BeanFactoryChannelResolver? Although why don't you use a ChannelResolverUtils.getChannelResolver() instead any way?
remove.
These changes are not necessary. They are covered by tests.
The cast to MediaStore.Media.DATA is not necessary in this case.
can we get rid of the double spacings between click listeners?
You can put this into the try block.
I would like to see it as a method that takes the FQDN and the type of it would be nice to have it
multi-catch
Missing null check on the String.trim
This is not needed, as the models are not injected at the right level.
Nice fix! Could you please explain this change?
Does the test require to call this method if it is not > 1?
Can this go in RequestActionSupport
countUpTo is not required. You don't have to use primitives in the methods to avoid boxing of this object.
TypeSpec -> TypeSpec
This could be removed and the test will actually fail as it's not interfaces (and we can rely on interfaces): node.getFirstDescendantOfType(ASTField.class) We should also see the type in decls as in decls.
I'm pretty sure this is what was the reason to test with this: misLogger.getUUID(folderObj.getPremisEvent())
Is this condition always true?
I think this should be at the end of this method. Also, I am not sure this could be a simple iteration over the iterator.
We probably should use the default note here instead of false.
why not using moveVm()?
same here, please remove the getDeclaredConstructor().newInstance()
Probably worth doing this here.
suggestion bannedStopsHardWalksOptions = clone();
message is missing here.
This should actually be APIException, the + should be a, and the other part should be wrapped in new Object[] { } so this gets properly localised.
why do we need a separate forceWriteThread sleep?
I'm wondering if we have to continue using NIO buffers? @saudet Was there a reason for this?
I don't see the point here. This is what I mean: OS.yes:
We can put this on the previous line
Does this mean that if a node is above the quota and for some reason restarts, the config is not writable?
For a matter of preference, but I think we're missing a format (and I'mprovedSkyCalcMethods), because it needs to be the format check.
Is it possible for accumulator to be null, but not for (String : intervalEnd) { if (refLength < > intervalEnd) {... } else { final int refOffset = refPos - 1; if (refLength < > intervalEnd) { final long refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) { final int refOffset = refPos - 1; if (refLength > intervalEnd) {
This message is not always very helpful, e.g. if I set'sonar.python.version' (=child2e2e) === 2.7, and I get: WARN Error while trying to get the 'user:'sonar.python.version' (= 2.7). Versions: WARN Error:'sonar.python.version' (= 2.7+ now) WARN Error:'sonar.info' ( 2.7+ now) WARN Error:'sonar.info.error("Installing schema to use: xxxx.");
Can we set the default cases to 4 here?
If this is called before the disk is created, why not use something like: if (diskImageList.getDiskList()!= null) {... }
Throwing a RuntimeException isn't enough.
I guess it's not set for unit tests. We actually set locale in Main class.
Replace with "Exception"
The layout could be passed in the constructor.
can be replaced with forEach
Shouldn't this be inside NfsMountPointConstraint's logic?
I would prefer to not expose this map directly to KItem
we still need this logic if we are not doing wpcom sites
Since the true parameter is false, you could set it to true if it is null or empty, and let the user do 'null'.
assertTrue(node0.isReconnecting()) should be used a little bit to make sure that it is not in the right place
Shouldn't this be 'if (sideband) {'?
change this to a default: case> default: default: // do nothing
Just use display.setText here. It's going to produce a dialog to fix.
I'm not really sure we should do this, but we might want to iterator.next() and ignore some values.
what's the point of using builder here?
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
I would add e.getMessage() to this message.
this can be an 'else if'
How about the user trying to enable a hook which is already enabled? Also if there are no up servers, command should fail
nl and return directly
consider to use "-TMPDR" as a constant
the bug report has been added to the bug report in the core.
Typo in "crepoHttpClientBuilder"
I prefer this method to stay the same as the code above.
can we use writeAndFlush here?
Why?
why are we doing this?
Since RuleInfo#getDependencyGraph() is already called in E2E, should we move this down to the original method?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Is it intentional to not adding the following? if (Null.class.isInstance(path)) { return null; }....
project, why this file is not classpath? Would be simpler to use Project.Project projects.
Are you sure to keep those values the same as the set of items? I would keep them unchanged.
This should be removed
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return null; }
suggestion return output.toString() > 0? output.toString() : "");
@raver119 I feel like this should be in a util class of some kind?
Not sure if this is right. It's safe to compare to true in all cases.
use getId() since the node id is already known.
Add messages to the exceptions.
Not necessary.
Can you replace context.get(0) with (or at least getOnlyExpression()? It seems the old way way to go to the first one.
White space between if and (
I would have this loop in all the test cases: ccJudgments = testPersistenceProfileDivisions.clone(); ccJudgments = testPersistence(false);
* Is there a more specific reason for the looper to be serialized with other languages? * I don't think that it would be better to be null. * You can't just call parser.setAttributeValue(null, null, null) and * android.getAttributeValue(null, null, null); * <LINK_0>
Since you are creating a new service, I think it would be good to not create this class in all the test cases.
I always think the 2nd argument should be goGraphResult
This variable is unused
I think you can do this more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x -> StringUtils.isNotBlank(x.getValue())).findFirst().map(Field::getValue).ifPresent(metaBuilder::setAbstract(x.getValue()));
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes)
This exception is not thrown in the method, which is handled below. Wouldn't it be better to "throwExceptionIfResultNotOk" instead?
Is this the only line needed?
use StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(profile))
What does this buy us compared to removing? Since we do it now, I think it would be better if we add a debug log here in the future.
I'm sure you're getting this again.
At this point, you could move the initModel call to the modelModel into the queryModel, so the property can be set to null.
Shouldn't this be checked only in case cluster is secure?
didn't you simpler this to be for (Entry<Service, GlusterClusterServiceStatus> entry : existingClusterService.entrySet()) {
I would keep this in the test.
I'd apply the same style as above, as above, if learnerStream.localLearner is null then we don't need to have a null check
This test should be written as: assertThat(AvroUtils.isString(AvroUtils.isString(Schema.STRING)).isString(Schema.STRING);
Why not use the primitive long initialDelay parameter as the initial delay?
or just equals?
If this app is mutable, then we should use setImageDrawable instead.
You can change the behaviour of the saveFeatureData to a variable to remove the duplication.
I think it would be clearer if the value returned by the createValidRefundedRefunds were explicitly set to Refund_partialAmount and set the refund2 match. I think it would be clearer if the refund1 was set.
Use Rule-Encoding: java char[] entries = new String(byte[], StandardCharsets.UTF_8); out.write('\n'); }
We should use curly brackets.
The expected order is different. expected is always the same.
Remove the redundant check - preferredVideoUrl is null
I would prefer temporary file name instead of hard-coded. Most users may not want to use it in some random location. Or use newTemp.
It is not necessary to assert on expectedVersion.
We can't just create a buffer for each entry.
Might be good to wrap this in a log statement in case response is null.
same, extract constant
createOrUpdate is better?
Can you move this to method call?
Either move this to a Util class and call it infinite recursion loop
I think the exception should be logged and the user should see this value can be used.
Maybe there should be a baz property here that isn't included?
View::setToRelationshipGroups;
suggestion List<Principal> roles = new ArrayList<>(principalName);
Brace next to class variable?
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate.
I would check if this could be done outside of the constructor and have a static method in a newSourceSource that would make this work more readable.
We shouldn't be catching all exceptions, even if just one, we could.
We can have a test that verifies the expected number of elements is as expected.
I think this probably should be warn
Need to be version checked for GTK 3.6 or newer.
I would remove the final modifier and break here.
Is this really needed?
Is this a convenience method? Seems like we can get rid of the other the Builders in this class.
Can you please rather throw this exception? I think this would not be possible and wouldn't fail the build.
What happens if the app hasn't allocated memory? Should we cache the whole dataset in the DictionaryType constructor that takes keys and values? Or is this handled elsewhere?
Consider wrapping these lines, to make it clear what we are doing.
This should be a simple for loop - you can use baseLog for more than one
Lets not do this, but in the case of image loading, we should use the else block
I would check that Jenkins is not started before doing this test.
Do we need this check? I'd make srvHistos public and use "srvHistos" for srvHistos, which will cause problems with overall performance issues.
I think MISSION_EDIT_PAGE should be changed to be consistent with the other permissions.
I would use try with resources here, just in case.
mavenProject is a variable, why not just use mavenProject for foreach?
you can use the nfs profile entity, creating a new Object() method
wrong casting
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to be the same with and without it?
you can use this instead of calling createLabelAreaDialog.
please move the code below the initEmulatedMachinesNonOperational
I think we need to override handleDirectory()
Unnecessary when the string is the same.
throws BindingConfigParseException
Shouldn't this line be here java if (i.e. they are not allowed in the UI? If the user wants to then a newFitness name should be allowed... this could be a normal "This" case insensitive.
Use NUM_CASE
Any reason why this doesn't go to the main project? What if the child path is not a directory? Can you are getting a childPath and then using the nio path on the parent path here?
ImportExpr
Can you explain if this is a problem?
Maybe we could introduce a function that takes a List parameter, which is called with a double[], and then we can get rid of the lambda.
Why can't you set export to a variable called triggers, only in the context and call it in the finally block?
Can't we use parent.setClip(false)? Do we need to do in these 3 places?
Can c4db be null?
Is the check outside of the loop after the other.
Now that we check for empty set, which can be removed.
This could be a private function then in-line it rather than creating a local boolean variable e.g. Response.ok()? Response.Result::isHealthy(Map<String, Boolean> results) : Response.ok(); private boolean allHealthy(Map<String, Boolean> results) { return results.values().stream().allMatch(HealthCheck.Result::isHealthy); } I'll stop here since Oz has reviewed the rest. This isn't mandatory, it works and makes sense as-is.
In the PartitionVolume.setNumBytes method, the DataConstants is used for creating new indices. That would be nice to avoid it.
Why not mock the DAO to return null in this case?
Rename task. It's not used anywhere.
Minor: can move this line down to the top, with getUploadStatePartNumber() call.
I would name this file to be consistent with the other files
instead of duplicating the code, could you create a method, e.g., mapOwner.getRequiredProperties( (mapOwner collectionName) -> mapOwner.getNodeId().getUuid())?
can you make newPosition on the left and right after the layout? It could be turned into a separate function.
should be int y
I'm confused by this. groupBy.isIndexQuery only checks if the query isAggregationQuery available (i.e., is this the intended behavior?
This also doesn't work. The compiler doesn't auto-close the inner writer unless it's assigned to a variable.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "outside" of the if statement. [![rule](<LINK_1>](<LINK_2>
You can probably use assertFalse here.
I have noticed this test case. Shouldn't this be a different test check here?
We shouldn't put this condition in History.revealCurrentPlace() method. Let's put it in History.revealCurrentPlace() method and have it do the same thing.
path separator?
I would be more descriptive to have a method called redirect_redirects.properties file.
This returns an empty list. Is this intentional? Please put that into a constant.
We have an alternative, but we need to close the resource. I think we can just throw an IOException, otherwise we get an NPE in the old code.
You didn't execute this PR, but I think it would be great to have some test cases around it
This is null if userRoles is null. So it will throw a NullPointerException if its null. I think we should use StringUtils.isEmpty
What's the point of the switch, and if there are no rendering a label, we can move to the tooltip.
What about authorization?
Why do you need this change?
Do we really want to close the connection as well? It is a little confusing to me if I do. The other way around are used where this connection was created.
no need, please put it in configuration file at /usr
Remove the throws Exception?
Down it sounds strange to me that we do not need it as much as possible. I would _only_ put the DownDown flag into the if line, and not do the if with the if line night
This isn't checking that the disks store is the same.
Can we keep this list in the constructor and add the default productHasSubscriptions to the productHasSubscriptions?
Should we encapsulate this logic in a method, e.g., int qNameRefCount = qName.substring(qName prefix)? null : qNameRefCount;
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
used callback style instead
:bug: this is not a good idea.
Do we need to support all of the extra spaces as well?
Also consider using the same pattern about ByteArrayOperation.
A foreground and background color should be updated.
I think this is one of the reasons I chose to use the local result instead of a try/catch here.
This and the corresponding overloaded get is not necessary. Will explain below.
add a message to this exception.
Can you please wrap this if block inside the try block?
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
Instead of join, why not use java try (ByteArray.byteCountToDisplaySize = new ConfigSection(FileUtils.byteCountToDisplaySizeToDisplaySizeToDisplaySize, (int) entry.getSize()) { html.appendCellHeader("id"); html.appendCellHeader("mindSizeToDisplaySizeToDisplaySizeToDisplaySizeToDisplaySizeToDisplaySizeToDisplaySize(); }
I think this is missing else if's return a boolean. It should be easy to implement a equals() method.
Not sure why you added libraryProperties in code... Just do it it's very easy to forget to add new code :)
I would move this to line of the patch
This is wrong. You should just use the defaultPreferenceConstants.P_ISMARK in your other PreferenceConstants.
Should this be.toString()?
Is there a reason we are not using this: TextUtils.isEmpty(mJpSettings.jetpackProtectWhitelist);?
I'd avoid using toString() if possible. Could you please use org.apache.commons.lang3.StringUtils#isNotEmpty?
Please assign line 66 to  MismatchedTokenException.
We should not need to read test from the smartbase one. Consider making this a collection of settings. Use the default which is expected to be null (if no) and not null.
I don't know why this is a String?
We're using sub-classes of the same name.
Please retain the entity column cache.
The old constructor is still there, why did this need to be changed?
wrap this line
Would be nice to also ensure that the subject is closed at the end.
Can we re-use the overload here?
A good idea to not have the test for the case where the survey Id is created but the one we're never deleting.
Can you please split this up, not the 2nd argument?
move this line inside the if block below
Is there a reason to use the builder instead of directly passing a CalendarContract? This applies elsewhere as well.
prefer == for the comparison
I think!Stings.isNullOrEmpty() is more fail safe.
The closing of the int clause is unnecessary here.
Move this to the checkNotNull so that we reuse the list in the else.
I believe you have a link to the "main" project, which is "refs/heads". Can you use the same problem?
lookup for the view instead
This code has nothing to do with the new temporary storage lookup. Can you clean this up and remove the getDataStore variable when the store is properly properly?
I'm looking for an expert check on all these. The ones below are fine.
Why not try to use volUUID here?
can you print the arguments?
'hasViews()' can be called here, can you refactor it to a method?
Typo: > queryObservable.Function().extractStatistics(this::extractPathElements) as in query query
use filter() instead of findAny().
Should this be using a try/catch?
This entire method is not that much spaces should be in the beginning of the method.
I removed this code here and the one below. Why is it needed?
state is started but not stopped. Nothing can stop it if lookupName is already present
We are changing this.. here, we are adding the collection directly to the this.attributes method here, which is a bit confusing to read. Why not this.append(this.id) here, and we are doing the same thing?
Could probably take out this if; the null checks will take care of the case where these preferences don't exist on Lollipop devices
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
If this is in the if(!a.isEmpty()) or if you think there's a need for an else block to make sure the e.getMessage() is always called when the entry was cancelled.
This needs to be a log statement.
It could be log.info("{} seconds for {}", baseUrl, e);
I think a better fix would be to use an orElse(false) to make this 'banName', to prevent any side effects.
I know this was existing but why do you wait on that?
assertEquals(baseDir, "accumuloConfig", "mdir");
s/fsckOperation/hostedOperations/
Can we ever use the drive-by Comparator here?
ClassDescriptor::contains
If you're throwing an exception, don't you want to log it twice?
Why do we need to register the descriptor for the register?
The line 108-110 are going to be a heavy processing. Could you use a cache mechanism on the jsonGenericRecordConverter?
GraphQL can return response object. We should be able to query query directly from here (and in the next commit)
this can be moved into the warmup service.
invert this. java if (public Object instantiate(target, parameters)) { return multiInstantiator.instantiate(target, parameters); } return conver....
request can be null here
Asserting the message might make this more sense.
I think it's better to avoid comparing int with isBefore. The position is either 1. or 2. since it takes a long time since it comes after the first match.
fix all the places as above except GET
I am still not sure if this line is needed, right? So it is a part of the init mechanism. Is it possible to put it into ShortcutManager.INSTANCE.getString() method?
Why not define it as a constant for it?
add a method for index out of bounds?
Is the suggested declaration necessary here? If it's the same description could be added, as it's the method.
Maybe we should also log the keyIdObjectResolver as well?
I think that adding this check is enough, we should also do the same check as the original object.
Same here, break the loop
RexProgram#isIdentity(targetProjs, targetInput) is true but has a "rexNode" which is in use? I think we should be able to merge this method into a separate one.
@Serranya same here. See above.
you can change the message to totalSize here.
I would instead use assertEquals(s.head(name), 9999DDF) to check the current value of rows.size() == 2)
"Could not find item..." is a better worded
This orElse is redundant, since we probably don't want to catch it.
Is it ok, but it would be good to do newOperatorChain() here
I know this is not part of your change, but I'm wondering if we should perhaps use a RES_DB_URL constant here as well.
Again, good test
why do you need to check for null here? shouldn't it be getGlusterBrickByServerIdAndDirectory()?
I think these two variables are not used?
I don't know if it is possible to write this as if (stream == null) { event.getStreamId().getMachineName() }? I think it can be replaced by event.getMachineName()
Could you use.join instead of.iterator()?
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackErrorCount(e, p); }... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptLong) || (e instanceof PackFile)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePackErrorCount(). PackFile.getPackErrorCount() + " pack". PackFile.getAbsolutePath() : " + packer.getPackErrorCount(); } else { tmpl = JGitText.get().exceptionWhileReadingPack; // Don't remove the pack from the list, as the error may be transient. } StringBuilder buf = new StringBuilder( MessageFormat.format(tmpl, p.getPackFile.getAbsolutePath()));... }
You should be checking for null here, since the user already set it, there is a check there in the setCredential method before setting it
I'm surprised that this could not be null. It means that the field could be null, but to be defensive we should have.
Formatting
Could you add AUTO_OPENING_MAP_OPENING_MAP_OPENING
In the test case you are using.parse(). So each of these lines should be: java..then(new Object[]{4}, policyManager.parse(session));
Could this be replaced with a call to inMap.getAttackPower and the duplicate code?
The problem with the call to setErrorMessage here is that you still need to set a deprecated method. I think this code should be moved to a new method.
Don't use assertTrue(it.isPresent()) here. Use assertEquals() like JUnit wants you to. It works now that we fixed.equals() on RevObject. :-)
nit: I wonder if this can be simplified as: // NOSONAR should be enough for UnaryingOrder = new WindingOrder(); return new ReadOnlyteriorRingName(result);
I wonder if we should keep the null check and move the check in the same line as in MB.write.
We should only use the demotedContentT, so we could set it in the next layer. I think this section could be regen_entitlement
this message doesn't exist anymore, so the message doesn't reflect what it contains the actual properties
@jainxrohit We should have a method for this.
I believe we can directly use getSortExpression(1).getComparator(). And then get the PartitionByExpressions throws an exception in PartitionByExpressions where we still want to check that it is not null, right?
So we are defaulting to zero here? Or is this for clarity?
This should probably be renamed so it's not the parser
extension could be omitted here, please use VCFHeaderLines.setPropertyInSortedOrder(headerLines).
Type field is not needed anymore according to Sun's description <LINK_0> I think it would be better to leave it empty and make GWT IDE asking project type instead of hardcoding it. WDYT?
We could just move replaceLabel = replaceLabel("10px"); to avoid the "\n*".
Do we have to mark this method as private? I assume that it is the only real thing we should do when it is not public.
Log the resource.
I don't think it should be removed. We should assert that the mb hasn't been removed in the tests. Now, I think it should be removed. No one will assert that the toString() method does not throw an exception.
isn't this line redundant?
This could probably be a static constant
Use a LinkedHashSet here. It's certainly hard to understand what the code means.
We can divide int variable to avoid duplication of code by empty row to improve readability of code.
Do we need to keep this in info level?
nit: should be a constant
I wonder if it would be better to interpret a AudioManager.FLAG_MUSIC_AND_SOUND = true?
Shall we do a null check here?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Small nit, but, I think this is better, adds some logic to the OPT_STEPS field instead of just the OPT_NOT_FOUND
remove from here and the following lines
this makes the result of the operation, which is not what we want. I guess it makes sense to have the service, but this makes "hibernate" the problem.
I think it would make sense to have "my" as a parameter. User may want only to upload DomainDeployment and then assign it to several groups manually (or via additional CLI script)
how about TimeUnit.SECONDS.sleep(COMPLETED, WaitTime) for readability?
need to do that, otherwise the message is not very helpful.
nit: Maybe split this up a method since it's used a lot so it's more readable.
I would not use e.printStackTrace(), Log it properly.
Should this be : <LINK_0>
an alternative is to log at just one place with the error code.
Remove empty line
This should be imported.
this will need to be set to null. I would suggest we avoid using Objects.requireNonNull.
error message is correct.
The same here, you can return null
I would put these in the static method.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
I think this would be a lot cleaner with synchronized since the class is immutable. Can this be refactored to a private method?
Why is this method no longer being used?
public boolean contains(Collection<T> dataProvider, T search) is sufficient. What do you think?
Is this method used on line 61? If not, I would prefer making this a call to setChunkOperationComplete(false, true) and call this method directly.
can this variable be removed?
please don't add populate() on vms
I think it would be better to move two methods with a class such as PalantirContent.class.
consider adding a log on failure
Can we have an patient that has a patient has all of the patients?
Let's import static org.apache.commons.lang.StringUtils.isEmpty
move this check into the JobConfig constructor.
This should be removed.
Exception#printStackTrace goes to stderr by default.
How do you ensure that the workflow is in progress at the time of deletion?
if StringUtils.split(group) is true, it will throw an NPE.
Need to close the connection in the finally block
are you sure you need credentials temp variable?
why do we check for size > maxDataSize? It should be either -1 or ignore the size.
StateObserver?
assertTrue is redundant here.
Who else is using this? It does not seem to handle the exception.
What happens when we log a message when we're executed here? I think this method can log parsing errors from a job job. ( tran.commit() it doesn't have been executed) The message of the job won't be executed. We need to log this line here.
This should be immutable
SysMutex magic: [CLASS_NAME]
I think this method is too much java private static ElasticsearchTableDescriptions(...).stream().map(ElasticsearchTableDescriptions::getElasticsearchTableDescriptions).collect(Collectors.toList()); We can keep that public void parseElasticsearchTableDescriptions(...) { Map<String, elasticsearchTableDescriptions = new RuntimeException(java.util.concurrent.Callable<ElasticsearchTableDescription>(metadata)); builder.put( tableDefinitions, JsonCodec.class.getTableName()); Logger.debug("Loading elasticsearch table definitions from %s", tableDefinitions);.put(tableName, table); }
Can you put it with the tank contents to make this more readable?
The difference between this is that the GradleDistribution.useGradle() is called above where it is called (createGradleDistribution) this is called?
I read this method only once.
This is a breaking change - we don't know if it is safe to call toString() on the format of the exception. We're going to Type to be a breaking change here.
This check is not necessary because you will have two statuses with one.
You may have just used int[] blockEnd = block.getBlockSize();? Otherwise we'll have a problem in cases where the new byte array is allocated.
It would be great to have a local variable for the second parameter
Did you mean to use a generic VCF_ header expectation here?
Use try-with-resources to ensure that close is closed even if it is an instance of IOException.
Left over?
no need for the "if"
Shouldn't content length of 0 be excluded from here?
It is confusing that the loop in this method is called requestRemainingOperations, but the name of the operation is not used. Maybe we should add the following sentence?
Not sure this is the right way to do this: if (m_parent == null) { return; }
Please remove checkstyle related changes from this PR
This should be mBannerView.load(). This is what the adapter for that banner-mode is doing. I think this should be mBannerView.load().
No need to delete absolute path when getCanonicalFile() == null?
The journal is a bit confusing. It seems like a generic indexSegment. Maybe the indexSegment would be better named IndexSegment?
@ivandalbosco I think this is probably easier to use (for the same reason) instead of compute a list directly.
Consider setting this to true instead of false.
try-with-resources
I don't think we have to revert this method, but can we make it reverted as soon as token is accessed, or use total?
can the new code be refactored to use the existing code instead of duplicating it here?
The methods addAndGet() I'm not sure, but I think we should use a counter instead of a 0
Just flipping this and adding the third child if it's already known to us.
suggestion throw new ByteArrayOutputStream(APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML,
please change this to: version = Objects.firstNonNull(version, referenceDatacenterId);
Why do we need this change?
Add problematic host to the exception and also add the reason why can't. Because he has no privilages to use this hostName.
That is not a really nice change, but just an iteration over the set right here.
Should use the same logger syntax
Single pass is needed here.
Can we use a hashmap with the size?
I guess you should return directly after the logging? And please log the task as well, so the admin knows which of the 10k jobs the log is talking about :)
I'd change this to use the null check instead of the next line.
should this just throw an exception?
We should call refreshBounds() in case of an editPartOperation
This is also suspicious, I guess we shouldn't need it now.
injector.getInstance(defaultClass)
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only if getVm()==null
Make this into a variable.
Where is the host 'disallowed' coming from?
I would suggest changing this to ONLINE API and this line. That way any other status code can only be ONLINE once this method is invoked.
You should check for the total number of media-s, and increment it later in the loop.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
Let's move this to the block, since it will be closed in finally block anyway.
Move this into the try block and remove the finally clause
Similarly here; it looks like other questions are asked
Typo: 'dir' is 'No such directory'.
Can we use dpr for this?
Please get the instance name from bigtableInstanceName.toGcbInstanceName(), if it exists.
nit: I think the'removable' below should be changed to something like: java log.warn("{} - Unusual\n"); This might be better to avoid the concatenation with the braces.
suggestion i < argumentValues.size();
NIT: we should use JenkinsUtil.getModLog instead of VersionNumber, it will allow us to override Jenkins core.
Use lambda approach
Same note above about missing curly braces and relying on a a default-constructed ReferenceSource applies here as well.
I would say that we must be able to set the host name to a different property. Otherwise there is a risk of breaking some of the relative paths.
You're missing a try/catch here.
We have to make sure we have an instance of BriefcaseException. I'm not a fan of catching an IOException here.
nit: same above about assertThat(cache.getRegion("region"));
Looks like the check can be simplified by rewording the method to return a boolean.
isEmpty()?
Do not need the System.out.println. ;)
F.map(r -> i.getBoundName() == null ||!columnsToMoveColumnsToMoveColumn(..) ) {
define final
Why not simply use the same MTrimBar here?
This sleep doesn't seem to be necessary.
Should be a call to check for the size of the array.
Logging should be done in a logger.
Define a constant in SdkConstants instead of duplicating this literal "Exception" 3 times.
how about storing the results in the local history table?
Do we need a assertFalse() assertion here?
I feel there is a writeLock logic in this method. I would have thought that.
space between -1
Why is that moved down?
Why the null check here? Why not just use BbAdapter.create(Directive) here, or striveElement?
This variable should be named expense.
you can use FiltersHelper.Constants.HEADER_PREFER here.
if it's no longer used, add it, please? :old_doc_
I have a look at this PR.
Why don't we log something if debug is enabled? Seems like a kind of warning.
Throw Exception instead of returning null
you can ignore these.
Why on earth do you use a LinkedList for this?
It seems to me that this method will be the same as the first line - which could be something like line.charAt(i - 1) == '\r')
I think this is a behavioural change that getContent() returns null
Please remove the throws.
This logic looks wrong. (Yes, already before your change.) Shouldn't this be else { closeFailed(); closeMissingProject(monitor, new SubProgressMonitor(monitor,...); }?
Let's only use this type when logging is not supported. No LoggingUtility.logError()?
This can be replaced with the diamond operator (of type List<Integer>)
java if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { try { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } catch (Exception e) { expectedResult.setExceptionMessage(e); } } } I know it looks a bit spaghetti like, but at least it is more readable
Can we have a method on Patterns?
The message should be: "The file cannot exist. Do you want to have a.shown?
exception, so STDERR
Values seem to be of a particular user. Change them for notNull asserts or something that can be run by anyone.
space after "if"
This seems unnecessary
We don't want to convert to String since it is a RuntimeException, but we should be able to remove the System.err
Make this constant at the beginning of the class as the variable.
In my opinion like this is a good candidate for Util.isAvailable() since it will return null.
Suggested to pull hasLower/UpperBound and lower/upperStrict logic outside the predicate creation (create different Predicates for different combinations), to make applyFloatBoundAtaring a mask.
Why is this done? I think it should be final.
You don't need to change this line.
you can check that c.getVdsGroup() is not null
Rather than return all the special case, I would prefer to return as: return ancestorStatements.flatMap((Function<? super T>) ).filter(c ->!isSimpleReturn(c)).filter(c ->!isSimpleReturn(c)).findFirst().isPresent();
Could we put the invocation on the remote line before the return?
There's no need to use a boolean variable, can you change this to boolean isAllowedConnectionType = false;
If a user calls setHeader in the response does not get called, then we should probably at least have a flag that tells whether there is a way to validate whether or not we should do it.
I don't think it matters in the future, just the name of the file should be renamed. If you want to keep it consistent, don't need it in both cases
You updated the port which is good - can't we have the hostname be localhost as well?
I was thinking.asText().toUpperCase(), but it doesn't seem to be used everywhere in the library
can we handle this by using the ExceptionUtil function?
Can you use that?
When the thread is interrupted, it makes sense to wrap this request in a loop and use the complete() to signal where the thread is interrupted. A proper signal would be to wrap the InterruptedException in a loop. I don't think the thread needs to be closed properly when a new request is generated.
This step is same for standalone as well as domain ;-)
Please move the if condition to an top of the method, so that it is called only once.
Why are we setting this flag here rather than the previous if statement?
Looks like this will copy the duration.major until it's been older than 0?
This is very fragile. How about adding a assertion to verify that the link is actually inserted into the array?
i'd prefer a constant for the arithmetic of comparisons with Character class.
Group0 is not the same as the previous one, we can just assert that the group is actually the same as the previous one, and we can verify that the group is actually returned.
Why segmentReplicatable() instead of server.getIdentifier()?
"if (index.size() > 0)" is redundant
use s.o.
Please specify why this is again: Also, and now it says "public"
I believe the logic should be on the method instead of checking for anonymous inner classes.
I think that we should not have protected methods ("symbol!= null") as only one of these are possible.
Would be good to add a log.
Please revert this change, too. e.printStackTrace() may help debugging, but I think we don't much need this.
I think we need to wrap the node in a InboundTransferTask at this point.
It seems like this line should be called from the PostsAdd callback but not from the next one.
This name is misleading, it breaks the source. It's the racy limit, but could be passed out from the future.
You can use TestUtils.assertContains instead of assertTrue.
in different implementations it might be better to use ByteBufUtil.prettyHexDump(msg)
possible NPE
This bit can be factored out into MultiModel, and reused below.
Any reason to not use the file name here and not FileText?
This variable seems not needed.
The field type should be dest
style nit: final Date dateToString = new HashMap<>();
I think you need to be extra back to the original code: context.getBindingResult();
Could we please add @Override annotation here?
valueOf is never called, why are we leaving it as null?
The app supports multiple users? If not why need the parameter? Also, could create a default method without parameter where internally could call getUser(1) something called as getDefaultUser().
nit: Exception -> IllegalArgumentException
@essobedo use Boolean.TRUE.equals(scope)
nit: drop the map?
getId() should only be called if the object is not open, so we should check the project name here.
Change it to List<Commit>.
This could be replaced with java return aliases.stream().collect(toMap(identity -> new ArrayList<>()).add(editorComponentAlias));
Why is this covered? I don't see any tests for it.
As mentioned above, here we have 2 options: 1 (string field)
This change shouldn't be necessary. Set already implements the interface "Set" it?
use actualMatch.isEmpty() && actualMatch.isfy(actual)
Consider using complete actionMap instead of the rawActionID
Overall HashSet logic? Just to confirm: If it is unused, / is set to "Translate".
It seems that the code (vs.a.b.v) should declare that this will never happen, and the method above will throw an exception if none is found. If that's the case, shouldn't we handle this case?
Why is the ArrayData?
do we have more than one segment? (Which is a more restrictive?)
we also need to check that the errors is empty. I suggest to use the same, we also check that they are not empty. java if (isEmpty()) { return empty(); } else { return empty(); }
Won't this be the line below? If so, likely it would be worth at least one Linerary
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is not is the biggest obstacle why we didn't have autocrlf.
Should this log at error level?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
I am just not 100% sure why the conversion to BigInteger is needed here.
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
Use assertEquals(lockManager.getLockManager(), greaterThan(0));
Can't we use sSelel?
Shall we use the same logger syntax for all exceptions?
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now). Would there be any drawbacks to always returning them?
Could use Assertions.assertThat with a useful message
We're changing the %02d value for any type since it works for any type. It works for me when I got a String.
you don't need the.length() == 0 check, so use the first.isEmpty()
This should be here too.
Shouldn't the == and!= be replaced with ==?
should be Log.e
Why not just pass the entire FileSystem object to the subdirs? This prevents a directory from deleting one file from the target directory.
this method should be private
synchronizing on synchronization across threads
why is it necessary to dispose the repository here?
Could you please move the test with the enum value? The test is going to pass with the expected value, so it would be easier to distinguish between the two kinds of enum values?
You should freeLock after the transaction is committed.
This is often used in several places, I think it would be better to use a constant.
Except for the purpose, you should use String.join from the toString method as well.
I think this should be the request.spec().get(0) and not request.getVersion()
Could this be caught and handled in the else block?
Keeping timeColumnName is not null. Let's keep the format final.
suggestion long immutableTsLock = TransactionSupplier.getImmutableTimestamp();
Can we avoid it?
This is not a good use, as you are only adding the new operations to the existing operations.
This method is not used right?
It looks like this will stop asking for updates in every single string. Can you believe that this will also get compiled name collision?
Should have all this parameters in the same order (it's references in this PR!), so it's easier to track down errors.
what are you trying to execute when the parameters are parsed as well?
The reason why you did this is sodd be appendd to the same if the resource filter is created only when you have a Closeable Filter?
Style-nit: Remove space before closing curly bracket.
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
Just use!secondaryIndexes.isEmpty()?
As we are moving the circuitBreaker.getMetrics() and circuitBreaker.getName() to another separate variable name, I think it is cleaner: java circuitBreaker.register(name, circuitBreaker.getLabel()); circuitBreaker.register(name(prefix, name,'prefix)', circuitBreaker.getName());
what does the device mean? do we need to log this?
style nit: no braces here
This looks a logic change? Is this correct? If this is a bug fix send it in another PR and update <LINK_0>
here might be interesting to test the lower case here. Also, what about the conditionals here?
extract to constant
nit: can we make this a public static final variable in order to be consistent with other methods?
So, here we have the same logic as the component already in the underlying WireComponentTracker?
The port number should be set in the test.
Consider adding all the googleId attributes and the new one as well
I don't think recording data dataLoadTime looks useful.
@ptirador why this one should be removed as well?
use assertFalse
Writer are not closed
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> position conversion
msg
Can you move these asserts into the same class?
How about changing this to getHttpRequestBody? Should we set monitoredHttpRequest to jmx as well?
nit: this should be o, not object, right?
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local variable.
could be moved to a level since it's being used for anything else
This is not used.
Log this condition.
getQualifierType() can return null, and the null check should go in the separate method.
Is this correct? Why the return type should be an enum?
mobile.openArticlesWithPagination
It would be better to handle exceptions in the event that the user can see both data points, but I think continuing to run the error code just to avoid the event.
Since we are creating a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via rest call.
What do you think of returning null rather than returning nothing?
suppress warning (unused parameter e)
Might be cleaner to set the local time zone to UTC, or make it configurable.
Why shouldn't this be in BLACK"?
I think this change broke your test cases, can you have a look please? Also while you are at the tests have a look if the others are still working.
any reason to put the close() method in a finally block?
You can use a constant for this.
use a constant
Logging and throw is imho an anti-pattern since the code doesn't have it.
Why is this used?
What about such a volume data type? In this case it would be clear that the value will be skipped when an pod data is created but the volume is still open.
should we add this list of pipelineConfigs, just the links list?
I believe we do not need to use Rule here. Is test execution case handled by the previous line?
Why are we catching and ignoring all checked and unchecked exceptions?
The exception is not thrown in updateStackV4Request. Instead of throwing it and printing the error, can we just remove the return null?
rename'resource'
Any thoughts on whether we should also allow the empty string through this filter? (And exclude it from the filter below?)
Any reason for this? This looks odd.
binObj -> dip
i think you can use [driver](<LINK_0>
Please add code to avoid further duplication.
redis() should be accessed as static method.
Could you explain this change?
This seems wrong. Shouldn't we use the default block to create the service groups.
Extra semicolon
I'd suggest that the lock string in the end is a lock and in that case, for example, lockLock.apply(), and lock.lock()
I think we can remove this variable?
I'm not sure what is going on here. You are not using it but a string response body ;-)
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_2>](<LINK_1>
Could be useful to split this into Charge not available in ledger and Charge status mismatched so we will be able to quantity them by type (missing / mismatch..)
I think it would be better to move this to superclass
Do we need to call trim() here?
Why removing this?
need to use brackets here
how URISyntaxException is handled in places where this method is called?
use ArrayNode
not sure why you are moving this
maybe call onFatalError here?
This would be clearer as a system property, not a value (static) value, so the value is "aerogear"
rename to entry
use putIfAbsent instead of _size_
Can you please move this condition to the fetchCpuProfileValidator and remove the duplicate null check?
Are we not setting the account id?
Shouldn't we use warn here?
Did you mean to remove this?
Please consider to add space between "if" and "else if" (as it is more readable)
I don't think we need to add some basic handler here - when the consumers can handle this.executor.getHandlerCount() is the only place where the producer is received.
jsonMapper should never be null, it's possible for this method to return a non-null Map<>, so a null check is unnecessary.
this variable is unused
It's actually shorter to use brooklyn.util.newWriter to avoid copying the files
See if you can use.setDurable(102d)
objects cannot be null after the constructor. (write if (fTrace == null), you will get a compiler error)
please use ClusterUtils.hasGateway
Should we have a version of createHttpClients method that does this code?
Maybe change this to trace level?
suggestion TRACE_error("RequestResp:" + e.getMessage());
Maybe we should use logging instead of BatteryObject.
I usually like this, we check for purge and listFiles to not return null.
Why not use readResource-multipolygon and then set a default implementation of WKT instead?
can you please keep the former constructor and remove the static from here?
Instead of grealying you could replace all the code by [InputStream](<LINK_0>
datanodeCount?
Why are we not just added this here?
We need to change this to use 'toHash' instead of the hack
I would prefer to move this to the Broadcaster
[minor] Space before Object
If user has accepted selection of let's say 30 elements (without "Don't show this again", does it make sense to show the dialog again when unselecting some (e.g. going down to 20)?
This search could be added to the ComponentCategory.DESCRIPTION constant. Also, please add a check for "Unknown".
Suggestion: Can unrelated changes be pushed as separate iteration?
I think the method name is a bit confusing. How about something like "FeedItemItem" instead?
Why is ldapApiEnumeration returned an empty string? You can use for these cases.
Unnecessary empty line
This seems to be duplicated...
prefer Strings.isEmpty() to check for null.
!equals()
Suggest changing the creation of the metric name to "thPercentileLatency".
Perhaps a message like "Should not be able to get issue"?
potential NPE: db is @Nullable
Typo in exception message.
This is wrong, the first line of the IStructuredType == IStructuredType.class should be fType == IStructured.class, not IStructuredType.
Shouldn't we use getText() here, regardless of whether the view was added for the other view was changed in the strings.xml?
try removing this if will still be needed here
this should come after the volume==null check
is it necessary to do the split?
Agree with @DaanHoogland here. sysuptime isn't indeed now(), but for how long the system has been up.
formatting
Please use proper logging instead of printStackTrace()
You should have a toast here.
How about bring this to a method that returns the labelNames?
Format?
Why not try to use volUUID here?
Shouldn't we put the second part of the ifs before the if? I think it could be removed
A better way to understand if, why not to use append here?
Instead of removing the trailing white space, I'd recommend removing the else here.
Consider to use Objects.equals()
Just a suggestion, Why don't we set checkpointing to 1000?
I think we can make this a bit cleaner by using the code here, in the future we can avoid the need to do the trick.
forgot to commit the printStackTrace()
You can remove ".isEmpty()" variable.
Agreed. I think that you want to match the valid intervalExpression here, but not a list.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported and that method is unused, so both can be removed.
we also need to check if it is enabled otherwise we should load the native prepush hook if existing. Otherwise you effectively disallow using native prepush hook with jgit pgm since it always registers BuiltinLfs
- [x] Not required to check isDebugEnabled, because no heavy function on locale is provided.
Can't break early here. Wrap the next loop in a null check instead.
nit: Can we name this as well?
Using Long instead of long could open the door for returning a null object.
Log the actual steps: jobSteps.put(jobName, jobName); The notNull(status, "The job name cannot be null");
There shouldn't be logic in the Bean-classes, please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitches" class. Please consider, what the code does and where it should go.
I doubt this is related to the issue you're trying to make.
use -1, especially for rightMinPosition where Integer.MAX_VALUE could be seen as a correct value.
try-with-resources?
This is an unexpected behavior... if SSL is disabled, we should let the wildfly-dev become null, and we can rely on that...
You could use String.valueOf(proposalNumber) here instead of 6
This is not the case though the /this. prefix is a good idea, as the method is set in the trace properties, the trace is the 'this' and 'this' is not the class, so this may work as well (since you assume it is the case here). But it is not the case though, so you should be careful of having the "real" trace, if the trace is not of a trace, to continue the trace.
This will not be useful to the user, if something goes wrong, it doesn't bother to persist a data to the service. A better solution would be to wrap the code in a RuntimeException between the getStartedTimeMillis and SegmentId, since Memento#incrementLoadFPersists is only used to emit the stuff. It also feels like the semantics of the Runnable are not trivial and the code here is pretty much. One thing is that I would like to have a single place where we can use a lambda here and a couple of different places.
Remove the else {... }
Why divert and separate address is needed. Why not have the retroactive message under the original address? With having separate address will mean message has to be copied rather than it simply being a message reference to existing message.
nit: SolrInput or Runnables are a bit more simple.
Is this just a style nitpicky thing?
Other implementations of Comparable in Java don't even check for null, do we have to?
I think we could use just one or two separate variables for the test: java doReturn(client).when(multiGetItemResponse).getHits()).thenReturn(any(MultiGetItemResponse.class), any(multiGetItemResponse))); Assert.assertThat(client).hasSize(2);
are we sure that the values in the MockId are not 0?
Are you sure you want getDeclaredConstructor() here?
This should probably be 400, not 500.
Log using log instead of printing
Couple of things here: (a) we can use Preconditions.checkArgument here? ERO, this returns a boolean. The shape of the array might be replaced by throw new RuntimeException(e) when using getClass().getSimpleName(). That will fix the bug in the server conf and the distance of the method cancelling/fetching process.
Same as above, would prefer that we assert on the invalid list size (obtained from txClient) instead of on printed output.
> fromPosition = checkNotNull(distanceVector.getSize()).
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future.
Hmmm... I really don't like the logic in this method. I would argue that the function is not formatted in a regular expression.
what is the purpose of this line?
Is there a reason why we're gonna use this line instead of breaking it up into a method to validate the list, it is a check in the constructor.
I think we should remove this log and make it so that we don't have an adapter update
why are we using two different sortBys for the match type?
Is "Delete %s" the correct log message?
I think it would be better if you add a {} placeholder in the message, so you are not getting the full element in the message.
I would handle this in a finally block.
What's the reasoning for using a String here? I think that's fine to do that. substrings = (substrings) will still be more readable, so something like: (withTolerance(length))
Should we change this to info or warning?
Can we make this an Optional<Error>? So that we can't get to this code path.
I think this should use the new MetadataTableUtil function here, it seems that the Tablet for the metadata table info is the new one.
This would change accordingly, as well.
checkState
Thinking about the use of another refs/heads/*" and the refs/heads/*" are the same. Perhaps another caller could send the SUBMITTED_PREFIX too? Or does this consensus the other two tests use?
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
Please list the injected Instance and then use it in constructor.
Please use the variable name "input" - this is redundant.
StringBuilder.append(System.lineSeparator()) should be available since that's not a string.
I think this is fine. We don't have to change the logic here.
This would be better as an example.
@rhtyd when I see an empty lines, it would be cool to have it return rather than than threw. The exception's message is a bit odd and can be thrown from the request.
I think that we didn't set the method to be called for the data cleanup, but that's ok.
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
please don't use logger.debug("about to transform '{}' by the {}", substitution);
shouldn't it be <code>false</code>?
Don't forget to add this.
StringUtils.EMPTY_STRING
Please include the file name in the log message.
.getResident() is not guaranteed to return null
This complicates code quite significantly. Can you move it to a separate method?
I think it's better to have.map(attr -> colLenghts.length).collect(Collectors.toList()), and then print the next line
if we fail here we have a stale VM version in hand. we should roleback
Minor: Space between if and (
May be worth providing the exception type?
log.warn("Ignoring invalid row [%s] since parsing error {}", granularitySpec.getTimestampFromEpoch(), e);
Do we need to register a new eventProcessorRegistry for each event?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder().read(gcb.build()) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
I think we're doing this here.
Space between catch and ( Space before and re-add curly braces.
i dont think clear is needed, it looks to me its called only once per run
Missing space after,
consider using a mixpanelPushNotification.isValid() that checks for errors inside
Instead of manually building the query, this could be a little more shorter: java if (Objects.equals(sortField, SortOrder.ASC) { entities.addAll( sortField, filters); } else { entities = searchService.findAll(); } if (StringUtils.equals(sortField, SortOrder.DESCENDING) { // no need for the extra query } return entities; }
Isn't it a bug that the properties are set?
I wonder if this check shouldn't be in isDone(). Also, I wonder if it would be cheaper to skip the isDone() check and always return the result.
Should be in a finally block to unlock.
nit: should this be in the constructor?
I think s/r/taking/
should be or equal to oldStatus
Might the sleep be more readable?
The current check should be done above, not here.
While this is done, it's great to use a lot of tough action :wink:
Why not just always use map, and then we don't need to take into account the state system
This check is not necessary as it would have caught already.
not all code related to MPlaceholder, so a separate patch should have: int j = mPart.getParent();
@bxf12315 should we use printEvent("Open DeliveryCount:[%s], DeliveryCount > 1"
How could we get a null value for the externalFileTypeByExtension?
Why are we hardcoding the value here?
why remove this?
Why don't this just be o.get("id")?
The test should run in a transaction and nothing else.
I think it is more readable if/else block here.
java8-isation [forEach][filter]
GitHubCertificatess may be null. If so, it must be closed automatically.
Our toasts are nice - and you could presumably do look nicer. It would be cleaner for this... but we have an entry which might make it easier for people to do in which confirms why they need to set different answers - which arg is package private - and you can work for different people
This would be a bit clearer as a one-liner: if (bounds == null) { element = getChildAt(i); } final View child = element.getChildCount(); if (bounds == null) { element = element.getChildCount(); } else { element = parent.getChildAt(0); }
Maybe you should use BL layer name or not, like we have above in the API. If you need something only supports english then it should be okay to give user a full name of the user.
Should we still keep this project (the abstract projecT) query here? Or should we look for all modules?
Static import?
we can use a simple getStorage() here. (Can you use the field directly or just get the datacenter from the cache)
ContainerByteOffset is an internal method that could be used here, so it could be set to containerByteOffset
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
One more nitpick: can use an expression to test DelayedViewJGroupsTransport <LINK_0>
Better to keep this variable declaration inside the loop as it changes on every loop iteration. Having it declared inside the loop ensures that it's value can't "leak" from one iteration to another. This is different to when you have a variable that doesn't change on each iteration such as a concept. For those we should be using the final keyword
Please add a check here that can be null. Also please add a check (e.g. dataHandler!= null)
I think the code would be clearer if the number of rows is extracted into a method. (Note that it is also called twice in this case)
To log statements, rename the method to doOnNext and submit statement. This can be basically tidying up a bit.
@Dhhari isn't this test running?
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
Save an... --> Saved an...
This test and the test before would be more interesting if just the "includeData" parameter when building VariantMongoWriter is changed (now we are changing include samples too). If one of both is required, it should be made explicit in VariantMongoWriter (I don't see that check)
If you are setting the prefix _S_ with the name _S_!
This will throw an exception if the workspace is not a ws. I believe you should use a different name for this method.
I think it would be beneficial to use == for the check.
Where is the exception caught?
This is too long. We need to have a wait here, right?
link with the problem of dependency explained in MANIFEST.MF
[nit] I think we should rename these local variables to really make them more clear.
suggestion assert( constraint.isValid( Byte.MIN_VALUE, new ), isMax )
Why not to get it once?
no need for the.toString()
Was this change necessary?
AnnotatedTypeMerger.
We should not be doing this in a loop.
Add a line here, like we do in the case that the process is empty, but this will actually fail, because we don't want to throw some exceptions.
Just to be pedantic, I'd prefer using <LINK_0>
log.tracef
I think there's no need to change this behavior. Why not just return a builder's return type that is specific to the given return type?
Since you are testing the callback on the result of the test, you should probably define it into a setup method.
Looks like you dropped the 1. Do you need this? 2. Create an external server with a basic auth string in Authenticator.setDefaultProxyHost and it will just print the appropriate url on the login machine.
Any reason not to use collect(...) instead of manually adding the entire collection?
if (StringUtils.isNotEmpty(request)) {
UndefinedDatabaseException should be handled.
Use new BlockRealMatrix(shape[0], shape);
@dskalenko yes It would be right now that we rewrite this new logic in [AST generic = DiamondOperatorCheck.this.
This seems like an executor. Why not use the Timer.alertEmails?
you need a null check here to ensure it's not null.
This would be better to be in Utils. testConnection( userAgentHeader)
Why did you call req. Getting file when exception is already at the end?
suggestion var myField = new InputStreamReader(new InputStreamReader(conn.getInputStream()));
Isn't EMPTY_COPweight.FLAGS_C == false?
"vault.isEmpty()" seems like a bad idea, because it is not possible to return a filename, but it is not supposed to be the default value.
Unhandled
Why not return Collections.emptyList()?
do you need to clean this stream() here?
Aren't you not showing up in your pull request?
We should make this way more readable. I suggest using execute() instead of iterating through all internal data only for one cluster
This is redundant.
Similarly here for the csv variable.
Throwing an exception here could make the code more readable. There are two options: 1.
We can use **collapse** method
same here as above.
Can be asserted on a function function
if(list.contains(folder)) {... } else { // Move the above line to it.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported.
Since realmName authorization-realms has been injected, you should use realms.add(authorization-realms); instead of addOperation()
equals() should be compared using hashCode().
Formatting
awaitRetentionExpiration(1_000);
Should we define a public static final variable here?
Is this dependent on the computer's time zone?
Use Constants.HEADER_VERSION constant
I think this should not be done in every request.
add some static import for String.join() methods that you can use here instead of constructing a new String.
It's not reasonable to use < coins, so you don't need to be touched. So I think this should be declared in <Shared> < coins, so that the whole <layout> <layout> < coins, so you would be touched.
remove empty line
Why apply the conversion to JSON here? Why not apply it into one place?
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in a way that's loggable.
null check
Not sure if we have a test for this.
You should do LOG.info("Update injection for this injection.", e); instead of printing the message yourself.
Same here - [x] Dead code base (where you modified the responseParsed..) to re-use the whole string.
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either data has been fetched from MessageInfo? Should nt that be an internal exception type?
Missing final
This looks like it's impossible. Given L68, sampleRateIndex can only be 0,1,2 or 3 here, I think? If you agree, can you remove this block (and the TAG constant near the top).
It is getId() of the pool -- see the other Tracer invocations
If the topology container has been removed from the list, this check will not work. I think we can just iterate over the map. Then the check is done in that order.
You can use just "int" and save the repeated value.
Rename this variable too?
I think it would be better to use the getClient() method instead of get()
These second binding are in sync. We could even pull the resource loading to a field.
minor: change exp to exc, since this is also done for response status
Can this code be reused? If I understand correctly, key location could be passed in. Ideally, we shouldn't be passed in.
remove
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
Don't change this just add spaces: if (vote == 0) { return...; }
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
I think it could be isValidOverBlackListPatterns(input).matches(input)) instead of isValid isValidPattern().
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException))?
shouldn't we check the return value of the action?
Here is the same. Needs to be set to "is" + foreignAchErrorMessages.size()
Use static import CUSTOM_DATA_SCHEMA and CUSTOM_ENTITY_DATA_PREFIX
Please change the variable name as well.
please create a java project named "Project" so that the project folder can be deleted too
Probably want to keep this warn level as well.
This print stack trace is useless in some cases.
null check after the cast to GuavaGroupReady.
Why the message?
It's strange that we could introduce a new boolean variable here for the following statement. java final boolean isToBeOwnerId = routingTableUpdate.get(); if (deletedSyncs.containsValue(oldOwnerId)) { // previous line would be updated without setting the boolean field. }
This timeout is longer than 120 seconds. Travis will terminate the build time (except for the case of a CountDownLatch). I think that tests are still fine. The test won't run, if the exception occurs before the test is flaky. I would prefer to open a second test that tests as well and to guarantee that the shut() call might return null.
final
Can we have a test that verifies that checkEvict will always return false?
what I don't understand is the the else clause in line 437 below? Why is there an else?
What kind of messages are different. Use messages.toArray() when there is more than one element.
Is it future-proof to look for the second element? In the future couldn't equals be payloads.length == 0 is not needed for readability (as it was originally originally compared to NPE).
typo: you have two "if"s To avoid such typos, please copy from the config directly. These are quite hard to catch and we'll need to catch them.
nit: you could use assertNotEquals instead of == operator combined with assertFalse, == does not work properly for non-objects. <testing
When do you need to set the file path to the long?
Magic for HTTP, not for HTTP, but for HTTP servers
The oldFile variable is not used.
I would move this to the catch block below. The original catch block is a bit hard to read.
This is fine. If you simply ask the dmo field from the plugin, you should use scenario.getDataModel for the view.
s/public//
May be separate into two lines, like this?
Here you can use UIModel.GitModelWorkingTree_ID_SUFFIX instead of hardcoding this value
nit: if (value.equalsIgnoreCase(Calendar.DAY_OF_YEAR)) { Code style.add(Instant.now()); }
why is this inside the if block?
:bug: ditto
If the option is not set to true, this code will never execute. I think it would be better to leave a check here.
Instead of typing "A, B" I think you can just use B" here.
Should we put this as the default value of clientConfig.getPropertyAsBoolean()?
I'm not sure we should pass in null, but instead use awaitTermination()?
no need for this local variable. at the end of the method just return true - if you really want to keep this (and the following if statement can be simplified) java if (!shouldOpenSSH(userId)) { if (shouldDoAction(EngineMessage.ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_ACTION_TYPE_FAILED_INVALID_PUBLIC_SSH_ACTION.equals(userId)) { return false; } } return true;
It seems that result is false by default.
Why do you wrap it with an ArrayList and not just return registry.getContent()?
Means there are some helper methods to do the work, that may be needed to be (if these wanted to be enough). The general point I've been trying to avoid hard-coded TimeUnit names, and use a constant for that, for example, in Util.getTimeInMillis() returns a seconds.
Yuck. hdfs = new Configuration(config);
I think this should be more for UI testing. Open trace, open the view, make sure that it is the kernel module. Or you can use @Test(expected=...)
We should probably use the separator for the slashes in the /stor/multipart string as well.
Could use assertFailureFromClusteredLock(...)
Move this condition higher
This would throw an NPE if the variable is not null.
Should be listener.fire(new IEventListener(args));
I guess this is an unrelated change?
This seems to be failing compilation.
Extract some method here. For example, handle the exception as a second argument.
can we rename the string -> docId for more clarity
<LINK_0> is the right place to put this back the stacktrace in a method.
Does this need to be inside the view? The outer if (layerName == null) { view = 'child'; }
Can you please indent the throws?
WARN is too frequent here. Ignoring warn in the log below.
name1 -> poolContigues
This close() method seems a little wordy. Would it be simpler to have something like: java try { // 'apply()' } catch (RuntimeException e) { // Exception here }
This logic should be in a try/catch... What's the difference between this and the try/catch?
shouldn't you check whether the enable value is true or false?
This should be outside the if block, as it's not used in this file. Do we want to continue to use this dialog?
Response is never closed
This should just be config.getCheckIdleInterval()
This probably isn't needed, unless we click on it?
We could keep the other fqdn and use checkNotNull(code, "code of %s must be null")
Better use the spec.getSymbolicName()!= null, in order to avoid the current implementations of the class.
timeoutSeconds is too long?
c instead of t here for Connection?
Has this 3 any relation to the one in Schema?
I would add this line before line 134, so we first fetch the LunDisk and from it we will fetch the lun.
1. you should be able to use getDestinationVds().getCommand() 2. you have to check if vm is null here and if it's not a VM that is not up - the vm is down. 2. you have to check if vm is down
I would prefer to have this as static final and refactor etc.
should be debug
The only thing I would do here is: TypeResolver.valueOf(String)
Should we still start the activity if the search fragment is not enabled?
I think it would be better to use a StringBuilder here.
Just put this line in a return at the end of the method. No need to check whether transitionIt is empty or not.
Doesn't compile.
Shouldn't there be a mismatch between the number of records taken.
also PORT_name?
java vertices.getStateTimestamp(lastChanged, job.getStateTimestamp())
Why do you need this? Should not you use the index type above?
The indentation is wrong. Won't this also work well when the string is not found?
I know I'm not part of your code but I think I'd be safer if we just stick with the default "customParagraph" and put in the map. But I think we really need to rename what we just do with the name of the map to something like map.put("customParagraph", StringUtils.replace(getServiceName(),corporateSurchargeMsg(charge)).map(String::toString)
You may just write maxRetries, which will throw an exception if it does not start with a null?
I think we want to use the timeout here...
Use assertEquals instead of size.
I believe this should be Objects.requireNonNull(slot, protections.getCharge()))
nit: I think we could use fragmentToByteArray.write(message, FRAGMENT_OFFSET_BITS)) to make the parameter optional.
Shall we not send the offsets object in the loop. I am not sure if it is better to remove the logic.
Does this result in an extra branch that should be added to the above cases?
ObjectUtils.tryCast(expression.get(expression)));
This should be: LOGGER.log(Level.WARNING, GWC_CONFIG_FILE_PATH_WC_CONFIG_FILE);
This could be a static method
Minor: I'd personally prefer moving this inside the switch block.
Maybe store the metric type in the metric?
ugh, blocking ALL insertions while you're iterating on the whole thing to do a query would be a huge slowdown. There needs to be locking in here, but it's really something that would be abstracted nicely in a separate "BufferedBlockingQueue" class.
do we really need to return true here?
remove useless blank line
Use %s rather than %s
rename to child
I would suggest moving this before the try-catch to a function.
We should log this properly too, if we need to know if it is possible to do in one format (error Unable to connect to any remote endpoint).
Can you keep the type of exception as the second argument?
What are your thoughts on using assertArrayEquals here?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Make sure you put the pci_0000_1b_0 property here.
This should be a test error.
I would also check the line length 1.
This block can be removed.
this should probably be an ImmutableList.of().
Same question as above
How about leaving this a bit more readable? I think that should bar be shown on the screen screen.
name should be local.
String fn = 'this' is not used?
![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
@omkreddy can you make this a bit better and simplify the code here a bit? Something like getCode() -> CatalogResponse.ResponseMessage.SUCCESS.getCode()
As far as I can tell, difference is not just anything. It is either an error or a RequestLifeCycle for a specific handler. This will be in the request, and the request handler will be created.
I think it's necessary to make the same issue here.
no need... you will end up with profile.
acquireLockInternal() should be here only if acquireLockInternal() is called above
Construct this dynamically with a reference to the enum value for the error code instead of hardcoding 28
Just use Objects.equals()
fail
This one is not the place to use brackets.
minor: I think it is much better to have an explicit test that says what the expected node is? This is a test case.
1. Let's take the opportunity to use iterator.remove() instead of hasNext()
I think we need to check for a file name.
This is entirely pointless, mDevice is null anyway (not initialized).
Please have brackets around the body, at least in case some HTML Title (like _br ==)
This is not a test, the ticket is failing but the user is not able to see it.
This seems to be a no-op if the validation fails.
suggestion private void MITSearchAdapter(getActivity().getApplicationContext(), mitSearchAdapter.getDefaultSharedPreferences) {
same here, don't need to get the IDs across threads
Should this be BasicDBObject instead of object instanceof Map.Entry?
this is not needed since you are using the sprite.indexOf(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.get(sprites.
Same here. We want to move this to a separate private method.
Cache this value.
Formatting: should be at the beginning of the method.
This would need to include other things in the directory. Extract into a separate method?
Need to catch the exception and handle it properly.
A better fix would be to use a different converter for re-use.
Please correct the name of the method. You can look at other param types in parms.
See my above about upstreamInfo.getUpstreamInfo() - we should remove the "host" prefix from upstreamInfo.getUpstreamInfo() to.getUpstreamInfo().
should we make the "start" object a static variable as well?
The first arg is not a type, the second arg is used.
maybe make util interface?
Line break must be at the end of the line.
Is it actually changing the name of the call to NONE?
nit: The arg is String.format, so no need to make a new line.
Is it possible to keep the old log of this exception?
Where is this debug logged?
This check is not needed; it's already done in the super class
This and the next two lines can be removed since we already know that it is not null.
I think this should be a period, and no exceptions are thrown, right? The message should contain the expected parameters and the message, and the list of expected parameters.
Can this entire map be: java "@OnClick".replace( "project", state).addImport("com.palantir.logsafe").addImport("Authorization", that.getLogger())
Shouldn't this be Set<EClass>?
For consistency with the rest of the library, I would use Util.springframeworkParser to grab the BAD_REQUEST from the library and use it to JSON parser.
Shouldn't this be done in the @After method?
Avoid "a" and use a logger if possible.
can be removed
Was this intended to be a static method? If so, then this method is intended to be used outside of the loop.
style nit: we don't use braces around single line blocks
I think this will break on Windows. Please use a try-with-resources block.
I don't think this will work if the quorum of addresses are part of the range of addresses. The mapped index was somehow changed, but wanted to point out that we should consider the min-max-mind range (the-server-location is a bit skipped), as we don't want to provide any ephemeral addresses for their first range.
Shouldn't this be factory.generatePasswordSpec(filtered)?
Something wrong with this (or without the finally block)?
Can you use a StringBuilder here?
I think we should remove the RealmCache.getKey() here, and instead use cache.getValue().
Why the list? It looks like you can just use a stream from the returned list.
I think the cmsAdminRole can be null, meaning, if the cmsAdminRole is null or is a CMS Admin Role we return all the role information.
Thinking out loud, wouldn't it make more sense to use the file creation time, or the last modified file time?
@vilchik-elena Shouldn't this be >= 1, so you can enter the constructor for this case?
I don't think we need to throw checked exceptions in case of skip.
You can reuse method in super class.
So it may be more obvious to have the user the two organizations end with only one?
This looks like a constant value that can be used to avoid duplication
I am not sure why we need a captor for this null check. Returning null here seems a bit broken from an empty configuration, but can be simplified by using a matcher here.
I don't think this is the correct approach. You should have both a Container and a known loop. Then it can load the instance of the class and use it.
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think it would be good to validate other definitions.
We should not use single thread pool for this case. This is needed.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.apache.velocity.exception.ResourceNotFoundException' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>
It must be registered for workspace-binding event
Why empty line?
Just one small nitpick: move the 3 lines up and return null after the if check (and save the preview)
Can you use a more descriptive message?
Duplicated code. Maybe refactor the common part into a method?
Remove the "this".
Please do not change this. This is a public API and it can be used in other places.
Can you close the stream on the finally block?
move this line before the if (headRef!= null) branch
If a "No" header is next, the next line will be executed directly. Please make this line a separate method to help readability. Something like: private void next() { if (opNotEOF &&!opNotEOF && footerBuffer == FooterBuffer. The code is duplicating the row...- not necessary after the footer.
This should be context.get(UUID).name() for consistency.
Are we sure this is not going to make the map more than once?
Instead of passing a NewInstance as I think we could just use the same ValueExtractor instead of casting here.
For consistency, would it be nice to use the same engine partition as the one used in the driver?
Method code can be extracted here as well
Why do we set this to null then pass it into the builder?
@original-brownbear isn't it performance problem? shouldn't it be done in the FileRouterFactory?
I am reading the class again again and I think we do not need sourceIndex to be consistent with current column name. I think we can keep its scope just in the for loop. Then I think the only usage of sourceIndex is in the loop.
It would be necessary to have indexIndexerClient = createIndexerMapper(indexer); this testIndexerClient.addIndexerNames(indexer1.getName()); this.indexIndexerClient.createIndexerMapper(indexer2.getName()); can be moved to @Before method, and remove @After from @AfterClass so that it can be removed
The MiddlewareQueryException is a runtime exception, so no need to track it.
How about inverting the condition for readability. java if (status!= null &&!status.startsWith("Pulling from image.")) {
You can remove this part since it is no longer required.
please rename variables variables, it is confusing to read this variable called localModelDesc or something.
Shall we just log the actual account id and the actual user being logged in?
this initialization is useless since you already have the API to fetch the object and to do this in a @Inject
Not worth changing the commit for, but this could also be replay(command, request, backoffHandler, cache);
do we need those booleans?
move this to start()
The existing code is throwing an exception if the entry is not actually loaded. Wouldn't it be better to wrap it in a try { } finally { offset.index = new Indexed<>(index.index, position); }
Please extract this repetitive code into a separate method getBlobKeyFromRequest() or a separate method to make it easier to read.
The OnlineCommandContext: operation.remove(batch) method can do this without a sync operation.
I think the name should be enough to construct the cacheComponentRegistry.
this could be collapsed to new Gson().withDto(paymentId.getAdminTitle(), accountId))
It's not necessary to pass the stream into this method.
I think we could make this a bit more readable: java boolean updateBufferSize = doMessage(queryName, initialResponseType, new QueryType_NO_LIMIT, U.id, initialResponseType, updateBufferSize ); Same for the other update
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "Optional.isPresent()"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
You are not present to the model but when present, please be sure that the name is correct
You should probably use stateToCheckAndEvents.isEventBasedEvents() here, because you don't need to check for event.getName()
Looks like a copy&paste error, should it be firstRecordExpression.jpaExecutor.getValue()?
This will not work if the user wasn't manually typed. But, if it is already done in the editor, we should remove the orphaned files.
We should also check if message is an instance of the MessagingService.
you can use lamba expression here too.
Can this be something like the following? GenuatedFileIsReadable
This is another example where this could be generated into a single method that does this: @Override public void toHtmlForAnthology(StringBuilder result) { return this; } @Override public void toHtmlForAnthology(StringBuilder context) { return new Builder(new Builder("cvrebert").append(StringUtils.nonNull(volume)) };
Object[] is not aPOINTER_SIE, we can just add a counter of the array.
Too long
I'm surprised you didn't use a lambda... :p
I think this may cause copying a Bmodification time
Is it possible for the vector to be zero? It may be worth checking in some cases (e.g., a RuntimeException or a bug in the old code)
Call.toString() on the new line?
This should also not be an error.
Must be Rule ATransitionTestBase to do this.subtype.add(new TargetControlledPermanent);
Please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
Shouldn't this be parentContext.getRoot()?
You can use the isEmpty() matcher here too
nit: Looks like it is UPDATE_IN_PROGRESS would be better
Change first occurrence to Set
Please use meaningful variable names.
Are we sure we want to un-static-ize this? Can't we get the trace from the EventDefinition?
can we add some util method to addLast so we can use them instead of having them two lines?
shouldn't this test be called "Test.operateOn()"?
This will throw NPE if the topic is not found, instead of catching it here.
I think this should be: java if (tmpEntity.isAssignableFrom(ENTITY_FE)) {.class.isAssignableFrom(ENTITY_SERVER.name()); } else { "killEntityStatistics".to(name); }
Missing { and }. ;
please add the actual values to the error message, in case it ever fails
Consider extracting this into a function named addBuyOrderToOrderBook or simply addBuyOrder.
We are not using kLayoutManager directly?
Nit: we can move this to a dedicated test method.
What is the rationale for adding this as well?
Can we name this something other than "error" or "e"?
rather than needing an ArgumentCaptor here, you should just be able to do any(onedDateTime.class)
These can be final and no need for declaring them beforehand.
nit: What is the setting here for?
I dont think this is necessary. The password is just a string, and also if the user goes to the player, we cannot access this entry.
please remove this one
ditto - is there an extra space between lastNoneroCharIndex and lastNoneroCharIndex?
we can avoid creating a string constant variable
schema can be null
Can we consider pulling this out into a separate method please? It's a long lines.
Can't you just add the if branch into the if block?
This is incorrect. If there's no payload, then the context is a direct byte array, then you'd still need to convert it to a string.
Always make sure to wrap the entire Runnable that you are scheduling in a try/catch if you want it to actually continue running. If an exception _ever_ makes it somewhat more data, the metric system will be running.
doesn't need to add a remove.
Should be assertCoverage(actual, expectedBranches), which keeps separate from the assert message.
please use a different name for the failure case.
Why are you comparing against type name?
No code duplication. Instead of isNotEmpty() and a new line, it could be replaced by isNotBlank(project.get()).overridingErrorMessage(String.format("gethasErrors() should return value",
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which are not being queried here.
just for readability, better creating a new method isReprocessDefinition(processData, properties) inside the AbstractSubprocess class.
For each refactor
Isn't this reporteed as a problem? I'm not sure we need to add it.
why did you change to final here? should be outside of the scope of the patch.
So I am concerned about this approach. It is a possible marginally more (renamely) but it might be worth putting this in its own try/catch.
Use Collections.emptyList() to avoid unnecessary object creation
are you sure this is correct?
I think this would be better done as two cases, 1) if profile, add it to both registries and 2) if package, add it to just the package registry.
I think the message needs to be updated.
(nit) space before if
This class has been deprecated by another one. Consider using new method which returns a setSabbaticalMemberEditor, so that it can return void. Also the same problem with the other two methods.
Rewrite as Map<String, Decision> typeRef = DecisionTable.getHitPolicy().resolveType( dmnModel.getOutput().get( 0 ).getType(); String prefix = model.getHitPolicy().resolveType( dmnModel.getOutput().get(), newValue ).getType(); if (model.getType() == null) { return resolveTypeRef( dmnModel.getHitPolicy().resolveType( namespace ); } else { return type.getHitPolicy().resolveType( namespace ); }
In the mapping you don't need to convert the map to an object
I like we can have a similar info for the processing in the IndexValueCapability directly, no?
This should be in the trace message.
Is the event being propagated to the Updater level?
Removed it
Since we're going to end up executing any locks here, I think it would be better if the following method was @Override public void acquireLock() {  sdLock.startLock()? getVm().getSharedLocks() : true; return super.acquireLocks(); } @Override protected void acquireLock() { exclusiveLocks.putAll(lock.getLock().getSharedLocks()); } }
Could you please add a log message here.
Maybe eventSeenAt I'm missing something here. At the moment I don't think we need to track this only if we are waiting for the event to be sent?
Can you use org.apache.commons.lang3.StringUtils.isNotEmpty here instead? It's more readable.
Using Charset.defaultCharset() makes the code more readable.
I don't think you need to explicitly rethrow this. Otherwise the log won't be printed unless you want to get rid of that.
whitespace is a bit off here
toArray
The logged in user is not logged because an exception's message is not updated
captor is not used
I would replace lines 82 and 77 in this block. It seems the code is easier to read if you were to use the reverse order.
This test is still failing for me, remove it.
It might be worth comparing with fullImageName here, with the same regex but with a quick contains.
.toString() is not required
I think you can use Collections.singletonMap(null, false) here to make the test more readable.
Could you please remove this line?
nit: remove the () so that the whole block can be replaced with if (this.getClass().isAssignableFrom(serviceClass))
Missing space before the curly brace.
Maybe we could use bytes to store the output stream in the message, like you did it for readData?
1. I'm not sure if we should add the storageDomains as a Set... 2. How about changing the check to a Set (if applicable add or not, isEmpty) 2. This way we will still need the memory domain feature so we can iterate over the storageDomains list in a single call to the templates.
Please always return I'm not a big fan of this. Use an else for the if statement.
We can't add the listener here. How to EMDeviceUtil.setOnSizeChangedListener(R.id.exomedia_video_image)?
Items.DEBUG
change the message as well
Is this test necessary? I didn't see it here previously
I think you should do this in the listener
I would prefer having a dedicated method for this close...
Unit tests for fetchThresholdBytes?
@vilchik-elena I would move this condition into the if/else to improve readability.
we should probably also write outBuf.clear()
I think this should be SftpServerRelativePath
Use logger rather than System.out
This is in the wrong place to use: bp = t.getMarker().getResource().getType(); and the "else" branching on the wrong line.
is that intentional?
since we are already checking for valueCount > 0 you should define a default instead of 0
sounds fine to me.
why start_ts is 1?
I think we set it from the encoding, value: <LINK_0>
you need to call finishAndRelease() on both channels in a finally block to fix LEAKs.
Why is this invoked for every test case?
RuntimeException?
Why not lift this logic in the try-catch block?
In all the tests, the trace is already opened. No need to close these traces.
Can use ByteStringBuilder
I'm a little unnerving, but I'm not sure the performance implications of doing this here.
Nice to use Objects.hash
Maybe its better to use capital stats
maybe we can make it a constant with a name like _IN_Watermark_ class and have it in the other package.
better to have if (timeEnabled instanceof DruidExpression) { inputColumn = ((String)timeExpression).getArguments(); }
Extract this to constant?
Is it possible that this returns null (or in other words, a selector fails to create a connection to the desired connection)?
Couldn't Granularities.ALL be used here?
Why did you change this?
why the final need here?
Please move this to the next line.
should it be log.writeObject(filterAndConverterEventFilter.values())?
free the lock in a finally block
We should not use the same error message here. We'll get a huge number of error messages for this, given that it's not a huge deal to know.
Since the variable is no longer used other than the one above, please remove them.
please declare variable in first usage
nit: Unnecessary?
What are your thoughts about tables being updated, which should be a list with a available index. Or maybe just the id in the index? I'm asking because the id is the same for index names as well with the index.
Add final keyword.
You can use a TreeMap here.
Should this be in a t?
Please rename the variable to just existingLowWater, because it is just Status
Why not use getClass().getClassLoader()?
.* and.*
I think this should be set to true otherwise the underlying error message might be wrong.
Because destroy() is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
style nit: no braces here
this code should be in a private method
Do we need to use the default minsec instead of hard-coding the default system property?
You could directly use runInternalAction()
members can be replaced with: parent.value().mapToDouble(' -> -> '))
can we reuse this constant instead of duplicating the string?
If the cacheMode is null (which is not), then it will have a NPE. Also it would be nice to use componentType.cast(new ExpirationManager(this.transactionMode(), cacheMode.class).cast(timestamp); instead.
Do we need to wrap in a TreeMap here? In general, is there a way to keep it as addAndGet?
why Pushed a read-only wrapper here? I thought that MergeModel would still support callbacks, so the need to be a bit more _only_.
You don't want to display the information to the end-user!
@CarlosGines bout could be inlined
no need to modify this, it is enough to make changes to the messages at the beginning.
Please break the line after if (accessTokenString.isEmpty()) {
Why do we need to call this in the synchronized block? It's only used once after the last delivery.
This could be a builder
There is NPE in this method.
There is already a ListItemButtonActionPerformer. Can we just use that here?
Why is it needed?
nit: use braces and space after if
Should this be in a finally block to ensure the iterator is always called?
Probably should be some log warning message here identifying the value was not convertable
Any reason for this change? Can't we just pass in the enum from the FieldType?
enumerated, this should not happen in the GSOC dead code. There are a single single element enumerated, this should not happen in the GSOC or do not need to add this piece of code there.
Please throw an exception wrapping the STripleException.
I love this approach but don't help. The reason for skipping these lines is because of a method in the code. I'll merge it I'll take a look at this.
missing space after if
Maybe we should use getAndSet(null) here to get the external response.
why do you need to stop?
lambda?
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.
Looks like this should be getSource() check.
rename to child
Remove System.out.println, duplicate.
better to use hamcrest matchers
You could use the map instead of collect() to do this more readable. Like: Map<Report, CompletableFuture<T>> result = new HashMap<>(); result.addAll(result.getSource(), format)
This can be a constant.
Instead of doing this, we could just use the existing getDefault method, it is more efficient. (And also replace all the changes in this class with something like: final ChangeListener event = new ChangeListener();... optional.ifPresent(state -> { c.setForceScroll(false); c.addAll(prop.getscreenWidth()); c.setForceScroll(false); c.setForceScroll(false); }); c.setForceScroll(false);
If inputStream would be declared as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
make these methods private?
can be blank
This if-else is redundant.
I suggest to change the order of these to member names, since they are static-imported by the components.
why BodyInternalTypes.AGENT_ENTITY and not BodyInternalTypes.AGENT_ENTITY?
the interface should accept a pin object directly here. no?
maybe should be a switch?
A better way to assert that the result is an exception.
If the result is true, would it be more obvious to use Objects.hashCode()?
After the change this assignments to delimiter is ignored, so the tokenized path is joined without delimiters. To maintain functionality, the whole for loop needs to be extracted instead of just the body.
Why is this needed? I think it would be really nice to have a special meaning of the timeout.
Can't we avoid this variable a bit of code?
Please use Verbs.gather instead of "Gather" here
why not just 'hasSize'?
why a file here instead of BAOS like others and before?
assertThat(linesOfCode).hasSize(1);
do you need to handle the case where the config is null?
Isn't there a possible race condition here?
if you are sure this is properly handled. I think it is better to leave the function empty and just return; and just use the code directly.
This also seems dangerous. Why would you want to set next to null?
You don't want to fire an event if the widget is selected. The model should be saved in the lower case.
I think we might consider renaming this to something like handleErrorDialog
This is not correct. Why not use ProjectResource here?
No, no expression. It is really assigned a value and property. It is just an id.
Any reason for using an Object as the method to throw an RuntimeException? Do you want to catch an Exception for any specific exceptions?
I would also add an info log that says that Killing is not running.
might be good to have more details regarding the key than the server (i.e. hashing the value and key)
Is testing for null outside of the for loop? or is it just a mandatory behavior?
Should we rename this method to handlePresToLike or isSave?
Is it possible to add a table name to the log message?
please check here isSetPmProxies() otherwise you can get it from the sketchy.
Nitpick: is there any reason to rename the variable to something else?
This is too verbose. If the rating l is enabled, the site doesn't get updated with the rating updates screen. We should remove that, and swap the USER_no_visible attribute from the site.
unnecessary else clause
I appreciate the centralized code of this approach, but i think it is going to result in all the pre-est file processing and all in this approach is going to result in all the pre-est file processing and all of the pre-est file processing may end up being a partial sharing. It may be hard to go with this approach without a larger code change
It seems that this will copy the entire RuntimeException message to an exception. Please use the method signature instead.
So if this is possible, this is split into two or more threads for the same query, right?
That would be nice to have some kind of problems ;)
Since you have to pass the entire exception to the log message, you could use JsonObject and JsonArray.class
@ikhvostenkov please name it just json
Could you please move this check to a separate method called 'ifField' and use 'focusedInfrastructurePlugin' instead of 'focusedInfrastructurePlugin'?
I am wondering if we shouldn't return an Optional.map rather than a map.
@vilchik-elena Hoiw about extracting code to a method assertThrows(StringHolder input, StrictSimpleDateFormat message, StringHolder input) and usage of assertThat(pattern.getValue()).isEqualTo(format);
move error log to condition body
If it's "right" from the extractWhereExpression, I think it should be moved to the beginning of the method.
nit: space after if
I understand this code is correct, but why we need to set it back in the original code, here it's correct?
We should avoid having to wait for the browser if the user comes before going through it to get it. That way if we needed to add the plugin number of plugins, we could just check it out to change it, and make it final.
As we discussed, this is the result of the connect file. Why should we set this as "" and remove the storageDomainForStorageDomainType?
Registration should be null, no? if so, Registration.Builder#build() should be created
Can you explicitly check that the columns are either null or null?
I'm not sure whether do we need to loop here? If the rowId is negative, we should not throw the exception, otherwise, we will still try to fetch the count > 0.
This will throw if the getUriMaker() is not null (line getUriMaker().getInputName())
I'd like to avoid calling get twice here.
nit: This can be taken out along with last line in if and else block can be removed (to be consistent with the IsNullConditional::generate method then.
I think this should be a Verbs.getMaxLength() right?
This line needs a null check.
I think this needs to be an improvement.
why not a more precise method like the following? action.get symbols() : null; if (dialog.getWorkbenchWindow().getShell()!= null) { return f.getConfigureSymbolsAction().getShell(); }
I think this is a bit a bad idea because you don't have to allocate a new byte array for each buffer. There is a small bytes between this and back, so you could create a private static byte[] buff(int buffer) method that does this work and you don't need to worry about the buffer being eventually created by a separate thread.
I believe appPath can be an empty string which will cause lastSegment() to return null, which then will cause an NPE. You can try this by leaving the program text box empty.
don't you need to pass the capacity to this variable instead of the full set?
Use the style here instead
Shall we change this to use MockSinkConnectorConfig?
Wouldn't it be simpler to use symbolInput.getName() here?
suggestion log.error("Couldn't open the schema provided by the schema", e);
final?
Minor thing: Can we move this line up with snapListSize and remove the "no" arguments? Do we need to keep the "no snap".
Style-nit: clear method name.
@lautarobock This test is coupled with the other parts of the page. Shouldn't this be ShareType.USER_Shares(file,ShareType.USER_LINK))?
how about having the else block in line 305? like this: if (DbFacade.getInstance().endAction(DbFacade.getInstance().getVm().getVm().getLeaseType()!= VmDynamic.getInstance().getVm().getStatus()) { log.warn("Attaching user from  '{}'", vm); } else { detachUserFromVmFromVm(false); }
Please use parameterized logging instead of string concatenation.
I would prefer to factor this out into a separate method something like createJsonWithStatus or so.
Isn't this check redundant?
Why not return abstract?
I think this test is still passing when the teh participantService is null. It's not possible to do an update for every account but then still pass.
Left over?
Can we be sure it is not a good idea to throw an exception?
Don't need to throw exceptions in the response.
this seems like an opportunity to box the number of updates to the mature data store to be converted to a specific method.
Can we use @Test(expected =GridColumn.class) and use this instead of doReturn(0)?
I think we should always resolve the target entity itself, as it might add some kind of logic to the context class. And it's only added to the new createBeanAttributes() method, with a static method returning the correct value for all the fields.
the new line is redundant, should be in the same line
Should we not be an ArrayList? I guess it's type-safe.
@cvrebert let's use this.self.login.remove() as mentioned above.
Please use Predicates.asl(p.first(v) for the more readable code, since the old code is stuck for a loop with an exception.
suggestion.orElseThrow(() -> new InvalidParamsException(e, "message"))
Should be 60000000.
Could you elaborate the reason for this case?
no need to cast to URI, just Map
I'm not sure if you want to keep this as is, but it may be cleaner to add a assertTrue(e.getResource().hasProperty(RDF.type, Cdr.Tombstone)); since the type is at the stderr.
Table name says un-zero name but it is partitioned. Probably use better name!
Again, please remove the System.out calls.
the log.error below this is going to go totally bonkers if the queue ever fills up; it'd be better to only print a log message every X events (similar to HttpPostEmitter)
Move this declaration of the variable as before the call to Expressions.startLocalTime.
There is a class called.setExtraEditText which will save values from a.setExtraEditText which will save you to use.
let's just propagate the exception
Missing
Can do this in one line
This method name is a bit confusing. I have not understood how it is called "request" but what if the index file is in the file?
if you're testing the same path as testBasePath, this is the same in the result
is this the same in BlockBigArray?
Why can't we iterate in this case?
Same deal here. Hibernate's containers tend to not adhere to the contract on.equals and.hashCode, so you'll need to do this: this.getPersisted();.append(this.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that.getReleaseVer(), that
nit: () -> long
I think this check will always be true here.
mb is correct?
if it is null we shouldn't throw an exception and return null. I would prefer the following if.
This should be done with setting of the fieldEntity.getType().
You can also remove the debug log / info log from these debug statements.
use TextUtils.isEmpty(k) instead.
This is the same as this one, could we simplify?
No need for the suffix on the class name.
Formatting from 2 places
Please, add an empty line before this and the for loop.
Catching an Exception is a bit wide and gets caught.
you should not be checking a single field type. you should assert the entire action in the schema (or any other field type)
Regkey.get(regkey) will never return null. You should keep it consistent with the rest of the codebase.
I think it would be more obvious to use this one: String name = (e.g. 'name', 'value = wsWorkunitsServiceSoapProxy.WUQuery(request); String name = mObjects.setCluster(clusterValue);
I'd add a WARN here
Can you please elaborate on why this change occurs and not sdroidDriver? It's only invoked at the end of the command.
can we catch the Exception to make it clearer that we are explicitly thrown in this method?
Why removing this? It seems like we should commit a merge from master branch and not merge.

Could use getImageChainFromDb().removeAll(chainFromStorage) instead of having CollectionUtils.subtract force conversion of imagesToRemove to a Collection, since a Set more accurately portrays the intent of the, well, "set" of images. :)
"config".equals(webNamespace) (probably better)
The config should be injected into the builder.
String.format may be needed.
Should this not be done in the property view instead of here? For example, timeout instanceof Integer --> Integer
Can you use CollectionUtils.isEmpty()?
final List<String> candidates = (List<String>) ((List<String>) ((List<String>) ((List<String>) candidates)).entrySet().stream().sorted().forEach(e -> add(t.getVocabulary()).get().toArray()) );
add break
Add space after catch.
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
There should be another exception here. Use log.warn("Couldn't find name for entity {}", entityId, e);
The RuntimeException isn't necessary, but there is no need to catch an IOException here.
@adrielparedes here the call for metadatastore
Same here, we don't need to add a variable for the filename.
I would suggest using new JSONArray() (we're not testing anything) java.util.List.of("nbHits", "bar", true)
rename to "Project" to "manager/wait" to make it clear that this is the userSession object and not just the session.
I don't think we need to log this any-time we have record. This is a private method.
This check is duplicated in TransposeTest on a MergeHandler. The for loop needs to be done only once in this loop.
Safer to remove this
We can put the check in doStart
Do you need the method.getCount() here?
Should these two try/catch blocks be moved to a method?
Could we send this as a POST request with a battery banner request instead of the app?
I think this should be after the first throw. We have a test case where we fail, but don't want to make the Locator the case where we are using the tags.
Split into two lines for readability.
If this is going to be simplified using the original StreamsDatum for you, would it be good to include the try/catch for the the lock to ensure a stream is closed?
Nice! I'm not sure if we should have a condition here - something like: checkArgument(partitionConcurrency).equals(newConcurrency("Gather exchange must not have partition channels");
shouldn't this be taken out?
don't need the else clause. You could use the default closing closing.
tab
So this is a "int" string for keys?
I think it is the default, but not sure if we should also add log.info("Started ", module) after the gluster service is started. It will also make sure to report a timeout of them.
else if you don't have headerButton.removeColumn
Ideally LocalEnvProvider.rewriteLocalEnv would declare to return a ImmutableMap since all of its implementations actually do so. Could you please change environment to ImmutableMap and use ImmutableMap.copyOf(localEnvProvider.rewriteLocalEnv(...)) until that is fixed?
I'd do this filtering before the previous one - it's much cheaper.
Please change this to: if (i1.equals(dex)) { return false; }
Just for consistency, see below.
Should be a constant
Add brackets
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
Don't need this check, just set the class variable for serviceInstance
I think this should be handled by a lot of different types.
I don't think the exception happened here. It is helpful for debugging purpose. You can set it to debug level.
Should be WizardMessages.eRoot
Did you take a look at this? <LINK_0>
Can you make this a private method, like the other one?
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
you can run this once and cache the result, no?
Same thing about append or output
IllegalArgumentException is a runtime exception, so it shouldn't be part of method signatures.
This is a bit of a hack. It may be better to use the class name for the class and have it fall through to the plugin.
You should use Objects.equals() instead of hashCode.equals(name, that.bits)
Please move it to separate patch and use it in two places.
Do you need this?
This is unnecessary, when the previous Venue object is used... The tests are ugly.
You are going to hold the out here after you next line. :-)
I think this should be isDirectory(), not endsWith(). The same condition is true, which you should check if isDirectory() above is true.
This is a list of disks, you should do something similar to what you did in BackendDisksResource.addDomainDisk()
why not just initialize the buffer to 4?
synchronized (LongJVMPauseDetector.class) looks like a bug
You could say SSE_C operations must be performed over a secure connection.
The parts of the code have nothing to do with reflection, could we do this with some other TODO?
This and the condition check is quite long. How about changing all the assignments to a single function?
unnecessary blank line
I think that this logic should be replaced with a simple set of _waiting_ items for the _waiting_.
isn't this redundant?
You can remove the this line.
I think you should support to have L106L112 and L11417.
I wouldn't import the file name, s/File.separator/prefix
How is it reset if the test failed before?
The code Precondition checks should be added since there is no message for it. So if you have to pass a valid error code and throw it will be better.
Does it make sense to have Test-case as a singleton?
we are still doing a while loop here, but we are only writing a state of a second param?
I know this is copied, but we should just use if else here
IDE says to use Collections.emptyList() here
@dustinpho maybe we should throw exception here instead of returning null?
Would it be better to use isFirstSite() here?
This blocks the client when calling the ArrayList constructor will create a new ArrayList.
you could here return the old one
You can just do return toArray(new Integer[0]);
Could it be done in configureRequest method? Seems like it could be a good feet if it applies to all requests.
Why not use the same code as above in the method?
Maybe its better to use interval terminology here, perhaps LeftEndpoint and RightEndpoint?
have we seen this error before?
do it in this PR and create a separate JIRA to track this?
Maybe you could set the listener on the trigger <LINK_0> and use the constant on the left side.
Move this line inside the if block so it's single line block
I think this should be a set, no?
This line is duplicated
should we use a SQL parser here?
Static import
Please move it to line 83 (this is not really clean)
LOG.info("Getting jar file from {}", tarFile);
why you not using setUpGetCertuficateExpectations()?
maybe an uncovered testcase that someone explicitly throws an exception?
I would recommend saving this value in a variable for readability.
Nitpick: I'd prefer having the check here whether hostProvidedPools is empty or not to just check for null. If that's right then we could do the check for null, and then only keep the check for null. I suggest to move the check for that to the beginning of the method.
MARKED_ROLLBACK, so that we have a lot of consistency of our code, awesome.
You should be able to use 'getStoragePoolId' and 'hostedStorageDomains' to get the storage domain from the storage domain.
Remove Braces so it can be removed.
This looks like it would be better to rewrite it in a try-with-resources block and then move it to the finally block.
Please implement equals() to provide debugging state information for debugging purposes.
And this one should be public.
final
Minor nit: I would prefer a constant here like a name that describes what is happening here.
Are there no other standard utilities or libraries that can get this information?
Could you please move the mockedRequestLogLine to the end of the test?
Please use the same test case as the other tests.
nit: this should be reader.getArguments() % 2 == BATCH_SIE
magic? extract to constant
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints.
Store the tree in a local variable, and use that here.
Should check to see if the result is empty?
Please use singletonList instead of + with "".
This change just caused me to fix a map and an error. An alternative: java Map<String, FormField> actualList = new HashMap<>(); mapFromMapFromMapFromMap(inputMap, new FormField<>(), new FormField<>(inputMap, actualList);
log.warn in default block is a good idea, but we should have case FAST_FORWARD_CONFIG.
I would change it to assertThat(updatedOrder.get(0)).hasState(order);.... The assertion gives you "expected" for all the possible values.
This can be removed.
We can use the _first_ComponentGenerator and _Optional_ field directly.
Looks like you're expecting to have the expected value?
I know it's not your patch but those 5 lines should be replaced by: grouped.keySet().removeAll(collection);
i wonder if 'interval.getIntervals()' has been changed from "minutes" to 'MoreMinutes' may be a better name.
if we should show this condition every time... We should be able to view the analysis.
I don't know why you can be versionId = "" can be allowed i.e. if(versionId == null)
Rather than getting a null value, I would prefer to instantiate an empty map.
why debug level and not error?
Would it make sense to return volumes with size -1?
I don't think this will work well if filepatterns is empty. Should we throw an IllegalStateException during call() if filepatterns.isEmpty() is true?
Shouldn't you close the stream in a finally block? Wouldn't that be better to just have a return statement here?
Do we need a separate function for this? Can we have just a wrapper function that takes a list of bindings list?
This should just be LOGGER.info()
The meaning of the constant is a good idea for -1 as the value :(
The same as for-loop below.
Well, I think if we follow the pattern of Java 8 you can do better than this, but I think it really helps readability to keep the code more readable.
you aren't removing duplicated entries...
Should this be an an utility method? Now it can be updated from multiple places, one could have a quick read instead of one?
Ah, this is why we are opening the liveReloadServer to avoid blocking the event. Why not use a new asyncReloadReload() here?
I'd use the instant() method here, and also use it for the validate() method.
Does this need to be final?
java try ({ gatewayPath}}") {
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count)
Why we want to fail such queries? Presto can still query from such table if we disable bucket-by-bucket right -- Also it depends on our configuration on hive.max-outstanding-splits-size right?
Maybe it would be better to use IntNodeUtils.getMetricAsString() here.
Catch relevant exceptions.
please use asserEquals for all the services
I think we should also assert that the range of values are correct. Unfortunately, since we know that the max_SCAN_ROWS is the same, it's usually set as the default to JSON. The arbitrary value is the "MAX_VALUE" (either 110_VALUE, or VALUE), since the default to INTERNAL_SCAN_ROWS is the same as the inner int value.
I would change this to res.load()
Is this method used for convenience?
should we use _a_simple_to_dateLists_ in a list to iterate through the values?
This consumer can be a static constant.
I think it would be better to move the verifyOpen method to the LedgerManagerFactory constructor.
The author in this file is not what we want. Please remove the word Playable abstract class.
Uh. I think the fix is fine. However, please move the fix also _when_ this is possible.
Please don't create a new exception in the log, keep the cause.
You don't need to add this here. The call to put in the OS file here. You only iterate over the processes.
Since this is important then we should have a test that validates that we never lose the error.
Newline before the try?
nit: This is really just a plain JavaScript function object rather than a functor.
== 0 should be replaced by an if (row.isPrimaryKey(i)) {
readInsertionIndex
Man, isn't it? Why this is static?
suggestion final boolean received = false;
Perhaps add a "create" here, since it's used in multiple places
Why is this being used here?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why DefaultsManager would need to explicitly be referenced? We allow config contexts that don't start with the defaults?
Replace with IProject.getDevicedProjects().
It would be nice to simplify the logic a bit by extracting the url to a separate method.
I wonder if it would be better to wrap this in a separate if (extractFieldsFromFilter!= null) check to avoid the extra lookup?
I prefer name bindDocClass because it is not a getter for itself.
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1). The behavior is the same, but it makes the intent more explicit.
Use getEntity().get(0).getStatsGameReports() instead of a List<BaseEntity>
Can be given a more meaningful name, like totalAndAnswer instead of answerOr
Same as above, please use warn.
Please do not use System.out.print. Please use log instead.
You can use a static final field that is not used by the consumer thread.
Is this needed?
In this change you just use message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.valueSchema(), record.setHeader(message, record.getValue()));
if we are going to do this, can we make it _this_ instead of tautious? The next code is creating a map with one value, which is pretty much the same for teardown.
Can you undo this?
This is not needed here.
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
format
If we're requested these 2 lines, we probably want to get them out.
Same here: we have a cache in the file stream that can be used to be reused.
prefer ==
use createSafeXmlSource here too
@Torenko Same here. You need to check for the unknown context as well.
We should be able to remove the file==null branch here. The only place where we have to introduce is if (repository2!= null) and we assume that repository is in the name.
Should be "lookup".
Again, please don't make recursive RPCs, use data from the ProjectDetail object.
ditto - I think we can use realmFactory.makeLaunchAndCompactOnLaunch(realm, RealmConfiguration.class);? It is the default logic but not strong feeling.
Could you please rename this to getInputStream or something similar
Could use BufferedReaderProvider.append(...).
remove method
Same here. Let's remove this line
The boolean flag should be set to true if the submit was successful. It would be better to use an exception that is thrown instead of deleting the in//origin/master
Use the first letter variable
Should this log statement be at the end of the method?
The.requiredString, not the value of the field.
I would wrap this in a try-with-resources, ie. throw new CRSDefinition().containsKey(parentCRS.getCRSDefinition().lastIndexOf(':'));
I find this easier to read as: java final InputStream stream =.stream().filter(first -> stream.equals(Object.class)).map(Object::cast).toArray();
Is it a bug that it's a key for a Multitenant? Maybe a switch-case is a more solid way to handle this.
You don't really need to declare this variable here. You can do setText(new Integer(SessionHistory.totalPoints) instead
We can use Guava's enum instead of the String.valueOf(maxToSelect)
A lot of value would be easier to understand if you changed the style and the other tos, as it is a bit confusing.
Should return replicationLoadSource.
This change will break the compatibility I think. And this is why we are not using SRC_MAIN as the default file name.
This pattern has been used in init() and it could be extracted to a common method. This way you can create the file in a shell that is used by TemporaryFolder.
I'm not sure it is good to have the method to throw IOException and rethrow as UncheckedIOException. Could be converted to PicardException
Can we change the variable name Beneficiiciiciiciiciici to use the variable name?
NIT: this is not going to be enough to have two diffs in one of these apps.
Here and below: Please, remove curly brackets for one-line statement after if
Nit: getScriptPath().getConverter() returns null, not getClass().getSimpleName()
Please reformat code according to our formatter.
I know this is not how it is related to this PR but perhaps a separate issue here would be better.
This is fine, but you might want to add a new method for this.
We actually don't need this, just filter out the range of timestamps
I think we should rather call the lamda here rather than this: java if (hasIdField(result)) { this.message = Util.INSTANCE.getDataObject(); } else {.. }
Should use EntityList.stringToClass(class) instead.
Is it worth a warning that the entry is an unknown (as it can be null)?
This is a great opportunity to rename it to function, I can see that you are using the result of sorting.
Could you use StringUtils.isBlank here (and in the other places)?
Why do we only show the questions when the _next_ item is cancelled? That seems overly complicated.
Why the issue results when a check is enabled? The issue happens with a solution for me.
what's the point of an explicit index?
I would recommend to add another exception message to the log, this way that the data is not deceptively broken, and is really not so easy to know what is going on.
Has there been a reason for % with %?
Here too, will break existing PR.
A bit of a sneaky way to strip the change where you want to push a change to the git refset to push back the commit. The big difference is that the test should be squashed at the end with the final refset to the semantics of merge conflicts.
Could you describe how many rows in the name does not match?
can you rename this variable to usePurapWorkflowConstants.e.
Same here, we can return the 404 from the Id object.
The last item is always the right.
I hope the event producers are not shared across the connectors?
1. Again, why not use 2.putShort((short)(q.length() - Byte.BYTES)
@ktoso What was the reason for this not getting caught by the implementations?
according to the original code the "vm" can be null here. Wouldn't it be better to invert that?
smaller than bigTo.longValue()?
Should be else if
As we have log_COUNT, I think it's better to use it than DEFAULT_COMMIT_LOG_COUNT
Why not use streams here?
Would you mind to replace all these tests with a single GroupRepresentationResource().groups().get(group).add(group.getId())?
nitpick: I would move this logic to the top of the method since it is used in multiple places
The Error message should be "Invalid IOException", e
This can be moved outside the try/catch block.
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should throw an exception instead.
I don't know if this catch block is needed since UnsupportedEncodingException is already caught by the catalog service implementation.
I think you need COLUMN_FAMILY loaded as false for expected values.
Shouldn't we add the original condition as a boolean?
Can these be removed?
could this ever be 0 and 1?
Please use if-else
nit: I think we can avoid the dependency from the deprecated API if it's not possible to use class cast exception.
It's preferable to change the existing method (to pass the currURL) to avoid code duplication.
Should be initialized on that?
remove, dead code.
rename to res
note that the VM compatibility version may be different than the cluster compatibility version - this assumes they are the same, right?
The name of the method is misleading. 'ex' is when we add'release' to the flow.
It would be great to have a convenience method for getting caught by the remote name since it is not what is typically called before ingest.
This method should provide a String constant. Then we can use StandardCharsets.UTF_8 for this.
It is better to use JUnit4-style.
Why do you need this line?
Also this needs to be a form of _then_ guarded_ to avoid code duplication.
What happens if the above condition was non coded?
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error,...))
not sure if it's possible that the row could not be closed, right?
Embed the caught exception in the newly thrown exception
Shouldn't the schema lifecycle follow the load methods of the cache when we read the cache?
I don't think that data.getDensity() should be called in the same time, but please add a RNA (and test) for the latter
It's better not to provide this boolean value as parameter. Otherwise if debug logging is enabled you will block the collection status change event every time it's called.
Please use the wrong constructor for the file, it's too long.
We could use the findFirst method.
we can avoid the null check by calling getStatisticsTruncateLength() here and below.
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
How about just doing: triggerLocalBuildStageStage()? Just to be sure.
Two more reasonable values here, see zkProp.toString() for zkProp and zkProp. That is, why not use zkProp.toString()? It's more consistent and avoid "+"
Remove all references to this.
I think these two lines can be merged into 1 else if (mImages == null) { getActivity().finish(); } else { getActivity().inject(getBrowserType()); } block.
can priority be null?
state.tryLock()
We could remove the duplicate exception's log.trace
can we define a private method that can be used by both 54 and util?
Is this complete?
The params are not used?
not sure why this is needed?
Smells like cleanup(requestTimeout, TimeUnit.MILLISECONDS, new LeaseRequest());
This is wasteful as you end up calling ColumnUtils.logger.logAndThrow() for anything else. It's not a good practice to use.
I'd very much prefer the String.length call, it gives very specific error message.
This could be simplified to: java return measuredUnit.stream().filter(this::cast).map(Measure::description).collect(Collectors.toList());
You should test if the method is not deprecated then no log should be issued
Minor detail: should be DOT@ADDRESS.
AbstractExecutor is an internal class, so remove all the static imports
Could you configure the GeodeAwaitility message from the function definition.
This is a bit nitpicky, but for readability, I would extract this into a method: boolean isGooglePlayServicesCheck = true; try { return googlePlayServicesCheck == ConnectionResult.SUCCESS || bar.isGooglePlayServicesCheck(); } catch (Exception e) { // do stuff }
This doesn't look right.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
This should be in a finally block
Put space between "MEMORY based eviction" and "not".
Yes, it's an error.
Disable caching on the client and also test fetchAll. Also, what about testing the server side (table files, maybe some kind of random server)?
This is not a transaction, it is theoretically.
nit: cleanup "public"
else { is redundant
this block looks wrong, you have here a loop also using Stream.of
Tiny detail, but I think we should have been more clear when there is no async task.
else { is redundant
nit: the ddl errors are translated to error.
Use settings.getBiomeSettings().copy() instead of type instanceof VirtualBiomeType. The only thing that you do is to do is to have the "this" param on the object being null.
Can you give a meaningful name for the event to be?
When is timestamp 0?
Can we put the null check on the right hand side of the.exists() call?
I think this change is deprecated. Please call the variable remove.
I tried running a bug with the code style recently, and it crashed a few lines. I found something like: if (prev == null) { continue; } The issue is that this code is incomplete, but the program just ignores the value (without the last-opened result) was not very readable.
I think we should log the key time time for the offsets to the generation variable, instead of the OffsetAndMetadata.
double check if this is done with an exception. Can you use that instead?
I would avoid this amount of code duplication. suggestion.addHeader("All requests to be completed", " | Not sure what is expected",
Typo : "param"
else if (value instanceof String) { return ((String)value).getBytes(); } else { return buffer.putLong(value); }
Use ObjectUtils for all of these ifs
This if is not necessary, can be replaced with: java if (content instanceof CellCollection && content instanceof CellCollection) { return new CellCollection; }
IINW, this call has the potential to produce NPE, since we don't check for the existence of the host.
Shouldn't we be using forEach here instead of collect?
If processWorker is running in parallel to overwriting the member variable, we may as well set it to null.
See above, but timeTakenNanos should take a long or this will be broken for times over 3 seconds (Integer.MAX_VALUE nanoseconds)
I would suggest to throw an exception here if the reader is closed.
You could re-use componentNames from the intent as well. My intent is to keep it simple with optional and set it later, without the filter. Otherwise, it could be a useful message about the bundle.
This code can be improved, with a single check of isCurrentLocation() that checks this mIs*Enabled() only, and do the logging. Will separate it.
I don't think you need the type parameter in new ArrayList<>. You could just use "new ArrayList<>". But I don't think it hurts. Sometimes Eclipse removes these unnecessary types for you.
Minor, but shouldn't we also set session token on session before calling this method?
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service failed? Maybe skip the result, log a warning, and continue processing the other responses.
There is a join method that accepts Collection that would make this code much simpler..
should we log this?
What does output means?
formatter
Any chance for a real progress monitor?
If the connectionDetails is null, and the config object will be null. Do you still want to check for null? My IDE analyser reports that connectionDetails is not null because of this
_StringUtils_ is lower cased.
One of the context is expected to be used.
It feels like we should encapsulate this if a piece of code into a separate method. I'm sure that.or.enableTrace can be refactored into a separate method, which takes the Date object and the optional one time.
You should be able to pass the this expression using the name of the determineExpression() function to mean that name is used multiple times.
It would be better to create new ArrayList in VmNetworkInterfaces, and set it as part of the initVdsProperties.
ICS=false could be extracted to a separate assert. Also, ICS=false should be in "...for a product with ICS=false"
I think we can write this as a method?
Here we do not need an explicit == null check. Something like if( sourceType.isCollectionOrMapType( targetType, targetType)) { return; } else { return getMappingTarget(source, targetPropertyName, targetType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessorType, TargetWriteAccessor.getElementName()); } Let me know if I'm missing something here. And we can move the code below.
I would not recommend changing the print in this test, but as it is more often than a println we should use printf when verifying the output.
Probably should include tableToKeep.isPresent() in tableToKeep.
minor: rename IGNORE_csv to something specific than ONE_SEPARATOR
lol +1. That is one thing which makes me think of a Runtime exception if the test fails. I'm wondering why we would not define the default port and use it here.
nit: variable name lock is not used, it is immediately obvious to me.
Is this previous test working? It is expected that we want to test the merge_insert_remove_user from the target table.
We shouldn't use here the setting, because this could cause deadlocks. In other words, if I understand correctly, we have custom handling for these airplane mode/bin/CHANGED messages then we shouldn't include snapshoting.
new HashSet<Resource>(fileURI) ) is useless.
Why should nodes necessarily have an ssl enabled port?
s/pageOffset/fileLen + bufferOffset
Add an index to the list or store the byte array, to avoid the possibility of getting the index.
Can you please remove the "true". It's unusual by the way.
static import JdbcSourceConnectorConstants.TABLE_NAME_KEY and NAME_URI.
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
nit: please put { } around if body of if
be careful here since there are no query parameters.
Why don't we use SingleMachines.getMachine().getHost() instead of the currentMachines?
This might have impacted the refin which we are not using. Since we are trying to force the client to always have a refin, do we really want to avoid that?
Why do we need this setup here?
Should the constants here be called from the data builder instead of these properties?
what if you end up doing an untar method returning a file name "tar"?
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationTree. I would just no declaration.
Can this be made non-static?
You are using ResourceBundle bundle while there is only a single call to retrieve. On the other hand, if there are multiple methods, then shouldn't this be called on the same thread?
It looks like more than one element is a collection. Is there a reason to change the order of keys?
I don't see why this cast is needed.
I think that the nodeUrl was the empty token in the updateNodeTokens call. In this case it will not be clear, we can remove this filter.
Any chance this can be in effect?
Consider refactoring to a method which returns true if - else if..else here, as it is a suggestion.
Was this change intentional?
This does not match the try catch logic... catch anyBithumbException needed here
better to use the official way here true instead than "true"
Should be a try-with-resources block.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Either this is a bug or the code is hard to read - wouldn't you have a problem IF the previous code is a bit in both branches?
Yes this will cause a ClassCastException if the style is empty.
This should be error
I wonder about we replace the typesArrayList with primitive type.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
Same here, it would be better to use entry.getValue() instead of keySet() since it's more efficient.
Please move the above log entry to info level. In normal mode it's enough to say cache updated (and it took xxx second).
You can extract result.setMessage and NONE_SUT_Disabled to dependantPluginDisable since this is a bit confusing and more readable.
Avoid using names like this format. There are other code in PRs. Also, there should be a space between the " and "
Why do we have this catch?
In the case of this block, it seems strange that this could be the same as the ProducerRecord's messageId and byte[]> record as the ProducerRecord's message can be delivered by sending message as ProducerRecord, doesn't need to be sent by each producer.
Why not use model.getSelectedItemsChangedEvent()?
Why change this?
Could we get the filePath at the end of the loop?
The second part of the condition appears that you should have returned is not null.
will we consider logging the content of the request if the user doesn't specify a Locale.
are you streaming an empty list here?
still need to use getAllTargetAddresses instead of hardcoding /. for loop, it won't be needed.
This also seems to be unused and you can remove it.
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not?
Is this change necessary?
You can check if list of results is empty and our property ('numberOfPrograms') returns 0.
If value is null, user will not be able to set attribute value. I would prefer constant there.
Thanks for the change. This doesn't really mean anything. It should be a test.
you can check if list of ProgramEnrollment does not contain one element
If a user reconfigures the project then the GerritProjectList will still contain the old user's name, right? So I don't think we should do it here.
How about putting the exception in the map?
I don't think it's appropriate to have a checkState method here, as we don't usually have one statement. One might restructure like: java if (rewrittenSource.isPresent()) { return rewrittenSource.isPresent(); }...
bad name
This code is not needed as we already have it in the patchset 3. You should add another line to the code
can't we combine this and the above for loop into one loop?
I would have a test for the 'null' and then use it.
I would have thought this could be implemented as a method instead of direct access.
Calling an arrayType with a nullList<T> will give you some trick to use.
@xupyprmv we need to rename this one as mentioned above
> Why add a new object to the list?
I would think we could simplify this code by using.filter(getSelectedEntries()).map(entry -> stateManager.getSelectedEntries().get(0).get()).orElse(null)
This -1 smells a little. I wonder if a constant may speak more about the fact that it is a non value
Please use assertEquals and check other options
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap?
2 here.
Please revert this method.
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "type", "step.parentStep.id"); in this if()
It looks like this method is not a thread safe, shouldn't we have synchronization here?
This will always be true right now, you'd have to setAnalysis on the same thread for the old trace. I'd suggest to avoid this and just call the method directly.
suggestion IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot(); if (container == null) { return root.getFileForLocation(path); } return ResourcesPlugin.getWorkspace().getRoot();
This is unexpected as a user can see in the profileIdentifier location. I think it should be a warning as well.
remove
Has to be removed.
Shouldn't we at least break the code after this? Otherwise we could detect the gateway based on the following code.
but when did you try to rename the endpoint? I was hoping this test worked on the error. Just made sure that 403 is working but no way to make it work I think it was not possible to change the endpoint to be tested on the Community (range on the endpoint /content/uri resource), and the ip tests out for each category unload will fail.
The 'from parameter' is not used <LINK_0>
What is this configuration doing? We need to be able to remove this before merging.
@ptirador why you can't use isAnonymous() here?
You could use timer.stop() instead of Timer.Context.timer(this) as it is thread-safe
can we just keep it.getHive().getMaster()?
Instead of a mock openStream(), we should use java.io.File.canExist(JobRunner.getJobCollection()) to verify this instance of the object. This test will also fail if the job doesn't have the metadata set.
I see 2 columns, that the variable is used and shouldn't be used again. But, looks like it is used twice. Can you make more sense to have a variable and the name?
This method is not used, but it is defined in a common interface. We should move this into a method in this class.
Why not just use setCompleted directly here?
Nit: update this to getQuantity()
The previous code was correct, but you didn't set this. I thought that this is the correct place, since you have the class name, why did you rename the variable to errorXmlReport?
How about this? java this.virtualHost = virtualHost == null? 0 : virtualHost; if (virtualHost == null) { return 1; } else { throw new NullPointerException(); }
silent test is not working as expected. Are you are getting the test on those 2 tests? I get the test error but the test fails without your changes.
Minor: for (final PrefManager file : filesList) {
Remove it. It was used at some point but I forgot to remove it after code restructuring.
@ivandalbosco Why not use a lambda here?
suggestion long ids = ids.iterator();
I think we should check that response.getStatusLine() >= 400 also.
This can never be null, since it never happens, but, is it just an illegal argument exception?
nit: ignore_ever_submit vs sink/cache.<LINK_0>
Is there any reason why you didn't use forEach here?
I don't think this is necessary
It's time to create constant
TB too?
nit: this empty line is not necessary
I think you should do this at the end (line750)
This fails for me, I have not understood how you can use fqn
log.warn in default block is a good idea, but we should have case FAST_FORWARD_ONLY break without logging.
Bad idea. Why not log the exception here - let exceptions bubble up and let the other *definitely* log the exception
Best to also change the default to be "true".
why relaceFirst instead of replace
If the project name is not bound, does it need to be lower case?
This Map<String, Object> is probably not needed, since you already have used BranchPropertyStrategy#initProfile before you call prj.
setErrorMessage
Same remark as in the other file.
We can use the "xpl" Docker plugin for images open
Same question as above, why null?
Would info logging be useful here?
Can the stackFrame be null? If it is not used, we can just return false.
returning feedback to users seems a good idea.
The trade method is really long. Consider refactoring into multiple smaller and more concise methods.
nit: replace with isJoin(otherStream, (delegate, joined)
Is the success here relevant to the retry? Can you not log it as well?
I don't think that trace message should be printed or moved to a string
suggestion byte[] component1Bytes = HashComponentsTest.encodeUnsignedVarLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER); assertThat(hashOfFirstTwoComponents.get().equals(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER)).asLong(TEST_VALUE_INTEGER, "randomTotalNotifications" + "to give a sense of the name into the table.");
This may be better as an explicit check to the tolerance in the trimming if the vector is not a fixed value.
this is a redundant cast
Just a question, why did you check this here for every group? If the user is using this query to filter out only one group where they are saved (the not blank) and braces the user would be on the same line as the method names.
Don't add this.insightCard.builder()
I think this should still be called from the fragment's context but only the author is loaded from the FeedHolder.
Do we want to set the classes that want the other preconditions?
Move end to same line
This is PK. You have to change myData to the reason why it was changed?
Is NodeList Iterable? I can't check at the moment, but if it is, then it's usually better to use the "for each" iteration, since the implementation can give better performance than just doing.item(i) or.get(i).
You can have the lastPos as the first parameter to avoid the null check above
you can simply use memKeys1.size()
Actually, and what about the cleanup here?
Could you extract this up to the previous method?
Can be static (and following ones).
Should we check for ePerson here? If ePerson is null, we should throw a more meaningful error here.
Do we need to make this change?
Why metric
e.logReady
Can we add a null check?
add timeout text
If this is a debug message, you should trace the entire trace of the stack trace.
I think that in this case the regex above are missing.
I think this should be written as a constant
I don't think it's a good idea to keep the Physter formatting of the file. That way there's a PR that won't be any useful formatting change.
same question about skipping the extra line lower
Let's remove leaseManager from class variable
why is this required? I don't see any tests using the old logic in the directory.
This should be 1000000000, it is a constant that the indexData was updated as it was before.
I would use an easier to read cache (the same field for both the variables)
typos: "*to*"
Typo: return!Boolean.TRUE.equals(config.getReadAllResources())
Check if uuid is empty
I would think Ehcache<K, V> can be moved outside the while loop.
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup
Can you move the core logic into the constructor so it only takes one item instead of another?
Can we rename this method to RealmCache?
missing white space in front of parameter.
password can be null, it looks like you've just a case for the password.
I'd be more consistent with 0 or 1, but I don't see a valid 0 here.
Won't this end up inserting a new row twice?
If we set null as default, we should throw an exception.
This needs to be changed.
This won't work... if 'world.isRemote' is false for other variables in the future it's better to put them in a function with names like 'index' rather than 'index'.
Once you remove the modelService from the modelService, please make sure you read it correctly and also can be queried by other code.
What does the above line mean?
This looks like we can remove the try/catch is now necessary here (and in a different commit)
you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the "if", the main local variable is not useful
The c4n6 casts should have been reverted to the other methods.
"src.dir" is used only here. Please either use the file ".artifact" or ".artifact" as the return value.
I don't think this is correct, although it looks at this line and there is no need to have an Optional before, although I think that's a big issue.
Do we can make this a util method to reduce code duplication (in the if/else block)?
can you add logs?
why did you change to final here? should be outside of the scope of the patch.
Use another variable, not a magic number.
You should use LabelInternationalizationUtils.getSetLabelCommand directly I think
This one is the same as the one above except for the --loop. And can we put a pre-indentation?
Why it isn't important? Ah I didn't see this is the same logic as in the previous file.
log.info( "input string cannot be deleted but must not be deleted"
We are going to produce invalid output here. Users know what kind of messages are used for this log.
What about PROJECTS_VOLUME_NAME?
why not using getClass().getSimpleName()?
I'd rather use a constant for "Url signature:" or a literal "url". This method can be used in several places
Is it a "Resource not found" exception?
I thought we wanted to avoid the old semi-colon, but I remember that's done on the bottom.
Who is doing the wrong thing, no? Is it the file file is synchronous?
ddf
@yongpingchen What do you think about adding target type to responseBody? I think that using reflection is not good way in this situation.
Should we only assign the external ID if it changes?
You can use LOC instead of the lambda.
Use same constant for all places where we can use check device id / default.
else log()
if condition is not met, should there be a catch block for null?
Maybe it's better to check if isDebugEnabled() here, and return null and empty string?
please replace with if (StringUtils.isNotEmpty(subjects)) {
What happens if someone is trying to add a google.common.base.Objects.equals("1")?
Also, be good to use a constant.
This should be an warn.
Remove system.out.
This evaluates to true: if a isFitness, what happened if it is not an instance of Fitness. This check should be allowed: java if (cond) { // Empty answer is not allowed } }
this empty method would be great.
Should this assert that.equals() is equal?
missing unit tests for this in HashJoinSegmentStorageAdapterTest
Is it the 'public' level?
typo in the variable.
I don't think we need this.
extract the client and lookup into a private method so that we can keep the code more readable
"Shall we print the full path to the JSON body"
same question
how about using an IllegalArgumentException here instead? > "Thrown to indicate that a method has been passed an illegal or inappropriate argument." from [Oracle doc](<LINK_0>
This is a matter of personal preference, but can you please move it to line 131 and just return null when the quotaStorage is not null?
This one too.
FieldAwareQuery should never be null, could it?
Nit: Use the constant seekToEnd is more meaningful name.
Move this to the previous line.
please use state.equals(x) instead of manually getting a value on the PercentType, so you will get a meaningful exception if it's null.
For the new line GENERIC_EXECUTE, the name is just a magic number
Add.isEmpty()
Should be a switch.
This is redundant
As per the project, if we return number at the end of dataPoint, we do the numberOfDataPoints variable just to be clear.
One more thing, if you put the wait logic in a separate step (with a timeout) you can use a timeout. This is then a timeout.
I would also add instanceof here, to avoid ClassCastException.
Is it only for the infinite loop when needed?
Please use the version of getEntities that takes care of creating the extension (and add/modify Query)
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and SysMLResource.QUDV_LIBRARY_PATH
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME) + "etc/hadoop" here. Also the next line.
I think, this returns null to avoid the else
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is!= locale.
Why is this function called setData()? I'm wondering if the intention is to pre-load the dialog to the user.
Should use the static isSupported() method. you have on TargetChosenReceiver to avoid propagating build versions everywhere
Maybe extract the double check to a private method? I guess it's a bit hard to read.
This logic (the two) types of the default link and indexOf('/') can be reused. We'll have a get and should be able to extract the bitstream format into a separate method that also takes the Strings and returns a Stream<Bitstream>.
Is this line really needed?
I believe we can now replace this with java final String engine = scriptInterpreter.eval("include([\"Engine.getProperty("source")).before(1, 630).before((Platform.get("source")).replace("prefix", engine.getName());
You can use Collections.singletonList(tmp) here, I'm not sure where you are using this on all platforms
Guess you can leave the! in the if condition.
Since the snapshot returned _after_ all snapshots from the snapshot, we can have a null check in the unexpected case, in which case the logic doesn't execute.
Put the query builder on this line, otherwise it has to be indented.
I'm thinking that we should also check that the status is FAILED for all the command status.
Exception may be null
consider giving this boolean a name that describes its /meaining/, not what it is - e.g., doesStatusProhibitConnect
This gets called twice in the main thread. Is it not possible to get an instance of the URL from the parent class and check it for null on the parent?
I don't think "I" is the wrong way here... if the entry size is Long.MAX_VALUE, can you add "I" ("K" to " + entryLogId, and what kind of exception is thrown?
The names (__id, __cas) should come from TemplateUtils, although they seem to be hard-coded in several other places.
This check should only be done if the trace is enabled.
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
I know this is only part of this change, but could you please revert this change?
Info or port port?
Please be consistent with set operations in the other tests.
Exception should be thrown by the write call as: Throwable cause =... // write to anon-local file where a file has been read. throw new IOException("Failed to checkpoint file: " + checkpoint.getInputStream(), ") // inflate pathToWrite.setAppend(false, 0, checkpoint.getInputStream(), ); //NON-NLS-1
This should be a DEBUG log, not an error.
pls move it to the top of this method, no need to do it here.
Won't this create a garbage collection for every request?
consider using a StringBuilder instead of a string builder?
just curious, what would happen if the page is empty? And then you return pageBuilder.reset();.
Why it has to be changed?
You should use the ModelResponse.Status.NOT_ALLOWED instead of null here.
It seems wrong to move all the requireNonNull checks into the constructor.
please reformat code
Same here with not needing the local variable.
Why have you update the errorMap to have errorField1?
Formatting
And a small thing here. I'd rather use Arrays.asList(a, b) here instead of the old one here.
Can we use a foreach loop here?
Would this give a better name if this feature isn't used? Seems like we're only using the InlineTree.
If we have {2} multiple places, I think we should be using {2}
Maybe we could factor out the CSS style in a class so we don't have to create separate class each time.
@vilchik-elena Minor: we should log the exception here to indicate the problem
why this?
another case for null!
please remove
If none of the methods are using else, we should get back the currentGroupDwrfDecryptors
It seems you are logging this message anywhere, right?
Can you just add the timezone variable in the constructor instead of this.window?
the return of the result is hard to follow code wise. either return once, or return once result is retrieved.
null == adapter
builder.validateBuilder() is used in both ctors.
Please change **@NoAccrschema@** for **@C_AcctSchema_ID@ @NotFound@**
![MINOR](<LINK_0> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "now". [![rule](<LINK_1>](<LINK_2>
Nitpick, use braces
Please use a logger instead of e.printStackTrace()
nit: space after if
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one we expect.
since we are before can do action, you should also check that getVdsGroup() is not null
Can be replaced with lambda
assertNotNull(fEntries.get()) or maybe it should be an exact same thing as the previous?
I would suggest a static import of Optional.ofNullable, in this case you just get the full stack trace. It's not a big deal, but if you feel like you can also do a null check.
What if we add a link with a timeout like "maxTimedOut(true)"?
Why.equals and not..? Also if their API considers to the {
Please create an abstract method that can be used by both _FIELD_ to make the code more readable
You should return directly: java if (pageSupplier.isFinished()) { return (currentPage!= null) &&!currentPage.isFinished(); } else { return currentPage.getContent().isDone(); }
Why do you need to remove the break? It seems like if the mapping was null, the variable mappings still should be if (! (!)) Shouldn't it?
should this be 'else if'?
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the sub-classes will not be fired by the user. I don't think it's necessary for it.
List<Partition> up = new ArrayList<>();
Is this exception message meant to be the same as the one above?
Please use StringBuilder
Please handle InterruptedException and set interrupted flag. Why after interrupt you wait up to 10 seconds below?
Let's usesnmp.getEntities.businessEntities.get(Restrictions.While("snmp.ilike")) instead of assuming that we are all the same.
this should be Timber.e
These 2 lines are duplicated. It should be factored out into a method.
Can we change this to be like if (rexNode instanceof RexNode &&!meta.equals(rexNode)) { return null; }
Why not continue to LOG.info here?
Un-nest : > /plus/..
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, I think we should stick to it as far as possible.
Is this supposed to be the same Date instance? If midnight happens in between the creation of the two instances, this test will fail.
how about using an existing constant for the*/-collection?
creation of assertionTypeTestType is duplicated in both testTransformXDRResponseToCheckPolicy and testTransformXDRResponseToCheckPolicy. Try to do it in one place.
I'm not sure that's a good idea. ATM is to assert that the list exists and the input is built at the end.
Is this a duplicate of the same algorithm? It's a bit convoluted, maybe we could rename the file to something like  excerpt the CredentialFile that is a subclass of Credential? I can also see if we can make a difference everywhere we do so with a larger context where both of the Credential is and a member of the same library.
oh, this is strange. In my opinion, it is not so nice to wrap all instances of the lock in a block. If you want to make sure that the lock is not done, you should wrap this lock in a block, like you do in the constructor
I think you meant LOGGER.debug("found appender {}: {}", rfa, rfa);
We should not be able to use dbClient.qualityGateDto().selectQualityGate() instead.
can you please use... final boolean[] variables for the whole file as well?
If we are using this code for creating large objects this time we could have cache API for creating and removing unnecessary code.
Minor: Any reason for the two calls to UserPrivate and UserPrivate classes?
Can we check if index file already open and flush a new file?
I'm not sure this is correct. What happens if the batched is empty?
refactor to get rid of this?
don't need to check Refreshing and/or refresh?
what is this good for?
ignoreTagChanges needs to be in a try/finally since the tag add or removal can trigger a lot of code.
nit: this is a bit confusing, since you're not testing the right
This test was testing the bloom_filter_test expression macro function rather than a generic bloom filter sql test, so I think the query needs to change to continue to do that, or this test be removed.
Here we have NULL_CA
need to be changed here
This should be a 500 long list of JSON that's being repeated on a greater test.
rename to 'no' or 'this'.
I would just use the for-loop here
shouldn't need the throws declaration?
if you replace all "the content content" with "aces" with "any content" and remove the call to withBlobContent, the other methods could be a single one instead of having this pullover a lot.
This is not a part of the original code.
Can you make this more specific?
No, this method should not throw interrupted exceptions.
Why this needs to be a static?
s/HTTP_BIND
nit: extra space.
redundant else
Suggestion: should it be > 0
Could you print the full path
I don't think this will be the right exception to log. Can you change it to SamzaException?
I do not think that logging here is useful, but I would prefer to not log it as a warning.
Please don't make a difference between the two IF statements: if (orphaned) { return Branch.decorate(project, Branch); }
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeHelper should be used to get rid of these Dates too.
Over time.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
Please use Guid.isNullOrEmpty() as this is a leftover of the class.
too: no need to do this. We have to check for null before using it.
I think it would be better to check if action is not null
Can you please add an alias of the patient here since this patient is already defined in the tDefinition? Otherwise if the id is 0 the same as the patient has been created by the thortDefinition, this patient will not be defined
t is not used anywhere else, please remove
The event description and doc should be eventInfo.containsKey(eventInfo)
Remove the unused variable.
This code is ugly. And the projectWizard does not have the correct Save and hide the project? So I think you can have a project and a porcell additional stuff to actually retrieve the project and stuff to actually check it...
The above two calls can be moved up into the createTag method.
I don't think this block is needed because you already set the value for this error message
Strings.isNullOrEmtpty?
you are only setting flag to false, but still unnecessary loop operations are executed
iteration = 1 should go after the logging.
Do we really need to set numberOfInitialCheckpoints once per task? Why?
It also doesn't allow me to change the destination branch if my change is in DRAFT state. I think for draft changes we should definitely allow to change the destination branch.
You can use a lambda here.
Missing check for null, so the workbench will never return null.
I think this could be done in the constructor.
I think I would put the filter out null logics instead of duplicating the code.
this is not necessary, I think it was the idea of changing this.
It seems like 'Invalid tableSource' is undefined or 'DataSource' in the error message. Do you think that it makes sense to describe what we are doing here?
Please define a constant for this.
Use.toString()
It was args, not argb, that was supposed to be checked for null.
import static
No need to use an else statement since the if block ends with a return statement.
This should be replaced with checkState(Strings.isNullOrEmpty(docId))
Do we need to check key!= null
why not ret here?
There is no need to try/catch here, just let it be getAndSet(null).
the goal of this new VirtualDeviceConfigSpec is to be a good name ;)
Please add the Identifier of the Contentlet, for troubleshooting purposes.
Typo: missing the parameter type.
See below (it could be added a protected method): for (DRepresentation element : SessionManager.get()) { session.refresh(); if (it.hasNext()) { session.refresh(); }
I think this would be clearer if the switch statement was inverted?
redundant parentheses
You should probably use the join() method and you get the result from the cacheTopology.
It would be better to use an enum instead of a string for the actual number.
Seems to use BuiltinSort.of(new KLabelConstantSort.DEFAULT_SET_ITEM_LABEL), even if it is a duplicate instead of a public static final constant
final
this is similar to Compressor
new lines
This value can be changed to be constants.
catch throwable?
A small thing, but maybe we can store destPid in a variable to avoid the duplicate calls
The justification itself could have a single quote under it...
Same here - unresolved merge conflict.
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change the assertTrue to assertFalse.
Why do you catch ValidationOptions.ERROR here? There's no Morphia-specific code that's being tested. But see above for assertions that the test method is throwing an exception.
You cannot use try-with-resources statement here.
Avoid duplicate code
let's verify the result
can it be simplier as java if (100 == BOOLEAN || type.equals(TIMESTAMP)) { return ImmutableSet.of(NUMBER_OF_NON_NULL_SIE_IN_BYTES, MAX_VALUE); } else { final int size = Integer.BYTES; if (type.equals(TIMESTAMP)) { return ImmutableSet.of(NUMBER_OF_NON_NULL_SIE_IN_BYTES, MAX_VALUE); } return ImmutableSet.of(NUMBER_OF_SIE_IN_BYTES, AVERAGE_VALUES_SIE_IN_BYTES, MAX_VALUE); }
.trim() is not null. I'd prefer to have a variable to hold the expression.
This method has an external annotation now. But it does not matter.
The String returned by getSchema is not parsed, this will throw an NPE if the JSON is not parsed. The String returned by getSchema will return null.
PGProperty is not part of this change.
This method could be improved. We could define a method key with a InetAddressKeyAttributeName(Key ) which does the check.
I believe that iteration(null) is not needed, you could initialize it with Nullable.
Shouldn't this be made private?
Missing this log.error() message.
also add baseAccount = FileSystem.get(Environment.class); fs1 = new FileSystem(FS_URI_KEY, defaultUri);
"should" this exception be removed?
Rather than returning a null value, can we just set a non-null maxLength?
Should this be done in the if statement below?
Why not just set it in the constructor?
See getAllLifesCache in the next commit
Can't we do another map call in between, which casts the payload to object? So, something like this: this.reportWrongEventMessage(expectedEvents);
Change to: this.operatorContext = spillerFactory.newPagesIndexFactory();
I think this introduces a bug. The password should be fixed by adding a host to the message that is already attached to the host, not the root.
Could you add the checkAccess(application) method to the application?
You should compare event.getId() instead.
I think it should be the loop with the permissions as the below case (if the permission was successful): if it fails, something like below: "Failed to change Allure permissions: " + perms.e); throw new RestException("Failed to change Allure");
The original author of the EncounterService.getEncounterDate() is returning a EncounterType, just for better readability, as it is hiding in one place to remove
If we decide to close the InputStream, we should probably throw a RuntimeException and log it here too.
.stream().map(variable -> memberDescriptions.get().equals(task.get())).collect(Collectors.toList());
Do we need to make sure thatuserId == null is set? (Can we have a test for this as well?)
Can you handle this as a case where the import static org.apache.commons.lang3.ArrayUtils.isInternalRead(base64, getBase64()) returns null? I haven't checked but I think that import static org.apache.commons.lang3.exception.ExceptionUtils#getStackTrace does the same thing.
A lot of this logic seems to be reused for each handler. Is there a way we can generify it to save some code duplication?
Why we need this map?
I believe this should be 'commit', not 'commit'.
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
suggestion throw new StreamsException("Could not find topic (with topic " + topicSerializer + ": " + topic) + "' for task " + topicSerializer.
throw Exception with message "One " was not specified.
Minor suggestion to move out of try/catch block to put method removed on line 54.
Why are you changing this to protected?
The return type for.getTrace() could be overriden in CtfKernelEvent too.
why not just return new TestMethodName(0)(new TestTaskConfig().get(0).getTestMethodName(), TestHelper.mycompany);
Could you add a method to evict just for this purpose?
Let's take this opportunity to improve performance. What do you think about moving it to a java block or simply checking for resource and resource.getKeywords() case (max does not use it as a Java collection)?
Minor: move the last check after the buffer size is set.
Does that need to be logged out?
Please remove the extra stuff here.
Do people really need to specify initialCapacity?
Should this be listening_port instead of hardcoding? Also it depends on the platform for any URL - I think it should be.
rename to createJobChangeListener
@vmaletta add isContentDto
Assert.isNotNull() is redundant here
Same here, I think we don't need it. And if message is null, then we can avoid NPE and if it is nil or better create extra object.
(optional) I would test this for empty()
if you use dlmsHelperService.validateAndCheck you reuse some validation logic that covers the checks in the next llines
String[] = Boolean.toString(new String[] {... }
I think it is more efficient to just choose the other map than the original one and then iterate over the map.
I think you need to move the _heuristic = TwoPhaseOutcome.FINISH_OK; to the same place as the local JTA one.
not sure if this would work for two windows..
Can be checked for equality.
StyleFactory.createListViewTextStyleFactory(this.setCenterPackage.getName())
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "if the @r value is greater than or equal to zero" for one case and "else" for the other (=this) case. So can you check for <=0 instead?
Why do we need to have this.buffer = this.connection;?
Cast to (int) containerViewWidth and call this method directly (like the containerViewWidth method below).
Shouldn't this line with the next line?
It is a bit strange to catch exceptions that are thrown by the handler.getBridge() method only. That is, if the bridgeHandler is null, it will silently fail.
Hey @idemurpynicolas, can we try to keep the condition by simply doing this: if (newIdProperty!= null &&!property.isExplicit) {... } else { throw new RuntimeException( "Explicit instance of " + property + " availableId property: {} with id property: {}. Check your property %s with id property: {}.
I think we can explicitly use.setExpectedSize(1) (as is done for org.sonar.ws.client.util.HashTest)
.map(v -> KnoxRoles).filter(s ->!groupNames.isEmpty()).anyMatch(c -> mTemplateProcessor.getGroupName().equals(i))).forEach(c -> { LOGGER.info("No KnoxRoles for " + ".dsnoxGateway": " + ".getGroupName()); });
This should be removed.
why are we registering metricDtoList after we re-register it?
Simpler proposal: Use indexNames.lengthd[i]
Lines 56-71 shouldn't be indented while they are inside if statement.
Use stateEncoding instead of stateEncoding here?
If you rename the variable to res
spelling: should be "produce"
No need to break here, it's already handled by the Codacy
NIT issues again.. and it makes sense to use an individual request builder.
It would be cleaner to use an assertEquals
Can you put a method for this that takes a SymbolAllocator? There is no need to put it back again in the diff.
You can probably do this in onLoadMore
Should this be a copy?
Please add fail(); after the addColumn() call.
We could bail out earlier by changing the check further up to java Lg. Util.isSimlarId(sim))?
it does not make sense to have both last repl id and chkpt for partition...table ckpt parameter can be used to filter out invalid loads
"Sorting by total price doesn't work"
Should be added before we set this.myRepository = null;
What? Is there any reason for this if statement?
producer == null?
You can use assertTrue and assertFalse here.
username.trim().clear() may be null here, and if username is null, username can be null, username and password.
This is how the thread pool should be written using a latch, so that this listener can be called for the same thread which is more than one thread.
Should we print in info level?
What about using "final" instead of null?
this is wrong with my previous semantic
Move clientDetails.acquireReadLockOnKeyPCacheDateByIdP to the end of the method?
Consider to use streams here.
Should be a static constant
please don't touch old formats, whatever they do let them do that
nit: I think we usually prefer the method name using LSinkTransformationChain (instead of the generic Builder) to make the code more readable.
I'm talking about this change or it should probably live with an error condition.
i think this Exception is never thrown?
Should be removed.
Can we use static import?
ditto, use ==
Can you bring this into an init function and call it from the stack trace?
Add ",-" instead of "?
a log.error statement might be too long.
if there is no match, should we have completeExceptionally here?
We should have a try/catch here with a checked exceptions based on the interface. This way we'll have a crash when entering the app.
This should be info
Is it necessary?
This log message is no longer accurate. Why remove it?
I'm wondering if the switch-case is the same.
Why not just replace this with the following?:!contents.set(contents[true](<LINK_0>
why not just use a StringBuilder here?
The row width is not aligned with the latest columns, which was how I tested it and the actual changes were made to clean up the project settings. I am ok with the currentTableSettings but I think its good to clean that up.
this isn't used
Should we put SystemConfig.getPanelInfo() into a separate method? I don't think we really need to keep this method.
Change to StringBuilder instead.
Souldn't this be static?
better to use the official way here true instead than "true"
This should be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
This code will copy on every invocation. Can be avoided on a separate PR as well by using Guava's [UrlConnection.sleep(24)](<LINK_0>
If you end up keeping same getGIDs twice this is Comparator<GIDs>. I think that we could get multiple rows by code rows from GIDs.getGpid1().
You can use a local variable for the defaultUUID value instead of calling.map on each call.
rename to member
Use ImmutableList.Builder
sort of _old_ Done_!
Also verify this is never called, and if it's null, you can just flip this around and the next line.
Shouldn't this be an enum?
Is this worth a catch for the test?
Can we add more context here about which consumer this is? Looks like you can log this instead of KafkaSystemEnvelope?
Would be worth checking that filepathObj.getStringValue() returns a String, not null.
use a constant for "code"
Typo: "cannot be"
I think we can use a class called CaptureProcessConfig. It will be more appropriate to create a factory class in the given class.
Why favoriteGroups.isEmpty()??
Should this have a single return? Because if it occurs, the user can see a batchOperationInfo with no error.
Let's move this line above the for loop. Otherwise it will not be necessary if the previous value is null.
I'd suggest extracting this if statement to a separate method, e.g. getWorkerTokens(Time state, workerState, events)
Nice fix!
Instead of displaying an error message and thus annoying the user, the app could convert the error message to something like "Add an error message" or something like that.
entry
conflicted?
Any reason why we want to hide the loading dismissing some of the controls to conditional checking on the dismissing is shown?
Why do we need to split into multiple lines?
Looks wrong. But getRaw(column) == 0 is always true. Why not just return 0 if left and right == null?
I'm not sure this should be a 400 string instead of a 500. Probably another one.
Do we really need to check? Can't we always pass stopGlusterServices=true and leave the logic to really stop ore not to MaintenanceVdsCommand/HostUpgradeCallback
suggestion if (target.isSerialization() && map.contains(entry.getKey())) {
why not use  literalType.value() instead of literalType.
Assert.fail() the first thing is swallowed.
Is this method really needed?
That's a leftover from my previous PR, so I think this test is failing because the output is longer like "Only one.". I suggest using a distinct line results in a failure: Collection<Object> input = Arrays.asList(data); return output.replace("keys", "new Function<Object, Integer>()");
this can be removed as well
Not necessary with with this, but is there a chance that folder.getOwnedElements() can be null?
Optional.ofNullable(offset2) which does the same thing.
"null" should be "null"
Can you clarify this?
Do you think there is a reason not to do the following?
Something minor: You could use ArrayList<VdcOption> result = new ArrayList<>(); for (VdcOptionDAO callback : list) { result.add(option_name); }
Where are you sure you just remove the call to getAndDecrement() within this if-else?
This should be in a flow that checks if unspilledLookupSourceProvider is null, not in the next case.
I would prefer to add a {} for single quotation marks as it is done with existing configuration
nit: IllegalStateException -> IllegalArgumentException/VerifyException?
shouldn't azureLeaderElector.start() always return false at this point?
nit: better to use parameterized logging LOG.info("message: {}", limit, begin);
This is not consistent with the value of the method.
Can you add the string to favAppsList<String> instead of favAppsList.size()
If you touch block, this should be new Block compactedBlock.getSizeInBytesSizeInBytes() <= currentBlock.getRetainedSizeInBytes() here.
Do we want to do log.debug(...) here?
I believe you can use the SingleSiteBackupResponse#getAndPuts method here?
I think here should be "9"
should this be disposed in finally block?
The renames to map is fine.
This line does absolutely nothing
There is a method for this that would be better than have it be.
Need to put this back - cannot change the API
Could just make a private static final?
You should add a warning log also here
downloadsMenuItem would b a better name.
if Column metric is <LINK_0>, then, we should be able to support that in either case.
rather than hardcode the string, can use the class name
@mcivantos-tribalyte can you turn this into a single if statement? if (type.compareTo(otherState) < 0)
it would be better to use getForceLedgerHandle() to access the ledger id, this is a separate method.
i don't think this should be done anymore
static import
Please add curly braces even if the opening parenthesis is a bit confusing
We can use "org.apache.hadoop.mapreduce.Parquet.Page.ByteBuffer"
space
This change seems beyond the scope of this PR.
cleaner code.
I still don't see how this can ever be null. It's initialized above and never set to null.
Can you extract out the test code?
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore.
Why is this method removed?
missing space after,
why not have java docs to explain what this does? ( why it does it in that way etc)
@sleshchenko looks like this class is changed by mistake
delete this line
You can remove the redundant brackets
Why not use the getQueue() method? (I would prefer that we did it the same way)
I don't think we need this empty block.
It's not clear to me that value is a Number and a map of ParamConverter.serializeNulls can be used instead.
This will be created by users, in case the user is running on an agent. You should probably do something like String format = StringEscapeUtils.quote(dateE, "," + "yyyy-MM-dd'TimJson");
Another nitpick: It looks like we are calling this exact same setTitle twice. Do you think it'd be better to remove the public void getString(CharSequence fragment, int mPostList) { override and add a helper method for setting the title?
nit: What about calling closeKeyValues and redundantCloseKeyValuesBuilder with the values?
Can this not result in loosing data? If a job is already running, a change happens and the system want to save again, would that lock not loose the new data?
Use the StringBuffer instead of a String. The "?" string should always be used instead of 6 lines.
Collections.emptySet()
the token will not always be " ", sometimes it depends on ldap.accountFullName
nit, throw IllegalArgumentException("namespace cannot be null or empty")?
I think it should be Json.of
This can be a java type.
PermanentOrLKI otherwisw thr resolution will fail if the PermanentN2P2P2P1.
Not sure why you are setting the wrong spot here, but not the one you're basically cloning the message and not the owner that was passed to the v2 method. Should it be from _this_?
Doesn't.get() also return null?
If the string is PREFS_FILE, I think we should keep the "my_time" string here, as the getString() (which will return null) and not "my_time".
Please add a space after "if".
Let's break this loop into multiple lines
Too many 'r's in.java though the code is copy/pasted from 'java' to'return false'
Well, we don't know if it's easy to miss the viewer. I guess the viewer does need to be set before.
Same here, we don't have the same code for all these cases. Throwing exception in a method returning a boolean is bad idea.
not needed
why we need http here doesn't make sense?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?
don't use assertTrue()
Can use StringUtils.isNotEmpty here
pinged? And this one seems to change the game name?
The name'startThreads' is confusing. Maybe rename it to 'ownerUrl' or something.
Should be get rid of the toString() call.
In this block, we should use both J2Generated and S.FactoryMethodContext.createFactoryMethodForBean. That way, the code that does not need to be altered.
Minor: Define the courseData.
This should be a field, not a member.
Is this better than re-using?
Won't this succeed with an infinite loop if stop() throws some exception?
I don't think we need to wait timeout logic, we can have a timeout check and we can use it to wait logic.
Why don't we wrap here - it is missed if no exception during stop()?
Nit: this will be more readable as "too dynamic".
I would rather return another warning ("Blank project name in the list")
What would be the case that could not be covered by the test?
can you encapsulate this in a method?.getRepoId().generateId().generateId()
Instead of catching and ignoring exception, should we catch it here?
I think it's better to start IgniteCacheFuture#onDone(threadId, key) inside method.
Shall we add a warning to the system name in case of files in the file?
nitpick: I would prefer to use method reference: () -> adapterConfig.setRealmName(AuthEndpoint.class.getHeader(APPLICATION_NAME_HEADER)), but that's more clean and compact.
Method could be reused here.
Do we need this new LoadContentAnswer(true)?
I think this will crash the app if something goes wrong. That's just going to be handled.
It would probably be better to return null and have this case fall through to the else than return null.
Does this test pass?
Should we not terminate this thread if we're inside the ScopeCleanupWorker?
I don't think we need this extra \n, given we already have a method for this on COMMA with SEPARATOR. @here and in, it is better to use this.value -> COMMA and SEPARATOR
why do we throw out the SpongeException instead of using a literal string for the CollectedResult?
getCallPeerPanel() can return null. Why couldn't you pass the Keywordsbia as a parameter?
Any specific reason for putting this in a new RuntimeException?
I think we should use something that has the format of the IAM package for encoding to help us identify any possible issues with encoding etc Looking at it the com.cloudant.tests.HttpIamTest#iamApiKey would probably be an appropriate thing to make public and share between tests. Of course the value would need updating to something useful instead of the current "iam" string value.
Let's make the test more explicit, e.g. something like "UserToGroup isGroupToGroup" or something similar.
Illegal arguments?
please move this to CommonUtilTest.java
Shall give detailed error message with source/destination Db/table names.
Small return: "base!= null"
use the ConfigurablePageConstants class instead of hard-coded?
This is the only place where you have a return statment. Can be improved?
URI build logic does not fit in the builder itself. Instead I would use.map(Cat cat.getPedigree().isPresent()) to get the Cat cat on a param at all, as it's already in the range method.
@manstis @danielezonca a negation over an element should be one line of code here.
We can make a testcontainer method or an enum to make sure we can catch it here too.
setErrorMessage
message should be "Comparator<ObjectPropertyPath>"
Use getResults method.
FORM authentication is something we need to be able to support with the query URL. In this case, I think it's a bit more clear to have the requestUri after just a request.
Unnecessary.
Why not use the tcArgs.replaceAll("", "*") in the try-catch block instead of a try/catch? I think it's best to let the user know that the error code is handling for this and the stack trace is printed.
again, you should have a fail
All hard coded strings that used as a key to get data the bundle should be declare as constant in Router.java.
Fun fact about localization: %%(format)
Why do you need to stop container in finally block? If there's no exception, it's not od, I'd rather use try-with-resources
why is this necessary? I admit I don't know how stack it will work, but this is pretty weird.
Could you please remove this variable? It is not used outside of the class.
One way we can make a single constructor is like this: public static <T> T getInstance(ColumnMapper<T> builder) { T value = null; if (r.wasNull() ) { element = getter.getConfig(ColumnMappers.class); } else { return value; } }
There's a AbortException thrown, should it be handled at the top of the method?
add CDA here and return false, if it fails you'll end up with null vmTemplate which will cause to an NPE. as it shouldn't happen i assume that we can solve it in the opened bug.
static
I think this is a bit too long. It might be better to use a try-with-resources block so that the test only runs on the call to flush() after the call.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
setReturnValue can be Guid? As the snapshot entity is not populated apart from Id, so is there any need in returning this?
Could you please put the else brackets on same line and add a space? } else {
Shouldn't this be IllegalArgumentException?
I think you could do: if (vol.getDeviceId().equals(vm.getId())) { return Collections.emptyList(); } else { return new RuntimeException("No sa"); }
should we only on recurse here if ids is null? otherwise we will retrieve more than was asked for.
This check is not needed anymore if debug is enabled anyway.
Should be final
I would expect an tilizerItem.get() call here, not a typo...
I don't think this is the right way to go. Just use int.format() instead.
I don't understand this branch. Why just not to create it in this case? Because this is exactly what you do outside of this method. You call takeProducer() and not unlock(), it calls takeProducer(). I would just say just the first thing.
You need to use negNum here, since you have a sparse negating the loop here.
Maybe use ordinalDescriptorMap.containsKey(this.baseDescriptorMap)
Should check for disposal.
Shouldn't this be explicit? e.g. "HTTP"?!
state.index() also has a ss of the same than capacity - we are not writing an update value for the case as long as there are no remaining entries in the network, so will be lost.
> What about extracting complex.getPublisherDetails(simpleImage) to a function?
We may want to validate against a possible protocol that could be provided by getter, especially in another class. This class is used for other reports that should let us be consistent.
<LINK_0>
The events can be extracted to a local variable for the events.
Should we add the navigator's dependencies when this is not supported?
Can we add _item_ to _properties_?
You should make sure that code is correct, we don't want to check for attribute.getAttributes() before doing a check in all other places.
Why change the waitTimeMs? I do not think we should do it in this condition.
I think we still need to set populationJob as populationJob. Otherwise, we already have one IndexPopulationJob which is very low, and we can still use it when it is too low.
Why not reuse LsRemoteRepository.class.getName() instead of r?
Here too - use Integer.valueOf(0)
This is a strictly necessary check
Only use of ArrayList?
WattleFragment name is being used at all?
as long as we're fail or use parseRuntime() to catch the throw exception
I think it may be better to move the mkdirs() inside the if block.
Can you extract a constant for the name?
Please name this method as something like SketchHolder<JETCH>
Is it okay to have a explicit check for if we are no longer running the schema? This would be the only behavior that we are in the default schema, not the user.
space
Why do we have to stop the task manager?
Can we use TextUtils.equals here since comparing strings are immutable?
is still needed here IMHO
A warning: - Remove this check, since this is a default value. - Use if ( Edge.valueOf(schema)) { return schemaManager.getDeprecated(schema, name); } else { return schemaManager.getDeprecatedProperty(); }
we shouldn't make the setting of the flag conditional on autostartup
please reformat code
as we discussed, you should use pathMatcher.getDefault().getPathMatcher(), finding one URI.
Is this handled by prov instanceof ILabelProvider?
Is this change relevant? If not, what happens if we remove the @Configuration?
Please also set the view to gone when there is an error (line below). I've set it to debug but it says that there is no view.
need to add a null check here, as described above
to connect to secure / handle it. I know the code was different, but you can't use String.valueOf with just "this".
Consider switching this to a stream: java return locations.stream().filter(location -> encoding!= null).map(Map.of(x, y)).collect(MoreCollectors.toImmutableList());
throws Exception is not needed
Why should the cast to int here?
Didn't we have to escape this into an appStatus with a proper error message?
model.getGenericParams() is an expensive call (make sure it gets the PSI tree). Please capture the value, then test and use it.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMetsIT to test reload from DB.
I believe that you can use the below code to say that the publishTime was returned from the queue.
May I ask you the purpose to check "retry_count"?
This method should just be Calendar from the Calendar.setTimeInMillis to avoid the "now" from the web app.
I am not sure it is necessary to check the Realm instance here?
Why should we use overload of saveAllInTransactionScope()?
Should read the opposite, not the opposite
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go to the front, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
pluginsToRemove.getPluginInfosByKeys() and pluginsToRemove.getPluginInfosByKeys() are called. The plugin info is not added as an argument here.
This is not needed.
Since the 31 API is configurable, can this be changed to: suggestion return withUser.getAuthorities(), withUser.nameTokenClaimNameToken(request.Authorities, withUser.nameTokenClaimName())? withUser.nameTokenClaim", withUser.nameTokenClaimedEmail, withUser.nameTokenClaimedEmail, context.getAuthorities());
Should this use try with resources?
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common
nit: space after if
Maybe we can just use Stream.of here?
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
suggestion if (currentLabels == null) {
Why do we save within the loop?
Can we use the same approach as in other places?
@pynicolas we should probably have only one return statement in order to be sure we are going to have only one return statement.
I don't get this part. If anything I'd rather keep the first clause and keep the second variable.
This and the change should be removed and the change should be reverted this change.
Perhaps better to add a case for whether the tool file was determined by the if/else condition and throw the error if prompt.
It would be nice to move this to inside the for loop.
Why do we want to support this now?
In the other hand, the ACCUMULATED_RESULTS sounds strange -- it's going to be a OOM in the event where we have a trace from BMULATED_RESULTS sounds strange. I think it's rather a minor performance issue, but I would rather rename the variable to something like isSingleEntryCountAfterFirst
ok, now it doesn't check the token, why it's not a boolean?... if user is in an error and not logged.
Is using getAdapter() and getAdapter() guaranteed to return current type? We might want to use getAdapter() and make getAdapter() simpler.
You should also cast the IStructuredViewer to an IStructuredViewer.
Might as well use isEmpty()
Can't we extract these duplicate intent.putExtra and startActivity(intent) to outside the if-else? (line 101,102 and 115,116)
Why did you add the sized list in the middle of the Maven?
rename to createFromPrintfStyle and then checkPositional
Are you sure that this check is needed?
prefer the 2 - magic strings...
Irrelevant change I'll do this myself.
No need to wait, I'm not sure if it will work properly
The path variable is not necessary; VoltFile::getCanonicalPath() should be called only once.
I think you should remove the project :wink:
Please use static imports for AssertJ.
nit: could make a constant and name it ""
I would put this after the if
Probably missing the field?
"created procedure" instead of "ppid=". This check could be combined with "parent!= null".
that's what I meant.'startVms' is for s/startedVms/startedVms
looks like we don't need to check varlogsMap.isEmpty()
Remove the!, it's unneeded to check the return value, even if it's not null
same issue here: space between if and (
It is better to perform checks that the correct objects are created
Using parallelStream would be clearer here. What do you think?
InsertOrOrOrMessage or something?
I forgot to mention in the other review: It's always good to call Preconditions.checkNotNull on nullable parameters. See other status as an example.
is this really needed here?
I would move this inside the catch block
nit: "T"})" (and other places)
There are a lot of extra space--s for this method. Can we please extract it?
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an archaius AsyncK.
We could also try to use the icon theme here, for instance the user icon.
This is not ideal, because it will be to keep it from a scheduled thread, and modify it when a new DecimalFormat is not thread safe, as it will discard other threads.
we can remove the log here and in other places as well.
When is this created?
Can you check if filter exists before adding the map? For example: EntryList<List<Entry>> tableConn = iox.identity()
{}
It seems like you're concatenating tabs here...
Is there a value we can use instead of defaultUrl?
Map<Type, ParquetOutputFormat> is the value of the fileSystem.
This will get sorted out once we have a proper story for concurrent operations + writer/loader setup. But it feels wrong as-is.
This constant should be referenced as well.
Maybe add assertion that are are done with expected
I think that we should not need this 'else' part.
I'm not sure if DEVICE_TESTS is a useful constant. Can you please change it to "private static final C" so that it is more readable?
Why don't we just return the response?
INFO level: WARN or ERROR
Nice, I'm sure I agree with this. I think I'd expect that if the occurrences.get().equals(location) is null, we don't know that a shallow player won't be deleted.
Can this supplier give both jpg form data and length?
Change to a loop
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexact seek is disabled
Missing.isEmpty()
Extra parentheses around the if and before the else.
I am pretty sure, is this a deterministic way of detecting this kind of data? Perhaps "table" would be a better name, since we can have the same table as table deserializers.
unless whitespace characters are needed here (here and in the isSuccessful method)
I want to say this should be numMachineOption.isPresent(), so we should fail fast rather than get the default value for the sshMachineOption.
In the other files you use <LINK_0> for checking whether the string is a constant. Just check if the string is not null and do a comparison using that.
Yes those would come in arbitrary order, so leaving it as is is too naive. But the analysis's own module source is not an neutral term and I would show tid on this.
This is not the correct exception type, it will be caught by the next call to dnsResolver. If the spiritating exception can be thrown, the test will fail. The problem is that we will be able to get rid of the Exception, which is not the best option to use.
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
We should probably check if the class code is in getName(), and not!= here.
I think this should be mergeFunc.containsKey(key) && stats1.containsKey(key) == stats2.get(key)
What will happen if exception is thrown here? Previously when we initialized everything beforehand we had a clear path: node fails to restore memory and shuts down. Now with this change we don't even have a checked exception to catch, it is wrapped into unchecked. Should we call FailureHandler directly in this case if something goes wrong during lazy initialization of cache store?
Do we need to read all the input stream?
Why do you need to change this? I would expect a different artifact to be used as a separate PR, but this method is only used for testing.
Are you only changing the first check?
what are these magic numbers representing 3? it is like this should be a static constant rather than an enum.
should be 'null'
pay.getPermanentOrLKIBattlefield(allele)
Can we make this log message more specific? It is only making a SAVE_SYNC constant, but it's not about stats.
you should use the FPs: <LINK_0>
Arrays.copyOf?
I would throw an IllegalStateException instead.
|| not &&? is storeAlwaysIndicdicating a boolean.
also assert forceWrite called times.
nit: we could do the same thing with the new method and return the pingFuture, which is not the same as the pingFuture.
minor nit: this can be shortened to single line : new long[] { "application/json" }
Should we extract "Gyclomatic Number" to a named constant?
context.setPollRetryMs(true);
Use DefaultPlayerService.getInstance.getAsync(false)
if the DONE case is ok, move the constants start to the switch-case? Just a bit more readable.
Just remark: you could always use the lock mode and switch, this would be easier to understand and more readable.
suggestion: how about extracting this into a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
You can do something similar to what I wrote in the previous patchset. Yeah, that's a nice change.
you can merge these two ifs into one
The indentation is a bit confusing here, it'd be nice if the overrides were shifter to the right past the first column of the new AuthorizationEntity line
This is dangerous, I think. The internal method should either be called when the variable is declared, or the trace is not enabled.
did we only want to set the non-existent type here?
Missing final
Let's move these necessary to the accessibleForAdminToMasqueradeAsInstructor
thanks for jdk 1.7 support
This should be a warn. Even though we're going to retry and everything might possibly be recovered, it is important for sysadmins to know that a failure happened.
What is the reason why this new method was added?
Just checking, but in some cases this is incorrect.
Since the commandId is not used, can you move it there?
Could be defined in class
Error message should be updated to match the form name
Wouldn't be better to call gwrpClient here?
final InfiniumGTCFile infiniumGTCFile.java should be moved into a dedicated method.
is / or /?
Why do we need to clear the tenant here? If it's not used, we can have two different s/public//
use try-with-resources to avoid extra close()
Just Log.debug instead of log.debug
should we close the channel here?
ExistingEntityException is thrown, isn't an UnknownEntityException a more valid choice?
nit: we can use final
Could we provide the values of this exception to the log message? In the case of an exception, we could log a message and move the exception to the end of the method.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "save". [![rule](<LINK_1>](<LINK_2>
It's enough to have only one factory for the configuration.
Maybe store the display name in the createResource method? This code is repeated several times in a few places
I'm not sure how it should be a warning message. It should be something like "User in retrieved token cache contains the user cache."
can you use the constants from SizeOf.
I guess this should never happen in theory
All of these local variables should be final.
Just thinking of this: <LINK_0> If user can not be blank or user has not specified, it returns null in case of no user.
Use the constant from CUSTOMIED.
Is this callback getting called on the user's app? If so, then mark this as @Nullable.
you can use lamdas.
The parameter is marked as @Nullable.
Can we use CorfuConstants.KEY_ELASTIC_PORT here?
why this's not a packet?
Shouldn't this be!transaction.isEmpty()?
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().equals(""); * Use a ternary operator when concatenating the strings instead of if/else blocks: java throw new Exception(tl("voiceSilencedReason") + (sender.hasMuteReason()? tl("userIsAwaySelfWithMessage")) : "
Please use a constant to the left hand side of the util.
Nit: redundant else clause
nit: use contigMap.get(0) instead of new Vector() for the array?
I think this will throw a NPE since the previous code will always execute the build. Maybe you should do something like this: java String subscriptionId = /api/steps.size() * 24; for (L : ooKeeper.list()) { if (zk.size() - 1) { return; }
This should be error level.
Will it create Audit Log for every 5 minute?.
Don't think it's necessary to show the button on the UI thread. The button might have been something like the following: showButton_showReplaceButton_setText(new String[]{ event, name}); So something like: showButton_ReplaceButton_.addClickHandler(replaceMode_) { showReplaceButton_.setVisible(true); }
What about using a regex here?
The original code was better, I think.
I'm confused by why this else is needed in Slice slice. I had a block with toBlock, but now it looks like the only difference is that the value is always the same.
Unused code.
We can use Preconditions.checkArgument to check that result is not null
Exception
why do you need to make this info instead of info?
You should use the constant DEFAULT_PROPERTY_REN_VALUE constant instead of null here in this case.
requestSent should be set to true after the requestSent, meaning the node is REQUEST_TIMEOUT while true is being used to request the request.
In fact, the payload is not null, so the loop above will throw a NPE.
1. Why do you need it here? 2. Custom Properties class is not covered by all usage of it.
Does journal.get journal favores over the same journal? If so, can we just use the TemporaryFolder @Rule?
Nitpick: return workflowVersion.equals(workflowVersion.getName())? null : referencePair.getWorkflowVersions().removeIf(workflow -> Objects.equals(workflowVersion.getName(), referencePair.getWorkflowVersions())).stream().filter(workflow -> Objects.equals(workflowVersion, referencePair.getRight()).map(workflow -> Objects.equals(workflowVersion, referencePair.getRight()).filter(workflow -> Objects.equals(workflowVersion, referencePair.getWorkflowVersions())).collect(Collectors.toList()));
It would be a bit faster to sample before applying the map.
The return value of the trace is only used for the experiment and not for the experiment.
Maybe use the cache.getCache(testName, data) method as well?
Log message should get cleaned up to remove braces.
We have to do the same thing, but we do not support the first element in the list. I think we need to define the size of the list, and use the iterator to do the iter, not the list. In general, for loop, we do not pay a cycles on using the iteration over the list as the values.
inputSchema is not null, you can use the existing converter
I think it would be better to test with some more description instead of exception.
From a commit message this could also be a link.
We should create a separate, generic class for this execution, since the body of the method is always the same.
I think it would be better to keep this log in the caller's log
If number instanceof Integer is always false, it may be faster to check if number.isNumber() is a boolean.
The return value of prepare/execute should still be done once as it is called. I think prepare does not need to be reset.
info: can't find a better name
should be: model.setSsh(model.getSsh().getSsh().isSetId())
This is not the standard way of getting the domain from db, you should be able to use StorageDomainStaticDAO.update()
Why "root"?
Not needed.
It looks like you can drop the trim altogether and just scan for that case.
I don't get the style here: the final were on the same line and the return can be removed.
Why do we need this condition?
Related to the commend doing this test in the test code? Maybe I'm missing something, but I see you're testing this.
To prevent the NPE, wouldn't it be better to let the exception bubble up and fail the test?
Any reason why the logic here is different than for userData just above?
If you do the check poly.isEmpty() then you could create an array in the first clause and if-InteriorRingN.isEmpty() > 0 anyway, you could do it earlier and if the index is met not create an array in the first place.
This is not the same as the one in the PR,.. and there are many other places. You can just use "group" and "id" for all VMs.
Isn't it easier to just do something to turn off the model here. Like we do it after the test data is updated.
If this happens, you need to check the type of the thumbnail to be convinced by this to return a Status.
Did you replace this with LOG.warn("Could not retrieve rule with id %s referenced by a non-existing rule key", ruleId, RuleKey);?
minor: I would suggest renaming (1)currentReplicas to previousReplicaId (2) updated to currentReplicaId * Set<String>* at the end of this method.
Extract logic to determine index name into its own function since you could also reuse it in the delete index and add the Putch core?
Why is additionalNamenodes.length() necessary?
use context.getComponentId() to inject into event sender
This can be simplified to just "return current!= null" and remove the else clause.
I am not sure how this worked. I expected it to be called during first checkpoint listener. The checkpoint listener is completed then for the CheckpointCoordinatorExecutor. It appears that the checkpoint is not necessary. But we have no task yet. So, the checkpoint listener should be responsible for closing the CheckpointBarrierListener by creating CheckpointBarrierListener asynchronously. We should also have a callback in CompletableFuture.
Doesn't matter much.
Would be good to explain why the change to :wink:
![MINOR](<LINK_1> 'Severity: MINOR') Move this use of "get" method to a separate method. [![rule](<LINK_0>](<LINK_2>
I would change this to: {... } because here the caller is going to write no bytes to a file.
I'm seeing this on the next line after the 'if'. Should be moved up into the start() method.
Why not just do this on windows? It looks like you are doing this for you.
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
It doesn't have srtpManager on ssrc/main/java/org/rtpManagerUtils.closeStreamListener I think we need to clean up sntranslation
We don't need to do this in the constructor, can we just use a local variable to reduce GC?
check topology id before creating the new version
@inverno We should still take advantage of the "name" variable. This is not going to work at all in this PR.
nit: can you move this to a method and then use the AUTH_TYPE_UNIT here?
Wondering if we need to clean the folder when the test is done?
Does not handle entry being removed or not modified.
Do you think this is necessary (and not.now().plusDays(7);
compareTo should not return an "id" (like "id")
spaces
The exception should be logged as a warning
Another example of setting null before loading...
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
Shouldn't these be else if?
This should be shared with the other test methods.
Wondering why this needs synchronized?
This code block should be using the currentCard.textview_desc.getValue()
This is more efficient to define a new field for each test, i.e.: new Argument(-21, "and not yet confirmed")
I know this is just a refactor, but please remove the return...super.tearDown() still needs to be called at the end.
gaps is not null?
I would suggest to swap the order of these checks, for example, this: <LINK_0>
What about extracting a method to perform the calculation?
Is it possible to be in the partService? I would expect it to be inside of the if, and return true here
Again, the local variable ListDataProjectListDataProjectList should be renamed to listDataProjectDataProject
if (zoneStrings == null) { return null; }
We need to check if oldData is not null here, since we will skip old data
Because we're not using the subscribe() functionality, we don't need to configure a consumer of the SuspectainableConnectionWorker for this class. We can use the remote-client config and make the remote connection handle the /etc/subpartition stuff explicitly. This will inline the [this](<LINK_0>
I am not sure where does the snapshot get fired from the snapshot?
See above, I think this can be replaced by java return loadedModel.get(xml.get(fieldName + ".xml"))
Why not move the same logic into a new function for all 3 nodes?
nit: same here, should be RepositoryEventTypeEnum.EVENT_RESH_FOR_ALL_TRASH_FOR_ALL_WORKSH_FOR_ALL_TRASH_FOR_ALL_TRASH_FOR_ALL_WORKTREE
Please move this block to a method called verifyAndOpenBlock(), so that the value of the queue can be changed to a file, and the logic in the getPermissionOrOpenAPI was handled by the survey.
Do you need to remove this line? I think that at this point it wont work if the special case is not covered.
return true might be a bit more straight-forward and you'd save yourself one variable
[minor] Space before {?
same....I'd be happy to use Unchecked.wrap() without wrapping the rest.
debug
@ochaloup, I would have expected the ts down under the if (...is this what I see? There is no need to check here if the xidsToRecoverForParent was false, which is what you have here.
Why catch and then catch here? What's the other catch?
The code that says "with path to {0}" should be fixed by any other tests.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent() here.
This feels like a good behavior... The only thing I can see is that the test would be in a teardown() method, which is called after the test.
Can you explain this?
Is it possible that this could be null?
SAPConstants.TRANSPORT_SAP_EXT
I think it would be better to use constants.
This should be result.FILE_PATH_NAME for "updateDownloading".
getting the same metrics on both cases
add a null check for those 2 elements is not needed
Please add a null check, cause NullPointerException if filter is null
I am worried about this... This looks like a weak-based string ID...
Grate! I think we don't need an if (file!= null) any more after this.
Identification of the hyperLinkify are there. The jira issue is that the code for this one is not being consistent with the rest of the codebase, but previously it was working on a different issue (e.g. 'Xiso/run/modules/null/nullable' ) you should add the (...) to the list.
Useless extra line
static import formatFactory
new ArrayList<String>(revision) is a good idea.
the request is not null
I think this should have a label for the index. Otherwise, it may be confusing to debug.
Please make sure to create a new default message for this.
This appears to me to be a redundant check as it is already done in updateActionAvailability so the action would be disabled right
Better to use equals to compare string
Please use the equivalent [ILogical](<LINK_0> instead.
I would use that instead of System.err.println, this is just a warning and should be an error.
Should be able to do anything with the AtomicReference<Object> here.
I'm thinking that this should be moved to the resource instead of pulling the list from the properties. We can merge this with the one below.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
we can have a different order than the previous line. I think that we might execute this method in the first place.
JUnit asserts would be even better, as it fails on the class.
I think you should use the same message as above.
Same as above: java conf.setController(new ControllerConf());
what if there's no String defined?
getString("category.getString("title")) can be replaced by getString()
pass the exception as the second parameter to shutdownBlobStore.get() for consistency?
I think here we should use invokeMethodWithoutException() as this requires more information.
You can use the lambda expression: java.map((Thread) -> {... }
On a local branch of mine I have already removed the remove method of CoreRegistry. That you remove it here is a sign that it shouldn't be in the CoreRegistry for the first place. If you need a Rule for that, you can create a child context via Registry for the actual folder.
Does this print exception? If so, it should be logged somewhere
That needs to use maskedSelectionFlags too.
I don't think it's safe to do this here. We should probably have the property bePath somewhere, or just the binarySubPath variable. You may need to add it in the header map to the reader. Also, it might be good to make sure that the header value could be reduced to something like "CdrBinarySubPath".
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return. This avoids too "deep" nesting.
While I understand your question, I would make it so that you don't have to specify the path when you use a different property.
U.logHandshakeNeeded() sounds a bit like a method name, but it's a good idea to rename what's happening here.
Instead of grabbing all of this, I'd prefer to keep it as a public method.
For errors I would recommend to rename "Connection for project" to "r"
Was this inspired from kafka?
seems subsumed
Can you switch the Exception here for the 3rd parameter, like you did in the other cases?
imo we should be using a builder for the base-type when building the files, e.g. java SamlRequest uri = RequestUtils.encode(authnRequest, StandardCharsets.UTF_8);
almost same for all the test cases. #Closed
Do you think it makes sense to check configDetails if sslQueryTimeMS is null? There may be a configDetails for this configDetails if no config is specified.
The operation is a bit confusing, I don't understand why we need to clear region stop. But in fact, the regionNode is a table, so the Master shouldn't have been stopped. The Master is going to be running on/exclusive. Maybe the call stack doesn't make sense.
Thanks for refactoring this method
should be tried to replace usage languages with an array so we can find the usage views without an array loaded?
* Why are you added to the list twice? Is it because of no synchronization?
Please, move this to after line 50
remove?
I would suggest to rename it to _public_
This is similar to the other list, will add all fields to the list if the argument is in outputSchema.
Can you add a message that reads: "The user location of the initial location of the key\n" + "/"?
I'd prefer keyType.equals(keyType) to make the code more readable.
Why not retrieve the lock on the table? You only need to call it once in the loop.
Collections.emptyList()
I think this should be CollectionUtils.isNotEmpty
I just noticed this and I am wondering why the conversion to BigInteger is needed here.
@cuenyad Is it worth performing this validation? (int)
Could we use try-with-resources here?
Uh, I'm not sure this should be moved.
I would suggest to add a format string as option: java String specificOffsets = format(String.format("Currently Kafka source of option '%s' but was %s.", SCAN_OFFSETS, but could be formated.length), (If it is simpler, then there is a single value, use the regex to format.)
This is incorrect with two different tests to validate that the same time is defined with different defaultDataBaseName to 1234.
nit: move these two lines to a function called processor, so you can call it something more than once.
redundant line
if there is a style element in the list: this is not a DRepresentationElement, nor a DRepresentation but nor a semantic element...
Please change a static import to tick as it was previously.
This is not guaranteed if the cache is doing the same as the default constructor, otherwise this will throw an NPE if it is null.
It might be a little cleaner to just return here, to avoid double nesting.
I am not sure why this is needed here. The asyncReadQueue isn't used at all.
There is no need to use the same name in both if and the description. Just check for family.isPresent()
You probably need to pass this to some local variable so you can use some method to fetch the database, e.g. you're only calling tool.copy() since you're already doing it twice
addAll
This seems inconsistent. the methods are already configured with a fallback that looks for the Could not find the path... and this message could be confusing. Why should we have the fallback and a fallback string?
Why change to Arrays.asList(inputSize)?
This can be just List<Resource>
Formatting
I may suggest just do: if (m.getDelivery() > 0) {... }
Maybe Log an error here?
what about multiple storage domains?
What is the advantage of workDir() here? Can we avoid it later if we need to add more details in the future?
Parentheses formatting.
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
Nice. The SQLDatabase now has an SQLDatabase and it seems like it might be better to use the SQLDatabaseUtils class?
Missing final
Objects.equal()?
can we make this more readable something like Total runningCompactTasks = 0, stats.size() * dynamicConfig.getCoordinator().getCoordinator().getCoordinator().stream().filter(IntegrationTasks::getCoordinator).findFirst().orElse(null);
It is strange that you have _allTasksCount_ as a assigned variable between each iteration. However, you can remove this if statement because it is only used once after the first iteration of the loop.
Missing white space after the bracket.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
why not using z <= bPlayer?
Do we want to add a message to the KafkaFuture? Or could it just be KafkaFutureImpl::completeExceptionally?
This method is very similar to testTopic(). It should be able to create constructor with static method to mock out the work
You can replace this if with assertEquals(expected, actual).
not sure how this line was added here - this initialization is done in line 67 and needs to be removed.
Can we put this into a private method please?
1. Why the map isn't static? 2. Why the map is not static method?
else if (compareTime!= 0) { above, existingResult.setsResult(getResString.getResString("comparison_differ_time")), null); }
switch/case?
Please use the static import for String.format.
Slightly unrelated, but the selection listener should not be added to the SWT.CHECK
Duped code. Any way of sharing?
[optional] List<LINK_0>
I think throwing RuntimeException is sufficient here.
You might want to put the k2 to be more intuitive as it is being used by the method above
Wonder if we can move this to the constructor, since we only use it once.
You need the "build"s to avoid the toString() appending the weight to the standardDeviation.
We can't need to hide the loading indicator if we get the data from the outside world.
The actual fix is this alone right?
Use File.separator instead of.
Just curious.. should this be based on the other callers of this method instead of the method? It may be unnecessary to define an inner loop, but it will probably all the time.
The service is not used for this test, is it intentional?
I think you meant LOGGER.debug("No Kerberos", rootLogger call.
do not use hardcoded values for encounter
Add a severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Now you can use index instead of getContributionItem
to a exact issue, shouldn't this be Thread.sleep()?
@vilchik-elena why do we need both tests?
Since the entityClass need to be a separate line, it seems like this should be entityClass
Not sure how you want to handle this, but previously, I don't know if that was intended?
This should be in a finally block. Otherwise the caller might see an NPE.
This catch block is too long. Line wrap not in a separate try/catch block.
You need to set this to null by id, you don't need to have a null check before calling save, so this will break the test, but for MultiOrderType and gain some extra checks
Don't bother, but you can probably call it something like activity.create(v)
Is there a reason we are performing this same check twice?
why not: boolean ret = false; try( Connection connection = ds.getConnection(); PreparedStatement prepareStatement = connection.prepareStatement(selectQuery); ) { prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try (resultSet = prepareStatement.executeQuery()) { if (resultSet.next()) { ret = true; } } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_0>](<LINK_2>
else if on line 1 above, then maybe we could remove the else, but I think it could be fixed in this PR.
Why not createNetwork?
Replace passenger!= this with!Objects.equals(passenger, this)
Why do we need both of these two methods?
We should un-use the TTL of the controls.
suggestion log.tracef("L1 in progress");
I think you should put the label into a constant because you can use it here.
output row group is not used
Needs a null check for the current id, otherwise this is a risk breaking a dialog.
This would probably be a good time to change the logic of this class to use the static level (as this would not change much in the future). I would like to keep the changes in the field and change the constructor and access the field as protected.
Same. Should this be HTTP?
lo assertArgs even?
Would be good to have a switch statement instead of these two.
merge with the previous line
I wonder why this is false. Can't you return true?
Can we extract this code to some method?
Note that this constructor is public API, so you could use the following: this(schemaXml, null, schemaXmls, "invalid Solr schema file,...");
As before, this is shared code with File..CompareEditorInput. Shared superclass?
refundHistoryId={}] [refundHistoryId={}] [refundHistoryId={}] [refundHistoryId={}] [refundHistoryId={}]", refundHistory.getExternalId(), refundHistory.getStatus(), refundHistory.getExternalId());
What is the reason behind this change?
ejb3SubsystemAddOperation.register(reader, element, "filename");
do we need the case insensitive checks?
I think "nestedValueIndex" is always using String.format. It would be simpler to write as: List<String> nestedValueIndex = Arrays.stream(nestedValueIndex).map(item -> nestedValueIndex + ".nestedValueIndex", nestedValueIndex).collect(Collectors.toList());
We can set the default value of DEFAULT_LOOKUP_ORDER that Config.key().key().toString().
Typo? "Yshould_A"?
suggestion if (isPaused) {
I think we should add a check here to set the time shouldn't be set the time. This should be done on line 185.
In this case I think it might be nice to go ahead and merge these into one log.
Use Guid.isNullOrEmpty
why did you change this? It was a ACTION_TYPE to a UNKNOWN_FAILED status.
nit: I think these lines are not needed. Rest of the logic is that checks the map if the map is empty, which makes it easier to see the map as early as possible.
I think we should replace the 'private' visibility by 'TheSymbols'.
We are going to synchronize on channel lock. We should be able to lock around a channels with the same lock.
Remove from local cache. Publish.
I would prefer to return the field.
this is a larger change. if I handle the current exception using JellyTagException, then it is 3xt. (for example, if I handle the current logic correctly)
Since ASN1InputStream is not being closed, the service constructor should be removed.
rename to launch
> I am not sure if you could just use this here: > If you don't have to touch the code, this is quite a bad idea. > > I am not fully sure, but you might want to consider revising the other two settings. I'd say: > [](start = 7, length = 48) Should this code be converted to the following? > [line] = getPrefix(Alt-L);](<LINK_0>
Should this be removed?
@NielsCharlier remove these empty lines?
Yes, I think this would be more readable (and the same UI would be something like parseFontAdd("style.sample.title", String.format("style.w.coup", "text-through", etc.);
can you rename nativeJavaLangImports?
Again, the code is broken. Instead of this, maybe it would be better to read if (input.getGroupType()!= Group.SIMPLE) { return (AggregateCall.isSingleValueCheckAggregateFunctionSupported(input))?
Please use a regular if condition here.
It may be better to add a message to the job.
Even here, is there a possibility of an exception?
I don't think that unwraps the relevant alias. I think you need to add the alias.
This isn't necessary, it doesn't use the constructor for PreviewStyle for your effect on Act of effect, i.e. it should be all.addTargetEffect(new PermanentPermanentPermanentOrLa())
setErrorMessage
use { } around if and {
Nit: you should probably use this.cloudProperties.getCloudInfo().
Should this still add the following activity where the fragment is added? The RxView.search_tab_title property is set in ManageImageFragment. Maybe consider moving this logic to RxViewFragment and make it a private method
while at this, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
Wait over I would say if the action is null, the title is something comparable to factionIcon. When you add a action it to the file it's undefined, so the user can choose a something like factionIcon.setVisible(false);
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
Please specify why you are using ":" here.
Could you please rename this variable to children.
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).map(item -> (T)item).collect(Collectors.toList());
please log the whole exception
This isn't a change of users.
The assertion method should be replaced by assertThat(actualDetectedLanguageList).isEmpty();
This is invalid output.
I wonder if this is a problem for cases when the query is an array of sql. It should be SELECT DISTINCT.
Should this be catch (Exception ignored)?
:+1: for using the previous assertion
Nice way to do this code. It doesn't seem to be nice!
Can you please add a message to the exception?
I guess we will need to add some context to the exception message here.
I think this was necessary. This was the problem with the previous implementation, but only wut Okay. The problem was that the problem was the unit for the  WildFlySecurityManager class. I think this was intended to be unit tested. When I tried this with a change to build the WebSecurityManager class, I think it would be necessary to keep the WildFlySecurityManager class under the direct parent SecurityManager(*) constructor.
I don't think we need to set this to null. Is that right?
Fix cyclomatic complexity sonar issue
You should use a StringBuilder (the same goes for all the other usages of += on Strings for this PR).
Maybe the form should be set to null, in case the plugin is not initialized.
Why not define a new variable for this?
This "synchronized" seems not needed as TLSNIOWriteStream.shutdown() already protects it.
Did you consider to remove this list all hosts from the cluster?
We're using a Refsc.memoize: it would be cleaner and make JGitFileSystem an interface.
Maybe worth to make this a part of equals to avoid repeated calls to isNotEmpty
Why is this different from the one used above?
The random suffix is not needed for this test.
I would add // TODO: check if it is a repository.
It might be better to remove the installed properties too, so it can be fetched from the refresh while "run()" method.
I think this test is useless
Add newline before return.
What about making this change?
optional: you could add the first :
nit: space after if
What happens if there is no location specified? Is there a fake location in this case?
You could use a simple for statement instead of using deletedEdges.
Changed to problems if not using BigDecimal. and then using longValue() method.
It is better to make this check > firstOperator.currentCloseableIterator.hasNext() as the iterator is always returning false. Because > 0 is the condition as far as I know, won't this NPEs?
Catch Throwable here as well, so that we can easily see the error stack trace in the log.
Add final keyword.
Please use a better name (primaryKeys, primaryKeyColumns).
why not using getDbFacade().getStorageServerConnectionDAO().get(message)
NonNull?
Is this a typo? (e.g. should be 'Removed' or 'getSelectedDoctypes().
We can remove this if condition and add 1st null check after this if condition.
use this utils method to show error <LINK_0>
The rest of this function can be moved above the if block so that we don't have to wait for it. Also the results from the on_session is driven by the results from the on_session network call. However the results from on_session is drive by the backend and if the player fits into the PREFS_ONESIGNAL_PREFIX table in the FS will not always have the PREFS_ONESIGNAL_PREFIX. So we can keep the "OR" and put this into the _only_ conditional so that we can skip this else if the change above doesn't actually go into the "if" statement. Can it be moved above above to be consistent with the rest of the function? I would also go for that.
Same here messager should never be null. Otherwise we can't report.
typo
If you make this message more specific, you can use the diamond operator and remove this warning.
Must be Outcome.Benefit (AI must try to discard 1 card instead 2)
@kirankumarkolli - you need to update this file with the proper spotbug issue which is failing here : <LINK_0>
The declaration of these statements can be removed.
Collection or array
This change is not correct. It will be sent in the IInjectionTarget instance which means the same line return;
return getOninvokeMethod(MethodInfo.getOnCallContext(method));
Is this the only way to do this? It is invoking this in the synchronized block...
StringUtils.hasDurableSubscription(BinderPropertyKeys.CONCURRENCYProperty)
Why do you need to create a directory here? Shouldn't the file be deleted all?
I would prefer to use Optional<Boolean> here, like the other places below.
Can't this string be a constant? I'd prefer a name for the file to indicate it's going to be used in the code.
Style-nit: Spaces around operators
Why did you make this change?
Let's move this file name to finally block.
@praj for my best practices I would prefer to use TIMEOUT style in the code, at least in this case I think a reason the default choice is no.
I think this test is not necessary, right?
Although this makes no sense as it could be null for a collection later on, YamlMappingImpl start/end the original code, so we can remove the null check for sourceAsMapping.
I believe this can be converted to an AtomicBoolean
Don't remove anything...
transoromation is always processing (Optional) present element but the last element. IMO it would be nice easier if we could move Transformation.process(elementOptional).
i don't see any uses for the hardcoded clocks.
If you add an thenAccept here then the damage of the second clause is called twice, the second time should be successful.
2 corrections: 1. Static imports 2. Have this as a constant, since it won't change its value during the entire execution (reading purposes, but more importantly avoid going to check system property per each time the code is executed)
We should save even more instances by directly prepending to Lists instead of appending to Queues: java List<T> first = Stream.of(from(t)).filter(predicate.iterator(), firstComparator.reverse(predicate, firstComparator.iterator())); first.append(reverse(), second);
Should we use the executor here with the appropriate timeout (500ms).
Use a constant for isNullOrEmpty
Typo: timestamp -> range
Are these extra checks necessary since they all extend any superinterfaces?
Nit: I think the indentation of the ifs are redundant.
I think you really need this line? Can the following scenario happen that the verify() method is called twice? If so, I think you could add the timeout check in the countDown() and then set the status as true.
Use [Bundle.readLine()](<LINK_0> instead
for comparison with an enum it's better to use ==.
nit... You can say - " - [ ] ["...] This is kind of confusing.
Rather than invoking a simple in loop, you could have the methods [here](<LINK_0>
this is a little confusing, we're still using the input schema here, as it's currently a different behavior. Set the field and the input schema to a default schema, which is not consistent with the field names
Formatting (add spaces around operators)
I'd change is back to 50 for consistency with CDT.
Should we log or fail the test if we're not going to work on windows?
Can we log the exception, rather than putting the stack trace?
you can use the value for journalNodeBase
Must be object.change(db). The Change can be lazily loaded, and we may have the PatchSet but not the Change yet. So you need to pass the db through just in case, so the ChangeData can load the Change on demand if necessary.
final
nit:.with-snapshot-id -> <LINK_0>
Space after if
Either with <>, or completely without.
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_3>](<LINK_4>![MINOR](<LINK_1> 'Severity: MINOR') Do something with the "boolean" value returned by "delete". [![rule](<LINK_3>](<LINK_2>
java assertThat(foo1, "foo2").incrementAndGet();
@rvansa I would like to see it in a well-worker to get the image on the busy disk. Files() will get the imageID from the command line, so if you want to keep this one, it should be drive as well, right?
IgniteThread is created for each thread.
remove the extraneous space after the cast operator
No need to init local variable here. Just return directly
We can just check if oldStoreDef exists before doing this check. Same in your tests.
You might want to write the iterator and assert that the iterator is empty or not the list of items from the benchTarget and from the iteration?
You could probably do sb.append(IgniteUtils.nl_...);
Check log message before log.
No need to create a new Date object and then transform it into OffsetDateTime. You can move this code to OffsetDateTime.now() function.
if an exception is thrown for any reason, it is a bug in the git repo.
You could use the Bukkit API which returns a UUID instead of a UUID.
should be final
I think this should be ts - floorTS.
Define a final static int[] dist = Integer.MAX_VALUE + 5 / (int)(dist) vs a =?"
Would it be better if we could avoid code duplication with the getCurrentListener() method?
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
nit, do the same for the null check above?
It seems that CountDownLatch.append(value) is used in multiple tests. Maybe it should be used to put it in a helper method?
I think this should be removed
For now we should keep this method package visible only
What was the reason for this change?
Let's say why these statements were grouped together.
The indentation level shouldn't be changed.
please remove, it's not a good practice to swallow exceptions
update
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
why not just return subPaths here?
I wouldn't use this variable and the one above it (result.getGridSetId() + metaBWCVars.CACHE_USE_WMS_BACKEND_VALUE). It's a bit odd to have it inline or not.
nit: error message could be more descriptive.
not needed
I am not sure that this change is needed. Why the test is to allow both trim and isEmpty?
This call should not be done before we set the initial datya received. Also, this call should be done from the FilesTabView class
Does this mean that statement.isClosed() is useless?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
toOSString() gets platform dependent path - Consider the case where you are looking at shared indexing from different platforms win/lin/mac - wouldn't we get a different URL if it is platform dependent - shouldn't this be toPortableString()?
This looks good.
This should be a plain String[] array right?
This test is failing on my feeling. Assertions should not be sufficient.
should we consider to create the GroovyShell and pull request into constructor instead of creating them?
I rename BreakpointConfigurationDto to ws
Would it make sense to move this line down to where we switch to egress legs for the third phase?
This should be getTopologyCustomState()
Prefer get retval here as well.
maybe add a null check for instanceId?
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getClusterName(); - BigtableTableName tableName = clusterName.toTableName(configuration.getTableId()); - SampleRowKeysRequest.Builder request = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
like this should use JUnitUtil.getTestDir()
If you do a selection in the trace, the black-tree viewer would be the plot editor, the selection won't work. But here you have to re-open it in the view, each time the user can be cancelled.
When did we start supporting yE supporting yE supporting day? I didn't think that was supported in the current version of WPAndroid Devep.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
Warn log level seems to high for a normal state transition.
Instead of sleep, what about putting the thread's own flag to the Master class that you can use? Then you don't need to wait for a replication.
Why is this not using getpreferences()?
Use ProjectRights instead of InheritedRights, and just InheritedRights.
Please,a dd these lines and in drools-wb-common-stunner.ext.selectPage.business.api.model.getDiagrams().get(0)
Already added to the trace output, so you can put directly the canvas, instead of the whole trace output
Couldn't this just be return asString()? e.g. return Optional.ofNullable(myReturnType.get(i)))
I think we could have this duplicate as a method
is there a similar query for "Waited {}ms"?
IMHO it sounds like a DataBrokerConnectionFactory but not sure why we have an accessor
Even though it's here, doesn't there be a test for this? (applies to other pieces of code too)
I'd like to see this code further, the setFilter method contains the javassist even if "Is this file exists or does it make sense to put it in a try..catch block.
should this be final?
to be on the same host, you don't need to create an arraylist, change to: private List<VDS> parameters = new ArrayList<>( lunsSizePairs);.add(new Pair<>( lunsSizePairs, lunsSizePairs));
The mac address is now redundant. Please remove it.
So hide all dialogs in the same class, I am unable to hide the left side?
why does this need to be a list? Let's use UtilMethods.isSet(emailAddress) method instead.
Don't use the uuid temp variable, rather than just the name, otherwise we're just returning the hash call.
let's rename this to RelationshipRequest
Move this to catch
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
Should that be <=?
This line seems to be the same as the above one. Does it make sense to do it here?
nit: Topic.repartitionSource -> Topic.repartitionSource(topicName, topicTopic);?
We should fail if in at least one event is disabled. In the last iteration we throw an exception, or use isNewMessageUpdated() just to avoid changing the condition in the if.
Please use NLS.bind() here.
SpdxListedLicense = null; should be checked first.
It would be good to explain here, e.g.: // Friend results are all included. Own results are only included if some friend has a goal in the same category.
Or, assertThat(category.getAttributes(), hasItem(Core.TITLE)) (this will print a more useful message when the test fails).
Should there be a copy?
probably just move it to a different method so that we don't create an array for every read
Can we get more informative error message here?
Ths should be one sql statement where there is a join between calls.
order of operands
Does not need the code for this?
This should be another else if, otherwise we're throwing a RuntimeException anyway.
I believe that we need to use the same code as above. Could we have a private method and then call it from the base class?
Unneeded cast here
Static import the constant?
Place in ApplicationConstants instead.
this will use the "if" statement as it is redundant, also it can be simplified by: private boolean foundActiveHost(String system, String key) { String toString().getBytes(Charset.defaultCharset()).append(value); }
Swapping the empty bracket here, just add a else statement
do not change this test, it should still check if proper encounter is returned from createEncounter service
Remove this addComponent() (not 0).
requireNonNull
Don't need this change.
Why is this needed?
You don't need to check for null here.
if other.getIndex()!= 0 and other.merge!=null, this should throw a NullPointerException.
@werereren't we still need to remove this block?
Nit: might want to consider leaving this in a follow-up if statement, so that the user can at least see the running state.
I don't think we need to modify the exchange scope (instead of having separate maps)
please remove this log or replace it with a logger.
Why do you create constants if you have to use them?
Should use error callback.
Suggest to add an exception as the cause.
assertTrue is redundant here.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call() method.
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I guess it is cleaner and easier to understand, but just as a suggestion.
I think get was more approriate here
Checking this is probably redundant now when we return an Optional<LabelMeta>?
Minor improvement: Could use a static import here as well.
is it really needed?
WDYT about moving such logic to [this](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this conditional on the "if" condition. [![rule](<LINK_1>](<LINK_2>
Let's remove alias check
I think there is no point in going to use here
You can use try with resources
No need to check for null
Here you could directly use TextUtils.isEmpty(parentId)},) instead of a loop.
Duplicated code please introduce variable.
Device should be rebooted before test starts, to avoid clash with any ongoing OTP processing.
I think we need a logger.
If we throw an exception it should be logged with the same message.
The formatting looks off.
This should be: java if (optional) { return MirroredPackageName.match(JCTree.getId()); } else { return IdScanner idScanner.id(s.get(idScannerId.class)); }
I used the same logic as the one above.
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); }
Can you replace lines 354-361d with : > I am pretty sure this works as long as the default limit is lower than the number of characters, but how about removing the limit?
There is a lot of conditional here where you could do this check and throw an exception if it is null. At least in the catch block there should be a finally block.
This is not a loop but just have no effectors and isClan.
Shall we add service as the first parameter to log message
@Happy-Neko we should ensure that null is taken here if we have GuidedMetrics.setLanguageVersionResolution(conf)
Why change it?
there is no guarantee that this should always be an HTTP error.
This is usually a good idea.
Instead of this code, could you create a find symbol _and_ method _and_ return null; and add it there? We're already doing this themselves right?
This is not a good idea..build() might be used in the.getOnlyElement() (previously existing code)
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block.
Is it possible to catch InterruptedException here?
Why are we replacing the field here?
Would it be better if this method would be one that maps to multiple config values, and then do deactivate() on the configKey.
Why not use the moduleMap parameter here?
nit: what if we change the adapter to a default View instead of checking null? : View.VISIBLE; View adapter = View.GONE; adapter.get(View.GONE); if (adapter!= null) { return View.GONE; } return null;
Declaration should just be Map
This way it won't return any result, you should wrap it with "addLinks(Arrays.asList(vmTemplate));"
nit: Could use HttpUrlConnection.HTTP_OK constant instead.
You need to also store the end time here?
This should probably be WorkflowInstanceAction.getInt()
setErrorMessage
I don't see a need to keep the declaration on a separate line.
Normally we should be skipping the service.pid key in the generator, not in the horizon set. I would expect that the endWindow is in the middle (and you would need to returned the windowState)
Move to L428 as the 'if' block below, then we don't even need to compute if its not boolean. And we can directly say registry.getTargetNotifiers()!= null. And then we don't need to check for null, as we just always have to notify one layer in some cases.
style nit: remove the spaces before && as well
User can't be null here? If you use addEmailAutoComplete.
You could have replaced o.getAccountServerURI() with o.isSyncingEnabled() here.
@rishabh-997 "src" is a good place for a common function.
Remove the AuthenticationException catch block.
I think that we should use the same time format for the log message.
Should all of these be public?
@maria-farooq Hmm, here we are doing the right thing, with the current logic, we should be comparing by host, thanks, this is why I didn't want to squash the volume of HTTP/hosthost stuff. Port is a part of the PR, so I'm not sure I like this.
We should also define a constant for the path - you can use the prefix as context for the path
This test can be removed, no?
Unless I am missing something, the array creation with new Object() method is not needed, because no passing in a reference to the method.
This whole convoluted mess can be replaced with Paths.get(config.getPKIDir(), "certs", name)
We can't assume this will be called when the upload failed. I suggest to add a new method in the IndexOutOfBoundsException that calls it from maxMediaIdPredicate.
This is already private. It's just a matter of personal taste, but it might make it clearer.
There's no need for the null check here.
Why do we need to have OpenShiftBinaryFile enough? It's not used anymore
should not use the "Null" part.
I tend to put this (which is a good question :() (which is the same case with below). Maybe you could extract it to a private method, something like addCurrentChunksFooter or some similar, so it's easier to read?
This can be simplified, right?
Can you please also do not need to pass the Long.toString, as a parameter? This way you don't need to convert the Long back to String
Why not have the cancel(true) and cancel only the first? Then it's a issue if we have a span start or not.
RenamingThreadFactoryProxy would be nice, since it is the default value when you have a diff
This could also be removed
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this method final so that it is only instantiated once. [![rule](<LINK_1>](<LINK_2>
needsComma I think would be a better name than hasComma
You'll need to check for null before calling'remove'
this can be simplified to ((Util.ICP4D_DEPLOYMENT_URL)!= null)
I think we should consider making the "false" as the default if there is no "true".
Isn't it the createCinderDomainId method? Maybe we should add an audit log for the audit log, and say here it in debug mode.
Should we consider a list of Guid so vdsmTaskIdList will be null?
Any reason this call was just moved from there to toPage method?
Log the exception here.
rm
Hmm, this is not really required, if we have more than one timeout we should at least log those IgniteEx messages,.
this is hard to say > value > e.g.: int startTs = get(Sha256Hash::computeHash)?
Instead of this change it would be more convenient to encapsulate the filters inside isAbstractDebugExtension() method which returns the original value of the filters, not the start of the method.
A cast to IStatus is missing here.
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "set" method. [![rule](<LINK_2>](<LINK_0>
You can use try-with-resources for both scanner and csis in the same block.
Is there a reason to move this declaration to a separate function?
You should put this in the synchronized block below
I think you can't really use the connection if the user can create a connection with this as a result of the try-with-resource block and add the 'if (conn!= null) return;' incase the connection isn't valid?
And here we can't use the regex for ""
build does not allow end of'refSeqWalker' object
Use assertEquals of "nuxeo" is the "nuxeo" literal.
catch operator?
This is a 5-line method that you have to be in the current thread with the requestSize/2 of the output is in the default thread (main thread)
If this is null should probably be treated the same
now you can just do int scanId = telephony.requestNetworkScan(
- check mKeyPair.is not null
I'd suggest keeping this as a java.lang.Long fromEventId (if people don't import this class)
Nitpicking: do you mind splitting this in 2 tests for readability / style.
Check args?
Could we include the path /path?
And this is not needed
I think the braces are redundant now.
nit: the return type here is redundant
Can we just use tpchValue.equals(columnType) here?
Shouldn't the message reflect the new metrics?
Is it possible that the connector will never be 'null'?
I'm not sure this is correct. If id is null, in the error message you're trying to mix it.
Please dont do this test, it is just a role (for the service, and the name of the test)
computeIfAbsent?
Use.get() instead of.add().
Can you also add a reference to the modelTypeName here?
Should be!Boolean.equals(object)
Won't this corrupt the second argument?
we should handle return types java.util.Date and java.sql.Date
Why did the change to 1?
why do we check/break here, it is already covered in the while clause condition.
The field name has a getBytes method. I was thinking that the class would have a BytesChunk.SIE that would make it more clear. There is no need to convert the string to a byte[] and that to get a string.
typo
now that the expected value is updated, is the replace all still needed?
Missing <LINK_0>
Use a standard tag instead of using a magic number.
This should handle the case where the map is not empty as it may not be returned by the map. Even though the map is immutable, it may not be exposed from changes to client code. So this map is not intended to be used as a above removed method.
We should log the error and print the stack trace.
This is a test, so let's not get it. If it is a problem, better to put it in a test method.
you may have just copied this over, but is there a reason this returns null instead of catching the exception and returning ""?
Please don't print the line character inside the append.
What is the benefit of having a switch here?
I have a feeling that if we try to ling the code, we need to try to initialize the streams. If we want to try first, we should try to avoid the code duplication. But even though we need the try-with-resource I have been trying to read the code, I almost tried it and it was unnecessary. The try-catch is going though.
static import of get.
A random header id should be added if httpHeaders is null.
typo
Can you change this to have the content of the SubscribeHelper.writeNotificationChannel implement getBytes() so that it creates an array each time the content is reused?
why not use a try-with-resources here?
Can we use the same MetadataFieldUtil method?
Perhaps single quotes around actual code
@inverno This null check is redundant.
Instead of passing a listener in the middle of the callback chain, should the queue reader manage its own queue? Can the queue be full?
The length can't be null, can it? if so, do we need check for length and MAX_NUMBER_OF_UTF8 or something similar?
Not sure if this is a good idea, but I think it would be more readable if you was something like: java.filter(NotificationCategory::isRead).map(NotificationCategory::getName).collect(Collectors.toList());
how about renaming this variable to noStarlarkHandle?
This test will pass even without your latest change, right? Seems like this is now always a test-method.
final
I think it will be better to perform the removal of the managed block disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
minor: this is a little confusing since you are changing the logs in this file. Please change this to debug
maps should have a better name.
Remove the catch block and let the exception propagate normally (which fails the test)
Could use the Constant.messages.getString(context) method.
You can use game.getPlayer(player.getPermanentOrLAND(...)). That way always won't call onNext() which doesn't require that.
replicationation -> data,
We need to get the LifecycleListener from the interface, maybe use it for the common controller.
Now that you have the same type, why not just check for null?
taskGroupEntry is thread-safe so I think it should be possible to make this Runnable instead of TaskData.isRunning()
Let's move this into a separate function, like boolean updatePartError()
[minor] Just use getIn().setHeader("birthday.APRIL", getStartOffset(), getTempdate());
Is it okay to throw an exception here?
Please rename this variable list to pushResults for example
Does it make sense to log the exception?
I think we should use assertEquals, it does the actual work.
Why this change should be a part of this PR? cardinality < 0 probably means that completely different approach should be taken to compute topN, setting just to Integer.MAX_VALUE may result in a lot of excessive work and allocations in run() method.
Can these be extracted to a method?
no need for the final to call this method twice
please use.equals() instead of.equals()
I think we should put the thread name in a constant, and then use it in the runnable instead of waited for "GONE".
assertEquals(boolean actual, boolean expected)
can it be faster to call it e.g. if (myStream.length() == 0) { return 1; } else { return "this".
nit: seems we can just use MAX_CLUSTER_SIE - 1 here and in the other places, since it is not needed
null -> getMessage
there is RepositoryFiles.trash, can you please use it here instead of toString()
Please use the SynchronousObservable type here. If you want to be consistent with the other class, I think there are some operators for this.
Is this really an error situation?
Instead of setting this current user memory, just use the supplier
I think we can just check if it is empty before throwing an exception here.
The condition is starts with a true statement, so it indicates that the exception is thrown. If there is no current device, there is a bug in the current run, and we should be able to remove the code that calls eccPushed.getLanguageConnection() and getLanguageConnectionContext() method.
Just a small note - after changing "driver" we are still using _ inside the service_ block, the logic is different than what we found in the _install service_..
Please don't use the exceptions, so no need to include the parameters.
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility methods for creating and deleting a case.
rename to event
This should return!TypedObjects.isEmpty(request)
Agreed. I'm wondering if we should not _not_ allow the component to be empty, or could we just use an empty string?
I think it is better to extract all this code into a method and call it from both the t1 and t1.getLocalizedMessage() as is too long.
Better use java if (!iterator.isEmpty()) { return new IllegalArgumentException("Incorrect path to folder " + fileName + ". Reason: " + fileName); } The reason is that you are unable to create your own files with the provided path".
It seems we have two methods, except one can be unified. Perhaps we should change it to Vector.of(...)?
why not write it using getGitTreeOptions().getGitTree() and then write to it?
this method is big, please refactor to more readable code
Can be rewritten as: if (cacheTypes.size() > 0) { cacheTypes.add(sortedType); }
same question as above for request
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
Return an empty list instead of null (which probably doesn't change the behavior of the null case).
replace with ProjectUtil.isFolder
This is a little confusing. I'd suggest you replace "ternary" with "> " &&... ".
I'd rather go with a NULL value.
Shouldn't we check if long calls are made and return null?
Code role should be removed.
I think it would be more readable if it was a stream iteration over the set.
is there a reason to synchronize on the thread, or the thread is interrupted?
Hey @inverno Why don't you get the listener outside the test?
This should be put into a constant.
This should have a space after the comma.
Writer is not closed, so just close it (and 'close' is not needed)
I think it would be best to add a case for the evaluator's values (in case it is one of two keys, or two different conditions).
Could be public
How about changing code block (line 141  line 147) to following loop: for (RequestOrResponseType requestType : EnumSet.of(RequestOrResponseType.PutRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.GetRequest,
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase is not necessary
final
This is the same logic as we have the String.join method which is cool to take the feature of not only the duplication of this logic. So we should probably move the reporting logic out of the sb.append method and call sb.append(this.arguments) into the build method.
I think you can use the interface instead of this:.withClass(() -> SIMULACRON_RULE_TOKEN).equals(expectedValue)
You can just use an if (this.channel.isPlayerDisconnect()) {...
This should probably use the Guard class to check for null and empty
A much faster way to do this would be to just do a lookup on the computeIfAbsent.
could we use a more descriptive name?
Probably should be SURF RAM login, same for description.
There is a typo here. Sentences should start performance (it can be more specific)
We should move this logic to a helper method like createOutputMessage(Message<?>) which is called on the next line. That way the caller doesn't have to worry about HeaderBuilder on its state.
please remove the 'if' statements.
Looks like you're mixing a dialog and the activity similarly pasting code. I think a better approach would be to listen to the event and call resetCall() or something like that.
You also have to remove the m_isLeader check here since it's only DONE if m_isLeader is true.
Is this method meant to be updated?
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
assertTrue instead
just use == for an favor of a switch and an else block instead.
DatastreamProducerRecordBuilder?
getScore() doesn't look like milliseconds is used in the
This should be simplier than it will lead to more than one
You can move this check to superclass
This method is doing the same thing, but you still need to trigger the watcher for the data activity
i think this can be simplified to get rid of the null check and return the result of getEncryptionKey() == null.
Should we really have this a list of tsIdsToFilter?
typo
You should have the same, and just return at the end of the method.
Use for (String url : headers)
This fits properly in the previous line
That would be slightly clearer if you would change this to put the sleep in a loop.
Not sure what this test is supposed to test.
Can you use "hibernate" here?
is it referring to smallestFilesToCompact is a little smarter than just calling getSecond?
how about to assign the value of the block below instead of loop?
suggestion } catch (NoSuchAlgorithmException nsae) {
s/originalContentType/type/
I don't think we need this. The readBuf method is already read from the ByteBuffer, it can't be used.
when can be simplified to Map<QueryId, Long> entry = map.entrySet().stream().filter(queryIdMap.values()).collect(Collectors.toMap( queryId -> { map.put(CH_FREE_TAG, "..")); map.put( queryIdMap.get(FORCE_FREE_TAG, getKey()); return ImmutableMap.copyOf(queryId, FORCE_FREE_TAG)); }
SAP
Why don't we assert message here?
remove the use of setBankState in this case.
Should we be using ValueObject.asNativeString(p) here?
could you change this to an if?
Use constant for port
Activator.PLUGIN_ID use activator of tmf.core
I think a better name for this - "group-id="+confname) or something like this. Or perhaps "group-id="+confname and the setter that could do the same here.
Don't need this line.
I think it is correct to use resultsService.next() here. That way it will be faster for the developer to write to the list of services.
maxSize does not seem to be an index, the minimum size is the minimum between buffer and the maximum size. Is there a reason you dont want to convert it to an array?
[minor] Why are we doing a %s here for better readability?
Should this be: java if (isStudent) { name = Const.getUser(identifier); }
It could be simplified to... java data.get(obj);
Why the copyReqBuilder.copy(source) and copyReqBuilder.copyReqBuilder to copyReqBuilder?
final
We could use getDefinition() as an Optional<Definition>, and store it in a field so we don't have to worry about nulls.
Is this with an error msg?
since you're using the Objects.hashCode - why not just use getClass()?
This looks like a copy paste mistake, it should be Sns.
Up to you.
Good new line: we could move this to a separate method: private void addToolbar(final px) {.addRightWidget(useGitIgnoreLabel_().getPath()); }
if this listed the available names it'd probably be very helpful for people
use Field.class
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if addDefaultRoute fails, perhaps it makes sense not to set mDefaultRouteSet to true?
(minor)
1. It will be nice if we can remove the RuntimePermissions from here - only ET1 and I added the version to EntityTypeSet.
I don't think you've sufficient the toString() operator.
I think saga.getClass() returns the class name, but what is the reasoning behind this change?
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.computeIfAbsent(recipientTeam, k -> new LinkedHashMap<>());
In case of exception, we shouldn't make a command with nocallcall (I think it's ok to ignore it) and set cellElement
should probably be +=
You could eliminate the need for the function here. You could just inline it.
If the nullable type is null, we should have a non-null optional instead of an empty collection.
checkTypeMismatch at the end?
Can we move this line to the front of the if statement?
Also, here we should use Arg indicating whether this will happen for all transform function is in the Arguably: java interface TransformFunction<String, Parameter> { // here }
Should we add a metric here?
I think it's better to close the connection once we're done with it. If we get an exception, we can't close the configFile at all.
store method: String[] w = "view"; for (String entry : entries) {... }
I think this change should be in the else block below. In case of an exception, the TransportException is thrown and when the prepared statement is not executed.
I believe you should put this line after the first assertAllInformationMatch method.
here we'll want to throw only if we are not already tracing this packet.
Please merge both the conditionals into one
Remove the containsKey wrapper
why do we need to do that? I'm not sure we want the token to be able to know if it was creds, but not creds.
Here could you check for null, and also set the value to "false" in the first place?
You could also use getString() in place of strings.xml.
extra space
Shouldn't this be "' with value '" + target + "'");? Why is it needed for the other methods? Shouldn't we just add this as a constructor parameter on the field value?
Use _int_ instead of _byte_ to allow for values > 127...
What is the use of expected.patient?
@felipeaziz Use Integer.compare(techList, person.getPositive().getCode(), Comparator.comparing(Technology::getName));.
Wrong check, should be!unifiedMessage.getVariants().isEmpty()? Also it seems that UnifiedMessage is already being null and empty.
Use 'getEntity()' method to populate the connection with null as a parameter. Do the above logic the following into a method to make it more readable: 1. Create a new instance of WorkflowException and try to do the same for this by requesting the database from the DB. 2. Get the database in the "GAL" ( handle by GET_STATUS_QUERY: 1. Change the DB to a new PreparedStatement object, then retrieve it as a query parameter, otherwise you don't need to handle nulls
It seems like we are creating an authorization user for each test, which means we are dealing with a user in a repository. Would be better to just throw an exception here, which means we can catch the WorkflowException that is thrown when an invalid API user is actually logged (e.g., non-admin user-facing), and then let the user pass the organization information.
Typo here.
Isn't this a bit present? I think it would be cleaner to throw an exception if we could have a RNAResource throw an exception if the latter is not found.
>80 chars and extract
You need to check that the value of these options are not null.
I'm not sure why I didn't get this in the repo. Better to use RtForks instead
log the exception
I am not sure which operation we need to handle. What happens if expiry is null?
This can be a bit more efficient as it was originally added. Like other pool.acquire() calls.
Shouldn't this exception be logged instead of printed?
Use already definedVmDevice in the model provider
Do we need this?
This should be an IOException. And what it throws?
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog refs/remotes/origin/master" in a repo of your choice.
Missing a try-with-resources.
Cache is closeable, so I'd prefer if you wrap all the in-memory transaction in a try/finally block: java if (c!= null &&!c.getStatus() == Flag.CACHE_MODE_LOCAL).size() > 0) { c.stop(); }
Any reason for the specific guard? I.e. GTK3.14.13 instead of 3.14.0. If there is no specific reason then please change this to: if ((style & SWT.VERSION (3, 0) ) {
You might want to consider logging the current metrics rather than sending it to the metricName?
Should be checked for null.
Why is this second block needed?
.map_url ->.ifPresent( webMapItem -> {
Formatting: addDnsTimeoutEvent(new SimpleBindingContext(SystemClock.getCallName(), TimeUnit.MILLISECONDS));
Change 'else' statement to block i.e. add braces.
How about making this a constant?
nit: Why can't we just do List<AbstractReflections> itemType = dataTable), EDIT:
I think you should use streams here instead, otherwise you're iterating over the collection.
Shouldn't we rather compare the number of entries in the hash and set the actual number of entries in UserAccountManager? If we have a new UserAccountManager, we should've converted to a directory and the Context is to get the initial value from the SyncManager.
We should add a space after the if and before the {
Maybe consider String.valueOf() to circumvent NPE.
Why do we need to create the list if it's not going to be used?
Absolute path for example?
How about a const or org.junit.Assert. prefix like blobContainerSize?
I think we can have a "normal" Java for now using Java 8's Java 8 and Java 8's Java 8's Duration.ERO;
The constant must be before the variable.
I preferred the old way where we had methods getAllDimensions. BetterCodeHub will probably ding this for complexity and number of lines.
I think this check should be done in a private method.
It looks like this path is not needed.
if you look at Util::checkForDataFile
@vkdrn Thanks for toString()
You may want to use Arrays.asList() to remove all null checks
Why does this return srcGlobalSnapshot? It should either be called from after snapshot and then inside the loop and then inside the loop.
if the disk doesn't exist you'll fail with NPE here, please first verify that it exists.
I'd put this in a try/finally block, to ensure the callback is closed even if an exception occurs.
It's better to use JsonValue#toString()
You should use a ConcurrentPack[0] here
You do not print in the exception message any context information, it is sign of bad usage.
**entourage** block can be tricky to debug. Maybe we could include a case where the user has to know whether the user is a user or not, and have a case where the user has been logged out.
Why do we need to synchronize on the whole method?
I'm not sure this is the right place to use getRefundsForPayment with it. I think this will be the full refunded paymentExternalId and you can just do: java return Optional.ofNullable(transaction.getRefundsForPayment(transactionUrl)).map(Payment::getRefundsForPayment -> { String gateway_account_id = builder.readEntity(RefundTransactionsForPayment.class); return Optional.of(transaction); }).collect(Collectors.toList());
recommended, but in this case, we can write result, and add statically import for appenders
primitive boolean
I think we should also store the selected name as a field, otherwise we might have to change this line to something like isFontLoaded
Would it be a good idea to keep those indentations as small as possible?
Feels a little funky that this check is failing for me. If the latter sounds like it was to begin with, then it will have to go into the pipeline.
This assertion would be better (and not be needed in the new FileSnapshot)
Unused method in the class.
We have to improve readability here.
can contribution.getImage() be null
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to be used here.
/s/in/is
Call RxJavaHooks.onError so no exception is lost.
Here reset should not be inside update() method, otherwise since StampedLock is not reentrant, this could be deadlock
I think it's better to use a local variable for the base class to store the CounterTreeViewerEntry
won't this catch(Exception) catch a checkArgument() failure?
Maybe extract this code to a method?
The method should be the one that the customPanels should be created.
Is this part of the code still needed?
Can you make it a local variable?
final
EntityType.getRegistry().getRegistry().
I would put this in a util method in PlanUtils.isDefaultPlanWithType
Have we confirmed that permissionList.add(permissionList);
the last two changes are unnecessary.
It would be better to call getActivity() here instead of getContext() as a parameter. This way we'd only need to call getActivity() once.
This must be a builder. It is the id of the provider id.
why is this related to deploymentconfig now?
you need to call force.force(true) twice here
please use System.getProperty("java.version", "java.version"). The reason is that we use java.util.Properties (as this is on Java 8 conventions)
I think you should remove the formatting of the original file and make it shorter.
this.
This should be a builder.
no need for qualified name here
This method has an external annotation now.
Please add also VOOBSERVER.
No need to use UriBuilder
Could we keep the implementation so developers can override how the notification is built if they want to add new features or modify settings? MixpanelPushNotification.isValid is false only
Not needed.
Why not using.size()?
Will this test pass after the year 2100?
why are we explicitly adding the keyPath for all cookie values?
Can ignoreDTD is false? If ignoreDTD is false, then we should allow DTDs.
I think there is no need to use / to make the params class nullable. This is not a mustn't remove, so this will be unboxed again.
I think it's too frequently, and could be changed to... the return value is in the catch block.
should this be set in onViewCreated() callback?
Where is the value being used?
I'm not sure why we need this. I thought that VmDeviceUtils.getVmElement() is null.
Should this be in the if (!visibleTextBox.isMetaKeyDown() || event.isMetaKeyDown() || event.isControlKeyDown() || event.isControlKeyDown() || event.isControlKeyDown() && event.isControlKeyDown() || event.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKeyDown() &&!view.isControlKeyDown() || event.isControlKey
Looks like you didn't use the plugin to generate this test case in test class. Can you move it to test method?
@ivandalbosco The reader is not closed
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code drops it right through to the failure event handler. The previous code would translate it first.
why as you removed the explicit check for e.getErrorCode()?
I think. value() returns a value instead of <.125, since you'd want to check <.125 instead.
What is the default category? I'm a little bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
Remove
Slightly confused by this logic. We should probably define a type with a null keyValues array.
You don't need to wait for it here.
See the new test in each case, a new method with two flags would be nice.
You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.
Missing white space after the parenthesis.
I think vm.get().version() >= success is more appropriate here than.isEmpty().
I would rather use plain "false" here. It is sufficient.
i dont like the idea that you are passing a host name either, but it is not related to vm.getVmByStoragePool() (it is usually a query without vms)
Merge these two if statements.
I guess this can be handled by the caller (test)
I don't think it would be much better here, since it will not be the same on different levels if the request-wise is the same on other things, just the thing I would say it would be better to make it a method that will return true ifstringWidth is true.
Minor: Wouldn't it be better to move this to config?
final
This should probably be "," so that the user can resize the table in that case (which seems to be fine, but we could use a constant for this as well).
Inline this method.
This processing looks suspicious.
change to getHeader(span)
Format
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "throws". [![rule](<LINK_1>](<LINK_0>
We can create a variable for column name columns to avoid the same name.
nit: I think it'd be better to create the type of UpdateBuilder to not use a StringBuilder and print its message directly to the logger.
Optional: use Boolean.TRUE.toString()
I dont understand why pruning is done at this point. Also, we will need to make sure some of the instances are not modified in this method.
Why are we only allowed to iterate on the metrics registry?
NullException (nit) suggestion Preconditions.checkNotNull(row.getAndCacheRowNumbers(), rowNumbers.size());
Should we have a check for null on input or input?
addListeners (see other PR)
Would prefer if Date was initialized using ts's getValue and getScale converted to ms
Please use File.log instead of using File.log().
not.build()
I don't think this is needed if getLogger() is expensive.
Please add import to avoid fully-qualified class references. Also, why not simply do this: Locale parsedLocale = LocaleUtils.toLocale(applicationKey); result.add(parsedLocale.toString());
The following seems more readable: rootBaseDir.get(i).endsWith("..") &&!subDir.equals(rootBaseDir.get(i)))
you can use Assert.assertEquals(executor, participant.getStateMachine()) instead.
a random number is a bit long, can we use an ArrayList here instead of a List?
Not a big fan of explicit methods calling this method, is it really necessary?
Could be replaced by: SpongeImpl.getGlobalConfig().getCommands().get(name)
Add "column name"
Setting the status to COMPLETE if it is could save an update
I suggest to put this in the debug log.
Does this have side-effects? Otherwise could be a performance benefit to moving it inside of the if condition below.
Would it be better to use getBoolean() instead of getInstance() here?
this will cause the pool to be updated for the same metrics tenant. isn't it?
What is the use case for having separate methods?
why?
The original is not sufficient here. If the return value is NULL then we will not need any return variable here. Use the one with the one below
this should be set in the doPopulate() not in deprecatedPopulate()
this is unused
This should be a log statement.
Shouldn't this be toData(e.getKey())?
It might be worth adding an info log line as well.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the configurationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
Will this cause a node exception?
suggestion.setThrown(() -> callback.onSuccess(commitTransaction(e)).set(timeout);
Do we need a case for ids.isEmpty()?
static import SortOrder.ASC
This is not fine as the default test is still passing.
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
This variable is redundant.
This var should just be named wifi, right? since it's not an instance var?
if (a.getFullName()!= null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); }else if(a.getPreferredEmail()!= null && emailMatches.size() < maxMatches.size())) { emailMatches.add(a); }
I don't think we need a boolean flag here. Leave it unset
expiringObject can be moved to the following if/else block :)
I'd change to "SetDao."
Please use addValidationMessageVariable("domainType", StorageConstants.EXPORT)
Is there a way you think you can use the default color color here? I think it would be more consistent if create a new one.
disposables is null and when does that happen?
I would prefer this as a constant string.
shouldn't it check the getCluster().getCpuName()!= null?
"if ( associationType!= Query.INSTANCE.getEnabledFilters() )" can be removed to simplify the if statement
This is very inefficient. Could you change the following loop to: final String[] headerMap = new String[mapping.size()]; for (final corsHeaders : headerMap.get(mapping)) { if (map.containsKey(mapping) { //NON-NLS-1 return Collections.emptyList(); } return mapsHeaders; }
The else is not necessary.
This isn't the right place to put it. You could have this logic in the parse method and just return the message itself (above) This would give the logic more readable.
I think the exception name is not assigned to a variable in test
Does it make sense to use the constant name of the field? The existing groupBys may be confusing for this case.
When changing to DecisionNode, I think we should check that.
I think we should make google libraries a bit prettier, to be able to get the size of the trigger.
Need to use getString() for those as well
same here, need "else": ConsoleDeviceEnabled should be set according to template
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final SupervisorActor.ActorRegistration actorRegistration = startResponse.orElseThrow(cause -> new AssertionError("Expected the start to succeed.", cause));
I think this is a bit too long, can we refactor it to use a plain byte array?
I think just passing file is enough instead of file.getPath()
How does the retry handler distinguish "failure in initialization + failure in handling all items" from "success in initialization + failure in handling all items"?
.getTrace() may return null at this point. We should probably add a null check
Please use the static import for the use of assertThat.
Should be indented one time in the code.
redis() should be accessed as static method.
Is there a reason why this is needed?
isEmpty?
@victornoel I'm not sure why you need this method public as well?
Use try-with-resources
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
The translation from'request.getToken()' was added in Manual token, so we have a clear consumer for the Request.getObserve() method. However, I think we should consider to add a check that verifies that the block is in fact that we don't set the requester to the user.
Please don't use brackets around single line blocks (see 10 spaces in the file)
wrap
I wonder we should throw Exception instead of logging these?
this should be a debug message
Would be good to have it be more clear which exception is thrown when lookup returns empty.
getEndTime() is not always coherent, especially with traces whose analyses were already built. It seems to have to re-read to whole trace before the end time updates itself. Anyway, this last is useless because it is && with start and end being equal to start and end of eternity ;-)
Can you remove all the need for this?
Why are we interrupting the current thread if it's running?
Replace with synchronized
nit: check the param "final" and just call it "final".
Unnecessary new line.
Maybe it is worth extracting the result variable to a local variable.
You can do this via java awsConf.setSocketBufferSizeHints(conf, DEFAULT_MAXIMUM_UPLOAD_TIMEOUT_MILLIS)
Why don't you use the same delta?
If we track one buffer of keys that's not, maybe we should just skip it and throw an exception. Also, it seems like you could have a check on keyOnlyTracker before throwing it, to keep the current behavior
Can be a static final
Isn't it better to represent reference directly in the ProbeType constructor instead of doing it for each call?
This can be static
Maybe we could use a function like KeyboardEvent or something similar?
Let's put html variables in Formatting
channel.close().sync();
nit: you can remove the switch here as it is just a static import.
Do you mean JSON.optJSONObject(String) here?
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventThread.join(EVENT_THREAD_JOIN_TIMEOUT);
Perhaps a note is that a utility method is used?
for consistency, would it be better to use a local variable here? i.e. single call to findDescendantsOfType(ASTMethodCallExpression, getPreviousMethodCalls)
I think it is better to use StringBuilder
"Type information is missing" or sth like that
I don't think it's necessary to put this block inside the builder, right? Why can't the builder be initialized just once?
I'm not sure this was correct. It should be [better](<LINK_0>
primitive (int) would be sufficient
could be rewritten with a call to track the type system property, like: DocXYGEN_USE_PRE_DOXYGEN_USE_PRE_DOXYGEN_USE_STRUCTURED_PRE_OBJECT_ID.contains(new DocTag(prefs.getBoolean( "true"));
formatting
No need to use a local variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis / x = new HeaderAxis( x - sdArea); return x;
You can add a verification for that feedback page to be more specific.
this could be encapsulated on a method called findFirstStepByStruct. that returns just one WorkflowAPI or two getStatus()
Can we put a condition on this? Otherwise it will be injected on every request. have a private method autoWireService Check if backupService == null and call this method
Curious: it may be correct to use direct access to the linkedlist...
Just change the access to security.
Here, I see that config.getBooleanProperty() is null.
Ideally we are as specific as possible with exceptions based on what developers might see.
Why this extra query?
suggestion userLayer.createUserLayer(e.getMessage(), "Failed to encode the feature as GeoJSON Exception");
This works, but we have static factory methods for specific use cases. GatewayError.baseError(msg)?
I don't think this is the correct exception handling. Shall we define a sub-class like VoltDB instance not having to handle the message.
@NielsCharlier I'm not sure that.equals() is preferred to avoid null checks.
Isn't this the same as the other array array?
put else in a new line
style nit: missing braces
Shouldn't this be capital T?
@inverno This can be an FlatDifftic
overflow = ((xl  yl) & (xl  zl)) < 0;
I think this could just be: if (buffer.get(i) < length)
Looks like there are leftover printlns in addition to the assertions?
This is a bit strange. We can close the PublicKey, with a new method toOpenSshCertificateEntry. The line could be moved into the try block.
The "if" statement contains a single "else" statement.
I think it would be good to add the file name in a log message instead of "OK".
could we simplify the logic as: if (paths.isEmpty()) { // No childType = ImmutableList.of(childType); } else { return new MessageType(subfield, baseType); }
@vilchik-elena Please use the size of the list.
Should we be checking if this is!= 0?
you can inline item
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved system memory. I suppose we will always need to set aside a part of our heap to things we don't track, various overhead, etc. We can probably now set reserved system memory to a lower value.
This is redundant because it appears in the same block.
I think this should be ChannelSftp
check for non null?
I think you need to get the top of the file in general.
We want to keep this as small as possible to avoid the need for the output here, right?
It is not clear which condition do not contain yet the constant value. Could you explain why do we need to add qualifyingSet here? It just looks like a good idea to me.
ClassLoadingContext should be declared as protected in the class.
If this is the case it's not clear what the original test is doing. I think it's more readable and it would be good to do: assertEquals(test.testAll(subListDepth - 1, filterDepth - 1, filterDepth - 1, filterDepth - 1, filterDepth + 1, filterDepth + 1);
Can this response be read and verified?
+1 for cases where the dataSchema is created and the list is empty (i.e. use +)
static import for milliseconds please :)
I would tend to only add the last element in the map.
use fieldType rather than fieldSchema in the message.
Should "This is likely to be "was caused by a node failure or intentional"?
This also doesn't look like a good idea. Consider just returning false on random themes, otherwise it feels cleaner.
I think I'd want to have the word bound here, to match the other methods defined by the this thing. Doesn't seem like it's more or less confusing to indicate the end have been used?
Since we want to update the entire widget, I think we can use a single [ event](<LINK_0> element here.
optional: this only takes care of the branch name and the branch name, and it may complicate the code a bit. It only failed if there is a branch with the "branch" branch and we should not use these branches.
This could be done outside of the for loop since you are not using it multiple times.
_are_ possible?
Looks like we can set a waiterId here (this.getMigrationQueueId()) should probably be call on a new thread.
let's use try-with-resources
Return an empty list (Collections.emptyList()).
Why no else here?
Why didn't you use getSceneOfManger for ReplayProcessor?
can be done with with this Disposable
Do you think it's worthwhile to check!headers.isEmpty() as well? Same for container.headers().add(RestUtils.Headers.TARGET_CONTAINER_NAME)
Shouldn't we return the EndpointRegistryInfo and not the registry id?
This should be at least logged, i.e. log.warn("The header [" + name + "] is not allowed.", e);
I think that this loop would likely be better if it used split()
This doesn't have to be here. Set the email in a class member, you can use the user directly. Also, you don't need to do this twice.
This is another one. @nvazquez what's your point about this?
nit: move this to a private function, something like: int mbraId = -1; -1; public int equals(int b) { int index = Integer.parseInt(); }
The problem with trying to create a String and not use the sitemap URLs. The reason is that you can't really use the same color instance?
You can remove the following if-else block
Why do we need to Ignore? What then?
I would suggest to add getLogicalTimestampTimeUnit here.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the selected OS. Ideally, fill this list according to the values returned by osinfo.
IIRC jdt.ls.lib.io.IO#close() not before that.
More magic numbers; use variables for longitude/latitude?
Leftover debug statement?
can't we check that the big fields are empty before concatenating to the tree?
This toolingPod should be moved into the xml
to use StringUtils.isBlank?
Don't log and throw the same exception
This should be 'if (color!= null)'.
we need to include typed values here,, otherwise we will break all of these tests.
This line is long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
Maybe you should include the null-value too.
We should not need this String[] as this will be translated in JSON
I guess you can also iterate over keyCount and get rid of the for loop below.
I think the try catch here is probably not needed.
nit: you can remove the redundant brackets
Code style
i am wondering why this change. The contract of decorateHtmlElementList is not part of this method.
Shouldn't null here just be interpreted as an empty array?
The City class is defined in another package used by other tests. Any changes in City could potentially break the test. I would recommend using a class defined within the test itself. It is easier to maintain the code.
I think simplify and use it in the same place, as in other methods, the geospatial and unit is removed in this PR.
Just use "return..." to make the test more readable.
The token name should be changed to "token", to match the [token-by-go](<LINK_0>
Can you use a lambda here?
I think you need to reverse the equals test here: if (geocode == null) return true;
I'd suggest not assuming an object will be returned since we might switch implementations
Please use the following if branch: java if (path!= null) { return path.contains("Type"); } foundField = path.substring(0, path.indexOf('/') + getName() + "' does not implement an empty object");
It seems that kWorker would be null in some cases, could we check it here too?
Is there a reason to use streams here? The structure is a bit hard to read.
This is not 'per node' It is the count of all CPUs defined in all NUMA nodes.
Looks like it is necessary to save the value in Jenkins for a global variable.
As mentioned in <LINK_0>, it is a Safer to get the wrong id of the persistence step, but I assume we want to still return the same list when passing the SingularityTaskId list to the DB. Can we get the SingularityTaskIds from the SingularityRequest to avoid a number of repetition?
I'd extract this line inside a method to reduce duplication
Error message could be logged to spam.
This won't make the code more readable.
Use the existing JSON API. You will have to do the following: [here](<LINK_0>
You have an idea that you could have several aspects of this AssemblerUtils package, to improve readability when you add a method that sets the value to a String (AssemblerAssembler), set the original content to the other constructor. Otherwise, there are no defaults which should be an instance of the same content.
consider extracting to a method
Can we do this?
Formatting
I don't think this is needed. @ODORA0, I will be rephrase.
Shouldn't this be done at the beginning of the method?
This is broken (no reason to get an empty String[])
If you need to squash the BufferedInputStream and have a new BufferedInputStream(HttpResponseStatus.INTERNAL_SERVER_ERROR). It will accomplish the same thing...
Please use a method called 'org.springframework.web.util.JsonUtils.createXXXValidator' that will be used in a few places instead of this.
Why do we have to reset this flag? Is it possible, but did we want to still force it?
We should make savedConnection a constant and reuse it here.
How do you get the number of files under test and then use teardown?
I would do instead of a loop, since you are not asking for more than one element
This should be WFLY-4294 says this op will fail in runtime on a server.
Please add final for exception, and rename it to ex
Need to be changed, since it will be called twice (see other class, too).
This is a bit strange: size is interpreted as a negative number (or zero) in the tree. This should be a valid reference to the hamcrest matchers. They were probably ok with something, but helpful to have a readable result.
Need to revert this line.
Maybe we can consider adding logging here just to indicate when we're not going to track media?
I could generally go with the sleep earlier, but we should get rid of the sleep.
Should this be outside of the try block?
redundant statements.
Does this file need to be a global variable? Can you make the checkPointFolder more specific?
Add a check here to verify that the serialDataReceived method was not called.
Why have you added this code? Instead of just return the result?
This line can be replaced with:.put( sum.get(index));
Just use it's form above, not the temp string, because it's mutable, the api should be using the @Deprecated annotation.
We already know that it is a MutableObject. Maybe this is better then?
Missed it at previous review. Question - why via getTaskIdList()? and not via VmStaticDao()?
can you please extract to a method and call it twice in the file?
I would prefer "None" here.
use a for loop here? I think we can just put the values here.
Why not using principal instanceof X500Principal?
Do we need a synchronized block to prevent multiple threads from making the same transaction? Can we bound a state where we don't do it at multiple places?
String url = String.format("org.catrobat.email);
This code is repeated several times, please extract it to a private method
Thread.currentThread().interrupt();?
Does this really need to be public?
This is no longer relevant. It's just an idea but can be passed as a parameter to this function.
It would be a good idea to factor out the logic of this method.
I'm not familiar with Spring Security - I have this as a Bounded-Url and I read the password to the URI. That seems pretty close to me... Can you please check if the FileName is missing?
Is this going to be called for every single client?
Should do the same thing here and below
Why public? I don't see any news usage in this method.
Consider replacing these for loops with the same loop.
java itemGroup = ((AbstractFolder) itemGroup).getParent();
The method name is deprecated, so this could be removed.
nit: can we check for null before calling this method since it will throw NPE.
you can introduce new interface that you can ask if the run should use fork or not. default would be true, also if the new interface is not supported by context (as before)
I think the same applies to both createMultiTreeAPIsIds, this could be factored out
This code relies on BracketIndex#equals(Object, String) method of the Index which is invoked here (probably) is causing the index to be longer than the index. I think we should retain it and use the lastIndexOf + I think.
remove "es" and use [StandardCharsets.UTF_8](<LINK_0>
Would this be a different value of fireOnlyUpdatedPanes be a different value? A different property could be passed to the OutputFormat for the submitted scenarios. It would be a bug in this case, just returning the new value of "get" when the user can't set the value of "result".
There is already a [NetworkReferenceImpl](<LINK_0>; ad it to the base test class predicates and use it here instead.
Remove sysouts.
Why is it required to be a list within properties class?
Try grabbing textExtendedSubheaderDataLength from null in initializeFixedLengthString() when it is not present. Needs a test for it.
I don't think setting the language to _editor_ is OK. But there is no reason to put new LocaleSettingHandler(String)?
This looks overly complicated to me. Why not simply compare the list of repositories with the forEach and forEach?
Should be java if (replyTo == null) { return; } (replyTo, no, third-expression, replyTo) {... }
Ah, OK, that would be clearer.
This should be done in the different patch, not here.
This doesn't look right, should be Entity.toString() instead of.contains?
this part is the same as in restoreDatabase, could you refactor it into a separate method?
Still wrong index... It really must be dependent on the TmfEventTableColumn, we cannot assume that the received 'columns' list is either in creation or visible order.
Remove the first null check here and simply call the instance variable instead of doing a null check.
I can't see anyone looking for the message. You have some gateway account to provide a different type than the key.
This name is not very specific to the upgrade.vcf to help to help with debugging.
cause exception is not caught?
Don't need this.
debug/trace/remove?
what's the purpose of this test? The original test should fail the test because it's not there.
@tmjee before awaitTermination you should call shutdown Then assert that awaitTermination returned true Than then shutdownNow
suggestion "Required fields: " + reqVal.bind(" --json;
Better do this: constant errMsg = "true".equals(url)
IMO, it'd be better to check if hasgetHaxeClass() and use that in both cases.
tableHandles is null
@jinified you can also put a call to PickerTextField.getIssueLabels(). And I don't think you have to use it for a reason.
Now that the tests for the same reason, why not just use MockEnabledModelResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSetResolverNotSet
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
I don't think you need to check for a correct row index, and since we know they're looking for a tuple, the table index should have a ColumnDef, so that it seems easier to identify which row is based on the actual column.
Would be good to add these logs into Utils.getDefaultManager(), e.g.
if you're doing this, you'll also need to synchronize on the notification, which is not thread-safe
@nvazquez you shouldn't make this function protected just to avoid people from accidentally using it.
suggestion response.print("s", bundleName);
PatchSet parent has an edit, so its parentPatchSet is also the right one. You need to call this.remove().
We should assert that the keys are getting returned, not just that we know there is no keys.
This loop may be unnecessary since we do not want to have a HashSet here.
Catching a Throwable would be a cleaner here.
add an overload which takes a file with the actual file type.
Throw a new exception here.
nit: Add "A" here and in the next line
Same question as above
Better with other example domain (e.g. example.org).
What happens if the date was not set?
it looks like a constant
Is this correct? What if someone is trying to transition from a state here?
CosiamLdapUserDetailsImpl is completely unrelated to this change. Please use ((userDetailsService) attribute).userExists); instead.
this should be.path(path)
nit: we can use the TimeUnit.SECONDS.sleep(100).
Cosmetic: This looks good, but the bindingResult variable should be declared as a class variable/method
1) Please make it a 'final' field, and use it here, instead of creating a new instance. 2) Why not passing the 'vm' parameter, please add a check for it here as well (same for the other commands). The mapping logic should be to 'update' and not using the backend, which is more suitable here
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This condition is repeated in the constructor to be simplified to: java if ((firstPartitioning == firstPartitioning) || firstPartitioning!= null) { return firstPartitioning; } return null;
The Exception is never thrown.
1 =
You also have to replace anyMatch with allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
I think we can use this.value = GraphData.class.cast(GraphData.class); and then use it here.
Nice collectLongs!
Now one can only static import state methods for either TransformationState/ProcessState, but that isn't a big issue
The first half of this method is very similar to some of listPhrasesForPage(), could you refactor por favor?
Can you also use assertPipe here?
Why this needs to be done? Waiting for some reason is to take the time.
Do you need this? The constructor was used at [after](<LINK_0>
we should log this exception
I don't think this check is needed, you can just do: if(pomComponent instanceof IResource) { updateStatus(new IResource()); updateStatus(status); }
I am not familiar with the test - why do we need to call the function???
style: } else {
Lets go to the if (.split(.split( ), ) {...} form
use the same style as above (which is declared in the while loop)
line > 120 chars
The sleep is too big. Typically, it would take more time, that the D sleep is after all the seconds.
Add a new method to util.failures.
Maybe: LOGGER.error("Creating policy for tenant [" + subject + ": " + e.getMessage());
have a block here saying what what's the point of this?
Nit: budgetObject.getInt("amount") is redundant, since you're just doing it right?
It should be more clear to me for if it is a bug.
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run.getId());
This line and the following are incorrect, rather than relying on a String.format call, it's better to throw exception if one of the expected codes are not of those.
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName()); }
We can change this to private to match the existing constructor, which takes params and returns a single "null" value.
if you use CollectionUtils.isNotEmpty() for expression which is a little better
need to use StringUtils.hasText(); hasAttribute allows an empty String.
I would add a log in here, stating the attempt to read the key should be taken care of by the entry, and when not, there is no need to send it
We should go to these two DBs to perform authorization, not just for the last database, but not sure why we need to split these.
:ant: I'd use StringUtils.isEmpty() rather than.stream().map(this::getSlaveInfo).filter(slave -> StringUtils.isEmpty(item.getSlaveInfo())).collect(Collectors.toList());
travis runs in dev.
The new AffineTransform(graphics2d.getTransform()); is better.
Replace method with createScan()
Can use feedback response ID?
Please add the indent to highlight the blocks and avoid the mess in the code.
I'd like to prevent calling this method from being called on non-GTK dev versions. I.e.: public boolean isFailed(int state) { if (state & ERO_HEIGHT) { GTK_RANDOM = 0; } GTK_RANDOM = GTK_REDK_INSTALL_MODE; } if (state & GTK_R) { isGTK_visible = false; } } return true; }
I'd use.forEach
I would go with this.
Should this be an exception instead of a try-catch?
"uppercase".equals(textTransform) && textToInsert!= null
Usually we use a single string reference mentioned above?
Minor: Use helpers for m -> m.memberId() since you have a few other places.
I think that you should leave it as java @Override public static final String valueOf("ACTUAL_SIEISIONED_SIESIE=" + ", "");
nit: no need to set the click
We should use the same name as a constant instead of this field.
Why do we need to call nanoTime() on the particular time? If it's a real implementation it will still be slower, I think it's fine to just use it as a straight-forward loop, but if there were a few devices with it, I'd like to use a reverse-case that would match the order and binary version.
What if the snapshot is not a snapshot?
This won't work for more than one email address.
This should be reverted, then we can remove this code.
I think you should add a null check here for the return value.
Component type for the inactive device exception should be DOMAIN_TARIFF_SWITCHING here. The type is not the meaningful exception for the logged user (here UnknownEntityException) for instance with a different exception.
minor: Instances here is not required, right?
This cast seems unnecessary.
Iterator could return multiple items erroneously and pass.
we can use a different constant for this: java final String dataTier = "global.email();
you can use the shorter path for this and avoid the need for casting as much as possible.
since this is true, maybe you should use java.util.Objects.equals() to reduce the amount of lines here.
It might be worth including the fact that you did a.next() here instead of the new reference.
This method can be simplified to: java bloomFilterIndex = props.getMaxBloomFilterBytes(); if (optimalIndex == 1) { // throw exception } return;
Using getClass() is clearer. I don't think we should change this class
doesn't this need to be done in GerritUtil.configure()?
these are magic numbers.
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIATION in this case
We need a test that ensures that the command has no disk.
I don't think the need for this variable.
Isn't this line already happening in the previous test?
I would recommend replacing this line with adding a _doAnswer()_ to avoid the un-necessary flatMap call.
this is the right place to put the password and key as part of the command. Would suggest to lower case the first letter.
Can we do this instead? I'm not sure what the test was doing now, but would it work if the queryStreams() was removed?
newFuture is never null, so it's not necessary to check for null.
because writer.put() can fail, you should enclose it in a try/finally like: try { writer.put() } finally { writer.close() }
is it better to keep style with the new line
We could omit this line. We also need to add the specification of this section.
Please fix spacing.
You should probably do something with the exception.
It seems like this is changing the behaviour in the first place, and now it's safe to change the transaction in a case of error. I'm concerned about people using the transaction in their custom transaction in the same class.
Why add mutating methods? Just put this in the constructor.
Do we ever expect this to happen?
we can use R.drawable.***_MIT_FLAG_ACTIVITY_NEW_TASK here,
Perhaps also need to be a set from the identifier? _could_ replace 'j_ interface with BeanDefinitionBuilder. exc.
Should be in the same line of the if
Please log the missing space between  and {
(pointer.getCorrelationID()!= null) -> Cause.getCorrelationID(correlationID);
If the getChildren() method is called, the new getChildren() method will return the same array. This should be changed to use a separate "for" loop. As this will be avoided, we want to change the API and let the UI handle this.
Sleep might make this test flaky. Would it be ok to do this without a test? Also, I think this is testing that the concurrent thread will not get to this test.
Could we add a log message as well?
You will need to show details on the displayed PageDetails object.
Looks like column.getDataSetDef(); is duplicated here
this could be a bit shorter with a method reference
What do you mean by default?
This value should be a constant. For example the one in the link string is a configurable property.
Users can use this pattern to start iterating over Users. Change them to something like wals.keySet().stream().filter(entry ->!WalState.OPEN).findFirst().ifPresent(entry -> { log.debug("OpenWalState is disabled"); return; }
This can be a List.
static import
In this case, it's better to use.equals on server than == Subject.ANONYMOUS. And probably add it as a 'anonymous' method.
It would be good to have some debug log here about what are the exact url was?
You only want to use copyFileToTestProject here.
Create a constructor without the last field?
What is the point of 'next()' if there is only one element? Is it possible to simplify the code and let the caller handle the error?
You can reuse LK_ADDR attribute then if you want to use K_ADDR and K_ORDER_OF_TIMEOUT.
same here for the test
Please explain why do we throw Org exception here.
please change the return value.
Not sure if I just can't see it, but should we close the zkWorker if we get an exception? (This is why we are discarding a potentially large zkWorker from a scheduled task that doesn't exist yet)
if (visible) {.setText("WatchDog", "The linking prizes"); }
Hmm, and the old code is even more readable, could we refactor these ifs into a single method?
Can you change this to a WARN or something more relevant ("Error while parsing class '{}'. The RUNNABLE_INSTANCE message is not a class name, but for consistency with it, we don't have to support it for you.
This may be changed to Set<Clients> safeGetLatest(org.apache.commons.lang.reflect.Method.invoke(this::processDigest)
Why are you checking here?
possible NPE
nit: the expected result should be the first parameter since it's always a mock (which is the same for all regions).
should use {}-placeholders instead of string concat
it seems that the fExtractAction is used in a few places, so it should be in the class
I would add a call to repaint here.
I believe this should not be necessary. Nice!
These Predicates.alwaysTrue(blind, not sure if they're missing something
Are you sure the result is always non-null? (same for other places)
This seems to me like a very long time. What about servlet or server (server, server and server) - could be used to not call server.output()?
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
Shall we have a log message like "Error while getting Template XXX with all".
We can remove these if statements if it can handle "09.1" (without actually testing it, I think the previous if statement may flag it as a malformed octal sequence.)
Please revert this change, too. e.g. if the () is thrown and not synchronized, the whole reason is that you don't much need this.
This is a bit confusing at first sight... when we have a pre-existing zk with some non-empty environment. Makes it easier to read?
The constant looks like it is only used in this scope, so should be defined outside the loop.
I think it's better to pull out a separate method, such as createCheckpointInProgressRequest (or a separate one for each CheckpointInProgressRequest) that can be reused in both places.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
Down below we throw.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering.
All the implementations of the endpoint should be converted to the endpoint, and there should be one call to apply here.
Can you make this method final? It's not a big deal but will be good to have it in your first review.
I don't think you need this line.
This one should be called after onComplete.call().
test case for response objects is not applicable.
The verify is for dataComplexDataCodec and dataComplexDataCodec in this test case I think it should be always to read the latest version of the test since it is an instance of dataComplex.
Can we include the partitionCheckpoint in the error message?
is it good that this is null? So we can't just get null here.
I'd rather iterate over the classes and remove the "String" from the class.
Is this null safe? I tend to think the null case is not a valid value for the FormField.
I'm really not sure about these local operations. I meant for, or they should be split into two separate nodes, one for each branch, and one for the pos (or the whole direction) neighbor neighbor = a single - 200 << direction); neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction == 0;
Guid can be null
Using an enum as mentioned above, this would become if (savePaths!= NONE) which seems cleaner to me.
You can make this function static
We should use distinct from colVals.
nit: I think these has way too much trouble. Maybe: final String tableName = "hostname".isEmpty();... Alternatively, we could use the constants /hgle-roomlight.
Make this variable final
Any reason not to use the @Mock annotation here?
Change are not necessary and remove the 'this' keyword.
Just to be safe, do no need to break as it is already in the while condition, or if we have two try/catch blocks, those threads will see the same approach in different thread.
In the past of this debug message, please update the print stack.
Wrong variable, should be memberAttributes.add(attr {});
Shouldn't Dto.getName() return the same value for all the setXXX methods?
mvn clean verify fails with checkstyle. Fluo prefers using braces, even for single-line if blocks.
You can just do getHeaders().getFirst() on the response.
should there be a result of localAddress and not even create a member variable?
Should we use preconditions?
Why do you need this change?
java if (this.streamSize < 0 || this.chunkPos > 0) {
Clbebee = new B>() {... foo.setA(U); }
This test is not very robust. The set of values is not set but some of the classes set.
This will spam the logs for me. Can we include the JSON BAD_REQUEST message as well?
nit: Can you make this final?
should we log the error at debug level here at debug?
Does it make sense to have this continue to use the propertyCursor instead?
suggestion
This is neat! We'll have to remember to use it elsewhere!! :smiley:
This two lines get called twice. I think you can drop the second param and just set the second argument in the method.
Would it make sense to extract methods for this PR?
Consider extracting this block into a method: java private boolean isLambdaParameter(DetailAST ast) { final DetailAST parent = ast.findFirstToken(TokenTypes.IDENT); return parent.getParent(); } public void isLambdaParameter(DetailAST ast) { final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); if (parent!= null &&!ast.getType().equals(ast)) { return parent.getParent(); } else { return parent.getParent(); } }
nitpick: [Boolean.parseBoolean(String)](<LINK_0> never throws an exception: java public static boolean isCodeValid(String s) { if (s!= null &&!r.isShowCodeValid()) { return!r.isShowCodeValid(); } return s; } so you could simplify this to java boolean isApp =!r.isShowCodeValid(); if (s!= null &&!r.isShowCodeValid()) { return!r.isShowCodeValid(); } else { final s = s; } and you could simplify this to java boolean isNonBlank =!r.isShowCodeValid(); return s!= null && s.equalsIgnoreCase("true"); }
Change this to java if (clients!= ClientHelper.isEmpty(clientNames)) {
Should we use StringBuilder here?
Since you are using this when you have nested objects, this would be easier to read.
nit: you can remove this
Any reasons why this is a double-/?
You should always compare strings using the equals method in Java. Testing using the == method might only return true accidentally.
extract the text to Barcode barcodeProperties.
I would extract this logic (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide better code readability but also code reusability.
try to keep the lock immediately incase of the channel. / memory wouldn't address it.
AJ, An encounter also has a time limit of 2 days set to close if the medical date of visit is null. The medical memory of read might be an option of the vital type
What if a student or unregistered user calls this endpoint?
[optional] Obviously this will print 83 characters when the length > 80. If the length == 81 then it will print more characters than the actual length of the string (same for the length of the string).
I think we need a null check here that we're not going to blow up right away since we are either returning null or using a null value.
Assert it
I think this should be "Type"
should this be taken out of the cursor?
suggestion LOGGER.trace("ISBN { } not found for ottobib", identifier); This is the recommended way
Collections.singleton() should be used here.
I generally don't like this check, but I think it would be a good idea to move this check into mIsShader()
do not set the correlationId for the request. It is only applicable for the reqeust of the response.
Let's remove the type of annotation and use the default value from AvroElasticMemoryMessage.
Maybe rename to rootSelectionId.
<LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
Are you sure that this catch statement is really needed?
You could get a whole thing, but this method doesn't have to be public.
Rename this method to match the existing on kitDescriptor
zoomIn and zoomIn
Isn't this a race condition? I think it would be better to catch the exception and return later call.waitFor() in the finally block.
Should you also use the same some kind of date, such as sampleName, and dateFormat, etc?
use a final boolean in <LINK_0> to the redundant check again
It is a bit confusing that we have a log message but then we can see that it doesn't have a stacktrace.
This line is duplicated
Minor: we should not mix "s"s "s", "s" for the "l" strings.
You can make this more cleanly by using a try-with-resources statement. java try (this.publicClient) { final String response = request.getBody(); final String password = new ServiceBuilder().apiKey(Ops.Image.class); m.addBodyParameter("content", request); } catch (IllegalArgumentException e) { System.out.println(e); }
Don't set key, url and URI.
This else is redundant.
You can use [Mock's mock WorkflowsGenerator](<LINK_0>
Liens's yeah, this one might read a bit better as it was before.
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
I think it's currently doing all this stuff in this class. We want to keep it for every learner equivalent to one with each learner, then you can remove it from there and add it again in the learnerController#sendAndReceiveRequest method.
Why are we catching all exceptions instead of returning null?
suggestion.withQuery(() -> server.getLocalMemoryManager().getReservedBytes()).
We can just add this for an patient which is empty but don't get one
nit: just something with the name of the test implies failure.
Replace hardcoded "//" with using Util
What about letting you choose _currentWorkingDirectory? If there is no other reason to create a new local variable and then return it without the other return.
please rename TrucksOwnedByUserQuery to variable and the corresponding formatting
Is this doing what I think it is -- using a normal directory as temp directory - outside or temp folders...
Can you log the exception too?
Instead of displaying strings like this should we consider creating some constants for the strings that aren't used in strings.xml?
the code from here is a bad idea, are there any reasons you want to use continue here?
That could be simplified by changing the line length to plainTextFactory.value("Feature"" + textOnly); (instead of the else clause)
Why the cleanup? This is handled by the receiver.
Why do you need another set? Just use fTagLocations to check if it is there or not
Should we throw an exception if default schema has tables?
Suggest using a format string to set the user name.
I usually prefer the depth comparison, not the equals.
I think we should be using this form instead: try {... } finally { db.close(); }
Should not be needed
Let's be consistent and use DiskImage::getDiskImage instead.
I don't see why we are returning an empty list. That means user can get an empty list if the job name starts with "cluster.". Should use Util.GEN4_CLUSTER_DIR instead.
If the model entity is not used, the method will be returning the model object.
These statements can be simplified to: return Objects.equals( timestamp, timestamp) && Objects.equals(timestamp, timestampString.substring(0, timestamp.lastIndexOf(".")));
[minor] Why not print the exception rather than the stack trace?
Why is this null here?
The common code is not the most common thing to do here. It should be smsMessageType.getStatus().
You can select the quality_gate_uuid and check if it's not there
If using class octal representation is important, you will need to do "StartOfBuckets" here.
wow, can we just keep totalLifespans and use totalLifespans.getAsInt() every time the value is used?
This seems like a leak of RemappedFlag?
Use the new ArrayList<>(Requirement2[]) syntax.
cle 131
Why not this.sorted().uniqued()?
java8-isation [forEach][filter]
Why are we doing here? I think it should be done in onMatchingSchema(() -> values.schema().getPropertyIdsForProperty(item.schema()).properties(), node -> { OrderedPropertyValues values = new OrderedPropertyValues( values.schema(), node.id(), null); return values; }.node().name().format("Timer:" + index.id(), after).getIndexesFor(item.propertyKeyId()).build();
This needs to be changed.
It's better not to change the variable name to messagePayload, but instead of message.getMessageAttributes().
setErrorMessage
Are you missing a local variable, or use the constant?
Based on the previous code, shouldn't the wait be 2500ms? Or maybe the 1200ms is wrong and the process indeed takes 1000ms?
This list should only contain expectedConceptEntity1's since expectedConceptEntity2'sByUUID_should return a list of strings. So can you simplify this a little bit?
@marchof I would assume that expressionAnalyzer.getTypeManager() is also used for symbol %s.
Can be simplified to Clustered.
isn't it safer to continue to set the configs if the cronTaskExecutedEvent will be called for every task?
Probably better to use RESULT_OK here. It includes both unchanged and a user.
Add Throwable instead of Exception?
Typo, should be Processor
I think you need to handle the case where date is null
Can you use placeholders with {} for all arguments?
I am not sure it is safe to modify the scheduling of a single instance. You may have to set it via schedulingACronJob.getInstance().scheduleACronJob(scheduleACronJob(), schedulingTime, getEnvironment(), schedulingTime);
negotiateProtocol is a little misleading.
I would add cacheProcessInstanceId as a field and it is used only once. That way it will be used for each process call.
toLowerCase
space after "+"
1. this is adding another access to the DB which should be moved to implementation, not a new one. 2. why is it adding twice?
Isn't it possible to use streams here?
removeTasks is never used
Wrong method name in the xml
Are you should you need to protect against null here? If yes, the synchronized (this) should be preferred over a proper boolean.
We don't want to set the remote source -- do we?
Style nit: I think this is redundant.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java bean prefix of get or is.
Won't this solve the problem? Only a few problems with test coverage: 1) if a Declaration doesn't exist, it will be ignored (if it exists) 2) is missing a LinkedHashMap (for some reason)
Will this method be called for all partitions of the baseline file?
This can be replaced with something like: assertNull(voidedDiagnosisService.getDiagnosisByUuid(clazz));
Shouldn't we return here?
rename to simple
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs,...)?
This change is not very useful, is there some way to deprecate some of kit names?
final?
check response code.
@free4murad Why you put same implementation of subscribe() in different methods?
Again you should check presence of Attribute and Facility within the beans read from ldapcManager.
Why did you add this, when you just want to the log statement?
maybe the first sentence should be "executor submit failed" or something similar?
I'm not sure why we're adding this check here.
Shoudn't this be 'private'?
@cuenyad use anyMatch instead of isEmpty
Please add braces around ||.
You should probably use the logger but not the for loop.
this new String[] is unnecessary, please use Utils.splitString, for example in testSplitMissingTags().
As above, probably shouldn't try to create new Properties manually.
Why do we need to convert to a List? can't we just iterate over the list?
This if-else can be replaced with one-liner
So we're basically testing this thing now, right? Care to add a note that we can use Jdk8ModuleFactory.fromUrl(clientToServices)
I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate
Can we catch any exception here?
Format this file.
the serialization is not reliable, what is the purpose of the JSON?
should this be done in a synchronized block in ActiveMQConnection, with the different messages?
I think it would be better to have this reverse the order of the segments, such as: java upgrade.client.machine.getMapDao().saveFeatures(coordinatess);
Isn't the try-block inside the if block? As it is the standard for loop, please initialize it in the try block.
This is inconsistent with the size of 1.
This was inefficient. Odd... are we cannot cache the result?
Might it be a problem, but you should probably use the new @NonNull annotation on the parameter here.
Why don't you use isNotBlank here?
Cannot we add this to the exception?
is this really needed?
Why are you overriding it here? I think it's not good to use the BoundedContext here.
Lower case
I think we don't need to clear the database type here.
Should this be using MassRepairOption, ExportViewTypeMap.SmartLock?
Wouldn't this lead to a NPE if credentials is null?
This test method says test not setting the patient id of the patient. The problem is that the method returns the patient id of the patient with id "order.test...." was already failing and then the test just says "Concept.to.been" in the test below
need a null check on password
consider moving the if to the addVmCinderDisks method.
Use foreach?
It needs i18n still. You probably just need to create a new logger class in this weld/ejb module
osArch already has a constant for "equals"
We don't need to mock it.
Shouldn't this be a separate method to replace the second call to 'else' with a=true'?
Prefer using a constant instead of "magic" like this.
I think it would be more robust to use org.talend.commons.utils.Version, which implements the interface Comparable.
nit, adding parenthesis to the calculation so it is cleaner and safer.
Maybe "ArgumentDeclaration".
I know we are dealing with this but can we not support this approach?
I don't like the sec here suggestion getArguments().getString(R.id.getArguments() + "selected_text");
Looks like this line is not needed?
Here indentation is screwed again. Just remove the whole try there's no need for this example
This is not a good idea. The whole point is to include the name in the error message, not just the message
I would recommend to set testClass to null in the other test cases.
Style-nit: Parens aren't necessary here around the new operator.
suggestion log.warn("Could not delete service account user {}", serviceAccount);
I think this line should be removed.
I'd call getOrDefault() for these kind of checks.
should this be public?
If it's an error, shouldn't we retry the future?
Does this test fail when it did not delete the file? Was it useful to test it?
Why not chain these setting in the previous statement?
looks like this method can be used instead of removing?
same as above.
Wouldn't the MockMapBuilder be easier to use and keep a DefaultValue here?
I think it'd be better to have this abstract class instead of having Entry<Long, FileSummary> get the value from Summary. The dedicated class is implemented for each Summary, and also used by Entry<Long, FileSummary>
Reusing but seems a bit weird to me. If the plugin is rejected by the plugin manager, I'd rather keep it: if (!valid = true) { return; }
Suggest having a method that takes the default length and the constructor with the appropriate length.
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated error message![screenshot 2015-09-09 21 44 35](<LINK_0>
Objects.requireNotNull(user, when) returns false if the user has been removed. Although this is not a check then we should consider throwing the exception at the end.
One more.
1. I think the logic here could be refactored, 2. Non-null? Any way that we can make this private?
@antonini If you add @SuppressWarnings("unchecked") then this will cause the warning.
Should we assert that apiversion is of the first resource?
Here it is going to depend on the resilience strategy... so hard to say. I would drop the operation result assertion though.
@STRING_RIGHTOUTER > 1. The defined RDB will be able to use a single expression which doesn't have indexes, but we need to keep the old itself more flexible.
use this utils method to show error <LINK_0>
It's a little sad we should throw away with the catch in parseMessage.
IMO, you can merge both ifs if (rv == null ||!needsUnboxing(ctx1, command2) -> {
Shouldn't an error be thrown here?
Better to just age >= age * Long.parse(cookie);
This seems like the wrong path... what about moving this one to the 'if' below?
I'd replace this with a better name.
I'm not sure if this is safe: Have you checked any timer we use in the constructor?
Being with representation() is more readable.
This early return can be removed.
aren't changing the name of this method or something?
correct indention if you made this a code, and also replace the first call to super.putExtraIntent
is this supposed to be the original?
Assert.fail()
Why don't you use the static method to determine all the server data, and return the value from dbcp config file as well in the runtime properties, the values that are being defined in the runtime properties, here the values being defined in the dbcp config file would be ignored. Is that the expected behavior?
these would short-circuit at the same condition as with the assertion before these and hence might just be redundant
why does this message need to be different from "Non-auth"?
I'm not sure about the use of this variable.
Please remove this and the else clause below. The logging may be useful elsewhere, and this is a little more messy.
See getAllOperandsCachesCache
requireNonNull(keyBlockNativeEquals, "keyBlockNative == keyBlockNative == null");
Good idea. Will do.
Is there a reason to use "rights" instead of "description"?
Can we extract this as a constant?
This is not right. This is a general PR and should be fixed for a refactoring.
please use Type.VALUE_ARRAY instead of 0
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_1>](<LINK_2>
To be super nice, we have a few conventions in dasein: - AutoScalingData - ips - ips - mmma terminate any instances with label. - The call to nodeIds might not be necessary, - we want to log a warning.
Use rewrite instead of get expression.
You can use try-with-resources here.
It's better to use static import here to simplify the code.
Since we are checking for this before we actually need to fetch allergy, we should keep the original value. The typical standard is to say we are getting allergen.
Please use participantId\":\"" in a string literal, it's not necessary to do the text for you.
Can you put the first block in a single if?
If not inlined, requestedCount reference should be read into a local variable outside the loop.
fix formatting add space after bracket
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
will this need to be public? I think if the style is isolated for that, it should not be created with an API
this can be set by user
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as this.store = getStore(KEY_SET_A, KEY_SET_B); private Store getStore(Set<String>... sets) { Map<String, String> originalStoreContent = getEntryMap(sets); FakeStore fakeStore = new FakeStore(originalStoreContent); return spy(fakeStore); } especially since there's a getCache() method to encapsulate the cache creation
Check out of the variable.
I would rather use the newer syntax (the new api is generally used everywhere): java import static com.sun.ram.common.base.util.RenderUtils.getQuotedNameTo0fras(**US_Touched.getTSs**(), new BitSetStop);
It looks like the cleanup is on heap, so this doesn't need to be in the same location.
Why final?
if (first) { } else if (next) { }
It's not good practice to accept File and InputStream, but instead create another name from file, and use _this_ name instead of File.separator
it is safer to perform the comparison the other way: VmDeviceType.Empty == VmBase.getInstance().getImageVmMap()?
I'd add a check that looks to see if any of the aggregations contains an ORDER BY clause and bail out early if not. These rules get applied many times throughout the optimization process, so the no-op case should be as lightweight as possible.
Experimental with the check for Stored?
We could simplify this by sing the preference option and ssding it further into the preference option.
This could probably be easier to read as: java if (object.equalsIgnoreCase("algebric")) { return "algebric"; } else if (object.equalsIgnoreCase("operation")) { return "Math operations with Constant operations with value " + object.equalsIgnoreCase("operation")) } else { return value; }
are you sure? There are non-throwing cases.
We're abstracting accesses to _parallel property by moving related implementations to ParallelControl. Why don't you move this logic to Config class and use it here?
Defensive copy-paste - do we need to replace this with a member variable?
Perhaps a new method on the enum is not the same as the other class (but with the same type)?
I think this isChangingLocation(); @Override public boolean alterType(ReplicationSource getFingerprints) { if (conf.getBoolean(ALTERLOCATION_MANAGED_TABLES)) { return true; } }
Any reason to not use Collections.emptyMap()?
Could return Flux.defer().
Useless extra line
protected VdsServerWrapper(VDS vdsBroker exception) { log.infoFormat("Initialize vdsBroker {} vdsBroker", vds.getHostName(), vds.getHostName(), vds.getPort()); log.infoFormat(VdsServerWrapper.getHostName(), vds.getHostName(), vds.getPort()); }
I'd prefer the following instead: String supervisors.merge(false, spec, false) { supervisors.merge(true); } catch (Exception e) { throw new supervisors.remove(id); }
This looks like duplicate code (see above) could be in a common method.
Why not just Optional.absent() or Optional.of(file)?
Are you sure that this code is necessary? If not, perhaps just split it into two lines: 1. add a function to the model 2. Use the view.getCloudSession() and cast it to just before the assignment 3. In the case of network network and update the credentials.
Why not keep the try?
In a function the ingest value is safest if we can set the value to 0 and break the function by default.
Can you add final modifier to make the code more obvious?
There are checks for the usage of BatchFinderEntry in the context and Map.Entry implementations. Please make sure that the top level checks are not changed.
Is this a good idea to make the check more explicit?
Might be my math skills, but 5 + 20!= 35 ;-)
Can this (and other instances of "Enter" code) be changed to trace level?
I think you can use the constant for the workspace URI instead of the name of the project.
shouldn't this be externalized?
BoxDto doesn't have a storageLocation, so this needs to be updated: Long id = boxObj.getByBarcode(); Dto.setText(new ValidationResult(request.getByBarcode()));
Not every id record has an email address.
Curious: Why is this explicitly adding a line?
Can we use an else block here?
Please add a check that it's not a valid segment.
Shouldnt entry be added when a container contains the old pods?
We should treat this as a Unexpected error code, since it could also be handled within the catch block.
Can you make 3 a constant for the interval here too?
I would remove this and keep the flow as it was before.
nitpick: join these lines
This is not correct. It should now be ">". And even more important.
No need for monitor.done() if we're using SubMonitor everywhere.
doesn't these methods create a byte array?
Missing java.util.Objects.equals(SmartMeterConverter, o);
Causes ctf tests to fail
why not use t.readLock().lock() instead?
i think you can do something like java.filter(Objects::nonNull).findFirst().map(String::valueOf).filter(Objects::nonNull).findFirst().map(String::valueOf).collect(Collectors.toList());
@ivandalbosco Why not just use ||?
Should you use "\n" here (and also at the error message before printing the "VmsList" variable), you might receive a more readable error, where each VM name is printed on its own line.
I didn't notice this in the prior commit, but we should not have System.out in the code...
Use component instead of this. this in this context will refer to the WebViewClient object, not the Web component (which is what it needs to be).
We should refactor out the logic to use a FileReader here
These are supposed to be debug, right? There are other messages that are passed in by the Java code.
I think I'd rather throw the IOException, so that we don't get the cause.
Also here applies the "try/finally" block.
What is the chance for the number of running elements?
![MAJOR](<LINK_1> Make "isSuppressWarningLines" a "static" method. [![rule](<LINK_2>](<LINK_0>
This change seems unrelated. Perhaps, extract it into a separate PR.
Can you fix this so that webappPath returns a slash?
I don't think it makes sense to add the same source to the QueryDataSource.query() method, since it's a sub query and the getQuery() method does.
double de-reference
I thought about it to be comparing 'name' as 'other.alias' as well?
Please add some asserts ( interval.length == 2)
I would rather use an anonymous class.
add fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
Please use the onNext function and then call onNext for the lambda. This will allow the compiler to get the error-prone. java /** * @param name * @param name * @param name * The type could be used in the onNext* method, if the error is an error, and the compiler will crash. */ public void onNext(final onCompleted) { return; }
Shall we use SharedSiteInstance here?
better to log the uri here too
Can just return true if it's incoming and fall through to returning false.
don't we want to support this under the API version?
Typo: 'be'
I think this change is unnecessary, since it is just a debug log
why not just return new TestMethodName(0)(new TestTaskGroupedShutdownRunnable(), 1, 1);? Given the priority of 1, I thought that TestMethodName() should go after the setup.
I think there's no need to copy the entry part of the array in order to compare it with DOT_GIT_ATTRIBUTES. Instead use RawParseUtil.match() to directly compare the entry name
Please use StringBuilder.
What's the reason for marking it non-null?
Can we use Guava's Streams.stream().filter(_accountService::isAccess).map(Account::isAccess) instead of x.getType() == Account.ID)
It is not good practice to have different name than "CHE_WORKSPACE_ID" so as well, what do you think of that case?
What would happen if it is null? Seems like it would be a bad idea to log null somewhere.
Can you use Objects.hash() here?
Should we still check if RDFFormat!= null? I don't like to have a better stacktrace to be error-prone instead.
I think commandLineInstance() is an instance of this, so it is not needed for this, could be loaded as a field in System.exit().
don't think you need to append the index into the record itself?
Should check if parent param is an enum.
I would modify this message to be is defined multiple times
global variable name maybe?
Use the xml / to create the fragments.
consider to consolidate into a single if block as both do the same, unless there is a particular reason.
Does it make sense to remove the fully qualified name?
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
Can you change this to a method, like the PathWatcher is cleaner? FileCompat.navState.getSelectionModel().addListener(n -> { C.navState.class.getName()); }.
The message is actually wrong, you should assert the NETWORK_ATTACHMENT_HOST > NETWORK_ATTACHMENT_HOST >"
Please add method checkGroupIsExistsException and check if it is true.
does this constructor need to also add edges, if present -- or is that somehow taken care of in the call to super()?
Shouldn't we use a child sans preference instead of Raptor?
Please use the same buildTreeBuilder.build(BuildPlan.getBuildsSummary(), 0) in case the output should be [BuildPlan.getBuildsUnits()](<LINK_0>
can use null?
I think we should check if empty or whitespace only if there is whitespace only in the text.
minor: might want to use the reset() pattern here?
This will cause the second parameter to be null.
I think it was possible to rewrite it with cipherSuite() using the proper resolveCipher method
We can consider adding this value to QueryServicesOptions.STATS_INVALID_ROW_NAME_FOR_PARALLELIATION and IB_ENABLED_ATTRIB.toString()
This method will only remove the defined feature from the defined feature. That is, it could be costly, since the featureState lookup is the same and the ones in the map is only done if the feature is enabled.
fValue
Isn't this already a Long?
You can insert an empty group if the group is null.
What about currentUser.getObjectId() instead of currentUser.getObjectId()?
ss.getCurrentEndTime() returns an empty string, which ss.getCurrentEndTime() returns a long basename! This is the contract I don't understand why it is not string?
Do we need this? Can't we just create auth auth once and reuse it?
Maybe just iterate over the rule rather than iterating through the rule directly?
nit: can we reuse this?
@Nullable please consider using getMinIntervals() as the result is _priority_ so we can bail out early if needed.
Only source and destination is not null
Add newline before return.
if u would FS this exception be logged, we should probably remove the switch and throw in the other case.
This 'else' branch is unnecessary, the return after 'if' returns.
Isn't this the same as the one above?
I wonder if we could end up with some issue, having bean.defaultOutputChannel() and the interceptorRunner in the same case. I'd say that we really should move these logic out of the if (LOG.isDebugEnabled()) {... } block and remove the check in the else clause.
same here - the length should be updated to take into account the offset part
log.error.
This could be a huge performance improvement, since we would have to call it once before the loop.
please use a static import for explicit methods
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames.size() and removedNetworks.size() to variable so it's not calculated multiple times.
double check that no group has been created
These assertions are required, in tests and the next one, the test : results are not verified in the parallel.
Pull out
make BUCK a constant
"pto-" instead of "p"
isEmpty()
this is now wrong - we should not check for null squashed by commit
this seems like an unnecessary step - just something to be written about.
s/Pool/saved/processing/etc/
@mykrishabh-997 why not the following? java if (HorizontalPanel /game/getWidget(i)) { return false; } else { return HorizontalPanel.getWidget(); }
please move this check to service level
Depending on whether the output needs to be released after this call. In case it is not, you should just call this excelWriter to close it instead of writing a single table.
I wonder if this should be WorkbenchHandler.getWorkbenchMessages()
This need to be set in the CSS
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback to be completed to rely on the callback being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
public static? Is that keyword ordering important in this codebase?
We could use CacheContainer#isAsync() for null argument.
Perhaps use try with resources and thenRunLargeException.
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
What is the output of this exception? Should the message be ss?
Are you sure this "random" was already deprecated?
Not sure why this is necessary
should be debug
should update currentEvent in the loop?
Shouldn't we avoid the asset keyword? Are we sure that Eclipse is started with the -ea switch?
@bxf12315 you could have a method that returns EmbeddedHostHandlers and use it to pass the ActiveHost as the constructor of the call to initializeRouteMatcher.
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
Hi. Could you please use {} for all if/else statements?
I don't think that's a good idea to make this more clear. _seem_ IT_
I would replace this if-else with ternary statements to make it shorter. but that's a matter of style - so just consider it
toString() still has to be avoided (the class still provide is in source string).
This is probably not needed at all if it is a translated message.
Have you checked that this method is called with a BlobInfo rather than a String?
nit: why not assertTrue(mapsaps >= CountingHandler.getLoopbackAddress().getHostAddress(), CountingHandler.class);
Should probably be "!x"
newObjectReader(out); and new StringBuilder(toEditList()).append("\n");
Is there any way to not use StringUtils.join() or directly in the if?
Optional: use StringBuilder.append(repo).append(timestamp)
I would rather use a constant for these booleans, for example: java if (cache == null) { cache = new ProtoStreamMarshaller(); }
nit: Use requireNonNull.
Can be reduced to a constant?
I have seen this code in the PR, but we have not changed the public API for COMPOED_TING_ORDER that we can use here.
Could we keep this method on one line? It doesn't seem to exceed recommended length of the line.
@vzool, i think this log message should be removed to release the lock as well.
same here for server.getClientID()
can you use msgClazz directly? (it is just a static method that accepts a boolean flag)
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IllegalArgumentException if there are any problems deleting {@code location}. */ private void delete(Path location) throws IOException { if (location.notExists(location)) { throw new IllegalArgumentException("Could not delete " + location); } } Would this implementation do the same thing?
You may create a static method which calls complexType.getString() here.
The same here, you can use new ArrayList<>(selectedEvents.getOutputEvents());
Please change this to something like Monitor.newServer(failedNode.get(), true, false);
I think it is better to use: java if (readPage!= null) { encodings = new ArrayList<>(Arrays.asList(getPos, content.size()));... } else {... }
Shouldnt we return VDSReturnValue itself here? If some exception, succedded flag is set to false, else getReturnValue would have the status entity populated.
Do we really need a separate try-catch-finally block here? If there is an exception thrown, can we just throw an exception?
2 or 3?
Move the local variable declaration to the start of the method.
didn't we have to set this to true as well?
Looks like a copy/paste error
Incorrect indentation.
without **a** 'MessageHandler'.
Is this line as well in other parts of this if block?
Iterables.filter(fEntries, CounterTreeViewerEntry.class)
You added a parameter but this command is also used from other places, so this will cause compilation failures.
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to nullValue by the state system.
There are a few issues with this: 1. You need to compare the idenitifiedUser with all change. 2. It only fails if the change is in the PatchSetApproval. If the user has to deal with it with another user, it should be fine. There are also other issues with this coding style in this file that I can see.
This method seems to be used only.
I'd use Collections.emptyMap() instead of new String(c,p).
I think.findFirst() is safer here
Minor typo in variable name; should be malicious
After rebasing with master branch, this will cause NPE.
I think if you move this statement to a separate method and call it twice in this class, would be more clear (e.g. method createTopic)?
change to LOG.info
The second condition should be: if (attribute == null ||!attribute.getName().isEmpty())
As it is currently written, stripe.add(stripeIdx) will have no effect.
CharArrayUtils.subarray(fValue, offset, delta), use the char[] constructor.
You can do away with the added complexity of a negative check in both if and else.
The name should probably be 'dc' and the others.
initializeDisksAndReplicasOnNode is always used for this, we can remove it.
extract method
Can you please use ProjectUtils.createRelBuilder(RelBuilder, input, rel, child, rel, etc) here?
should we use the object avro() instead of Boolean?
suggestion List<Completion> list = new ArrayList<>();
@d-molotchko reference the test instead of assertTrue.000001(actual.longValue()) instead of a failure.
Yes, I agree. Done.
In case of a valid IPv4, the address will be resolved using brackets.
Even this is not necessary. This is not really hiding anything.
When opening a trace in the unit tests, the file makes sense... This is often set to null, it is not required. But then we'd have to see where the file is empty
This is the same as the one above except for the PR, so this error handling should be a runtime exception instead of a string. I would move the default error handling up to the UserPortal's startup which is currently not recommended.
@ptirador why you dropped it?
Use TaskType.STANDBY.
:pencil2: You can remove the cast to ((OpenAttributes) util.getMetacardsByFilter(ATTRIBUTE_TEMPLATE_TAG)) below.
Arrays.asList(modelEntry.getKey()).collect
Why don't you use "this" here? It's just a lint warning.
Make the method static - it is only used in 1 place
A lot more vals please
nit: The only issue I'd think is logging the expected message as a warning, saying something went wrong.
I understand that this is the timeout for a test which is something different than the one in #LeaderElectionListener. Maybe it would be better to use a timeout for the test to verify that the node was started without a timeout.
@tsurdilo You can use here rather asserting HTTP status code, that way if we are expecting the attribute to be greater than 0 then the test will fail.
Define the strings in a constant or have it in one place.
Should be a single logger.info("Loading properties from disk: {}: {}", current);
This is impossible, blockLength is an int.
Why did you add this parameter? It always has the exact same value as the other. So maybe just drop it?
If this changes, can you just throw an exception to avoid returning a metadata storage?
s/getMessage/get
Is this equivalent to org.ovirt.engine.core.common.businessentities.OsType#Other?
What does the race condition here? Aren't we still skipping the access token lookup even it's still valid?
suggestion MekHQ.getLogger().log(Level.WARNING, "Player for (final Replicate [Player] / [Playerless.] With this change, the other class is not mounted."
There's no locking on this? Also, isn't this the functionality you wanted in the Facade layer?
I would suggest not to call init here, as this method is called in initBugShaker
is there a reason why this is public?
I'd like to be more explicit then these message messages could be removed to be more verbose by using the SSLSocket class, and invoke the exception with the message in the log statement.
Does it make sense to print m_response?
Maybe it's better to put this in a new method to take "private" into account methods and refer to the same method? I.e. java private void main() { if (conversationFragment == null) { final UiFragment fragment = new UiFragment();... } else if (line > 0) {.. } }
can you use tracef here too?
You can do:.map(this::getGoal, payload -> { payload.getRelatedLoginID().getImport()); });
Does this mean that we are not throwing an exception?
If we add anything to the project data, we probably don't want to update the entire project data for each update.
Don't we need to hold onto the result of FileSystem.create() here? Ditto..
make this final I think
what's the purpose of this comparison? RefFilter doesn't have to be modified either, just refs.
It's not safe to return null if there are more than one strikes as the value, and equals the returned boolean. The latter is more clear as if (strikes == null) { return true; } if (strikes == null) { return false; }
I think the clazz here could just be throw new IllegalArgumentException("Poorly configured permission '" + annotationClass, e);
missing space after if
typo
Multiple 'if' and'return' statement on the same line.
Instead of calling this method here, you could create a private method that returns this collection.
This message should be "Cannot partitioner."
I think its better to return at this point (and to keep the function signature in a local variable) before calling it again.
Nit: can we define a final variable for this?
change to Log.error(message, e)
does Version automatically define the buffer if it's not going to be stored in the payload? Although I'm not sure about the fact that payload.length() is guaranteed to be less than bytes in the buffer. It's not a big deal, but it's probably not a problem in practice, since message is already a byte array.
These strings can be extracted as constants.
This test case seems excessive.
Can you put this on one line?
Could we include just the expected value in the exception?
If there is no ProjectState then we're still using this form of ProjectState.
any reason not to use diamond operator?
We should remove this.
Shall we move this to a setUp method and keep the diff lines of code a bit more concise?
I'm not sure if we should have this. I think that there's a failure reporting which would need to do something.
Shouldn't these be done when start/stop polling? They are already performed in the set of changelog and not on.
We can probably replace this with RuntimeException (if you are dealing with a catch block).
Why are we using.anyMatch() here?
Let's use the replacement as described above.
Failed do nothing
You can use the logger instead of this.
Check how this looks in landscape mode
Do we need a special case for evaluator?
This value should be read from the UI in the layer.
doesn't properties.forEach((ConfigurationManager) )
The following part can be moved out of the synchronized block.
After trying it, we would prefer that the black highlighting would be drawn with two lines. The reason is that when the'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y, rect.y + rect.width, rect.y + rect.height, rect.y + rect.height); Or I guess alternatively you could draw the highlighting rectangle first then fill the state color which would overwrite the left and right edges...
This is not an issue, but if you wanted to avoid strange name then can you change it to something like quartzTrigger.withJobData(jobIdentity).build()
Null check?
Can we move this logic to a separate method?
maybe you could move this to a common place in the MetadataType class?
What if host and port are null? Shouldn't we throw an exception?
This processing should be done before instantiating the aggregator, right?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
if you're not checking for this outside of the loop, it's hard to read. IMHO
Can you add project name (see the ticket name and subject)?
Can logEntries be used instead of TRACE
should make sure error messages are consistent.
We cannot assume all the DSpaceObject is the thing being indexed. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
This is an expensive operation to check if ssl already exists, and throw the exception to avoid string concat with the right exception. This is done by using Preconditions.checkNotNull() from JDK, and the general _matched list_ to check if null is found.
explain this
It's also possible to test that IDENTITY_MAPPING is used for both categorys. You should apply the same changes in both parts of this branch in your PR.
flip the logic here as well
I came here that the entire point of a suggestion is to populate as a list all of these sorted strings and now we have a proper String value for the result?
You can change the variable name as well
This will need to be revisited to throw proper exceptions.
Should the check be moved to isPrivileges() method?
I'd split this into two methods. One for example:.getArguments().ifPresent(expression -> { aggregation.getArguments().ifPresent(expression -> { aggregation.getOrderBy().ifPresent(expression -> {... });
Use EMPTY_ARRAY
Missing generics
missing a finally block?
if you have multiple return statements here, I would say: if (supportsGlusterService && Frontend.supportsGlusterService) {... }
You must check bother.
Can you give a more specific error message for this exception. Does it make sense to throw a RuntimeException with a more useful message?
I think you can delete the try/catch and the test case is not necessary?
If this is moved to a new line it would also need to be wrapped in an else and just return an error and the caller is not able to see anything about it.
doesn't need to be final
Seems like this should be 'if (notification.getMeasure(() + notification)) {' and not 'break'.
Please use String name as second argument here, not just 'firstName'
I don't think it's possible to call close
The final keyword is redundant with the above declaration.
I think.equals() returns a value in the range [0, 1), so you'd want to check <.125 instead.
I think you should be reading the ByteBuffer instead of the array. That way, if it is the thing that you can loop directly on line 133, then you don't need to assign it here.
We can use the log level of the stack trace when we get it.
I think this should be in a finally block to ensure that the user sent the error during save()
Blank line before and after the loop
I remember that QueryParameter#contains elsewhere but not here. Is that needed?
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
s/callExpression/callExpression/
Please use any(State.class) with never() to be more reliable
Just a space after the {.
It seems that this check can be simplified to: return ((Set<HiveType>)fromFieldTypes.get(i).equals(toFieldNames) || isFieldTypes.get(i) ||...
Did you take a look at this? <LINK_0>
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
IMO, it's better to use the different approach: suggestion if (modifiersToken!= null && modifiersToken.branchContains(TokenTypes.PARAMETERS)) {.subscribe(modifiersToken -> { DetailAST modifiersToken = methodDefToken.findFirstToken(TokenTypes.PARAMETERS); checkArgs.findFirstToken(TokenTypes.java:88) || modifiersToken!= null); }
Three space after if.
Seems like this could be removed if it was already been added above. Why would it be needed?
this block is repeated in the above only. can you refactor it to a private method that gets called from the UI?
same thing as above, can this be a different method?
Ah, I see you are using the code formatting in the PR :)
Maybe we could have a TypeParameter annotated type parameter?
This is much more readable, I would extract a method to computeCurvedinate(Line) and call it from there. The code you can have 'getStroke(...)' into a constant.
this could be put in a constructor, like what do you think?
Can you add a fail() after the comma?
A straight port of this is odd. You could call r.append(";i") for.append(i).append("..");
Using assertThat would help readability.
Why are you using getOutputStreams() to get the input?
whole thing I was thinking for using p+m where to avoid the.map stuff if the user uses a lot of precision for scales and will starve because of this method. It is not really hard to grok with the getAsDouble, what have an annoying annoying unboxing from the OptionalDouble but I'm not as it is. It would be a good idea to make the change since the test has no effect on the scale. Granted, we don't have a good idea to make sure it is mutable, but it's not so easy to forget to make a difference when it gets called.
It's preferable to use String.valueOf()
:notebook: [System.out.format](<LINK_0> may be able to help here
Why forceWrite?
Is this necessary? Just curious.
I think we have to use getContent() here instead of getContent().getDefinition() to get the definition of a map and then just call getContent().getDefinition() here.
What happens if delete is called after close?
Design wise : I would rename this method to CFG.USE.
This is a generic pattern. Let's pass the JdbcSourceConnectorConfig to the constructor.
A WordsEnvironment.getObject() should throw an exception if the object isn't found.
Shall we wrap this with a try/catch?
A check for the null check would be better, to allow the user to locate a new PluginInstantiator instance.
Should this be Expressions.isBefore?
useless parentheses
Change this to be: "GOV1-BND4_INFO".equals(CurrencyAmount.getVCS()), SETTLEMENT_DATE);
Use expectException?
This is a completely redundant, you can just move the delete of the if below the if-else
This should probably use auto-loglog, since the callback may be executed under the resource (and not the data that is closed).
I'd suggest making addFromProjectNegotiation(referencePoint, referencePoint);
Please double check if this method is invoked too as we have two lines above, EditableHeaderMetaDataHelper.getColumnInformation cirdString(String[], String)
Why does it return null? Also I think this should be a null check on the injection as well.
This change does not seem necessary for this PR. I would like to know why this line was changed.
The constructor doesn't use a setter in the constructor.
Does this also log the information from the Exception?
> AudioManager.getMap()?
braces
Wouldn't this be problematic when detaching the network from cluster and this code will run?
why not to check it with lastIndexOf? It will be more interesting to see when project already exist.
I know you didn't add this, but shouldn't it happen? ;)
You are using a static import for Char
I think these variable names should be changed to be the same as the field names now.
Can we have this property on the other side, especially if it's not a supported filename, something like: java if (payload!= null && payload.has(FIELD_OPERATION)) { return payload.asText().equals(payload); }
Here we are still checking for the presence of the expected size.
@vilchik-elena This makes the code harder to read. It's not necessarily the case of symbol from!enum or method.is(Kind.METHOD)
Perhaps single quotes around actual code
What if metadata is null?
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
Should we have this config.user for the database so that it can be used?
Same nit about formatting here.
We don't need to add the default env vars.
@atmp; keep the last line in the if statement.
This is a bugfix. Suggest changing to use the feature.getUserData() to allow things like 'if (isExisting) { insert an insert feature; }
I'd like to see it in a " image" list. I'd be able to look into this in the repositories view.
This method is returning List<String> rather than Mono. It may give you a way to implement this method?
suggestion botClient.getLocalPlayer().setCamoCategory(botForce);
I'm not sure if this is necessary. What happens with an empty list of timeout?
You can change.equals to.equals(BIGINT) ||.equals(INTEGER).....equals(NUMBER_OF_NON_NULL_SIE).equals(TIMESTAMP_OF_TRUE)?
This Id may not be set in the constructor. We can do it only for properties which want this groupId to be present in the constructor.
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the normal or exception flow path, no?
Why not just use sanitizeGoogleId(googleId); and do it automatically?
Do we really need to do the asserts here?
This should be a static final constant.
one?
Can you remove the quotes not added here?
prop: It seems like we do not need statefulTasksToRankedCandidates anymore. We could directly build tasksToCaughtUpClients from statefulTasks, clientsToCaughtUpClients, and configs.acceptableRecoveryLag. Also in assignStandbyReplicaTasks(), we only use the keySet() of statefulTasksToRankedCandidates. So, we can remove statefulTasksToRankedCandidates.
You are not testing whether the changed value is null. This is why [this](<LINK_0> here.
We should put this code in the RepositoryHandler class.
This creates a very small List <String> -- so there's no need to convert to a String
Since you're only going to be using the fact that these get pressed, consider just passing Events instead of Booleans. (Igneous.joystick2.getButtonSource will give you EventInputs directly.)
remove first argument
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
1. This is a bug fix, 2. Why is this needed?
Could you please invert this filter and avoid the Streamer return null and the StreamerimentAccession for short return statements?
Minor: There is no need to add jobsWithoutConfig.
Is this repeated from elsewhere (e.g. Sirius)? Can reuse?
it's confusing to me. Can you perhaps elaborate on what is going on here?
I would add a null check for elastic agents
do we really need a timeout here? I think this makes sense.
I think you need to do a null check here or just move the task definition.
v1
We should not set the archives on the other archives, as it is a local with a different archives, which are not the other than the other archives, which are not the other than the other archives, which are not the other than the other archives, which are not the what we want. I'd rather go with a different property than the -spark- archives which are not the same as the archives, which are not the other than the -threads default - which is a property with a archives set of the other than the -jar - archives
Why remove the key and value from properties map?
this validation part could be moved to a separate method (validate in one line).
this should be numberOfRetries.size()
whitespace
why is this done again? looks like it was done already in line 111
Are we not going to use the EntityRef here? To avoid confusion, I think it would be better to have the entityRef variable from the EntityRef to store the entityRef in a Map<AccountRef, String> (not a BehaviorNodeComponent) rather than the BaseRefactor.
This looks strange. I think that for some reason you need to add some examples of what you need to do with the command line flag.
might be better to use the titleView.layout here, wdyt?
((Server)server).setModuleState(temp, state) is called twice in this loop
Unrelated change in this PR, but do we need to create PRs?
I think we should check for null here too.
please include the cause.getCause() part before calling generateRequest().
Why are you checking an insertAfterKey and insertAfterKey together? I think that should be simpler.
should we use Project.Builder here?
Why not adding a new stream to the loop and then just findFirstToken() the array? Wouldn't it make more sense to have separate methods for each type?
do we get the redundant newline thing now?
This is a little weird, but you could actually check the view to return here... So this is a generic colour specific thing, and should be in other files.
Yes, I think getArtifacts() returns null. This should probably be assertThat(latch.get(0), Matchers.equalTo(2));
Should this be an assertion for the fact that a field is missing the same as the field?
else if
This should also be included in the exception message
totalExecutors.entrySet() can be replaced with Comparator.comparing(Map.Entry::getKey, Integer::getValue)
nit: does this need to be a static?
s/Qualifier/Qualifier
why not put image?
use a constant
Maybe I'm being daft, but where are the CDA message being added?
Why are we not using this?
Shouldn't it be template.isJSFVersion()?
List<RepositoryGroup> groups = List.of(groups); List<RepositoryGroup> groups = elements.stream().anyMatch(group -> { if (element instanceof RepositoryGroup && group.isVisible()) { groups.add(group); } } return list; }
nit: I'd suggest putting the redundant checks in a separate function.
Was this intended? If so, can we just log error message in 'debug'?
why returnValue? if you want to keep the same indentation, you can use it instead of the else
How about creating a job in the Job?
I'm not sure if this method should be called from here to let it do the same for all the other messages. For example, if someone has FixedRepositoryRepositoryManager.getInstance() and it resets the result and returns the value of the form and from that point. So, something like this: if (!hasCentralRepository()) { throw new CorrelationAttributeInstance("Error"); }
This looks spam
I'd catch RuntimeException here as well.
This can be moved into a private method.
This is unnecessarily slow when change!= null and we know the branch name from the change object.
in the name of this, it's a common use case. I do not want to go through the Pattern to find the regexp (they're not Pattern anymore)
This code is used in my app. So it's more than once. If we need to create a new class for the appInfo, please return a top-level message.
There should be a null check on this.
Yeah, I would have thought that responseStart - requestProcessingTime is the response time, but it can be assigned to responseStart and responseStart. I don't think we need a retry.
nstream = new BitstreamRest?
Shouldn't this be: if (mActive && mWifiStateMachine.isMobile) { mLastPowerState = cm.get(); }
This might throw an exception. Also, shouldn't this check be made to convert to string.
Make sure it works, but you're still doing it for every request.
Do you want to keep this?
I think 'n' is a reasonable way to handle this.
shouldn't you emit the map from the BufferedInputStream?
Will fail due to null pointer or study, like we are doing in Shawn
It would be better to throw an exception instead of just logging it.
Please rename 'getFacings' to 'clearProperty'.
Order of these two if conditions should be combined into one. Otherwise we would not log the exception to the fact that the file ends up in the directory.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
The groups should be inside ProjectControl.
I think this is missing an implementation of it, because this _could_ have a queryPlusQuery interface which handles that queryPlus from an interface.
For a config we have a way to protect that, the user specified a field in the global way they have that name. The global "init" is used at multiple places in the code. But then, if it's not used, the global *init* is going to imply that, it could have a different extension (since it seems to return a data provider with no data), and then the configuration just does not have to manage it.
Using the returned AppBase app to get a case where it was before (in the PR).
I'm not sure that fetch parameters are needed here, or anyway, it looks like you don't have to explicitly close the column if there are no rows left after it has been reached. Also, if you are going to close any row that has not been closed, it's not stopped to return false.
Please combine the block with the following if statement: java if (!healthCheckRegistry.getCRUDController(crudControllers) && crudControllers.getCRUDControllers()) { return false; }
You should use the org.elasticsearch.client.model.Map<Entry, HttpStatus> to make the code more readable.
I wonder if we can have operatorChain being able to remove this log statement?
I think that the key could be null, in which case 'empty' would have been thrown.
If the index was not found, then the message should be updated as well.
Please use getDbFacade() - it makes it easier to unit test.
@inverno This is confusing, the method name is not correct. The exception message also states that the user is interrupted should be ignored and the command is not complete. I would suggest adding a new CommandContext() method that the command implements the interface method, so it will make it cleaner.
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
This looks like it's duplicate of the bounding box, why not just take the bounding box?
This can be simplified: if (acl == null ||!acl.isEmpty()) { throw new AccessControlPolicy[0] }
ipEntry entry = new ipEntry(new FileInputStream(path));
Why not to use ImmutableList.Builder<HiveColumnHandle>?
nit: wrap with {
Should this be StringComparator.allowsEmpty(name)?
these if blocks can be combined
Would it be possible to refactor this and other logic inside a method to reduce duplicate code?
double check that the group is still here
I'm not sure we should keep this, but just add the original exception to the log, so that we can identify the issue and avoid duplication. This is just to keep in mind to have a clean up script that is done, and acceptable to have a clean message for the user if they want to have the right Exception, or if not we should add a new one and just keep the exception message.
I think it's better to create a method called getPossibleErrorsNumber(TASK_FAIL_ON_DISABLED_TASK_NAME, TASK_FAIL_ON_TASK_NAME, trueParam) and use it.
should be 'task'.getFixAssets()' instead of 'task'.
start time is -1?
can we make resourceName for all the states be same e.g. "state" instead of being specific as that requires the conditional and hardcoding of URLs? I think it's better to have a static variable.
1) When would 'worked' throw? 2) Why drop the exeption message and use the proper message?
I think the default should be true. It is a little bit cleaner: selectedAnnotation = > Optional.of(annoProxy.getShowMarkerClick(marker, false));
You could use IOUtils.validateArg which takes a java.util.concurrent.Callable and isCommand.
Are you sure that Id is not a string?
Can we just iterate over the list to avoid the intermediate list?
We can probably just store the actual value in a local variable here.
Why is this needed?
Should be meanSingularValue.
Two getBytes(Charset) and helper methods. They are repeated three times.
If we are testing the "positive" flow, we should also test the following cases: * 1. tests that are passing a non-null account to the DB. 2. If not, we should explicitly check that the account doesn't exist in the following tests. (Same with all the other tests.) 3. verify that the account doesn't exist in the returned password.
Since this is an error, it'd be better to leave the caller out for better code. Code: If we can avoid using the method throwing an exception, I don't think the caller doesn't need to call it explicitly. This is an error that is fine, but it might be better to keep the caller happy.
Format the whole code (ctrl + alt + L)
I think we should keep the logic of jettyRequest as a field, but rather we don't need to use it twice.  jettyRequest = jetty.getAuthenticationStore().getAuthenticationStore().getAuthenticationStore().addAuthentication(HttpServletRequest.USER_AGENT_CHALLENGE.toJson(request.getAuthenticationStore().getAuthenticationStore().getAuthenticationStore().getAuthenticationStore().toString()));
Update log message
It looks like this should be a warn instead of a DEBUG
use parameterized logging instead of string concatenation.
Perhaps a builder pattern could be used here: this.checkstableGeneration = Iterables.get(pagedFile, Predicates.hasSelectOption( "lowTreeNodeId", "/", treeNode)?
Should this always be called on the hudson.Util class? If the location is external, this will throw an exception.
lets add a short blurb in the field description and in the.md doc file describing that records with a null field get filtered out.
Why do you close this stream in constructor?
I don't think any of these are still part of the API and others. Why can't we use RANGER_HDFS_STATUS_CAPTIONKCARD_SCREEN_AVAILABLE_URL here?
we might not need GetBlobResult anymore if GetBlobResult already contains the chunk IDs.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.get(). That interrupt will (potentially) interrupt the sleep and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching the interrupt and just returning.
To add edges, *or* that are not handled. In this case however in the node table the first node algo may still be skewed.
Any reason not to include e?
Please format the code according to the Eclipse formatter: > initializing VM vdsm as a string, should be the first parameter of the method. I prefer the way it is done in line 138 and only if it fails.
Defaults.Object[]?
Can the code be written more readable without the need to compute the filter string first?
define a class for this?
This should probably be else if (accessTravelTimes && lineStart) { to reduce the amount of code duplication
You introduced 8192 in a local variable. Could use a better name for this.
Store the Attribute in the constructor? No need to use the boxed type.
This must be done from whitin the locked block, after we've received the sigal from "notResolving". Otherwise a new thread might come here and dispose of the old one's pools. Likewise for all calls to create and unlock a new one created once.
I assume this should be 0L instead of 1.
Minor: cleaner (ITree ment ;)
@ocID WDYT about using a StringBuilder to get rid of the extra whitespace.
This seems to be incorrect. Even if limit is 0, it is not possible to have a key for the current user.
I think it would be worth making this error a bit more useful. At least adding the node number so that if errors pop up in the log then someone can see if a particular device is generating lots of errors.
For that if we do end up with this check, we should probably use if (mode!= null) {}
Let's update metadataLoc to avoid re-creating it for newMeta1?
please use a collector here, like the structure of the 'List'
null == adapter
I am not sure if this is the right place in code.. I have the feeling that the query could run multiple times for a single query. For example, if we set the timeout to 10 seconds, we will need to be 2 seconds. What is the reasoning for awaits in the test?
I think you should keep this as NORMAL since the equals method is only used for the parameter in the rest of the test.
You can use the ChunkState#isStitchOperation() here. Then you won't need the code here.
I think here it's better to sort the time. It is used only once in the method, so you can ensure that it's the same variable and be used for each iteration.
I would suggest you to add a TODO here, in case there is a significant number of args for a log, and it's not a problem.
Can we make this more readable like java Set<String> unusedTasks = previousAssignmentByInstance.values().stream().flatMap(Collection::stream).filter(x ->!newTasks.contains(x.getName())).collect(Collectors.toSet()); return unusedTasks; }
Is this needed?
Shouldn't the string be included in the base class (or a specific class)?
wait for the callback to be called, then you don't need to check it again.
org.apache.commons.lang3.Validate#notBlank(Object, Class<? extends Authentication>)
It is best to define a method to do this. Up to you.
This file can be deleted.
Please move the above line to after the loop.
it is a good idea to log an error in case the connection fails for example
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do: Long value = expectedMetrics.get(metric.name()); if (value!= null) { long expectedValue = value.longValue();...
I'm a bit confused by this code.. I don't think it's necessary to do the isCurrentPlanBlogIdForLocalBlogId check here.
You can use try-with-resources.
The semaphore cannot be equal to 1 thread, so it's the case that the semaphore cannot be allocated, which means the request should be restarted.
This file is used in two places
Why not add the this. prefix?
I don't think this function needs to be synchronized, or there needs to be a race condition here, since there's technically a race condition.
what if isRunning() returns false?
This can be replaced by == rather than a for loop to avoid the slow condition: if (t == null) { return; }
rlum.role:vraptor has a method called Target instead of targets
Could you move this log to the top?
why do we need to use the above 2 lines?
You should have done it right when writing this for the first time
Minor: FileOutputStream outputStream = new FileOutputStream(fullTempPath);
No need for a separate exception.
1. no need to call checkValids(order) here. 2. don't you already save the entire execution?
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work
Ah, you should probably catch the exception and wrap it with a RuntimeException and handle it properly. This way'success way of being thrown from the method is already interrupted. Also, you should probably wrap the exception into a RuntimeException and throw with a more specific exception. Returning the result would be a runtime exception rather than a runtime exception.
We should assert the workflows, not the workflow.
extract the in a try/finally to ensure the 'if' statement is closed
It would be good to throw another exception, instead of ignoring it.
Should it be new ApiAction(ACTION_EXCLUDE_FROM_SEARCH_SCANS, new ApiView(ACTION_EXCLUDED_FROM_SCANS_EXIST, PARAM_SCAN_KEY, true))?
We appear to be re-implementing some of querying logic to find the host for a standby-container. Instead, leverage the existing APIs in job-job-filter
Please specify why this is again: f1.evaulate(itcarray[i].getName());
So if I have 2 sherlockAttributes in the same granularity, we'll get the action content for each element....
no need for 'this'
I know that it is not part of your changes, but please add a space in the keys.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
Remove the hard coded string
I don't think we need to do this anymore.
don't break the entire function
Conflicting name with other ratesources
What is this?
@fanifieiev the same above.
May be move this to a private static final class.
No need to print stack trace here.
suggestion assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-
I think it would be better to avoid other loop casting by class name. It is more complicated.
<LINK_0> This is only true when insert is failing due to the violation for PK uniqueness, neither foreign key nor unique key. So we still need to query for existence while we are defining foreign key.
You should probably return the resource as a job id, not a trace element.
extra blank
Do we want an assertion for this?
Should we check if the file has been deleted for some reason?
I would still throw Exception here instead of printStackTrace
if (row.size() == 0) { return IntIterators.EMPTY_ITERATOR; } else { IndexedInts row = row.get(dimensionId).iterator(); return IntIterators.EMPTY_ITERATOR; } return "true".iterator();
style nit: no braces around single line blocks
Is it possible to use!nextNode == null ||nextNode == null?
new byte[0] instead of new String().format().
not sure that this should be done in the snapshotTable that you receive as event
Generics?
This is not sufficient. Status is always true by default, so the user gets an error (it doesn't show when file.getProject() returns null).
This will probably add the span to the current thread.
This will break when the correct behaviour is defined in the parent class. Is there any reason we shouldn't add this check?
The first parameter you need to set is that it is 'expectedClass'.
Calling getLifecycle() twice (just in case). Then, you can call "this".
We probably don't want it to be disabled here, but just suppress it. You can remove the IOException catch block and let the exception propagate to the method caller.
Make it as a method, since it's used in a file, and you could just put that method to the wallet. Then you don't need to call a method (which is then a Long instance, but avoids double-negative).
I'm not the biggest fan of having the isExpanded/setExpanded still live in the model object, but maybe that is a change that will be a part of <LINK_0>?
I think that the! is redundant because of the!
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why DefaultsPropertiesContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
pwd is never null. I would recommend using [client](<LINK_0> instead (which is a lot cleaner).
Great!
I believe it should be TypedId
You could add your own anonymous class to the top of the method for this. Just the Problems and style is wrong too :(
I don't think that if this happens, throw an exception is better.
would add constants for string constants
same here - "this page is not in page"
Remove firstSense, not this code.
put this in a finally block
I'm always a bit suspicious about using method calls with ternary operator, since Java will invoke the method even if the precondition equals to false
Not sure if using StringBuilder is the best option here. This also require a StringBuilder, I think, and it would be easier to read.
I think you should check sSelel, as as first line returning null.
We may want to use nullOrEmpty.
an alternative is to put in a method in the base class. For instance, inflightRequestInfo has the same logic to return the response for the partition id and exception. I don't think it's a good idea to throw exceptions in these cases.
(originalDs is not null) can this be done in the prior DatastreamObjectMapper?
The other test does not have this delay; why is it needed here?
change line arg to callbackListener.onError
Instead of having a string constant, would it make sense to use a static variable to hold this specific class?
I'd prefer to have static import.
I would move this inside of the workbenchWindow
Nit: These usages of the constructor above should be used over here.
I suggest using the randomSize method here (and in the next test class). IMHO it's not the right way to go.
The prefix M is used at several places. It could be extracted out as a constant.
DataGenerators.getFieldCount() is only called in validateOptions(). Please use the private method to validate only the name, change the private method to validateOptions().
can these be info?
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "final". [![rule](<LINK_1>](<LINK_2>
use try-with-resource for close
This is going to produce a list of arrays. Is this the best way to put this in a static block?
Missing case insensitive check suggestion if (conjunctiveFormula!= null) {
Is this line really needed? What is the purpose of using Java 8?
Would be nice if try-with-resources to avoid the resource leak
This should not be needed since the default value is set by the user.
fyi, it would be great to add a bit more code here to initializeCipherStorage for the sake of expiration
