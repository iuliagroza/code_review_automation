Is it guaranteed that this order is undefined?
Is this order guaranteed, ie ls exception?
Is this order guaranteed?
Why not use logging framework?
why not use logging framework?
remove
Is this really needed?
I think a switch statement may be clearer here?
I think a switch is required here?
Shouldn't this line be deleted?
That is also a good candidate for a dialog with an _else_ condition.
That is also a good candidate for an else-if.
Could you please extract the duplicated logic to a separate method?
Could you extract the getTypeToken call into a separate method?
Could you please move all of these checks to a separate method?
how about using try-with-resources so that the connection is closed?
how about using try-with-resources statement here?
how about using try-with-resources so that the connection is unreleased?
No need to extend threads
What about the following? Java 8 String threshold = new StringBuilder().append(Paths.get(index)).append(" threads");
Is the following method necessary?
What is this supposed to do?
Why are we not using the provided values for the user-provided values?
Why are we not using the provided value for the user-provided values?
shouldn't we throw the exception here?
Isn't better to use the constants for the error codes?
shouldn't we set the error message to Provider manager and auth for the first?
How about handling the case where there are several fragments?
Please format this like below.
Please format this like below
Can it be package-private?
Can we catch a more specific exception here?
Can we catch a more specific exception?
I wouldn't do this at all, I'm wonder if we should use the old BulkWriteError (if we aren't doing anything special)
I'm not sure if we want to return anything else here.
I wouldn't do this at all, I'm wonder if we should use the old BulkWriteError (if we aren't doing anything about it).
why not returning null?
final?
why not?
path list will be empty with copy error set to true?
path list will be empty with copy error set to true
in what scenario copy error set to true?
Can l be a lambda here?
I don't think this is right. Should it be l == 1?
Can l be a lambda here as well?
Make this a long rather than 0L?
Make this a for loop for (long net = new ArrayList<>();).
Make this a long rather than 0L
check to make sure notificationUUID is not null
check to make sure notificationUUID is not null here
check to make sure notificationUUID is not null?
suggestion return validateLocksOnReads(tableRef);
suggestion return validateLocksOnReads();
nice one
please don't remove this. You are not supposed to check this now. If the commit is not started we should check for this.
please don't remove this. We don't want to check for null from this.ui
please don't remove this. You are not supposed to check this now. If the commit is not started we should check getCommit() method above.
Seems like there's a spacing issue here, two spaces instead of 4.
What happens if the user actually wants to use this file config/sun_checks? There will be some problem then, no?
What happens if the user actually wants to use this file config/sun_checks? There will be some problem then?
Do we need to consider the Messages.getString("DatabaseForm:" +schemaText.getText()); or extract a constant?
Do we need to extract the definition of this given statement?
Do we need to consider the Messages.getString("DatabaseForm:" +schemaText.getText()); or maybe even the text?
I think I'd call that addEditLink() or something. I am not sure I like the idea of using the same name as the general purpose field.
I think I'd call that webLink" or "defaultLink". I am not sure I like the idea of using the same name as the general purpose field.
I think I'd call that webLink" or "canTheLink"
Use.util instead of Arrays.asList
Use.util instead of "/"
Use 'this'
unnecessary else block
remove unnecessary else block
unnecessary new line
Why are we using bus here?
Do we have any thoughts about using EventBus here?
Do we have any thoughts about how to emit this?
this.redisTemplate
this.value = redisTemplate.get(value);
please use Assert.notNull(value, "value");
Shouldn't we move this inside the while loop?
Shouldn't we move this inside a while loop?
Shouldn't we move this inside a while loop, so we can forecessary?
This seems redundant with the sysout ;-)
This seems redundant with the next line.
This seems redundant.
This filter seems to be used very frequently and may be removed. Is it intentional to pass the graphService.getGraph() directly? I mean I would just call it once and store it in a set? Or am I missing something?
This filter seems to be used very frequently and may be removed. Is it intentional to pass the graphService.getGraph() directly? I mean I would use it only for clarity and cache it in on every call to graphService.getGraph()
This filter seems to be used very frequently and may be removed. Is it intentional to pass the graphService.getGraph() directly? I mean I would just call it once and store it in a set and then use it in onVm and cache.
Should we use the super.format() here?
Should we use super.createViewToolTipText() here?
Should we use the super?
@ivandalbosco Is pNode.getParent() needed here?
I think pNode.getParent()!= null is more readable, especially in the next case.
I think pNode.getParent()!= null is more readable, especially in the new method.
Why do we need this.flowChainManager = direction == Direction.Forward? null : direction);
Why do we have this.flowChainManager = direction == Direction.Forward? null : direction);
Why do we have this.flowChainManager = direction == Direction.Forward? null : direction);?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to move the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
Might be worth creating a common interface for org.apache.commons.lang.StringUtils.isEmpty(String)
Might be worth creating a common interface for org.apache.commons.lang.StringUtils.safeStringToInt().
Better to move this logic to a separate method
Are you sure this is safe? Did you want to wrap the ByteBuffer in an interface?
Are you sure this is safe? Did you want to make the type of the ByteBuffer to cast?
Are you sure this is safe? Did you want to make the type of the ByteBuffer instead?
Why do you need to check the filter here?
Why is filter null checked here?
Why is filter null checked?
Possible copy/paste bug in the order by clause.
nit: Possible copy/paste bug in the order by clause.
Why does this need to be ordered by the synthetic primary key?
This would compile a lot in parseDateAssert..
This would compile a lot in parseDate(String format) method.
This would compile a lot in parseDate((String) format) method.
Hash code
Hash code?
return false?
nit: I think these two lines can be assertTrue(FormForm.getInstance().getDeliveryForm() > hasText);
nit: I think these two lines can be asserts the same fact.
nit: I think these two lines can be asserts the same fact you just need the return value.
can we have a special case for the "Descending"?
can we have this logic in the queryCacheable itself? i.e. the delegate.getType() call isDescendingOrEmpty().
can we have this logic in the queryCacheable itself? i.e. the index of the queryCacheable itself is now more accurate
would be easier to understand if you would add a.orElse(null)
would be easier to understand if you would add a.orElse(null) here.
would be easier to understand if you would add a.orElse(null) after the assert.
fail
isn't this risk of breaking the test?
isn't this risk still problems?
Shouldn't this return a Publisher?
Shouldn't this return an empty Publisher?
Shouldn't this return an error?
Can you add a StringReader instead? a ByteArrayString tableName = RawParseUtils.parseString(this)?
Can you add a StringReader instead? a ByteArrayString tableName = RawParseUtils.parseRawString(this)?
Can you add a StringReader instead? a ByteArrayString tableName = RawParseUtils.parseString(this.obj);
Should we throw a more specific exception?
Should we throw the IllegalArgumentException instead?
Should we throw the exception for the user?
Could you extract this into a method: Yaml(String obj) { yamlLoader = new HashMap<String, String>(); return properties; } public Map<String, String> getYaml() { Yaml<String, String> propertiesCopy = new HashMap<>(); properties.forEach((in); return properties; }
Could you extract this into a method: Yaml(String obj) { yamlLoader = new HashMap<String, String>() { yamlSupplier.load(in); } return properties; }
Could you extract this into a method: Yaml(String obj)
Just a note: you can make "foo/bar" a constant (so you can use it directly to change it).
Just call it "createAccounts" instead of "assertTrue".
Just a note: you can make "foo/bar" a constant (so you can change it directly to -1).
count should be count - 1 in range %s
To avoid code duplication, we should probably have a getIntResponse method for the Integer and Long.valueOf
Integer.valueOf
Could you put this in a try/catch so that we can log the exception as well?
Could you put this in a try/catch so that the dismissToast() doesn't return null
Could you put this in a try/catch so that the dismissToast() doesn't return null?
Looks like this lambda is not used on a component. Better use "return false" one
Looks like this lambda is not used on a component. Better use getContext().get(0)
Doesn't it have to be removed?
There is a race condition here. Even if SessionInUse is true, sessions may change and we've lost it. Can you double check that it's still needed?
There is a race condition here. Even if SessionInUse is true, sessions may change and we've lost it. Can you double check that it's not null?
There is a race condition here. Even if SessionInUse is true, sessions may change and we've lost it. Can you remove these null checks?
This can be switched into a simple if (IS_ACTIVE.equals(selectedMonitorId))
This can be switched into the above if as well.
This can be switched into a simple if-else statement.
method name doesn't make sense
method name is not needed.
static method?
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
@Serranya Please, use Cactoos' TempFile instead of this method.
I think this can be moved to a constant.
I think this is not necessary since the port is hardcoded.
I think this is not necessary since the port is always set.
I'm just curious, what's the point of this vs. front of the toString()?
hmmm, can we use Arrays.toString() here?
I'm just curious, what's the point of this vs. whether it's OK to just use the string format?
you could check that the list does not contain "Aimee", and there is no difference between the two tests
this name does not match what it does?
you could check that the list does not contain "Aimee"
Shouldn't this be on the URL class?
Shouldn't this be uri.isVersion26OrLater()?
Shouldn't this be on the Resource class?
You are missing the other change here too.
You are missing the "else" here.
You can drop the "else" here.
I may be wrong, but it looks like a hack to make a copy of the GeneratedHttpRequest type here. Is this method really needed?
I may be wrong, but it looks like a hack to make a copy of the GeneratedHttpRequest type here. Is this method really necessary?
I may be wrong, but it looks like a hack to make a copy of the GeneratedHttpRequest type here. Is it?
We should probably return a List here.
We should probably return a List here instead of ArrayList.
We should probably return an empty list here since it could be null.
Please consider the following case:'setItems(label)'
Please consider the following flow: 1. User should be able to reuse the'setItems(label)'
Please consider the following scenario: 1. The user of the'setItems(label)' is missing. 2. You know what value is, but you call'setItems(label)' explicitly.
this method is pretty inefficient, can it be fixed in a generic precondition?
this method is pretty inefficient, can we just do an + and log the exception?
this method is sync on L43
why not use a constant?
why not use assertEquals? Same for the other methods.
why not use assertEquals?
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_G_LABEL getDeviceIdG -> getDeviceIdE
SetSpecialDaysRequestIsReceived => E-meter
I think it's better to use inputWindow.get("sum") to do the trick.
I think it's better to use inputWindow.append("sum(sum)...
I think it's better to use inputWindow.get("sum") to do the conversion.
I think you want to make the dlInputs final by using a context.
I think you want to make the dlInputs final by using a context file in the exception message, since it's initially a translatable directory.
I think you want to make the dlInputs final by using a context file in the exception message, since it's initially a syntax error (NullPointerException below).
Why you use here "t_name=?"?
Why you use here static?
Why do you use t_name=? here?
We should put this in a helper class instead of a nested class.
We should put the map in a lazy block. I think it is a bit easier to understand what is happening here in the constructor.
We should put the map in a lazy block. I think it is a bit easier to understand what is happening here
Should this be an unmodifiable list? If so, it's not a big deal.
Could be package-private.
Could this be an unmodifiable list?
I would tend to have one method that returns a sequence object, calling it multiple times, once in the queue. This way it is easier to read and understand.
I would think it's cleaner if we reset sequence numbers here as well (or elsewhere) to have some logic to notify the notion of setting of a single sequence number. But that's not a blocker.
I would think it's cleaner if we reset sequence numbers here as well (or elsewhere) to have some logic to notify the notion of setting of a single sequence number. But that's not a a nice PR.
Minor: Would be good to reword this to match the existing code; in this case I wonder if it would be better to re-use the default constructor.
Minor: Would be good to reword this to be "Bump"
Minor: Would be good to reword this to be "Bump".
shouldn't this be realm.sharedRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.contains(BaseRealm.LISTENER_NOT_ALLOWED_ALLOWED_S);?
shouldn't this be realm.sharedRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.contains(BaseRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.getValue());?
shouldn't this be realm.sharedRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.contains(BaseRealm.LISTENER_NOT_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ALLOWED_ACTIONS.getValue());?
final
spaces around if and (
spaces around if and curly
doMerge() which is defined in the constructor instead of here?
do you need this check?
doMerge() which is defined in the class instead of here?
Why can't we use here <code>else if</code>?
Why it is the same as for container?
Why can't we use here <code>if</code>?
You're missing a check for containerName?
You're missing a check for the existence of the pipeline.
You're using StringUtils.isNotEmpty() here.
Would the new Path, FIles API be easier to use than the old File API?
Would the previous tests be easier to use than the old File API?
Would the new order be easier to use than the old File API?
Optional.ofNullable should be used instead.
Optional.ofNullable could be used here instead.
Optional.ofNullable could be used here instead of Optional.
DatabaseName and end of something else?
DatabaseName.get(nameBytes)?
DatabaseName.get(nameBytes)?)?
When isEmpty() is called, the 2nd line above will throw an NPE. You should also check mServiceConnection.getBindServiceConnection.
You should also check mServiceConnection is null before doing this.
When isEmpty() is called, the 2nd line above will throw an exception
You can just use Objects.hash() here
You can use Objects.hash() which simplifies this.
Can use Objects.hash()
Do we need to lazily create the spliterator here?
Do we need to lazily create the spliterator? Can't we have a difficulty interval of 1?
Do we need to lazily create the spliterator?
@Christopher-Chianelli I think it could be done in this class as well (or I'm not sure if it's a good idea). I think it could be done in just one command.
@Christopher-Chianelli I think it could be done in this class as well (or I'm not sure if it's a good idea). I think it could be done in a easier way than that. FormLayout is a list, so we could drop the fieldLayout variable.
@Christopher-Chianelli I think it could be done in this class as well (or I'm not sure if it's a good idea). I think it could be done in a easier way than that. FormLayout is a list.
Looks like there is a race condition here.
create a protected method in the interface which returns the existing configuration
create a protected method in the interface which returns the existing LibraryGenerator.
This should return an immutable set.
This should return an immutableSet.
This should be immutable and cached.
Can you make this file a constant?
Can you make this method private?
Missing @Override
Here too, let's use try-with-resources
Here too, public BufferedOutputStream(InputStream source, File dest) throws IOException {
Here too, let's use try-with-resources.
can we break this up?
can we break this up in the future?
can we break this up into multiple statements?
Done!
> else if
Done.
You can use a last argument for this method.
I don't think you need to change this, but think it should not be necessary.
I think a cast would be enough.
I would not use getDescription() if it is null or empty. I would just say Localization.lang("Removes all {} brackets around words", getDescription(), getDescription());
I would not use getDescription() if it is null or empty. I would just say Localization.lang("Removes all {} brackets around words") instead of getDescription right?
I would not use getDescription() if it is null or empty. I would just say getDescription() is not null.
Is this an output format?
Is there a reason to use a timestamp here?
Is this a debug statement?
It should be (Safer to use _cast_ instead of the cast.
It should be (didn't equal).
It should be (Safer to make it consistent with other classes): throw new RealmException("Could not map Json", e);
missing @since tag
You don't need to unwrap the original exception if you want to keep it.
You don't want to print the stack trace if you not just print it.
Why is this the ControllerFactory method?
Revert
Why is this the ControllerFactory now?
No need to use ConcurrentMap.
No need for else here.
No need for final here.
Should be this.mode = mode;
Should be a WARN.
Should be this.mode = mode instead of logging
I don't see why you would store strings in the cache, instead of doing a String.split(getJEP223) twice.
I don't see why you would store strings in the cache, instead of doing a String.split(null) at the beginning of the method, you wouldn't have to do that, once when you're done.
I don't see why you would store strings in the cache, instead of doing a String.split(null) at the beginning of the method, you wouldn't have to do that, once at the beginning of each method.
Suggest making this a static method in the class with many test classes (see line 61, 79).
Suggest making this a static method in the class with many test classes (see lines 61-79).
Unnecessary.
For consistency with the rest of the codebase, we should probably call the toString() method.
require a password?
require a password
Change this to String.format()?
Change this to String[] (not String)
Change this to String[] (not String[])
Why do we do this?
Why do we do this here?
Why do we do these tests?
should this return isReady instead?
should this return isReady()?
should this return true instead?
Should be "certificationRequestInfo" instead of "certificationRequestInfo"
The parameter type on a CertificationRequest is not a CertificationRequest. I think it should be a warn about the method name.
The parameter type on a CertificationRequest is not a CertificationRequest. I think it should be a warnwarn about the method name.
this.requirement.edfill(trace); don't have to be run in the same try/catch block
this 'null' is not needed.
this.requirement.edfill(trace); don't have to be run in the same try/catch block.
I would have expected that the name could be null here.
I would have expected the name to be null here.
please use isEmpty()
s/class/getName/
s/equals/equals/equals/
s/equals/equals/equals
why do you need to check for empty strings here?
why do you need to set it to empty if there is no url?
why do you need to set it to empty if it is not null?
You can remove private, and just use TimeUnit.MILLIS_PER_DAY
You can remove private, and just use TimeUnit.DAYS.toMillis()
You can remove private, and just use TimeUnit.DAYS.toMillis(LocalDate)
Can we add { } around this if statement?
Can we add a checkSelfScanningEnabled of persistence here?
Can we add {}?
should we use binaryType.isBinary(binaryType) here?
Should we use binaryType.isBinary(binaryType) here?
should we use binaryType.isBinaryType(binaryType) here?
Where is the name to MutateRowsRequest?
Where is the type being used?
Where is the size being set?
How about adding validation here like this: throw new RuntimeException("The oraclePS from v2 to v32");
How about adding validation here like this: throw new RuntimeException("The oraclePS from v2 to v6?");
How about adding validation here like this: throw new RuntimeException("The oraclePS from v2 to v6a");
Why not put it in an else block and call getVariable()?
Why not put the check for variable instanceof Integer?
Isn't it better to put the check for variable instanceof Integer
CompletionException would be better
What happens if it throws an exception?
CompletionException would be better.
make it final
ensure we have elements in the selectable elements?
ensure we have elements in the original Stream?
Please convert these to a logger.
Please convert these two logs into a logger.
Please convert these two logs into a LOG.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
Not sure whether worth doing, but since the only usage are "DownloadImageManager" (that is in the same package), it is possible to remove "public".
Not sure whether worth doing.
Unnecessary empty line.
Update to use a constant for the index
Unnecessary empty line
maybe this one should be a warn instead of a strong assertion on the message.
I think this one should be AssertionError instead of a custom exception.
maybe this one should be a warn instead of a strong assertion on the zero.
Could you move the check for the filename to be sure it is the last character?
Could you change the logic into private static final String charAt(String filename, String count)?
Please leave the duplicate check.
What about adding some string (didn't blank)?
What about throwing an exception here?
What about adding some string (didn't exists)?
Nitpicking: more efficient as indexOf('/')
Nitpick: more efficient as indexOf('/')
Nitpicking: more efficient as indexOf(""")
Should this be the diamond operator?
Should this be the throws?
Should this be 1?
This may be better named the variable "award" instead of award. That is not what you really want
This may be better named award, if there is noward, you really want award.
This may be better named the variable "award"
At this point where the code is detecting there is a problem, shouldn't it also be reporting specifics about the population that had the issue? IMHO, recording the identifiers of the items with the issue being checked for at the point where the problem happens. It hard to try to find that population or the conditions later on.
At this point where the code is detecting there is a problem, shouldn't it also be reporting specifics about the population that had the issue? IMHO, recording the identifiers of the classes with the issue being checked for at the point where the problem happens. It hard to try to find that population or the conditions later on.
At this point where the code is detecting there is a problem, shouldn't it also be reporting specifics about the population that had the issue? IMHO, recording the identifiers of the issue being checked for at the point where the problem happens. It hard to try to find that population or the conditions later on.
nit, this should be.jersey().register(new EmptyOptionalTo204ExceptionMapper());
nit: this should be.jersey().register(new EmptyOptionalTo204ExceptionMapper());
nit: this is unnecessary
source is not passed into this method, so it is pretty ugly. Instead you can make try { return df.get(msg); } catch (ParseException e) { DateFormat object = new RuntimeException(e); return df.parse(msg); }
source is not passed into this method, so it is pretty ugly. Instead you can make try { return df.get(msg); } catch (ParseException e) { DateFormat df = new RuntimeException(e); return df.parse(msg); }
source is not passed into this method, so it is pretty ugly. Instead you can make try { return df.get(msg); } catch (ParseException e) { DateFormat df.parse(e); return df.parse(e); }
should this be Float.BYTES?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true?
should this be Float.BYTES? I don't see the benefit of Float.BYTES being used in DoubleFirstAggregatorFactory.
Should use lower case for all of these
Should use lower case
Should use lower case notation
DEFAULT_LOADING_THROTTLE_LIMIT?
any clue on how this number was chosen? Is it an absolute or relative value? I think we should preserve the existing behavior by default so perhaps it doesn't matter which config is chosen which makes it harder to stop rebalancing.
any clue on how this number was chosen? Is it an absolute or relative value?
Minor: you can remove the redundant null check: if (getActivity()!= null) { permissionListener.requestPermissions(getActivity()).onPermissionGranted(); }
Minor: you can remove the this.
redundant null check
This is not enough. We will need to add other sub-velocity annotations if we are not doing this in the control.
This is not enough. We will need to add other sub-velocity annotations if we are not doing that.
This is not enough. We will need to add other sub-velocity annotations if we are not doing this in the view.
According to the code style, you can have a lot of code duplication between this and the new code in this file.
According to the code style, you can have a lot of code duplication between this and the new code.
According to the code style, you can just change this to be: long currentTime = lastCacheCleanupMillis;
Maybe we can use this to get the item stack and the current one to avoid having to loop through the itemstack?
Maybe we can extract this to a private method that will be called by each thread?
Maybe we can use this to get the item stack and the current one to avoid having to loop through the item stack?
what happens if there is no state stored? Might be worth throwing an exception here.
what happens if there is no state stored? Might be worth throwing an exception here?
what happens if there is no active state in the partition?
The 'if' statement covers this condition on the first line.
The 'if' statement above doesn't actually satisfy the condition.
The 'if' statement looks really nice for the reader.
I think you should close client after the restart.
I think you want to close client after the restart.
I think you want to close client after the restart?
Should this be the other way around?
Should this be the containerInfo's name?
Should this be the container id instead of the name?
nit: throw new IllegalStateException("entry content can be accessed only once");
nit: throw new UnsupportedOperationException("entry content can be accessed only once");
nit: move this line below the try
This can be package private, no?
Can we use ImmutableList.copyOf() here?
Doesn't need to be synchronized
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "ignore" to "ignired" Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "ignore" to "ignired" please.
I think it would be better if the same insert op would be in both cases.
I think the same code is in both the control and the external code.
I think it would be better if the same insert op would be in both sides of the same if statement.
This pattern looks strange to me. I'm sure it's not part of the PR, but maybe it's worth adding a check if it's really necessary as we don't use placeholders?
This pattern looks strange to me. I'm sure it's not part of the PR, but maybe it's worth adding a check if it's still present or not.
This pattern looks strange to me. Do we really need a new method?
To be safe, should check gerritTrigger.getTrigger()!= null first.
To be safe, should check gerritTrigger.isTrigger() here.
To be safe, should check gerritTrigger.isTrigger() first before the trigger.
I think any better to use RandomUtils.nextInt(300, "") instead of 2 here
I think this should be moved back to the previous implementation rather than in forecast and add a new Random(0)
I think this should be moved back to the previous implementation rather than in forecast and add a new RandomUtils
Is there any way we can move this line into the.transform?
Is there any way we can move this line into the.format? There are 3 places where you use a variable for this.
Is there any way we can move this line into the.format block for readability? You may want to move the variable refactoring.
Here try to use UriUtils.add(...).
Here try to use UriUtils.add(scheme, new String())
Here try to keep the else and only check whether the scheme is null.
Don't we want to log this as well?
Don't we have to load the property for this class?
Don't log and throw
log the tenant id and use it in log
log the tenant id and logging it
log the tenant id and log the exception
also check this
also check focusRequestCompat == null
just curious, why bother re-init?
Add Assert.notNull(replicate, "ReplicateTo must not be null");
Add assertion to make sure that the replicateTo is not null
Add final keyword.
we should have an effect here instead of the Variable, to avoid the cast.
we need to check here for the VariableVariables instance, not the variable itself.
we need to check here for the VariableVariables instance, not the variable directly
<LINK_0>
<LINK_0> That is the reason why you catch and rethrow as a general exception, so you should do something, if you wish. <LINK_1>
< should say what is the variable name; please.
This is very minor but is it possible to rearrange the code like this? try { layerOnMap.addLayerToMap(airMapGeoJsonLayer); } catch (JSONException e) { log.e(TAG, "Failed to add GeoJsonLayerGeoJsonLayerLayerLayerGeoJsonLayerLayerLayerLayerGeoJsonLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayer.getDefaultPolygonStyle().get(); }
This is very minor but is it possible to rearrange the code like this? try { layerOnMap.addLayerToMap(airMapGeoJsonLayer); } catch (JSONException e) { log.e(TAG, "Failed to add GeoJsonLayerGeoJsonLayerLayerLayerGeoJsonLayerLayerLayerLayerGeoJsonLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayer.getDefaultPolygonStyle().get(); }
This is very minor but is it possible to rearrange the code like this? try { layerOnMap.addLayerToMap(airMapGeoJsonLayer); } catch (JSONException e) { log.e(TAG, "Failed to add GeoJsonLayerGeoJsonLayerLayerLayerGeoJsonLayerLayerLayerLayerGeoJsonLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayerLayer.getDefaultPolygonStyle().get(); }
Shouldn't we handle InterruptedExceptions here?
what about catching RuntimeExceptions and rethrow them? It's a bit odd that this method throws Exception, isn't it?
Shouldn't we handle InterruptedExceptions here? Thread.currentThread().interrupt(); throw new RuntimeException(e);
rename to hashCode
rename to hashObjectId
rename to other
Maybe I'm a little bit confused by this change. It seems like a reasonable fact that it's incorrect, but how about a fact that it's an API of the class. WDYT?
Maybe I'm a little bit confused by this change. It seems like a reasonable fact that it's incorrect, but how about a change to some other logic instead of a hardcoded one.
Maybe I'm a little bit confused by this change. It seems like a reasonable fact that it's incorrect, but how about a fact that it's an API of the class. Is there a way to keep that?
Override
Override is missing on line above.
Override is missing on this line.
This has to be removed.
You might want to move this handler to a different field, so that it can be called only once.
You might want to move this handler to a different field, so those handler could use only one message.
Redundant cast.
Redundant newline
Redundant null check
Is the first line necessary? I think the second one should be the same.
Is the first line necessary? I think the second one should be the same, to match the first one.
Is the first line necessary? I think this can be removed.
nit: List<HiveSplit> splits = ImmutableList.builder(); while (iter.hasNext()) {.. }
nit: List<HiveSplit> splits = ImmutableList.builder(); for (HiveSplit entry : partitions) {.. } return splits;
nit: List<HiveSplit> splits = ImmutableList.builder(); for (HiveSplit entry : partitions) {.. }.collect(toImmutableList());
submit?
submit
submit method
can we use camel case?
can we use camel case exception?
can we use camel case for variables?
Segments: for (ChannelFuture listener : response).toString()?
Segments aren't really needed in the middle of the class.
Segments: for (ChannelFuture listener : response).toString()?
please add new HelpTag and HashName (as in StorageListModel)
please add new HelpTag and HashName (as in StorageListModel), as well as in StorageListModel.
please add new HelpTag and HashConstants (as in StorageListModel)
suggestion processInstanceIds.forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> { You dont need to use.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds));
suggestion processInstanceIds.forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> { You dont need to use.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId -> abortProcessInstance.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceIds)); }
suggestion processInstanceIds.forEach(processInstanceId -> { You dont need to use _.stream_ to access _filter_
This should check to make sure that notificationUUID is not null before attempting to delete it.
This should check to make sure that notificationUUID is not null before attempting to get it.
This should check to make sure that notificationUUID is not null before attempting toreference it.
Use Arrays.copyOf() or Arrays.copyOf with the varargs signature.
Use Arrays.copyOf() or Arrays.copyOf()
Use Arrays.copyOf() or Arrays.copyOf()?
Wouldn't it be better not to have a build for this? It is a side effect for the config (i.e. BATCH_SIE_OPT).
Wouldn't it be better not to have a build for this? It is a side effect for the config (i.e. BATCH_SIE_LIMIT_MS )
Wouldn't it be better not to have a config in buildComputation as we do for the batch?
Per IRL, I meant to say uploadApi is fine here. This is fine too, but unrelated.
Per IRL, I meant to say uploadApi is motivated, but unrelated.
Per IRL, I meant to say uploadApi is motivated, but unrelated. I do not think there is a reason to keep that?
This is not really needed, either change the old name to something like cleanupHeadless()
I'd suggest to make this package-private (it can be removed from the class, but the tests aren't refinement): <LINK_0>
I'd suggest to make this package-private (it can be removed from the class, but the other way around) this one can be removed.
Please use Objects.requireNonNull(ignored) to include messages.
Please use Objects.requireNonNull(ignored) to reduce duplicate code
Please use Objects.requireNonNull(ignored) to keep this check
don't need this
use try-with-resources
don't need this, use URI instead
I have two questions here: 1) the index is the NON-NLS but it will start failing on non-rom that's not what we want to do here. 2) What do you think about this?
I have two questions here: 1) the index is the NON-NLS but it will start failing on non-rom that's not what you want to do here. 2) What do you think about this?
I have two questions here: 1) the index is the NON-NLS but it will start failing on non-rom that's not what we want to do here. 2) What do you think about it?
This is fine but it is better to use the original code here
This is fine but it is better to use the default case here
This is fine but it is better to use a string resource
A test will be nice
I would return an InvalidArgumentException or IOException
should it be thrown?
this.config = ImmutableList.of();
Minor: copy-paste error message?
Minor: copy
[Checkstyle] INFO: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/com/wikia/webdriver/common/core/java/com/wikia/plugin/java/com/wikia/webdriver/common/core/url/UrlBuilder.java:[lang.String,boolean]  [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats/gpl/src/main/java/com/wikia/webdriver/common/core/java/com/wikia/plugin/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L1L_java#L1
[Checkstyle] INFO: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/com/wikia/webdriver/common/core/java/com/wikia/plugin/java/com/wikia/webdriver/common/core/url/UrlBuilder.java:[lang.String,boolean]
[Checkstyle] INFO: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/com/wikia/webdriver/common/core/java/com/wikia/plugin/java/com/wikia/webdriver/common/core/java/com/wikia/java/dialog/FeedListeners/ReaderClient#java
Unreachable statement?
You might want to use MathUtils.min here.
The data is unused in this method.
Static import
You can replace this if (checkNotNullOrEmpty(attributeValue, attributeType)) { with the same logic
Why did you not do this on the previous line?
This seems to be returning an Optional<Integer> instead of a String. Is that what we want?
This seems to be returning an Optional<Integer> instead of a String...
This seems to be returning a long default value for a few minutes?
The message needs to be the full path.
The message needs to be the full name.
The message needs to be the full word.
Can we make this into a constant called Version_Field_Sizes_In_Bytes?
Can we make this into a constant variable? I think it'd be good to have a descriptive name.
I think we should have a bounds check here instead of <=.
can use Collections.emptyMap()
this can be initialized with Collections.emptyMap().
this can use Collections.emptyMap()
Why did you remove the logging?
Why did you add 'for'?
Why did you add 'for' instead of '?
Should we wrap this method with an IDisposeEvent()?
Should we wrap this method with an IDisposeEventdispose()?
Should we wrap this method with an IDisposed()?
suggestion if (this.fuseDuration()!= null) {
suggestion vanillaValues.add(this.fuseDuration());
suggestion if (this.fuseDuration == null) {
Could you please use TIME_FORMAT instead of "HH:mm:ss"
Could you add a check for getInputBind() here? just to make sure the config works.
Could you add a check for getInputBind() here? just to make sure the config knows.
Curious why this is not a literal here
Curious why this is not a literal here...
Curious why we need to set the match algorithm here
Minor - unnecessary use of addAll
Minor - unnecessary added synchronized
Minor - unnecessary added synchronized suggestion
suggest this.public SketchMergeAggregatorFactory()
suggest this too.
suggest this.
return INSTANCE_SIE
return INSTANCE_SIE here
should it static?
No need to use UriBuilder
No need to use UriUtils.convert()
Use formParam() instead
You can use remove() as it does not remove the entry
You can use remove() as well.
You can use remove() as it does not remove the entry.
Do we need to handle the exception here?
Do we need to handle the leaderListener here?
Do we need to handle the interrupt here?
The exception doesn't seem to be the expected exception. Why not use assertThatIllegalArgumentException?
The exception doesn't seem to be the expected value. Why not use something like this?
The exception doesn't seem to be the expected exception. Why not use the same message?
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
you can return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
you can initialize image to empty list and keep the null check on getPermissionCheckSubjects()
Are you sure that refreshJob is always called when it's first in the tree?
Are you sure that refreshJob is never null?
Are you sure this is always called when the job is never cancelled?
Ternary
isEmpty
isEmpty is redundant
nit: s/this.wentactive/borrowed
nit: s/this/wpnRunner/
nit: s/this/wpnRunner/b/
This is why I don't like Iterable ;)
This is why I don't like Iterable :(
why public?
Style-nit: No reason to add final.
Style-nit: No reason to add else.
Redundant else.
This is not the best way to test this
This is not the job of the test. This is useful to have the field with the old field set.
This is not the job of this test. This is useful to have protected and Non-default constructor.
dismissNotification(notificationInformation) is called twice
dismissNotification(notificationInformation) is unnecessary here
dismissNotification(...) can be false
same remark, here, this check should be moved to a new method with "TypeMirrors.realm".
This check is not needed, as in the case of nested typeMirror /foo are the same
same remark, here, this check should be moved to a new method
if (options == null) { options = new CosmosItemRequestOptions(); } if (partitionKey!= null) { ModelBridgeInternal.setPartitionKey(options, partitionKey); } return withContext(item, requestOptions, partitionKey);
if (options == null) { options = new CosmosItemRequestOptions(); } if (partitionKey == null) { ModelBridgeInternal.setPartitionKey(options, partitionKey); } return withContext(item, requestOptions, partitionKey);
suggestion ModelBridgeInternal.setPartitionKey(options, partitionKey, CosmosItemRequestOptions options);
- [x] What about creating a list of results to be passed to a method here instead of having this list available?
- [x] What about creating a list of results to be passed to a method here instead of having a list and set it inside?
- [ ] We should probably refactor so that "checkstyle3.xml" is not available
having wallClock = 4 for sure to split this test as well
having wallClock = 4 for sure?
having wallClock = 4 for sure to split this up
Because there is only one argument, we can pass workerMetrics instead of an object array.
Because there is only one argument, we can pass workerMetrics instead of an array.
Because there is only one argument, we can pass workerMetrics instead of an empty string.
Minor suggestion: Are we missing a Fodacy check here for isEmpty() checks?
Minor suggestion: Are we missing a Fodacy check here for isEmpty() check?
Minor suggestion: Are we missing a FATE BS: Missing changes?
Please put "everyone" on the next line and use "norm".
Please put "251" into constants
Please put "everyone" in a constant
Codacy complains here: don't prefer to use +
Codacy complains here: <LINK_0> Can you use a constant?
Codacy complains here: <LINK_0> Can you use Codacy code?
Can you use 0.0 and 1.0 instead of 0.0?
Can you use 0.0 and 1.0 for consistency?
Can you use 0.0 and 1.0 instead of 0.0 here?
You can return an empty string instead of null.
You can return an empty list instead of null.
You can return directly.
From my point of view, wouldn't a pattern end be tripPattern always first and then the tripPattern to add to the tripPattern if possible? It could be also good to avoid the tripPattern if possible.
From my point of view, wouldn't a pattern end be tripPattern always first and then the tripPattern to add to the tripPattern if possible? It could be also good to make patternsForStop.
From my point of view, wouldn't a pattern end be tripPattern always first and then the tripPattern to add to the tripPattern if possible? It could be also good to make patternsForStop.contains(stop, tripPattern) a constant if tripPattern is null.
Since we only need the getType() in the registry, this can be replaced with: java return getType().toString();
Since we only need the getType() in the registry, this can be replaced with: java return "name".toString();
Since we only need the getType() in the registry, this can be replaced with: java return getName().toString();
Please make sure that ApplicationMode is set to a different data for all users.
u need to setSucceeded(true)
please make sure you set the data in ApplicationMode before calling this method.
@dmzaytsev This method is copied only once. Please extract it to a method.
@dmzaytsev This method is copied only once. Please move it to a method.
@dmzaytsev This method is copied only once. Please extract it to a variable.
Missing space before brackets.
Missing space after if
Missing space after if.
This needs to be protected.
This needs to be protected, not public.
This needs to be protected, as well.
here we should use if (decisionTableHasEditableColumns)
ifdecisionTableHasEditableColumns is called, the selectedColumns is cleared and called twice.
ifdecisionTableHasEditableColumns is called and this code is called, the selectedColumnsPage will be null.
you can use Objects.equals() here
you can use Objects.equals()
you meant to use equals here, when comparing enums.
EmptyActionInput()?
suggestion () -> null;
suggestion () -> null, null, value);
Why is this needed?
Why is this necessary?
Why is this returning a copy of collection?
You should be able to move this test to createEncounterParameters and have it just call the method
You should be able to move this test to createEncounterParameters and have it just create createEncounterUuid
A check on encounter is optional
I don't think we need this condition. It seems like if we have more than one entry, we can just say "This entry is not published."
I don't think we need this condition. It seems like if we have more than one entry, we can just say "This entry is not published"
I don't think we need this condition. It seems like if we have more than one entry, we should be able to modify the entry code.
Is it worth logging if value is not negative?
Is it worth logging if we have the same value?
return value;
Duplicate in both createSubject and createSubject methods. Consider to refactoring into helper method.
Duplicate in both createSubject and createSubject methods. Consider to refactoring into existing method.
Duplicated code please update
Shouldn't this be a field so we don't have to create one each time
Shouldn't be a field so we don't have to create one each time
Shouldn't this be a field so we don't have a create one each time
On START_DATE, the discount factor for start date should be 1.
On STARTS, the discount factor for start date should be 1.
On START_DATE, the discount factor for start date should be 2.
Can't we use stream() with values()?
Can't we use Arrays.stream(queueNames) instead of do a null check?
Can't we use Arrays.stream(queueNames) instead of stream()?
Is this necessary?
Is this necessary for a configuration change?
Is this necessary for the reload event?
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
minor suggestion: it is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
minor suggestion: It is perhaps simpler to set a local variable for storing a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
can you split the string to a constant?
can you split out the deployComponent and getMojoState() from the Mojo case?
can you split out the deployComponent and get rid of the method?
Did you intend to leave this log call as info?
Did you intend to leave this as info?
Did you intend to leave this log call as the logger method?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
Would be awesome to rename it to something more descriptive like "DiscussionsPostViewContainsOnPost d"
Would be awesome to rename it to something more descriptive like "DiscussionsPostViewContainsOnPostSzl"
This expects a localization key.
Magic number.
Magic number
please remove redundant this.
you can use the static method and remove the class
please remove
Could we have a static variable all the time?
Could we have a static variable, to be consistent with the rest?
Could we have a static variable that can be used?
could you change the order of separators?
could you change this to separators?
Should be separators
> backups should be replaced with Collections.singletonList(backups)
Configuration should be immutable, as well.
> backups should be replaced with Collections.singletonList(backups).
Should be final
Should be a field.
Should be better to use Visibility.SpoutVisibility.
Same here, this is obsolete
Same here, this is a copy-paste and should be removed
Same here, this is a public method and should be removed
Typo?
can we put this out of the loop?
can we put this out of the for loop?
FIXME: This crashes.
Can we put this back to the activity lifecycle by making the menu item finish?
FIXME: Crash here if the user didn't call finish, right?
@jagill Is this the intention? What happens if we we use lz4Decompressor here?
@jagill Is this the intention? What happens if the L4Decompressor's not the newest?
@jagill Is this the intention?
Math.out
Maybe change to printTime(fromStart), similar to the change below?
Int.
Please use StringBuilder instead of substring.
value can be just a no-op
Please use ParameterUtils
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the connection has been established.
I would simplify to return (true) && activeNetwork.isConnected() && activeNetwork.isConnected();
rename to PercentageBasedSamplers
rename to PercentageBasedSamplerList
rename to distance
Needs to be in finally
Needs to be synchronized
warn?
I think the 2nd param should be set to the exception as well, otherwise the method will not get called.
I think the 2nd param should be set to the exception as well, otherwise the method will not be called.
I think the logic for checking file is wrong here, because CMProbeStat.fromType(path) will not throw an exception is a SCMProbeStat
I think it should be initialized inside the constructor.
there is no need to throw NoSuchElementException
I would throw NoSuchElementException instead of returning null.
WikipediaApp.getInstance() unnecessary?
WikipediaApp.getInstance() can be null.
WikipediaApp.getApplication() can be null
Though I can't see it's named "devel".equals(DOTCDK_AUTH_PASS) is used here, is this correct?
Though I can't see it's named "devel"?
Though I can't see it's named "devel".equals(name)?
I think it's better to use the ModelUtil.checkConnection(getContext()) here.
I think it's better to use the ModelUtil.checkConnection() pattern.
It may be better to use switch-case.
Maybe diving to deep into the state object?
Maybe diving to deep into the state declaration and then fluent?
Maybe diving to deep into the state declaration and then use it consistently?
Is this test superfluous? The test seems to pass even if properties is empty, so it will just skip the test.
Is this test superfluous? The test seems to pass even if properties is empty, so it will just skip the test if it's not null.
Is this test superfluous? The test seems to pass even if properties is empty, so it wouldn't be an empty map.
suggestion LOGGER.log(Level.FINE, "Rejects not supported under pool");??
suggestion LOGGER.log(Level.FINE, "Rejects not supported on stack: {}", message);
suggestion LOGGER.log(Level.FINE, "Rejects not supported on stack");??
Better to do it only when name.trim() here?
Better to do this method here too.
Better to do it only when name.trim() here.
Should we provide a function for this?
Should we provide a max value for this?
Should we provide a max value for TTL here?
Safer to keep consistent
Safer to add more Action name.
Unnecessary switch statement.
make it final?
naming: totalRefCount
Is this hashing algorithm needed?
rename to launchManager
rename to launchNs
rename to launch/dispose
Code conventions: please use File.separator instead of +
Code conventions: please use File.separator instead of "/"
Code conventions: please use curly braces and the closing space after the opening {
Do we actually call init multiple times on the same thread? Just asking.
Do we actually call init multiple times on a thread? Just curious.
Do we actually call init multiple times on a trace or is it a safe-guard?
This should be switched back to info.
This should be switched
This should be switched.
I see that this method is also used in other files, so changing the visibility of the method may affect other tests
I see that this method is also used in other files, so changing the visibility of the method should be changed to protected
Access suggestion return new getAccessToken().getPlainText();
Change the return value to an IConfiguration
Change the return type to IConfiguration instead.
Change the return value to an enum
keep the static imports
keep the static code style
keep the static code readable
The OutputStream output = new OutputStream(output.getInstrumentation().mark(length); should be inside of try-with-resources.
The OutputStream output = new OutputStream(output.read(buffer));... And then finally throw an exception....
The OutputStream output should probably be closed after this.
Should just use new HashMap<>() here
Slightly more readable with a variable name that describes what it is.
Slightly more readable with a variable named MarketHistory
Object[] sourceSaveables = new HashSet<>();
Case insensitive form is honored as a constant.
Case insensitive form is honored as part of the 'public'.
What you're trying to achieve here?
What you should do?
What about to do you catch here?
System.out.println should be removed.
System.out.println should be removed
System.out.println
Let's use PojoStackTraceWriter to make it more readable.
Let's not use PojoStackTraceWriter to make it more readable.
Let's not use PojoStackTraceWriter to make it more readable. We can use it in testIdentifier.
static
final
static?
FYI: using a map here would have given us:.map(Map<String, String>::block)
FYI: using a map here would have given us:.map(Map.Entry::block)
FYI: using a map here would have given us:.map(Map<String, String>).block())
Should it be 2000?
This is problematic, the test is trying to track that and not the other one.
This can be protected.
You can use Objects.hashCode(this.logEntry) here.
You can use Objects.hashCode(this.logEntry, o).
You can use Objects.hashCode(this.logEntry) here
hmmm, let's discuss the idea behind it. The previous version of this PR is to clean up a lot.
hmmm, let's keep it as it was without try/catch
hmmm, let's discuss the idea behind it. The previous version of this PR is to introduce a new method cleanup(path, mode, false) that would let the if do the logic.
please change to private
please have the throws
please have the @Test annotation here.
Should we check if this.metricsLabel!= null? metricsLabel.get(currentMode) : null;
Should we check if this.metricsModes.isEmpty()?
Should this be following the same as in line 72?
Could be replaced with: java throw new java.util.Objects.requireNonNull(p.getDeletionViewPortlet().join());
Could be replaced with: java throw new java.util.Objects.requireNonNull(p.getDeletionViewPortlet().class);
Could be replaced with: java throw new UnsupportedOperationException(" portlets > portlets;");
couldn't you do this in the model.getName()?
couldn't you do this with vm.getName()?
Where do you do that?
Likewise.
Likewise. Don't need the cast.
Likewise..
Looks like this method is missing this
Looks like this should be if ( task == null) {
Looks like this
Could you please describe what has changed since the duplicate line looks a bit long?
Could you please describe what has changed since the duplicate line looks a bit long.
Could you please describe what does this action works?
I don't understand why not use modifiers.findFirstToken(TokenTypes.FINAL) here. This method can be simplified, as well, as in anyMatch.
I don't understand why not use modifiers.findFirstToken(TokenTypes.FINAL) here. This method can be simplified, as well
I don't understand why not use modifiers.findFirstToken(TokenTypes.FINAL) here. This method can be simplified, as well, as in anyMatch. Also, it's a little hard simplification.
This change is not necessary.
This change looks unrelated to this patch.
This change makes no sense.
This is a read-only operation but there's no reason to choose/read the metadata state again if you call sync.
This is a read-only operation but it does not read as expected. I assume you want to read the whole Kafka but not the read/write of all other fields.
This is a read-only operation but it does not read as expected. I assume you want to read the whole Kafka but not the read/write of all the metrics.
This method should be static.
This method should be static
This method should throw IllegalArgumentException unless it's an internal exception.
"-%d" is used for http events.
"-%d" is a bit weird.
"-%d" is used for http events. Can we have a constant for "NONE"?
empty point in time?
in size - 1?
final
return attachable == null? null : attachable;
return attachable!= null && attachable.get()
return attachable == null && attachable.get()
why not use the field directly?
No, this is why it is necessary?
why not use the local variable / fEvent itself?
Shouldn't this be onBackpressureBuffer()?
I don't think this is needed.
I don't think this is needed. onBackpressureBuffer() is needed since you're using a subscribe() method.
nodeID could be null
nodeID shouldn't be null
nodeID shouldn't it be null?
I'd rather go with public getInstance() { return getDialect(Adaptor.class); }
I'd rather go with public DialectNamingNamingNamingNamingNamings we use the constructors above.
no need for the this.
error level could be considered as a bad practice.
stop() is better, as you did with the change
trace or debug?
Could you refactor this to something like this?
Please add this to the handlerClass.
Could you add this to the handlerClass.
Use StandardCharsets.UTF_8 instead of a string literal
Use StandardCharsets.UTF_8 instead
Use StandardCharsets.UTF_8
The test is wrong, we should use the Mockito.mock method without a public method.
The /static methods are not part of the package-private class, they should be removed.
The test is wrong, we should use the Mockito.mock method without the context.
I think this should be RECORD_CLOSE_PROVIDER_CLOSE or something like that.
I think this should be TRACK_CLOSE_PROVIDER_CLOSE or something like that.
I think this should be TRACK_CLOSE_PROVIDER_CLOSE or ERROR
would be nice if this :) I mean that the handler is only implemented once, right?
would be nice if this :) I mean that the handler is only implemented once right?
would be nice if this :) I mean that the handler is only implemented once.
Please make a copy of the header in the map, just use the one in the map.
Please make a copy of the header in the map, to not use it.
Please make a copy of the header in the map, just use the provided headers directly.
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you?
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. If you want to verify that we can throw an exception, then the test should be fine.
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. If you want to verify that we can throw an exception, then the test should have a failed test.
Shouldn't this be return IronSource.isRewardedVideo() || isReady()?
Shouldn't this be return IronSource.isRewardedVideo() || showVideo() == 0);?
Shouldn't you call isVideoAvailable() instead?
How about setupTestUsers?
How about testDirectory and testDirectory?
How about setupTestUsers? Is there any test related to these?
Again, should this be an System.out.println?
Need to make this System.out.println(...) call.
Need to make this System.out.println(...) call. Otherwise, it's hard to see what happened if it is in the future.
@nvazquez you have a util method, not a raw implementation. Please use the assert keyword here.
@nvazquez you have a util method, not a raw implementation. Please use a for the assert, same below
I am not sure why you need this variable.
In this case, you don't need the null check, the method can be removed.
In this case, you can remove the null check, and this one can be removed.
In this case, you don't need to perform the null check, the method can be removed.
same question as before
same thing as before
same thing about this.
Consider writing java getView().setName(name);
Consider writing: java getView().setName(name);
Consider to use Java8's ErrorToStringHelper.
If the categoryIdentifier is already defined, do you need to check again?
if (public String) { I would use String.format() }
if (public String) {
Same here, could this be moved to the top?
Same here, could this be replaced by computeIfAbsent?
Maybe we could move this to a Utils method?
Can this be simplified to: if (value instanceof Number) { return (ByteBuffer) value; }
Can this be simplified to: if (value instanceof Number) { return (this.value > 0); }
Can this be simplified into a call to ByteBuffer byteBuffer?
I don't understand what this means, even if the component was added in the constructor, we will try to get logged in the constructor. How am I wrong?
I don't understand this. Why was the first argument removed?
I don't understand what this means, even if the component was added in the constructor, we will try to get logged in the constructor. How about just let the exception be thrown?
Instead of a hack like this, maybe we need (or have) an "update()" or "refresh()" method somewhere that could be called to do this kind of thing, since it might be useful elsewhere, and it would be good to have it centralized and standardized.
Instead of a hack like this, maybe we need (or have) an "update()" or "refreshConvisualizerInstanceId"?
Instead of a null check, probably worth moving this line into the initialize() method
Should this method just throw IllegalArgumentException? Same for other createTopic().
Should this method just throw IllegalArgumentException? Same for other places.
Should this method just throw IllegalArgumentException?
Can this be moved to a private method?
Can this lambda be moved to a private method?
Can this be moved to a method in the interface?
Missing the part of shuffling...
Can we part of shuffling the order is type of the order?
part of shuffling...
Do not create the path in the test. Just create the directory with test repo and remove it in the test.
Do not create the path in this test. Just pass it to the previous test.
Do not create the path in this test. Just pass it directly to the method.
This isn't thread safe. If we're trying to use one of the text that'ss thread-safe, we should make the chart final.
This isn't thread safe. If we're trying to use it anywhere, we're trying to use one of the text that's leaks.
This isn't thread safe. If we're trying to use it anywhere, we're trying to use one of the text that's leaks. Can we make the output of the input size final?
CompletableFuture.any() will be invoked on the main thread, thus we really don't need to do it here.
You can do the future: try { zk.abort(); } finally { super.abort(); }
CompletableFuture.any() will be invoked on the main thread, thus we really don't need to call it twice.
given/ execute/ assert
This step is not necessary.
This key is not used.
You can add a bit more information here, e.g. number of entries...
You can add a bit more information here. And it doesn't matter much.
You can add an ExecutorService as well.
Can you make this an array or split out of bounds?
Can you make this an array as final and use at the beginning of write?
Can you make this an interface?
nit: can you add a config flag in the constructor for this purpose, since null would be consistent with the rest of the thrift methods.
nit: can you add a config flag in the constructor for this purpose, since null would be consistent with other parameters where it's used?
nit: can you add a config flag in the constructor for this purpose, since null would be consistent with the rest of the thrift docs (also I think)
I think you want to add this check: <LINK_0>
By convention, you use 'fetch' instead of 'fetch'. It makes the code shorter and more readable.
By convention, you use 'fetch' instead of 'fetch'. It makes the code shorter and easier to understand.
Add this back
Add those 2
Add this back to Long.
Why have you removed this?
Why wrote this in your test? I'd rather have it be easier to read/understandable if you don't use TestDatasetStream.
Why wrote this in your test?
Why do we need to use ref here?
Why do we need to use ref here? Is it even possible to use rename?
What is the purpose of this change?
yeah, we can drop the this static in that case now. I think its a good idea.
yeah, we can drop this static here, but just use the other 2 exposed elsewhere
yeah, we can drop the this static in that case now.
Should only be checking if the format is null.
Should only be checking if the format is not null.
This does not print the arguments.
This should probably be fileId, and not name.
This should probably be fileId, and not name of it.
This should probably be fileId, and not name
Can this be package-private?
Can this be package-private and not public?
Can this be package-private and not private?
I believe the null check is not necessary here, the filtered value is an empty list.
It would be better to invert the if statement so that the collection is visible on one line.
It would be better to invert the if statement so that the collection is not set.
Unsure if this method is called on every single mutedTopics.
Unsure if this method is called in other places, or is it a helper method?
Unsure if this method is called on every single mutedTopics. I think we should just put the regex there.
Can be replaced by: return!knownConstants.contains(argument.getColumn())
Can drop the "else" here since it's more readable.
Can drop the "else" now be removed?
instanceof Dataset is redundant
rather call view.get(KITE_PARTITION_DIR, view.getType())
rather call view.get(KITE_DIR) instead of view.get().getLocation()
>80 chars
needs a space before the comma
needs a check
Great! I think this will work with IPv6 addresses though.
Why extract to a constant?
Great!
And use stream instead of collect() on the stream?
And use stream instead of stream.
And use stream id here
Should be compared using SystemTimeIn
Should be done as return setTimeTimeIn
Should be done as a HashSet
Should we not just pass null here?
We should probably just pass null here as the third argument.
We should probably just pass the cosmosCollectionLink, here and everywhere else inazureMetrics.
minor nit: this could be initialized to null.
same question
same question.
Can be: if (oldRevision == null)
Can be: if (oldRevision == null) { return; }
Can be checkState statement
Should we use org.apache.kafka.common.utils.Utils.closeQuietly?
Should you use org.apache.kafka.common.utils.Utils.closeQuietly?
Should we use closeQuietly?
Don't need to use builder.build();
Don't need to use builder.build()
Do we need to use static import?
RTPConnectorInputStream is not thread-safe
RTPConnectorInputStream doesn't have a good name for this
RTPConnector
rename to pack
rename to ws
rename to i
Is there a reason to keep this "if" block of code in a private method? This might be a personal preference though.
Is there a reason to keep this "if" block of code in a private method? This way the user could only get the app name from the app, right?
Is there a reason to keep this "if" block of code in a private method? This way the user could only get the app name if they are available for the update message.
nit: it's probably easier to read if it were a single return statement
nit: it's probably easier to read if it were a single if statement.
nit: it's probably easier to read if it were a single if block.
This is a bug. You should check that the storage service is not null.
This is a bug. You should check that the storage service is not null and throw an exception if it's null.
This is a wrong check, you should be able to call getClass() on short text.
The Exception is never thrown.
The Exception is never thrown. Please don't use AssertException.
The MessagingException can be removed.
I don't think it should be public.
I would say it should be fine to make the copy internally instead of the dataResolver.
I don't think it would make sense to have a copy of the contentResolver here.
UnsupportedOperationException seems like a better fit to me.
UnsupportedOperationException seems like a better fit to me
Why not throwing an exception here?
Shouldn't this be "relativeTarget" instead?
Shouldn't this be an assert not null?
Shouldn't this be "relativeTarget" or something?
You may also want a test case for a search value that is non-blank but invalid.
You may also want a test case for a search value which is non-blank but invalid.
You may also want a test case for a search value that is nonday of109909
You can use this method.
You can use this method instead.
You can use Paths.get(commonCacheConfig.getCacheDirectory(), crs.getCacheDirectory(), userMapBytes);.
is this needed?
this is not needed
This is not needed
These should all be PopulateDB.
These fields should not be empty at this point, as they should not be empty
These fields should not be empty at this point, as they should not be deleted
I don't think we should log here but throw an RuntimeException - we'll be vulnerable to a race condition
I don't think we should log here but throw an RuntimeException - we'll be vulnerable to a race condition, and a RuntimeException here if an RuntimeException occurs.
log an error?
is the same as the previous one?
is the same as the previous step?
is the default value specified?
I see another SWT.Selection between MouseDown and MouseDouble2
I see that you remove the timing schedule, but I'm not sure that's a real bug here. It's probably better to remove the SWT.MouseUp. They aren't normally sent when you only select the first item.
I see that you remove the timing schedule, but I'm not sure that's a real bug here. It's probably better to remove the SWT.MouseUp. They aren't normally sent when it is in the correct order.
The MathUtils.nextDouble() is null, should we check for that?
The MathUtils will handle this row red
The MathUtils will handle this
I am not sure we want to allow the listener in this case, or maybe make the method private?
I am not sure we want to hold this into the ITmfFormsViewContext class, which could have the full ViewModels
I would wrap in a Function<IT>.
Actually, I'm not sure how this code is required. You can create a copy of the ConfigurationMetadata and put this stuff in dybeanConfig.
Actually, I'm not sure how much this will work. Do we need to separate configs and call this TC and toString? CandybeanConfig just get the value?
Actually, I'm not sure how much this will work. Do we need to separate configs and call this TC? CandybeanConfig just get the value?
super.cleanup() should be in the same line of code.
super.cleanup() should be on the same line.
super.cleanup()?
Remove the public modifier.
can be inlined in class
make final
ditto
ditto, remove this
This is wrong
Class.shutdown()?
Class.shutdown() too?
Class<?>
Can we inline the variable name of the test to carbonTransport and call this method on the static method?
Can we inline the variable name of the test to carbonTransport and call this method on the return value?
Can we rename the variable name of the test to carbonTransport and call this method on the return value?
Why not move the close to the finally block?
Why not do the close() here to ensure the stream is closed?
Why not do the close() here to ensure the stream is never closed?
The same is here, let's use Objects.requireNonNull(tailSupplier, "tailSupplier is null");
The Objects.requireNonNull(tailSupplier, "tailSupplier is null");
The Objects.requireNonNull(tailSupplier, "tailSupplier cannot be null");
I think we should encode the message as a constant for the message.
I think we should encode the message as a constant for the author.
I think we should keep the message in the collector and store it in the message.
rename to elementLeft?
rename to occurrence
rename to elementLeft
I think we could keep the copy and populate in init() method.
I think we could keep the copy and populate in init() method. WDYT?
I think we could avoid an empty copy and put the List#init method in AbstractData class.
Shall we update getManifestConfig to the Config class instead of doing this?
Shall we update getManifestConfig to the Config class and have a method with the configs?
Shall we update getManifestConfig to the buildGlobalConfig method?
please check if random value is not defined
please check if randomboo is available
please check if random value is set to 2boo
This needs an @Override annotation.
This should be in a simplification of the method, not the code.
style nit: s/if(/if (/
@Override?
@override?
@inverno This?
Nitpick: startingCounter?
@dalifreire why we are changing the debug log here? Is it a bug fix?
@dalifreire why we are changing the debug log here? Is it a behaviour change?
Please don't use curly braces around single line blocks
Why not private?
Please don't have curly braces around single line blocks
Log statement here too.
EpdqParameterBuilder.extract()
drop this redundant else
Why it can't SUCCESS?
Why all the result go here?
Why result is NULL?
This is a build() call, so this can be removed.
This is a build() call, so this can fail.
This is a build() call, so this can throw.
should we also assert that content!= null?
should we also use assertEmpty for these?
should we also show the content or disposed?
can we use super(name, super(name, super(name)); so we don't have to do this each time the class is called.
can we use super(name, super(name, super(name)); so we don't have to do this each time it's called.
why use super()?
I guess we normally try to avoid exposing type here. For now, I would prefer to keep it for consistency.
I guess we don't need to keep this method public, since we only use it for subclasses.
I guess we don't need to keep this method public, right?
Use { } please :)
Use <LINK_0>
Use <LINK_0> <LINK_1>
This should be an assertion message.
Can we use an assertion message?
...
nitpick; could we just use site.getMySite() here to keep the same block of code.
nitpick; could we just use site.getMySite() here?
nitpick; could we just use site.getMySite() here to keep the same code.
why this cast?
why this cast again?
I think you should put this in a local variable.
Is this the right place to set the class? It seems like this could be a bug.
Is this the right name for the connector? It seems like it should be the only class name.
Is this the right interface for the connectorKind? It seems like this should have a static method.
UserAccount can't we pass in null for the UserAccount and we should create a new object to get the cache to UserAccount and decide to keep the old data in UserAccount and we should create a new object to get the UserAccount and then call to getUserAccount and we should create a new object to obtain the repository data: UserAccount getCurrentUser().set(newUserAccount(account.get(), null)));
UserAccount can't we pass in null for the UserAccount and we should create a new object to get the cache to UserAccount and decide to keep the old data in UserAccount and we should create a new object to get the UserAccount and then call to getUserAccount and we should create a new object to obtain the repository data: UserAccount getCurrentUser().set(null); if then we should call repository.set(null);
UserAccount can't we pass in null for the UserAccount and we should create a new Account?
Same here. In the PR, shall we make this a debug statement?
Same here. Can you include a check for container idMapping, or something along those lines?
Can you include a message in the log statement? In the case where processorIdMapping is null, we will get a NPE.
Should we use the iterator [Iterator](<LINK_0> here?
Should we use the iterator [Iterator](<LINK_0> to make sense?
Should we use the iterator here? It makes sense to use iterator in the context of each iteration.
@keyStorePassword should be used here.
@keyStorePassword should be used here. You can use try-with-resources
We can remove this.
This method does not do as it's named...
run() will never be called if the element is empty.
run() does not do anything.
What is this mock doing? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you need to test this
What is this mock doing? This way we will test filtering. In ACUnitTestBase you have method to test this
What is this mock doing? This way we will test filtering. In ACUnitTestBase you have method to test this.
can we move this to the method?
can we move this into the method?
can we move this to the method reload() method?
Boolean.valueOf( Preference.APPLICATION_SCOPE.toString()).toString() is not needed.
Boolean.valueOf( Preference.APPLICATION_SCOPE.toString()).get(BriefcasePreferences.get(Instant.now()).toString()
Boolean.valueOf() instead.
Check the env variable before returning true.
This should check the environment variable before returning true.
This should have been done in the ServiceConfiguration class.
I think that we should save the PrintStream as well, no?
I wonder if we should instead log this error?
I wonder if we should remove that line?
make sure that we don't need to make new String classification as well.
As we discussed, I think we should make sure that default constructor should be private and final.
As we discussed, I think we should make sure that default constructor should be private.
consider overloading throwIfCrossFileScannerTest or something like that.
consider overloading throwIfCrossFileScannerTest to have only one method with a util method.
consider overloading throwIfCrossFileScannerTest to have only one method with a util method, it's not so easy to read at least
throw new RuntimeException("Encountered a value with " + d + " can not be represented as a negative number");
throw new RuntimeException("Encountered a value with " + d + " can not be represented as a double.");
throw new RuntimeException("Encountered a value with " + max.ulp(d)
I'm a bit worried about this the test being run.
I'm not sure this will work on HotRodClientTestingUtilTest
I'm not sure this will work on HotRodClientTestingUtil
why this change?
why is this necessary?
why this is no longer a test?
This should have tested the property name as well.
This should have tested the property name with the json value of the API and not the json value.
This should have assertContainNumericConstants()
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "getCapability("![rule](<LINK_1>](<LINK_2>
why not use!isEmpty()?
why not use!ifPresent?
Instead of setting this flag and just after line pageIndex, just spell it: boolean useRevocableMemoryContext
Instead of setting this flag and just after line pageIndex, just set the local user memory context.
move close to finally
For this logic, is it necessary to raise an exception here? It is good to make sure the client connection is correct.
Since we are doing a null check, is it necessary to check for null?
Since we are doing a null check, is it necessary to keep the if condition?
Nit: I would prefer creating the constants with these args.
Nit: I would prefer creating the constructor with this(new UTF8StringMarshaller()); clientBuilder.build();
Nit: I would prefer creating the constructor with this(new UTF8StringMarshaller(), clientBuilder.build()) and then mock the client.
Formatting: s/space.
Formatting: s/space/style
Formatting: s/space/style.
This looks like a nice candidate for a private method _withTimeout_
This looks like a nice candidate for a method that returns the simple value.
This looks like a nice candidate for a method that returns the simple value instead of creating a new one
Should move this try/catch deeper into the call stack, either the public overload or in the end of the package.
Should probably move this try/catch deeper into a call to the public overload.
Should this move into the try block instead?
should it be the other way around? getLog(type, type)
should it be the other way around? getLog(type)
should it be the other way around? getLog(type, type);
remove public
remove public?
Remove public.
There is some wrong reason for the featurecrolledComposite.setRender("No exception thrown")?
There is some wrong reason for the featurecrolledComposite.setRender("No exception thrown", e);
There is some wrong value in the test.
This change should not be here. It should be the responsibility of the method to set a statusInfo object to null if you set it to not present
The same here.
This change should not be here.
Since the super() is implied, the variable can be omitted.
Since the super() is implied, the method can be omitted.
super() is implied.
Style-nit: We don't use braces around single line blocks
Style-nit: We don't put curly braces around single line blocks
Style-nit: Unnecessary blank line.
These two lines are a bit long, try to keep them.
Our code style is to have a transaction only for code consistency.
These two lines are unnecessary, its a bit confusing to read.
A suggestion: we can avoid a little bit by doing the encoding in the constructor. suggestion if (! orderByClause orderByClause.isEmpty()) {
A suggestion: we can avoid a little bit by doing the encoding in planner.replace() with a final String
A suggestion: we can avoid a little bit by doing the encoding in planner.replace() with a comparator.
How about using try-with-resources? I.e. java try (InputStream inputStream = DecisionTableFactory.newInputStream(inputStream)) { inputStream.close(); }
How about using try-with-resources? I.e.: java try (InputStream inputStream = DecisionTableFactory.newInputStream(inputStream)) { inputStream.close(); }
How about using try-with-resources? And then you could also use.close() in the finally clause.
Do this in memory or could it be zero?
Please make sure that this method is not deprecated. The point is that the method was doing a double-take after this.
Please make sure that this method is not deprecated. The problem is that the method is trying to unconsumedSegment() and it only gets called once.
Remove this log. s/Error loading/whatever/
Is there a reason to use Log.e? I don't liked it if we want to change.
Remove this log.
I would prefer to have a single instruction to be more clear than a class, so that the UI can display the hierarchy of the resource.
I would prefer to have a single instruction to be more clear than a class name.
I would prefer to have a single instruction to be more clear than a class, so that the UI can display the hierarchy of the entity.
Why make this package private?
make this package private.
Why make this non-static?
Codacy has an issue, we can make this private.
Codacy is complaining about this exception. I think we can remove it.
Codacy is complaining about this exception. I think we can make this private.
Needs to be a separate line.
Wrong line.
Wrong permission check: <LINK_0> :)
Same as above, I should throw an exception if!null.
Same as above, I don't think this class should be named input.
Same here?
you could have this all in one line instead of concatenating the004 and 005 to break dependency from github.
you could have this all in one line instead of concatenating the004 and 005 to break dependency from the main and uglier.
you could have this all in one line instead of concatenating the004 and 005 to break dependency from github.data to <LINK_0>
Should we add a comma here?
Should we add a null check on on null?
Should we add a null check on the empty string?
need to set this to true instead
need to set this to false instead
need to set this to true instead.
Vague variable name s
Vague variable name SEPARATOR
name could be more descriptive
An exception will be printed to the console if the url doesn't contain the description. e.g. LOGGER.debug("Unable to parse the url {}", url, e);
An exception will be printed to the console if the url doesn't contain the description. E.g. LOGGER.debug("Unable to parse the url {}", url, e);
An AtomicBoolean would be better here.
This check is not needed.
I think the array list is not needed.
I think the following code is not needed.
Can't we have: this.payload = part, Objects.requireNonNull(payload, "payload"); in the PayloadSlice constructor?
Can't we have: this.payload = part, Objects.requireNonNull(payload, "payload is null");?
Can't we have: this.payload = part, Objects.requireNonNull(payload, "payload"); to avoid NPE?
use static imports
use static imports for non-obvious cases.
else { return }
This part of the code doesn't seem easy to me. When a method name changed, it's easy to look at a unit. When it's easy to see a unit test.
This part of the code doesn't seem easy to me. When a method name changed, it's easy to look at a unit test.
This part of the code should be replaced with equals...
What does the constant mean?
What does the numbers mean?
What are the numbers for the test?
I would suggest to: java return config.orElseThrow(() -> new RuntimeException("no column mapper found for type: " + valueType.class));
I would suggest to: java return config.orElseThrow(() -> new RuntimeException("no column mapper found for type: %s", valueType, ConfigRegistry config));
I would suggest using the built-in codecs.
Added because?
Added because? Or at least change it?
Added for?
The error handling should be dropped entirely. Like the other checks, we can flip this around such that an NPE can't occur (even though we intend such a thing to be impossible).
The error handling should be caught entirely. Like the other checks, we can flip this around such that an NPE can't occur (even though we intend such a thing to be impossible).
The error handling should be dropped entirely. Like the other checks, we can flip this around such that an NPE can't occur (even though we intend such a thing to be impossible)
Won't this make more sense to handle InterruptedException?
Won't this be a performance suicide given how large our tenants work?
Won't this be a performance suicide given how large our sysouts are?
Please add a constructor with List<SchemaIncompatibility> validate(SchemaIncompatibility) that accepts ObjectSchemaIncompatibility boolean. This method can be used for large implementation
Please add a constructor with List<SchemaIncompatibility> validate(SchemaIncompatibility) that accepts ObjectSchemaIncompatibility booleans as well. This method can be used for large implementation
Please add a constructor with List<SchemaIncompatibility> validate(SchemaIncompatibility) that accepts ObjectSchemaIncompatibility booleans as well. This method can be used for large strings
Change to: HexUtils.decode(s.getBytes()) to make this safer.
Make this a static field.
Change to: HexUtils.decode(s.getBytes()) to make this method more readable
You may want to use the MDC.clear() method here
You may use Objects.requireNonNull(backup)
You may use [this](<LINK_0>
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree) return allLabels(defaultIsLastCase(switchStatementTree).noneMatch(SwitchLastCaseIsLastCaseIsLastCase);
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(SwitchStatementTree ) return defaultIsLastCase(switchStatementTree).map(SwitchStatementTree::defaultIsLastCase);
You should go one step more in every case.
Same why not else if?
Same why are we throwing runtime exception?
Same why are we not else if?
What about the 1000 here?
What about the 1000?
What about the underscores?
I'd suggest we also log/throw an IllegalStateException here if permanent is not RuntimeException.
I'd suggest throw permanent.contains("type does not exist") if permanent is empty.
I'd suggest we also log/throw an IllegalStateException here if permanent is empty.
Not a big deal, but a method that returns Optional instead of throwing an exception would be better.
Not a new SQLSessionContext.get(). Won't this return null?
Not a big deal, but a method that returns Optional instead of throwing an exception?
Couldn't this just be e.g. [internal.index gzipStream]?
Couldn't we just ignore the e.getMessage() here?
Couldn't this just be e.g.. e..?
It's good to have this as a single static method.
It's good to have this as a single line.
It's interesting to have this prefix.
"SELECT * FROM quality_gates WHERE name =>"
"SELECT * FROM quality_gates WHERE name =?"
"SELECT * FROM quality_gates WHERE name =?".
"TtyDev" is a typo.
"TtyDev" is not a name, so the name is misleading.
need to be public
Since you're only calling LimitedEntryActionRetractFactCol52 and LimitedEntryActionRetractFactCol52, the code should be the same here.
Since you are no longer updating the LimitedEntryActionRetractFactCol52 and LimitedEntryActionRetractFactCol52, the code should be the same here.
Since you are no longer using a string resource, the code inside the command will never be run.
It seems like the base class should be immutable, and the view should be set to null. Also, TableViewerColumn doesn't seem to be returning an empty Index object.
It seems like the base class should be immutable, and the view should be set to null. Also, TableViewerColumn doesn't seem to be returning an empty list.
It seems like the base class should be immutable, and the view should be set to null. Also, TableViewerColumn doesn't seem to be returning an empty Index object, but it's in the same package.
Missing a failure message.
Missing the expected value.
Missing assertion for result.get().
@vilchik-elena Why this switch case?
@vilchik-elena Shouldn't this return the default case?
@vilchik-elena Shouldn't this return the enum value result instead?
I know this is just a weak snippet of code, but I think we should split it up to the URL.
I know this is just a weak snippet of code, but I think we should split it up to the URL in this same way.
GitHubSCMSource is final.
nit: make masked to assertEquals
make public static
make public static.
code style: throw new Exception(Exception.getMessage(), e);
Use Exceptions.getMessage() instead of this.
code format
Is it necessary to have nested try-catch scopes? Can we make it simpler?
Remove this
Isn't it better to have nested try-catch scopes?
If this is the last line of the test, we may want to use Assertions.assertDoesNotThrow an exception.
If this is the last line of the test, we may want to use Assertions.assertDoesNotThrow(S3B3B3CtedStreamRecord.class)
If this is the last line of the test, we may want to use Assertions.assertDoesNotThrow(originalStreamRecord.class) here.
Do you think that the array access itself will perform this check for you and throw an identical exception...so I'm not sure of the purpose of performing this test here. unless, that is you will show more information in your exception method. (I'm happy either way)
Do you think that the array access itself will perform this check for you? As I understand, this will throw an identical exception...so I'm not sure of the purpose of performing this test here. unless, that is you will show more information in your exception method. (I'm happy either way)
Do you think that the array access itself will perform this check for you and throw an identical exception...so I'm not sure of the purpose of performing this test here. unless, that is you will show more information in the exception method. (I'm happy either way)
In this case, we need to add the new term to the physicalSlotRequestId. This can be implemented using String.format(...).
In this case, we need to add the new term to the physicalSlotRequestId. This can happen in the following commit.
In general, I think %s should be used instead of %s, not int.
Unnecessary?
Unnecessary, just return q - 1 here.
Please make sure that this function never returns null.
To avoid end-of-the-box precision, you might want to use all variables to count * AccessibilityBytes. Otherwise it's clearer to have a field called Accessibility[] or int.
To avoid end-of-the-box precision, you might want to use all variables to count * AccessibilityBytes to start with a length of the actual position?
To avoid end-of-the-box precision, you might want to use all variables to count * AccessibilityBytes.
would it be good to assert at the end of the test? It's both test cases?
would it be good to have a test that verifies that range is within the range and we're expecting it to be? It looks like it's not test negative, but it's not (and I'm missing something here...)
would it be good to have a test that verifies that range is within the range and we're getting based on the timestamp
Same as above, I don't think this is needed.
Same as above, I don't think this check is necessary.
Same as above, I don't think this is needed and if it is done in other clients, it would still be enough to check the database.
What's the purpose of this change?
What's the purpose of this line?
Why do we need this string?
SortedDescriptorsForGlobalConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoConfigurationConfig
SortedDescriptorsForGlobalConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoConfigurationConfig
SortedDescriptorsForGlobalConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoSecurityConfigNoConfigurationConfig
I guess we could also use Paths.get(outputDir.getFileStore()) here?
I guess we could also use Paths.get(outputDir.getFile()) here?
This is fine, but I'm not sure where we can avoid this conversion. Why not just use the nio file on theFiles?
Did you intentionally ignore the patientProgram parameter?
Did you intend to use PatientProgram here?
Did you intentionally ignore this patientProgram parameter?
You don't need this check, you can just do sdf.setTimeone(Timeone.getTimeone("UTC"));
You don't need this check, you can just do this.setTimeone(Timeone.getTimeone("UTC"));
You don't need this check, you can just do this.setTimeone(Timeone.getTimeone("UTC")
0 if txn is not null
txn can be null right?
txn can be null
Why do you catch this? Shouldn't it be done in the same way as you did in update()?
Why do you use this? Shouldn't it be done in the finally block in init()?
Why do you use this? Shouldn't it be done in a finally block in the try?
Can this be changed to false?
Can this useConverged()?
Can this comparison be avoided?
Did you mean code that?
Did you mean code that? I really don't like this change because line 215/16 are still the same
Did you mean code style here? I always use braces for single line blocks
Should this be public?
Can we wrap this constructor to make it public?
Can we wrap this constructor body...
I think this should be a Glowing
I think this should be a Glowing.ReflectionUtil.setGlowing(Boolean blow)?
I think this should be a Glowing.ReflectionUtil.setGlowing(Boolean glow)?
Can we use a self-explained constant here?
Can we use a self-explaining constant here?
Can we use a self-explained constant here? :D
can't we check for null?
seems like a good candidate for null
seems like this can be null
there are several problems with this approach: java return queries.stream().map(TestContext::getId).map(TestContext::getId).collect(Collectors.toList());
there are several problems with this approach: java return queries.stream().map(TestContext::getId).map(TestContext::getId).collect(Collectors.toList());
there are several problems with this approach: java return queries.stream().map(TestContext::getId).map(this::create).collect(Collectors.toList());
Why not implement the return type of the function?
Why not implement the check also, why not -1 if preferredDirection == null?
Why not implement the return type of the method?
This might be null if already permissions are specified. The SnapshotFormatValidator#DESCRIPTOR_VERSION already returns null.
This might be null if already permissions are specified. The SnapshotFormatValidator#DESCRIPTOR_VERSION already returns false.
This might be null if already permissions are provided. The SnapshotFormatValidator#DESCRIPTOR_VERSIONS is called.
Why does this only update the font if it is not already set?
Why does this only update the font if the est exists?
Why doesn't this method static?
Why the logic being repeated?
Why the logic being done in the API?
Typo: "get"
Why this?
Try to change the method name to FeedbackPage.
Why the.conf()?
You can remove the AbstractView class and just use view here
A LinkedList is better than ArrayList.
You can remove the AbstractView class
This isn't really a "remote hung up unexpectedly"
This isn't immediately clear that this is a "remote hung up unexpectedly" screen.
This isn't immediately clear that this is a "remote hung up unexpectedly" or "remote".
Should this be in the try-with-resources block?
should this be private?
This method should be private.
Same as above, pass in the result.
Same as above, authenticationAuthConfigUpdateCommand
Same here.
Wondering why you need this?
Wondering why you need a transactional method that takes a lock (like transaction is)
Wondering why we need a transactional method that takes a lock (like transaction is)
Can't we do the same here, too?
super.getConfiguration() returns a null value, so the constructor doesn't do anything.
super.getConfiguration() returns a null value, so the constructor doesn't throw the exception.
Since we know we don't want to do anything, just change the return value to VdcBllErrors. This should be done in the superclass.
Since we know we don't want to do anything, just change the return value of the vdsError.
Since we know what the outcome is as expected, just change the state.
Consider using TimeUnit.MILLISECONDS.toSeconds(expiresAtMs - creationTimeMs) instead of creating an object
Consider using TimeUnit.MILLISECONDS.toSeconds(expiresAtMs, long) instead of creating an object?
Could we change the return type to long?
nit: unnecessary else
nit: no need to explicitly check getFromTable() to return null.
I don't think this is necessary.
I think we can define this as: public static final int getInputStream() { return (stream == null)? createInputStream() : stream; }
I think we can define this as: public static final int getInputStream() { return (stream == null)? createInputStream() : createInputStream(); }
I think we can define this as final and only replace the first if the stream is null.
Please put back the parentheses around (Unsupported URL : index) + ((key) == DataSnapshot)
Please put back the parentheses around (UnsupportedParameter value : index)
Please put back the parentheses around (Unsupported URL : index)
fileName.getImageSelectorIndex() is the same as previously.
fileName.getImageSelectorIndex() is an array, so it should be removed
fileName.getImageSelectorIndex() is an array, so it should be marked as final
same again: do not create a new empty exception but reuse the old one.
same again: do not create a new empty exception but reuse the previous one.
same again: do not create a new empty exception but reuse the original exception.
I think this should be: super.add(entity.getAddAllowed(entity));
I think this should be... : super.add(entity);
I think this should be: super.add(entity);
Just a nitpick: you can simplify this a little like this: return Objects.requireNonNull(url1, "url");
Just a nitpick: you can simplify this a little like this: return Objects.requireNonNull(url1, url2);
Just a nitpick: you could simplify this by returning the url.
Could you flip the order of the columns and expected columns with the name?
Can we put only the first columns in there?
Could you flip the order of the columns and expected columns with the suffix?
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
the results changed?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
the order is not correct?
you could eliminate this for a lot of things that you like
you could eliminate this for a lot of things that you like.
another constant?
Why is this needed?
Why this change?
Why is this displayed here?
This if-else is redundant here as you're calling it immediately after the if.
This if-else is redundant here as you're already calling it directly on the base class.
This if-else is redundant here as you're already calling it directly on the other factory.
I'd love to have assertions here, like in the rest of the codebase
I'd love to have assertions here, as they were used in multiple places.
could we move these three lines into a separate method?
Can't this be NONE?
Can't this be all compile?
Can we take the default case to the user as a static variable?
I would suggest updating this to analyze the primary key field instead of updating the primary key.
I would suggest updating this to analyze the primary key.
I would suggest updating this to analyze the primary key field instead of updating the primary keys map.
The property is not set, should it be "0"?
The property is not set, should it be DEFAULT_POLL_DURATION
The property is not set in the codacy environment.
Are you sure that the fluid is a truth of this?
Are you sure this doesn't always be true? Do you still need the fluid?
Are you sure that the fluid is a fluid? I think it should be in the same package
This line can be removed.
Shouldn't this line be: menuItemMenuItem.add( and menuItemMethods);?
Shouldn't this line be: menuItemMenuItem.addImportMenuItem(**last**)?
We tend to prefer if no access modifier was introduced in java 1.8.sql.Statement -> this.sql.Statement == that.sql.Indexes && this.attributes.add(this.attributes); It is a bit hard to follow.
We tend to prefer if no access modifier was introduced in java 1.8.sql.Statement -> this.sql.Statement == that.sql.Indexes && this.attributes.add(null)
We tend to prefer if no access modifier was introduced in java 1.8.sql.Statement -> this.sql.Statement
Exception should be logged
RuntimeException should be catched here as well.
RuntimeException should be catched here too.
is this a duplicate of the View#sign_button?
is this a duplicate of the View here?
is this a duplicate of the ViewUtils.sign_in to notify?
This can be the same as the accountService.getAccountUsers(_accountService.getAccount()).
This can be the User getAccountUsers() call instead of the re-accountService.getAccountById
This can be the same as the accountService.getAccountUsers().
This should clear the access modifier.
This should clear the access modifier on the field.
This should clear the access modifiers on the _queue_.
Could you name this inputElement?
Could you use a field for this string?
Could we use a field for this on the class or variable?
Why not.filter(exam -> exam.getRoom().getPenalty()!= 0)?
Why not.filter(exam -> exam.getRoom().equals(Exam.class))?
Why not.filter(exam -> exam.getRoom().equals(Exam.class))?
return a new IRSAKey;?
return a null value when the key is not valid
return a constant
Are you sure that thrown.expect( ) is the same as the one in the method below?
Are you sure that thrown.expect( ) is the same as the one in the method above?
Are you sure that thrown.expect( ) is the same as the other tests
no need to declare this, it would be a runtime exception
no need to declare this, it would be the default value
no need to declare this, it would be the default
s/index/indexForNull/
s/index/inputForNull/
isNotNull()
You can use tagsToResource.get(fromTag).containsKey(fromTag).
You can use tagsToResource.putIfAbsent(fromTag, as this) will be more efficient
Might want to check if the tag was removed.
I missed this one before, but there is a reason the problem is that we don't use else here.
I missed this one before, but there is a reason the problem is that we don't do this.
I missed this one before, but there is a reason the problem is that we don't do this. It's a bit strange to throw an exception if the resolver manager is null, but the password does not exist.
Rename to escaped?
Rename to character
Rename to character or character
Can be simplified to java return Try.of(partialFunction)::apply);
Can be simplified to java return Try.of(partialFunction)::apply).stream().map(partialFunction::apply).collect(Collectors.toList());
Please use Try and map instead of collect.
I missed this before, but isn't it?
I missed this before, we should keep the DialogFragment as a field so that it's safe to leak here.
I missed this before, we should probably store the DialogFragment as a field so that it is safe to keep on fresh call.
Make this synchronized
Make this an atomic long?
Make this an synchronized
The local variable is not used. Just return directly the value of getCachedImageParams.
The local variable is not used. Just return directly the value of getCachedImagePath()
The local variable is not used. Just return directly the value of getCachedImagePath() method
Why put this from scratch?
Why put the brightness in finally?
Why put this from scratch space?
Why not: java return StreamSupport.stream(desc -> desc.hashCode().count()).distinct().count();
Why not: java return StreamSupport.stream(desc -> desc.hashCode().spliterator(), false).distinct().count();
Why not put this into a stream?
I am not sure if this is a good idea to wait until you have max connections, but wait until you get one. Is there a particular reason to count count than 1?
I am not sure if this is a good idea to wait until you have max connections, but count of 1M you may have many connections. In that case, you need to getNumberOfConnections() to return 1 count.
I am not sure if this is a good idea to wait until you have max connections, but count of 1M you may have many connections. In that case, you need to getNumberOfConnections() to return the count.
The context is not used. If you want to use ds.setReuseAddress(true) then you can remove the DatagramSocket instance variable and change the implementation to: java ds.setReuseAddress(true);
The context is not used. If you want to use ds.setReuseAddress(true) then you can remove the DatagramSocketUtils.getInt(port) method from the main thread.
The context is not used. If you want to read the ip address from the IPv6 address, maybe we should use it.
Is this method still used?
Is it possible to have this method private?
Cool :-)
Add a message for the Throwable
Add a message for the exception
Add a message
rename
could be inline
rename?
same here, can be linkedAddresses!= null
same here, can be null.
rename to linkedAddresses
This is an overloaded method, why change the class?
This is an anti-pattern that I recommends doing this in a constructor.
This is an anti-pattern that I recommends doing this in a constructor and a builder.
Can we use a specific ConfigJavaUtils.isEmpty(config)?
Can we use a java 8 streams here?
Can we use a specific ConfigJavaUtils.validateConfig here?
Why not just 'this'?
Why not [0..length on both sides.
Why not [0..length on both sides
Can you move this for file re-use?
Can you move this to class level?
Please remove this
Maybe using OutcomeSettings.setOutcomeSettings(settings, ApplicationPropertySettings.EMPTY_LIST) instead?
Maybe using OutcomeSettings.setOutcomeSettings(settings); here?
Maybe using OutcomeSettings.setOutcomeSettings(settings, ApplicationPropertySettings.DEFAULT_Outcome); here?
I like 2. Let's do that. And I like the message, it makes it easier to read.
I like 2. Let's do that. It's a good idea to keep a reference to the underlying cause.
I like 2. Let's do that. It's a good idea to keep a reference to the underlying exception, in a catch block.
Static string constants
Has the stagger found for your PR?
Bad name.
RuleImpl '" + container + "' has been removed from the string
RuleImpl '" +'has been removed from the string
RuleImpl#toString
Should have a space after add
Should have a space before add
Should have a space after add should
context can be null.
context.release() is possible to be used to set the operator.
context.release() is possible to set a high value to 0.
If you want to return a RawText object, you don't need a new RawText implementation.
No need to create a new byte[] here since its a length of 0.
If you want to return a RawText object, you don't need a new byte[].
We can use this inline in the create method. It is not necessary for this JmsConfiguration.
We can use the return statement in declaration of this method here
We can use the return statement in #setJmsTemplate(): we already have the return statement in the if.
Needs a try/catch for all exceptions.
Needs a new exception for all exceptions
Needs an else if
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
It would be nice to change the parameters class so that it uses List instead of Set, then you could use just "toList".
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you can use just "toList".
Is this correct? Why don't you use a stream?
Is this intended to use a hashset here to avoid the entire collect?
collect only one set?
I think we should drop the m as it is not a member anymore, same applies to cancel
I think we should drop the mTrainingDate here, same applies to cancel
I think we should drop the mTrainingDate here, same applies to cancel the event.
Make it public
Make it final.
Make it public.
I think we can simplify this by replacing the following 2 lines with:.registerException(exceptionEvent)
I think we can create this map... :smile:
Please add the cause here.
again, extract into a local variable.
this should be in a try/finally.
Optional.toIntExact(Group.Id....)
Store this in its own if-else statement
Store this value in private static final field
StringUtils.isEmpty()
Why is this needed?
Why is this needed? It is used later
why is this needed?
Should be Exception
I think it should be Exception
Why Exception?
I think it should be renamed as formConfigByName.
I think it should be in a different PR as you were thinking about creating the config object instead of adding the config object. This should be in an example <LINK_0>
I think it should be in a different PR as you're using this. Not sure about it though.
you don't need the "else" here.
you don't need the if else block here.
you don't need the if/else blocks here.
What if it's not _empty_? Is it possible to just return null?
What if it's not _or_? Is it possible to just log the exception?
What if it's not a string?
static import
static import anyMatch
static import orElseGet
Was this got to make sure that the test pass even without it?
Was this got to make sure that the test pass even without the wildfly-core plugin?
Shoudn't we use the wildfly.url.xml for this?
Recommend using a LinkedHashSet instead of a HashSet, it is more efficient.
Recommend using a LinkedHashSet here, it looks better.
Recommend using a LinkedHashSet.
= 'public Date'?
= new Date('a', 'a') => shorter and more readable.
= new Date('a', 'a') => shorter & more readable
This should probably be trialUntil
This should be a static member
This should probably be a static member
Does it really need to be public?
Is this the same as getClass().getName()?
Is this the same as getClass().getSimpleName()?
Defensive the order is incorrect - it should be NOT spiller. Otherwise, I'd remove the modifier.
Defensive the order is incorrect - it should be NOT spiller. Otherwise, I'd remove the whole thing
Change this to unmodifiableSet.
If you want to use assertEquals(PaxosTimelockServerIntegrationTest::get...) I think it's cleaner to have the latter, and easier to understand.
If you want to use assertEquals(PaxosTimelockServerIntegrationTest::get...) I think it's cleaner than the interface, and easier to understand.
If you want to use assertEquals(PaxosTimelockServerIntegrationTest::get...) I think it's cleaner than the assertTrue inside the method, and I'd recommend including the magic number.
I honestly didn't remove all the logger messages but that's a bug. <LINK_0>
I honestly didn't remove all the logger messages but that's a bug.
Should this be parameterized?
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor](<LINK_1>
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_2>
This is a bug in PR, but I think you want to handle this. Not sure about the fix, but since you are on the client side, you can do something like this: String minStr = String.valueOf(minStr); conf.getFormatter().apply(minStr);
This is a bug in PR, but I think you want to handle this. Not sure about the fix, but since you are on the client side, you can do a :(
This is a bug in PR, but I may be missing something. Might be safer to keep this (in case there's a :laughing:
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<>();
Should this be List<String> instead of PartitionAttributesFactory = new PartitionAttributesFactory();
Should this be List<String> instead of List<String>?
Isn't this the formatting of the method in the first place? I'm not sure if we should have to do this as: return Bindings.createBooleanBinding(StateManager.SHARED).map(true::to)
Isn't this the formatting of the method in the first place? I'm not sure if we should have to do this in the first place...
Isn't this the formatting of the method in the first place? I'm not a fan of static imports.
Instead of this try/catch, you can create a variable with the same name and initialize it in the constructor instead of using this variable. This way, it's less confusing to read.
Instead of this try/catch, you can create a variable with the same name and initialize it in the constructor instead of using this variable. This will remove the need for the null check.
Instead of this try/catch, you can create a variable with the same name and initialize it in the constructor instead of using this variable. This way, this view will be more consistent with the next test.
Is this code line a duplicate?
Is it getEmail()?
Is this if statement really needed?
This is not testing the RulesDao. It should have its own loadRules as well.
This is not testing the RulesDao. It should have its own loadRules method.
This is not testing the RulesDao API, but the list of rules should be immutable.
Is there a reason why this method is called updatedStatusDisplayName?
Is there a reason to use an forEach here?
Is there a reason to use an OfflineDb tag instead of creating one for each of these?
how about max < min and max >= min?
how about max <= min?
how about max < min and max?
Why not make this a constant so you can use the constants?
Why not make this a DateTime?
Format this file
I think this part should be placed in the generalisation class TraceResponseOutInterceptor
I think this part should be placed in the generalisation class TraceeResponseOutInterceptor
I think this part should be placed in the generalisation class TraceResponseResponse<Void>
if the 'VnicProfile' is not null, it means that the user doesn't have an entity which is missing for the 'VnicProfile'. In this case the 'VnicProfile.getNetworkQosIdOrNull will have NPE fine.
if the 'VnicProfile' is not null, it means that the user doesn't have an entity which is meant to be non-null
if the 'VnicProfile' is not null, it will throw an NPE.
We don't need to expose this. Iterable.copyOf is unnecessary.
Another addAll method here: <LINK_0>
We don't need to expose this. Iterable.copyOf() is enough.
Let's put ColumnTypingStrategy#STRING and constant.
Let's use constant.
Let's put ColumnTyping.
Can you extract this list into a private method please?
Can you extract this list into a constant?
Can you rename this to provider
Move the logic to FILE_PATH and make it consistent with the other characters.
Move the equals to the previous line so that the put returns the value?
Move the logic to FILE_PATH and make it consistent with the other constant
nit: can we also define ObjectMapper when it's declared?
nit: can we also use assertj for the rest of the code?
Shouldn't we also verify that the mapper was added to the right side?
This doesn't really need a throws declaration.
I don't think this is going to ever be called after the underlying lock is actually needed.
I don't think this is going to be a really helpful idea. If you don't want to do this, use a SetViewView which will be actually returned.
Can we please remove these deprecations?
Can we please remove these so we're not actually using the chc value?
Can we please remove these so we're not running the test?
Perhaps you can use the Files.write(path) here, which does this work for you.
Perhaps you can use the Files.write(path) here, so that the next line is the same
Perhaps you can use the Files.write(path) here, which uses the regex automatically
You could do: java return rawCookies.split(": raw");
You could use raw asserts here.
You could use raw asserts.
It might be good to add more info to this _ServerStates_. This way, clientStates etc. from the queue could be mutable.
It might be good to add more info to this _ServerStates_. This way, clientStates etc. from the queue could be different than the one used.
It might be good to add more info to this _ServerStates_. This way, clientStates etc. from the queue could be different depending on the order of poll.
this should be the disk id, not the image id
this method should always return the quota, and always fetch disk's disks, what do you think?
this method should always return the quota, and always fetch disk's name, also the user will probably not need to modify the quota
It's more readable in my opinion. Review the name as e.g. getSortWeight(int)
It's more readable in my opinion. Review the name as e.g. getSortWeight((double) formField).
It's more readable in my opinion. Review.
Why not, ImmutableList.Builder<TypeTree>?
Why not, ImmutableList.Builder<TypeTree>?
Why not, instanceof TypeTree?
nit: drop the final
Nit: extract this to separate function
Nit: Can we make this a member constant?
Could use ImmutableSet.copyOf() here.
...and use CollectionUtils.isNotEmpty()
...and use CollectionUtils.isNotEmpty() here?
Do we need to check if formDir is not null?
Do we need to check if endpointUtil is null?
Do we need to check if endpointUtil is not null?
this.
can this all be done in one line?
can this all be done with just this.
This is a lot of code duplication. Could you just use app.getClass().getCanonicalName()?
This is a lot of code duplication. can you just use app.getClass().getCanonicalName()?
This is a lot of code duplication. Could you just use app.getClass().getCanonicalName()? It's up to you.
Replace these two lines with: writeVarInt32(in, endA, endB, beginA) { endA(in, endA, endB, beginB); }
Replace these two lines with: writeVarInt32(in, endA, endB, beginA) { endA(in, endB, endA, endB); }
Shouldn't this method be put into the writeVarInt32() method? It seems like it could be removed to make an argument of this method easier to read and understand.
We can use directly context.get(CatalogContext.DB_IGNORE_TABLES, CatalogConfiguration config)
We can use directly context.split(mConfig) here instead of calling trim().
We can use directly context.get(CatalogContext.DB_IGNORE_TABLES, CatalogConfiguration configuration)
in this case, the message could be collapsed to: "Updating filter".equals(filter)
in this case, the message could be collapsed to: "Updating filter".equals(filter, locale)
this.
Why are you looping here? Can you give a use-case?
why are you looping here? Can you give a use-case?
Why are you looping here? Can you give a return statement?
Put the catch block inside the same try/catch block.
Put the catch block inside the same try-catch block.
Put the catch block inside the same try/catch.
Should be synchronized or else this.next()
Should this be synchronized?
Should be synchronized
If we made this method private, we might want to replace it with something like: java public Route(final Route<Territory> territories) { this(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int
If we made this method private, we might want to replace it with something like: java public Route(final Route<Territory> territories) { this.start = checkNotNull(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get
If we made this method private, we might want to replace it with something like: java public Route(final Route<Territory> territories) { this.start = checkNotNull(territories.size()); for (int i = 0; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get
Please don't use the getSelectionSelection
don't forget the space.
getSelection().getSelection()
This should probably be a static constant because it is used in multiple places.
This should probably be a static constant because it is not local to the class name.
This should probably be a static constant because it is not local to the class.
Should we be closing the stream in a finally block?
This should be a log statement.
This should be a log instead of a error.
Formatting?
Minor: you can return true on lines 47 and 106 at are very similar.
Suggest to check that the certificate is > > 0 and return false.
I'm not sure if nicsForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdate));
I'm not sure if nicsForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForUpdate));
I'm not sure if nicsForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdateInterfacesForUpdateInterfacesForVds(updateNicsForUpdateInterfacesForUpdate));
I don't know if this should be public, but it does not go through the interface.
I don't know if this should be public, but it does not really matter in the interface.
I don't know if this should be public, but can we make it package-private (no modifier) instead?
Can you have one method for this? Its a lot easier to read
Can you have one method to test this? Its a lot easier to read
Can you have one method for this? Its a lot cleaner than another.
shouldn't we just add 'null' here?
why is this required? It's only used in tests.
shouldn't we just add 'unzip(which is a more expressive method?
I think that in this case it's best to use a constant here.
I think that in this case it's best to declare some sort of feedback url here.
I think that in this case it's best to declare some sort of feedback from the database and have it return a special case here.
Single or double pipe
Single;
10
mapper.getAsyncTaskExecutor() is a bit confusing. It looks like the other constructor should be private or at least package-private.
mapper.getAsyncTaskExecutor() is a bit confusing. It looks like the other constructor should be package-private, but it is also used by the consumer.
mapper.get() is a bit null
Is this null here?
Is this the skillCompare!= 0 necessary?
Is this the same as below?
why this change?
why this change to a Binary?
final
Please add NON-NLS tag for "vo".
Please add NON-NLS tag for this method.
Please wrap it in InternalErrorException.
The field names are wrong, but the field names are different. 'public' and 'public' is defined.
The field names are wrong, but the field names are different. 'public' and 'value' is defined.
The field names are wrong, but the field names are different. 'public' and 'public' are not a good name.
I believe it should be a warning instead of info.
I believe it should be a warning instead of info?
I believe it should be a debug level here?
Do we really need this?
Do we really need this variable? We can simplify the logic here.
Do we really need this variable?
mShareIntent!= null may not be the better fit here.
mShareIntent!= null may not be enough.
mShareIntent should be used to be the shared intent here.
static imports
static import
final
Do we want to initialize actual values when actual name is not empty? If we are trying to avoid any trouble we get ride of actual downloads...
Do we want to initialize actual values when actual name is not empty here? If we are trying to avoid empty names then we will get all of them when trying to import.
Do we want to initialize actual values when actual name is not empty? If we are trying to avoid any trouble we get ride of the [alternative_type]
If we move this logic to grandParent, the code may be more logical. Or maybe we could have a wrapper for hive class which is not necessarily an identifier. Does it make sense to have this class implementing isVerifiable?
If we move this logic to grandParent, the code may be more logical. Or maybe we have a test for this case.
If we move this logic to grandParent, the code may be more logical. Or maybe we could have a wrapper for hive class which is not necessarily an identifier. Does it make sense to have this class return a whole tree?
Should this be a switch?
Should this be a switch statement?
Should this be a switch expression?
probably shouldn't be a null check?
probably not needed.
probably not required.
Again, getRequestURI() already contains the context.
Again, getRequestURI() already contains the path.
You should probably use request.getRequestURI() instead of "consumer"?
extension cannot be empty or /.
extension cannot be empty or /
extension cannot be empty?
this is a bad idea, you should use a filter instead.
please use {}
this is a bad idea, you should use a processe method.
reopenAccount?
reopenAccount on purpose?
reopenAccount on purpose or try editing
rsdl_metadata.yaml you should be validating these fields: action.name(), action.name()
action.toString() would be cleaner here.
action.toString() would be cleaner.
It seems like the only place where the lock is used is the transaction..
It seems like the only thing to do here is the transaction.isOnePhaseCommit() and not the instanceof check here.
It seems like the only place where the transaction is used is the transaction..
Same as above, why not just Compare with FilterPath.equals(other.path)
Objects.equals() is used for both of these, may be you can use Objects.equals()
Same as above, why not just Compare with FilterPath.equals(other.path)?
s/hasAvailable/hasAvailable
1. Consider having a version with the key 2. Does this need to be public?
1. Consider having a version with the key 2. Does this need to be protected, or package-private?
Should this be moved into the constructor?
Should this not be public?
Should this not be private?
Should this array include VIEW?
Should this array include VIEW so it's lower-case?
Should this array include VIEW so it's lower case?
This might read better if we use servers.addAll(Collection<ServerHolder>) instead of the if statement.
I'd use servers.addAll(Collection<ServerHolder>) instead of the if statement.
This might read better if we use servers.addAll(Collection<ServerHolder>) instead of the for loop.
Can we use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
Can we use a logger here?
Seek too?
Duplicated, no need to call it.
Duplicated, no need to call it activeSeek
Style-nit: curlies not needed
Style-nit: Space after exception
This should use the normal configUri instead.
This class has a receive method where we have a Consistent status and can be used to fetch the localClusterId. Can we just pass the localClusterId to this method?
This class has a receive method where we have a Consistent status, so can we just set the localClusterId to null?
This class has a receive method where we have a Consistent status, so can we just set the localClusterId to null? It will not be relevant to this method.
maybe we should be using orElse(false)?
Maybe we should be using orElse(false)?
The message should be: "CassandraKeyValueService creating the KeyValueService..."
Should this be logged as such a user?
Can we log that all instances are returned by logger.debug?
Can we log that all instances are being returned by logger.debug?
as there is no need to create this variable here, you can just return at the end of the method.
as there is no need to create this variable here, you can just return at the end of the method
as there is no point in overriding this method, it is better to return true (that for all cases)
I think if the credentialType is null, we should assume that the credentialType is either null or identityType.
I think if the credentialType is null, we should assume that the credentialType is either null or a CredentialAcquireSupportLevel, that is likely not what we want.
I think if the credentialType is null, we should assume the credentialType is either null or identityType.
Can we use the super constructor?
I think we should have a static import for DelegatingSystemTablesProvider... just call those methods
I think we should have a static import for DelegatingSystemTablesProvider... just call those methods?
Why not GraphDatabaseService?
Why not let the default ResourceIterator API instead?
Why not let the default ResourceIterator constructor to handle?
That is right. If you are not using the mPostsObjects in the current browser component, it will throw an exception.
That is right. If you are not using the mPostsObjects in the current browser component, it will throw an exception. I would expect the app to crash here.
That is right. If you are not using the mSelected mana for this, at least the local context is available.
Consider extracting position.getStockSymbol() to a local variable.
Consider extracting a variable for position.
Consider extracting position.getStockSymbol() into a local variable.
uniqueDiagnoses is a Set and by design it doesn't allow duplicates, all you need to get rid of duplicates is the call below: uniqueDiagnoses.addAll(diagnoses);
uniqueDiagnoses is a Set and by design it doesn't allow duplicates, all you need to get rid of duplicates is the call above: uniqueDiagnoses.addAll(diagnoses);
unique value instead of diagnoses.addAll(diagnoses);
Maybe this is simpler: if (!notification.getNotifications() ||!filter.isNotificationEnabled()) {
Maybe this will only delete the last notifications if it is empty.
Maybe this will only remove the warning.
<>
Again, an int is better.
Again, an exception will be thrown.
could be fSpan.isEmpty()
Missing f span name?
could be fSpan.isEmpty().
I believe this should be stored in a field, not in the class.
I believe it should be stored in a field, not in the class.
I believe this should be stored in a field.
"Filter cannot be null"
Include the offending value in the message
checkState
That's not correct. Do you think we still need to be passing any argument?
That's not correct. Do you still need to be passing any argument?
That's not correct. Remove it.
This seems to be the same as equals and hashcode. Can we please return an empty list instead?
This seems to be the same as annotation. Can it be a static method?
This seems to be the same as equals and hashcode. Can you please revert this change?
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Instead of FileHandler, you should use the PropertyConfigurationLayout to save an instance of the configuration.
According to <LINK_0>, it's better to use java.util.ConfigurationProvider.config() instead.
Why can't we have it as a UdpServerAdapter with the notNull check?
Why can't we have it as a UdpServerOutboundEvent wrapper with the notNull check?
Can you have it as a change?
You can also call getWakeLockPermission() here.
Remove the try/catch.
Can you also assert this value?
I think we should at least log the exception.
What else are you trying to do with it?
I think we should at least log the exception. That means we could have something at least.
Do we have only two ways to use GraphQLType here?
Do we have only two methods? Could it be refactored to use GraphQLType?
Do we have only two methods?
MergeViewerSide side, no need for the cast here
MergeViewerSide side, you could extract to a local variable for clarity.
MergeViewerSide side, no need for the cast here.
Instead of using a hardcoded string, I think we should create a SYNC_PERIOD_SYNC constant, as it will be more readable.
Instead of downloading a connect, could we create a Response in the context and then pass it to the background as an argument? That way we can keep SYNC_PERIOD as default.
Instead of using a hardcoded string, I think we should create a SYNC_PERIOD_SYNC constant, as it will be more specific.
yeah, let's move this up
yeah, let's remove this @.
static import
nit: as above for cache
nit: storeSensorPrefix would be clearer to mark the store as final.
nit: space between ) and {
return id == null
return id;
return id!= null
anonymous class
anonymous class is redundant
is this anonymous class necessary?
extract the return cachedEnvironment; out of the try-catch block.
extract the return cachedEnvironment; in a local variable outside the if.
But it does not matter.
The id is the id in the list.
The names in the findElement() method can be extracted out as a constant.
The names in the findElement() method can be used instead of in a HTML constant.
Shouldn't this be cacheManager.get()?
I'm not sure if this is the correct way to do this. I have the method working on a gerrit and it seems to me to be too fast.
I'm not sure if this is the correct way to do this. I have the method working on a gerrit-server.xml and it does not follow that paradigm.
Check command and status null.
Check command and return null if it is not a valid Exception.
Check command and status null. The same applies to all the other methods.
I wonder if we can have a more neutral term. This is a structural class
I wonder if we can have a more neutral term. This is a structural class and we have a structural one?
I find this more readable
Maybe it is better to use try-with-resources?
Why it is not using old-style?
Why it is not using old variables to avoid the cast?
null!= settings
null!= settings.getBoolean
null!= settings.getBoolean(...)
I would assume that it will throw an AssertionError for us, with a clear error message.
It should throw an IllegalArgumentException.
I would assume that it will throw an AssertionError for us, with a descriptive message.
As per offline discussion, we should always get rid of the map keyBasedEventQueueMap.get(mapKeyForQueue) method instead.
As per offline, we should avoid creating the map everytime the map is concurrent?
As per offline discussion, we should always get rid of the map keyBasedEventQueueMap.containsKey() timeout.
Why is the 'else' part needed?
Why is this method synchronized?
Why is the 'else' block needed?
I guess this should be ac rather than ac/response
I guess this should be ac rather than ac/ref? (same for other PRs below)
I guess this should be ac instead of this method. (It was public in the third commit)
suggestion if (parameters.getMode() == ExitCode.OK) {
Might be better to add an else block since your arguments are of type param.
Might be better to add an else block to make it explicit that it also terminates.
with.inRoot(s) the text should be extracted to a constant
with.withClickOnOK() you could skip the.withClickOnOK() as it would still do nothing
with.withClickOnOK() you could skip the.with click on the first child.
instead of a list, use.toList()
instead of a list, use.equals()
instead of a list, use.equals() method.
Space before {
remove unnecessary blank line.
remove exception.
use context.get(new TermContext(substitution, context)) instead
use context.getNormalColor() instead of this assignment.
use context.getNormalUser() instead of this assignment.
nitpick: In theory the raw token and other have the same type, we are relying on the raw type.
nitpick: In theory the raw token and other have the same type.
nitpick: In theory the raw token and other have the same type, we are relying on the raw token.
We need to make this ApplicationContextAware and check the context. We don't want to react to events from other contexts in the hierarchy.
We need to make this ApplicationContextAware and check the context in the event matches. We don't want to react to events from other contexts in the hierarchy - maybe not relevant here, but best practice.
We need to make this ApplicationContextAware and check the context in the event matches. We don't want to react to events from other contexts in the hierarchy - maybe check the context's context.
It's best if we could use a StringBuilder to build this string.
I think this string could be replaced by a StringBuilder, or even use it directly.
I think this string could be replaced by a StringBuilder, or even use it as a type.
should atleast check o being non-null and instanceof sessions?
should atleast check o being non null?
should atleast check o being non null
Please add a limit = limit; here to avoid negative values.
Please add a null check here: if limit is null, limit cannot be null
Please add a null check here: if limit is null, limit cannot be negative
To follow the conventions of Spring Security, please change to "Set<url>".
To follow the conventions of Spring Security, please change to "This setting has nothing to prevent the problem"
To follow the conventions of Spring Security, please change to "Set<url> :".
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if!ref.startsWith(oldPrefix)
I would feel more comfortable with this if block. Could we change it to something like: if (ref.startsWith(oldPrefix)) { throw new IllegalArgumentException("HEAD"); } else { return " + oldPrefix + " does not start with " + oldPrefix + ".length(); }
I would feel more comfortable with this if block. Could we do something like: if (ref.startsWith(oldPrefix)) { oldPrefix = oldPrefix + oldPrefix + " does not start with " + oldPrefix + ".length(); } else { throw new IllegalArgumentException("HEAD"); }
final
Missing final
getOrDefault?
This can be written more concisely as: return mgr.stream().filter(Objects::nonNull).map(Objects::nonNull).collect(Collectors.toSet());
This can be written more concisely as: return mgr.stream().map(Objects::nonNull).filter(Objects::nonNull).collect(Collectors.toSet());
This can be done shorter: return mgr.stream().filter(Objects::nonNull).map(Objects::nonNull).collect(Collectors.toSet());
here you can use the static String SCHEMA_FILENAME = "SCHEMAS_LOCATION" + "/" + version);
here you can use the static String SCHEMA_FILENAME = "SCHEMAS_LOCATION" + "/" + SCHEMAS_LOCATION_TYPE_LOCATION;
here you can use the static String SCHEMA_FILENAME = "SCHEMAS_LOCATION" + "/" + SCHEMAS_LOCATION: " + version);
"99999" not frequently. You should make sure getName() is not that a long println.
"99999" not frequently. You should make sure getName() is not that a long > 0.
"99999" not frequently. You should make sure getSignature() is not a Long
I think it's better to make this private and move the setter to the end of the class
I think it's better to make this private and move the setter to the constructor. Then we don't need to make a private setter.
I think it's better to make this private.
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
I think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
This line wrapped in line 91. parseResponse can return null (line 133), which will cause this future to never complete.
Is headers or properties not supported by this class?
Is headers or properties not supported?
Can we rename headers or properties to something?
Nit: I prefer using a private final String here and in the constructor to avoid code duplication.
Nit: I prefer using a private final static field for the property names.
Nit: I prefer using a private final String here and in the constructor to avoid the duplication.
if (map == null || '='.equals(x)) { return map.collect(Collectors.joining(", "); }
if (map == null || '='.equals(x)) { return map.collect(Collectors.joining(", "); } return new StringBuilder();
if (map == null) { return null; }..
I'm not sure if this is the right place for the test since it's the same as the other method. That's what I would expect.
I'm not sure if this is the right place for the test since it's the same as the other method. That's the only place this method is used.
I'd rather see Boolean.parseBoolean(...) call here. It's much more readable.
I think we should move this message to logger
"Building", set with this.validator
I think we should move this message to logger.debug
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the class's monitor.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void...)
if you are synchronizing whole methods on the same object, you might as well use the class's value.
@weisebrazil all indentations should be 4 spaces, not 8.
@weisebrazil all indentations should only be 4 spaces, not 8.
@dalifreire There's no need to do this with.exit().
dublicate biz
I would add a biz check:ganttproject.core.chart.scene.BIG_ENDIAN to avoid a non-biz logic
I would add a biz
Please make submit a class to the OutputCommand.
Please make submit an issue.
Please make it configurable.
This is the same as [plunk issues](<LINK_0>
This is the same as [plunk issues](<LINK_1>
This is the same as Workers.setFilter(). It did
Shouldn't this be "file.isEmpty()"?
Shouldn't this be "Storage".isEmpty()?
Shouldn't this be "Storage".equals(commit)?
Should we use the provided string constant?
Should we use the passed in value?
Should we use the passed in from the constructor?
I suppose this is safe as well.
I suppose this is safe as well. Yes, that is what I meant.
I suppose this is safe as well. Yes, that was the first time I see this is done. But I am still a bit concerned about the potentially missing piece of code here.
I'm not sure this is safe. If the other tests do not fail, I don't think this is a good idea to keep.
I'm not sure this is safe. If the other tests do not fail, I don't think this is a good idea to keep all this. In order to be able to assert that the message's actual number of bytes we expect.
I'm not sure this is safe. If the other tests do not fail, I don't think this is a good idea to keep all this. In order to be able to assert that the message's actual number of rows will be the same and keep them separate.
what about location? we do not need LocationSerializer?
what about setting the date format in the constructor?
what about setting the date format to a temporary byte[]?
If you don't want to be closed after test methods, please delete them and create a new test class in the factory.
If you don't want to be closed after test, please delete this class and clean-up with the factory.
If you don't want to be closed after test, please delete this line.
We should enforce that object is statically imported.
Should we enforce that object is statically imported?
Should we enforce that the b-cing children aren't?
**txn!= null** is not needed.
scheduled() returns null instead of an empty call
scheduled() returns null
How about getServerMetricConf().getServerMetricConf()?
How about getServerMetricConf()?
How about getServerMetricConf().getServerMetricConf(); instead?
This is a local variable, should be camelCase not fCamelCase
I think that any unhandled block should be skipped instead of returning null because this will end parsing.
There are less than 28 bytes left in the packet data. May be less than 28 bytes.
Is there a reason you use MetricsManager here?
Is there a reason you use the MetricsManager instead of the metrics manager?
Is there a reason you use the MetricsManager here?
maybe you could add a debug log here?
maybe you can add a debug log here?
maybe you can add a debug log here, for consistency?
I don't think this is needed.
I don't think this is needed. We have the empty query on the web UI.
I don't think this is necessary.
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikis, it seems to me like it is only used in one place, so you don't need it.
Please remove extra line
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikis, it seems to me like it is only used in one place, so you don't need it. Also, do we need it?
I think this should be: if (this == this) return true; if (this == o) return true;
I think this should be: if (this == this) return true; if (this == this) return false;
I wonder if this should be a static field equals since it is a derived class.
As we talked about the readShort logic better than nothing because it can be very expensive.
As I understand the bit is correct, we do not need to cast it to int.
Same remark as in the CodecTracker.
What is the use of this constant?
What is the use of this returned value of this method?
What is the use of this returned value of the method?
Use instead of if (file == null) return;
Use instead the if (file == null) return;
Use instead the if (file == null) return; instead.
s/occured/occurred/
same, we should be logging here, at least.
same, we should be logging here, at least
vanish needs to be the same
Override
vanish, too
I don't think we want to check if this is present in the map.
I don't think we want to check if trace is enabled, or not.
I don't think we want to check if trace is enabled, or not..
Can you make the type Map<String, String>?
Can you make the type Map<String, String>?
Can you make this Map<String, String>?
why add?
please rename to edit
should be edit
final
Why don't you just use the field directly?
Why don't you just use the field instead?
Should this be trace level?
Should this be a WARN instead?
Should this be a trace level?
Can we use return new Class<T>(method).resolve() instead?
Can we use return new Class<Method>(method).resolve() instead?
Can we use return new Class<Method>( method); instead?
why not use StartupContext.FORCE_container.getName?
Why not use StartupContext.FORCE_container.getName?
why not use StartupContext.FORCE_container.public?
why do we need the info here?
the info is removed
you need to use the info.exists here, right?
Is it worth extracting ColorMode.getColorTemperature to a local variable?
Is it worth extracting ColorMode.getColorTemperature to a local variable, e.g. why 100?
Is it worth extracting ColorMode.getColorTemperature to a constant?
I'd rather not supply an empty list. Just in case.
Hm, just opportunity to update this method
Hm, no need for a builder here? :-)
break if obj is null.
Ah true. I see that you need to override the THE_ROW event type.
missing hasNext()?
You should have close() on the finally block.
You should have a catch block just to close it in a finally block.
You should have a catch block just to close it.
Could this be max(1, parallelism) or Math.min(1, parallelism)?
nit: Could be parallelism / maximum.
nit: Could not create a util method.
I'd add a toString() of Long.toString() if you want to keep that.
I'd add a toString() here
I'd go for this.
These two lines can be combined.
These two lines can be combined
Use "public".
It's better to make this a method on S1 with a new name, to avoid repeating isTable6.
It's better to make this new method on S1 with FULL_TIMESTAMP constant in many many classes.
It's better to make this a method on S1 with a new name, to avoid repeating on every attribute.
I wonder if the reason this was so that we can't just run the workManager through the nbogate? ;)
I wonder if the reason this was so that we can't just run the workManager through the nbogate?
I wonder if the reason this was so that we can't just run the workManager through the security manager. Just to avoid a race condition here.
I think all "else" can be removed.
I think all "else" can be removed
I find it kind of confusing.
In debug, please
In debug, please :-)
In debug, please...
I think that the call to vdsId should be removed from here.
I believe that the call to vdsId should be removed from here.
I think it's better to keep the call to vdsId (the vdsId is relevant for the cluster)
Nhinc specific thing here - I think we should extract this method under getProvideAndRegisterRequest(request) - to avoid duplication.
Nhinc specific thing here - I think we should extract this method under getProvideAndRegisterRequest(request) as we do in AbstractProvideAndRegisterRequest, and avoid the duplicate method calls here. Some of these methods would make the test clearer.
Nhinc specific thing here - I think we should extract this method under getProvideAndRegisterRequest(request) as we do in AbstractProvideAndRegisterRequest, and avoid the duplicate method calls here. Some of these methods would make the test clearer, and avoid duplication.
Why not just return getAnnotationFinder().findAnnotation(clazz, annotationClass, String[] groups)?
Why not just call the super.useConsideringValuesAndGroupValuesAndGroupValues(clazz, annotationClass, String[] groups) here?
Why not just call the other method via this one?
@paulodamaso the braces and return are not needed here
@paulodamaso use final String prefix = new String(prefix)
@paulodamaso use final
write(out) twice?
write(out) twice
write(out)
I'd drop this.
I missed this one before, but it's still needed.
I missed this on my previous review, but should should it be the return type?
can use metric == null
can call.setMetric(...).
can use metric
suggestion if (task!= null) { captureOutputsAndReEnqueueInternal(mockWallClockTime); captureOutputsAndReEnqueueInternalResults = null; }
suggestion if (task!= null) { captureOutputsAndReEnqueueInternal(mockWallClockTime); captureOutputsAndReEnqueueInternalResults() can be processed.
suggestion log.info("Due to the {} defined.", Streams.MAX_TASK_IDLE_MS_CONFIG, " + thread.getMessage());
After looking at the numa records around, I can see here. Shouldn't it be "start" and "end"?
After looking at the numa records around, I can see here. Shouldn't it be "start" and "end" together?
I think put the keys and values in them in a method. Have you considered to use them in the test too?
Please use a meaningful name for the variable name.
Please use toStringHelper(this.getReductionKeys()) here.
Please use a meaningful name for the variable.
why are we making this method public?
why are we changing this?
why are we making this package protected?
Since the screenMap is an\\\\ field, you should probably use the same representation of the map.
Since the screenMap is an\\\\ field, you should probably use the same representation of the map. These are more readable if you do this here.
Since the screenMap is an\\\\ field, you should probably use a final String or method for this class.
You can keep the message ("In the rule " + getClass() + ".
You can keep the message ("In the rule " + getClass() + " has an no support an no weightMultiplier"
You can keep the message ("In the rule " + getClass() + " has an no support an nokeystoreMultiplier."
I'm not sure if we can replace this lambda by lambda: () -> waitItemOnContexMenuIsNotVisible
It's better to name this method to waitProjectExplorerContextMenu()
I'm not sure if we can replace this lambda by lambda: () -> waitItemOnContexEnvironmentOnContexMenuIsNotVisible
idx => 0?
check if hasEvent() before casting?
check if hasEvent() before accessing the event
Hum seems we are already setting this listener
Hum seems we are already setting it entitientProvider.getAccountPropertyString(int) so I think we can make it more clear what it is instead of using the prefix.
Hum seems we are already setting it entitpicking
I think we're using "" instead of null here.
I think we're using String.format() here instead of initializing them.
I think we're using String.format() here instead of StringBuilder
no need for this?
inline?
not related to this change
It would be nice to log everytime a user is logged
It would be nice to log everytime a user is visible
It would be nice to log here if SpecialUserLogin is visible
Is it needed to use DEFAULT_PARTITION_TIMEOUT in a test?
Can we use DEFAULT_PARTITION_TIMEOUT as a constant?
Is it needed?
use execute i mentioned above
use execute i mentioned below
use execute i mentioned
Looks like both XmlSuite and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Looks like only a single XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Looks like both XmlSuite and XmlSuite could share this code. Maybe extract it in a common parseParallelMode?
java this.messageHandlingMetrics = Objects.requireNonNull(conn);
java this.messageHandlingMetrics = Objects.requireNonNull(conn, "'conn'");
java this.messageHandlingMetrics = Objects.requireNonNull(conn, "'conn'"));
toString() is unnecessary; I think we should use a StringBuilder here.
toString() is unnecessary; I think we should use a String here.
toString() is redundant here.
Not sure about this'syncSession'.
Logging involves disk removeSession() so the notify() method can be dropped.
Not sure about this one.
space between ) and {
space between  and {
tab
Wouldn't it be better to have a boolean parameter instead of a default value?
Custom
Custom?
We don't really need to use the Multimap, just use a Map.of.
We don't really need to use the Multimap, just use a List.
We don't really need to use the Multimap, just use a Map.
You can use fragment.setCallback(this, fragment, callback) here.
You can use fragment.setCallback(this) here.
You can use fragment.setCallback(this::createCallback); here instead.
We don't want to know when this happens - is there really a typo? I'd bee..
We don't want to know when this happens - is there really a need to change in the code? I'm fine with either way, just passing the old signature in as the constructor parameter.
We don't want to know when this happens - is there really a need to change in the code? I'm fine with either way, just passing the original ldLibraryPath in here.
Does it make sense to initialize this variable at the beginning of the synchronized block, and mark it final?
How about to rename it to "addedEval" or similar?
Does it make sense to initialize this variable at the beginning of the synchronized block?
I am confused with this. I have to read the code of the AbstractXAResourceRecoveryResource constructor now with something like that. I am not sure it is a good idea to have the option of the AbstractXAResourceRecovery constructor in the work. On the other hand, it seems strange to call the constructor to compute the precision of the property per-load.
I am confused with this. I have to read the code of the AbstractXAResourceRecoveryResource constructor now with something like that. I am not sure it is a good idea to have the option of the AbstractXAResourceRecovery constructor in the work. On the other hand, it seems strange to call the constructor to compute the precision of the properties
I am confused with this. I have to read the code of the AbstractXAResourceRecoveryResource constructor now with something like that. I am not sure it is a good idea to have the name of the instance.
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the list of commonParams and deployParams final.
If createParams should always have commonParams and commonServerParams, why not just define it that way to avoid duplication?
If create-liceLibertyMojoDeploy _deployArchivePath_ method can be reused.
I see it's better to create a test class that is responsible for creating MkGithub.class.
I see it's better to store it in a variable.
I see it's better to create a test class that is responsible for creating MkGithub.DEFAULT.
Remove useless assert
Remove useless assert (null == null).
Remove useless assert ;)
Maybe better to use the org.apache.commons.lang.FINE.
Maybe we should include the exception in the stack trace?
Maybe better to use the proper name for the exception message.
You need this to be thread-safe, should be thread-safe
why need this?
You need this to be thread safe.
should this be renamed into something like KeyProperties above?
should this be renamed into createKeyId?
should this be renamed into something like KeyProperties before
Should we log an exception instead of returning null?
Should we log an error instead of returning null?
Should we log an error if the rd is null?
You can use a assertEquals here
You can use a assertEquals here.
You can use a assertEquals here...
Utils.validateArg
Utils.validateValues()
Already generated code in create...
hmm, I wonder if TreeMap.putIfAbsent() should be enough here.
hmm, I wonder if the sorting would be better here.
hmm, I wonder if TreeMap.putIfAbsent() should be enough here?
Shouldn't the default value be GeomType.NONE?
Can you put the getDeclaredConstructor call in the previous line, and remove the unnecessary try-catch?
Can you put the getDeclaredConstructor call in the previous line and remove the unnecessary method
Probably should crash if bad format string
Probably want to crash if bad format string
Probably better to crash if bad format string
You don't have to create new VO from the group, just add getters.
You don't need this new VO as well.
You don't need this new method.
you can clean up here a bit if the log is deleted.
you can clean up here a bit if the log is interrupted.
shutdownQuietly()
Can we use primitive array here?
Can we use different naming conventions for variables? This sounds like an error.
Can we use different naming conventions for variables? This sounds like an array of blocks starting from 0.
Wouldn't the implementation of this method be more readable as something like java static final Set<String> annotationType = new org.jboss.weld.security.StreamImpl<String>(Collections.singleton(new org.jboss.weld.util.logging.warp")) );
Wouldn't the implementation of this method be more readable as something like java public Class<String> getAddress() { return annotationType.getQualifiers(); }
Wouldn't the implementation of this method be more readable as a strategy?
why not log.debug("Error during log {}", ex.getMessage());?
why not log.debug("Error during log {}", ex.getMessage());
why not use the log format of the log file?
It would be better to call logger.error("", e)
It would be better to define logger.error("Exception during logger.getMessage(), e);
It would be better to call logger.error(logger.isDebugEnabled(), message);
nit: update STANDBY to LEADER?
nit: update STANDBY to LEADEREdit.java
nit: update STANDBY to LEADER_IN_MUTED
Don't we need this?
I don't think this makes sense, since you already know the host manager. Please add the annotations for any usages of this class.
I don't think this is necessary anymore, because in the current implementation, it's called automatically when no storage is paused.
Simpler: return GaussianDistribution as null;
Simpler: return GaussianDistribution as early as possible instead of ternary operator.
Simpler: return GaussianDistribution as early as possible instead of storing errors in the constructor.
Do we want to make this method synchronized?
Do we want to optimize this? convertValue isn't an efficient operation.
Do we want to make this method protected?
I don't know the answer but can you please use String.format instead?
I don't know the answer but can you please use StringUtils.format instead?
I don't know the answer but could be null?
Any reason why these need to be separate methods?
Any reason why these need to be changed?
Shouldn't need to be a capital of this
suggestion OnmsTopologyVertex createActiveVertex()? new OnmsTopologyVertex() : new OnmsTopologyVertex(Objects.requireNonNull(id, "id is null"));
suggestion return new OnmsTopologyVertex(Objects.requireNonNull(id, "id is null");
suggestion OnmsTopologyVertex createActiveVertex()? new OnmsTopologyVertex() : new OnmsTopologyVertex(Objects.requireNonNull(id, "id is null");
not all listener
not allListener
not anymore
@erikdw MEManager in case of problems with linux system.logviewer-startup.lib?
@erikdw MEManager, as all users will use it as testSetup will now default to "HOME". Can you please make sure that storm is running?
@erikdw MEManager, as all users will use it as testSetup will now default to "storm".xml.
This does not support implementation details. In my opinion it should be implemented like this: class A { public static void on(ITestClass testClass) throws IOException { if (default method == null) { throw new UnsupportedOperationException("Method is not implemented"); } }
This does not support implementation details. In my opinion it should be implemented like this: class A { public static void onInstance(ITestClass testClass) throws IOException { if (defaultMethod == null) { throw new UnsupportedOperationException("Method is not implemented"); } }
This does not need to be implemented here
Should be: Assert.assertTrue(mView.addProperty("User should contain the same value");
Should be: Assert.assertTrue(mView.addProperty("User should contain the same value", property.getName())
Should be one line below
I think we should have a CUSTOM version here.
I realize this was also the case, but is CUSTOM at some point?
I realize this was also the case, but is CUSTOM
You can use this method the DOWN type in the SOFT_DOWN property since it is in multiple threads.
You can use this method but return SOFT_DOWN directly in the if-else statement
I don't think this method is good, but it can be private
Maybe for cases like this where the list is either empty or null?
Maybe for cases like this where the array is either empty or null?
Maybe for cases like this where the list is either null or empty?
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Some proxies may not grok the comma-separated headers; any reason you can't just do Cache-Control: no-cache here?
Isn't this backwards? :-)
Here we know the result, but I would like to use Optional
Here we know the result, but I would prefer to use Optional
Here we know the result can be null.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Is this reload really necessary?
I think the else statement should be inside the if statement.
I think the else statement should be removed (or at least log the exception)
I think the else statement should be removed (or at least log the exception).
Prefer StartStart.getId().longValue() instead.
Prefer StartStart and use that once.
Missing final
Do we need to check for -1 here?
Do we need this? It's not used outside of this class.
Can we change the implementation of TrackStatistics to keep this line?
I prefer message for all the exception messages.
I prefer message for all the exception
I'd prefer throwing a more meaningful exception here.
is this try catch needed?
this code doesn't look like a complete control of the runtime exception. Why not just throw the IllegalArgumentException?
this code doesn't throw a RuntimeException
override this variable
override this?
ignore?
I think it's safe to remove the local recovery info in the caller thread and return the stage.thenRun(() -> removeRecoveryInformation(internalId));
I think it's safe to remove the local recovery info in the caller thread and then return the stage.thenRun(() -> removeRecoveryInformation(internalId));
I think it's safe to keep the old code and return a CompletableFutures
entry
entry: entry
entry:Entry
This can be avoided by synchronizing on "output" of the metric. Then we can avoid the synchronized keyword and make it final.
This can deadlock if we are monitoring on the lock. The metric is not available via the ThreadSafe. Note that once this is called, we can remove the synchronized flag.
This can deadlock if we are monitoring on the lock. The metric is not available via the ThreadSafe. Note that once we are synchronization, we can remove the synchronized flag and access to the underlying channels.
can we add a throw exception?
can we combine these two lines?
can we add a TODO to specify this?
return object No?
return object == null?
return object here?
Shouldn't this be!isDeferJavaScriptLoading()?
Shouldn't this be: Framework.getService(ConfigurationService cs)
Shouldn't this be!isDeferJavaScriptLoading() && cs.isDeferJavaScriptLoading()?
how about threadFactory.shutdown() instead?
Can we have a try/catch here, and close it in the finally block?
how about threadFactory.shutdown() instead?
This should be bundles.getWorkbenchBundle()
This should be bundles.getTypeSignature().getBase().
This should be bundles.getWorkbenchBundle(class)
Could you use Objects.requireNonNull( tableName, " tableName") instead?
Could you use Objects.requireNonNull() here?
Could you please add a message for this exception?
should return false if the validation fails
should return true if the validation fails
should return false if the validation fails.
I would expect this method to be called EnvironmentUserId or something, so that it would be better to use the method startUser.getPhoneNumber()
I would expect this method to be called EnvironmentUserId or something, so that it would be better to keep this method. Just thinking if the endUser.getPhoneNumber() is null or not we can remove this check. I would expect this method to be called with the return value of sendUser.
I would expect this method to be called EnvironmentUserId or something, so that it would be better to keep this method. Just thinking if the endUser.getPhoneNumber() is null or not we can remove this check.
Can be private or package protected.
Can be private or package private.
Can be private or package-private.
I don't think it's very good to change the value of a JsonNode to also extract the value into the JsonNodeFactory.
I don't think it's very good to change the value of a JsonNode to also extract the value into the JsonNodeFactory
I don't think it's very good to extract the value into a field mapper in the case of a JsonNode JsonNode.
Is it necessary to filter on NT in the returned Map? If yes, I would prefer to use it only as return type.
Is it necessary to filter on NT in the returned Map? If yes, I would prefer to use it to store the result of a constant.
Is it necessary to filter the FQN?
We should not be using String.format with values as the key name. Add it here too.
We should not be using String.format with values as the key name. Add the String.format() method to AndroidSmartmeteringKeys
We should not be using String.format. There are a number of places in the code where Parameters is used.
Can you make this more specific by making applicationContext a member variable?
Can you make this more specific by making applicationContext a static member?
This should be a static member.
Would this method stop the rebalance as well? I can not see stop call here.
Would this method stop the rebalance as well? I can not see stop call below.
Would this method stop the rebalance as well? I can not imagine what is the time.
Can you just change the return type of this method?
Shouldn't this be member?
Can you just change the member variable to member?
I think it's possible to have some constants for these. <LINK_0>
I think it's possible to define a reference to <LINK_0> that get(long) should be re-used, but not the current reference.
I think it's possible to define a reference to <LINK_0> that get(long) should be re-used, but the above method is used.
Should we use Arrays.toString(micro) here instead of the toString()?
Should we include the toString() in the toString()?
Should we include the toString() methods that return String.toString(micro)?
Use the same logic as in add()
Use a for loop here
Use a map here
Use startsWith instead of contains.
Could you check if this is an Optional for performance reasons?
Could you check if this is present?
Can you rename this xpathFilter to xpathFilter
Can you rename xpathFilter to xpathFilter
Can you rename this xpathFilter to xpathFilter?
I don't think you need the second testNfsConnection method. It would be good to verify that the storage type is valid.
I don't think you need the isNotEmpty here. The testNfsConnectionWithValidMountOptions is already tested, and it never gets false.
I don't think you need the isNotEmpty here. The testNfsConnectionWithValidMountOptions is already tested, and it never returns false.
This can be simplified to: return Objects.equals(name, name);
Checking for null is not needed
Null-check
I think this code could be simplified to just selectedLayouts.isEmpty()
I think this code could be simplified to just selectedLayouts.isEmpty().
I would rename the list instead.
Why did we make this public?
Why did we make this protected?
Why did we make this create a singleton?
this is a bit complicated.
this is a bug, but the tests should not be reverted
this is a bug, but the tests should not do this.
could be simplified: specs = Arrays.copyOf(refsSpecs, specs);
could be simplified: specs.addAll(refsSpecs, specs);
could be simplified: specs = StreamSupport.stream(refs.spliterator(), false)
should use LogUtil.DEBUG_MODE_ENABLED here.
should use a logger statement instead of string concatenation
Should this be logged at error level?
Do not catch this, it's the exception and not the test case?
Do not catch this, it's the exception and not the test case
Do not catch all exceptions, can it be thrown?
please revert as well.
please revert changes
please revert.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(_class, false) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(_class, new Script(_class, getRequiredParamLong()), to avoid the null check.
unnecessary cast.
you can do this without creating the map.
unnecessary
Resource overflow
Why the underscore?
Resource Resource
Is this a bug fix? If it's not, I think it's better to ignore this condition.
Is this a bug fix? If it's not, I think it's better to ignore it.
I think this condition is not needed, right?
No space
No name
name
I believe we should be able to make this method final. We should be able to offer it.
I believe we should be able to make this method final if we are sure we want to detect the case.
I believe we should be able to make this method final. We should be able to offer the 'value' field instead.
+ NUM_STRING_ARRAY_STRING + NUM_STRING_STRING;
+NUM_STRING_LENGTH + NUM_STRING_ARRAY_STRING + NUM_STRING_STRING;
+ NUM_STRING_ARRAY_STRING + NUM_STRING_STRING + NUM_STRING_STRING;
log.debug instead.
log.debug instead of printout
Suggest LOG.debug instead.
It doesn't seem to throw an exception if imageId is negative.
Seems like this should be 'public static final'
It seems like this should be 'public static final'
I'm going to add targetNode.getClassesDir(TargetNode.getClassesDir(buildTarget, targetNode.getBuildTarget()) in the superclass. Would it make sense to rename targetNode.getClassesDir(TargetNode.getClasses()) to make sure that targetNode is the same as targetNode.
I'm going to add targetNode.getClassesDir(TargetNode.getClassesDir(buildTargetNode.getClassesDir( targetNode.getBuildTarget(), targetNode.getBuildTarget()) here
I'm going to add targetNode.getClassesDir(TargetNode.getClassesDir(buildTarget, targetNode.getBuildTarget()) in the superclass. Would it make sense to rename targetNode.getClassesDir(TargetNode.getClassesDir(buildTarget, targetNode.getBuildTarget()) to just use that
line 228 and line 223 are identical.
line 228 and line 223 are identical..
line 228 and line 223 are identical: setIfModelIsCached
I don't think we want to have a test for the second or two, since it's a clear what this indicates.
I don't think we want to have a test for the second or two, since it's a clear what this means.
I don't think we want to have a test for failure. You could call filter.onPerform(...) in a separate Runnable and have log the work.
Why the change? Let's keep the log messages logic in this method.
Why the change? Let's keep the log messages logic in this class.
Revert
consider a private constructor and extract the MarkupParser to a field?
consider making the field volatile so that there is no need to save each lambda call.
consider a private constructor
I would put this in another method: assertEquals(LineItem lineItemDraft lineItemDraft = AddLineItem(); assertEquals(LineItem lineItemDraft.of(lineItemDraft.of(lineItemDraft));
I would put this in another method: assertEquals(LineItem lineItemDraft lineItemDraft = AddLineItem(LineItem lineItemDraft.of(lineItemDraft.of(lineItemDraft));
I would put this in another method: assertEquals(LineItem lineItemDraft lineItemDraft = AddLineItem(LineItem lineItemDraft.of(lineItemDraft.of(lineItemDraft)) > AddLineItem();
You can use assertj's iterator.
You can add an assert to check if write == null
You can use assertArrayEquals
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects#requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null")
Can use StringUtils.fromUtf8()
Can use StringUtils.isBlank here.
Can use StringBuilder.
Honestly, I think we should use basic when exporting/import_type=none or something similar.
Make an extra final. here?
Make an extra final
Redundant parentheses
Redundant parenthesis.
Redundant.
Can we have a thread name here?
Can we have a start() method on the interface?
Can we have a thread name here? startDiscoveryService or something similar?
Please make a copy of the same class and use it in the constructor.
Please make a copy of the message to the class.
Please make a copy of the same class and use it here.
suggestion connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
suggestion connectionFactory.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
suggestion connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close() );
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "add" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> Make "child" a "Compile" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "child'"; it is deprecated. [![rule](<LINK_1>](<LINK_2>
Why not 'public'?
Why not INSTANCE?
Why not return timeSource?
use ShellIsAvailable
Is this the same as jboss.modules? or is it required to be there?
Is this the same as jboss.modules? or is it required to do this?
Conflict event creation here as well
nit: you can use the constant setLocation.currentBackupId here
nit: you can use the static field as it is reused
Check that the payment id is not null and you can both call getPaymentRefundsResponse.
Check that the payment id is an RefundsResponse. I think this should be removed.
There is a need for this before merging.
I'd have expected a return value at the top. Then you can just return JsFunction.equals(resultType) or even Boolean.FALSE in this case.
I'd have expected a return value at the top. Then you can just return JsFunction.equals(resultType) or even Boolean::parseBoolean
I'd have expected a return value at the top of this function. Then you can just return JsFunction.equals(resultValue) or even Boolean.FALSE in this case.
Is there a reason for this change? OutcomeParams seems to be only for internal outcomes, so it shouldn't be false too.
Is there a reason for this change? OutcomeParams seems to be only for internal outcomes, so it shouldn't be false
Is there a reason for this change? OutcomeParams seems to be only for maps that have a non-default behaviour.
Can be replaced by logging.
Can be replaced with logging.
Can be removed
You should use this variable rather than the it is _must_ be PreviewTransformedDataActionListener.
You should use this variable rather than the it is _must_ be LOADING_ActionListener.
You should use this method and the @FindBy annotation1.
I think this should be a check that the metric is a service metric
I think this should be a check that the metric is not null
I think this should be a check reference in the metric. We should only support the metrics prefix
Can we use Objects.hashCode here?
Should the interface be renamed to hash?
Can we use Objects.hash here?
I don't see this method being used.
I wonder if this can be static?
I don't see this method being tested.
Missing space between if and (
Missing space between ) and {
Throw an exception if it is not aactivemq.artemis.
I don't think this is the correct way to look for the icon theme here. This seems to be the one IImageState. Could you please undo this?
I don't think this should be changed to getName()
I don't think this is the correct way to look for the icon theme here. This seems to be the one IImageState or the descriptor?
Should use.error(String.format("Error: ", error));
Should use the Utils.validateError(String) method to show error.
Should use the Utils.showError method
It's hard to read. Could you please omit getOrDefault? It's also used in VoEntryManager on the line above
It's hard to understand why we need to call toString on both parameters. Could you please remove the line from the return statement?
It's hard to read. Could you please omit getOrDefault? It's also used in the line before getOrDefault
This method should be synchronized
This synchronized block should be removed
This synchronized block should be removed.
use Assertion.DOMAIN_SEPARATOR instead of "/file page opened"
use Assertion.assertContains instead of URLsContent
use Assertion.assertContains instead of e.g. ()
It looks like initializeRuleRuntimes should be initialized inside the initialize method, while returning the initializeRuleRuntimes, so it shouldn't be used anywhere else.
It looks like initializeRuleRuntimes should be initialized inside the initialize method, while returning the initializeRuleRuntimes, so it shouldn't be returning the initialize method.
It looks like initializeRuleRuntimes should be renamed to initializeRuleRuntimes, but here it is only used in initializeRuleRuntimes, so it should be renamed.
1 should be _nextTaskListener.onComplete(new Runnable() { @Override public void run() {... } });
1 should be done before the _nextTaskListener is _nextTaskListener_
1 should be _nextTaskListener_
This is a little peculiar - does the state represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
This is a little peculiar - does the position represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
This is a little peculiar - does the state represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the default interceptor to do this?
Could use Objects.requireNonNull(value, destRow).replaceInt(value, destRow).replaceInt(value); here.
Could use Objects.requireNonNull(dest, "destColumn is null");
Could use Objects.requireNonNull(value, destRow).replaceInt(value, destRow); here.
Why first the connect, then the check and disconnect?
static imports
suggestion "dummynetConnectionType.defaultType";
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable name: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they set the default fractions.
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>,%20java.nio.charset.Charset)
return Optional<ContributionItem>
return Optional<ContributionItem>?
Possible NPE here
Genre.getGenre() is an empty String. Can't we just call id3v2Tag.getGenre()?
Genre.getGenre() is an empty String. Can't we just call id3v2Tag.getGenre()?
Genre.getGenre() is an empty String. Can't we just call it something else?
It is better if we use here we want instead of \n, like this:\n\n" + "\n" //...
It is better if we use here we want instead of string concatenation.
It is better if we use here we want instead of \n, like this:\n\n" + " EOL, "\n"
It's the same class so we can probably remove that one.
It's the same class so we can avoid that.
It's the same class so we can probably remove that one by calling private final static.
if you have symbol already hasUnresolvedTypeHierarchy, you can get rid of this check and in the following would be enough: symbol.kind()!= Symbol.isUnresolvedTypeHierarchy();
if you have symbol already hasUnresolvedTypeHierarchy we wouldn't need to check if symbol is org.eclipse.egit.core.util.Objects.hasUnresolvedTypeHierarchy
if you have symbol already hasUnresolvedTypeHierarchy, you can get rid of FOO and BAR
This should probably be injector.getInstance(Resource.class);
This should probably be injector.getInstance(CONFIGURATION).getProperty("user.home")
This should probably be injector.getInstance( injector.getInstance(Resource.class));
I don't think there is a reason to use the loggers in the code here, let's have a consistent formatting.
I don't think there is a reason to use the camel case for the filter syntax, let's define what you're testing for
I don't think there is a reason to use the loggers in the code here, let's have this file as a debug message.
public
you must make sure that the list is mutable
you must make sure that this class is not empty
I know this is in the current PR, but can we make this final? It makes this a bit unclear why the change is needed?
I know this is in your current PR, but can we make this final? It makes this a bit unclear why the change is needed?
I know this is in your current PR, but can we make this final? It makes this a bit easier to understand.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "close" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "getMeasured" method. [![rule](<LINK_1>](<LINK_2>
Is this the right way to do that?
I think it would be better to have a more specific error message here. Can we have a more specific message?
I think it would be better to have a more specific error message here.
I think it would be better to have a more specific error message here. For example, LOG.error("Unable to execute process. It is {}", e.getMessage());
add a lock to the service
add a lock
send service service service
Why did we change to partial match here instead of whole string match?
Quality tools will complain about that statement because the string is not constant.
Quality tools will complain about that statement because the string is not no string match.
I think using StringBuilder here is cleaner.
I think using StringBuilder here is not necessary.
I wonder if this should be an output stream.
Might want to have a WATCH_LIST_FILTER_REGEX as a default value.
Might want to have a private static final
Might want to have a private static final String
should it be the public API?
Can we have the public static methods at the beginning?
Shouldn't we have the <String, int> here?
Can we make this a static method in the parent class?
nit: "chunkSize" -> "file.seekPositiveOrero(offset)."
Can we make this a static method in the class? This should be limited to what it is.
please use AssertJ.
please use AssertJ.assertNull
please use assertEquals for the error message
.exceptions(CHECK_NAME)
Line too long.
CheckForNull
I think we can remove this line. Since it will be true in the default form instead of setting properties.
I think we should skip the defaultReplicationFactor!= null check. Since it will never be false, we can skip this check.
I think we should skip the defaultReplicationFactor!= null check. Since it will never be false, the logic will be easier to understand and maintain here.
I feel like this should be else if (public_retentionPolicyMgr!= null) { RetentionPolicyMgr.updateThreadPoolSize() }
I feel like this should be else if (public_retentionPolicyMgr!= null) { RetentionPolicyMgr.updateThreadPoolSize(); }
I feel like this should be else if (public instanceof RetentionPolicyMgr) {... }
rename to listener
rename to listeners
rename to action
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need any code duplication.
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to null. And in that case, we don't need any code duplication.
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to null.
Is it possible to avoid using WaitUtils.sleepQuietly(1); here?
Is it possible to avoid using WaitUtils.sleepQuietly(1);
Is it possible to avoid sleeping here?
suggestion final RecyclerView parent = ( RecyclerView) view;
suggestion final RecyclerView parent = RecyclerView.Adapter.onCreate(View view);
suggestion final RecyclerView parent = ( RecyclerView) view.getChildAdapterPosition(view);
This should be set to something like: java final PayForOrder UnresolvedInfo = PayForOrder.newBuilder().build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command =
This should be set to something like: java final PayForOrder UnresolvedInfo = PayForOrder.newBuilder().build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command =
This should be set to something like: java final PayForOrder UnresolvedInfo = PayForOrder.newBuilder().build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command = request.build(); final PayForOrder command = (BillingInfo) request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.build(); final PayForOrder command = request.getBillingInfo().build(); final PayForOrder command =
The order of the arguments is reversed - it should be assertEquals("Test_scripts", result);
The order of the arguments is reversed - it should be assertEquals("Test_scripts, expected", result);
The order of the arguments is reversed - it should be assertEquals("Test_scripts, expected", "", result);
Assert.notNull()
Assert.notNull()?
Assert.isNotNull()
I think we should use AbstractAsProvider.class::isInstance instead of getClass() here
I think we should use parameterMethod.getAnnotation( as == null) instead of newInstance which will return the Description.class...
I think we should use AbstractAsProvider.class::isInstance instead of getClass() here (in order to be consistent with ReflectionUtil)
Use braces for each block for clarity.
Use braces for each block for loop.
Use braces for all of these
You could use IOUtils.toString() or just use a try-with-resources
You could use IOUtils.toString() or just use try-with-resources
You could use IOUtils.toString() or just use IOUtils.toString() here.
I think you should use the positional parameters.
Maybe you should use the positional parameters.
I think you need to use the positional parameters.
I'm not sure about this. @daniel-beck proposed a PR and I'm fine with changing this to: @Override public boolean verifyCheckpoint(Set<Container> containers) { return containers.isEmpty()? containers.get() : containers; } @Override public boolean verifyCheckpoint(Set<Container> containers) { return containers.stream().allMatch(Container::isCheckpoint); }
I'm not sure about this. @daniel-beck proposed a PR and I'm fine with changing this to: @Override public Iterable<Container> getCheckpoint(Set<Container> containers) { return containers.stream().filter(c -> c.equals(c)).collect(Collectors.toList()); }
I'm not sure about this. @daniel-beck proposed a PR and I'm fine with changing this to: @Override public Iterable<Container> getCheckpoint(Set<Container> containers) { return containers.stream().filter(c -> c.equals(c)).collect(Collectors.toList()); }
Use AssertJ please
Could you use rcForceReturnFS here?
Use assertThat()
This is a bit weird. In blob, layers of disk stores are either enabled or healthy. What about the rest of them?
This is a bit weird. In blob, layers and disk are used per layers. It should be a named method.
s/public//
Style-nit: Remove the unnecessary brackets.
Can the delete of the doc be null?
Can the doc be null?
Can it be just a static member of this class? And use it from the other package as well.
Can it be just a static member of this class?
Can it be a static member?
This should be done in a finally block
This should probably be done in a finally block
This should also check if the path is a string.
Could you remove the toString() here?
Could you remove the toStringHelper method?
Could you remove the ToStringHelper#toString() here?
Remove all "null" cases. There is a default case for that.
Remove all "private" cases. There is a default case for that.
Looks like you will always need switch? What did you mean?
This method needs to be synchronized.
This method is called from the previous line (at least in the case). It does not look right.
This method is called from a thread pool (at least in the PR) see how the client works with a non-zero random number (not exactly the timestamp)
nit: remove
I would suggest debug level logging here.
nit: debug
Can you use the test method _verifyClient_ instead of the magic number?
Can you use the test method util.getTestConfiguration() instead of the magic number?
Can you use the test method _assertThrowsCacheMode.OFFrod_ and 1 here?
So, you can rename prvdr to pvdr or pvdr to make it clearer
So if you make this a method, you can simplify the code by pvdr == null || prvdr.isEmpty() == 0).
So, you can rename prvdr to pvdr or pvdr.
This should be better: FileSnapshot save = new FileSnapshot(read);
This should be better: FileSnapshot save = System.currentTimeMillis();
This should be better: FileSnapshot save = new FileSnapshot(File);
Why has this been added? A struct { } should have been removed?
Why has this been added?
Why has this been added? A struct { } should have been added.
Don't add this here, it'll be a good idea to log the field in every operation.
Don't add this here, it'll be a good idea to log the field in every call.
Don't add this here, it'll be a good idea to log the field in every operation in the map when debugging.
All web contexts should be sessionAttributes instead of sessionAttributes.
You can change all web contexts to protected and use Objects.equals instead of ==
You can change all web contexts to protected and use Objects.equals instead of ==.
nit - There should be a DEBUG log here.
nit - There should be a space before the &&.
Please remove diagnostic modifications to roles here.
NonNull?
return "" +
return ""
Can you use the new LANG_getNamespace(Class) method instead?
Can you use the new LANG_getNamespace(Marshaller)?
Can you use the default constructor?
This is the correct message, the blurred message is for retreived as 'getSnapshot://bucket/requests/src/main/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java
This is the correct message, the blurred message is for retreived as 'getSnapshot://bucket/requests/src/main/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/eclipse/che/core/src/test/java/org
This is the correct message, the blurred message is for retreived as 'getSnapshot://bucket/requests/src/main/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/src/test/java/org/ovirt/engine/core/OpenShift/Build.java
This is a lot of duplicated code. It might be worth creating a private method that returns a boolean, and slightly rid of this duplication.
This is a lot of duplicated code. It might be worth creating a private method that returns a boolean, and the name of the function could indicate that this is the same as the field name.
This is a lot of duplicated code. It might be worth creating a private method that returns a boolean, and the name of the function could indicate that this is the same as the field used in the constructor.
I doubt this can be true, also if the assertion on the content is the same as the command, right?
I doubt this can be true, is it always true?
I doubt this can be true, also if the assertion on the content is the same as the command.
this is 3.3 feature, not 3.2
this is 3.3 feature, not 3.2?
this is 3.3 feature
synchronized -- this class is thread-safe and guaranteed happens-before-stop mode although it seems possible if someone is invoking this method.
This class is thread-safe and synchronized. boolean methods used in this class
This class is thread-safe and synchronized could be used here
Change to: "Finished Pending Tasks are already in the next line."
Change to: "Finished Pending Tasks are already in the next iteration."
Change to: "Finished serialiser for the entire job"
Is this kind of thing done elsewhere? Seems a bit unusual but won't debate it if that's how we treat other exceptions.
Is this kind of thing done elsewhere? Seems a bit unusual but won't debate it if that's how we treat other people.
Is the initial state of the stack trace done by the caller? Seems like an error to me if I'm wrong.
Wouldn't it be better to change variable name to non-null?
Wouldn't be better to change variable name to non-null?
Wouldn't it be better to change variable name to non-default?
It's beeter to used int type.
It's beeter to used int type
It's beeter to used int
Why do you need this synchronized?
Why do you change the synchronized block?
Make it debug
Use a typed method here.
Use a typed method here?
Use a typed method here
I would prefer for (int i = 0; i < matcher.length; i++) { }
I would prefer for (int i = 0; i < raw.length; i++) { }
I would prefer for (int i = 0; i < matcher.length; inetAddressStringRepresentation
concurrency issue too
shouldn't be initialized to an empty map?
shouldn't be initialized at the constructor, I think
Isn't this more simply: java return State.UNSET.getState() == State.UNSET;?
Isn't this more simply: java return State.UNSET.getState() == State.UNSET && a!= State.UNSET;
Isn't this more simply: java return "true".equals(UNSET)?
MaxwellFilter has a test cases for these two
MaxwellFilter is a test, so this should be asserted that there are cases without these three
MaxwellFilter is a test, so this should be asserted that there are cases without these two.
Please don't swallow exceptions. The test will fail anyway if an exception is thrown on this line.
Remove this catch block and replace with: Lib.exec(system.bin/sh)
Remove this catch block and replace with: Lib.exec(system.bin/sh).
Should be synchronized
Should be locked too
Should be deleted
Can you include this log message.
Can you include the exception in the log message.
Can you include the exception in the log statement?
Add a note about how it works.
Add a note about how it works with this condition.
Add a message
Maybe we should rename this to storeToManyRelationSystem.
Maybe we should rename this to storeToManyRelationDatabase.
Maybe we should rename this to storeToManyRelationShip.
Why should this be asserted?
Why should this be patientToAdd and not patientToAdd?
Why should this be check in the patient id?
Log debug - not info.
typo: not clear -> has
typo: not supported
Use try-with-resources.
Use try-with-resources
No need to catch checked exceptions.
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on what the intention is to say?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention? If that's not true, then can you elaborate on the naming convention?
Can be replaced by Collections.emptyList()
This can be replaced by Collections.emptyList()
this can be replaced by Collections.emptyList()
I'd convert this method into a static method isExcluded(excludedGroups, groups) and having the constructor do the check for it.
I'd convert this method into a static method isExcluded(excludedGroups, groups) and having the constructor do the trick.
Maybe we could convert this method into a static method isExcluded(excludedGroups, groups) and call that method in that constructor.
This code is deeply nested. The code above can be simplified to this.stat = ((channel.stat) this.channel.stat) & this.channel.getHome();
This code is deeply nested. The code above can be simplified to this.stat = ((channel.stat) this.channel.stat); return false;
This code is deeply nested. The code above can be simplified to this.stat = ((channel.stat) this.channel.stat) & this.channel.stat;
This will do the same thing as vmwareVmImplementer.implementer The The VmwareVmImplementer should be removed completely here.
This line is not needed anymore (vmwareVmImplementer should be removed manually)
This will do the same thing as vmwareVmImplementer.implementer The The VmwareVmImplementer should be a good name.
should we use logEntry in the property here too?
should we use logEntryStirng with help of this.
suggestion logPutCountsPeriodically, messageSetToWrite);
Please, use text "projectName" (Name was fixed after sending this pool request) thank you.
Please, use text "projectName" (Name is missing after sending this pool request) thank you.
Please, use text "projectName" (Name is missing there after use of this name). There is no need to be changed too.
This can also be made static
This can be made static
This test is also duplicated below.
Is it sufficient to keep an instance of DefaultAWSCredentialsProvider() and keep AWSCredentialsProvider() for null as well?
Is it sufficient to keep an instance of DefaultAWSCredentialsProvider() and keep AWSCredentialsProvider() for all of this?
Is it sufficient to keep an instance of DefaultAWSCredentialsProvider() and keep AWSCredentialsProvider() for null?
click on element
click on element is not reliable
clickAndClick()
Not sure that this is the best way to test this.?
Not sure that this is the best way to test? :(
Not sure that this is the best way to test? :D
This method should not throw an Exception.
This method should not be changed.
This method should not throw an species.
Please use AnonymousSpec instead of this.
Please use AnonymousSpec which is general.
Please use AnonymousSpec which contains this pattern.
nit: I would move this line to the top of the method, so we don't have to use separate lines?
nit: I would move this line to the top of the method, so we don't have to use separate lines?
Should we be binding these to constants? Parameters are a bit dangerous to me.
It's better to use static import here to improve readability of code.
It would be better to use static import here to improve readability of code.
It's better to use static here to improve readability of code.
Why not String.valueOf(label)?
Should be String.valueOf(label)
Why not String.valueOf(label)?
Don't need to print the stack trace.
Don't print the stack trace of the test.
Don't print the stack trace, as those exceptions are not thrown
you can call endSuccessfully directly
you setSucceeded to true and then endRemoveEntity()
you setSucceeded to true
Let's make it a factory.
Let's make it a constructor, and use it here.
Let's make it a constructor, and use it here and below
extract as a constant
extract this as a constant
final
I would prefer to have the same size as the result. java when(result == null) { result = stageSqlMapDao.getAllDistinctStages(); }
I would prefer to have the same unit tested methods again, and verify if the result is the same as the expected result.
I would prefer to have the same size as the result. java when(result == null) { result = stageSqlMapDao.getAllDistinctStages(expectedResult); }
Why is this needed?
Why is this needed? It's already part of the static import.
Why is this needed? It's already part of the static method and the called-then-else block below.
You shouldn't depend on the prefixFormat and it should go there.
You should go by MaskValidator.getInstance().isPrefixValid(mask).
You shouldn't depend on the prefixFormat and prefix here. This is not valid.
I'm not sure there is too many problems with generating an executor here. At this point if the operation is too big and the timeout is too big.
- Do we really need to timeout here? - There's nothing wrong with it...
I'm not sure there is too many problems with generating an executor here. At least the ones where the server is running.
Remove this.
Remove this. And why are we doing it here?
Remove public.
Remove
Remove this.
Redundant qualifier
Nitpick: I'd prefer this. localId = localBlogId == null? null : localBlogId; That way it's clear above.
Nitpick: I'd prefer this. localId = localBlogId!= null? localBlogId : getLocalTableBlogId();
Nitpick: I'd prefer this. localId = localBlogId == null? null : localBlogId; That way it's truly a bit more readable.
Should this be removed?
Will this cause NPE? Should we log an exception?
Will this cause NPE?
The containerIDs here should be removed, not deleted.
The containerIDs here should be removed, right?
the containerIDs here are not used right?
Maybe rename this to cause it's not clear what this is doing
Maybe rename this to cause it's not clear the list.
Maybe this should be in a finally block?
Please use spaces
nit: space after if
nit: spaces around ==
Shall we throw an exception in this case?
Shall we throw an exception in getName() for this case?
Shall we throw an exception in this case? And please add error message to the user
Please not do that, check right now and open another PR.
Please remove empty line.
Please not do that, check right now and use isEmpty() instead.
Rename -> CosmosDbFactory to CosmosFactory
Rename -> CosmosFactory to CosmosFactory
Rename -> CosmosDbFactory
Can we just do this?
s/type/index
s/type/index/
Is it the only place these methods are used?
Is there a reason to use addAll()?
use addAll
Why does the handler require a zkController, task concurrent cleanly? Same for the other one.
Why does the handler require a zkController, task concurrent? Same for the other one.
Why does the handler require a zkController? Same for the other one.
Use.orElse(atomic.Atomic() + delta
Use.orElse(atomic.Atomic() + remove)
Use.orElse(atomic.Atomic() + remove) instead of calling it twice
IMO you should extract this line as a separate method getCheckCheckValueAndScanIncludes(actionBuilder)
IMO you should extract this line into a separate method getCheckCheckValueAndScanIncludes(actionBuilder)
IMO you should extract this line as a separate method with two parameters
return strMessage.startsWith("")
return strMessage;
could you replace this with a constant?
why the two lines above?
why check for null?
why not ccmd.userDefined?
this should be activateEntries.put(entry.getKey(), entry.name());
this should be activateEntries.put(entry.service, entries.name).
this is already done in line 119.
I know this is just a nitpicking, but this method is not actually thread safe, so there is no need to check if the connection is closed.
I know this is just a nitpicking, but this method is not actually thread safe, so there's no need to check if the connection is closed.
I know this is just a nitpicking, but this method is not actually thread safe, so there is no need to check if the connection is already closed.
Pair<String, String>?
Pair<String, String>?
Pair<String, String> will be cleaner
This is not really a good idea. If you have a MetaDataUtil you can use the default one, but you don't need to keep it
This is not really a good idea. If you have a MetaDataUtil you can use the default one, but the actual value is null
This is not really a good idea. If you have a MetaDataUtil you can use the default one, but you don't need to create a new IndexType.
Please add a space before the.
Please add a space before the )
Please use File.toURL() here
You can use [public static final](<LINK_0>,%20java.lang.String...)) to make these tests more readable.
You can use [public static final](<LINK_0> here, I think.
You can use [public static final](<LINK_0> here,and below.
Minor: try-with-resources
Name preparedRead..
Name preparedRead.
why public?
why public? I'd remove this method.
Move this to the end of visitCheckConstraint?
add braces
add final
add this check
If you are using open() method, then you don't need to wait the element at all.
If you are using open() method, then you won't need to wait the element at all.
If you are using open() method, then you don't need to wait for it to work.
Static import AbstractCheck in AbstractCheck.
Static import AbstractCheck.class
Static import AbstractCheck.Type
Why do you make this query a string? Isn't it a cron expression?
Why do you make this query a field?
Why do you use the projection here?
why the cast to long?
why public?
why the await.actionGet()?
please rebase, arik removed the lock in a different patch.
please rebase, arik removed the lock in a different patch
please rebase, arik removed the lock
I'm not sure if this is a good idea. If anyone specified the field, we should set it to null. I would just set it to the empty string and then set it to null.
I'm not sure if this is a good idea. If anyone specified the field, we should set it to null as a default, not any more. In which case, the web UI will just be set to null.
I'm not sure if this is a good idea. If anyone specified the field, we should set it to null. I would just set it to the empty string and then set it to null. It would be a lot more clear
Can you please merge this into the if condition?
Can you please merge this and the next Long lines in a single method with the following and make it shorter.
Can you please merge this and the next tab with the else?
fNumericCompilerSuffixes can't be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the get method.
fNumericCompilerSuffixes can be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the get method.
fNumericCompilerSuffixes!= null? CharArrayUtils.EMPTY : numericCompilerSuffixes;
return valueOf(paramName);
return valueOf
return valueOf(paramValue);
Typo: SamzaException
Typo: UnsupportedOperationException
Typo?
This looks like an IllegalStateException.
Why don't we use buildContext() instead of buildContext()?
This looks like an exception.
Please use the SecurityBindAddressResourceDefinition.BIND_PORT" attribute instead.
Please use the SecurityBindAddressResourceDefinition.BIND_PORT" + ".get";
Please don't change this, it's incorrect.
Is this the intended version?
Is this the intended behavior?
Is this the intended version? You could just use the version.
This could do a ofNullable(WorkflowInstanceAction.getWorkflowInstanceWithCTE() + "childWorkflows can not be null");
This could do a containsKey() check
This could be a ofNullable, right?
Eliminate this constant and use the int version to indicate what's being cast to (int) or store a Map<String, int>.
Eliminate this constant and use the int version to indicate what's being passed to the Map<String, Integer>.
Eliminate this constant and use the int version to indicate what's being cast to (int) or store a Map<String, int> in a final field.
For this should also be applied to the Href() method, not the id.
For this should also be applied to the Href() method of the model.
For this should probably use the [internal API](<LINK_0> pattern instead.
This should include Ds3ApiSpec in the name.
This should include Ds3ApiSpec in the error message.
Missing final
Revert
Should this be false?
Rethrow it?
please check here isSetPmProxies() otherwise you can get NPE
please check here isSetPmProxies() otherwise we can get NPE
please check here isSetPmProxies() otherwise you could get NPE
Why not make the test timezone-independent by either calculating the correct long value for "2015" and "16)" value?
Why not make the test timezone-independent by either calculating the correct long value for "2015" and "intraHex" value?
Why not make the variable final?
You may want to log the layer name as well.
You know what type of layerName it is?
You may want to log the layer name as well?
This test doesn't check the actual result.
This test doesn't check the following.
This test doesn't check the actual result of the call.
Fix indention (should align with following code).
Please add a check to check if the password is blank.
Please add a check to check if the service is blank.
Objects.requireNotNull(oldValue);
Redundant cast.
Objects.requireNotNull (We're for a version that doesn't accept null values).
Check with suite == null
Check with suite!= null
Check for null
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "access" method. [![rule](<LINK_2>](<LINK_0>
same here, can we bring the field visibility right away?
same here, can we use a final field instead of creating the field?
This can be done outside the synchronized block. A better approach would be to initialize sourceDataTypeMap once it has been initialized.
This can be done outside the synchronized block.
This can be done outside the synchronized block. A better approach would be to initialize sourceDataTypeMap once it has returned.
Looks like this one is duplicated.
Looks like this PR is duplicated.
Looks like this PR is duplicated from above
Please change log.debug("Argument 'username' cannot be empty", e) instead of query.toString()
Please simplify this log.debug("Argument 'username' cannot be empty", e);
Please change log.debug("Argument 'username' cannot be empty", e);
Should this be private?
Why not private?
Why not this change?
does it mean that the return is not in the middle of the method? if so, don't we want to check the return value?
1. do we need this? if the method is called with the old version? null?
toString
Please add the test (just in case you inline the method)
Please add the test (just in case you inline this diff)
Please change this test to simply remove the throws statement.
But why do we handle 400 differently than all other errors?
But why do we handle 400 differently than 400?
But why do we handle 400 differently than 403?
I don't think we should use reset() here. It should be reset() by init().
I don't think we should use reset() here. It should be reset() by init()
I don't think we should use final for anything
We should close the client in a finally block.
if (t!= null) dbClient.shutdown()
if (t!= null) dbClient.shutdown();
I think it should be wrapped in a try/finally block, to avoid the double-assignment of the session when the lock is held.
I think it should be wrapped in a try/finally block, to avoid the double-assignment of the session before the lock is acquired.
I think it should be wrapped in a try/finally block, to avoid the double-assignment of the session before the lock is held.
Could you add another enum instead of multiple values?
Could you add another enum type for this function?
why is this line a duplicate?
why not just return toolVersion.parallelStream().map(toolVersion -> { List<ToolVersion> toolVersions =.map(c -> c.getVersions(toolVersion.getV1(i)).collect(Collectors.toList()); return toolVersions.get(); }).collect(Collectors.toList());
why not just return toolVersion.parallelStream().map(toolVersion::getVersionsV1(i)).collect(Collectors.toList());
why not using a stream and avoid the parallelStream?
I guess you forgot to change the one above to a ternary expression.
I guess the ACADE should be our own AbstractACADE as well.
I guess the +"]", ;-)
Would it be worth adding a comparison to the messagesPerPackage (or simply adding the AnalyzerMessageReporter for this case)? It will also avoid the crash on line 195 with the messagesPerPackage (when that might be a separate method for this).
Would it be worth adding a comparison to the messagesPerPackage (or simply adding the AnalyzerMessageReporter for this case)? It will also avoid the crash on line 74, and it will break on AnalyzerMessageReporter.
Would it be worth adding a comparison to the messagesPerPackage (or simply adding the AnalyzerMessageReporter for this case)? It will also avoid the crash on line 195 with the messagesPerPackage (when that might be a separate method).
I think a better implementation would be to use a regular expression: return findById(type, count(type)).or(HUtils.findById(type))
I think a better implementation would be to use a regular expression: return findById(type, count(type)).or(HUtils.findById(type, "type"))
I think a better implementation would be to use a regular expression: return findById(type, count(type)).or(HUtils.findById(type, "type");
We can just use the evictExpiredTokens method from the config.
We can just use the evictExpiredTokens method from the configuration.
We should drop the check here.
If this is called from multiple flowIds, can you make it private?
If this is called before flowIds, wouldn't it be better to use the return type?
If this is called before flowIds, wouldn't it be better to use a StringBuilder?
rename to eventDelta
Move to the previous line
needs to be &&
Use this.key
Use this.key instead of the hard coded value.
Use the constants in Keys.SPAWNER_*
Hmmm... I feel that this could be easier: sceneOpaque = new WorldRenderer(sceneOpaque); sceneOpaque = new WorldRenderer(sceneOpaque);
Hmmm... I feel that this could be easier: sceneOpaque = new PerformanceMonitor(sceneOpaque()); bind(sceneOpaque, sceneOpaque);
Hmmm... I feel that this could be easier: sceneOpaque = new WorldRenderer(sceneOpaque); sceneOpaque = new WorldRenderer(sceneOpaque());
Assert.assertEquals(DeploymentException.getMessage(), "Bean class cannot be null");
Assert.assertEquals(DeploymentException.getMessage(), "Bean class has decorators decorators.");
Assert.assertEquals(DeploymentException.getMessage(), "Bean class has decorators decorators");
Extra line.
Extra line 228.
Extra line
why not use the primitive type?
why not return message?
why not use the primitive boolean?
The query modifies the map passed as a parameter? Depending on how the query is called (from inside the backend? from the frontend via seiralization?) it may cause unintuitive behavior at best, and inconsistent behavior at worst. Why not get a Set<DiskImage> of the IDs (like this change)?
The query modifies the map passed as a parameter? Depending on how the query is called (from inside the backend? from the frontend via seiralization?) it may cause unintuitive behavior at best, and inconsistent behavior at worst. Why not get a Set<DiskImage> of the IDs (like this approach)?
The query modifies the map passed as a parameter? Depending on how the query is called (from inside the backend? from the frontend via seiralization?) it may cause unintuitive behavior at best, and inconsistent behavior at worst. Why not get a Set<DiskImage> of the IDs (like this approach?). In any case, you have to check the DiskImage instance before calling getAncestor.
Please, add // GIVEN WHEN/THEN structure.
Please, do not add the 'final' keyword.
Please, do not add the 'driver' parameter.
Let's replace this with org.apache.dubbo.common.utils.Utils
Let's replace this with org.apache.dubbo.common.utils.Utils#closeQuietly
Let's replace this with org.apache.dubbo.common.util.StringUtils#containsIgnoreCase
The logic to this method should be moved to SaxonXPathRuleQuery::getRuleQuery
I would use SaxonXPathRuleQuery::getRuleQuery("") here.
I would use SaxonXPathRuleQuery::getDialect(String) here.
Unneeded parenthesis
rename to pm
Unwrapping the code is not needed.
It should return ReadOnlyArray instead of ReadOnlyArray.
It should return ReadOnlyArray not ReadOnlyArray.
It should return ReadOnlyArray not ReadOnlyArrayInterface.
@rui-castro why do we need this?
@rui-castro why do we need to use bytes here?
@rui-castro why do we need to use UTF-8 here as well?
As per this patch, we need to keep this if/else, could we put 'if' body on a separate line.
As per this patch, we need to keep this if/else block.
Please test this method. It's not much clearer when we try to rewrite this method to call some method on a parent.
I think this should be named "mobile_remnant" or "mobile_remnant"
I think this should be named DATA_CTX_Appended.
I think this should be named DATA_CTX_Appended, as well.
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction(...)?
Shouldn't this be new Fraction( t ) instead of new Fraction( 1, 64 ) here?
This should not be needed. If the event handler is a set, it returns true, so the value will not be evaluated too.
This should not be needed. If the event handler is a set, it returns true, so the value will not be set.
This should not be needed.
Maybe add a message that is not convenient for this method?
Maybe add a message that is not supported for this reason?
Maybe add a message that is not convenient for this operation?
Space before {
Space after if
Braces
I think we should just throw a RuntimeException here.
I think we should throw a RuntimeException here.
I think we should just log on stdout and stderr.
This class isn't proxy, so, why is this object called other than the previous object?
This class is written in HashCodeBuilder, so you can just use this.title == this.title
This class is written in HashCodeBuilder, so you can just use the class object directly.
Isn't it more efficient to call runDisposeListener on the runnable?
DisposeEvent should be done either. You should block the runnable or use a lambda to the runnable
Isn't it more performant to directly call run()?
Can you assert both are null?
I think this should be marked as private and called by both constructors.
Can you assert here that both are null?
Should we move this in ScalaMojoSupport parent and avoid code duplication?
Should we move this in ScalaMojoSupport class?
Should we call this in ScalaMojoSupport parent and avoid code duplication?
Just make this comparison, and use FlexTable.setText("titleBar")
Just make this comparison, and use FlexTable.setText("id")
Just make this comparison, and use FlexTable.setText("titledev")
@ivandalbosco Why not using superTree?
@ivandalbosco Why not using superTree?
@ivandalbosco Why not use superTree?
We can use Arrays.asList(customProps) here
We can use Arrays.asList() here
We can use Arrays.asList(customProps) here.
Why not use the constructor of HarlequinEffect?
Why not use the constructor?
Must be Outcome.Benefit to keep good card
Do you think it'd make sense to initializeMetric(final MetricsFile, final MetricsFile existing) constructor with a default value? I don't see any tests where it's explicitly created.
Do you think it'd make sense to initializeMetric(final MetricsFile, final MetricsFile existing) here? I thought the "default"'s usage is a bit too general.
Do you think it'd make sense to initializeMetric(final MetricsFile, final MetricsFile existing) constructor with a default value? I don't see a reason why it's called from two places.
Format this file.
Format this line.
This should return an int.
This line can be replaced with: return Collections.singleton(new HashSet<>()
This line can be removed.
This line can be removed as well
I would like to check that the result is not null before executing the operation
I would like to check that the result is not null before executing the operation.
I would like to check that the result is not null before going to match it.
please verify response on remove()
please verify response on create()
please verify response on 'actioin' (not sure what you want)
I think this should be moved into the doStoppable method.
I think this should be moved into the while loop as it was before
I think this should be ws
Aren't you supposed to use different defaults in the case where the min is used?
Aren't you supposed to have a new method for this?
Aren't you supposed to use different defaults for this?
Command name should not be the command.
Command name should not be capitalized.
typo.
You are using a putIfAbsent rather than putIfAbsent.
you are using the put method here.
you are using the put method here. I think this is no longer necessary.
use String.format instead of concatenation
use String.format instead of string concat
'String' (<LINK_0>
Shouldn't this logic be part of perEnvironmentChannelGroupUpdater?
Shouldn't this logic be part of the perEnvironmentChannelGroupUpdater implementation?
Shouldn't this logic be part of perEnvironmentChannelGroupUpdater(Publisher)?
You can use assertEquals()
You can compare the whole object instead of the real one.
You can compare the whole object instead of the raw one.
This variable should be removed.
We can move this logic to a private method please
This variable should be removed at line 54
this is going to always return a list. I'd use append instead of manually building the response body.
this is going to always return a list. I'd use append instead of manually adding the body.
you can use ImmutableUtils.EMPTY_LIST; otherwise you'll have to map the items twice (and then create a new list)
This test looks strange to me. I think I would prefer to use a mock instead of another test.
This test would be better if we use a test for both methods
This test would be better if we use a test for both methods?
s/public//
nit: s/public//
nit: can be private, and remove the final modifier.
Can we move the check to only if (sharedIDEContext == null) line?
Can we move the check to the original if (sharedIDEContext == null) line?
Can we move the check to the original line?
Could we add a util method CacheCollection<V> explicitFlags = new CacheCollection<V>(explicitFlags, explicitFlags);
Could we add a util method CacheCollection<V> explicitFlags = new CacheCollection<V>(explicitFlags, explicitFlags, explicitFlags);
Could we add a util method CacheCollection<V> explicitFlags = CacheCollection<V>?
Ditto re: operation -> operation.perform(aggregate)
Ditto re: operation.perform(aggregate)
Is this for your rejoin? Or am I missing something?
This plays the current, not the next station.
This plays the current, not the current, not the next station.
This plays the next station.
We should keep the same format as the method static <LINK_0>
We should keep the same format as the method static
We should avoid the same thing about a static method.
@antonini you can use RqFake and use Tv.TEN instead.
@antonini you can use RqFake here instead of cors.class, see checkstyle
@antonini you can use RqFake here instead of cors.class, I guess
shouldn't be " instanceof" also? Since the cast will be checked first, it should be changed to (PairQueryable) object).getSecond()
shouldn't be " instanceof" also? Since the cast will be checked first, it should be changed to (PairQueryable) object).getSecond() because it has the risk of having two methods.
shouldn't be " instanceof" also? Since the cast will be checked first, it should be changed in the caller's constructor
Can we make this an exception, something like "Could not find core-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-resources: MountTableConfigLoader loader = MountTableConfigLoader.parse(mountTableConfig.CONFIG_VIEWFS_MOUNTTABLE_PATH); if (LOG.is mountTableConfig()) { throw new RuntimeException(mountTableConfig.CONFIG_VIEWFS_MOUNTTABLE_PATH, "with core-site.xml"); }
Can we make this an exception, something like "Could not find core-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-site.xml mount-resources: MountTableConfigLoader loader = MountTableConfigLoader.parse(mountTableConfig.CONFIG_VIEWFS_MOUNTTABLE_PATH); if (LOG.is mountTableConfig()) { throw new RuntimeException(mountTableConfig.CONFIG_VIEWFS_MOUNTTABLE_PATH); }...
use  mountTableConfigLoader
catch Exception instead of RuntimeException
catch with the same exception instead of 7?
catch (IOException e) {
These two could be simplified to assertNull.
Could be simplified to assertNull.
These two could be simplified to assertEquals.
shouldn't this be List<ERepositoryObjectType> toReturn = new ArrayList<>(...)?
shouldn't this be List<ERepositoryObjectType> toReturn = new ArrayList<>()?
shouldn't this be Arrays.asList(ERepositoryObjectType.PROCESS.ERepositoryObjectType.PROCESS_LIST, ERepositoryObjectType.PROCESS);
Shouldn't this be an error?
Shouldn't this be an error? There are other messages to which this is a valid error code defined.
Shouldn't this be the default value?
you should have "moveToState(state,...") return moveToState(state,...);" here, not a blocker
you should call moveToState(state,... the same value for all the other handlers, not the same thing for each state
you should call moveToState(state, STATE_LIST) here, not the other way around.
It works but it smells, I think this is a complete abuse of the API
It works but it smells, I think this should be a separate function (like DiskVmElement)
It works but it smells, I think this should be a separate method
extract this string to a constant, so it is more readable
extract this string to a static variable
extract this string to a static final constant
shouldn't the return type be 'protected'?
shouldn't the return type be warn?
shouldn't the return type be getParameters().getClusterId()
Causes a null pointer exception if mLooper is null.
Causes a null pointer exception in the request, we are not passing it in?
Causes a null pointer exception in the setter. can we calculate them in the constructor?
suggestion LOG.info("Skipping revoke (authToken) of the cache", newToken);
suggestion LOG.info("Skipping revoke (and detected token has already changed)", e);
Please use a separate log message.
I think this is wrong, we need to click on an item that is being started
I think this is wrong, we shouldn't need to notify the patient here since it's being handled more than once.
I think this is wrong, we shouldn't need to notify the patient here since it's being handled above.
Why doesn't groupIdExisting == groupId?
Why doesn't this use Arrays.asList?
Why doesn't we use valuePosition for the groupId?
Why not iterate with the list? It can be hundreds of entries.
For the sake of consistency, use the for-each loop instead?
Why not iterate with the list?
Can this be done before the check for list.isPresent()?
Can this be done before the check for list.isEmpty()?
Can this be done before the check for list.
please use querydsl instead (already in master)
Please use querydsl instead (already in master)
TypedQuery, as its name reminds, is parameterized, so please use setParameter()
Could this be replaced with:.equals(driver.getPageSource().get("div.title"))
Could this be replaced with:.equals(driver.getPageSource().get("div.title"))?
Could this be replaced with assertThrows?
Do we need to catch Exception at the top of the method at the top?
Do we need to catch Exception at the places where it is used?
Do we need to catch Exception at the top of the method?
Can we use new File(path) here?
Can we use new File(path).equals(path) here?
Can we use new File(path.equals(path) here?
Is it guaranteed that all io.druid.java has already been closed?
Is it a problem that you aren't throwing the exception at all?
Is it guaranteed that all io.druid.java has already been deleted?
Never catch NPEs.
Never swallow exceptions.
Is this a log statement?
missing braces.
well, isUsefulForIndex()
not sure if it is worth it..
You might want to check for PermissionService.hasInitialization(this, new Predicate<PermissionService>() { @Override public void onInitialization() { // check for PermissionService.INSTANCE } });
You might want to check for PermissionService.hasInitialization(false) and throw an appropriate exception in that case.
You might want to check for PermissionService.hasInitialization(this, new Predicate<PermissionService>() { @Override public void onInitialization() { // check } });
static import
nit: I think you'd want to do this as a static import.
nit: I think you'd want to assert on the actual end time here.
any other error handling missed?
this should go into other parts of the constructor.
this should go into other parts of the mapper.
This should be: if (entity.hasEntity(PersistentEntity.class.getName())) { entity.getName(); }
This should be: if ( entity.hasIdProperty()) { entity.getName(); } else { entity.getName(); }
This should be: if (entity.hasEntity(PersistentEntity.class.getName())) { entity.getName(); } We can do this with the MappingException constructor.
Why is this needed?
Why is this changed?
Why is this different from the test?
You should never swallow this exception. just return TYPE_DEMO.TYPE_DEMO 0 if it's not equal to id can be null.
You should never swallow this exception. just return TYPE_DEMOType.TYPE_DEMOType() if it's not equal to id can be null.
You should never swallow this exception. just return TYPE_DEMOType.TYPE_DEMOType() if it's not there
should probably be a test method.
should we have a test that verifies that this throw is as expected?
should we have a test that verifies that this throw is as expected
why don't you use patameter?
when you use AssertJ, i.e. use AssertJ
why do you use this instead of Assert?
Unfortunately, I don't think it's a good idea to keep these methods as private since they are overridden in the subclasses. In particular, it's a breaking change because it's not intended to be used outside of the package.
Unfortunately, I don't think it's a good idea to keep these methods as private since they are overridden in the subclasses. In particular, it's unlikely to make sense to also have getMaxLength() abstract methods that are overridden by subclasses.
Unfortunately, I don't think it's a good idea to keep these methods as private since they are overridden in the subclasses. In particular, it's unlikely to make sense to also have getMaxLength() abstract methods that are overridden by subclasses. I'm also not sure we need to change the access modifiers?
can we assert something here?
I think we can keep the implementation in the append method. Also, what do you think of using the @Test annotation?
I think we can keep each test for a single line for each test case
Is there a reason to define a pad here?
Is there a reason to define the pad as a method?
base is not nullable here.
Should have a null check here?
Should have a null check here.
Should use a constant?
I think we should prefer accuracy over speed here, and use theradius should not be radius.
I think we should prefer accuracy over speed here, and use theradius should be radius.
I think we should prefer accuracy over speed here, and use theradius should not be set to radius.
Can you please also add a default value for limit codes here?
Can you please also add a default value for all queries?
Can you please also add a default value for limit too?
Why it is better to use the ThreadHelper instead of sleep for a single session?
Why it is better to use the ThreadHelper instead of sleep for one second?
Why it is better to use the ThreadHelper and call ThreadHelper.waitFor(500); instead?
Consider using XOR operator: return cache.getProfile().read(profile).readProfile(profileManager.getStorageProfile().get(0);
Consider using XOR operator: return cache.getProfile().read(profile.getStorageProfile(), Profile.Storage);
Wondering if this method should be synchronized?
I get the feeling this is too simple. What about splitting the filters? What if they match? We could just have a single constant for the enum value, and then use it here.
I get the feeling this is too simple. What about splitting the filters? What if they match? We could just have a single constant, and we do it when the class is configured.
I get the feeling this is too simple. What about splitting the filters? What if they match? We could just have a single constant for the enum value, and then use it instead of the default constructor.
is there any reason that this is not handled by the createCheck() method?
I don't think we should catch this kind of Exception.
is there any reason that this is not handled by the createCheck() implementation?
With the latest version, it's going to be delegate to the latest version.
With the latest version, it's going to throw a UnsupportedOperationException now.
With the latest version, it's going to cause issues then.
> Sorry I missed this before, but should we add @Override annotation here?
> It should be this.attributes.size() * this.attributes.size()
> It should be this.attributes.size()
@Godin Here I think it's better to declare the return type with boolean.
@Godin Have you considered using getEnclosingTryStatement(VariableTree.class) here?
@Godin Here I think it's better to declare the return type as boolean.
Can be simplified to: java if (classType == Type.classType.isAssignableFrom(classType)) { return Factory.classType(); } else { return Factory.classType(); }
Can be replaced with: java if (classType == Type.classType.isAssignableFrom(classType)) { return Factory.classType(); } else { return Factory.classType(); }
Can be simplified to: java if (classType == Type.classType.isAssignableFrom(classType)) { return Factory.classType(); } else { return super.clone(); }
This will also force us to use a byte array which could be a byte array with one element and an array with the length of the byte array.
This will also force us to use a byte array which could be a byte array with size 4 and 9 in the array.
This will also force us to use a byte array which could be a byte array with one element and an array with the length of the array.
Adding this to a field is good manner.
Adding this to an API class is good manner.
Adding this to a field will cause a NPE.
instead of returning the result from this method, could it be that it will be returned directly?
so maybe it would be better to return the result to the interpreterContext instead?
so maybe it would be better to return the result to the interpreterContext instead of using it directly?
Does it make sense to go into KafkaTranslator instead?
What's driving the change to improve visibility here? It is very important to keep things simple.
Does it make sense to go into KafkaTranslator at once? I'm not sure how important it is to use them all.
If the FrontendRunAction() returns null, you'll end up with NPE anyway
If you're going to do this, don't you need to check for the existence of the hostId?
If you're going to do this, don't you need to check for null here?
Just checking for path.equals(new File(path).
Just checking for path.getFileNames() first
Just checking for path.getFileNames() first.
Shouldn't conform to other equals impls?
Shouldn't conform to other equals impls here?
Shouldn't this lead to false?
Can the getter be package private?
This should be the getter, not the field.
Can the getter be package access?
You can do this: return super.PRODUCTION, autoConfig);
You can do this: return ImmutableList.copyOf(this.PRODUCTION, autoConfig);
Can we revert this to the original code?
System.out???
System.out.println
Needs a logger
I don't think you need this null check. Given that you have the assert above, this is fine.
I don't think we need this null check. Given that we have cacty the context is null, this is probably a redundant check for null.
I don't think we need this null check. Given that we have cacty the context is null, this is probably a redundant check.
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
suggestion EMPTY_VALUE);
suggestion assertThat(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
can we do this to other mappers?
can we do this to the mapper in the rest of the mapper?
can we use the integration-test module as well?
This implementation is correct, but this method is not compare to the value of this field, which is the same as the default value. Why not use the old value to compare directly?
This method should not be public, it is the default value. If a developer wants to override value, they should use this method.
This implementation is correct, but this method is not compare to the value of this field, which is the same as the default value. Why not use the old value to compare int and Long.compare again?
I think the cast is not needed, since generics is introduced by the compiler.
I think the cast is not needed, since generics is introduced by the compiler warning.
I think the cast is not needed, since generics is introduced by the compiler
Is this else needed?
I think this check is unnecessary (the if (numChunks() > 1) check.
I think this part is unnecessary (the if (numChunks() > 1) check.
Charset.defaultCharset() should be replaced with a given charset.
@vilchik-elena Charset.defaultCharset() seems better to me
@vilchik-elena Charset.defaultCharset() should be better here.
suggestion if (rowIdx >= rows.size() && requested > 0)
suggestion if (rowIdx < rows.size() && requested > 0)
suggestion if (rowIdx >= rows.size()) {
Can we use the ternary operator here?
Can we use the two-arg constructor?
Can we use the ternary operator?
This condition is hard to understand. Can you rename the log message a bit?
This condition is too long.
This condition is hard to understand.
I don't think we need this if block. We can always perform the optimization just before the getExpressionTypes method. I'm not sure if we can drop this cast.
I don't think we need this if block. We can always perform the optimization just before the getExpressionTypes() call.
I don't think we need this if block. We can always perform the conversion once then.
same again: do not create a newIndexOutOfBoundsException.
same again: do not create an empty exception but reuse the old one.
same again: do not create a new empty exception but reuse the same exception
In the other class you use a JBMenuItem. Any special reason to use a JMenuItem here?
Can you use a JBMenuItem. Any special reason to use a JMenuItem here?
In the other class you use a JGroupsMenuItem. Any special reason to use a JMenuItem here?
Let's use Guava's BaseStreams.toByteArray() method instead.
Let's use Guava's BaseStreams.toByteArray() method instead
Let's use Guava's Strings.isNullOrEmpty()
This mapping should be done for all mappers.
This mapping should happen in the context of this class.
This mapping should be done in the enum itself.
A SqlCall call with unparseCall is better for this.
A SqlCall call with unparseCall is not necessary
A SqlCall call with unparseCall is not necessary.
Sorry, I missed this before. Shouldn't there be a new method here?
Sorry, I missed this before. Shouldn't there be a new method here instead of copy to a new one?
Sorry, I missed this before. Shouldn't there be a new method here instead of copy to the original request, which will copy the request and attach it when we old request?
Returning a List should be a Collection instead of a List.
Returning a null list is bad style. Make it final.
Throw a defensive copy of the data.
What if flow.getConnection().blockUntilWritable(LOGGER.get()); or something?
What if flow.getConnection().blockUntilWritable(LOGGER.get()) or something like that?
What if flow.getConnection().blockUntilWritable() is false?
have you considered java Objects.requireNonNull(errors, "errors is null");
have you considered java return Objects.requireNonNull(errors, "errors is null");
need to be ValidationException here.
if it's null, then return appName.getPackageName() can be null. Otherwise return null.
if it's null, then return appName.getPackageName() can be null. That's not obvious.
if it's null, then return appName.getPackageName() can be null. Otherwise return null. probably change it to this....
So, this is dangerous. I think we should have 2 knxnSocket instances for the same batch.
So we have to be careful with this change?
final?
Why in RunListener? It would be nice to have a common interface for each listener in the ReporterImpl. I think, that you can do: java try (final RunListener runResult = new RunListenerAdapter(); runResult.close(); } catch (Exception e) { // ignore }
Why in RunListener? It would be nice to have a common interface for each listener in the ReporterImpl. I think, that you can do: java try (final RunListener runResult = new RunListenerAdapter(); runResult.close(); } catch (Exception e) { // no-op }
Why in RunListener? It would be nice to have a common interface for each listener in the ReporterImpl. I think, you can do that in a different PR.
Couldn't you simply use SpringApplication.run(ModuleLauncherApplication.class, "Couldn't launch module", e);?
Couldn't you simply use SpringApplication.run(ModuleLauncher.class, "Couldn't launch module", e); instead?
Couldn't you simply set the return value to 0?
suggestion this.licenses = licenses;
suggestion this.licenses.licenses = licenses;
I thought we want to use this.licenses.isEmpty() here?
I don't see this as necessary. assertkeyPair(file, null);
I don't see this as necessary. assertkeyPair(this, null);
assertkeyPair(file, null);
Doesn't this method need to be public?
How does this return (protected boolean hasChanges)
How does this compare to 0?
should it be public?
shouldn't we use length() here instead of 0?
shouldn't we use length() here?
In both constructors, you can use builder pattern.
If you are going to use constructor that takes a value and a fileName you can use here.
If you are going to use constructor that takes a value and a fileName you can use here instead of passing a null.
nit: might want to consider changing this to a Set<PartitionedPartitionsAssignedRate>.
nit: might want to consider changing this to a Set<PartitionedPartitionsAssignedRate> in order to avoid duplicates.
nit: might want to consider changing this to a Set<PartitionedPartitions>?
I don't think there is a way to write this instead of having the @SuppressWarnings annotation on a separate line.
Missing 'this'.
I don't think we have to specify this. Does it make sense? If so, please call setWizard().getConfig(wizard).
I don't see any reason to add this method public
I think this should be private
I don't see any reason to put this on the same line
check if (ec.actions!= null) {
return results.toArray(new ActionDescriptor[results.size()]);
return results.toArray(ec.actions::toArray);
We should not catch this InterruptedException. I think we should catch it and rethrow the InterruptedException.
We should not catch this InterruptedException. I think that should be catched, not InterruptedException.
We should not catch this InterruptedException. I think that should be catched, but placed on the outer catch as well.
@njhill we need to check if isTraceEnabled() is not null here
@njhill I think we should not change this to.collect(Collectors.toImmutableList());
@njhill I think we should not change this to.collect(Collectors.toImmutableList()).
Should this throw throw new toString()?
Should this throw IndexOutOfBoundsException?
Should this throw IndexOutOfBoundsException?
should this be "== 1"?
should this be "== getRight().getOutputType()"
should this be "== getRight()"
@scmscmfoo can be null. Is it enough to check for this?
@scmscmfoo can be null. Is it guaranteed to return a non-null value?
@scmscmfoo can be null.
Is there a reason why you removed the 'org.hibernate.search.exception.Error?
Is there a reason why you removed the FQN?
Is there a reason for the change?
I think we should be more explicit about the waitUntilFlowPreparationFinish() here, it appears to be invoked more than once in that scenario.
I think we should be more explicit about the waitUntilFlowPreparationFinish() here, it appears to be the only difference and makes performance clearer.
I think we should be able to fix this in the waitUntilFlowPreparationFinishProcessor.
Isn't a HTTP BAD_REQUEST the HTTP Status 404 just enough? Do we need to write a json message as well?
Isn't a HTTP Status 404 just enough? Do we need to write a json message as well?
Isn't a HTTP BAD_REQUEST the HTTP Status 404 just enough? Do we have to write a json message as well?
You could use spritesheet instead of new RuntimeException(java.util.swt.RuntimeException) to make this line more readable
You could use spritesheet here for this method
You could use spritesheet here for this
Do we actually need to add the "255" literal?
Do we actually need to add assert for the case where tag is set?
Do we actually need to add the "255", and "port" here?
Should not this throw Exception?
Should not this throw RuntimeException?
Should this throw Missing?
Do we need to use getters for this?
Do we need to use this?
Do we need to use this? if so, perhaps we can use suggestion return waitForPath(getCacrypt-cert);
can be replaced by a static method
can you replace this with a static method?
can you replace this with a static method
Think it's easier to read if you reverse the! and do java String config = System.getProperties(config.get(key)); return properties.setProperty(key, systemProperties);
Think it would be simpler to do java String key = System.getProperties(config); return properties.get(key);
Think it's easier to read if you reverse the! and do java String config = System.getProperties(config.get(key)); return properties.put(key, systemProperties);
Can we change the static variable to use the same variable?
Can we change the static variable to just one line?
Can we merge these two functions?
Please use a simple assertj for this. Same below.
Why KinesisProxyFactory is not enough for testing purposes?
Why do we need a super. Same for other mocks?
is it possible to make a public key to be null?
is it possible to make a row to be null?
can we make this public?
Couldn't we check mCheckingDomainCreditsProgressDialog!=null && mCheckingDomainCreditsProgressDialog.isShowing() instead?
Couldn't we check mCheckingDomainCreditsProgressDialog == null?
Couldn't we check mCheckingDomainCreditsProgressDialog == null here?
Instead of silently returning null, we should return a GitBuilder. That way we don't hoist the caller into the caller.
Instead of silently returning null, we should return a GitBuilder. That way we don't _always_ return a Git object.
Instead of silently returning null, we should return a GitBuilder. That way we don't need to allocate an object with a GitBuilder on the server.
It would be more consistent to use iterator() to do iterator.iterator().iterator();
It would be more consistent to use iterator() to do iterator.iterator().next().iterator();
It would be more consistent to use Iterator#reverse instead of iterator()
Change to one-line.
Change to use an early return when the deadline is less than null.
Change this to use the deadline.getTime() method which has a local variable.
do we need to pass timestamplockServiceWithBatch() everywhere?
do we need to pass timestamplockServiceWithBatchWithBatchBatching?
do we need to pass timestamplockServiceWithBatchBatchUpdate, or can we just pass the timestamp?
use getStorageDomainId()
use'return'
use 'protected' modifier
move this synchronized block to the next line?
move this after synchronized
move this synchronized block to the constructor?
Shouldn't this be inside of the try-with-resources block?
Shouldn't this be inside the try-with-resources block?
Add a null check here, so that this points to the top of the method.
No need for.toString() in new tests?
We don't need to use static imports for PollResponse.
We don't need to change PollResponse.fromString() in the next line.
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc...
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(clazz); // Or sanitizeTag or normalizeTag, etc...
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(iTag); // Or sanitizeTag or normalizeTag, etc...
I would expect the white-listing rules to have changed and match app id by the new property now
I would expect the white-listing rules to have changed and match app id by the new id.
I would expect the white-listing rules to have changed and match app id by the new id. That could also be a PR
What about creating a small private static class for the Field and then using it here?
What about creating a private static method to define if you need to use it here?
What about creating a private static class and using it from here?
this seems like it should be a try() with resources
this seems like it should be a try-with-resources
this seems like it should be a try with resources
Can we have a constant for the size of the cell?
Can we have a constant for the header i.e. <LINK_0>
Can we have a title?
This is not right. Please use String.valueOf() instead.
This is not right. Please use "system.tallies[i]" instead.
This is not right. Please use "system.tallies[i]" in this example.
Maybe use OpaqueReport.parseBytes(...)?
Maybe use OpaqueReport.parseBytes(...) here?
Maybe use OpaqueResponse.parseBytes(...) here?
I find it strange that readNext() returns an Optional<M>, why do we need to cast here?
I find it strange that readNext() returns an Optional<M>, why do we need to get rid of this method?
I find it strange that readNext() returns an Optional<M>, why do we need to get rid of readNext() here?
Can you make isExternallyInducedSource() return null?
Can you make isExternallyInducedSource() return true?
isExternallyInducedSource()?
how about simply checking for repositories.get(stateClass) == null
How about getNoAlreadyRegistered().splitToList(Arrays.asList("No"));?
How about getNoAlreadyRegistered().splitToList(Arrays.asList("No");
I think we can rename these to "getHeartbeatHeartbeat()" so that one is more generic and you can use it later.
I think we can rename these to "getHeartbeatHeartbeat()" so that one is more generic and you can use the leader election.
I think we can rename these to "getHeartbeatHeartbeat()" so that one is more generic.
It would be cleaner to use a constant for the retries.
It seems like we should delegate to another new method.
It seems like we should use RetryCondition.class here, right?
I think this change is not needed.
I think this is not going to work like it has to be an estimate of 200 entries long.
I think this is not going to work like it is on the same object.
I think we should rename the future to startFuture and then wait for leaderElectorExecutor. This won't make sense.
I think we should rename the future to startFuture and startFuture to be more specific.
I think we should rename the future to startFuture.
needs 3 _arguments_, plural
needs 3 _get(0)_
needs 3 _get(0)_ _bindings_ too as a constant
Should this be delegating to a different method than encodeLink, above?
Should this be delegating to a different method than encodeLink, above? And why not have a different method that does this?
Should this be delegating to a different utility method than encodeLink, above?
returning internalLink would be better
returning null is a bad idea
returning internalLink would be better here
Should the return type be List<Object>?
Should the return type be List?
This isn't the same as this.
Should we still log the error if the user fails to find out why?
Should we still log the error if the user is trying to find out why?
I see the error message in the log.
I see that it is only in test code, but it is not a good idea to use String.format and pass results as the second parameter.
I see that it is only in test code, but it is not a good idea to use String.format and add if it is only a single line
I found a problem with this approach; probably it is better to do it in a loop to have results as a result.
Can we use.equals to avoid adding further dependency on.getPictureId()?
Can we use.equals to avoid adding further dependency on.getPictureId()? Just a thought.
Can we use.equals to avoid adding further dependency on.getPictureId() if this is true?
Can we add a check that annotations contains the annotation name?
Can you call this method after the for loop?
Can we add a check that annotations contains the annotation name? You can use AnnotationUtils.getJavaClassMimeType()
Yep, what Leo says is what I meant.
Please name it "image"
You have to mark it with "image"
Can you please use a logger instead? I know it's a standard output, but we should not have to display them in the console.
Please remove the System.out.println from the test file
Can you please use a logger instead?
Consider rename this to filterArchived, to make it clearer
Consider rename this to filterPageParam to be consistent with other methods.
Consider rename this to filterArchived, to be consistent with other methods.
I wouldn't bother with this, but the logic looks a bit weird. If I'm not mistaken the duplicate call it here seems a bit weird to me.
I wouldn't bother with this, but the logic looks a bit weird. If I'm not mistaken the duplicate call it here could help in a simple way.
With the default null check, is there a validate throttling to do the job?
can you clarify why this method isn't used here?
can you clarify why the message is null and not the empty string?
can you clarify the reason for this method?
This can be removed from saved list.
This can be removed from the synchronized block.
This can be removed from saved list (saved)
The super.close() method should be before the if statement
The super.close() should be in a finally block
The super.close() should be before the if statement
I think it's better to remove the "throws Exception" from the method name.
I think it's better to remove the "is" prefix from the string.
I think it's better to remove the "isNotNull()" from the message.
Can maybe others not set the size here?
Can maybe others not set the size?
Can maybe others not do null check?
JUnit checks are usually in place so these constants are not needed.
JUnit checks are usually in place so these constants are not required.
JUnit asserts are ok without them.
I can't help but much prefer to use curly brackets to make this code even more readable.
This is is a code smells like this can be factored out.
This is often a bug in the code base. I've never seen this fix in the code.
Isn't there some simple little library for generating JSON output?
Isn't there some simple little library for generating JSON objects?
Isn't there some simple little library for generating JSON output? The library isn'tJKali/user/have bit.
I think we should only do this once in the callback when it's added to listeners.
I think we should only do this once in the callback when it's null.
I think we should only do this once in the callback when it's added to class's callback.
This is not necessary?
This is unnecessary.
This line is unnecessary.
This expression is unnecessary.
This expression is redundant.
This is unnecessary.
This looks like a leftover of debugging, could be removed.
This looks like a leftover of debugging code.
This looks like a leftover of debugging code. The previous code was more proper.
Minor: you can simplify this to java logger.info("\n");
Minor: you can simplify this as follows? logger.info("\n----------------WebSocket")
Minor: you can simplify this as follows? logger.info("\n");
Can you please use PDataType.fromSqlTypeName to get a stream? PDataType.fromSqlTypeName(arrayPrimitiveType, elements)
Can you please use PDataType.fromSqlTypeName to get a more precise type? TDataType.fromSqlTypeName(arrayPrimitiveType, elements)
Can you please use PDataType.fromSqlTypeName to get a more precise type? TDataType.fromSqlTypeName(arrayPrimitiveType, elements);
Sound great. I will change it to private.
Mode.valueOf(mode)
Sound great.
I'm not sure why this change was made. The method should be synchronized as well..
I'm not sure why this change was made. The method should be synchronized as well.
I'm not sure why this change was made. The method should be synchronized with the return value.
Throw IllegalStateException is pauseDepth becomes negative.
I don't think this does anything. It's pauseDepth becomes negative.
I don't think pauseDepth becomes negative.
can we change this to something like for (listenerToInterruptListener : runningCommandsMap.values()) { if (!listenerToInterruptWatcher.isEmpty()) { //... } }
can we change this to something like for (listenerToInterruptListener : runningCommandsMap.values()) { if (!listenerToInterruptWatcher.containsKey(commandsToInterruptException)) { //... } }
can we change this to something like for (listenerToInterruptionCommands : runningCommandsMap.values()) { if (!listenerToInterruptWatcher.containsKey(commandsToInterruptLeader) { //... } }
I think this needs to be inside the synchronized block or something.
I think this needs to be inside the synchronized block.
this needs to be inside the synchronized block or something.
NullPointerException
new HashMap<>(address)
ClassCastException is thrown.
I guess this will cause issues later on.
I guess we don't need this s, but thinking about moving the metric name here?
I guess we don't want to set the s here?
minor: these are deprecated in l147-158. I would recommend using private static final String DEFAULT_SEPARATOR = "_" + clusterMapPort + "_" + clusterMapPort + "_" + clusterMapPort + "_"
minor: I am guessing this is not used anywhere?
minor: I am guessing this is not used.
overlay.toBack();
You could just set the value of lastReloadNotification here to false
Couldn't you leave the old code here?
Was there a reason to remove the null check? The rest of the code is checking the length of the array.
Was indexOftance_company() a null check needed?
Was there a reason to remove the null check? The rest of the code is checking the length of the array, so adding it here will cause an NPE.
This needs to be: java return new BigInteger(primitive.parse(primitive.getAsString(), new DateTimeFormatter())).parse(primitive.parse(primitive)));
This needs to be: java return new DateTime(JsonObject, memberName, memberName);
This needs to be: java return new BigInteger(primitive.parse(primitive.getAsString(), new SimpleDateFormat());
super.toString()?
super.toString(), why not use super.toString()?
super.toString(), why not use super.toString()?
consider createContainerOptions(ImmutableList.of("versions"), options.buildRequestHeaders());
nit: remove empty line?
consider createContainerOptions
nit: one line
nit: one line is missing
constant?
This method should be org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace(String) instead.
This method should be org.apache.commons.lang3.exception.Exception, not a unit test (in which case the caller should use the new method).
This method should be org.apache.commons.lang3.exception.Exception, not a unit test (test)
It looks that cfg.getConfiguration(SystemView) can be used.
It looks that cfg.getConfiguration(SystemView) can be used here.
This line should be moved after line 94.
I don't think we should be using this to access the members of the Resource and not the whole class. This happens on the next line.
I don't think we should be using this to access the members of the Resource and not the whole class. This happens in another package and it should be removed.
I don't think we should use this to access the members directly. abstract class Amodule and protected means that it can be needed in any case.
The constructor can directly call lease.get() only once.
The constructor can delegate to this one, no need for leaseManager anymore.
The constructor can delegate to this one, no need for leaseManager.
Likewise..
Likewise.. } else if (VixprovedHoursSpentInputChange(...)) {
Likewise.
You can use a Set on the size of the list.
You can use a Set<CapabilityList<Capability>> here.
You can use a Set.
nit: use EMPTY?
nit: use EMPTY
Use EMPTY?
You need to have a TypeVariableName here.
We need to have a TypeVariableName here.
You need to have a TypeVariableName here (maybe)
Why can't we test for empty tags as well?
Why can't we check if property is empty?
Why do we have test for it?
Suggest to use _Logging_ in the logInfo_, not the one from the incoming memberName.
Suggest to use _Logging_ in the logInfo_, not the one in the logInfo.
Suggest to use _Logging_ in the logInfo_, not the one from the incoming member.
@inverno This is confusing, I think it should be package private for test classes instead.
@inverno This is confusing. You could just define a default constructor for logger, and call it with logger.log.
@inverno This is confusing. You could just define a default constructor for logger, and use it in constructor to call this one with logger.log.
not sure why 42 or something like that?
why 42?
not sure this is the correct way around it?
Please replace with getVds().getVds().getVdsGroupCompatibilityVersion()
please replace with: return getVds().getVds().getVdsGroupCompatibilityVersion();
Please replace with: return getVds().getVds().getVdsGroupCompatibilityVersion()..
shoudl we only catch this exception if value is null? I don't think this is possible any more.
shoudl we only deal with value 'value' here? Definitely what not all the time?
shoudl we only catch this exception if value is null?
Instead of adding an extra "outout of the for loop" statements, you could just inline the for loop.
Instead of adding an extra "outout of the for loop, you could just inline the for loop.
Remove this line.
Can we use name as the second argument here?
Can we use name as an example.
Can we use addfinal for the test cases?
This is fine, but please move FactoryTransformer.factoryTransformer(factoryTransformer.factoryTransformer(factoryTransformer.factoryTransformer(factoryTransformer)). factory(factoryTransformer:: factory); out of the constructor.
The FactoryTransformer.factoryTransformer(factory) should be used instead.
Missing 'factory'.
We should avoid using system.out.println if possible.
We should avoid using Assert.fail since it really only checks the specific exception.
We should avoid using Assert.fail since it really only checks the specific exception type.
nit: do you mean getQualifiedName()?
nit: no need for getQualifiedName here
nit: getQualifiedName()?
It seems this method is not used anywhere. Could you please rename it to something like writeProperties?
It seems this method is not used anywhere. Could you please rename it to something more like "wrong schema"
It seems this method is not used anywhere. Could you please remove it?
I would prefer to make the name of the 0-9]+ object as a name.
I would prefer to make the name of the 0-9]+ class with a name.
I would prefer to make the name of the 0-9]+ object clearer
suggestion public void instantiateSound(final Media Player app) {
suggestion private void instantiateSound(final Media Player app) {
Is there a reason we are getting this on the file? Also: the current implementation in the file isn't the same as the title?
Minor: since locateMemberMember has been renamed to locateTestsArtifact, maybe downloadMember should be renamed, too?
Minor: since locateMember has been renamed to locateTests() to avoid creating too much unnecessary work, maybe downloadMember should be renamed, too?
Minor: since locateMember has been renamed to locateTests() to avoid confusion, maybe downloadMember should be renamed, too?
I think here we should keep the old code as it was before.
I think here we should keep the old code.
I think here we should keep the old code as it was before
Shouldn't we use "implicit threads" instead?
Shouldn't we use "implicit threads"?
"public" is not the best choice here. Should we use "null" instead?
This should be logger.error(message).
Should this be logger.error(message)?
This should be logger.error(message, message).
Shouldn't this line be in the previous for loop?
Shouldn't this check be in the previous line?
I think this line should be removed.
Rename to DEFAULT_COUNT
Rename to DEFAULT_WAIT_height?
Rename to DEFAULT_WAIT_VERSION
Use a LinkedHashSet to avoid the risk of two being added to the list.
Use a LinkedHashSet to avoid the risk of two being returned instances (i.e. Comparator.comparingDouble(List::getComparator)
Use a Comparator to have a comparator that does this compare?
Do you need this check, or ifmntByAttribute is empty or not?
Do you need to check ifmntByAttribute is empty or not?
Do you need this line at all? I think it's okay ifmntByAttribute is empty or not.
this is a breaking change, right? If so, please make it final.
it seems like a good idea to have a single single {} static final as well.
this is a breaking change, right? If so, please sum with a unit test
Why not use the client provided by the command name instead of a string?
Why not use the client provided by the command name instead of a string? Returning true would be confusing.
Why not use the client provided by the command name instead of a string? Returning true would be more consistent.
Why not throw new DefaultAuthenticationExtractorException("general", "token");
why not public?
Why not public?
inline?
please externalize error message
please externalize error messages
Is there a reason this doesn't use the getServerSpecificRoot(String path) method?
Is it possible to use the getServerSpecificRoot(String path) method here?
Is there a reason both of these exceptions were caught?
Typo?
typo?
typo
This will add the same overhead as get() is called in add() but it would be better to avoid the add() if you are adding more info to it.
This will add the same overhead as get() is called in add() but it would be better to avoid the add() if you are adding more than one hook.
This will add the same overhead as get() is called in add() but it would be better to avoid a concurrent hash map.
Move String values used more then once to a constant.
Move String values used more then once to a constant. This could be used more then once to a constant.
Move String values used more than once to a constant.
Minor: this.groupArtifact = checkNotNull(groupArtifact, "groupArtifact");
This doesn't need to be public, otherwise it would be null.
This doesn't need to be public
Looks like you forgot to check null here.
Looks like you forgot to check null here
Looks like you forgot to check for null here
what if someone will call this method to create a new organization object?
what about just filter and throw organizations?
what about not adding a potentially unused organization parameter?
"this."
"this." is redundant here.
"this." is redundant
You can just do return start;
You can just do return start() > 0;
You can just do return start().withCondition()
The last assert is different from the first 2
The first assert is different from the first 2
The first assert is different from the last 2
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable: ExpectException expectException = new ExpectException(new PassingStatement));
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable: ExpectException expectException = new ExpectException(new ExpectException(e.getMessage(), containsString("Expected exception"))
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable: ExpectException expectException = new ExpectException(new ExpectException(e.getMessage(), containsString("Expected exception"))?
Can you add LOG.info to the end of the string?
Can you add LOG.info to the logger?
Can we use StringUtils.toStringToDropwizardEmitterConfig
Update the default implementation
Update the storage domain to update the storage domain
Update the storage domain to invalidates.
This is a bit hard to read. Please use [SQL.standard.boot](<LINK_0> here.
This is a bit hard to read. Please use [SQL code](<LINK_0> instead.
This is a bit hard to read. Please use [SQL.standard.boot](<LINK_0>
I don't think this PR is needed for this now.
I don't think this PR is necessary
I don't think we need the query variable here.
You can have this.typeList = Arrays.asList(typeList.stream()).map(this.typeList::trim).collect(Collectors.toList());
You can have this.typeList = Arrays.asList(typeList.stream(), this.typeList.getExtraValue("type"), this.typeList.trim().split("\\s*,\\s*"));
You can have this.typeList = Arrays.asList(typeList.stream(), this.typeList.getExtraValue());
I thought Drugs.getAllDrugs() always returns true for non-empty collection, but the methods which are either not true or false, by mistake.
I thought Drugs.getAllDrugs() always returns true for non-empty collection, but the methods which are either not true or false, for example, an event, was actually set to false in this case, then the test should stay.
I thought Drugs.getAllDrugs() always returns true for non-empty collection, but the methods which are either not true or false, for example, an event, was actually interrupted.
This should be a notLong.
This should be a notlong
This should be a notlong.
Should this be LON_DGS?
Should this be LON_DON_GEN532_FORMAT?
Should this be LON_DON_GEN5_CONFIG?
Yes, I see it is deprecated. Please use ResteasyProviderFactory.newInstance() instead.
Please use ResteasyProviderFactory.newInstance() to create the ResteasyProviderFactory, you don't need to create it again.
Please use ResteasyProviderFactory.newInstance() to create the ResteasyProviderFactory, you don't need to create one each time.
missing else
missing else?
else if
it would be good to make it a util method
you can use ToStringBuilder on the param json to avoid the string concatenation
it would be good to make it a util class for this purpose.
Maybe we should use the expected value here too, e.g. it's always smRqTextText(value).
Maybe we should use the expected value here too, e.g.: java public HmRqText(final String expected) { return this.inputText; }
Matchers.containsString is clearer
can we add here more descriptive name instead of element?
can you add here more descriptive name instead of element?
can we add here shorter wait?
You should do: String msg = String.join(",", "baz", "bar"); assertNull(null, "bar");
You should do: String msg = String.join(",", "bar", String[],bar"); assertNull(actual, expected);
You should do: String msg = String.join(",", "bar", String[],bar"); assertNull(array);
I think think System.outs should be logged.
I think 'log' is redundant
Typo
Why not implement the  Extendable persister#addWhenIndexFromDiscriminator as it will do the same thing with both of those methods.
I don't think we need to change the logic here. As it is getting called "hasSubclasses" can be removed.
I don't think we need to change the logic here. As it is, the flow should be moved to IndexImpl.method.
Should this be done only when retrieving the cache?
Consider to use Dao#get(identity) here.
Consider to use Dao#get(identity) instead of load.
No need to use the.toString() here, just return null
No need to use the.toString() here, just print the stack trace
No need to use the.toString() here, just return null?
nit: can be replaced with Jenkins.getInstance()
can be replaced with Jenkins.getInstance()
can be delete()
The original code is correct. It would be nice to extract the it as a method to avoid duplication.
The original code is correct. It would be nice to extract the messageNode.setTimeout(BufferNode) to a local variable, so it is clear what it is.
The original code is correct. It would be nice to extract the messageNode.setTimeout(BufferNode) to a local variable, so it is easier to understand.
remove?
Use logger instead
remove this?
You could have used checkArgument(params.length > 0, "Params must be greater than or equal to %s", params);
You could have used checkArgument(params.length > 0, "Params must be greater than or equal to %s", params), "
You may want to include the unsupported values that are not supported in the exception message
This is weird. (i.e. it's default to "abc" as null)
(i'm biased.. i'm the author of this for loop)
This is weird. (i.e. it's default to "abc" not " as an empty string)
nit: move all these fields into the config class.
nit: move all these config fields to constants.
nit: move all these config fields into the task class
The empty string is not needed here
suggestion LOGGER.info("deserializing here, is);
The empty string is not needed here.
same here, synchronize on dimension
Same question
same question
Should we use the logging framework instead of DEBUG?
Should we use the logging framework instead of DEBUG?
Should we use the logging framework instead of printing out the stacktrace?
nit: can we return null in this method?
nit: can we return readNetworkStatsDetail() here?
Why can't this return null?
Does this mean that confutch-site has to be null?
Does this mean that confutch-site has to be null? Please use String.format()
Does this mean that confutch-site has to be set on the target cluster?
Add Override annotation.
Add Override annotation here.
Add Override annotation here?
There are only few methods that could make this constructor protected.
There are no longer this setter as well.
There are no longer this constructor that does not have this constructor.
Shouldn't you be able to undo this?
Shouldn't be using session. manager.exist()
Shouldn't be using session. manager.exist(1000, false););
Should we use Objects.toString() here so that the product is human readable?
Should we use.equals here?
Should we use Objects.toStringHelper() here so that the product is human readable?
Please use [this](<LINK_0>
It seems to be there's no need to supply a list here.
It seems to be there's no need to supply a list instead of a default List.
sequential can be in one line.
nitpick: it's the entire immutable & might be collapsed into a single map.
nitpick: it's the entire immutable & might be collapse into a single line.
I am unsure about the use of manifestFile, as it is worth refactoring.
I am unsure about the use of manifestFile, as it is just a copy. Can we?_review_ support files?
I am unsure about the use of manifestFile, as it is just a legacy file. Can we?_review/operator more defensively_
return "this"?
return (null) -> return null
return "this"
Please use: return allValidationResults.entrySet().stream().filter(entry -> value == null ||!value.isEmpty()).collect(Collectors.toList());
Please use: return allValidationResults.entrySet().stream().filter(entry -> value == null ||!value.isEmpty()).collect(Collectors.toList());
Please use: return allValidationResults.entrySet().stream().filter(entry -> value == null ||!result.isEmpty()).collect(Collectors.toList());
Can't we just keep the old code style style, without duplicating code?
Can't we just keep the old code style style, for consistency?
Can't we just keep the old method, no need to convert it to one?
Minor: Seems we have two properties (or both) and shutdownAll. Maybe we should be consistent in what I see in the run method.
Minor: Seems we have two properties (or both) and shutdownAll. Maybe we should be consistent in the run method.
Minor: Seems we have two properties (or both) and shutdownAll. Maybe we should be consistent in what I see in the runAll.
Do we need to skip the existing checks here?
Do we need to skip the existing entries?
Do we need to skip the existing checks?
nit: not sure if you need to use {} explicitly.
nit: not sure if you need to use {} here.
nit: not sure if you need to read this file.
What does this do? If the compareTo method never returns null, you should throw an exception.
What does this do? If the file has different content, the last one will be the same as the default?
What does this do? If the file has different content, the last one will be the default, too.
I think this should be 4 spaces. Please change to assertEquals.
Please use the new assert() method for these cases.
I think this should be 4 spaces.
return toEstimatedSize()?
should return a long
return Integer.MAX_VALUE?
you can use Objects.equals()
you can use!= instead of &&
you can use!= instead of equals
Why do we need to keep a reference to the activity here?
Why do we need to keep a reference to the activity here? This should be obtained from the ConnectivityIndicatorFragment itself.
Do we need to keep a reference to the activity here?
No reason to keep the methods public except for the implementation.
No reason to keep the methods public except for the others...
No reason to keep the methods public except in a public modifier.
it doesn't look right to me. You are doing this in any way. I think you need to be more than just LOG.info("Parent directory is changed", parentDir);
it doesn't look right to me. You are doing this in any way.
it doesn't look like you are doing any good to me. Was this change intended?
This fails on my machine, but it seems to be the same. Can you replace this with System.out.println()?
This fails on my machine, but it seems to be the same. Did you mean to assert that the output has been?
This fails on my machine, but it seems to be the same. Can you replace this with System.out?
I think we should also check isSignedIn!= null here.
I think we should also check isSignedIn?
did you mean to remove this?
it is the tenant ID and the database ID should be deleted
it is the tenant ID and settings object
it is OK to call this method with id as parameter
What does this line do?
Does this need to be public?
What does the reason for using the constant here?
why not use angleMap.keySet().stream().map(si -> angleMap.get(name)).filter(l -> l.get(name)).collect(Collectors.toMap(Function.identity(), eti -> { Loader.ToJointAngles(name)); for (String name : angleMap.keySet()) { si.get(name); }
why not use angleMap.keySet().stream().map(si -> angleMap.get(name)).filter(l -> l.get(name)).collect(Collectors.toMap(Function.identity(), eti -> { Loader.ToJointAngles(name)); for (String name : angleMap.keySet()) { si.getService(name); }
why not use angleMap.keySet().stream().map(si -> angleMap.get(name)).filter(l -> l.get(name)).collect(Collectors.toMap(Function.identity(), eti -> { Loader.ToJointAngles(name)); for (String name : angleMap.keySet()) { si.get(name); } });
Consider using StringUtils.split() method instead
Consider using StringUtils.split() method instead of String.split()
Consider using StringUtils.split() method instead of the string.
Could you extract this into a constant?
Could you extract this to a constant?
Could you extract this into a constant param?
This would be better as: if (fileExtes.startsWith(index)) { return Parser.text(fileExtesionStartIndex) } else { fileExtes.remove(fileExtes); }
This would be better as: if (fileExtes.startsWith(index)) {... } else {
This method should be private as well.
accessService is not used, should be private
access token is not used, should be it public
access flag
Should this be indefinite?
Should this be instrNum
same as above. check if possible.
What should we do here? We should likely log an error (i.e. this is unable to initialize YouTubeUriCanonicalUriCanonicalUriCanonical)
What should we do here? We should likely log an error (i.e. this exception) if there is no exception we can't get here.
What should we do here? We should likely log an error (i.e. this exception) if there is no exception we can't get here?
I'd go with the string "_ORE" here. Makes it a tiny bit clearer to read.
I'd go with the string "_ORE" here.
I'd go with the string "_ORE" here. Makes it a tiny bit faster to read.
I suppose there is nothing wrong with this, but there is no need either, is there?
Why need this? I suppose there is no need to check for monitor here
Is there a specific reason this is not part of the original code?
Could we maybe use Collections.singleton(...) here?
Could we maybe use Collections.emptySet() here, or at least do this in the other constructor?
Could we maybe use Collections.emptySet() here, or at least put the new DefaultVariableNameFunction inside Builder?
Shouldn't this be: if (isComplete()) {
Shouldn't this be java if (isComplete()) {
Shouldn't this be synchornized?
Can we use pollerPluginId instead to avoid ternary for control flow?
Can we use Objects.requireNotNull?
Why not use material instead of material?
What is the purpose of this.?
What is the purpose of this change?
What is the purpose of this. here?
What does the test have to assert for?
Why testing student?
What does the test do?
Is this really needed?
Is this really necessary?
Is it really necessary to keep this?
setErrorMessage
Set the value of the message to this value.
Set the value of the message to the log.
can u extract a final constant with a readable name out of "<[ ]*%s[ ]*>"?
can u extract a final constant with a readable name out of "<[ ]*>"?
can u extract a final constant with a readable name out of "<[ ]*%s[ ]*"?
Here you need to initialize the field in all the places: probeRenderer = probeRenderer.writer(new DiagnosticsLogWriter()); probeRenderer.writer( probeRenderer);
Here you need to initialize the field in all the places, do you need to make it final and use that here?
why is this needed?
you have to synchronize this with options? this doesn't mean that if it's the option it's seconds, it doesn't the default (which we're setting up the environment variable)?
you have to synchronize this with options - it doesn't really matter much.
you have to synchronize this with options
I'm not sure it is ImageJ style. It won't be possible to use Path.getFileName() instead. This will just pass true on the File object. Our project will have a reference to the File object passed to it.
I'm not sure it is ImageJ style. It won't be possible to use Path.getFileName() instead. This will require some dependency to make sure that it's not possible to use nio.file.Path or File. Path object.
I'm not sure it is ImageJ style. It won't be possible to use Path.getFileName() instead. This will require some dependency to make sure that it's not possible to use nio.file.Path or File.toPath() below.
i18n
boolean hasButtonVisible = true; and re-use it in the method below.
Please move this method into the method waitForTestModeButtonVisible, and re-use it in a method
rename to uri
rename to uri here
formatting
Instead of clone(), we can use Checker.updateIfPresent() method.
Instead of clone(), we can use Checker.updateIfPresent as before.
Instead of clone(), we can use Checker.updateIfPresent() as before.
nit: this.iterator() seems unnecessary.
nit: you can use Iterables.getFirst instead
nit: this wrapping can be replaced with java return getOrCreateStream(getOrCreateStream);
Add a checkNotNull check.
The parameter name is actually used.
The parameter name is not used.
I like that we can extract headers from the constructor: Map<String, String> headers = headers.get(nameempotencyKey); headers.putAll(map);
I like that we don't have to define headers by class. What do you think?
I like that we don't have this map anyway, as it's just a string.
You want to use the expected path to be "word2";"
You want to use assertEquals instead?
You want to use assertEquals instead of assertTrue?
this mapping should happen via public enum and not via mapping backend enum to string
This mapping should happen via public enum and not via mapping backend enum to string
shouldn't it be 'isSetBackend()'?
calling endSuccessfully is problematic, I don't think we need to call endSuccessfully after the 'log' method.
calling endSuccessfully is problematic, I don't think we should filter out the 'log' method.
calling endSuccessfully is problematic, I don't think we need to call endSuccessfully after the 'log' method, the 'log' method is called, do we really need 'log' method?
This shouldn't be a constant of a class, since it can change later on. In which case, I don't think we need to set the timeout here as well.
Could you use the constants from MINUTES_TIMEOUT to MAX_CONTAINER_TIMEOUT?
This shouldn't be a constant of a class, since it can change later in the future.
this is overflows max througput = 1,000,000 if you multiply that by 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L
Ideally there's a "IoTune" method, where the minPartParams and maxBytes could be renamed to "IoTune" which is actually used.
this is overflows max througput = 1,000,000 if you multiply that by 1024L * 1024L * 1024L * 1024L * 1024L * 1024L
consider simplifying this: if ( pkgType == null || pkgType.equals( entry.getKey())) {
suggestion if ( pkgType == null || pkgType.equals( entry.getKey())) {
consider simplifying this: if ( pkgType == null || pkgType.equals(entry.getKey())) {
Does this method need to return a new value?
Does this method need to return a new value as well?
Does this method need to return a new value, I think?
suggestion throw new IllegalStateException("Cannot terminate process with Not a UNIX system");
suggestion throw new IllegalStateException("Cannot terminate process with Not a UNIX system?");
suggestion throw new IllegalStateException("Cannot terminate process with Not a UNIX system?"); }
I think this make more sense as this.clientConfig = clientConfig; this.clientConfig = clientConfig;
I think this make more sense as this.clientConfig = clientConfig.get(CommonClientConfigKey.DEFAULT_TIMEOUT);
I think this make more sense by default if clientConfig is null
please use printStackTrace(ex);
please use printStackTrace instead of logging
please use printStackTrace instead of logging and then rethrow.
It would be better to have a entry between the subsystems and the unkownSubsystems class (i.e., not a string literal).
It would be better to have a entry between the subsystems and the unkownSubsystems.
It would be better to use constants
Is it guaranteed that the order of siblings are immutable? The list returned by parent().getItem() is different from the other method.
Is it guaranteed, so the order of siblings.size() is 0?
Is it guaranteed that the order of siblings.size() is 0?
Remove this parenthesis
Remove the parenthesis
Remove this parenthesis.
@SocketAddress is not used.
@d rather throw an exception here, in the constructor if it is not null.
@SocketAddress(username, clientAddress); is missing here?
I'm not sure that's a good idea. I would prefer to go through a exitValue here.
it's better to go here, I'm not sure that's a solution
it's better to go here, I'm not sure that's a solution.
This should be: java return new SignatureFor(algorithm, secretBytes.getBytes(Charsets.UTF_8), UTF_8)
This should be: java return new SignatureFor(algorithm, secretBytes.getBytes(Charsets.UTF_8), payloadBytes);
This should also be part of the PR
needs to be synchronized (in case of exception)?
needs to be synchronized (in case of exception)
needs to be synchronized (in case of exception) {}
Same thing here, I would prefer to use brackets even for one line statements.
Same thing here, I would prefer to use the "<LINK_1>".
Same thing here, I would prefer to use the "<LINK_0>".
I would not name it something like DataStore.coordinatess
I would not rely on the cast.
I would not name it something like DataStore.coordinatess?
suggestion prepareAndRethrowXAException(CompletableFuture.class, Xid), executor);
I think it's better to return a Xid here, not a Completed.
suggestion prepareAndRethrowXAException(CompletableFuture.class, () -> txTable.prepare(...))
nit: this definition looks really awkward
nit: this can be a static method. It is only used once.
nit: this can be a static method.
CommitOrgAction is misleading, even if it isDeveloperAction is true (and not "CommitOrg".
CommitOrgAction is misleading, even if it isDeveloperAction is true (or isDeveloperAction) it refers to the user (and not the servlet container)
CommitOrgAction is misleading, even if it isDeveloperAction is true (and then I think that isDeveloperAction is a No-op in the *original* user)
Rather than using a for each event that is never added to the list, why not use a TreeMap here?
Rather than using a for each event handler, why not use a for loop here?
Rather than using a for each event that is never added to the list, iterate over the eventsToFire list.
no need for public modifier
I would say that no empty collection is provided
I would say that no empty collection would have been provided
Let's make this private and introduce two factory methods known(String, Optional<String> LeaderInformation) and then deprecate that.
Can we make this private and introduce two factory methods known(String, Optional<String> LeaderInformation) and then deprecate that?
Let's make this private and introduce two factory methods known(String, Optional<String> LeaderInformation)
pattterns? Can't we move this pattern to a static final field?
patt is never used.
pattterns? Can't we retrieve the patt in ValidationUtils.compile() instead?
I think all users need to save if you aren't going to use the return value as well. What am I missing?
I think all users need to save if you aren't going to use the return value as well. What do you think about making this one-liner?
I think all users need to save if you aren't going to use the return value as well. What do you think about making this method synchronized?
We can consider tocHandler.hideToCEvent(c);
We can consider tocHandler.hide()
We can consider tocHandler.hide() instead of SHOW_HIDE_EVENT.
Collections.singleton(...) should be used
Collections.emptySet().
Collections.singleton(...)?
Since the read index file is corrupted, shouldn't we keep it to the original exception here?
Since the read index file is the same as TribbleException except for line 365, I'd prefer to wrap this in a TribbleException. It's not a big deal, but I'm also not a big fan of runtime exceptions here.
Since the read index file is the same as TribbleException except for line 365, I'd prefer to wrap this in a TribbleException. It's not a good idea to throw a TribbleException here.
This check should be done by the Assert class right? This allows us to get rid of this.
This check should be folded into the next line
This check should be folded into the next line.
What are the reasoning for having ProgressListenerWrapper a boolean param?
What are the reasoning for having ProgressListenerWrapper a few times?
What are the reasoning for having ProgressListenerWrapper a boolean param? I think it would be nice to have a method getFirstChild() to do the presence of the methods...
This method should probably be protected as well.
This method can be protected as well.
This method should probably be protected and not public.
I don't think we need this. The cache should have a JTA transaction manager at the top of the transaction manager. I think the right place to do this.
I don't think we need this. The cache should have a JTA transaction manager at the top of the transaction manager.
I don't think we need this. The cache should have a JTA transaction manager at the top of the transaction manager. I'm ok with this, though.
We should wrap this in a try-with-resources so that close is always called
We should wrap this in a synchronized (to make sure we always get closed)
We shouldn't be closing the stream on the finally block
can be simplified to return response.getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getApiTermsOfUse().get(systemConfig.getApiTermsOfUse.class);
can be simplified to return response.getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getValue())
can be simplified to return response.getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getApiTermsOfUse().get(systemConfig.getApiTermsOfUse().getValue()).
Should this be delayed_capture instead?
Should this be delayed_capture == null?
Should this be delayed_capture instead? Or do we need to set all the references?
please rename to child
please rename to occurrence
please rename to element
Other headers might be pre-existing to this method. Its probably not worth the complexity of the code to create a boolean should be split.
I think it might be easier to implement this in the constructor. Also, what if there's no other way of adding a node to the list?
Other headers might be pre-existing to this method. Its probably not worth the complexity of the code to create a boolean should be used when reading.
I don't think this needs to be here anymore.
I don't think this needs to be here anymore
I don't understand this. Shouldn't the outputln method have the correct definition?
Timed out -> System.currentTimeMillis()
CancelledException is handled without the sleep.
Timed out...
s/Fail
s/Faila/
s/Fail/Failed
that's already released. the call to vdsId is decreased. we should rename it to vdsId
that's already released. the call to vdsId is decreased so we don't need to rename it.
that's already released. the call to vdsId is decreased so we don't have to perform the actual values.
ArgChecker will probably be better
ArgChecker.isOnlyNonNull(function.get()) would be better
ArgChecker.isOnlyNonNull(fixedLeg.toString())
call notFound
change to notFound
call notFound()
what guarantees the name of the password?
what about just using getExternalUserPassword() here?
what guarantees the name of the password from the db?
Why not use a lambda?
Why not use lambda syntax?
why not use lambda?
nit: test with a more meaningful name, like "sDB Options"
nit: test with a more meaningful name?
nit: test with a more meaningful name, like "targetStatistics for RocksDB."
@NielsCharlier please use a try-with-resources block here.
This shouldn't be a static variable, you can use the try-with-resources statement.
This shouldn't be a static variable, you can use the try-with-resources block.
This is enough: catch (RuntimeException | SAXNotSupportedException e) {
Stream closing?
This is one statement in the if (SAXParserFactory) {
Small nit, but this could be null, as it's the actual annotation.
Small nit, but this could be null, as it's the expected value.
Small nit, but this could be extracted to a method.
how about "file cannot be null"? that would be a completed sentence
It is file, not url.
url is null, not url
Is it worth asserting that targetUriAsString is non null or empty at least? Why not assert targetUriAsString = " + targetUriAsString;
Is it worth asserting that targetUriAsString is non null or empty at least?
Is it worth asserting that targetUriAsString is null or empty at least?
should this be ImmutableList.of("brooklyn.size", "brooklyn.size()); instead?
should this be ImmutableList.copyOf(Arrays.asList("brooklyn.nodes"))?
should this be ImmutableList.of("brooklyn.empty")?
While [BigDecimal.get](<LINK_0> clearly specifies return values as -1, 0, or 1, < 0 (less than zero) and > 0 (greater than zero) look clearer to my taste, also [Comparable.MAX_VALUE](<LINK_1> specifies return values as a negative integer, zero, or a positive.
While [BigDecimal.get](<LINK_0> clearly specifies return values as -1, 0, or 1, < 0 (less than zero) and > 0 (greater than zero) look clearer to my taste, also [Comparable.get(int)](<LINK_1> specifies return values as a negative integer, zero, or a positive.
While [BigDecimal.get](<LINK_0> clearly specifies return values as -1, 0, or 1, < 0 (less than zero) and > 0 (greater than zero) look clearer to my taste, also [Comparable.getInt](<LINK_1> specifies return values as a negative integer, zero, or a positive.
do we need to CachedConnection here?
You are using cacheConnection outside of the loop. This is a cachedConnection.
do we need to CachedConnection here? Or is it already cachedConnection?
add brackets to make this expression more easy to understand
add braces to make this expression more easy to understand
add brackets to make this expression more easy to read
Shouldn't this be return Util.isEmpty(propertyEntries.size() )?
Shouldn't this be return Util.isEmpty(propertyEntries.isEmpty())?
Shouldn't this be: return Util.isEmpty(propertyEntries.isEmpty()?... :...
I don't think it's necessary to store the result of caches.caches().members() as a member variable.
I don't think it's necessary to store the result of caches.caches().members() as a member variable, since it's only used once.
I don't think it's necessary to store the result of caches.caches().onRebalanceKeyReceived().onRebalanceKeyReceived().onRebalanceKeyReceived().onRebalanceKeyReceived();.
Not an exception
Not an exception in the logs
Not an error
Could we maybe have a single constant for this? suggestion assertEquals(Keras, InputType.InputType.SOME_TRANSACTION_TIME_REGISTRATION_TOKEN);
Could we maybe have a singleKeras -> {3}? suggestion
Could we maybe have a single constant for this? suggestion throw new Keras("1nn2 1);
Please change equals to taskKeyToTaskIdMap to avoid NPE
Please change equals to taskKeyToTaskIdMap to avoid potential NPE
Please change equals here.
What about otherId, otherId and otherIds?
What about otherId, EXACT field?
What about extracting these 2 methods?
I believe that this is the same as "org.jboss.as.test.integration.management.server.ServerEnvironment.war".asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFileAsset()).addAsLibraries(new StringAsset("<web-app/>").asFile(".war").asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFile("type", "run-in-type")).asFile("WebXML", war, this test will also pass.
I believe that this is the same as "org.jboss.as.test.integration.management.server.ServerEnvironment.war".asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFileAsset()).addAsLibraries(new StringAsset("<web-app/>").asFile(".war").asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFile("java.nio.server.type", "web-app/") That way it is required for testing.
I believe that this is the same as "org.jboss.as.test.integration.management.server.ServerEnvironment.war".asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFileAsset()).addAsLibraries(new StringAsset("<web-app/>").asFile(".war").asFileAsset(new StringAsset("<web-app/>").asFileAsset(new StringAsset("<web-app/>").asFile("java.nio.server.type", "web-app/") That way it is required to use the same profile profile in the test.
Nit: I don't think there's a need for this line - the previous line is the same as the previous one.
Nit: I don't think there's a need for this line: this.check = checkNotNull(in, "in");
Nit: I don't think there's a need for this line: this.check = checkNotNull(in, "message")
Can you add it to Builder method?
Can you add it to 'public'?
Can you add it to'set this method?
please remove append
please do this
please do not remove, please
Should we use RyaTypeHierarchy instead of HEADER_DEyaTypeHierarchyAdapter here?
Should we use RyaTypeHierarchy instead of 'new GsonBuilder()'?
Should we use RyaTypeHierarchy instead of 'new GsonBuilder()' to be set twice?
It would be a good idea to put this in a constant (e.g. KAFKA_NAME_LIST_NAME)?
It would be better to put this in a constant (e.g. KAFKA_NAME_LIST_NAME)?
It would be a good idea to put this in a constant (e.g. KAFKA_NAME_LIST_NAME)
Cant we make this package private?
Can you make this package private?
Can we make this package private?
please use getVmPool() instead of getVm()
please use getVmPool() instead
why not use getVmPool() instead of getVm()
Would prefer a one-liner with TCCL and add the TCCL as the variable.
Wouldn't this be the TCCL object per thread?
Would prefer a one-liner with a ternary operator.
listeners are not notified?
listeners are notified?
listeners
Consider checking current instanceof StatementTree here.
Can be rewritten with a return statement.
Can be rewritten with a single constructor call
Can we return name?
Can we return this?
Log messages?
this can be 'long' instead of 'Long'
this can be in a finally block
this can be in a single line (collect)
Suggest "not implemented"
SporizationService will never return null. Use Context.getgetSplics()
SporizationService will never return null. Use Context.getgetSpang() instead
I think this should be GTK3 && GTK3gtkRequisition.getBlockCalculationsGTK3(). I.e.: If you don't have the style, I can't think of anything that would be fine. This is a style typo.
I think this should be GTK3 && GTK3gtkRequisition.getBlockCalculationsGTK3(). I.e.: If you don't have the style, I can't think of anything that would be fine.
I think this should be GTK3 && GTK3gtk3
Consider calling this actions.get(JabRefPreferences.PUSH_TO_APPLICATION) from within the context class (which is what the original action)?
Consider calling this actions.get(JabRefPreferences.PUSH_TO_APPLICATION) from within the context class (which is what the original action)? That way you'd have to add logic to the place where it is used, and this breaks anything.
Consider calling this actions.get(JabRefPreferences.PUSH_TO_APPLICATION) from within the context class (which is a separate class) to add context support for specified actions.
Why is the getBeanAsJson() call needed?
Why is the null bean being returned here?
Why is the getBeanAsJson method duplicated here?
do we need to exclude all the commands?
I'm not sure about this.
I'm not sure about the place where one assertion fails.
A CI run has a lot of protobuf objects. I think it might be better to have protobufMetadataManager implement EmbeddedCacheManager and add protobufMetadataManager to JMX properties.
A CI run has a lot of protobuf objects. I think it might be better to have a single started query that takes a ProtobufMetadataManager.
A CI run has a lot of protobuf objects. I think it might be better to have protobufMetadataManager implement EmbeddedCacheManager and add protobufMetadataManager to AdminCache.
can we revert this : there is a random character between writing the rotation to the disk and the firstChar can't be null? We should also clean it up on 30% right?
can we revert this : there is a random character between writing the rotation to the disk and the firstChar can't be null? We should also clean it up with a protected static field
can we revert this : there is a random character between writing the rotation to the disk and the firstChar + 1?
IMO we should check if manager.isInitialized() && manager.isInitialized() && manager.isInitialized() && manager.getCleaner().
IMO we should check if manager.isInitialized() && manager.isInitialized() && prerequisite.isInitialized() || manager.getCleaner().isInitialized()
Question: if we have three times and isInitialized we should just check manager.isInitialized() && right?
Can be removed.
Redundant blank line.
Can return null.
return this
return getValue(public);
return getValue();
can we use %s here?
can we use Uppere here?
can we use Upper now on the instance variable?
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage? I would just use it here.
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage? Could it be moved to the storage?
This should probably also be part of the public API. The other usages are protected by the subclasses and are overridden by the subclasses.
This should probably also be part of the public API.
This should probably also be part of the public API. The other usages are protected by the subclasses.
If the key is "null" then the following 2 calls can be simplified to assertThat(verifierNode, () -> res.get(entry.getKey()).hasSize(1);
If the key doesn't exist, then it throws NPE.
If the key is "null" then the following 2 checks can be simplified to assertThat(verifierNode, () -> res.is(entry.getKey()))
why not use new ArrayList<>() here?
@marchof maybe we should simplify this to startupPage.getStartupPages()?
why not use new ArrayList<>() here.
Can you rename this to shutdownPublisherAndReportMetrics?
Fix the method name here.
Can we use synchronized here?
The same here with the above method.
The message should probably be the same as the method above and should be that.
The same here with the member variable.
See the original story as well. Change this to Thing's configuration file.
See the original story as well. Change this to "Configuration reloaded" to be the last one.
See the original story as well. Change this to "Configuration reloaded" to reflect the first configuration.
Add a new message to this exception: throw new IllegalStateException( "The channel cannot be accepted");
Add an extra message to this exception: throw new IllegalStateException( "The channel cannot be accepted");
Add a new message to the exception.
These are constants so they don't need to use them.
These are constants so they don't need to be defined directly.
The default is false (<LINK_0>
Could you please rename these to rFamLen, right?
Could you please rename these to rFamLen, right? I don't think matchingColumn is really necessary.
Could you please rename these to rFamLen, right? I don't think matchingColumn is any need for this.
Maybe you can add constructor which accepts a default value
Maybe you can add constructor which uses a default value
Maybe you can rename this variable to deleteRequest
Should this not be on a warn level? If someone else uses an warn, it would be an error. We should keep it as it is and only throw an exception if there's a bug in the broker.
Should this not be on a warn level? If someone else uses an warn, it would be an error that they're confusing
Should this not be on a warn level? If someone else uses an warn, it would be an error. We should keep it as it is and only throw an exception if there's a bug.
this method should return 0 if it does.
this method should return 1 if it does.
Verify that it does.
I think this should be formatted consistently with the methods below it.
I think it would be better if this can be extracted to a constant.
I think it would be nicer if this method could be extracted to a constant.
I would prefer to avoid null checks by using Optional
I would prefer to avoid null checks by using a default param and having null checks at the beginning of the method by using a builder
I would prefer to avoid null checks by using TmfAnnotationValidator.isElementValidator().
I think this is an update. What is the purpose of this test?
I think this is an improvement. What about making a constructor that explicitly denying no values? That would be more clean.
I think this is an improvement. What about making a constructor that explicitly denying no values? That would be an odd issue.
final
defineInVisibleLines?
define and return this
The "future" is supposed to be an empty String.
The "future" is supposed to be the format of an enum and this is a typo in the request.
The "future" is supposed to be the format of an enum and this is a bit strange.
Just use this if and move the regex to a private static final String groupId = getContent()!= null? "" : Ignore) {
Just use getContent() here, as the default value is null and is not the corresponding parameter.
Just use this if and move the regex to a private static final variable
java try { base.close(); } catch (CairoException ex) { System.currentTimeMillis(); return null; }
java try { base.close(); } catch (CairoException ex) { System.currentTimeMillis(); return null; } That way, you don't need to set the interruptor to something.
Actually,, java 7 can be used
I think we should add the exception as the second parameter to WARNING.
I think we should add the exception as the second argument to WARNING for debugging purposes.
I think we should add the exception as the second argument to WARNING for debugging to be safe
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean variable instead of a direct access.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It does not save the lock. Please use the local variable.
This isn't the default implementation of equals, is it?
This isn't the default implementation of equals, was it?
This isn't the correct way to use the name.hashCode(...), this should be enough.
Missing white space
Missing final
Can you have primitive int here?
Be careful of nullable fields!
We can make a function like getStringWithFormFieldId(FormGroup formGroup.getFields()),....
We can make a function like getStringWithFormFieldId(String formFiledId).
We should be able to use @Autowired public cleanUpWithAdmin(userAccount) { Context userAccount = Factory.getInstance(); Context userAccount = SalesforceAnalyticsManager.getInstance().clearCachedAs(userAccount); if (userAccount == null) { CB.clearCache(); } } return userAccount; }
We should be able to use @Autowired public cleanUpWithAdmin(userAccount) { Context userAccount = Factory.getInstance(); Context userAccount = SalesforceAnalyticsManager.getInstance().clearCachedAs(userAccount); if (userAccount == null) { CB.clearCache(); } return userAccount; }
We should be able to use the close method.
return defaultBase
method? this should only be used once, right?
return shouldn't be needed
Do we need to synchronize on this? In the case of the iterator, you could just use the new JSONArray if you want.
Do we need to synchronize on this? In the future, could this method be private?
Do we need the same check here?
nit: setScrollTargetCallback(ScrollTargetCallback) this. scrollTargetCallback = scrollTargetCallback; setBehaviorScrollTargetCallback(ScrollTargetCallback);?
nit: setScrollTargetCallback(ScrollTargetCallback)?
And this one should be setBehaviorScrollTargetCallback(ScrollTargetCallback)?
if it is not required.
if it's not required.
if it's not used, you can remove it.
return Objects.equals(RequestParam);?
return Objects.equals(RequestParam);
Objects.equals?
please use PreviewEditModePageObject#equals()
please use PreviewEditModePageObject#equals() here to simplify it
please use PreviewEditMode.test() here to avoid this line
I get a warning about this cast from Object
I get a warning here if this field is not set, won't it?
I get a warning here if this field is not set
Why not put the token type as a field?
i'm not sure why this is more correct.
Why not put the token as a field?
ofNullable maybe, no?
credentials!= null
Hardcoded data being mutable.
You can directly use!SanityManager.isEliminateNots() instead of.verifyEliminateNots()
You can directly use!SanityManager.isEliminateNots() instead of using toString()
You can directly use!SanityManager.isElide().
expect string should be the first parameter in _if_!_
expect string should be the first parameter in _if_
expect string should be the first parameter in _every_ file
Is it guaranteed that the lock is acquired by the first thread? I'm not sure why we're waiting on the timeout here, but we're waiting for the lock to be left to complete.
Is it guaranteed that the lock is acquired by the first thread? I'm not sure why we're waiting on the timeout here, but just wanted to make sure.
Is it guaranteed that the lock is acquired by the lock? I'm not sure why we're waiting on the first lock.
I think it would be better to move this method into _groupByColumns. That way we don't have to add extra logic to _groupByColumns. That way we don't have to add a _groupByColumns to _group_.
Can we move this method up to the caller of starTreeV2?
Can we move this method up to the caller?
I think we are missing a null check for this?
I think we need to support this for member variables
I think we are missing a null check for this.
position is not necessary, just add them in the order you want to have them there: baseActivityTestRule.launchActivity(new SetVariableBrick()); changeBrickPosition.addBrick(new SetVariableBrick());
position is not necessary, just add them in the order you want to have them there: baseActivityTestRule.launchActivity(new SetVariableBrick()); project.addBrick(new SetVariableBrick());
position is not necessary, just add them in the order you want to have them there: baseActivityTestRule.launchActivity(new SetVariableBrick()); addBrick(new SetVariableBrick());
This check and the previous implementation (and in the next commit) doesn't do anything?
I suggest to move this check at the beginning of the method, so that it does not depend on the query context.
resultInterface.setNeverLazy().
Why do we need this?
Why do we need this change?
why do we need this?
I think this should be CrashlyticsCoreService.setPlaybacklytics(true), as it's already done in the CrashlyticsCoreService.update() method.
I think this should be CrashlyticsCoreService.getInstance().CrashlyticsCoreService.setPlaybacklytics(true), as it currently is the only change in this file.
why is this necessary here?
please use try-with-resources
please use try with resources here.
unnecessary (readContent)
Arrays.asList()?
Arrays.asList()
String.split(args.length(), 1);
Might this be clearer as: java return v == null || (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) && isSubscriptionBasedLicense();
Might this be clearer as: java return v == null || (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense();
Might this be clearer as: java return v!= null && isSubscriptionBasedLicense && isSubscriptionBasedLicense();
Should this be marked as deprecated as it is in Page?
Should be marked as deprecated as it is in Page.
Should be marked as deprecated as it is in Page. Could you add this too?
I think this is not an issue, but I think that we should be able to set this to the default stats. This would be a breaking change in behavior for both the old and new versions.
Do we need a metric for both of these? I think we should have a well defined number of threads for this executor.
I think this is not an issue, but I think that we should be able to set this to the default stats. This would be a breaking change in behavior for both the old and new schemas.
nit: make it easier to read if you just use switch statement
nit: make it easier to read if you just use switch?
nit: make it clearer to use switch and return null ||!facetSamplerConfig
This is not needed as you can just inline the field in the Buffer constructor.
This is not needed as you can just inline the field directly.
This is not needed as you can just inline the field in the constructor.
What about logging: Object[] results = new Object[] {"in case (..) failed to be empty.");
What about logging: Object[] results = {"col"}
What about throwing exception instead of logging?
use lock if you're not using the sync collection.
use lock if you're not using the sync method
use lock if you're not using the sync collection
use new RuntimeInfo(new SafeUnit() {
use new getRuntimeInfo() instead?
use new getRuntimeInfo() to remove getPath().
Why are all these methods public? It seems to be the only usages of the public API. I'd make them package private.
Why are all these methods public? It seems to be the only usages here.
Why are all these methods public? It seems to be the only usages of the public API. I'd make them package-private and mark the method private.
It's not directly related to the cursor, but instead of checking for null, I think it'd be better to specify a default cursor (or something similar).
It seems that these assertions are not relevant anymore, so should be removed
It's not directly related to the cursor, but instead of checking for null, I think it'd be better to use cursors.remove( cursor );
Shouldn't we make this method final?
Shouldn't we test the future as well?
Shouldn't we test the future if we're missing a future?
Why do we need the CCC descriptor here?
Why do we need the CCC service here?
Why do we need the CCC lock here?
Should we just fail if we couldn't get here?
Should we just fail if we couldn't get the cached URI?
Should we just fail if we couldn't get the warn?
This could be written as: return t -> t.requiresTransaction() && tokens.stream().anyMatch(t -> t.requiresTransaction() || tokens.stream().anyMatch(t -> t.requiresTransaction(t.requiresTransaction()))
This could be written as: return t -> t.requiresTransaction() || tokens.stream().anyMatch(t -> t.requiresTransaction() || tokens.stream().anyMatch(t -> t.requiresTransaction(t.requiresTransaction()))
This could be written as: return t -> t.requiresTransaction(t.getTransaction().orElse(t.getName()));
Is this necessary?
Can we just add a publishers? This would remove the MetricsPublisher interface.
Is this being called for publishers?
since we expect ReflectionUtils to contain only "throws* exception" in test.
since we expect ReflectionUtils to contain only "throws Exception" in test.
since we expect ReflectionUtils to contain only "throws Exception" in testNameName
This message should be: "No page sink provider with catalog '%s' is required"
This message should be: "No page sink provider with catalog '%s' providerId"
This message should be incorrect, and the provider may be null
This is a small nitpicky but can you move this call up to the beginning of the method so that it's easier to read?
This is fine, but maybe it's not possible to merge the whole thing into this, just make it a no-op?
This is a small nitpicky but can you move this call up to the start() method so it's easier to read?
No need for getInstance()?
No need for this
initialize
Does this method need to be synchronized?
Does this method need to be public?
Does this method exist by magic number?
This might be clearer as a Set.
This might be clearer with a TVE somewhere passed in?
This might be clearer with a TVE?
why do you need to use the default charset here?
Why do you need to use the default charset here?
why not use the system default encoding in UTF-8 as well?
return default value
return default value should be false if default is true.
return default
The error message should be more detailed. How about The Exception may be thrown and the test will be executed in the logs?
The error message should be more detailed. How about The Exception may be thrown and the test should be handled with a SQL error so it is clear that it fails to parse?
The error message should be more detailed. How about The Exception may be thrown and the test should be handled with a SQL request
for the name, can we use name instead of this?
for the name, is this "sendMessage"? Isn't it just a copy of the result.
for the name, is this "sendMessage"? Isn't it just a copy of the result?
what's the point of having a loop here?
drop these 2 lines
can we extract a constant?
you should transit to this message instead of using ternary operator
you should transit to this message instead of using the ternary operator
you should transit to this message here
This one needs to be private.
This line is a duplicate of the line above.
This line is a duplicate of the fragment above.
This is always null
This is always null.
This is always true.
can this be new ArrayList<>(config.getCause())?
Shouldn't this be new ArrayList<>(configs);
can this be new ArrayList<>(configs);
This should be context.getCurrentAddress()
This should be context.pathAddress()
This should be context.getCurrentAddress() == null
No need for this log message. The method should not be called _only_ if the parameter is false.
No need for this log message. The method should not be executed if seasons return null.
No need for this log message. The method should not be called _only_.
Do we really need this? I think it should be a debug.
Do we really need this? I think its a debug message.
Do we really need this? I think its a debug message
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message/Expected exception.
Please close this.
Please close the connection to the end.
Please remove this.
Move String values used more then once to a constant.
Move String values used more then once to a constant. Let's use a constant for this path.
Move String values used more than once to a constant.
Label should be reporting.parameter.date.startDate
Label should be reporting.parameter.date.
Label should be reporting.parameter.date.Date
The loop is not needed.
The loop is not needed
The loop is hard to read.
I think it would be better to use SQLDataSetDefValidationUtils.validateCustomAttributes...
I think we can improve the readability a bit here?
I think it would be better to use SQLDataSetDefValidationUtils.validateCustomAttributes...?
not related to this PR, but shouldn't this be based on the Value interface?
not related to this PR, but shouldn't this be based on the headers headers?
not related to this PR, but consider using functional style Optional#getFirst
detach?
great cleanup!
great catch.
please use NotImplementedException()
please use NotImplementedException() instead of IOException
missing NotImplementedException()
Shouldn't this check for the entire result of the tool?
Shouldn't this check for the entire view of the result?
Update: This should go for an entire test method and then should return true.
I'm not sure this is helpful. If you need to call this in a transaction, you should just get the countPerNode and check if it's empty.
I'm not sure this is helpful. If you need to call this in a transaction, you should just get the count of the list and compare it with the number of arguments.
I'm not sure this is helpful. If you need to call this in a transaction, you should just get the count of the list and compare it with the number of elements.
should be package-private unless it is a public API.
shouldn't it be package-private?
shouldn't it be package-private?
I think it might be clearer to use mapKeyToPrimaryAndBackups.
I think it might be clearer to use mapKeyToPrimaryAndBackups here too
I think it might be clearer to use mapKeyToPrimaryAndBackups here?
Please remove this. The same for the shutdownApp(EmbeddedAppHandleImpl.class)
Please remove this. The same for the shutdownApp(EmbeddedAppHandleImpl) method.
Please remove this. The same for the other setter is already checking runningMode.
Should this also use UserDao.getMemberByUsername(...)?
Should this method be changed to equals() as well?
Should this method be changed to MemberDao::getMemberByUsername()?
why do we need this list for sortedOrderInList?
why do we need a list, you can use ArrayList directly here
ArrayList is not used
should this be return 'public'?
should be return 'public'
return this.publicKey;
This method is called after the removal of the instructor for invalid courses, which may be a bug, but need to be manually typed (in the UI too).
This method is called after the removal of the instructor for invalid courses, which may be a problem, but need to be manually typed (in the UI too).
This method is used once, but need to be static too.
Remove this blank after the cast.
Change this blank after the cast to Type, right?
Change this blank after the cast.
Better revert.
Use the solution in the large Overall/Manage PR instead, please.
Change this to Jenkins.CONFIGURE.
I think it should be getRoot()
I think it should be the form actual Cause
I think it should be the form actual non-nullable
Since we are improving this code anyway, I think we should switch to [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Since this is the same for non-ascii characters, we could replace it with java.util.Objects.contains(value, input)
Since this is the same for non-ascii characters, we could replace it with java.util.Objects.contains(value, input) method.
Points to Points. You don't need to override Points. I think this should be public right?
Points to Points. You don't need to override Points. I think this should be done for the newPoints. @Override public String Points<Number> HASH_TYPES = new Points();
Points to Points. You don't need to override Points. I think this should be done for the base class. Points.
It seems that you can safely remove else block and if condition and just do what is written in the true-case block no matter if you have just one header.
It seems that you can safely remove else block and if condition and just do what is written in the true-case block no matter if you have just one event, you can safely remove it.
It seems that you can safely remove the annotation and if possible you can use hasNext() instead of stop().
Maybe you could initialize lastSentBrightness directly in the line below, which is more readable.
Maybe wrap this into the line below would make it clearer.
Maybe wrap this with null.
Doesn't this also trigger a break?
Doesn't the item need a tooltip?
Doesn't the item need a tooltip? This would be much clearer
Maybe it would be better to just return if (model.getConfirmWindow()!= null) { return getConfirmWindow(model); }
Maybe it would be better to just return if (model.getConfirmWindow()!= null) { return; } where the getConfirmWindow() call is called?
Maybe it would be better to just return if the window is not null?
Could we have a [SimpleEventRegistry](<LINK_0> method instead?
Could we change the signature here to have the @Event annotation, to have the symmetry?
Could we have a [SimpleEventRegistry](<LINK_0> method, for consistency?
I tend to prefer to use a lambda expression as per line style:.map(Class::symbol) instead of iterator().map(VariableTree::symbol).closeBraceToken())
I tend to prefer having both ifs, split this if statement in order to be more explicit.
I tend to prefer to use a lambda instead of a very simple loop.
I think this should be changed to: java @Override public  cleanTempIndexFile(File workDir) { return null; }
Let's use defragmentedIdxFile.toPath() instead of the assignment for defragmentedIndexFile.
Let's use defragmentedIdxFile(workDir) instead.
Is there a particular reason why you are checking for a particular range instead of the number?
Is there a particular reason why you are checking for a particular range instead of 0?
Is there a particular reason why you are checking for a particular range instead of the number?
Oh, I see, but I'm not entirely sure whether we need this method or not. If we support the builder, I can get a default value with the attribute builder. So we can make sure that the default value is 10.
What's the reason for the builder?
Oh, I see, but I'm not entirely sure whether we need this method or not. If we support the builder, I can get a default value with the attribute builder. So we can make sure that the default value is 10 here.
We should reverse this.
We should reverse this. If the index is started, we need to check if it's null.
We should reverse this. If the index is started, we need to check if it's stopped using index like this.
Are you sure about this? The modabilites can be null.
Are you sure about this? The modabilites can be set to null.
Are you sure about this? The modabilites can be set with the tile not being null.
You should be able to store owner of a local variable like this: i.e., return cachedOwnAttrs == null? null : cachedOwnAttrs
You should be able to store owner of a local variable here since it is not directly used anywhere.
You should be able to test against owner of a given user in the servlet container. It is not transformed into a variable.
Is there a reason not use.asType().toString()?
Is there a reason not to use.asType()?
Is that really needed?
The list returned by serviceDAO.findMyEntries() is already sorted.
The list returned by serviceDAO.findMyEntries() is never called.
The list will never be empty.
Same here, we need to use ConfigurationSetting to make it consistent.
Same here, use ConfigurationSetting to make it consistent with other classes.
Same here, we need to use setLabel
super.remove?
Catch?
formatting
I am unsure we need check here too. Could be a different way of checking attributes.
I am unsure we need check here too. Could be a different way around A getAttribute, get and return this when creating the attribute
The check of the attributes can be moved to inside of A getAttribute, not in attributes.
rename to bundleSleep
rename to bundleSleep or similar
this should not be a static
Same here, I don't think it's better to use Map.computeIfAbsent
Same here, I don't think it's better to use magic number.
Same here, I don't think it's better to use CountsTest.COUNT
@dmzaytsev this is not a good idea
StringBuilder is faster
StringBuilder should be faster
So this could be: return (fValue!= null)? super.toString() : super.toString();
So this could be: return (fValue == null)? String.valueOf(fValue));
So this could be: return (fValue!= null)? super.toString() : super.serialize();
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
shouldn't the test throw the error, it will be marked as a failure too, with complete stack?
shouldn't the test throw an exception if the file exists but is null, it will be marked as a failure too, with complete stack?
Will need to be changed
Will need to be change to default
Will need to be public
Can be inlined in the test.
Can be simplified by using an forEach method.
Please use forEach() here.
Please don't use final for local variables. It's not really needed, but please don't use them.
Please don't use final for local variables.
Please don't use final on variables. It's a bit hard to read and comes from the rest of the code.
Instead of re-formatting you could call toString() instead
Instead of re-formatting you could call toString() instead of toString()
Instead of re-formatting you could use StatisticsFormatter.format(...) to make it compact.
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
You could do the same thing by checking @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class);, see below.
Do you need this check here?
Do you need this if here?
Do you need this condition?
Should those hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode() implementation.
Should those hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode() implementation. Why don't we use TestHashCodeBuilder in JdbcTestUtils.toHashCode()?
Should these hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode() implementation.
Could you add a check if event is null here? I mean, I am trying to understand what event is in this case.
Could you add a check if event is null here? I mean, if there is no event in the queue then events will be lost.
Could you add a check if event is null here? I mean, if there is no event in the queue then events will not be sent.
you don't need to assign null to and return
you don't need to assign PrimaryKey here.
you don't need to assign null to and return.
![MAJOR](<LINK_0> 'Severity: MAJOR') Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> 'Severity: MAJOR') Refactor this method to throw at most one checked exception instead of: java.util.concurrent.ExecutionException, io.IOException, java.util.concurrent.ExecutionException, io.IOException) at com.google.common.base.Preconditions.checkNotNull(e).
should it be a try-with-resources?
should the try-with-resource be here?
should it be a try-with-resource (sincesince AutoCloseable)
should we use a constant for the "rateLimiterKey" and "latest" for consistency?
should we use a constant for the "rateLimiterKey" perhaps?
should we use the same mechanism to define these values?
java return "Abort and restart the build the build action" +...
java return "Abort and restart the build the build action"?
java throw new IllegalArgumentException("Abort for restart the build the build action");
This can be simplified by avoiding the local variable: return (autopacklimit < 0)? repo.getConfig().getInt( ConfigConstants.CONFIG_KEY_AUTOPACK) : autopacklimit;
This can be simplified by avoiding the local variable: return (autopacklimit < 1)? repo.getConfig().getInt( ConfigConstants.CONFIG_KEY_AUTOPACK) : autopacklimit;
This can be simplified by avoiding the local variable autopacklimit variable.
externalize
same suggestion as above.
same question about the style
I think these two lines should be synchronized. They are still around the check, so that they have an access to the attribute.
I think these two lines should be synchronized. They are still around the same code, so that they have an order.
I think these two lines should be synchronized. They are still around the critical values.
Why can't the consumer acquire the lock?
Why can't the consumer acquire a lock to the domain?
Why can't the consumer acquire a lock to get the lock?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') fieldTypesMap [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') fieldTypesMap 'public')'is not needed. [![rule](<LINK_1>](<LINK_0>
Shouldn't this be stateModelToReturn
Shouldn't this be copingStreamToReturn
Shouldn't it be coping to use the enum?
No need for a null check.
No need to cache a list of rule objects.
No need to cache this.
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Code snippet for if condition be as follows: if (io == AbstractBaseKafkaInputOperator.APPLICATION_OR_EARLIEST ||  == AbstractBaseKafkaInputOperator.APPLICATION_OR_EARLIEST ||  == AbstractBaseKafkaInputOperator.APPLICATION_OR_EARLIEST) {
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. which is not needed for your PR.
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Try to run this code.
I don't know if this is about to be public, but it should be just public.
I don't know if this is about to be public, but it should be just public
final
return Status.BACKUP_FAILED;
return Status.BACKUP_FAILED; is better here
return Status.BACKUP_FAILED?
I would say "Key passed by key must be 32B".
I would say "null key passed" here to match the value.
I would say "Key passed by key must be 32B". The "key".
No need to declare this exception here, that's the reason you have to declare throws Exception.
No need to declare this exception here, that's the reason you have to declare it throws Exception.
No need to declare this exception here, that's the reason you have to declare the method, rather than just return null.
Missing @Override
warn
Should return Response
If an exception is thrown, then arts will be to catch it and throw a NotFoundException. Or am I missing something?
If an exception is thrown, then arts will be to catch it. Or if the key was different then arts would be to throw a NotFoundException.
If an exception is thrown, then arts will be to catch it. Or if the key was different then arts would be to do it.
This else if case is redundant.
This else is redundant.
Should be unitFrom * unitTo).
use ShellIsAvailable
use ShellIsAvailable?
use ShellIsActive
throws
unsure if it's a good idea, but shouldn't we just return null here?
unsure if it should be a ConcurrentModifificationException.
include KeyFilter filter and KeyFilter to to make it clearer.
include KeyFilter filter and KeyFilter to purpose?
include equals
Currently, value is Integer and not int, so isn't it?
Currently, value is Integer and not int, so isn't it reasonable to set value to null?
Currently, value is Integer and not int, so isn't it reasonable to return null?
Use QualityGateWsSupport#getOrganization (QualityGateWsSupport is already used in this class, and it is not necessary to re-use it).
Use projectStatus.getString() instead of client.getHttp().getHttpParam()
Use QualityGateWsSupport
please remove the resource mapping from the resource.
please use parameterized logging instead of string concatenation
please use parameterized logging instead of string concatenation.
Change to Integer.valueOf(int)
Change to Boolean.valueOf(int)
I suggest we use binary 'int' here.
Why not switch to enum?
Why not switch the version in the builtInMetricsVersion?
Why not switch the version in the enum?
can we store "gaAccount" in a constant and reuse it here?
can we store "gaAccount" in a constant?
can we store "gaAccount" in a constant and use it here?
This fix should not be necessary.
This could be slightly clearer.
This list could be very specific.
Previous implementation was pretty fine, you can have two DoubleStreamUtils.stream(elements) with a single instance. I believe it will work here.
Previous implementation was DoubleStream.of(elements); and Revert all above?
Previous implementation was DoubleStream.of(elements);
Arrays.asList can be used here
Arrays.asList?
Shouldn't this be here?
Why are you blocking here? this should be async throughout.
Why is this blocking call needed? This should be async throughout.
Why are you blocking here? This should be async throughout.
Have you considered using something like Guava's [worth](<LINK_0> here?
Have you considered using project.post(BuildTarget.of("com.example.war")) instead?
Have you considered using project.post(BuildTarget.builder() instead?
Can't we just set without compare?
Can't you just set without compare?
Can't we just set without checking for bufferList?
suggestion "Namespace is longer than "+MAX_NAMESPACE_LEN+" characters");
suggestion "Namespace is longer than "+ MAX_NAMESPACE_LEN+" characters");
Instead of catches and rethrowing the IllegalArgumentException, I think we can catch the RuntimeException (which is also a better fit for this one)
remove
remove these or log.
remove sysout
Maybe "bbmri_eric"" makes more sense.
Maybe "bbmri_eric"" makes more sense?
Maybe "bbmri_eric" as a verb is two words, so it's clearer.
This should be caught at the top of the method. Otherwise passing Ref tag to the method will be confusing.
This should be caught at the top of the method. Otherwise passing Ref tag to the Git object is confusing.
This should be caught at the top of the method. Otherwise passing Ref tag to the Git object is confusing. It may be better to wrap it in a GitException.
return prevValue; can be simplified to int x = extraData.get(new Vector3i(x, y, z);
return prevValue; can be simplified.
return prevValue; can be simplified to int x = extraData.get(new Vector3i(x, y, z));
can we use similar logic here - define util for that?
can we rename currVal to should be consistent?
can we use similar logic here - it's cleaner to use drainh instead
I prefer Assert.notNull(this.getName(), actionParameter.getName()); to be safe
I prefer Assert.equals() to be used here: <LINK_0>
Good idea!
suggestion timer = new isSuccess().append(new Digest(ozoneConfiguration.getDigest().toString()));
suggestion timer = getMetrics().timer(" options.getBucket(input);
suggestion timer = new isSuccess().set(null);
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
Is this really needed? It seems that this should be part of the exception interface. Maybe it should be more specific in the exception type.
Is this really needed? It seems that this should be instanceof Incompatible
Why not just pass vmNumaNodes as an argument?
Why not just pass in VmAnalyzer to the constructor?
Why not just pass in VmOperationDao instead of doing this?
This whole lambda can be moved to just one line (same for "this" below)
This whole lambda can be moved to just one line.
This whole lambda can be moved to just do flags.put("this", "bool", "parameter")
This condition will always true in the first place. You should check whether unmanagedList.isEmpty() before b > 0.
This condition will always true in the first place. You should check that first element is unmanagedList.isEmpty()
This condition will always true in the first place (such as if at all).
Should we handle error here?
Should we handle error?
Should we add error checking if error is thrown?
Formatting
Unnecessary line
Unnecessary
you should use compareTo() and equals()
you can use Objects.equals()
you should use compareTo() and equals() at least
no need to use a Date instance here. It's already a UUID, no need to create a new Date().toInstant().
no need to use a Date instance here. It's already a UUID, no need to create a new Date instance here.
no need to use a Date instance here. It's already a mutable value either.
you don't need to check if that is true or false, and we should add logging in that case.
you don't need to check if that is true or false, and we should add logging for!
you should add final
rename this to method
apply to all other components here.
rename this to ContainerBuilder
Unnecessary line
missing space between ) and {
Style issues with { } around if
I'd try to use Builder pattern here, with a builder.
I'd try to use Builder pattern here, with a ternary operator
I'd try to use Builder pattern to a
Collections.singletonList()
Use Collections.singletonList() instead.
Arrays.asList() will not be needed
missing a space after,
missing a space after the,
missing a space after the :,
I'm not sure this is the right exception here.. it's the best way to inform the user that the operation needs to be configured. I would rather see the cause here.
I'm not sure this is the right exception here.. it's the best way to inform the user that the operation needs to be configured. I would rather inform the user about the operation to be "The operation is malformed".
I'm not sure this is the right exception here.. it's the best way to inform the user that the operation needs to be configured. I would rather inform the user about the operation to be "The operation is malformed"
To be consistent with elsewhere, can we do a quick checkNotNull(e)
To be consistent with elsewhere, can we do a quick checkNotNull(second), checkNotNull(value)
To be consistent with elsewhere, can we do this.
The order of the arguments is reversed - it should be assertEquals("", result.size());
The order of the arguments is reversed - it should be assertEquals("", result.getVdsUniqueId());
The order of the arguments is reversed here as well?
How about instead of having multiple lines for the eviction index?
How about instead of having each log message if we don't write anything to the cache?
How about instead of having each log message for the eviction index?
CAggregatedMemoryContext.this.delegate = requireNonNull(delegate);
CAggregatedMemoryContext.this.delegate.closeAggregatedMemoryContext()
CAggregatedMemoryContext.this.delegate.closeAggregatedMemoryContext.
The old code was a bit redundant with the class name. Can we rename it to something like "Lambda" for consistency?
The old code was a bit redundant with the class name. Can we make it a protected method getName() for consistency?
The old code was a bit redundant with the class name. Can we rename it to something like "Lambda" here?
If this is shown in the UI, I would suggest including the title of the bundle: "Table Report - Merge View - Merge View Name" where you use this grammar (e.g. "Table Report - Merge View'Merge View'Merge View'Merge View'Merge View'Merge View'Merge View'should be'Merge View '.
If this is shown in the UI, it will return 200 OK. And I don't think the message needs to be updated.
If this is shown in the UI, I would suggest including the title of the bundle: "Table Report - Merge View - Merge View Name" where you use this grammar (e.g. "Table Report - Merge View Name Merge View - Merge View Name")
Nit: Should probably be initialized with a parameters.
Nit: Should probably be initialized with constants.
Nit: maybe call this the constructor on the test cluster and just directly the string?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we could say "don't do that."
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former.
I would suggest static import of org.apache.commons.lang.StringUtils.isEmpty
this could be static
I would suggest static import
Could the doFill be a field on a different thread?
Could the doFill be a field?
Could the doFill be a field on a different line?
Would it be useful to use a StringBuilder here instead of a String?
While I understand your question, this would probably be the best option here. Can you use a StringBuilder instead?
While I understand your question, this would probably be the best option here instead of the concatenation.
Shouldn't it be public?
Shouldn't this be public?
Shouldn't it be synchronized?
please assert this
this can be removed.
this can be removed
ServerSocket implements AutoClosable, so try (ServerSocket socket =...) {} might be stylistically better?
ServerSocket implements AutoClosable, so try (ServerSocket socket = socket.close()) { ServerSocket socket = new ServerSocket(conn); port; }
ServerSocket implements AutoClosable, so try (ServerSocket socket = socket.close()) { } or even better AutoCloseable.
Is it better to put the cause here?
Is it better to put the cause here?
Prefer to add a space before the opening curly bracket
Maybe just return type here.
Maybe just inline this.
Maybe just return type here?
Could be simplified: return Objects.hash(version, version);
Could be simplified: return Objects.hash(version, name);
Can be simplified: return Objects.hash(version, version);
Looks like a copy/paste error here. Here and elsewhere. I would recommend to put this in a private method
Looks like a copy/paste error here. Here and elsewhere. I would recommend to put this in a finally
Looks like a copy/paste error, but not a big deal
Is it necessary to convert this to a Path and just use StandardCharsets.UTF_8?
Is it necessary to convert this into a Path and just use StandardCharsets.UTF_8?
Is it necessary to convert this to a Path and just use StandardCharsets.UTF_8? Also, why not just endsWith("/")?
I think we should have a test that confirms the error message here.
Can we remove this second part? I think we aren't actually doing this after the test.
I think we should have a test that checks if the offsets are present in the background.
nit: can you rename this to be testThorough?
Make the test a bit more readable
nit: should readThorough too
One of the following was to prevent calling get_allocation() if it is not of the main thread.
One of the code from line 3.10, and ERO_WIDTH should be symmetric with ERO_WIDTH.
One of the code from line 3.10, and 32
Is it worth to check for null here?
You can remove the super() here.
Should check for null
here you do not need the null check.
here you do not need to do this, just return null.
here you are not gonna want to do this, but you need to specify the username and password for 0,8 into Java
And here as well.
And here as well
And I suspect this has to go wrong :-)
should be done in the exception
should this be exception?
should be done in the constructor.
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to events?
no need for the extra '()' and missing space before '{'
no need for the extra 'if' and missing space before '{'
Again, the next line can be removed.
why is this change necessary?
Shouldn't this change be in another patch?
Safer to check if entry already exists. If yes, re-use else put new one.
Safer to check if entry already exists.
minor: reformat line
Why not use this?
Why not use this: return ((xValue) xValue).multiply(xValue);
Why not use this: return QuantityType.this.multiply(xValue);
Shouldn't this happen in the parent class?
Shouldn't this happen in the resource?
Shouldn't this happen in the typical run in file?
Use encodings.
Use encodings?
encodings?
It seems like the depth property is not used anywhere.
It seems like the depth property is not used.
It seems like this is not used.
It would be nice to have some message like: {error on establish connection with remote server {0}. {type}. The message in the exception may be misleading.
It would be nice to only log the exception in case it happens one item.
It would be nice to only log the exception in case it happens for other exception.
missing @since FolderPermissionLevel isn't set to FolderPermissionLevel
missing braces, more of these below
missing @since FolderPermissionLevel is set to FolderPermissionLevel and can be removed
can we avoid the if here?
can we avoid code duplication by making the code below?
can we avoid code duplication by making the code here?
Add this to message?
Add this to the FlowFactory builder?
Add this to the FlowFactoryImpl?
[x] Is this the same as the one above?
[x] I think the expression is the same as before, so we use "Assert.fail(...)".
Ping.
Wrong default clock provider?
Wrong default clock provider should use the system time zone id.
Wrong default clock provider should use the system time zone to 0.
Add another assert that the page size is not 0.
You can define another method for this purpose: species=1000&page=100012
Add another assert that the page range is > 100.
please decrease to DEBUG
this should go in properties file
this should return an Optional<>
Test name says 'MultipleAssignmentException', but the variable name is also 'testMultipleAssignmentException'
Test name says 'MultipleAssignmentException', but the variable name is actually educateee
Test name says 'MultipleAssignmentException', but the variable name is never thrown.
Just return jobName to be null if default is null.
Just return jobName to be null if default is null?
Is this supposed to be null or should this be Optional?
Why is this synchronized?
Why synchronized?
Why catch Exception?
Why do you need to bind the Context?
Why do you need to do this?
Why do you need to mark the context as argument?
suggestion EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptySubprocess, EMPTY_VALUE);
Why should this be the throws?
Why we have this throws?
Why are we returning WARN for this?
Is this change due to a merge conflict with the previous one?
Is this change due to a merge conflict with the next major version?
Is this change related to the bug report?
This is a lot of duplicated code. Why not make it a method that isFileTypeValid and use that?
This is a lot of duplicated code. Why not make it a method that takes a boolean?
This is a lot of duplicated code. I wonder if this should be a method that takes a boolean?
This should return the reference, not the interface.
This should all be removed, not the static access.
This should all be removed, not the static access modifier.
are you sure it is needed?
are we sure it is always a clone?
make it private and remove the @NonNull annotation.
Should be done in a separate constructor.
Should be done in a finally block.
Should be done in a constructor.
I see the act of this.sessionFactory.get() and remove the Config variable in this class. Should probably be above the remove method.
I see the act of this.sessionFactory.get() and remove the Config variable in this class. Should probably be above the logic in this class.
I see the act of this.sessionFactory.get() and remove the Config variable in this class. Should probably be above the logic in ConfigKey.
rename to signature
rename to signature instead of inputTypeSignatures?
rename to signature instead of _EMPTY_
Shouldn't this be getRelatedMessageId()?
Why not use messageResource instead of this
Shouldn't this be getRelatedMessage()?
Shouldn't we do an.show() here? It's not a good practice to manually set the activity to null, and will leak the activity if it fails.
Shouldn't we do an.show() here? It's not a good practice to manually set the activity to null, and will use the same activity as an activity lifecycle.
Shouldn't we do an.show() here? It's not a good practice to manually set the activity.
You're not testing the fact that the transaction events are actually returned in the transaction. I think it might be clearer what's going on if you call transactionEvents.get(0).getStatus() instead of this.ChargeStatus.CREATED
You're not testing the fact that the transaction events are actually returned in the transaction. I think it might be clearer what's going on if you call transactionEvents.get(0).getStatus() instead of is(1));
You're not testing the fact that the transaction events are actually returned in the transaction. I think it might be clearer what's going on if you call transactionEvents.get(0).getStatus() or something like that since the transaction event should be committed there
Would be nice to have a test that verifies that configService.updateConfigs does not return null.
Would be nice to have a test that verifies that configService.updateConfigs(configList, null, configList)?
Would be nice to have a test that sets the configs to null.
again, better to log the response
again, better to log the error
again logging here?
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "![![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "Long" by: [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') javax.vaadin.flow.core.features.registries.GrinderRecipeManager.all(object). [![rule](<LINK_1>](<LINK_2>
Not sure if it matters, but I think it's better to use switch-case here.
Not sure if it matters, but I think we should be consistent to use the default case.
Not sure if it matters, but I think it's better to use the same approach that the default case is consistent.
We are not removing these two lines. I would prefer to just remove them. And if there are other ones that are removed, > MAIL_SESSION_NOT_ADDRESS and NO_SESSION_NOT_ADDRESS, then remove them.
We are not removing these two lines. I would prefer to just remove them.
We are not removing these two lines. I would say.
I'm not sure this is correct, shouldn't we _not_ have the callback here?
@manuelplazaspalacio I'm not sure this AsyncQuery is used here.
@manuelplazaspalacio I'm not sure this is correct, but shouldn't we set the external listener to asyncQuery and here instead of this?
nit: can you flip the 'if' to avoid double-negative?
nit: can you flip this around and avoids the 'this' keyword?
nit: can you flip this back to the 'this' clause?
Could you call IntSets.forEach((int segmentsLost)?
Could you wrap this if statement with brackets?
Could you call IntSets.forEach()?
I would use Tree.Kind.CLASS here as well.
I would probably use Tree.Kind.CLASS here as well.
I would use Tree.Kind.CLASS here as well. I think the test method should be compliant.
You can use spmMap.put(spId, host);
You can use host.put(spId, host);
You can use spmMap.put(spId, host) to do the same thing.
should this be initialize in the constructor instead of assigning it all on one line?
should this be the default value (null) instead of the default value?
should this be initialize in the constructor instead of assigning it to a field?
Why do we need here roundtrip? Is it the last roundtrip that is called?
why do we need here roundtrip?
why do we need here roundtrip?
Please don't change the operands.
Please don't change the arguments.
Rename this to "AbstractInsnNode abstract".
Pattern.compile should be a static field, so that you can re-use it?
Pattern.compile should be a static field, so the matches can be updated only once.
Pattern.compile should be a static field, so that you can put this in it.
remove the new line
The new flag is useless here...
pass out the new parameters?
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled?
You should check whether this is defined as the type before casting. Just in case.
Please do not use the 2-arg constructor.
Please do not use the java convention for this: java return new Valid<>(supplier, );
Please do not use the ValidCommand. Synchronize on this.
Isn't it possible to just choose the expected type instead of creating a new one?
Isn't it possible to just pass the expected properties as a string? If so, we can just define a constant for that
Makes a function like the other examples.
I would use a try-with-resources statement here to make it more clear that we are using an instance variable
I would use a try-with-resources statement here to make it more clear that we are releasing the entity multiple times.
I would use a try-with-resources statement here to make it more clear that we are using an instance variable.
We could also check that providedNamespace is not null here: <LINK_0>
We could also check that providedNamespace is not null here. (Same for other similar places)
We could also check that providedNamespace is not null here. (Same for other similar code)
same here: Why is this needed?
same here - why is this needed?
same here: why is this needed?
What about the transportConnection.close() instead of the AtomicReference?
And in the same line of code.
What about the transportConnection.close()?
Should we change this to notLanguageTag?
Should we change this to a defaultBrowserLanguageTag("en-GB")? Otherwise, we don't have to create a defaultBrowserLanguageTag
Should we remove this switch? They can't be used.
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it anywhere.
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it, I think you need to send the query string anyway.
Now that you're encoding the ID are you missing decoding it somewhere?
should this be the parser?
Why should this be the parser?
Why should this be the parser method?
Will the volume be set in the constructor from parameters?
Will the volumeId not be set in the constructor from parameters?
Will the volume status not be set in the constructor from parameters?
mSessionApi.jpg2 is not too much specific.
mSessionApi.uploadApi(mSession);?
mSessionApi.jpg2
This might also cause a NPE if subject is not an Subject.ANONYMOUS is true.
This might also cause a NPE if subject is not an Subject. ANONYMOUS is true.
This might also cause a NPE if subject is not an Subject. ANONYMOUS is true; is a better choice.
Seems like we should also set this to 1 in div for the next line.
Seems like we should "div" not "first".
Seems like we should also set this to 1 in div.properties so that this is the default div file.
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgmentSearchResult(Judges)
judgmentSearchResult would be better here. The original code already explains why it cannot be null.
Isn't this the same as containerRequestContext.isSecure()?
Isn't this returning false?
Isn't this returning a copy of the account type?
Is this method needed?
Is it by design or just put this method there?
Is it not the proper way to make this method protected?
Could this be something like: java return getFileOperations(type) == null? DefaultFileOperations.INSTANCE : null;
Could this be also simplified to: java return getFileOperations(type) == null? DefaultFileOperations.INSTANCE : null;
Could this be also simplified to: java return getFileOperations(type) == null? DefaultFileOperations.INSTANCE : null);
Why "true".
Why "true" here?
Why "ex" is hardcoded?
Better use INSTANCE.getString("This operation is not implemented")
Better use INSTANCE.getString("This operation is not supported")
Better use a constant INSTANCE.
Why can't we have a simple method to check the account name and compare it with instanceof?
Why can't we do instanceof account name check here?
Why can't we have a throwing exception for this?
Should use ByteBuffer.toUtf8(fieldName, fieldNameBytes) here
Should use ByteBuffer.fromUtf8(fieldName, fieldNameBytes) here
Should this be doing something similar to writeToTopology().
This condition seems unnecessary
This condition looks like it does not have been removed.
alignment with &&
Make this final
Make the variable final
nit: int totalCards = 0;
If using a byte array on the buffer, it will be faster to read and write directly to the byte array. A ByteBuffer can be the length of the file and would be faster to read it.
If using a byte array on the buffer, it will be faster to read and write as a byte array on the original array. A ByteBuffer can be the length of the file and would be faster.
If using a byte array on the buffer, it will be faster to read and write as a byte array on the original array. A ByteBuffer can be the length of the array, and would avoid allocating a byte array on the binary.
rename to methodOfType
Please change to IType.isTypeOfType(IMethod.class)
Please change to IMethod.isTypeOfType(IMethod.class)
Why do we need this line?
Why do we need to subtract?
Do we need to release calls before the statement?
can we do the same here (and above)
can we do the same here?
nit: can be final
Should be: ObjectId id = (RevWalk) storeCommit(parseCommit(id), fs, RevObject.TYPE_COMMIT);
Should be: ObjectId id = (RevWalk) storeCommit(parseCommit(parseCommit(id), fs, Rev()).toObjectId();
Should be: ObjectId id = (RevWalk) storeCommit(parseCommit(parseCommit(id), fs, Rev.TYPE_COMMIT))
Throw the proper exception if something is not supported: - NullPointerException if frameID < 0 or if frameID > 255.
Throw the proper exception if something is not supported: - IllegalArgumentException if frameID < 0 or if frameID > 255.
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID > 255.
Same as above for otherNonCodedConceptUuid
Again, same as above for otherNonCodedConceptUuid
Same as otherNonCodedConceptUuid
This should be removed
I think we should log here
I think we should log here.
java throw new IllegalArgumentException("Should not happen.");
java throw new IllegalArgumentException("Should not happen."); }
Maybe throw IllegalArgumentException and log the exception
Best to use the enum value here since it's not the default value
"Optaplanner.Implemented"
Best to use the enum value here.
MemStore is used for tests, so we need to implement this function.
MemStore is used for tests, so we need to keep this function simple.
MemStore is used for tests, so we need to keep this function simpler.
waitForVideoPlayerVisible returns false so you can put the code in waitForVideoPlayerVisible().
waitForVideoPlayerVisible returns false so you can put it in waitForVideoPlayerVisible().
waitForVideoPlayerVisible returns false so waitForVideoPlayerVisible might be called before the waitForVideoPlayer()
You don't need to call.getValue() here, since the method neither does anything with the value, nor does it return it
You don't need this. You can invoke the API and leave it at that.
You don't need to call.getValue() here, since the method neither does anything with the value, nor does it return it.
Just an observation to think about if we didn't want to do the Optional.ofNullable in the method.
Just an observation to think about if we didn't want to do a Optional.ofNullable in the method.
Just an observation to think about if we would return the options field.
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
I know this was just copied from the original code, but bundle can be null here (although very unlikely)
"Could not get the bundle for..."
Why not just write this as column?
Why not just write this as ship_month?
Why not just write this as queryRunner?
This would also lead to exception, I think it would be nice to also raise correct exception type for this case.
This is a CFG class
This is aCFG patch.
Do you know why containerId is not supported here?
Do you know why containerId is not added here?
same question
The constant should be called PartitionByPartitionByPartitionBySchema.
The performance of PartitionBy partition could be quite expensive. What if the partition is large?
The constant should be called PartitionByPartitionBySchema.
I am not sure if this is correct. Does this make sense? If the file is not "BEARER"?
I am not sure if this is correct. Does this make sense? if the file is not already there, it return a boolean
I am not sure if this is correct. Does this make sense? if the file is not already there, it return null
This should not be registered on an HC.
This should not be registered on an HC/I/e.
This should not use a HC.
Does this need to be public?
Does this need to be waited for the network to complete?
Does it need to be waited for the network to complete?
Invincible
Why do we set invincible when exiting stargates?
Why do we set invincible when hero is null?
I wonder if this should just be: java return new ImmutablePair<String, String>(command, Optional.ofNullable(fact));
I wonder if this should just be: java return new ImmutablePair<String, String>(command, Optional.ofNullable(current));
I thought this was supposed to be return the optional?
No need to check here.
You should use Objects.requireNonNull().
No need for this.
Please change to LOG.debug
Please set a variable to LOG.debug
Please change to LOG.debug or trace
In this PR, I don't see any reason in changing the name of this method.
In this case, the current implementation seems to be using the annotate method instead.
In this PR, I don't see any reason in changing the name of the method.
This should be a logger.error()
This should be an else if so that it can be removed.
This should be an AtomicBoolean
if it should be public
final
+ desc
I like the strings being referenced in a couple of places, but I prefer to have them inline as constants.
I like the strings being in a couple of places, but I prefer to have these strings as constants.
I like the strings being in a couple of places, but I prefer to have these strings as constants for the strings.
This check is not needed
This check is not enough. We will have a risk to use the getName() method if it is null.
This check is not enough. We will have a risk to use the getName() method on the safeName.
We can use the new LexoNumericComparator here.
we can use the LexoNumericComparator here.
We can use the new LexoNumericComparator here as well.
Can you use Collections.emptyMap() instead?
Can you use Collections.emptyMap() instead of null?
Can this be in sync?
nit: %d instead of %d
nit: %d?
nit: %d
This should be a list of reasons: - use the.stream().map(s -> new ArrayList<>()) - Arrays.stream(n).collect(Collectors.toList());
This should be a list of reasons: - use the.stream().map(s -> new ArrayList<>()) - Arrays.stream(new ArrayList<>()).collect(Collectors.toList());
This should be a list of reasons: - use the.stream().map(s -> new ArrayList<>()) - Arrays.stream(n).collect(Collectors.toList()); - ditto other builders
lastUsed should be declared final
lastUsed should be declared final.
lastUsed should be declared static?
other.jettyMaxThreads!= null && other.jettyMaxThreads!= null is a better name. I feel that makes this a bit easier to follow and keep the other way around.
other.jettyMaxThreads!= null && other.jettyMaxThreads!= null is a better name. I feel that makes this a bit easier to follow and add the other.
other.jettyMaxThreads!= null && other.jettyMaxThreads!= null is a better name
Should this be a static method? It's not used anywhere.
Should be a static import.
Should this be a static import?
... = null : this.
... = null Directly assign result of Arrays.asList(...).
... = null?
please reuse the constant
please use {}
please use single line for ifs
don't leave the println from the generated body
don't think we want to leave the markup separate from Attributes to Type? What do you think @zlamalp?
see below re: spaces
@eg04lt3r we've talked about this approach before in #123
@dmzaytsev ThreadPoolExecutor can be used instead of this.latency
@eg04lt3r we've talked about this approach before in #123.
Same as above, store this as a field so that its created only once?
Same as above, store this as a field so that its created only once.
Same with this method, if it were protectiond with computeIfAbsent.
Just return getParameters().getImageList().stream().filter(this:: volumeExists).collect(toList());
Just return getParameters().getImageList().stream().filter(Objects::nonNull).collect(toList());
Just return getParameters().getImageList().stream().filter(this:: volumeExists).collect(toList())
Why not using iterator.forEach()?
Why not using iterator.forEach()?
Why is this needed?
It's better to use applicationContext.getBean(beanName). That way we don't forget to remove the beanName argument.
It's better to use applicationContext.getBean(beanName). That way we don't forget to change the reference equality.
It's better to use applicationContext.getBean(beanName). That way we don't forget to change the current directory name before we use the deprecated method.
You should be using enum constants instead of hardcoded numbers.
You should probably use enum constants instead of hardcoded numbers
You should probably use enum constants instead of the hardcoded string
Was this change intentional?
getEditorValue() is used twice.
TAG
i think it'd be a good idea to require the "this." reference.
i think it'd be a good idea to require a "this." constructor to be used in all the constructors.
i think it'd be a good idea to require a "this." constructor to be used in all the places.
Don't use this. for method calls
maybe use this.messageStr("rdbc-channel") here
maybe use this.messageFormat for consistency
o
you mean super.
o?
Please use the same message as in the other constructor.
Please use the same message syntax and throw IllegalArgumentException.
Please use the same message too.
Please add identifying information about the Nuage VSP device to assist with operational debugging.
Please add identifying information about the Nuage VSP device to the error message.
Please add identifying information about the Nuage VSP device to assist with operational debugging
Don't forget to update this
Don't think the external_id is a valid refund.
Don't think the external_id is a valid reference
do we need a @NonNull here?
do we need @NonNull here?
extra @NonNull
please put rickAtPositionShowsString 2 into a constant since it's used 3 times.
please put rickAtPositionShowsString 2 into a constant since it's used in multiple places
please put two lines in a function
that should not be possible, can we assert that it is null or empty
that should be final
final
Nit: releaseLock field should be synchronized.
Nit: releaseLock field should be volatile.
Nit: this should be getAndSet(partitionKeyLock).
This log message does not match with the one below in line 198. Please remove this log message.
This doesn't seem to throw an exception. Why not throw an exception and remove the getStatus()
This doesn't seem to throw an exception. Why not throw an exception and remove the getStatus() signature?
Can we make this a Test case?
Can we make the test case CaseFilterTimeRange filter1 and 16092 as constants?
Is the test necessary? Or it?
I don't think "getDoc" is a good name here. It's not a good idea to use "getDoc".
I don't think "getDoc" is a good name here.
I don't think "getDoc" is a good name here. It's not a good idea to use "getDoc" or something similar
You can use File.separator instead of hard-coding the path here.
You can use File.separator instead of "/"
You can use File.separator instead of hard coding the path.
Don't use a LinkedList, use an initial size.
Don't use LinkedList, use an ArrayList.
Don't use a LinkedList. You can use an ArrayList
value can be null
value can be null, it should be declared final.
value can be static
Should this be done in the base class, right?
Should this be done in the constructor, right?
Should this be done in the constructor, or is it too complicated?
Can you use the try-catch for the resource instead of try/catch?
Can you use the try-catch for the resource instead of a try/catch?
Can you use the try-catch for the resource instead?
Same as above, please use builder.variablesSet(builder, null) instead of the empty one.
Same as above, please use the checkNotNull.
Same thing here about arg checker, please.
Can you provide Jira for this one? i.e. after the change on the class.
Can you provide Jira for this one? i.e. after the change on the class level
Can you provide Jira for this one? i.e. after the change on the class level.
This fails with an ArrayIndexOutOfBoundsException on a zero-element array.
This fails with an ArrayIndexOutOfBoundsException when trying to delete it.
This fails with an ArrayIndexOutOfBoundsException when getNumberedFileName is not found.
nit: s/targetSubpartition/targetSubpartition
nit: s/targetSubpartition/partitionSubpartition
nit: s/targetSubpartition/targetSubpartition/
Can't we use the getBytes() here?
Can we use the getBytes() here?
Can't we use the compiler assert here?
Should we be using a boolean rather than default?
Should we be using a builder? Same in other places in this class.
Should we be using a builder here?
use File.separator instead of "/"
It's better to use File.separator instead of "/"
use File.separator instead of "/"?
nit: I think it's better to use a static import: @Test public void testTotalCount() throws Exception { final CheckpointException errorMessage = new CheckpointException("command: " + state); assertEquals(1, expected, actual); }
nit: I think it's better to use a static import: @Test public void testTotalCount() throws Exception { final CheckpointException errorMessage = new CheckpointException("command throwing " + state); assertEquals(1, expected, actual); }
nit: I think it would be nice to add an assertion that the reason is not empty
PullRequest is not part of the link. This will throw an exception.
PullRequest is not part of the link. This will throw an exception, so you can remove this line.
PullRequest is not part of the link. This will throw an exception. And the link will not work.
You can use a Set here.
You can use a Set<String> here
You can use filter here.
nit: does this need to be synchronized, or can we just use the lock?
nit: does this need to be synchronized?
nit: missing @Override
Please make it!( percentage == null || percentage > 100) < 0
Please make it!( percentage > 100) < 0
Please make it!( percentage == null)
I think Java supports covariant return types, so you can write: java return getConfig().getInt(inParameter, inParameter);
I think Java supports covariant return types, so you can write suggestion return getConfig().getInt(inParameter, inParameter);
I think it should be Integer.valueOf(inParameter)
Will this be really more readable? java env.map( Environment.Variable("CRATE_HEAP_SIE", StandardCharsets.UTF_8.name()));
Will this be really more readable? java env.map( Environment.Variable("CRATE_HEAP_SIE", StandardCharsets.UTF_8));
Will this be easier to read if you create a static method to use Environment.Variable("CRATE_HEAP_SIE", DEFAULT_HEAP_SIE).
Should this equalsIgnoreCase() be changed to equals() as well?
Should this be changed to equals() as well?
Should this be changed to equalsIgnoreCase() as well?
@lmontrieux Was this change?
@lmontrieux Wow... Strange. I think that we should change this and add ex.getMessage() to the log message.
@lmontrieux Was this change? I'm not sure that it makes sense to change the status code here.
Worth including the return type of the boolean in this method?
Worth including the return type of this method?
Worth including the return type of the boolean in this method.
"At least one interpreter should be declared"
The test of the DescriptionFactory is not needed.
typo?
this should be the default implementation.
this change is no longer necessary.
this change is no longer necessary
IMO it's a good idea to split the test into two lines, given that you are using the return value.
IMO it's a good idea to split the test into two lines, given that you are using the return value you are testing.
IMO it's a good idea to split the test into two lines.
Should the left over agencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list
are the left over agencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list
Should the left over agencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list.
this should use the same setToSuspended utility method
this should use the same setToSuspended utility methods
this should use the same exception instance.
Is this an error condition or just timing? When will it happen?
Is this an error condition or just timing?
Is this an error condition?
this is obviously a syntax error.
This is obviously a syntax error.
this is incorrect - the elementList is useless.
I think this should be in the base class, not the onComponent
I think this should be in the finally block, to avoid a potential NPE in the other tests.
I think this should be in the finally block, to avoid a potential NPE in the other places.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId()));
I think you should convert this into a try/catch block and throw an exception if the json is not in the file. Consider moving it to the try/catch so that the caller can throw an exception if it fails.
I think you should convert this into a try/catch and throw the exception if the test fails to ensure the stream is always closed.
I think you should convert this into a try/catch and throw the exception if the test fails to ensure the stream is always closed. That way you will also prevent errors from being logged and handle the exception.
Why not use the getter?
Why not use the getter in the super class?
Why not use toString()?
Can we change it to be the default one?
Can we change it to be consistent with other people?
Can we change it to the default one?
Since here we'll be consistent, would it be better to call loadSavedFilters instead of just saveSavedFilters?
Since here we'll be consistent, would it be better to call loadSavedFilters instead of just loadSavedFilters?
Since here we'll be consistent, would it be better to call loadSavedFilters instead of just saveSavedFilters as before and store in a local variable?
I have problem with this, we need to shutdown even for one second service in a finally block. We can use a try-with-resource pattern here.
I have problem with this, we need to shutdown even for one second service in a finally block. We can use a try-with-resource for close, and the [PowerClient](<LINK_0> (without any exception)
I have problem with this, we need to shutdown even for one second service in a finally block. We can use a try-with-resource for close, and the [PowerClient](<LINK_0>
CsvSchema has a separate field for this map so it's called only once, right?
CsvSchema has a separate field for this map, so it's called only once, right?
CsvSchema has a separate field for this map so it's called only once, but not twice.
There is no need for this.
spaces around ==
spaces
I think you need to rename operator.isBlocked() to operator.
extract operator.isBlocked() to a local variable in catch block.
extract operator.isBlocked()
[minor] Why do you not assert for action in all places?
[minor] You could remove the logger, and directly use the keyword in method signature.
[minor] Just removeActionFromTv.class.getSimpleName?
You can return null if you do not assign it to a variable.
You can use LoadingCount as 0 and LoadingCount.
You can return null if you do not have to deal with it.
>>(<LINK_0>
I'm confused by this. The line above looks like it's constructors... Should we remove them?
I'm confused by this. The line above looks like it's constructors... but it's not used IMO.
This synchronized can be removed.
Move this to the synchronized block above.
Move this to the synchronized block
I would change this to this.script = new Builder(this.driver, script, null); this.inject(script);
I would change this to this.script = new Builder(this.driver, script, null); this.inject(this);
I would change this to this.script = new Builder(this.driver, script, null);
can this be extracted to a constant?
can this be extracted to another method?
space before trailing {
You confused "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file
You confused "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error message" As I see it, it's in the whole test-file
You confused "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file-file
Need to remove codec from here too, right?
Need to remove codec from here too, right? ;-)
Need to remove codec from here too.
Maybe we can use isGroupAdmin(groupId) here since it is true only for group admins.
Maybe we can use isGroupAdmin(groupId) here since it is true when everything is null
Maybe we can use isGroupAdmin(groupId) here since group is not null
I don't think that cast to FlagAffectedCommand is necessary. Edit: Scratch that, I didn't see that the writeable methods are already there.
I don't think that cast to FlagAffectedCommand is necessary. Edit: Scratch that, I didn't see that the write of the field is always done.
I don't think that cast to FlagAffectedCommand is necessary. Edit: Scratch that, I didn't see that the write of the field is pre-allocateed.
This should be a Vertex.getInstance().isContainer()
This should be a Vertex
This should be a Vertex api.
same here, not sure if we need to add the same logic.
Can you not use the same name here?
format is used twice
Since this is async it should not be called in any thread. Can this go into the containerCoordinator?
Since this is async it should not be called in any thread. Can this happen with an exception?
Since this is async it should not be called in any thread. Can this go into the executor service?
This should probably just be syncListenersList
This should be notifyListenersList, not ListenerWrapper
This should be notifyListenersList, not pendingListenersList
code style: This is to not use braces around single line blocks
code style: This is to not use braces around single line blocks, more readable!
code style: This is to use braces around the if statement.
The rest of the code had pretty bad readability. I would prefer use src.slice(srcIdx), length, length);
The rest of the code had pretty bad readability. I would prefer use src.slice(srcIdx), length);
The rest of the code had pretty bad readability. I would prefer use src.slice(srcIdx), length, slice);, and we can use slice.
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified flag, and he selects "yes" on this option?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified field, and he selects "yes" on this option?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified group, and he selects "yes" on this option?
minor: I don't think this does anything. Same with below.
minor: I don't think this does anything. Same for FakeException.
minor: I don't think this does anything. Same with FakeState. Maybe we can leave some docs.
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{serverVersion}:1.0.0-SNAPSHOT.
It should be unique across maven repo. Please change it to org.openmrs-sdk-server-{serverVersion}:1.0.0-SNAPSHOT.
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{serverVersion}-1.0.0-SNAPSHOT.
I'm not sure why we can do this: java if (input == null || input.getItem() == null) { return null; } Not sure why we want to check for null here, just in case.
I'm not sure why we can do this: java if (input == null || input.getItem() == null) { return null; } Not sure why we want to check for null here, but in general I would suggest moving the null check into a separate method to improve readability.
I'm not sure why we can do this: java if (input == null || input.getItem() == null) { return null; } Not sure why we want to check for null here, since I don't think it's a valid use case.
Change this to LogicalServerStateMBeanImpl.class.
LogicalServerStateMBeanImpl.class.getName() to return a list.
use the interface here?
Can we add the max(message, _callToActions) to the RestrictedFunctionalityCallToAction...
Can we add the max(message, _callToActions) to the _callToActions field?
Can we add the max(message, _callToActions); here?
Please bring the braces back.
Please bring a braces back.
Please bring a copy of this.
There is no need to mock shell anymore.
There is no need to mock shell
There is no need for this sleep.
This one seems unused, is it?
This one will always use the default timestamp service name (though I'm fine with it either).
This one seems unused, can it be deleted?
Use TreeMap here instead of Collections.singleton
Use TreeMap here instead of a TreeMap.
Use TreeMap here instead of Collections.EMPTY
Shall we rename this to "completed" or "placeholder"?
Shall we rename this to "completed" since the error is an Synapse handler?
Shall we rename this to "completed" since the error is an output stream?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
I think you could just use allOf(...). It would be more consistent.
I think you can just use allOf(...). It will allow the collection to return true as the value of getItem(EnumSet.class) and not addField.class.
I think you can just use allOf(...). It will allow the collection to return true as the value of getItem(EnumSet.class)
same question as above
same, remove
remove
this looks like it should have been explicitly set on the class class (when there is a reference to the formController)
this looks like it should have been explicitly set on the class class (when there is a reference to the reference). I don't think it's useful here.
this looks like it should have been equals(), not CollectController.getInstance()
looks like this can not use any method
looks like this can be taken out of the loop
looks like this can be taken out of method
Shall we use.properties instead of hardcoding the hardcoded value here?
.. should be "-web-0.2" and "web-type"
.. is "web-0.2" and "web-type" used?
eg. "Basic " + responseTokenValid!= null &&! chain.doFilter(request, response);" can be moved to the end of the method, after all.
eg. "BasicHeaderApiTokenAuthenticator." can be moved back to the secondary index.
eg. "Basic " + responseTokenValid!= null &&! chain.doFilter(request, response);
Can we list the languageCode from the definition of the languageCode to be more specific? Also, the languageCode could be empty, so that the languageCode could be found to be a list of languageCode.
Can we list the languageCode from the definition of the languageCode to be more specific? Also, the languageCode could be empty, so the languageCode could be found to be a list of languageCode.
Can we list the languageCode from the definition of the languageCode to be more specific? Also, the languageCode could be empty, so that the languageCode could be found by the time the method is called.
This test doesn't actually test anything.
This is really a tad mock so I think we should just call close in a finally block
This tear down isn't really necessary.
It would be good to have tests util methods for this.
It would be good to have tests util methods for this. What do you think?
It's good practice to change this URL to a URL (see URL code)
Should we use d.getDisplayName()? (applies to all blocks below)
Should we use d.getDisplayName()? (applies to other divs in this project)
Should it be Registered?
This is the replacement for [this](<LINK_0> We might want to consider using [this](<LINK_1> or [this](<LINK_2>
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
This is the replacement for [this](<LINK_0> We might want to consider using [this](<LINK_1> and get rid of the newline altogether.
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() inline where it needs it.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
This change is now unnecessary. reject() will set the ctl.getRefName() to null and then remove this variable.
You don't need this if-statement, right?
You can drop the.size() == 0 check, as that's the case in the condition.
You can drop the.size() == 0 check, as that's the case in the beginning of the test
You should probably keep the following line as it was: if (forLog) { view.showOrHideNodeActions(false); }
You should probably keep the following line as it is: if (forLog) { view.showOrHideNodeActions(false); }
You should probably keep the following line as: if (forLog) { view.showOrHideNodeActions(false); }
I agree with this approach, but first element.setSize(Options.getInstance().playplaySoundFileName()); is called on a Size, would make sense.
I agree with this approach, but first element.setSize(Options.getInstance().playplaySoundFileName()); is called on a Size, would make sense for it.
I agree with this approach, but first element.setSize(Options.getInstance().playplaySoundFileName()); is called on a different value, would make sense.
unecessary new line.
I think you can use the writing method reference here.
you can use the writing method reference here.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
@fanifieiev the same above.
@ekondrashev Too much indentation for lines 61-64, move those back four spaces.
I think the idea of having values in mutable is that if there's an issue that can be behind concurrent writes. If there are concurrent calls to values.remove, then I think the following should be unnecessary. java final List<Integer> values = state.values(); final List<Integer> values = new ArrayList<>(); values.remove(key); return values;
I think the idea of having values in mutable is that if there's an issue that can be behind concurrent writes. If there are concurrent calls to values.remove, then I think the following should be unnecessary. java final List<Integer> values = state.values(); final List<Integer> values = new ArrayList<>(); values.remove(key); return values.remove(value);
I think the idea of having values in mutable is that if there's an issue that can be behind concurrent writes. If there are concurrent calls to values.remove, then I think the following should be unnecessary. java final List<Integer> values = state.values(); final List<Integer> values = new ArrayList<>(); values.remove(key); return values; }
You need to assert that the result is empty?
You need to assert the exact Exception in the map?
You need to assert that the result is empty
nit: could we make RocksDbPersistentStorageConfig.builder() to be consistent with the other one?
nit: could we make RocksDbPersistentStorageConfig.builder() to be a static field?
nit: could we assert the full path here?
Is this used anywhere?
Is this used elsewhere?
Is this used here?
Can we have a test for the actual meta type?
Can we have a test for the actual meta type here?
Can we use the name of the enclosing future instead of a JSON?
Overdid: if (read!= null) return getChannelNameFromMessage(JsonNode.protected, 0);
Overdid: if (read!= null) return getChannelNameFromMessage(JsonNode.protected);
Space after )
CopyableElementView to a variable?
You need a null check here? Shouldn't the pool id be part of the pool?
You need a null check here? Shouldn't the pool id be added as part of the pool?
Can we do something similar to what is done for this: java private static final SamzaException SamzaException.of(KafkaCheckpointLogKey key) throws IOException {
Can we do something similar to what is done for this: java private static final SamzaException FACTORY_FIELD = createKafkaCheckpointLogKey(KafkaCheckpointLogKey key, TASK_NAME_FIELD, key.getType()).before(Field.getTaskName()).group(...).build();
Can we do something similar to what is done for the other properties here? Can we make this a private method.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return true;
This will instead need to check the destination instead of checking for equality. See removeLinkAddress for an example.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return false;
Pointless return
missing in the finally, could be omitted
Pointless expression
OOC, there is a method for doing the null check and exception handling is not necessary. It would be easy to refactor the code, something like: java if (first instanceof Include) { if (eventually) { return true; } if (objClass.equals(objClass)) { return null; } return Optional.empty(); }
OOC, there is a method for doing the null check and exception handling is not necessary. It would be easy to refactor the code, something like: java if (first instanceof Include) { if (first instanceof Include) { return true; } if ((declaringClass == null) || (declaringClass == null)) { return null; } return Optional.empty();
OOC, there is a method for doing the null check and exception handling is not necessary. It would be easy to refactor the code, something like: java if (first instanceof Include) { if (eventually) { return true; } if (objClass.equals(objClass)) { return false; } return Optional.empty(); }
I'd rather use assertThrows here. Also, it's much better to use assertThrows here.
I'd rather use assertThrows here. Also, it's much better to have a custom exception message that the exception gets logged here.
I'd rather use assertThrows here. Also, it's much better to use assertThrows() because we are already making sure the exception is an instance method.
You just want to use LOGGER.debug("PetsManager", "capture");
You just want to decrease this out of order
You just want to decrease this by uberfire?
Minor nitpick: curly brackets are not needed
Redundant-parens around the type.
Minor nitpick: curly brackets around ()
I don't think this is good. If isWhitespace is null then you'll have to call length() before the loop and avoid the null check.
I don't think this is good. If isWhitespace is null then you'll have to call isEmpty before you call it.
I suggest you static import isWhitespace for readability
I'm not sure exactly what is going on here.
I'm not sure exactly what is going on here, as far as I can see.
I'm not sure exactly what is going on here. But as I'm not really understand how the project uses this, you are using a supplier to get the URI -> first host, and not ProxyConfiguration.Type()
Can we please use Objects.requireNonNull(step) here?
Can we please use Objects.requireNonNull(task, "output"); instead?
Why not this?
I think there is a reason to keep the extractor null; i.e. return ValueExtractors.add( extractor);
I think there is a reason to keep the extractor null; i.e. return ValueExtractors.add( extractor,  extractor);
I think there is a reason to keep the extractor null; i.e. return  extractor!= null? extractor.add( extractor) : )
Add a space after the for
originalKey could be replaced with originalKey.keySet().
It should be originalKey!= null
Seems like there is a doReturn() that you can do here..
Seems like there is a doReturn() that you can do here....
Seems like there is a doReturn() missing here..
empty rubbingData.
firstNonNull() for this
firstNonNull() for this?
This should also be: PowerMockito.spy(KubernetesClient.class);
This should probably be: PowerMockito.spy(KubernetesClient.class);
This should be: PowerMockito.spy(KubernetesClient.class);
should be RateLimit
should be rate
Should this be RateLimit instead?
use more assertion
use AssertJ
use more descriptive error
log a warning or something instead of returning null
log a warning or throw an exception
formatting
NIT: prefer having this one at the end of the line.
Nit: prefer having this at the end of the line
Nit: prefer having this at the end of the line, just so you don't have to do it in the same block
can be declared as Modifier.isPublic
Consider wrapping the { on { } conditional.
Consider wrapping the { on { }!
return DPIUtil.map(piImageStorage::getImageSelector);
return DPIUtil.map(zoom::getImageSelector);
return DPIUtil.mapoomToImageSelector(zoom)
should this be null?
Return an unmodifiable list?
Can this be null?
Could simplify to: if ( bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length < 1 && bases.length <= 1
Could simplify to: if ( bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length < 1 && bases.length <= 1 && bases.length <= 1
Could simplify to: if ( bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length <= 1 && bases.length <= 1
Given that we have a findFirst() method on the Optional object, we can make it a bit simpler: java return delegates.stream().map(Optional::of).filter(Optional::isPresent).map(Optional::get).filter(Optional::isPresent).map(Optional::get).filter(Optional::isPresent).map(Optional::get).filter(Optional::isPresent).findFirst();
Given that we have a findFirst() method, we can make it a bit more functional with a method reference.
Given that we have a findFirst() method on the Optional object, we can make it a anyMatch instead of a lambda.
Shouldn't this null be added to the handler?
Shouldn't this be executed before the callback is completed?
Shouldn't this null be added to the handler before the call?
Rename the variable to DashboardView or something. It is more clear that the style is'refresh' or 'preferred' and make it more clear what it is.
Rename the variable to DashboardView or something. It is more clear that the style is'refresh' or 'traversal'
Rename the variable to DashboardView or something. It is more clear that the style is'refresh' or 'traversal' to make it more clear that these asserts the same thing. The method called createFreeStyleJob is too verbose and just assert that the text is there instead of the assert keyword.
Can we define a common function for this? That way we don't need to worry about what it means.
Can we define a common function for this? That way we don't need to worry about what it means?
Can we define a common function for this? That way we don't need to define a common function.
I think we can use primitive type here, right?
I would use primitive type here, same as in the other methods.
I think we can use primitive type here, as well.
What about to use regex and use replaceAll?\\ does not end with regex.
What about adding this to Utils class and use it all the time?
What about to use regex and use replaceAll?
A question: Does this need to be public?
nit: I would throw a RuntimeException here
nit: I would throw a RuntimeException here.
formatting
space after =
space after if
Check for null.
Check for null
Check for null for consistency.
Is the type of the enumToBinary() really needed here?
Is there a reason to take object type here?
Is it worth creating an Builder from the ordinal?
remove.
remove
remove this debugging output
Looks better to extract this selector to a class attribute instead of hard coding the name.
Looks better to extract this selector to a method
Looks better to use single line for the empty row.
This should be a check instead of a!= null check.
This should be a check instead, as it is true in the adapter.
This should be a check instead of a INSTALL_SOURCE_APPLY
Maybe we could use a proper message here.
"firmwareImageFactoryException" is not needed.
"firmwareImageFactoryException" is not needed
Renaming java method to java.util.MultipleListeners and java.lang.Class#containsClass(java.lang.Class<JdbcEventListener>, eventListeners)
Renaming java method to java.util.MultipleListeners and java.lang.Class given the purpose of the test is the same as java.lang.ClassAssert.
Renaming java method to java.util.MultipleListeners and java.lang.Class given the purpose of the test
I think we can flip the panels and abstract into separate method to avoid doing this for every call.
I think we can flip the panels and abstract into separate method to avoid doing this for each event.
I think we can flip the panels and abstract into separate method to avoid doing this for every event.
if (itemClass == null || itemClass.isAssignableFrom(itemClass)) { return true; } //NON-NLS-1
if (itemClass == null ||itemClass.isAssignableFrom(itemClass)) { return true; } //NON-NLS-1
if (itemClass == null || itemClass.isAssignableFrom(itemClass)) { return true; }
PUT and POST are not necessary here
PUT and POST are not needed here
Constant
use: import static org.hamcrest.CoreMatchers.instanceOf;... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
use static import for assertTrue/assertFalse please.
use static import for assertTrue/assertFalse please. <LINK_0>
Maybe should check the expected value too?
Can be removed.
Maybe should check the case where the rule is not null
There's no locking on this? Also, isn't this the functionality you wanted in the Facade layer?
There's no need to check for bookedStatuses. I think a cast might do something different.
There's no locking on this? Also, isn't this the functionality you wanted in the Booking class?
I think that getClientInfo() should return a non-null value, otherwise it would be unexpected to return null.
I think that getClientInfo() should return a non-null value.
I think that getClientInfo() should return a non-null value, otherwise the user knows it was already created.
prefer String.format() for readability
prefer String.format() for consistency
use strings equals() instead of string concatenation
log.warn("Leaked thread group", e);
Log stack trace?
- should be log.warn
Capitalize Thrift (or remove the word)
Capitalize Thrift (or remove the word)?
Capitalised Thrift (or remove the word)
for branching and this I'm not sure how the new logic is intended to be.
final?
final
Unnecessary this.
Unnecessary cast
Unnecessary cast here?
why public? Are we planning to use it outside of this class?
why public? Are we planning to use it outside of the class?
why public? Are we planning to use it outside of this class? There is code duplication.
If the value doesn't have a NONE, then we should have a NO_SYNC flag.
If the value is null, then we should have a NONE check so that it can be null.
If the value doesn't have a NONE, then it should have a default of 0
- The position is the same as the method above. - This is not correct. - The position is the number of callback methods above. I don't think we should add a - prefix to the method above.
- The position is the same as the method above. - This is not correct. - The position is the number of callback methods above.
Again, I like the idea of breaking things.
why log.info() instead of i?
why log.info() instead of log.info()?
why log.info() instead of log.warn?
Make it final
Make it final.
Make it final please
List#isEmpty()
List#isEmpty() which is a bit misleading here.
List#isEmpty() which is a little misleading here.
Should this method be added to the EMFUtil?
this.
this
I think it would be better to use dialog.dismiss() instead of dialog.get().
I think it would be better to use dialog.dismiss() instead of dialog.
I think it would be better to use dialog.dismiss() instead of to avoid duplicate code.
Can't the local variable be removed?
Can't you use the same formatting for the dialog?
Can't you use the same formatting for the dialog name?
Can we use WorkItemManager here? If not, there is no need to catch exceptions and you can catch specific exceptions.
There should be a catch block inside the catch block. If you can't throw specific exceptions, all the implementation and the stack trace should be printed
Can we use WorkItemManager here? If not, there is no need to catch exceptions and you don't throw specific exceptions.
ResistanceCalculator -> ResistanceCalculator
ResistanceCalculator can be null
ResistanceCalculator can be created before ResistanceCalculator
Use same as above, with abstract annotations to the new ones, e.g. public class VarintType extends Integer { public int i; }
Use same as above, with abstract annotations to the new one, e.g. public class Reject?
Use same as above, switch between cases.
Collections.emptyList()
Collections.singleton(other.pattern())
Collections.singleton(other.pattern)
this doesn't look correct
part of this PR
it sounds like a good candidate to be returned
In such PR it has been required.
In such PR it has been backported before 3.
In such PR it has been lost on this.
I'm not sure, but this method should be always called before the state table has been set.
please always use curly braces, even though this is a One-liner
please add curly braces
I would prefer to rename element to element.isValid().
I would prefer to rename element to element.
I'd prefer to rename element to element.
PInspectionUtil.getExpressionList().getExpressionList().size(). Use GoInspectionUtil.getExpressionResult().
PInspectionUtil.getExpressionList().getExpressionList().size(). Use GoInspectionUtil.getExpressionList().
Pease extract expressions into GoInspectionUtil.getExpressionList().
I have a feeling that this is easier to read. synchronized(this) { if (this.nanoTime!= this) { TIME_ENTER_UPDATER = this.public; } else { TIME_ENTER_UPDATER = System.nanoTime(); } assertTrue(this.get(this.get(this));...
I have a feeling that this is easier to read. synchronized(this) { if (this.nanoTime!= this) { TIME_ENTER_UPDATER = this.public; } else { TIME_ENTER_UPDATER = System.nanoTime(); } }
I have a feeling that this is easier to read. synchronized(this) { if (this.nanoTime!= this) { TIME_ENTER_UPDATER = this.public; } else { TIME_ENTER_UPDATER = System.nanoTime(); } assertTrue(this.getValue(this.get(this));...
I don't know the reason to use getPolicy here, but if it is to avoid code duplication I would replace this method with return getPolicy(kind); or something like that.
I don't know the reason to use getPolicy here, but if it is to avoid code duplication I would replace this method with return getPolicy(kind, kind); or even return policy == null.
I don't know the reason to use getPolicy here, but if it is to avoid code duplication I would replace this method with return getPolicy(kind, kind); or even return policy!= null?
Please consider to verify the flow here. It's better to verify the error message as well.
Please consider to verify the flow that can be verified.
Please consider to verify the flow here.
note that the best practice for test is now to not use public.
note that the value of testSomeOtherClass isn't really used so we can be sure that the test is tested.
note that the value of testSomeOtherClass isn't really tested.
Lets use kernalContext.kernalContext()
Lets use kernalContext.kernal()
Lets call safeShouldrun
Should we close this before the finally?
Should we close this before the test?
Is this the expected behavior?
Can be replaced with this.canvas = new SpongeEmptyCanvas.get(this.canvas()).get();
Can be replaced with this.canvas = new SpongeEmptyCanvas().get(this.canvas()).get();
Can be replaced with this.canvas = new SpongeEmptyCanvas.get(this.canvas)).get();
This is a lot of code. Why are we using getKafkaTopicUploadAtTime(topicFilter) here?
This is also nitpicking: the if isRequiredToUploadAtTime(topicFilter) check is unnecessary.
This is a lot of code. Why are we using getKafkaTopicUploadAtTime instead of getKafkaTopicUploadAtTime?
this line is redundant.
this.packName = "/"
indentation does not seem correct.
This seems to be duplicated: public Stream<RecoveryDecorator> getRecoveryDecorator(Class<?> parentRecoveryDecorator) { return RecoveryDecorator.supports(returnType).orElseThrow(() -> new RecoveryDecorator(returnType, RecoveryDecorator.class)); }
This seems to be duplicated: public Stream<RecoveryDecorator> getRecoveryDecorator(Class<?> parentRecoveryDecorator) { return RecoveryDecorator.get(defaultRecoveryDecorator.get()).orElseThrow(() -> new RecoveryDecorator(returnType, RecoveryDecorator.class)); }
This seems to be duplicated: public Stream<RecoveryDecorator> getRecoveryDecorator(Class<?> parentRecoveryDecorator) { return RecoveryDecorator.get(defaultRecoveryDecorator.get()).orElseThrow(() -> new RecoveryDecorator(returnType, RecoveryDecorator.class()))); }
You can use JavaSymbol.flags() for this.
You could use JavaSymbol.flags()?
You can use JavaSymbol.flags() for this case.
Shall we use the SimpleCounter as the type?
Unnecessary log level?
Shall we use the SimpleCounterIdVisitor here as well?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can we not verify that the boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but should we not ascertain the values that should be being set?
I'd like to see an example of the: inlineGetInstanceField class.inlineGetInstanceField() to keep the style consistent. The first two are: 43 = (a == 42)? true : 42
I'd like to see an example of the: inlineGetInstanceField class.inlineGetInstanceField() to keep the style consistent. The first two are: 43 = (a == 42)? null : 42
I'd like to see an example of the 43 optimizer in the test.
I am wondering if it makes sense to use putIfAbsent elsewhere in the code path, instead of putIfAbsent where it is called.
I am wondering if it makes sense to use putIfAbsent elsewhere in the code path, instead of containsKey.
I am wondering if it makes sense to use putIfAbsent elsewhere in the code path, instead of putIfAbsent where it is used, but since we are in the UI, could we change the logic in _then_ be the same?
There is no need to TextUtils here, Locale.ROOT is the same for String.
There is no need to use Locale.ROOT for these
There is no need to use Locale.getDefault() since Locale.ROOT is actually a local variable.
return String.valueOf(id);
same here, common to throw exception
same here, common method
Set atts == null || atts.toString(value)
Set atts == null || atts.toString()
Set toString()
Please implement toString() to provide debugging state information for debugging purposes.
Please implement equals() to provide debugging state information for debugging purposes.
This equals implementation should include attributes from the Answer super class.
if (defaultSecurity == null) { return maybeServiceConfig.get().or(defaultSecurity); }?
if (defaultSecurity == null) { return maybeServiceConfig.get().or(defaultSecurity); } return defaultSecurityConfig;
if(defaultSecurity) { return Optional.empty(); }
Create your own session to make the property to be true.
I'd just use a lambda here: (rowExpression, level, session) -> rowExpression
I'd just use a Map<String,Expression> for an argument.
I don't think this will work for both, and the conditional above will need braces otherwise this is considered outside of the block.
I don't think this will work for both, and the conditional above will need braces
I don't think the permission check is necessary, and the attribute may need to be corrected in this case too.
suggestion EMPTY_VALUE);
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
suggestion assertThatSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
Works anyways but a bit weird to have it set in the constructor. I would just have a single constructor that takes a list of all the fields as an argument.
Works anyways but a bit weird to have it set in the constructor. I would just have a single if-else builder.append(input)
Works anyways but a bit weird to have it set in the constructor. I would just have a single if statement
nit: Add a space after the cast.
nit: Add a space after the cast operator
nit: Add a space after the cast -
Can this be simplified to return a boolean?
isNewUser() sufficient?
Can this be simplified to return a Boolean?
I think it is better to use "command.getName()" instead of "block".
I think it would be better to use "command.getName().equals("command.getName") here instead of the 'else if'
I think it would be better to use "command.getName().equals("command.getName") here instead of the 'else if'.
we should log a warning here so that users who have wrong permissions on /.gitconfig by mistake have a chance to detect the problem
we should log a warning here so that users who have wrong permissions on /
we should log a warning here so that users who have wrong configs.
Consider Long.valueOf
Consider adding throws RepeatLastCallException to this method.
Consider using Long.valueOf
I am not sure which permission it should be getRequiredPermission, but there is no reason to return Jenkins.ADMINISTER
I am not sure which permission it should be getRequiredPermission, but there is no reason for getRequiredPermission, so you can use Jenkins.getInstance().
I am not sure which permission it should be getRequiredPermission, but there is no reason to return Jenkins.getInstance()
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Replace this lambda with a method reference. [![rule](<LINK_1>](<LINK_0>
I think static
here you should reset the finish parameter to make sure that the topic's actually started
here, you should reset the finish parameter to make sure that the topic's actually started
here you should put "categoryInput" as a parameter and make it a constant
Unless there's a reason for it, I think we should have a final variable with the annotation.
Unless there's a reason for it, we could have a custom one, with the final keyword this way, we could make it final
Unless there's a reason for it, we could have a custom one, with the final keyword this now
This will be more efficient as we are creating a view instance for every row.
This will be more efficient.
This will be more efficient as we are creating a view with every iteration.
getParentNames() can return null
parents is always non-null here
parents is always non-null here.
Reverse the order of the constants.
Whitespace
Won't this crash when the Id is null?
Please use UncheckedRuntimeException here.
Please use UncheckedRuntimeException here
Please use UncheckedIOException or RuntimeException
Can you make this error message more meaningful?
Can this be moved to PostgreSQL's system property?
Can you make this error message more specific?
Which branch of the return and the case in which the user doesn't have the value?
Which branch of the return and the case in which the value is 'true'? Is this good?
Which one? Try to use the new one?
Using the boolean as an argument would make the assertion of checkForRemove_in_Tracker.
Using the boolean as an argument would make the assertion of checkForRemove_Deleted.
Using checkForRemove_Deleted() here is unnecessary as it has already been called in onChange().
Don't we need this change?
Don't we need a change here?
Is this used anywhere?
Using TskData.FileKnown() here is not a proper name.
Using TskData.FileKnown() here is unnecessary, as you already got the TagName from TagsManager.java
Using TskData.FileKnown() here is unnecessary, as you already got the TagName in the TskDataManager.
Looks like this will fail for null columns. What's the purpose of this change?
Oh, this shouldn't be private. What's the use case for calling it twice?
Oh, this shouldn't be private. What's the use case for calling it?
For consistency, this should come from the Builder
For consistency, this should come from the setActionMessageParameters method
For consistency, this should come from the BeanClientConfig
Please remove these empty lines.
Please remove whitespace.
Please remove whitespace around brackets.
It'd be nice to have a constant for this
It'd be nice to have a explicit constructor call that takes a ReadOnlyTableName object and a constructor.
It'd be nice to have a constructor called getSQLState(String) and then call this method.
Use StringUtils.isNotEmpty instead
Use parameterized logging instead of string concatenation
Use parameterized log
Arrays.stream(elementss).clear())
Arrays.stream(elementss).clear()?
Streams here as well.
I think you can use a lambda for the if-else operator.
I think you can use a lambda for the if/else operator.
I think you can use a lambda for the if-else operator here: } else { // handle return null }
Please change to Math.min(..., bMin, bMax, bMax, (Min, MaxMaxMaxMaxMax))
Please change to Math.min(..., bMin, bMax, bMax, (Min, MaxMaxMaxMax))
Please change to Math.min(..., bMin, bMax, bMax, bMax, (Min, MaxMaxMax))
Is this really necessary?
Is this really the "MetaDataService" configurable?
Is this really the same as for the service?
I'm not sure why this constructor does the right thing since it's used elsewhere
I'm not sure why this constructor does the right thing since it's called from several places.
I'm not sure why this constructor does the right thing anymore?
should probably log the error, so we can ignore it.
should probably log the error, so the user knows there is an error.
should it be logger.error()?
I don't think we should have a LOG here.
I don't think we should have a different name for this.
I don't think this is intended.
Can you use blocks here?
you may want to use "this" for variable
you may want to use blocks here
Are we sure about the 100 here? I mean, v = v < 256?
Are we sure about the 100 here? I mean, Are you thought about it?
Please add curly braces here.
declare throws please
declare throws Please
it also throws IOException
I mean "public" is used in this class.
I mean an UnsupportedOperationException is a better option. I mean something like this is actually deal with with NotImplementedException.
I mean an UnsupportedOperationException is a better choice.
Maybe make this a one-liner if ( exhausted.of(currentScore)) { throw new NoSuchElementException( currentScore.get(), currentScore.of("The iterator is exhausted")); } else { return new NoSuchElementException(); }
Maybe make this a one-liner if ( exhausted.of(currentScore)) { return new NoSuchElementException(); } else { return new NoSuchElementException(); }
Maybe put this in a new method in  exhausted...
tried to add warn maybe? and not sure if we want the exception. maybe just the message?
Very often this is TimedOutException or various Thrift-based things, though I don't know if this one is left here.
tried to add warn maybe? and not sure if this is good enough...
same here, throws IndexNotFiltersException
same here, throws IndexNotLoadedException
same here, throws used anywhere
change the method name to CPCount
CPCount is also used in getBase().
Missing space after,
Is there any reason to use the getter instead of the parameters object?
Is there any reason to use the getter rather than the setter?
Are we sure that this is not the right class name?
should we log the whole exception here?
should we add Null checks here?
I should expect this to return null as well.
Please add the following before the if-block.
Please add the following before the NotifierToStringBuilder
Please add the following before the NotifierToStringBuilder as well: java eachTestNotifier = new EachTestNotifier(statement, Notifier);
return activeSegment.get(length);
return activeSegment.get();
I don't see the need for length variable here.
What does this line mean?
What does the above line mean?
What does this line mean to throw an exception?
nit: you could use Objects.equals() to reduce the amount of null checks.
nit: you could use Objects.equals() here
nit: you could use Objects.equals() here to avoid the null check since it's null checking
@ivanarrizabalaga why is this catch needed?
@ivanarrizabalaga to print the stack trace is fine in general for this test, however I think it would be nice to have a debug log if you don't want to debug.
@ivanarrizabalaga to print the stack trace is fine in general for this test, however I think it would be nice to have a debug log if we don't want to debug.
can we use constant for "APPLICATION_JSON"
Could we use constant for the 200_TYPE name here?
can we use constant for "APPLICATION_JSON" and use here
floorValue?
floorValue :-)
floorValue is redundant.
The result of tester.getApplicationContext() is used for other tests, so it's easier to read.
The result of tester.getApplicationContext() is used for other tests
The result of tester.getApplicationContext() is used for both test cases.
add some message here to explain why it failed.
add { and }.
add { }}
log.info("Creating NamespaceListener {}", token);
Since we're using this multiple times, suggest to make a local variable.
log.info("Creating NamespaceListener {}", e);
Nice, but AFAIK MediaInfo is not able to parse it...
getCodecA()!= null && getCodecA().startsWith("dts") could be replaced with.contains("dts")
getCodecA()!= null && getCodecA().startsWith("dts") could also be replaced with.contains("dts")
can be inlined
can fail the runtime exception
can it be inlined
I'm not sure we should have to keep this method simple. I would think that if you use a wrapper method on the connect() method then only you should expose that to the channel.
I'm not sure we should have to keep this method simple. I would think that if you use a wrapper method on the connect() method then only you should expose that to the websocket and should not be initialized explicitly. WDYT?
I'm not sure we should have to keep this method simple. I would think that if you use a wrapper method on the connect() method then you should expose that to the websocket and should not be exposed to the user. So I'd use a getter instead of the Connection.
Can this be null?
Can you perform this conversion in a separate function?
Can you perform this conversion in a separate operation?
I like this, but I would prefer to have a test that does not assert on errors too
I like this, but I would prefer to have a test that does not assert on errors here
I like this, but I would prefer to have a test that does not assert on errors
I think this should reference OutputFileData,, not OutputFileData.
I think this should reference OutputFileData.getName() rather than OutputFileData.DEFAULT
I think this should reference OutputFileData, right?
This is a URL thing. I'd probably use a constant for the URL here to make it clear what it actually does.
This is a URL thing. I'd probably use a constant for the URL.
This is a URL thing. I'd probably use a constant for the URL here for the URL.
Why we need the else? Could we just return the annotation?
Why we need the else?
Why we need the else? Could we just wrap the exception?
remove this
remove this, no need to be this.
remove this line
This is a noop so an updateScores method will never be called.
Can a warn be enough?
This is a noop so no set.
@yingsu00 Can this method be implemented as assert?
@yingsu00 Can this method be implemented as assertArrayEquals here?
@yingsu00 Can this method be removed?
If you accept an Optional<Path> you could use a method reference, which would simplify this code a bit: return Optional.of(project).map(path -> "sources-jar-jar", project.getBspPath()).map(path -> Paths.get(path.getBspPath()).map(path -> Paths.get(path)).collect(Collectors.toList());
If you accept an Optional<Path> you can use.map(path -> path.getBspPath().toString()) which does the same thing.
If you accept an Optional<Path> you could use a method reference, which would simplify this code a bit: return Optional.of(project).map(path -> Paths.get(path.getBspPath().toString()));
I don't see this being tested. The "return false" variable is sufficient.
I don't see this being tested. The "tracktrace" string is set.
I don't see this being tested. The " track" variable is set on the first line.
Could we simplify this logic as: if (string == null ||!string.length() > maxMessageLength) { return string; } int maxMessageLength = string.substring(0, maxMessageLength);
Could we simplify this logic as: if (string == null ||!string.length() > maxMessageLength) { return string; } else { return string; }
Could we simplify this logic as: if (string == null) { return ""; } else { return string.substring(0, maxMessageLength); }
I think it would be better to do this: return valueOf(name.toUpperCase()); This way it's going to fall through to the next method.
I think it would be better to do this: return valueOf(name.toUpperCase()); This way it's going to fall through to the next method call.
I think it would be better to do this: return valueOf(name.toUpperCase()); This way it's going to fall through to the next invocation of the ValueType constructor.
Is it possible to add a new Monitor method that can be used here?
Is there a reason why you can't use the new constructor?
Why did you change this?
I think it'd be better to make a try-with-resources so that we can close it in the finally clause.
I believe that's a try-with-resources?
make a constant
AddressUtil.read
Address this
Address this.
Why is this check necessary?
Please check what happens when both registrations and if not null, why not use ConcurrentHashMap
Please check what happens when doing the add() method and remove()
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task));
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task)).until(() -> j.jenkins.getQueue().isBlockedByShutdown(task));
suggestion.until(() ->!isBlockedByShutdown(task));
Can you use || instead of duplicating the size logic?
Can you keep the original instruction, [ ](<LINK_0>
Can you keep the original instruction?
Assert.fail() the job doesn't throw a exception.
Assert.notNull() as well
Assert.fail() line
Can you move this to the model of the variable?
Can you move this to the model of the object that throws if there is an exception?
Can you move this to the model?
we can not change integer value of tokens. It will seriously damage compatibility. Please explain this change.
I'm not sure about this change. It will seriously damage compatibility. Please explain this change.
we can not change integer value of tokens. It will seriously damage compatibility. Did you explain this?
I don't think we want to include the "." in the message here, as the message says "The player does not been requested to the player."
I don't think we want to include the "." in the message here, as the message says "The player does not been requested to the player"
I don't think we want to include the ".
Can we move this to a constant?
Can you please put this to a constant?
Can you please move this to a constant?
I think this can be done only if key.remove(key) == 0.
I am not quite following the relation between updating a storable will contain the key.
I think this can be done within the cache, the result for each event being unique key.
move this to a method reference in the entity class
move this to a constant
move this to a constant.
> "Value to be less than or equal to the allowed value."
> "Value to be greater than **fBits**."
> "Value to be less than or equal to the allowed value"
Would it be nicer to use the version check to see if the config property already exists?
Can we use the version check to see if the config already exists?
Would it be nicer to use the version check to see if the config already exists?
The this.successfullyParsed.set(GeoLocationParseResult.items); is not needed.
Where is the this.items.addAll(toAdd) method called?
Where do you use this.successfullyParsed.set(successfullyParsed.items);?
Could you define a constant for the TravelTimeSurfaceTask?
Could you define a constant for this?
Could you define a constant for "destinations"?
getInstance is called two times, can you put this in a method?
getInstance is called twice. Can you put this at the end of the method?
getInstance is called twice. Can you put this at the end of the line?
The same Arrays.stream() can be applied here as well.
The same Arrays#stream() can be applied here as well.
The same Arrays.stream() can be applied in collectQueues().
This should be the event.getName() result in a finally block to make sure that rating is not null here.
This should be the event.getName() result in a finally block here.
This should be a field so that it can be easily parsed.
Why not ctx.executor() == currentExecutor?
Why not ctx.executor() == currentExecutor && ctx.executor() == currentExecutor?
Why not ctx.executor() == currentExecutor && ctx.executionMask);?
I think we need to change this as well.
I think re-uses this message to mute the failed messages.
I think re-uses this message in a loop to start().
I think the logic is reversed with the name now and it should be!useHyphens here.
I think we shouldn't use the name of the uuid as it should be!useHyphens here.
I think we shouldn't use the name of the uuid as it should be optional and on the name can be unexpected.
This is only valid for CPPBasics the code. It looks like it will create a new class (i.e. line 94), but still can't we just use isConstRightOfMisalignedConst() and be consistent.
This is only valid for CPPBasics the code. It looks like it will create a new class (i.e. as a package-private class) without an extra access modifier.
This is only valid for CPPBasics the code. It looks like it will create a new class (i.e. line 94), but still can't we just use isConstRight().
Cosmetic: It needs to be changed by the new name before the list.
Cosmetic: It needs to be changed by the new name before returning the list.
Cosmetic: It needs to be changed by the new name before roles.
Minor - s/something/operators/rest/script/
Minor - s/something/operator/g
Minor - s/something/operators/g
suggestion return (System.getProperty("OPENNLP_DATA_DIR.equals("OPENNLP_DATA_DIR"));
suggestion return (System.getProperty("OPENNLP_DATA_DIR.class"));
suggestion Utils.assertOpennlpDataDir();
please decrease log level to trace or better remove statement
please remove this statement or decrease to TRACE level
please decrease or remove this statement
Remove
Remove this
Remove type
This isn't an exception, so the name of the exception could be misleading.
I would throw an AssertionError here, as this should never happen.
I would throw an AssertionError here, as this doesn't happen.
> //NON-NLS-1
> Use the builder to create the strings.
> Clients don't use final for this.
please decrease or remove
please remove
please decrease log level to trace
Why do we have scheduling the sleep times? Also, do we need to wait the retryMs before we can't do anything under the min/max?
Why do we have scheduling the sleep times within a loop?
Why do we have scheduling the schedule timeout?
Why use the new SSLSession here?
Why use the new SSLSocketChannel here?
Why use an IOException here?
if this.public String getName() is the default, it can be omitted.
if this.public String getName() is the default, it may be a different value than the "Strategy"
if this are the same, make it a constant?
H-m. ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead?
H-m. ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead.
H-m. Why don't we do this once in the pool?
I would use the wordings of the Index_TYPE_NAME, instead of the +
I'm not sure it's good, but I would use the word bound where the TTL is, as the TTL is being sent by the server.
I'm not sure it's good, but I would use the word bound where the TTL is, as the TTL is being sent by the class.
Is this still needed?
Maybe you can use assertFalse here?
Maybe you can use assertFalse here instead?
Should also include context and suspend
Should also include context.
Should also include context -> AWSConfig
Can remove all invocations from this method.
Can remove all invocations from the codebase.
Can be removed
See the Sanitizer.sanitizeForRichText method that takes in the Sanitizer.
The Sanitizer call is not needed here.
See the Sanitizer.sanitizeForRichText method.
You can use assertNull
You can use assert indexMap.isEmpty()
You can use assert indexMap.isEmpty here
Log.error() for Flux.error()? There are many of these error types.
Since we are throwing the errorMapper, we don't need to log it here.
Log.error() -> errorMapper.onErrorResume(e);
Is this check necessary? If the mCommand list is empty, it could be implemented as: if (mCommandCounter == 1) { return; }
Is this check necessary? If the mCommand list is empty, it should be indexOfCommandCounter == 1 &&!mCommandCounter.DISABLE_UNDOOABLE_DISABLE_UNDO = true;
Is this check necessary? If the mCommand list is empty, it could be created when the command is not running.
Why don't you just call destroy instead? No break should be outside.
Why don't you just call destroy instead? No break should beMagnitude.
Why don't you just call destroy instead? No break should beMagnitude and then.
If customers send retention value that is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days. For cases where they deliberately send test metrics and then want to delete this file.
If customers send retention value that is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days (default 45 days).
If customers send retention value that is less than 45 days, we should use that value instead of 45 days (default value).
I think this should be else if to be consistent with the other methods.
I think this should be Future.getBlobInfo(oc, futureResult);
I think this should be Future.getBlobInfo(oc, futureResult, futureResult);.
Unnecessary, the packCache.getPackFile.remove already returns the reference.
Style-nit: Space after 'if'.
Unnecessary, the packCache.getPackFile.remove already returns the value from the packCache.
final int index = Math.min(index, height, lanes.get(index));
final int index = lanes.getUnifiedEnd();
I'd recommend adding an.size() here.
not sure if incrementCount is more reasonable.
not sure if incrementCount is more reasonable
not sure if incrementCount is correct
please verify the exact task was returned.
IMO the new TaskTaskFactory().getPresenter() should be invoked after the task task.
IMO the new TaskTaskFactory().getPresenter() should be called after the task task.
Could use port 0?
Could use port 0 to be consistent with other fields.
Could use port 0 to be passed all the time.
Are you sure about this exception? I think it is not a good idea to put this in it.
Are you sure about this exception? I think it is better to make it _private_, since you don't use it in constructors.
Are you sure about this exception? I think it is better to make it _private_, since you don't use it in multiple places
This should not be public
This should not be public.
inline
Can devfileFileLocation ever be null?
Can devfileFileLocation be null?
Can devfileFileLocation be null here?
Try to use Util.isBlank()
Try to use Util.isBlank() here
Try to use Util.isBlank
Shouldn't this be 60 * 1000L * 60 * 60 * 1000L?
Shouldn't this be 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60
Shouldn't this be 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 1000L * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60 * 60
It seems to me that this line is not necessary.
Why not just have a TriState.UNSET() method here?
It seems to me that this line is not needed.
This is not necessary.
This is not necessary anymore.
This variable is not necessary.
cost is already available in PlanNode constructor. It would be better for readability to take advantage of creating new BigInteger every time.
cost is already available in constructor
cost is already available in SKIP
This should be updated to use the parserContext.getReaderContext(). So, get the index for the provider.
This should be updated to use the parserContext.getReaderContext(). Otherwise, getPort will return the correct value.
This should be updated to use the parserContext.
Minor: This should be assertEquals(1, SECONDS).
This should be a precondition.
This should be assertEquals(msg, e.getMessage());.
I would add a condition for coll!= null &&!coll.isEmpty()
I would leave this one as it was with _isEmpty_.
I would add a condition for coll!= null
Does log.error("Exception caught at address {}, not data {}", data.getPayload(), data.getGlobalAddress());
Could you please use a more specific exception? log.error("Exception caught at address {}, id {}", data.getPayload());
Could you please use a more specific exception?
style nit: we don't use braces around single line blocks
style nit: no braces around single line blocks
style nit: we don't use curly braces around single line blocks
add () check for this.
add ()
add ()?
getSystemMemoryContextSupplier() -> getSystemMemoryContextSupplier().get()).orElse(systemMemoryContextSupplier::get);
getSystemMemoryContextSupplier() -> getSystemMemoryContextSupplier().get();
getSystemMemoryContextSupplier() -> getSystemMemoryContextSupplier().get()).orElse(systemMemoryContextSupplier::get);?
I don't see how this method is supposed to be used, I think it would be to do it. Or perhaps we need to do it now?
I don't see how this method would be invoked. Can it be called here?
I don't see how this method is supposed to be used, I think it would be to do it.
Better to assert that dependentFields is empty, rather than assertTrue( dependentFields.isEmpty()).
Better to assert that dependentFields is empty. E.g.: assertThat( dependentFields).containsOnly( dependentFields.size())
Better to assert that dependentFields is not empty.
Shouldn't you use ConfigurationGeneratorDataFileContent.class instead?
Shouldn't you use A.B.
Shouldn't you refactor the error messages to be more detailed?
@Override is missing
@jam01 Is Exception required here?
@Override is missing.
Please revert this change.
Please revert this line. It isn't really necessary to add authorizeService method to this PR.
Please revert this line.
Please check if you can extract to a method and reused.
Please check if you need to verify the command being null.
Please check if there is an ID in the format to avoid any future error.
It seems like this should be an address here, not a local endpoint that is supposed to be used.
This should contain the address that is localizable, not the one that we are testing.
It seems like this should be an address here.
log.warn
log the date and time instead of static method
log the date and time instead of static variable
Hmmmm.... now that you have something complete like this.
sysout not needed
sysout?
"WPS request process without the output column name." Is this the case?
"WPS request process without the output column name."
featureAttributeName(<LINK_0>
negotiate?
suggestion failHttpsFromConfig(event);
suggestion failHttpsFromConfig(event)
We want this to be able to trigger the IndexMismatchException may be thrown by the above method.
We want this to be able to trigger the IndexMismatchException's index, right?
We want this to be able to trigger the indexing if we don't see it.
brackets
brackets for all records
brackets around each block
Can we move new FormulaShifter(int externSheetIndex, lastMovedRowIndex, RowMove ) to make the new code of it?
Can we move new FormulaShifter(int externSheetIndex, lastMovedRowIndex, RowMove ) to the constructor?
Can we move new FormulaShifter(int externSheetIndex, long sheetName, int numberOfRowsToMove, externSheetIndex, lastMovedRowIndex ;)
Is it possible to use a timeout for the second time? I.e., what does it mean?
Is it possible to use a timeout for the second time? I do not understand how the concurrency is handled.
Is it possible to use a timeout for the second time? I do not see a reason to throw an exception.
Please use constants here, for consistency with the rest of the codebase.
Please use constants here, for consistency with the rest of the code.
Please use -1 as the default value when there are other constants in the JSON file.
Can we use!= null && componentInfo.applicationInfo!= null?
Can we use componentInfo!= null && componentInfo.applicationInfo.name!= null?
Can we use!= null && componentInfo.applicationInfo.name!= null?
Could we just do getEvidenceType().equals(alteration.VUS)
Could we just do getEvidenceType().equals(alteration))
Could we just do getEvidenceType().equals(alteration)
nit: this log message is a bit confusing, I think it would be cleaner if the hostName is not valid.
nit: this log message is a bit confusing, I think it would be nice to have the information about the host and value that is actually supplied.
nit: This log message is a bit confusing, I think it would be nice to have the information about the host and value that is actually supplied. Also I think the message should be method name
clients.remove(client)
If client is null, clients.remove(client) is called.
Check if client is null
you do not need InternalRecord (or ets_event_object_type_name) if you want to use a ets_event_object_value form in the Manangerous. I would prefer to use a simple ets_event_object_type_name instead of equals
you do not need InternalRecord (or ets_event_object_type_name) if you want to use a ets_event_object_type_name() method in the Flush docs.
you do not need InternalRecord (or ets_event_object_type_name) if you want to use a ets_event_object_type_name() method in the Flush docs.)
These two seem to be correct. Could you please remove the isisActive() check and use Objects.isActive() instead?
These two seem to be correct. Could you please remove the isisActive() check and use isActive() instead?
These two seem to be correct. Could you please remove the isisActive() check and just write return isActive()?
suggestion bean.setSourceSet(new HashSet<>());
suggestion bean.setSourceTemplate(new HashSet<>());
suggestion bean<?> = new HashSet<>();
is there a warning on sourceRow?
can destRow be null
can destRow be null?
The first argument should be enqueuedWrites
I would make it a constant.
The first argument should be enqueuedWrites().
Remove the try catch so it is closed automatically.
remove the try catch so it is set to null
Remove the try-catch block here.
can we have a single constructor that takes a SelectorFilter directly?
can we have a single constructor that takes a SelectorFilter and a nullToEmpty?
same question.
Should be a string resource
should be a string resource
This is a debug statement, please put it back
Do we need to check if this is all of the time?
Do we need to check if this is all in one line?
Do we need to check if this is all in the map?
Seems like we can merge this with the previous method.
Seems like we can merge this to one line.
Seems like we can figure out why this is required?
Since the action is non-existent, I think it should be Status.NOT_FOUND, and NO_ID is not mandatory. The idea is that if you pass brick.isForce() then you do not need to call the backend.
Since the action is non-existent, I think it should be Status.NOT_FOUND, and NO_ID is not mandatory. The idea is that if you pass brick.isForce() then you do not need to call this method.
Since the action is non-null, I think it should be 'false'.
Let's put cacheConfig = checkNotNull(cacheConfig, "hiveMetadata is null");
Let's put cacheConfig = checkNotNull(cacheConfig, "hiveConfig is null");
Let's put cacheConfig = checkNotNull(cacheConfig, "hiveMetadata is null"); before the assignment.
Also check if getSession() is null and remove this check.
Also check if getSession() is null and remove this check. The following code is superfluous.
Also check if getSession() is null and remove the close() call.
I think we can have a static import for CompletionStage
I think we can have a static import for this CompletionStage
I think we can have a single method for this CompletionStage
pls format (>120 chars)
no need to extract group name as it is done.
no need to extract group name as it is done....
I think here you could just use scrollAndClick instead of scrollAndClick, since it's not used anywhere else.
I think here you could just use scrollAndClick instead of scrollAndClick.
I think here you could just use scrollAndClick instead of scrollAndClick, since you are just doing a subset.
I don't think it will make sense to append the text twice. I wonder if we should just remove this method and directly call queryBuilder.append(jdbcLabel EMBEDDED MR always does the same.
I don't think it will make sense to append the text twice. I wonder if we should just remove this method and directly call queryBuilder.append(jdbcLabel EMBEDDED MR always does that.
I don't think it will make sense to append the text twice. I wonder if we should just remove this method and directly call queryBuilder.append(jdbcLabel EMBEDDED MR always does the same thing.
Why not use FAILED_ENV_NODE_CONIFG_EVENT here?
Why not use FAILED_ENV_NODE_CONIFG_COUNT here?
Why FAILED_ENV_event?
Can we compute this only once in the constructor and store it in local variable? e.g. getOzoneMetaDirPath(conf)
Can we compute this only once in the constructor and store it in local variable? e.g. getOzoneMetaDirectory(conf)
Can we compute this only once in the constructor and store it in local variable?
Missing ShortDOIServiceException and ShortDOIServiceException.
Maybe Ints.checkedCast(doi)
Missing generics
The last two return statements could be merged into one
The last two return statements could be merged to one, without any && or!=.
The last two return statements could be merged to one, without any && or ||.
Java doc mentioned: can be used to check check context
Java doc?
Java doc mentioned...
Consider using the username/password API for the username and password
Consider using the username field instead of the hard-coded string
Consider using the username field instead of the hard-coded string.
Is there a reason you are not using the annotation?
Is there a reason you are not using the annotation here?
Is there a reason for this change?
This should call idCodec.encode(idCodec.encode(id))
This should return the idCodec instead of returning null.
This should return an Optional.
I don't think you need the.name here.
I don't think you need the create span name here.
I don't think you need the createSpanNameRetrieval method here.
I think this can be reduced to a single line: return StringUtils.isNotBlank(gatewayAlias);
I think this can be reduced to a single log statement: java log.debug("debug--found url {}", gatewayAlias);
I think this can be reduced to a single log statement: java LOG.debug("debug--found url {}", gatewayAlias);
I think this part is redundant with the settings in setupModuleCheck below, isn't it?
I think this part is redundant with the settings in setupModuleChanged(), isn't it?
I think this part is redundant with the settings in setupModuleChangedAsTree(), isn't it?
> getValue()
Formatter
and this one
I'd use'return' here.
I'd use RefreshDurationListener<IPropertyListener> instead.
I'd use RefreshDurationListener<IPropertyListener> here.
No need of this. Its marked as @NotNull.
Why can't we use context.APPLICATION_PATH here?
No need of this. It is marked as @NotNull.
I know this was a lot of code, but can you please explain why this method is still needed?
I know this was a lot of code, but can you please explain why this method is needed?
I know this was a lot of code, but can you please explain this?
It's better to rewrote the lines by using **String.format()** method.
It's better to rewrote the lines by using **_waitAndClick** method.
It's better to rewrote the **_** method.
WDYT about changing the method name to one method?
WDYT about changing the method name to one method (and so method name)?
WDYT about changing the method name to one method (and so method name)
Missing trailing {
Nice error message
Was this needed?
Would it make sense to have this return false?
Would it make sense to assert running is not null?
Would it make sense to assert the return value here?
small typo - should be "encapsulation"
see the point for not using try-with-resources
see the point for not using try/catch - catch block
Does this work? It seems like you are creating a new serializer every time.
Does this work? It seems like you are creating a new serialize object every time.
Does this work? It seems like a waste of resources
MessageQueue.RegisterBankAccount_PushMessage
MessageQueue.RegisterBankAccount_PushMessage?
MessageQueue.RegisterBankAccount_PushMessage?
I think this part is redundant with the settings in setup code.
I think this code could be omitted.
I think this part is redundant with the settings in setup code already.
Why are we catching an exception and calling pause twice?
Why are we catching an exception and throwing the exception?
Why are we catching an exception and calling pause on the same thread?
Why are we no longer using the bundle here?
isn't a new Hashtable<String, String> be a concurrent?
isn't a new Hashtable<>?
Does this need to be synchronized? If the caller knows the reader, it should be ok in this case.
Does this need to be synchronized? If the caller knows the reader, it should be ok, but it's not...
Does this need to be synchronized? If the caller knows the reader, it should be ok, but it seems this method is not used.
Isn't there a peek operation on the getRoles method, and get the logic from the stream?
Isn't there a peek operation on the getRoles method, and get the logic from the other one?
Isn't there a peek operation on the getRoles method, and the logic that if you have Stream<Privileges> then the stream should be collect into a stream?
this is not necessary
this is not necessary anymore
not necessary.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
Also having util/logger/safe string, you can simplify this: case ConstantOperand.get(APPLICATION_SUITEException.class);
Also having util/logger/safe string, you can simplify this: case ConstantOperand.get(APPLICATION_SUITEException.class).getName(): case WE: case WE: break;
Also having util/logger/safe string, you can simplify this: case ConstantOperand.get(APPLICATION_SUITEException.class.getName()): case SET: case WE: show_RESOURCE_WE:
It seems that this filter could be replaced by findFirst().anyMatch(id -> shape.getDmnElement().equals(id))
It seems that this filter is not necessary to use filter on DMNShape.
It seems that this filter is not necessary to use filter on DMNShape.isDiagramElement().
Shouldn't this be: java return detectLanguageWithResponse(text);
Should the return type be Mono<Duration> instead of a Mono?
This method should be private.
I think we should clean up the toasts here instead of being able to add it to the log statement.
We should clean up the existing code here as well. I know that the text comes from the existing PromoDialog class.
I think we should clean up the toasts here instead of being able to add it to the log taken. It would be good to have a clean up the code here as well.
I'm not sure this is correct. reassignmentsInfo may be the same as reassignment, so, the local variable reassignmentsInfo is not assigned to a new instance. It's not very clear to me that reassignmentsInfo.
I'm not sure this is correct. reassignmentsInfo may be the same as reassignment, so, the local variable reassignmentsInfo is not assigned to a new instance. It's not very clear to me that reassignmentsInfo.reassignmentsInfo is hand, so the reassignment is not assigned to the same value. Why?
I'm not sure this is correct. reassignmentsInfo may be the same as reassignment, so, the local variable reassignmentsInfo is not assigned to a new instance. It's not very clear to me that reassignmentsInfo's are the same, but it's still on opposite.
Should this be private?
should this be private?
Should this be just PackageAsCondaPath(0)?
The following two method calls can be refactored into a method, because they are always the same for all the cases.
The following two method calls can be refactored in a method, because they are always the same for all the cases.
The following two method calls can be refactored into a method, because otherwise it is really complex to control the behaviour of the distributed system.
I would suggest to factor out this line into a method resolved in the super class, e.g. public void setIngressTimestamp(String newValue) { @Override public void getIngressTimestamp(String value) { return getIngressTimestamp(null); } }
I would suggest to factor out this line into a method resolved in the super class, e.g. public void setIngressTimestamp(String newValue) { @Override public void getIngressTimestamp(String value) { return new Object(); } };
I would suggest to factor out this line into a method resolved in the super class, e.g. public void setIngressTimestamp(String newValue) { return getIngressTimestamp(defaultObject); } This way if we apply this change other tests, the implementation can still return null anyway.
just FYI, this class is now immutable so you're missing a.equals() check for null just in case
just FYI, this class is now immutable so you're missing a.equals() check for null.
just use equals()
This is better than the following, since you have to touch regex by itself in constructor
This is better than the following, since you have to touch regex by itself in constructor and do a simple regex instead of calling contains method. At least a simple regex would be better, since you probably wouldn't want to test the middle after the tests.
This is better than the following, since you have to touch regex by itself in rule of compiled compiled pattern. At least let's do the following: - into bean: - start with \t\r,... - regex
nit: Could use Set<BasicRole>.
nit: Could use Set instead of HashSet here.
nit: Could use Set instead of HashSet
Should have a space before the braces.
Should have a space before the curly bracket
Should have a space before the curly bracket.
If this is the last line of the test, should be able to use Assertions.assertThat(...) as the new one?
If this is the last line of the test, should be able to use Assertions.assertDoesNotThrow(originalStreamRecord.class)
Any reason we need this?
Updating repository from remote repository?
Should we not just persist the repository?
Updating repository from remote repository, not just new Save
"0"?
"0" would make sense?
"0" seems odd?
No eventLoopGroup is missing.
No eventLoopGroup is needed.
No eventLoopGroup is ever present.
It might be better to use hashtag.getHashtag() instead of toString()
It might be better to do the same here and remove the hashtag if this is already present in the cache.
It might be better to do the same here and remove the hashtag if this is already created.
This early return can be simplified to if (!url.contains(getMimeType())) {...
This variable is unused.
This early return can be avoided.
Do we need to make this test more complex and have a test case to test when the solver is still running?
Do we need to call d3Loads() here?
Do we need to make this test more than once?
_Off-topic: Don't know why we used the equals method. You can add it to the equals method.
_Off-topic: Don't know why we used the equals method. You could add it to the equals method.
_Off-topic: Don't know why we used the equals method here.
Don't delete this, if it's ever the same, but in the LogDBExecutor case, we'll end up with an exception.
Don't delete this, instead make them final.
Don't delete this, if it's ever the same executor.
Why not use fixture?
Why not just use fixture?
Why use fixture?
This can be moved to a second if statement.
This can be added to the form brackets of the if statement.
This can be moved to a single line
you can merge the conditional on ctx.onReturn() before ctx.customizeInvocation()
you can merge the conditional on ctx.onReturn() before ctx.continueInvocation()
you can merge the conditional on ctx.onReturn() before ctx.onReturn()
Don't use basePath, use String.format("%s"
Don't use basePath at all.
Don't use basePath as it is safe.
move the calls to here, and remove the exclusive brackets
re-use 'private' here
exclusive these methods are not used?
As with the framework, I think this could be written like: java if (this.entityConstructor == null) { return null; } if (this.entityConstructor == null) { return null; } return getConstructor(entityClass);
As with the framework, I think this could be written like: java if (this.entityConstructor == null) { return null; } return getConstructor(entityConstructor.entityConstructor);
As with previous patch set 2, let's use a simple variable here.
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
Under what circumstances (indexInterpolated == null || indexInterpolated.equals(indexInterpolated)) seems to be false.
Under what circumstances (i.e. the validation methods below) are non-null?
Needs to use same hash code.
Needs to consider: return Objects.hash(path, path);
Needs to consider: return Objects.hashCode(path).hashCode();
rename to video
rename to OpenModel.asCheckBox()
rename to video.
Could you use lambda here? It would be nice to have a method reference instead of class.
Could you use a lambda here?
Could you use lambda here?
to this method is very confusing, you can check with Collections.singletonList() and return either Collections.emptyList() or Collections.singletonList()
to this method is very confusing, you can check with Collections.singletonList() and return either Collections.emptyList() or List.
to be consistent with this API name...
This will break when multiple pollers exist for the same user. Should we use Spring poller.getInstance() instead?
This will break when multiple pollers exist for the same user. Should use Spring poller.getInstance() instead
Why will it be null? Should we get an empty list instead?
remove local variable
remove local var
rename to descriptor
Maybe more specific: java Option<Integer> option = Option.some(1); return new Option<>();
Maybe more specific: java Option<Integer> option = Option.some(1); return new Option<Integer>();
Maybe more specific: java Option.some(1); return new Option<>();
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
I'd add a check for if (dbDir == null) { repoDir = db.getDirectory(); } else { repoDir = db.getDirectory(); }
I'd add a check for if (dbDir == null) { repoDir = db.getDirectory().getWorkTree(); if (db.isBare()) { repo.setBare(true); } else { repo.mkdirs(); }
Throw exception if user passes in null
Throw exception if user passes in null.
Throw exception if user passes in null, instead.
This should probably be done in the RestResourceController instead of here.
This should probably be done in a more useful way of error handling. Just to make sure the user can see what the group cannot be patched.
This should probably be done in a more useful way of error handling. Just to make sure the user can see what the group cannot be null.
I think this should be protected
This should be protected as well
This should be protected
This creates a new random provider every time, is it needed?
This creates a new random provider every time, is it needed?
This creates a new random provider every time the user is created
I like the idea of using a string resource, but I prefer the latter.
I like the idea of using a string constant here. I think, that might be a good idea.
I like the idea of using a string constant here. I think, that might be a good idea to put this as the default value.
This can be repelaced by a UserReportingSettingsHelper call.
This can be repelaced by a UserHelper call.
Use Ccich Impl.Builder
no reason to explicitly set to null, its default behavior
no need to explicitly set to null, its default behavior
no need for the super()
Not sure whether this should be done in the constructor.
Not sure whether this should be done in a while loop, but not for reading all the tuples.
Not sure whether it's a good idea to return an empty array when catching this.
Eliminate this variable and use a try-with-resources block.
Eliminate this as if the client is reused for both client and client. Is this the expected behavior?
Eliminate this as if the client is null
Can we assert on the result and isnamedBamFormat?
Can we assert that result is a specific bam?
Can we assert on the conf being null here?
Are these strings defined somewhere? They are not quite clear what they are.
Are these strings defined somewhere? They are not quite clear what they are. You should use the constant?
Are these strings defined somewhere? They are not quite clear what they are. You should use the constant.
I guess return "Failed to find PMMLConstants".
I would suggest adding something like Objects.equals that will work.
I would suggest adding something like "Failed to find PMMLConstants with name:"
I still don't understand why we need to re-throw the exception, and not just logging it as a warning
I still don't understand why we need to re-throw the exception, and not just logging it in the caller.
I still don't understand why we need to re-throw the exception, and not just logging it in the places below
Could you change this to: if (!cluster.getClusters().isEmpty()) { return cluster; } if (cluster.getId().equals(guid)) { return Clusters.get(cluster.getId().equals(cluster.getId())) { return cluster.getClusters(); } }
Could you change this to: if (!cluster.getClusters().isEmpty()) { return cluster; } if (cluster.getId().equals(guid)) { return ClustersClusters.get(cluster.getId().equals(cluster.getId())) }
Could you change this to: if (!cluster.getClusters().isEmpty()) { return cluster; } if (cluster.getId().equals(guid)) { return Clusters.get(cluster.getId().equals(cluster.getId())); } return cluster.getClusters() + 1);
It would be much clearer if lawJournalEntryCreator had a method like lawJournalEntryCreator. It could be used here and at the beginning of each class.
It would be much clearer if lawJournalEntryCreator had a method like lawJournalEntryCreator. It could be used here and at the beginning of each method.
It would be much clearer if lawJournalEntryCreator had a method like lawJournalEntryCreator.
If we're going to use this outside of the if (WindowRef.isEnvelopeAvailable()) block, do we still need this?
If we're going to use this outside of the if (WindowRef.isEnvelopeAvailable()) statement, do we still need this?
If we're going to use this outside of the if (WindowRef.isEnvelopeAvailable()) block, then we don't need the below if (
casting isn't necessary here, is it?
casting isn't necessary here, passed in the constructor.
casting isn't necessary.
Maybe it should be response.substring(0, response.indexOf() -'')
Maybe it should be response.substring(0, response.indexOf() -'');
Maybe it should be maxRemoteSize
I think this should be the first : Also, how about making sure that the Map is enough - there's a view need to be created under the Map in the list?
I think this should be the first : Also, how about making sure that the Map is enough - there's a view need to be created under the Map in the map?
I think this should be the first : Also, how about making sure that the Map is enough - there's a view of Values?
I think there are 2 approaches instead of just ignoring the File path, we can just use the File#getPath instead.
I think there are 2 approaches instead of just ignoring the File path, we can just use getPath instead. I know the conf already exists in the list, but the logic is not need to be changed.
I think there are 2 approaches instead of just ignoring the File path, we can just use getPath instead. I know the conf already exists in the list, but will not find it.
does this need to be public?
This is the only place where we need to get the value and then do equalsIgnoreCase on it.
This is the only place where we need to get the value and then do equalsIgnoreCase check.
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.shared.TimeoutUtil#adjust to adjust the time of this test?
100 seconds is 1 order of magnitude more. It could be a static import
100ms is too hard to understand
note: This will collapse all tables to a single table.
Possible NPE here if we're not going to happen.
Extract a method here?
This should be synchronized
It looks like it should be reset at the end of the class method
It looks like it should be reset at the end of this method
Should be faster than concatenation
Should be maxVote, no?
Should be maxVote, not %s
Why is this needed?
Why is this needed? I don't think the logic is necessary.
Why is this needed? I don't think this check is necessary.
this two things are special afair cc @lanwen
this initialization can be omitted as it is not used
this initialization is redundant
Can you add call to super() then? That'll give you a get() and the set() won't be null.
Can you add call to super() then? That'll give you a get() and the set() won't be null
Add call to super() then.
what does this mean?
what does this mean? Why should it be equals to avoid assuming before?
too long?
This can now be deleted.
This can now be replaced with the one above.
This can now be taken out.
Should be this.title = title
Should be this.title
Should we use TitleBuilder instead?
I suggest to also check if a field is not equal
I suggest to also check this method. getVersion() == null
I suggest to also check this for == null
we can make this a static inline method
we should also add a default encoding here
we can make this a static inline class
it is the only value of this method. The assertion is not necessary.
it is the only value of this method. The prefix of the method is not changed.
it is the only value of this if statement is the one.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to a method called toOrganization which really should be static
analysisMetadata.setOrganizationsEnabled() should be called first when the method is called.
analysisMetadata.getOrganization (Quality metadata) seems unnecessary
Log messages like this?
Log messages appear to be a bit of an unexpected format thing as they are used for logging.
Log messages appear to be a bit of an abstraction, they can be split into separate instances for readability.
I don't think we need that anymore, in fact, that's fine. The first thing I see is that we have to do with a null check. And if we don't use it, I think it's worth adding a null check in the first place to avoid that.
I don't think we need that anymore, in fact, that's fine. The first thing I see is that we have to do with a null check. And if we don't use it, I think it's worth adding a null check somewhere else.
I don't think we need that anymore, in fact, that's fine. The first thing I see is that we have to do with a null check. And if we don't use it, I think it's worth adding a null check in the first place.
final
store the value of mDataReader in the constructor instead of mmm
store the value of mint in the constructor as well
please assert the return value
please assert that the report is null
please add return type: public Report::Report
This is an magic number. Shouldn't it be CLOSED?
This is an magic number.
Isn't this a magic number?
I don't think you need to start with the line anymore.
I don't think you need to start with the line.
I don't think you need to skip the test.
Shouldn't this return 'public'?
Shouldn't this return'ref'?
Shouldn't this return TransitionProxy.class?
Wouldn't it make sense to use the constant for the keyShortener.fromKeyShortener. Right?
Wouldn't it make sense to use the constant for the keyShortener.fromKeyShortener?
Wouldn't it make more sense to use an KeyShortener.fromKeyShortener. Right now the key shortening is also used in many places, so you may want to change the KeyShortener.class to KeyShortener.class.
You don't need to check if the set is empty.
You don't need to update the locale - the value is not 0.
You don't need to update the locale - you can simply use "mind".
Is there a test for that?
Is there a test for this change necessary?
Is there any test for that?
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
I think we have some constraints regarding the options here. (e.g., exactly one? at most one?)
I think we have some constraints regarding the target URI? (e.g., exactly one in the ClientBuilder..)
Verify that returns null
Move this to the the non-static method.
Move this to the non-static methods.
Call base32.base32().decode(base32()); directly.
Call base32.base32().decode(base32()); on close?
Call base32.base32().decode(base32().decode(base32()));
Rename to m_
Should this have a final variable?
Let's have a more descriptive name.
remove the 'public' modifier
do we need a param here?
make this a Status
can you revert this?
can you please revert this?
can you please revert this change?
now that we are now using this method, changing the return value to: return runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters);
now that we are now using this method, changing the return value to: return runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters).getReturnValue();
now that we have to create new list, getReturnValue(getReturnValue()) should be non-null :)
Was this the same as LOGGER.warn?
Was this the same as warn?
Was this error message intentional?
Remove the redundant assertion.
Remove the redundant assertion?
Remove the added final
I think it is fine to remove this one. it is used only when debugging
I think it is fine to remove this one. It's unnecessary this a lot
I think it is fine to remove this one. It is a temporary debug/development
Hi @filfreire use Objects.isEmpty(message) instead of TextUtils.isEmpty(message)
Hi @filfreire use Objects.isEmpty(message) instead of!TextUtils.isEmpty(message)
Hi @filfreire use a more elegant solution, thanks!
No need to use SequentialIdentifierGenerator.
Any reason not to use SequentialIdentifierGenerator instead of SequentialIdentifierGenerator?
The SequentialIdentifierGenerator itself is not ordered. Is there a reason to use this?
Unnecessary call to super()
Unnecessary call to super
Unnecessary call to super method
Instead of reset i would you check if probeIndex is not null?
Instead of reset i think it will be better to reset value after reset
Instead of reset i think it should be reset
I didn't see a point in adding a new list to the list. Is that what we want? I see the point is that if project.getName() returns empty list, then it is not the default, right?
I didn't see a point in adding a new list to the list. Is that what you intended? I see it is a set, but it is not as understandable as a set.
I didn't see a point in adding a new list to the list. Is that what we want? I see the point is that if project.getName() returns empty list, everything is still in the UI, so maybe it is not a good idea to make sure the project contains all the time
Perhaps try to simplify this to: java if (institute == null) { return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED); } return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED_JOIN_COURSE_JOIN_COURSE_SEPARATOR;
Perhaps try to simplify this to: java if (institute == null) { return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED); } return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED_SEPARATOR;
Perhaps try to simplify this to: java if (institute == null) { return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED); } return Const.ParamsNames.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED_JOIN_SEPARATOR;
Why static? We should make a copy of the array.
Why static? We should make a helper method for this...
Why static? We should make a helper method for this
perhaps vds load blanacer
the same, why not use method reference?
the same, why not use C## ip?
final
final?
final.
I would prefer "SetAlarmNotifications must not be null"
I would prefer "SetAlarmNotifications" to make sure the interface methods are called.
I would prefer not to make this method synchronized
remove throws Exception for now, right?
remove throws Exception
same here, removed test
Why is it needed? You could just log it here.
Why is it needed?
Why is it needed? You could just log it and continue.
code shouldn't be here. TVAElementType. )
code shouldn't be here. TVAElementType..
code shouldn't be here. TVAElementType.. I don't know why Google uses UTF-8.
why 40 as a limit?
why not just 40 as a limit?
why not just "field column"?
I don't think this would be the right way to map them to the following: Objects.requireNonNull(subscriptionKey, "message");
I don't think this would be the right way to go.
I don't think this is needed.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSourceIfRequested(), and you will end up with a method called disposeLookupSourceIfRequested() in fact and disposeLookupSourceIfRequested()
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSourceIfRequested() and disposeLookupSourceIfRequested()
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_RESOURCE, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckNoneOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
You can do this more simply with java @Override public void testValidateField(final FormField field) throws; try { FormField field = mock(fieldStateValidator.class); when(fieldState.isRequired()); when(fieldStateValidator.validate(fieldStateValidator.class)); } catch(IllegalStateException.class); throw new IllegalStateException("IllegalStateException is not thrown"); } }
You can do this more simply with java @Override public void testValidateField(final FormField field) throws; try { FormField field = mock(fieldStateValidator.class); when(fieldState.isRequired()); when(fieldStateValidator.validate(fieldStateValidator.class)); } catch(IllegalStateException.class); } }
You can do this more simply with java @Override public void testValidateField(final FormField field) throws; try { FormField field = mock(fieldStateValidator.class); when(fieldState.isRequired()); when(fieldStateValidator.validate(fieldStateValidator.class)); } catch(IllegalStateException.class); throw new IllegalStateException(() -> { throw new FormField.class); } });
maybe use a logger instead of System.out
maybe use a logger here instead of System.out
maybe use a logger here instead of sysout?
if you want to keep this method, you can reference compareAndSet() instead
Rename to fluxDB
Rename method to fluxDB
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "Removed [%s]", path)
Can we use Trampoline.set(f); here?
Can we use Trampoline. Most be in Vampoline.
Can be inlined in the declaration.
why catch all exceptions and not Exception?
why catch all exceptions and not just Exception?
why catch all exceptions and not RuntimeException?
Is there any reason why this is needed?
Is there any reason why this change needed?
setHasOptionsMenu(true) seems unnecessary
I think it is better to use TimeUnit.currentTimeMillis() than System.currentTimeMillis()
any reason you have to change this?
I think it is better to use TimeUnit.currentTimeMillis() here.
Use Context.getAnalyzeContext(ExternalContext).
Use Context.getExternalContext;
Use class context instead of Context.
Parsing an additional timestamp is a little scary here. Would it make sense to separate the two new methods.
Parsing an additional timestamp is a little scary here. I think it would be a little clearer to follow the functionality.
Parsing an additional timestamp is a little scary here. I think it would be a little clearer to separate the functionality.
Might want to rename this to shutdownThreads()
Might want to rename this to something like - "There are no online jobs left uncompleted in test %s"
Might want to rename this to something like - "There are no uncompleted in test %s"
Would be better to have the context be null here?
Would be better to have the context be null here.
Would be better to have the context be null here instead of inflate it.
you can use mapToLong here and then sum()
You can use mapToLong here and then sum()
use mapToLong here and then sum()
Oh and this font color, do you have a Mac to test this? If I remember it right, then the call context is a chromeless hover window on Mac (with black background), while it is a standard window on other OSs. As the text is inside a normal dialog here, I don't think the color change is necessary.
Oh and this font color, do you have a Mac to test this? If I remember it right, then the call context is a chromeless hover window on Mac (with black background), while it is a standard window on other OSs. As the text is inside a normal dialog here, I don't think the color change is necessary IMO.
Oh and this font color, do you have a Mac to test this? If I remember it right, then the call context is a chromeless hover window on Mac (with black background), while it is a standard window on other OSs. Moreover, I don't think the color change is necessary anyway.
+ desc
if it should be public
should return this
this should be seekCommand(false)
this should be seekCommand( seekCommand)
this should be seekCommand( seekCommand)?
Can the order be negative?
Can you make sure that the order is not found (only) is the default from the database, so that it's better to remove them from here.
Can you make sure that the order is not found (only) is the default from the system
I'm not a big fan of this. Why are you using a map to the map?
I'm not a big fan of this. Why are you checking if the list is mutable?
I'm not a big fan of this., because it makes the symmetry harder to see what's happening here. What do you think?
Can be a private static class.
Can be simplified to just.equals(key)
Can be a private class, preferably the package?
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "start". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Replace this unused private "static" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "set" method. [![rule](<LINK_2>](<LINK_0>
Again, we should check namespaceBuilder.append('a', namespaceBuilder.toString()).
Again, we should check namespaceBuilder.append('a') namespaceBuilder.append('a', namespaceBuilder.toString()).
Again, namespaceBuilder variable can be omitted.
I thought this was to be debug to prevent unwanted data from appearing in the log.
I thought this was to debug to prevent unwanted data from appearing in the log.
I thought this was to be debug to prevent unwanted data from appearing in our log.
should be protected
should be inlined
use static
Use Collections.emptyList()
Use Collections.emptyList() here instead of a new ArrayList
Use Collections.emptyList() here instead
I think we can remove this line.
I think we can remove this method since it is not used anywhere else.
I think we can remove this method.
spacnig
s/input/input
We could keep those final.
Shouldn't it be an immutable list?
Initialize with an immutable list.
Can return an immutable list.
What about creating a private method BackendClusterFeatureHelper that just calls it? Then you don't need the.map() and the transform() method. The other method will use it.
What about creating a private method BackendClusterFeatureHelper that just calls it? Then you don't need the.map() and the transform() method.
What about creating a new BackendClusterFeatureHelper instance and then using it to pass it instead of creating a new one?
Can you use LOGGER.debug here?
Create a constant you can use below
LOGGER.debug
You could have a resolve() method instead of resolve() which returns a TmfCpuAspect (and derived classes) to resolve the event types too, but this is not.
You could have a resolve() method instead of resolve() which returns a TmfCpuAspect, for example: String resolve = resolve(Class.class); resolve(event);...
You could have a resolve method that does the resolve and resolve it before the get call.
isValid() instead of!= null?
isValid() instead of.matches().
isValid() instead of!true?
should this be able to add a membership that matches the patient?
I think this should be able to add a membership that matches the patient and remove it
should this be able to add a void?
This should probably return an optional.
This should probably return an Optional.
This should return an optional.
How is this expression different from "this"?
How is this expression different from "this"? I've seen in another commit that introduced this, but would like to use the project name instead?
How is the expression different from "this"?
I think this can go in the constructor.
I think Provider<MarkerSet> would make this method private.
I think Provider<MarkerSet> would work here.
s/public//
s/get*()/get*()/
Reduce the number of parentheses to the early return statement
@tristantarrant Is this something necessary? Shall we rename the variable?
@tristantarrant Is this something necessary? Shall we rename this function?
@Nullable Exception handling is necessary.
Could you put the Misc.free(backupWriterPool) in a local variable and use it here?
Could you put the Objects.free(backupWriterPool) in a local variable and use it here?
Could you put the Misc.free(backupWriterPool) in a local variable and use it here.
Consider adding a new CheckpointType, like the other methods that return a CompletableFuture<Void>. It would be the better to keep this method synchronized.
Consider adding a new CheckpointType, like the other methods that return a CompletableFuture<Void>. It would be the better to keep that.
Consider adding a new CheckpointType(..) method.
Maybe we should use the 2nd argument constructor
Maybe we should use the 2 argument constructor
use the 2nd parameter
We need to log exception here.
We need to add some log to exception.
We need to create some sort of RuntimeException here.
This whole method is unnecessary, stacktrace gets logged at the right level.
This whole method appears to be outdated. Could you move the suggested refactoring to the inner class?
This whole method appears to be a duplication, could you extract the if-else statement?
Add this to the delegate.
Add this to the flush method.
Let's have this one return null, I think.
getHCallDistance() could return 2 different results. It's that the first one will be different on each invocation.
getH method should return 2 different instances. You can use that one.
getHCallDistance() could return 2 different results. It's that the first one is returning "".
Integer.valueOf?
Integer.valueOf or similar
GetterName and name doesn't match
Should be e.g. on failure.
Should be in the view to clear the text.
Should be e.g. setText(false);
Hm, I think we should still throw exception in these cases?
Hm, I think we should still throw exception in such case?
Hm, I think we should still throw exception in such case.
Why not to keep the implementation more flexible?
Why not to make a synchronized method?
Could you explain why you make a new connectionId here?
Collections.emptyList();
Collections
Collections#emptyList();
Similarly
Hey @Override
Similarly :)
Why allocate a single boolean here?
Why do you need the handler here?
Why do you need the same flag here?
This is not needed. Could you please remove the first else and just return the value of getAutomaticIdSpec(Pattern.compileId(hardwareId)) );
This is not needed. Could you add an else clause to the current exception?
This is not needed. Could you add an else clause to the current error message?
Perhaps we should extract this logic into a method so we can call it twice in the pipelineFactory
Perhaps we could extract this into a method so we can call it twice in the pipelineFactory
need a null check
remove.
Remove.
remove
I do not think we need to cast to MapEntriesEntries in this context. What do you think?
I do not think we need to wrap in HAProxyEntries...
I do not think we need to cast to MapEntriesEntries, just to make it more readable.
since this happens before canDoAction, getVdsGroup() can be null
actually Yair reminded me that we do have the method isInternalExecution() that is true when call another, because it (should always) use runInternalExecution()
actually Yair reminded me that we do have the method isInternalExecution() that is true when command calls another, because it (should always) use runInternalAction
nit: assertNull
nit: assertNull?
nit: This line is not needed
throw exception
throw throw exception
throw exception?
Should be super(factory, null);
Should be super.public
Should be super(factory, "public");
[optional] Why not just use for(int questionId : displayName.get(i)) { and then iterate over the list instead of the displayName?
[optional] Why not just use for(int questionId : displayName.get(i).append("...")
[optional] Why not just use for(int questionId : displayName.get(i).toString())?
Please use StringUtil instead.
I think it's simpler to use StringUtil.EMPTY_USED_LAST_USED_LAST_USED constant.
I think it's simpler to use StringUtil.EMPTY_USED_LAST_USED constant.
expected?
expected is actual
expected is always first
I think we should depend on the fact that this is an instance of String which is not enough...
I think we should depend on the fact that this is an instance of EmptyObject which is not enough to check it's a reference to the class and we know it's not going to fail on an exception.
I think we should depend on the fact that this is an instance of EmptyObject which is not enough to check it's a reference to the class and we check it's not null.
toString() is not necessary
toString() is not required here
toString() is not required
Can we use NullBinding here?
Can we use StringUtils.join from Guava?
Can we use NullBinding instead?
you can use TimeUnit.SECONDS.toMillis(s)
you can use TimeUnit.SECONDS.toMillis(reNodeSize())
you can use TimeUnit.SECONDS.toMillis()
Can you log a debug message here?
Can you log a debug message?
Can you make this more specific?
click on element
double space
double space after )
You should use the bench instead, not the action, but you are not checking the action, hence getting the stack trace.
You should use the bench instead, not the action, but you are not checking the action, so it will be not that
You could use the bench instead of action, but you are not checking the action, so it will be not that
Just nitpick: tc.getTypes().add(ConstT.class);
Just thinking if we could use tc.getTypes().stream().map(Class::getName).collect(Collectors.toList()).
Just remove the tc variable altogether.
probably want a continue-fast here too, to either throw an exception or log a message saying that the client can't do anything with it.
probably want a continue-fast here too, to either throw an exception or log a message saying that the client can't send past the server, it will be too verbose for the client.
probably want a fix for %d here as well
I'm not sure how this particular case is handled. shouldn't we first try to read from the stream?
I'm not sure how this particular case is handled. The infinite loop would be better.
rename channel to readableByteChannel
Return the object instead of the concrete class' [List<Integer>](<LINK_0>
Return the object once is the same. We don't need to return a set here.
Return the object once is the same. We don't need to return a set
Map<String, String>
return getDescription()
String.format
final
Annotations should be done in a new code.
Annotations onAvro()?
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Rogelio's above suggestion applies here as well: > I think we could modify the logic a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private method, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Can be package local
This can be made package local
This can be made static
Do we need a defensive copy here?
Why not @ScalarImplementation?
choices.add(ScalarFunction.class, choice)
I think this line is unnecessary.
I think this line is better to understand.
I think this check is better to understand more.
I think it would be best to keep the comparison the other way around.
I think it would be best to keep the comparison the other.equals and hashcode logic here.
can we use comparison the other way around?
The while loop should be inside synchronized as well.
The 'finally' block is unnecessary here as well.
The while loop should be simplified to.forEach(thread!= null)
The same for every method
Maybe rename deleteDirectory to deleteDirectory
The same for every test
Object = myfile.findFile(virtualFile);
Object = myFile.findFile(virtualFile);
Object = myfile.findFile(virtualFile); if (primitive == null) { return; } return true;
synchronized on a method synchronizes on the quarks that are not synchronized, this method should be synchronized
synchronized on a method synchronizes on the quarks themselves instead of fTrace.valueOf(fCount)
rename to quark
Can you have an @After method that unbinds this connection. This is more reliable.
Can you have an @After method that unbinds this connection. It's more reliable.
Can you have an @After method that unbinds this connection.
I think this extra line is unnecessary.
I think this extra line is unnecessary
I think this try-catch is redundant
Don't use morrow.
Don't use morrow. In all the test cases, if only that one of them is change, the test will fail.
Could you change the test to use config.isDue()?
can you move this call to the declaration of 'if'?
can you pass parameters.getGracefully() to the constructor as well?
can you print the parameters in the log?
I'm not quite sure about usage of find() here. If we are searching for the entire string, I would recommend using matches() instead. I don't see any test case which would justify using finding for subsequences rather than on everything.
I'm not quite sure about usage of findValid here. If we are searching for the entire string, I would recommend using matches() instead. I don't see any test case which would justify using finding for subsequences rather than on everything.
I'm not quite sure about usage of findAttribute here. If we are searching for the entire string, I would recommend using matches() instead. I don't see any test case which would justify using finding for subsequences rather than on everything.
nit: Looks like it's never used?
nit: Looks like it's never thrown.
nit: Looks like it's never used.
nit: maybe change the declaration to newInstance and use codec.newInstance here.
nit: maybe replace the explicit type from the cast here.
Mmm
I am wondering if it would make sense to use return literalTypes.values() here
I am wondering if it would make sense to use return literalTypes.values() + 1
I am wondering if it would make sense to use return literalTypes.values() here?
Should we include typeAlternatives or something here, all the type has to be supported?
Should we include typeAlternatives or something here, right?
Should we include typeAlternatives or something here, all the type has to be
Map<String, () ->.map(InstanceProperties::getRegisterHealthIndicator).orElse(true);
Optional: use orElseGet
Map<String, >() is unnecessary
You should use the standard way of doing this, and you could use the @Rule ExpectedException rule
You should use the standard way of doing this, and you could use the @Rule ExpectedException rule.
You should use the standard way of doing this, and you could use the @Rule ExpectedException rule instead of calling the setter.
If these are Strings, this will be redundant with getPackageVersions().
If these are Strings, this will be redundant with the next call.
If these are Strings, this is going to break right?
@ptirador I mean this should be ELIXIR_SDK_PATH instead of ELIXIR_SDK_PATH.
@zhantemirov, should we use isElixirSdkPath instead of ELIXIR_SDK_PATH?
@ptirador I mean this should be ELIXIR_SDK_PATH instead of ELIXIR_SDK_PATH. But anyway this method doesn't need to be public.
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf(...) instead of new Long() - always for performance reasons
use Long.valueOf(1)
Can you reduce this to the minimum?
Can you reduce this to the columns that are relevant?
Can the minimum be restricted?
Unfortunately this method can be replaced by functional style Java, as per example given in Epdq.
Unfortunately, I think we're going to need to create a new object every time we call it. This block can be replaced with functional style Java, as per example given from the other places.
Unfortunately this method isn't named a sort of Charge
The close() should be done in a finally block.
The try-with-resources block should be moved to the finally block.
The data source is closed in a finally block
Use isEmpty instead?
Use isEmpty instead of isEmpty.
Use anyMatch instead of isEmpty.
I'm not sure this is correct. The test is not clear if the SslProtocolProperty is a mock (which is what we want). I don't think these assertions are necessary.
I'm not sure this is correct. The test is not clear if the SslProtocolProperty is a mock (which is what we want). I don't know if it's necessary since we reset it.
I'm not sure this is correct. The test is green when using Boolean.parseBoolean.
Why can't you just call cr.toString() and then remove the,?
Why can't you just call cr.toString() and then you don't need the entire string?
Why can't you just call cr.toString() and then remove the toString() from the string?
A flip!= null isORIENTATION_TRANSPOSF.
A flip!= 0 isORIENTATION_TRANSPOSF.
A flip!= 0 isORIENTATION_TRANSPOSF. Is it possible to use the mime type?
could we define a final variable that is initialized with the size of the API?
could we make a List<ParameterParameter> instead of change visibility?
could we make a List<ParameterParameter> instead of array?
Why are you assigning 0 to a value again?
Why are you assigning 0 to 1 here?
Why two and second condition?
what about testing here?
what about testing java conditionals like: if (values.stream().anyMatch('1', '2')) { should be '2', no?
what about testing java conditionals like: if (values.stream().anyMatch('1', '2')) { should be '1', no?
This should be public.
This should probably be public.
This should be private.
the try-with-resources block will not be closed
the try-with-resources block will not be closed.
you could just try-with-resources here?
Same here. Consider moving this into a private method.
Same here. Consider moving this into a class.
Same here, move this variable into the createPageUrl method.
Please, use if you're going to improve your code style.
Please, do not use Java 7 for such methods. Use <LINK_0>
Please, do not use generics for this. Please, fix the indentation.
style: we don't use braces around single line blocks
style: we don't use final for local variables
note: remove the logging?
Should we use the gridDialect variable here?
suggestion: new ForwardingGridDialect( gridDialect.gridDialect( gridDialect );
suggestion: new ForwardingGridDialect( gridDialect );
It doesn't clear why we don't use nested ifs. It doesn't make sense to merge these two nested try.
It doesn't clear why we don't use nested ifs. It doesn't make sense to merge them with the outer one.
It doesn't clear why we don't use nested ifs. It doesn't make sense to merge them with the other branch.
not sure sure there is a difference between a list name and a Nullable Long.
Why not just return typeDescriptor here?
not sure sure there is a difference between a list name and a Hexached.
Extra line
Should this be an AtomicReference?
> scope + start
Can you make this a synchronized method?
Can you make this a constant?
Can you make this a method in Util?
you could use method reference here instead of calling it several times. E.g. public boolean isHandleRenamed() { return oldFileRenamedFiles; }
Please use the method handleRenamedFiles() instead.
you could use method reference here instead of calling it twice for the same method.
In any event, since we're on Java7, just: new HashSet<>();
In any event, the user can see the inline Collections.unmodifiableSet() method of the set.
I don't see a reason to return an Iterable here instead of the more specific return type Set
I would use streams here
elements.stream().map(Element::getClass).collect(Collectors.toList());
elements.stream().map(Element::class).collect(Collectors.toList())
I am not sure if negation is the better. Why do we need to do a subtraction here?
I am not sure the negation is the better. Why do we need to do a subtraction here?
I am not sure if negation is the better. Why do we need this?
Name? Three more characters won't hurt. ;)
Name? ;)
Name it block? ;)
This does not need to be public.
I don't think we need to include the parent name.
This does not need to be public
if you call the vmBase.getId() instead of '==' please suggest replacing the condition with: if (hasEmoverDevices(spice.getId())) {... }
if you call the vmBase.getId() instead of '==' please suggest replacing the conditions with: VmDeviceDao.getVmDeviceByVmId(spice);
if you call the vmBase.getId() instead of '==' please suggest replacing the condition with: if (hasVds()) {... }
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this().removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2 :)
variable kind is redundant, should be removed.
I think the variable should be final.
I think the variable should be initialized at the end, a variable on a separate line.
activity.finish() can return null
activity.finish() can return null.
activity.finish() and then return the activity
Did you look at this? <LINK_0>
Why did you remove this?
You don't need to put this in a transaction, you can simply assert that the properties are not there
Looks like too many element names. Should we use!Objects.equals()?
Looks like a nice use of Guava's Objects.equal() to me.
Looks like too many element names. Should be a component.
Mapper should be created in constructor
Good to add this. I would like to say we need a blocker for this.
Good to add this.get() to the constructor
For consistency, change variable name to something more meaningful.
For consistency, change variable name to something like ExprType
For consistency, change the Rx constructor to use a LongExpr for consistency
We don't need this.
Might be better to make this protected instead of public
Might be great to make it explicit, but you don't use the protected method.
Please keep the indentation consistent.
This is a bit confusing. Please use configRestartabilityAllowValue instead.
This is a bit confusing. Please use configRestartabilityAllowValue, instead.
Access static fields directly, e.g. AbstractUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowUndertowActivity. This seems like a no-op.
Access static fields directly
Access
final
Integer.toString()?
final?
Pager builder can be replaced by Pager.single().
Pager builder can be replaced by Pager builder.single().
Pager builder can be replaced by Pager builder
You can have multiple nested ifs in one statement, due to break; after the other.
You can have multiple nested ifs in one statement, due to nested statements.
You can have this as a constant with a meaningful name like DEFAULT_PUSHING_CONNECTION
We could use the following syntax: return localCatalog.getClusters().get("clusterid")
We could use the following syntax: return getDrclusterid().getDrclusterid().get("clusterid")
Can you please use getDrclusterid() instead of localCatalog?
typically there is a [lambda](<LINK_0>,%20java.lang.Object))
typically there is a [lambda](<LINK_0> here which is up to you
typically there is a [lambda](<LINK_0> here.
It seems to me that we should have a create method to handle duplicates. Can't we just call this createServeReadTips(boolean)?
It seems to me that we should have a create method to handle duplicates. Can't we just call this createServeReadTips(boolean) in the same method?
It seems to me that we should have a create method to handle duplicates. Can't we just call this createServeReadTips(boolean) in here?
If the list of Strings is not fully qualified, this is superfluous.
If the list of Strings is not fully qualified, this should return null
If this is not a String, better use instanceof.
Please use <LINK_0> Also it's not formatted correctly. assertThat(condition) is the same as <LINK_1>
Please put this into a block of the test. it's hard to see what's happening.
Please use <LINK_0> Also it's not formatted correctly. assertThat(condition) is the same as the method.
This will NPE if bundles.getSymbolicName() == null, I think you should check that bundles.getSymbolicName()!= null
This will NPE if bundles.getSymbolicName() returns null, I would add a null check here and make sure that the equals(bundleSymbolicName) will return null
This is an unrelated change
Not sure if this will have to be done in sync with the next line. Thread.currentThread().interrupt();
nit: extract this into a method.
Not sure if this will have to be done in pollOperation
Consider to simplify this method to: return obj.get(name);
Consider to simplify this method to : return obj.get(name);
Access can be private?
253, why moving 5 here?
Arrange, but I like the PR. Remove these.
253, why moving this line?
Wow, that's a bug I think: if (instances!= null) { instances.put( slot ) ); }
This if-else block is redundand.
Wow, that's a bug I think.
Should use a constant for this.
This looks redundant.
Should use a constant for logging.
I think this code should be: java /** * Use TeraMath.run(float delta) instead of this. */ public void updateValue(float delta) { double newValue = new double(); }
I think this code should be: java /** * Use TeraMath.run(float delta) instead of this. */ private final double deltaValue(float delta) { double newValue = new double(); double delta = 0; for (float delta : oldValue) { if (newValue!= null) { ttl = new double(); } return updatedValue(getValue(), delta); }
I think this code should be: java /** * Use TeraMath.run(float delta) instead of this. */ private final double deltaValue(float delta) { double newValue = new double(); double delta = 0; for (float delta : oldValue) { if (newValue!= null) { ttl = new double(); } return newValue; }
I think the gson should be created before the constructor.
I think the gson should be created at the end of the constructor.
I think the gson should be created at the end of the method.
I think this if statement can be simplified to if (isPredefined) { eventService.subscribe( event -> event.getWorkspace().getId()); } else { LOG.error("Failed to cleanup workspace '{}': {}", workspaceId, ex); }
I think this if statement can be simplified to if (isPredefined) { eventService.subscribe( event -> event.getWorkspace().getId()); } else { LOG.error( event.getWorkspace().getId()); }
I think this if statement can be simplified to if (isPredefined) { eventService.subscribe( event -> event.getWorkspace().getId()); } else { LOG.error("Failed to cleanup workspace '{}': ", event.getWorkspace().getId()); }
What is this log statement for, exactly? Seems like a trace?
What is this logging statement for, exactly? Seems like a trace?
What is this log statement for? Seems like a trace?
I think it should be pass in the constructor of _chunkingKeys.
I think it should be pass in the constructor of _chunkingKeys. That way you don't need to pass Integer everywhere.
I think it should be pass in the constructor of _chunkingKeys. That way you don't need to pass Integer.
There's a lot of "SearchDto{" and "searchResultDbId=" that can be used.
There's a toString() method
Can the field be a String?
Can we just check that the customParams is not null?
Can we just check that the customParams is null?
Can we just check that the customParams is really an empty string?
I think this should be " ")");
I think we can just use builder.append("..separator")
I think we can just use builder.append(".."); without the StringBuilder.
While you're at it, you could drop the "reply" from the logging message, it's okay to remove that info since that is the default.
While you're at it, you could drop the "reply" from the logging message, it's okay to remove that info since that is the way to go.
While you're at it, you could drop the "reply" from the logging message, it's okay to remove FileHandler "and.
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
ewwww, abusing try/catch for this is really unideal... We have a Pattern for both the string and the value isn't a good idea.
ewwww, abusing try-with-resources would be a good idea.
Should we use UncheckedIOException here?
Should we not use defaultCharset() here as we are not returning an IOException?
Should we not use defaultCharset() here as well?
Reuse new SerializationServiceBuilder.
Nice cleanup
Nice cleanup!
Why do we use random chars here?
Why do we need new LinkedList here?
Why do we do this?
rename to implementInterfacesContext
rename to excludeInterfacesContext
rename to implementInterfaces
could you remove the getter, the setter should be one line above if parsedSources is not null (same for below)
could use getter for the parsedSources and getter if you are not required here
could you remove the getter, the setter should be one line above if parsedSources is not null?
(Firefox) can be private. We can add that code there, too.
We probably need that?
(Firefox) can be private.
shouldn't this be polling?
shouldn't this be debug level?
Does it make sense to have a info here?
This exception is not caught by another thread. Polling every single Mutation model is a bit too heavy for this class. I would keep it as it was.
This exception is not caught by another thread. Polling every one second on line 110 can be reduced to this.throwable = null;
This exception is not caught by another thread. Polling every one second?
Could you rename getBaseResponse to statusFlow
Could you use a switch statement here? It's a bit hard to read.
Could you rename this, to statusFlow.getSuccessTerminalState()? It's not intuitive when reading the response
Avoid the use of swtDefaults().align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.NONE);
Avoid the use of swtDefaults().align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.BEGINNING);
Avoid the use of swtDefaults().align(SWT.BEGINNING, SWT.BEGINNING).align(SWT.BEGINNING).align(SWT.BEGINNING, SWT.CENTER).align(SWT.BEGINNING, SWT.NONE);
Maybe we can move this code into some common function, so the code can be more readable.
Maybe we can move this line into below if (f.getWorkbench().setStop(true);
Maybe we can move this code into some common method?
Does it make sense to extract the MessageValues to the MessageValues?
Does it make sense to extract the MessageValues to the MessageValues constructor?
Does it make sense to extract the MessageValues to a variable?
Isn't this better handled by the write call to getObjectInserter() instead?
For the settings like in the other files, it's better to write headers to the write result instead.
Isn't this better handled by the write case above?
... is this 'public'?
...
... is this a BiMap?
return this.public?
Please keep this method public
Please keep this method public, but use the field directly.
This and line 59 can be a global variable to clean up tests a bit
This and line 59 can be a global variable to clean up tests a little bit
This and line 59 could be a global variable to clean up tests a bit
@dmzaytsev let's move this into a try-with-resources block and re-use it.
@dmzaytsev let's move this into a try-with-resources block and re-use it
@dmzaytsev let's move this into the try and get rid of baos and close()
As requested, I'm not sure we want this?
As requested, I'm not sure we want this anymore.
Better to use the empty string constant
Is the context object available by not being stored in the context?
Please revert this change.
Is the context object available by default?
I wonder if this is equivalent to: if (address == null ||!address.equals(this.address)) { messageChanged = address; }
I wonder if this is equivalent to: if (address == null ||!address.equals(this.address)) { messageChanged = address; }...
Needs a null check
Should make this private and have a constant for thePostgresToStart call
Should remove "Postgres"
Should remove "PostgresDB"
Could be: java return href.contains(imageName) || getImage().getAttribute("href");
Could return here, I think.
Could be: java return href.contains(imageName);
Why do you need this change?
Why do you need a new line?
Should you use a forEach on the interface?
I don't think this might be the right approach. I'd keep this method unchanged.
I don't think this might be the right approach. I'd keep this method synchronized.
I don't think this might be the right approach. I'd keep this method synchronized and move the createTempFile(...) to the constructor.
this is a bit of an odd pattern to put in the validateOutputFormatProvider itself, wouldn't it? If so, this could call that.
this is a bit of an odd pattern to put in the validateOutputFormatProvider itself, wouldn't it? If so, this could create a config map, then use the builder.
this is a bit of an odd pattern to put in the validateOutputFormatProvider itself, you could have this in the validate method also
is there a potential race condition here?
is there a reason we're getting the instance name here?
return the list.
this is not the same as the previous constructor of CassandraKeyValueServiceConfigManager.createSimpleManager(). It will be the PR, but I would just go with that one.
this is not the same as the previous constructor of CassandraKeyValueServiceConfigManager.createSimpleManager(). It will be the PR, but I would just go with this one.
this is not the same as the previous constructor of CassandraKeyValueServiceConfigManager.createSimpleManager(). It will be the PR, but I would just go with a new CassandraKeyValueServiceImpl in one place.
better to use protected
add to all the LivePortInfo instances
better to use protected access
Would be useful to have a meaningful name for the column names.
Would be useful to have a meaningful name for this column in the database, too.
Would be useful to have a meaningful name for this column in the database, instead of a hardcoded string?
These local variables can be final.
These asserts are not really needed.
I don't think this is correct.
should be done with constant
should be a constant
should be done with constant?
nit: we are doing this only for ConnectExceptions. if it does not have a RuntimeException?
nit: we are doing this only for ConnectExceptions. if it does not have a RuntimeException, we still want to throw an exception. However, we don't want to catch Throwables outside of the try{} block.
nit: we are doing this only for ConnectExceptions. if it does not have a RuntimeException, we still want to throw an exception. However, we don't want to keep the try{}catch... } block to rethrow the exception.
Should the repositoryIsRequired be in the delta instance? RevWalk internally creates an RevWalk instance, which can then be modified to this method.
Should the repositoryIsRequired be in the delta instance? RevWalk internally creates an RevWalk instance, so there's no need to do it again.
Should the repositoryIsRequired be in the delta instance? RevWalk internally creates an RevWalk instance, so there's no need to do it manually.
Could this be made static?
I have a look at the another way to do this, but I don't think there is a need to make the declaration outside the try.
I would have added a separate method for this, but just call the method directly when the errorId is already a String.
I think we should call isSupported() on that.
I think we should do.KeepAlive = true;?
I think we should do.KeepAlive = true; here.
ParameterSendTime has to be a constant for this.
Should this be one-liner?
inline this variable.
Please keep the style consistent with the rest of the codebase
Please keep the style consistent with the rest of the Statistics
Please keep the style consistent with the rest of the Statistics class
Could you rename this, to statusFlow
Could you rename this, to statusFlow.getSuccessTerminalState() (or is it possible to add some more specific error handling)
Could you rename this, to statusFlow.getSuccessTerminalState() (or is it possible to add some more specific error message)
I think we should keep this method private.
I think we should keep this method and make it private.
Can we keep this method private?
I don't know this code is affected by this change.
I don't know this code is part of this change because dirty variable is final and therefore can be final.
I don't know this code is part of this change because dirty variable is final and therefore it's false.
This code can be simplified to: java final String reviewer = Gerrit.isEmpty(); if (reviewer.isEmpty()) { String reviewer = Gerrit.getUserAccountInfo().name(); String tasker = Gerrit.getUserAccountInfo().name(); if (reviewer.isEmpty()) { mviewer.getUserAccountInfo().name(); }
This code can be simplified to: java final String reviewer = Gerrit.isEmpty(); if (reviewer.isEmpty()) { String reviewer = Gerrit.getUserAccountInfo().name(); String tasker = Gerrit.getUserAccountInfo().name(); if (reviewer.isEmpty()) { mviewer.getUserAccountInfo().name(); } }
(reviewer.isEmpty())
I don't think this will work for the cols. Could you use iterator?
I don't think this will work for the cols. Could you use visitSize()?
I don't think this will work for the cols. Could you use visitSize() to do this?
rPrec
use Prec
rPrec; should be leftPrec
It's more readable when part of deserializeValue
It's more readable when part of deserializeValue call is replaced with method call.
Same here. It's more readable when part of deserializeValue
@dilini is the order of fields in this class?
@amihaiemil could be move in init method since it's only used once
@amihaiemil could be move in init
Convention is to use mannually with hamcrest.
Convention is to use mannUtils.splitUserId for this.
Convention is to use mannually for this.
I think we should use the existing registries API before returning the event
Same as above, we should use the existing registries API.
I think we should use the existing registries as well
Wrong JSR number in validation provider.
+1 for this validation provider.
This validation provider still uses JSR-346 string.
Also requireNonNull that does not be null
Also requireNonNull that does not contain null
requireNonNull
Why not private static final boolean checkIfType(IDataChartDescriptor<?,?> desc) { final Descriptor INSTANCE = DescriptorTypeVisitor.checkIfType(DescriptorTypeVisitor.class); if (visitor) { return true; }
Why not private static final boolean checkIfType(IDataChartDescriptor<?,?> desc) { final Descriptor INSTANCE = DescriptorTypeVisitor.checkIfType(DescriptorTypeVisitor.class);... }
Why not private static final boolean checkIfType(IDataChartDescriptor<?,?> desc) { final Descriptor INSTANCE = new DescriptorManager();... }
Is it needed to return the list of users?
Is it necessary to return the list of users?
Is it necessary to return the list of users element as well?
My guess is that Java 8 has thenComparing() method, so there is no need to check these here.
My guess is that Java 8 has thenComparing() method, so there is no need to check position here.
My guess is that Java 8 has thenComparing() method, so there is no need to check for the state directly
This message does not seem right?
This message does not seem right.
This message does not match the current error message.
Wondering if this should be an error if the key contains not a TypeElement. Right?
Wondering if this should be an expensive operation. If the key is not an immutable, the hash code could be cached.
Wondering if this should be an expensive operation. If the key is not an immutable, the hash code could be cached. I'm not sure of the cleanest approach.
should be the default case
Collections.emptyList()
should be the type here
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I'm not sure if this is really necessary.
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I'm not sure if this is really needed.
Integer.MAX_VALUE?
s/tmp/name/
s/tmp/
printlns should be removed
super.handleData(event); could be the first check
super.handleData(event).
Should this not put the clientAwake information about clientStatusList? It looks like the clientStatusList will always be not set by the client.
Should we use containsKey()? It's not get in the map.
Should we use containsKey()? It's not get into the map.
I don't think values.isEmpty() is needed.
values.isEmpty()
values.isEmpty()?
Why we need to extract a method here?
Why we need to extract a method in the RefreshManager?
Why we need to add a method in the BaseCollectionManager?
I don't think we should modify the message to "strict"
I don't think we should modify the message as "strict"
I don't think we should modify the message a bit, it is better to have a descriptive message
Could use this::updateNextScheduleTime() instead.
Could use this::updateNextScheduleTime instead.
Could use this::updateNextScheduleTime() here.
same logging here as in perform next operation
same logging here and in perform next operation
same logging here, "Failed child command:"
An empty line is unnecessary.
My suggestion is to use a boolean primitive instead of a Boolean.
It is a bit weird to return themonitoring_content instead of the content.
Could you replace this with java final Files.write(Paths.getCOPEPlugin(), COPEPlugin.getLocalStorage());
Could you replace this with java StringBuilder builder = new StringBuilder(); Files.append(COPEPlugin.getLocalStorage()); //NON-NLS-1
Could you replace this with java final Files.write(Paths.getCOPEPlugin(), COPEPlugin.getLocalStorage());?
Separate getting the list and setting it to a class with the implementation
Separate getting the list and setting it to a class field so it's not repeated here.
Separate getting the list and returning the list.
We should be able to use the DeletePopupPresenter.showPrompt(getCurrentPath) method instead of duplicating the code.
We should be able to use the DeletePopupPresenter.showPrompt(getCurrentPath(), getCurrentVersionRecord()) method instead of duplicating the code.
We should be able to use the getStoragePath method here.
Should be logged before this call
Should be logged before start of the cursor.
Should be logged before start of the transaction
what do you think about changing this to use LedgerHandle.NO_LedgerHandle?
what do you think about changing this to checkLedgerHandle.this?
I don't think this is a good idea. Better use sync block, since we don't want to keep async
Why can't you just use defaultSystem.DEFAULTSystem here?
Why can't you just use defaultSystem.context instead of this.defaultSystem?
Why can't you just use defaultSystem.clear() here?
do we need the call to handleTransitionToStandby() here?
do we need the StandbyMode as well?
do we need the key-value for electors as well?
Are you sure that selectionToSelect will be null?
What if the currentSelectedElement is null?
Are you sure that selectionToSelect will be null here?
Why don't you just compare the values?
Why don't you just compare the string?
Why don't you just verify that the exposed flag?
technically more efficient :) for (int i = 0; i < cpuId; i++) { } return cpuId;
technically more efficient :) for (int i = 0; i < cpuId; i++) { } return cpuId; } return cpuId;
technically more efficient :) for (int i = 0; i < cpuId; ++i) { } return cpuId;
can we add isError = true to else statement here?
can you add if { return false; } to make it clearer
can you add if { return false; } to make it more explicit?
database shouldn't be closed.
database shouldn't be needed anymore.
database shouldn't be needed anymore?
Could you please extract some of this code into a method, such as: public static String text(final String text) { if (text!= null && text.text!= null) { return; } setText(text); }
Could you please extract some of this code into a method, such as: public static String text(final String text) { if (text!= null && text.text!= null) { return text; } // rest of the code
Could you please extract some of this code into a method, may be reused in other places. What do you think?
Can you log the exception, please.
Can you log the exception here?
Can you log the exception, please?
To make the client-side, we wouldn't need to create a new response object for each response, either to use 401 or not.
To make the client-side, we wouldn't need to create a new response object for each response, just use this endpoint and create a new one for each message.
To make the client-side, we wouldn't need to create a new response object for each response, just use this endpoint and create a new one for each response.
Can use Map.of()
Can use Map.of(...)
Can use the map.put(...)
return defaultVersion!= null &&!setDefaultVersion.equals(newDefaultVersion))
return defaultVersion!= null && this.defaultVersion.equals(newDefaultVersion)) || this.setDefaultVersion <= DEFAULT_UNKNOWN;
I think this method could be private
@lautarobock Here too, let's declare throws Exception.
@lautarobock Same here, let's declare throws Exception
@lautarobock Same here, let's declare throws Exception.
This listener can be removed and the register button is not enabled.
Set defaultCustomizations
move the listener call up
I don't think we need to modify the relation here, since getMRelations is only used in the next line.
I don't think we need to modify the relationAttrs field here. getMValid().
I don't think we need to modify the relationAttrs field here.
Missing {}
Maybe add a thrown exception in TradeInfo
Missing "tlement date".
I know this is just a legacy code, but I'd prefer if we use the DefaultClientMessageTracker directly for the DefaultClientMessageTracker.
I know this is just a legacy code, but I'd prefer if we use the public interfaces for both the declarations, like in AbstractClientMessageTracker.
I know this is just a legacy code, but I'd prefer if we use the DefaultClientMessageTracker directly and make the method private.
Should this be in the else branch?
Should this be in the button file?
Should this be in the else clause?
At this point you're actually calling the backend here.
At this point you're creating a list of Serveror server each time, but not the one we are dealing with the server.
At this point you're creating a list of Serverors that should contain the URL.
You can use the switch statement here rather than having the if else since you have it return.
You can use the log method of the equiv update if you need to then set it back to the result.
You can use the switch statement here
You are missing the null-check after the groupToSuperCategoryMap.put call.
You are missing the null-check after the if
You are missing the null-check after the groupToSuperCategoryMap.put method.
Let's fall back to the constructor.
Can be Log.v.
Let's make this final
toString()?
Shall we use the StringBuilder?
Shall we use the self-error message here.
We _could_ replace the toLowerCase with a char.
We _could_ replace the toLowerCase with a capital.
We _could_ replace the toLowerCase with a char..
Can you please put this one in a constant?
Can you please put this after the return above?
Can you please put this 2 lines above into a constant?
Better to use Boolean.TRUE.equals(nullableColumns).
Better to use Boolean.valueOf()
Same question as above
I'd suggest to return a Map as well, not an ArrayList.
I'd suggest to return a Map as well, not an ArrayList of componentChanges.
I'd suggest to return a Map as well, not an ArrayList of componentChanges. The key is in this map.
Same as above, we should use equalTo.
Same as above, we should use the null check and make sure that >1 call is unnecessary
Same as above, we should use the null check and make sure that >1 call is not null.
we should probably log the error instead of just printing the stacktrace
we should probably log the error instead of e.printStackTrace().
we should also check that the folder is disposed?
please verify that the amend function is actually executed
please verify that the disk is not attached to the image.
please verify that the disk is not attached to the created disk
keep both URLs in the same line
keep both URLs in constants
keep both URLs in constant
Can you put this in a constant so we can test both scenarios?
Can you put this in a constant so we can test both cases?
Can you put this in a constant?
Looks like there is no need to have an empty set from the given parameters.
Doesn't DroolsAbstractBiConstraintTree have isEmpty()? If not then there is no need to instantiate an empty PatternDSL, there is no need to instantiate a new one each time.
Doesn't DroolsAbstractBiConstraintTree have isEmpty()? If not, then there is no need to instantiate an empty PatternDSL, there is no need to instantiate a new one.
You can use ipAddress.getByAddress(key, 0).
You can use ipAddress.toStringUtf8()
Why do we need this method?
Something like this: lookupSourceProviderFuture.isDone() && lookupSourceProviderFuture.isDone()
Something like this: lookupSourceProviderFuture.isDone() && lookupSourceProvider was present
instead of spillInProgress, you could use lookupSourceProvider in try
s/foo/bar/
s/rules/foo/bar/
s/rules/foo/bar"
you can use the one stored in the entryset(exception)
you can use the one stored in the constant value
you can use the one stored in the entry
I think this is a good idea! I agree that it could be a problem, but I wonder if the reason for this change is to make the general PR and it is a good idea to have a fallback to the failing test.
I think this is a good idea! I agree that it could be a problem, but I wonder if the reason for this change is to make JmxConfiguratorImpl.start() and.server(jChannel) send.get()?
I think this is a good idea! I agree that it doesn't work as expected.
This needs to be Locale.translator.IN_INT_VALUE.
This needs to be Locale.translator.IN_INT_VALUE, as it's not safe and fail if it is null.
This needs to be Locale.translator.IN_INT_STRING.
wpLoginLogout_USER_USERNAME_ID
wpLoginLogout_USER_USERNAME_wpLoginLogout_USER_USERNAME = "wpLoginLogout"
wpLoginLogout_USER_USERNAME_wpLoginLogout_USER_USERNAME =>
Squash into one line? unregisterAndCloseRepository();
Make this into a for loop
Squash into one line please
Should we consider using a ConfigurationKeys.logger.isInfoEnabled() instead?
Should we only initialize this field in one place?
Should we return here?
please use this: <LINK_0>
Please use this: <LINK_0>
please use this: PermissionsFromForm(...)
Why do we need the getClassProperty here?
Why do we need a getClassProperty here?
Macro is supposed to be 'currentContext.getIdProperty()'
The synchronized block here doesn't make sense, since handler is a callback function, which does the same thing.
The synchronized block here doesn't make sense, since handler is only executed when the handler is not created, it's always the same as the callback.
The synchronized block here doesn't make sense, since handler is only executed when the handler is not created, it's always the same.
why do you use this.guid?
why do you use this.name()?
why do you use this.id?
please use assertFalse
you can use assertFalse
why not using assertFalse?
Simplify this to "getNewCommandCorrelationPLQRecords was created"
We should log this
We should log this properly too, or rename it to something like "create"
Do you think it's worthwhile to have a short circuit here?
Are you sure of the nanoTime here?
Do you think it's worthwhile to break this up a bit?
Can we make 1000 a constant, and maybe make it configurable via a system property? Similar to what we did on the other data views.
Can we make 1000 a constant, and maybe make it configurable?
Can we make the 1000 a constant, and maybe make it configurable?
I think there's the code in invoking the listeners with null.
I think there's the risk of making findbugs happy
I think there's the code in invoking the listeners with null. This could be implemented by calling setListeners(sharedListeners)
remove you set atmpdir <review.
remove this and use the actual logger instead.
remove this and use a local variable instead.
If you're just doing this, then I'd prefer to be using the enum for the IDs API.
If you're just doing this, then I'd prefer to be using the enum for the API rather than importing the specific entity like this.
If you're just doing this, then I'd prefer to be using the enum for the API rather than importing the specific ones.
This method is a same as updateVncTrackingModel(VNC_CLIENT_MODE)
This method is a same as updateVncTrackingModel(VNC_CLIENT_MODE, model.getConsoleModel()) and why do you need a new method for ovirt-engine?
This method is a same as updateVncTrackingModel(VNC_CLIENT_MODE, model.getConsoleModel()) and why do you need a new method for this?
Why is this method returning a boxed type?
Why is this returning a new set?
Please use "this" here
can we merge this if statement with the one above?
can we merge this if statement with nothing else?
can we only consider the values for all buffer.
Is it good to put this in the map? Seems like a better way?
Is it good to put this in the map? Seems like it should be before the map creation.
Is it good to put this in the map? Seems like it should be before the map has been loaded.
Is there a reason to get an instance of the listeners twice?
Is there a reason to get an instance of the listeners instead of using a map?
Is there a reason to get an unmodifiable list instead of a list?
Do you think we need sync control on all the map operations here?
Do we need sync control on all the map operations here?
Do you think we need sync control on all the map operations?
please remove the else
missing braces
please use brackets
Something is wrong here: why is this class using DaemonInfo? Seems like we need to make it static.
Something is wrong here. Shouldn't we make this method synchronized?
Something is wrong here: why is this class using DaemonInfo? Seems like we need to make this method package-private.
I don't think you need to check this here: if (localOwners.isEmpty()) { return parent.getOwners(); } else { final ProjectState parent = projectCache.get(project); if (localOwners) { parent = projectCache.get(project); } } return parent.getOwners();
I don't think you need to check this here: if (localOwners.isEmpty()) { return parent.getOwners(); } else { final ProjectState parent = projectCache.get(project); if (localOwners) { parent = projectCache.get(project); } return parent.getOwners(); }
I don't think you need to check here whether the project is valid or not.
I think that this check should no longer be needed.
I think that you want to check that the wrapper name is correct now.
I think that this check should no longer be needed. The check is missing.
Unnecessary whitespace.
Throw constants in airlift SizeOf.
Throw a warning.
Could lastCheckBox.equals(lastCheckBox.getText()) check if lastCheckBox is null?
could lastCheckBox.equals(lastCheckBox.getText()) check if lastCheckBox is null?
could lastCheckBox.equals(lastCheckBox.getText()) check if lastCheckBox is null, and then only check if lastCheckBox is null.
Similarly here, exec. should not be necessary.
Similarly here, exec. should not be needed.
exec....
Use the same style as the other ones.
Use the same message as the one above
Use the same style as the other connectors.
This is all the setter on queryHeader, should we make it private?
This is all the setter on queryHeader.
This is unnecessary
Please consider using Collections.singletonList.
Please consider using Collections.unmodifiableList(...) instead.
Please consider using Arrays.asList over the interface.
The tests in this class are not marked as @Test(expected=IllegalStateException.class) and /sgitattributes/subpath is guaranteed to be non-null at this point. Would you mind reverting this change?
The tests in this class are not marked as @Test, so let's have this line be removed.
The tests in this class are not marked as @Test, so let's use the @Test annotation here.
I don't think we can make this boolean. suggestion Statement sta = conn.createStatement();
I don't think we can make this boolean. final Statement sta = conn.createStatement();
is "CREATE TABLE" not "when conn.toString()?
Can you please use Guava's [Joiner](<LINK_0>.
Can you please separate this into two lines?
Can static import be avoided in this method
INTENT_TO_ADD. That's why I would change it to return INTENT_TO_ADD;
INTENT_TO_ADD?
INTENT_TO_ADD. And here, remove the first extra line
@vilchik-elena what if we reach this condition?
@vilchik-elena what if we reach the end of the visit?
@ivandalbosco CheckUtils.parent(JavaScriptTree) condition is a type of constant util.
Do you have the akvo java formatting profile setup? Usually it would auto format variable names to start with lowercase...
There's a.collect(Collectors.toList()) here you could do java List<String> values = ImmutableList.copyOf(Math.toIntExact(Sample.getStringCellValue()));
There's a.collect(Collectors.toList()) here you could do java List<String> values = ImmutableList.copyOf(Math.toIntExact(Sample.getName());
Can you please move the applicationHome property to ApplicationHome so it is used in other places?
Can you please move the applicationHome property to ApplicationHome or remove it from ConfigConstants?
Can you please move the applicationHome property to another constant?
Do we need to check twice since GENERAL_POOL can never be replaced?
Do we need to check twice since GENERAL_POOL can return a string?
Do we need to check twice or can this be null here?
Again, use IOUtils.
Probably we should use [IOUtils.toByteArray()](<LINK_0> here
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO.
Not sure we need to do this, we can either call startTs, or we can have a chance to rollback (and startTs after the transaction was created).
This line can be moved to after the catch block
Not sure we need to do this, we can either call startTs, or we can have a chance to rollback (and the transaction wouldn't be rollbacked).
suggestion ess.getLogger().log(Level.INFO, "errorCallingCommand");
No need to call this method, it's already called
suggestion ess.getLogger().isDebug();
Can we remove the copy?
Can we remove the copying?
Also remove the copy.
We could make a method from DocFormCommand protected and put this in a private method instead of in this class.
We could make a method from DocFormCommand protected and put this in a private method instead of direct testing so that we don't need to rely on them.
We could make a method from DocFormCommand protected and put this in a private method instead of direct testing so that we don't need to do the same thing.
Is there a reason you're creating this each time?
Is there a reason this constructor is public?
Is there a reason you're creating this every time?
I am thinking about doing this in the code and calling this from another thread. A lock is held by the locks, which won't be wrapped in a loop.
I am thinking about doing this in the code and calling this from another thread. A lock is held by the locks, which won't be allowed to override the UI thread.
I am thinking about doing this in the code and calling this from another thread. A lock is held by the caller.
you can use Arrays.asList
you can use a final List
you can use Arrays.asList()
Should be added to the LiteralText
Should be.getRegistry().getText().
Should be java this.literal.min
This probably should be a try-finally and have clients return null, in case this is null?
This probably should be a try-finally and have clients return null, in case this is in the request.
This probably should be a try-finally and have clients return null, in case this is in the response.
no need to check for null again...
the this.flags = FlagUtil.EMPTY_BIT_SET
the this.flags = getFlagSetOf(flags);?
I guess we want to keep this part of the previous PR, i.e., the spinner policy must be the same for the cameras
I guess we want to keep this part of the previous PR, i.e., the spinner policy must be the same for the cameras.
I guess we want to keep this part of the previous PR, i.e., the spinner policy should display the *item* in the same getAdapter(). <LINK_0>
This null check isn't necessary. The super method already checks if the label is null.
This null check isn't needed, because org.eclipse.eef.ui.internal.ui.api.ui.viewHelper.getLabel(String) will replace the second call to the method below.
This null check isn't needed, because org.eclipse.eef.ide.ui.internal.ui.api.ui.viewHelper.getLabel(String) will replace the whole method with that.
You can replace this with checksum = getChecksumType(checksumName); and then use checksum instead of checksum.
Shouldn't this be checksum = (ChecksumType.getChecksumType(checksumName))?
You can replace this with checksum = getChecksumType(checksumName);
@pynicolas Can we avoid code duplication?
@pynicolas Can you explain please use null check?
@pynicolas Can you explain please use Objects.equals?
Consider using && instead of if (!isColorTeamMatch())
Consider using == instead of.equals.
Consider using && instead of if (!isColorTeamMatch)
consider extract locating the Visualization.Factory into another method as it is used in getVisualizationInternal as well?
consider extract locating the Visualization.Factory into another method as it is used in getVisualizationInternal as well
consider extract locating the Visualization.Factory into another method as it is used in getVisualizationInternal as well.
nit: I normally use a Constant style nit on the same line as the getString() nui.
nit: I normally use a style-style style nit: R.string.or____
nit: I normally use a style-style style nit: java R.string.or____
looks like this property is not set here.
Would you mind ignoring the case where envValue could be null?
Would you mind ignoring the case where envValue= replaceAll would be enough?
Can we give this a longer name?
Use this.lossVariables in this context.
Use this
Consider throwing an exception instead, for example "public static final NotImplementedException offer(E e) { return this.public.NotImplementedException(); }
Consider throwing an exception instead, for example "public static final NotImplementedException offer(E e) { return this.public == NotImplementedException.class; }
Consider throwing an exception instead, for example "public static final NotImplementedException remove
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in Annotations.
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in branding.
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in branding.properties to point into this.
Move this to the previous line
Is this the job of that 'public static?
Move this to the previous line?
url should be part of the URL
url should be one of the url
url should be part of the url
is this line necessary?
is this line necessary? Looks like the 'ifcationCommand' method is not used in this case.
is this line necessary? Looks like the 'ifcationCommand' method is not used in this case?
Out of curiosity, what would res mean to be res? Is it possible to define an empty list and see if res is null?
Out of curiosity, what would res mean to be res? Is it possible to define an empty list and then simply return as a Collections.emptyList()?
Out of curiosity, what would res mean to be res? Is it possible to define an empty list and then simply return as a Collections.emptyList()? I don't see a need for a separate list here.
Can you move this to the end of method?
Can we do this as well?
Can you move this to the end of class method?
Why is the condition required? If ctx.statements() returns null, it should be splitted into several methods.
Why is the extra "this" needed?
Why is there a possible infinite loop here? If ctx.statements() returns null, it should not be null.
It appears that we can incorporate this logic better into CommandBase.endActionInTransactionScope() The finally block of that method is: if (TransactionSupport.current() == null) { try { getBackend().getId(); } catch (Exception e) { logException("Exception", e); } } else { compensate(); } The code can be improved, but this is not very readable.
It appears that we can incorporate this logic better into CommandBase.endActionInTransactionScope() The finally block of that method is: if (TransactionSupport.current() == null) { try { getBackend().getId(); } catch (Exception e) { logException("Exception", e); } } else { compensate(); } } The code can be improved, though.
It appears that we can incorporate this logic better into CommandBase.endActionInTransactionScope() The finally block of that method is: if (TransactionSupport.current() == null) { try { getBackend().getId(); } catch (Exception e) { logException("Exception", e); } } else { compensate(); } } The code can be improved, though
It would be good to have some kind of utility class for encoding set to use Misc.checkNotNull(outputTypes, ProduceWindowResults)
nit: better to use pageBuilder here
It would be good to have some kind of utility class for encoding set to null.
drop the toString - it would be easier for people to read <LINK_0>
drop the toString - not just the version.
drop the toString()
package private?
package-private instead?
redundant
Can use Arrays.setAll() if it's not required.
Can use Arrays.setAll() if you don't need to loop
Can use Arrays.setAll()
I wonder if it would be better to use the contextDataStrings.TYPE_AUTH_METHOD_FIELD_NAME here instead of the DEFAULT_AUTH_METHOD_FIELD_1.
I wonder if it would be better to use the contextDataStrings.TYPE_AUTH_METHOD_FIELD_1.
I wonder if it would be better to use the SessionManagementMethodHelper to load the  method in the context.
This isn't really necessary. In the next line, the forEachPixel method is called only once, and can be removed.
This isn't really necessary. In the next line the forEachPixel method is called only once, and it should be removed.
Why is this necessary?
The result of the call to accept-spans is the same as the set to span. It may be worth making a SortedSet to do this.
The result of the call to accept-spans is the same as the set to span. So you'd probably want to make the ThreadLocal to be synchronized.
Ahh, brevity
I think you should combine these two lines: logger.warn( logger.warn, ex);
I think you should combine these two lines: logger.warn( logger.warn(message, ex);
I think you should combine these two lines: logger.warn( logger.warn(message, ex));
minor: kBaseDataAccessor = getClusterMap();
Check not null? Done.
Check not null?
flying flag not set to true
flying flag not set
flying flag not set to 0
this method should be refactored to use the new attach(ServoListener).. rather here is is calling subscribe(ServoListener).. this method should be refactored to have a listen method.
should be refactored to call unattachServoListener(this); here (and in the other places)
this method should be refactored to use the new attach(ServoListener).. rather here is is calling subscribe to the proper Servo listener.
this whole method could be a oneLiner: return find(...)!= null
this whole method could be a oneLiner: return findVds().get(key);
this whole if
Use toIntExact
There is no need to extract this SocketConfig to a variable
There is no need to extract this SocketConfig to a local variable
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a time should solve this issue.
DateTimes will not always work here, as the maximum days in 10,000 years is within capacity
DateTimes is notdaysBetween
Use Integer.MAX_VALUE
Use Integer.copyOf for all these methods
Use final
I don't think this should be final
I don't think this should return void.
final
Using == for object comparison? :)
Using == for object comparison?
Why did you change this? I thought of removing the existing patient...
The same is here for that include("value") and Map result
I would rather do the same: java Query query = Query.query(Criteria.where("_id").is(key)); if (value!= null) { result.save(new Datastore(value, value); } if (value.exists() &&!value.is("value")) { result.save(new Datastore(value)); } return result; } and remove the need for the if statement.
The same is here for that include("value" + "value") and Map result
What is the benefit of returning "" instead of null?
What is the benefit of passing a value over here?
What is the benefit of returning empty values over empty strings?
This check should be done in the caller instead of in the http code. That's why I think we should handle this.
This check should be done in the caller instead of in the http code. That's why I was assuming the dataBytes is always greater than null.
This check should be done in the caller instead of in the http code. That's the reason why we introduced the lower branch now.
please replace with assertEquals - the message will be much clearer
please replace with assertEquals - it's more readable
Please replace assertEquals with assertEquals
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
I'm wondering why do you use RtForks instead of MkForks in MkForksTest tests. We should test MkForks instead
I'm wondering why do you use RtForks in MkForksTest tests. I think it is better to create MkForks instead
Please rebase the code style.
Please rebase the code style guidelines, use empty list.
Please use Java 8 stream convention for braces
I don't think we should do this here, but since it seems we'll be having two different things for the different app, and if we ever want to merge them, let's change CommCareApplication._().isConsumerApp() to take a long time (like adding a fallback, etc.).
I don't think we should do this here, but since it seems we'll be having two different things for the different app, and if we ever want to merge them, let's change CommCareApplication._().isConsumerApp() to take a long time (like adding the CommCareApplication._().isConsumerApp()) and have the logic for it.
I don't think we should do this here, but since it seems we'll be having two different things for the different app, and if we ever want to merge them, let's change CommCareApplication._().isConsumerApp() to take a long time (like adding the CommCareApplication._().isConsumerApp()) and probably the only thing that we'll be having to scroll all the way back to the initialize app
Yes, should probably use Option.Some_list() instead.
Don't need this assertion?
Yes, should probably use Option.SomeValueTest.SomeValueTest
Shouldn't the first exception be captured here?
Shouldn't the first exception be added?
Shouldn't the assert fail?
This is the same as premature optimization. Use a constant MASTER_ULKATION.
This is the same as the containerEditPart
This should be protected.
This has any performance impact as you're accessing the same connection twice in the same connection.
This can be package private for now.
This has any performance impact as you're accessing the same connection inside the closure object.
GroupedTopNBuilder.buildResult().hasNext()
.buildResult().hasNext()
GroupedTopNBuilder.buildResult().hasNext()?
Should we also check for null as well?
Should we check for null as well?
Should we also check for the name and width here?
This name and the class need to be updated.
This name and the class need not be changed.
This class doesn't have to be declared.
Too long. Let's replace this line with cfg.setClientMode(gridName);
Too long. Let's split "client" into separate methods.
Too long. Let's split "client" into two lines.
public
can you surround with synchronized?
public?
nit: we don't need this, and the function below this should bevoid highlightView(View view, HighlightDrawables[0].setColor(mainColor), true);
nit: we don't need this, and the function below this should bevoid highlightView(View view, String view, int mainColor)
nit: we don't need this, and the function below this should bevoid highlightView(View view, HighlightDrawables)
We can extract a private method delete(String s) and use this method in a single class
We can extract a method catch Exception(e) to avoid some wrapping of exceptions.
we can extract a private method delete(String s)
Consider moving this line to line 259
Consider moving this line to line 118.
Consider moving this line to line 118
so this will never be true? I wonder if we should wait for the cache to be Caffeine<String, Value<P>>?
so this will never be true? I think it's ok to have 5 minutes since the default time is Caffeine set by the cache.
so this will never be true? I wonder if we should wait for the cache to be Caffeine<String, Value>?
same here, better not have it in one line
same here, better use Objects.equal
same here, better not have it in localDir
Can we use createDefault feed() here?
Can we use createDefault feed" instead?
Can we use createDefault feeds instead?
Same here, if you don't provide a buffer that is expected to be used.
Same here, ByteBuffer buffer should be used rather than ByteBuffer.
Same here, ByteBuffer buffer should be used rather than copying.
Why the issue here? The test code does not specify anything.
Why the extra trim()?
Why the extra \n?
UnsupportedOperationException seems reasonable here.
UnsupportedOperationException seems a bit odd here.
UnsupportedOperationException seems a bit misleading.
I think it's more clear to have {this.input = OptimizeStatement.map(Arrays::stream).map(Arrays::asList).collect(toList()) ); return new OptimizeStatement(Collections.singletonList(mapper)); }
I think it's more clear to have {this.input = OptimizeStatement.map(Arrays::stream).map(Arrays::stream).map(Statement::get).map(Statement::get).collect(toList())); }
I think it's more clear to have { } around the body of the function body instead of calling OptimizeStatement.stream() here.
this can be optimized to return the value of getMessageContentBuilder.add(messageType);
this can be optimized to use getMessageContentBuilder.add(messageType)?
this can be optimized to return the value of getMessageContentBuilder().add(messageType);
Same here. If you are trying to make this an instance of TmfStatisticsNode, you could get rid of the cast here and in the other constructor
Same here. If you are trying to make this an instance of TmfStatisticsNode, you could get rid of the cast here and in the other constructor.
equals()
Correct me if I'm wrong, but I think we would be better off putting the whole method in a method getLocation(WebDriver driver) method, which is called inside a method.
Can't we pass in the task's path here?
Can you elaborate why we need this line? It's not really needed.
The check of part being moved to a method isTickable() which is supposed to be called after the real world is created. I suggest moving this check to a separate method and call it from here.
The check of part being moved to a method isTickable() which is supposed to be called after the real world is created. I suggest moving this check to a separate method
The check of instanceof checks is not needed anymore.
Remove?
Can we say '< -> '
Can we remove such code?
Could we have methods for this that return EventHandlerClientInstanceImpl instead of getInstanceService?
Could we have methods for this that return EventHandlerClientInstance instead of getInstanceService?
Could we have methods for this that return EventHandlerClientInstanceImpl instead of getInstanceService?
Why does this method need to be public?
Why not to use the getText method instead?
Why a null?
Have we tested this with AtsClientService.get().createChangeSets().get().createChangeSet("Update Found-In-Location", getRelation")?
We don't need to be using the same getArtifact() method.
We don't need to be using the return value here.
Shall we just use a constant instead of "timelog" here?
Shall we just use a constant instead of "submit-properties" it will be more robust to have a constant for the URL in this PR.
Shall we just use a constant instead of "submit-properties" it will be more robust to have a constant for the URL and pass the message.
@whikrishabh-997 I'd also use the constants for readability here
@whikrishabh-997 I'd also use the constants for the numbers, in order to be consistent.
@whikrishabh-997 I'd also use the constants for readability, since it's not a constant
Use faster methods, should not use data processors when possible.
Use faster methods, don't use data processors when possible.
Use faster methods, to use data processors when possible.
I think the message should be localized
Can you add an error message here?
Should be an error.
For the tests it's called twice. For the first time it's called twice. After the first four tests it's demonstrated it
For the tests it's called twice. For the first time it's called
For the tests it's easy to assert that the batch size is >= 2
Is this method really needed?
Is this method really required?
Is this method really needed? I think this should be nextYielder
If you're going to drop the this.. then you can drop the this.name = name;
If you're going to loop over the this.. then you can drop the this.name = name;
If you're going to loop over the this.. then you can drop the this..
Even though it's safe to do so, I would prefer to merge these two conditions into one.
Even though we don't really need it, I would prefer to merge these two conditions into one.
Even though it's better to merge these two conditions into one.
Can we have a test that verifies the fact that stats is empty?
Can we have a test that verifies the state is OPEN_FORM_CONNECTION?
Can we have a test that verifies the state is OPEN_FORM_CONNECTION and then test it?
You know what you want to do by using quarks from the trace to the base class, so you don't need to handle it.
You know what you want to do by using quarks from the trace to the base class, so you can expose it as a method. And even better, is there a point in doing this?
You know what you want to do by using quarks from the trace to the base class, so you can expose it as a method. And even better, is there a way to implement this?
since this persist is triggered by the maxRows config, would it make sense to persist the max batch size based on the max row count.
since this persist is triggered by the maxRows config, would it make sense to persist the max row count based on the max row count.
is this needed for the test?
Could you explain what this method does?
Could you explain what this method does, it reads from a single location of a dictionary?
IllegalArgumentException is unchecked
This can be done in the constructor.
This may cause a NPE, in Eclipse and while you're at it, why not use a java.util.Set() here?
This may cause a NPE, in Eclipse and while you're at it, why not use java.util.optional() instead?
Wow, this is impressive!
1000000000 is no need to put private
1000000000 is no need to put
Please use the following syntax: return entry.getCgetCrepoKey()!= null? entry.getCrepoKey() : getCrepoKey();
Please use the following syntax: return entry.getCrepoKey()!= null? entry.getCrepoKey() : getCrepoKey();
Please use the following syntax: return entry.getCgetCrepoKey()!= null? entry.getCrepoKey() : getCrepoKey()
The namespace should ideally be stored in the [Jdbc namespace](<LINK_0>
The namespace should have been stored in the configuration file.
The namespace should ideally be stored in the [Jdbc namespace](<LINK_0> method.
I think we should have an assert checking that the parameter is used for checking that it's not null before doing the compareAndSetMaxLong method.
I think we should have an assert checking that the parameter is used for checking that it's not null before doing the compareAndSetMaxLong check.
I think we should have an assert checking that the parameter is not null before doing that.
Since this is the same in other place, please put it into a local variable
Since this is the same in other place please consider extracting it into a method
Since this is the same in other place, shouldn't we be checking for rawSelection == null?
They probably run way less 998. Might be zk.('prog').n().client().execute().().().().().().().()..
They probably run way less 998. Might be zk.('prog').n().client().execute().().().().().().()..
They probably run way less 998. Might be zk.('prog').n().client().execute().().().().().()..
Can you make the method private?
Can you make the declaration of the parameter :... to avoid casting?
Can you make the declaration of this method final?
Similar
Isn't this an enum?
Isn't this an error?
I don't like this, maybe ConfigurableEnvironment?
I don't like this, maybe ConfigurableEnvironment would be clearer
I don't like this, maybe ConfigurableEnvironment would be better I think?
Remove the public modifier
Remove the public modifier from the interface.
Remove the public UserDTO setupUserFields
Use parent
Use assert in here
Use assert here.
I think it would be better to return sourceProcessingDetails here, instead of returning the Set<SourceProcessingDetails>.
I don't think it's a good idea to return the Set<SourceProcessingDetails> here, instead of returning the Set<SourceProcessingDetails>.
I don't think it's a good idea to return the Set<SourceProcessingDetails> here, instead of a set, it can be just return sourceProcessingDetails;
Is this helpful to have a test as a base class? After all, this will be covered by unit tests.
Is this helpful to have a test?
Is this helpful to have a test as a base class? After all, this would be much more useful...
Import?
space after if
Import or static
style nit: no braces around single line block
style nit: no braces around single line blocks
- Remove the unused method - there is no need for this local variable
This is redundant.
This method should be synchronized and not private.
This method should be left protected.
Does this need to be in Core?
Does this need to be instate? if so, don't we want to do it now?
Does this need to be instate? if so, don't we want to do it in another action?
How about "[{}] Control node {} was removed or forced down down down" instead?
Why equals?
Why are we checking here null?
Remove final.
Remove DoubleType local variable.
Remove DoubleType local variable
explicit real ref?
explicit real ref? Seems like I'd have expected a null check here.
explicit real ref? I'd rename it to entry
Is this line supposed to be here? If so, maybe we should add a call to assert in the log statement.
Is this line supposed to be here? If so, maybe we should add a call to assert that the buffer was filled before poll()
Is this line supposed to be executed after line 133?
Please use the context from the Command's class.
Please use the context's name.
Please use the context from a command.
you can remove this.
you should always use the bloom filter when this is not null.
you should always use the bloom filter when this is not null
Please implement equals and hashcode methods for debugging purposes.
Please implement equals and hashCode methods for debugging purposes.
Please implement equals instead of hashcode
Is there a case where you don't want to check key!= null?
Is there a case where id == null and a PatchSetOrBase?
Is there a case where this cannot be null?
You can write this as return GoalUtils.getGoal(BudgetGoal.class);
You can move this call to the super class so that it is used only once.
You can move this call to the super method.
This should not be changed.
We should not be computing this each time.
Accidental copy?
Why not just call the ADVENTURE here? That way you can save a lot of repeated code.
Why not just call the ADVENTURE here? That way you can save some lines by making a variable for the same purpose.
Why not just call the ADVENTURE here?
This doesn't need to be "restart."
This doesn't need to be "restart." as the read-only is used for the first time.
This doesn't need to be "restart." as the handler is used for the restart screen, only read and stop.
Don't swallow this
Don't swallow exceptions
Don't swallow exception
Please use the same message as in BackendAuditLogByIdParameters.
Please use the same message as in addExternalEventParameters()
Please use the same message as in BackendAuditLogByIdParameters.java
it's better to use the trait set instead of assert traitSet.
the return type can be >
it's better to use the trait set.
I think we don't need the schema registry here. The underlying schema registry relies on the CachedSchema registry, which can be used directly. And then we don't want to cache the schema registry's cache. The underlying schema registry never returns null (e.g. if the schema registry's key is dropped).
I think we don't need the schema registry here. The underlying schema registry relies on the CachedSchema registry, which can be used directly. And then we don't want to cache the schema registry's cache. The underlying schema registry's cache could then be lazily loaded, so we'll never return stale information.
I think we don't need the schema registry here. The underlying schema registry relies on the CachedSchema registry, which can be overridden by different consumers.
@pecko let's use the same name here as in other languages.
@pecko let's use the same name here as in other classes.
@pecko let's use the same name here also
I would suggest to keep this as TypeManagementPreferencePage = TypeManagementPreferencePage.getInstance().getPreferenceStore();
I would suggest to keep this as TypeManagementPreferencePage = TypeManagementPreferencePage.getDefault().getPreferenceStore();
Please remove this.
nitpick: use newTemplate<Template<Template>>
nitpick: use newTemplate<>
nitpick: use newTemplate<Template<TemplateTemplate>>
should it return null if queryStr is null?
should we return a Collections.emptyMap() here?
should we return a Collections.emptyList() here?
Should we extract this logic to a private method that takes a boolean to CommonImages.getImage so that callers don't have to worry about this?
Should we extract this logic to a private method that takes a boolean as parameter?
Should we extract this logic to a private method that takes a boolean to CommonImages.getImage to make sure that we don't have a reference to CommonImages.
I don't think this is correct. The code will need to be: public boolean isFreeze() { return isFreeze; }
I don't think this is correct. The code should be: public static boolean isFreeze() { return isFreeze; }
I don't think this is correct. The code will need to be: public static boolean isFreeze() { return isFreeze; }
I know this was just moved code, but I'm wondering if we shouldn't also be calling activityAnalytics.setDryRun(true) here. The same check in the if block above, but I'd be missing something here.
I know this was just moved code, but I'm wondering if we shouldn't also be calling activityAnalytics.setDryRun(true) here. The same check in the if block above, right?
I know this was just moved code, but I'm wondering if we shouldn't also be calling activityAnalytics.setDryRun(true) here. The same check in the if block above, but I think it'd be better to also add a check in place to make sure we're not missing something here.
negative logic
negative logic maybe?
negative check
Should we be able to put this line into the forEach block?
Should we be able to put this line into the if block?
Should we do the same thing here?
Shouldn't we use the old constructor only in this case?
Shouldn't these methods be public?
Shouldn't these methods be protected?
Cosmetic: Braces on new lines please.
probably better to use static import?
private static final
I'm not sure how there is a need to set config on the runtime config.
I'm not sure how there is a need to set config on every call.
I'm not sure how there is a need to set config on all extensions.
Is there any reason to add a null check?
Is there any reason to use a separate public method for all actions?
Is there any reason to use a separate protected method that can't be used?
Shouldn't this be TaskManagerDetailsHandler? The response can be gotten from the repository.
Shouldn't this be TaskManagerDetailsHandler? The response can be gotten from the instance itself.
Shouldn't this be TaskManagerDetailsHandler? The response is associated with a TestingUtils.getService?
getInstances is deprecated in a future version. Should this be public?
getInstances is deprecated in a future version. Should this be static?
getInstances is deprecated in favor of a lambda!
Why not use the Collections.synchronizedList(new ArrayList<SloccountProjectAction>());?
Why not use the Collections.synchronizedList(new ArrayList<II>());?
Why not use the Collections.synchronizedList(new ArrayList<>() here?
null -> size
null is not used
null check
Maybe it would be good to move this into a class-level function.
Maybe it would be good to put this check into a function that takes a Stream<YarnClient>. Then the class could then implement the interface itself.
Maybe it would be good to put this check into a function that takes a Stream<YarnClient>. Then the class can then implement the interface.
Do we need the String.valueOf() here?
Since the string is a String, we can use String.valueOf() here.
Do we need the String.valueOf() here? Since it will be called twice now.
Do we need a test for this?
Do we need a test where this is not a valid network type?
Do we need this?
What is the purpose of this change?
Does this need to be synchronized?
What is the purpose of this line?
Please keep the same changes here.
Please put this after the above changes.
Why this check?
Likewise..
Likewise.. I think if the value is null, the stop method can throw a NumberFormatException.
Likewise.. I think if the value is null, the error message can be removed.
Maybe.map(Map::toString)
Maybe better to use.map(Map::toString).map(Map::toString).collect(Collectors.joining(" "));
Maybe better to use.map(Map::toString).map(Map::toString).orElse(" ", " | ")
Shouldn't this make it so that it can be skipped?
can we make this a bit smarter so we don't do the cleanup?
can we make this a bit smarter so we don't do any cleanup in the Context?
If you"ll use generics you won't need this cast.
If you"ll use generics you won't need this line at all.
If you"ll use generics you won't need this line at all, please remove it from constructor
We should probably use the utility instead of in the abstract class.
We should probably use the utility instead of creating a new utility.
We should probably use the utility instead of creating a new instance.
Is this reachable? Seems like in your test mode, it is not an issue.
Is it possible to close the DAG before the worker is closed?
Is this reachable? Seems like in your test mode, it is not an error.
we should log this error, we can see if connection does not exist.
I don't think we should return true here. If the connection fails, we should return false.
we should log this error, we can see if connection does not exist
Can we add a check in the clientId to make sure that we don't overwrite it?
Can we add the page size in the message?
Can we add the DWServiceId table in the code?
This logic doesn't account for that observing messages
This logic is different. observers contains entities
This logic isn't accounted for observing messages
This could just be return interestClient!= null?
This could just be return interestClient!= null;
This could just be return interestClient.interestClient(true);
Why do we need this. here?
Why do we need this method?
Why do we need this?
The permit will set to be 0 here. <LINK_0>
The permit will be set to some default value in the future.
The permit will set to be 0. <LINK_0>
Instead of using the context class loader, use the class loader of the first aggregate factory provided.
Instead of using the context class loader, use the class loader of the first child class loader.
Use the context class loader of the first child class.
use equals() instead of ==
want to make this private, instead of public
nit: use equals()
Why do we need it here?
Why do we need it here? Is it possible to go up to the result of transform?
why do we need it here?
log?
remove unnecessary change?
rename to method?
Can't you replace this check with if ( conf.size() > 0) {?
I'd rather return false here.
I'd rather return boolean instead of Boolean.
instead of a hard coded host, why not use a CountDownLatch?
instead of a hard coded host, why not just use a CountDownLatch?
final?
We can simplify this common to java.map(SequenceFlow::getTargetConnection).filter(Objects::nonNull).mapToInt(SequenceFlow::getTargetConnection).subscribe(this::cast);
We can simplify this common to java.map(SequenceFlow::getTargetConnection).filter(Objects::nonNull).forEach(viewConnector -> {
We can simplify this common to java.map(SequenceFlow::getTargetConnection).filter(Objects::nonNull).mapToInt(SequenceFlow::getTargetConnection);
I think we should stick with error reporting here: suggestion LOG.warn("RocksDB will flush memtable.", arenaBlockSize);
I think we should stick with error reporting here: suggestion LOG.warn("RocksDB will flush memtable. If the RocksDB will flush memory, then arenaBlockSize {} arena block.", arenaBlockSize);
I think we should stick with error reporting here: suggestion LOG.warn("RocksDB will flush memtable. If the RocksDB will flush memory.", arenaBlockSize);
I think you want to log something if you don't want to know that the table is removed.
I think you want to log something if you don't want it to be logged, right?
I think you want to log something if you want to know what table was deleted.
Can we use logger here instead of e.printStackTrace?
Can we use Logger instead of printStackTrace?
Can we use logger here instead of e.printStackTrace()
The method doesn't need to be public.
The method is never used.
The code here is the same as the other one. In addition we should go to the builder as well.
Can be final
Can be simplified to return (public static final boolean isHeader)
Can be simplified to return (public static final String isHeader)
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
instead, start with bot.checkBox("SWT.READ_ONLY").select();
Instead, start with bot.checkBox("SWT.READ_ONLY").select("disabled")
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve it.
DateTimes will not always work... because of daylight savings time: <LINK_0> doing support to solve this issue.
My maths suggests int is sufficient here, as the maximum days in 10,000 years is within capacity
Why depend on DiscoveryServices and not require extended services to register specifically under that interface?
Why depend on all DiscoveryServices and not require extended services to register specifically under that interface?
Why depend on DiscoveryServices and not require extended discovery services?
Why are you checking the order type here? Shouldn't they be the order type?
Why are you checking the order type here?
Why are you checking the orderType?
Why not use assertThat?
Why not use lockToken instead?
Why not use lockToken instead of a map?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility method to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be nicer to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
I think we could use the existing Diamond Operator here m: <LINK_0>
I think we could use the existing Diamond Operator here: <LINK_0>
I think we can use the existing Diamond Operator here: <LINK_0>
I don't understand this. Isn't the "default" part of the interface?
I don't understand this change. Isn't this line always returning true?
I don't understand this change. Isn't this line always returning false?
More descriptive error message please
More descriptive error message please :)
More descriptive error message please.
Does this also work right? If so, it looks like this can be simplified to if (m instanceof Macro &&!block instanceof Macro) { if (block instanceof Macro &&!block instanceof Macro) { return true; } else if (block instanceof Macro) { return true; } else { return ret; }
Does this also work right? If so, it looks like this can be simplified to if (m instanceof Macro &&!block instanceof Macro) { if (block instanceof Macro &&!block instanceof Macro) { return true; } else if (block instanceof Macro) { return true; } else { return false; }
Does this also work right? If so, you can just use if (s!= null &&!block.equals(s.get(i)).
Better, but use logger.logExceptionAsWarning(...).
Better, but use logger.logExceptionAsWarning(...) instead.
Better, but use ex.getMessage() instead.
use MapperFactory.createTempDirectory()
use MapperFactory.create().
use MapperFactory.createTempDirectory().
Is this change intentional? It's not that important, but I would recommend to use Mockito here.
Just a nitpicking here: You could use this.protocol to keep the default values.
Is this change intentional?
@kavinkumarks Thanks for your contribution! Instead, let's better use String.format and avoid string concat
Hm, I don't think that's the best choice.
suggestion String resourceName = resource.toString();
LocalDate.now(LocalDate.toLocalDate())
This might fail if it isn't a string?
LocalDate.now(this.publicLocalDate);
Isn't it better to use appBuilderProvisioningLocation.getManagementContext() instead of "/hostMachineProvisioningLocation localhost".
Isn't it better to use appBuilderProvisioningLocation.getManagementContext() instead of "getManagementContext"?
Isn't it better to use appBuilderProvisioningLocation.getManagementContext() instead of "/hostMachineProvisioningLocation localhost"?
replace the if with checkIndex(toIndex)
replace with checkIndex(toIndex)
replace the if with checks
I would use BitBuffer.EMPTY_BITBUFFER here.
I would use BitBuffer.EMPTY_BITBUFFER here, given that the special case is not visible at all.
I would use 0 here, this is not a valid buffer, but it's not very useful.
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
object here can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
that can be null? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
{} I would write this as i > 0
{} block please
{}
Could we move the IOUtils.closeAllitDir into a method?
Could we move the BWC related stuff to the leu?
Could we move the BWC related stuff to the leu thing?
Formatting
Undo
Formatting issue
Maybe Menu.NONE is clearer?
I think this line is redundant.
Maybe Menu.NONE is a more logical name?
I think it would be simpler to just add the event name, and don't send it as sustainable (if there is only one item, we know).
I think it would be simpler to just add the event name, and don't send it as sustainable.
I think it would be simpler to just add the event name, and don't send it to an upsert
I wonder if it is better to pass the admin label here in getSystemAdmins()?
I wonder if it's better to pass the admin label here in getSystemAdmins()?
I wonder if it is better to pass the admin label here in getSystemAdmins().getValue()?
s/vmDevice/vmId, deviceType/vmId, deviceType, deviceType
s/vmDevice/vmId, deviceType, deviceType, deviceType
can we return null here?
Can you call super.onDestroy() here?
I don't think this should be call super.onDestroy();
I don't think this should be call super.onDestroy()
this is the same as service.getName().startsWith("eap"))
this is the same as service.getName().startsWith("eap");
this belongs in the service.
Do we need to have this on every test?
Do we need to have this on the next line? I think this line may not be necessary.
Do we need to copy the TXMode fields here?
Please add an error message: "Duplicate value of the local variable toDisplayInBraces"
Please add an error message: "The value of the local variable toDisplayInBraces"
Please add an error message.
Could we flip the order of these two lines into one?
Could we flip the order of the two variables here?
Could we flip the order of these two lines up to 24 instead?
I think we can move the declaration of the map outside the try block (by making it a separate method).
I think we can move the declaration of the e variable inside the try block.
I think we can move the declaration of the map outside the try block (by making it a getter) to reduce the overhead of creating the map.
I think you can get rid of this.
I think you can change this package scope.
I think you can change this.
Is it worth throwing a NPE instead of returning null?
Is it worth throwing a NPE instead of returning null? This could lead to NPEs in case this is null
Is this the case?
you are no longer calling isNotEmpty() can be null.
you are no longer grabbing the page from the test here.
you are no longer grabbing the field here, won't it be missing a check for empty list?
Best practice: make a defensive copy. suggestion return Scores.clone();
Best practice: make a defensive copy. suggestion return Collections.unmodifiableList(super.getScores(), newBuilder());
Best practice: make a defensive copy. suggestion return Collections.unmodifiableList(super.getScores());
Why not Resources.toString(resourceUrl, StandardCharsets.UTF_8)?
Why not Resources.toString(resourceUrl, Charsets.UTF_8)?
:ant: I am sure this should be in a finally block.
This is the right thing to do, but makes it hard to follow.
can we just return factory.getDataInterval() instead of create?
can we just return factory.createQueryRunner here instead of moveQueryRunner below?
This operator should be changed from a bitwise OR to a logical OR.
Why empty line?
Unnecessary change.
Is it really necessary to make thepercentageThresholdCheck constructor private? It's not visible in our internal implementation, but for symmetry, it would be better to keep the implementation simple.
Is it really necessary to make this empty?
Is it really necessary to make thepercentageThresholdCheck constructor private? It's not really clear which parameters are in this case, but for symmetry, it would be better to keep the implementation simple.
I'm not sure I like this. Why are you using a different cache for the OK search? Does this method return an empty set in a non-empty string? Or should we use an AtomicReference here?
I'm not sure I like this. Why are you removing the mediacache and adding it to the cache?
I'm not sure we should be using this.
Do we need this? All it does is assert that the message is equal
Do we need this? All it does is assert that the messages are equal
Do we need this? All it does is assert on the message is equal
@tarun0 why don't you use <LINK_0>
@tarun0 why don't you use <LINK_1>
why don't you use <LINK_0>
No need to check for the if condition here. If you have the request it is always going to be there, you may leave it as it is.
Same as above, just return the if statement.
No need for the if-statement
Wouldn't this be a good idea to create a constant for the 0 and 1 (because it's used in many places)?
Wouldn't this be a good idea to create a constant for the number of unique values?
Wouldn't this be a good idea to create a private constant for the 0 and 1 : values in it's not in an object?
I may suggest to make it private. Publication TTL isn't a static field.
I may suggest to make it private. Publication TTL isn't a singleton.
I may suggest to make it private. Publication AdminClient directly is a static method.
Why do we need this boolean? I know its a bit of a inclusive; but I see this boolean.
Is this the fix we need to do in the loop? I know this is a bit of a PR, but I think it might be worth renaming it to just _clear_.
Is this the fix we need to do in the loop? I know this is a bit of a PR, but I think it'd be good to keep the if statement synchronized.
Looks like this just declares a variable that's not used?
Looks like this just declares a new variable that's not used?
Looks like this line should be moved to the beginTask call.
Why not use assertNull and assertNotNull?
why not use assertNull and assertNotNull?
Why not use assertNotNull?
Can we use _name instead of _name?
Can we use _ instead of _?
Can we use _"notUDAF".
could you please change this to use the new name as well?
could be removed as well.
could you please change this to true by default?
Throw an exception since it's failing.
Throw a more specific exception.
Seems like a good idea to make it package private.
Shouldn't this say "slaves"?
Shouldn't this say "slaves" as well?
This should say "slaves"
Change to Map<Integer, Integer>
Change this to Map<Integer, Integer>
Change to Map<Integer, Integer> 1000)); = new ArrayList<>();
I think it would be better to throw something like: log.error("Static injection class IllegalStateException", e);
I think it would be better to throw an e or log the exception.
I think it would be better to throw an exception here.
Same as above, remove
Same as above, please use AssertJ
Same as above: print new ResourceQuery()
Seems like this call can be removed.
Why do we need the call to getRemainingBestMatchesToLimit()?
Why do we need the cast? Seems like we can just call getRemainingBestMatchesToLimit()
toString() is not needed
toString() is not required here, as this method will cause a NPE
toString() is not required here, as above.
I would prefer if you could use a method reference here: if (!subscription!= null) { Subscription subs.executeBlockingSphereClient(client).executeBlocking(); }
I would prefer if you could use a method reference here: if(subscription!= null) { Subscription subs.executeBlockingSphereClient(subscription) }
I would prefer if you could use a method reference here: if(subscription!= null) { Subscription subs.executeBlockingSphereClient(subscription); }
For me, you only add the attribute to the superclass in this class, right?
For me, you only add the attribute to the superclass in this class, right? You don't call tnoteRef twice.
For me, you only added the attribute of the class in the parent in the constructor, right?
Shouldn't these asserts be line-wrapped?
Shouldn't these asserts be the same?
load
It's always called with join(), so I wouldn't return CompletionStage here.
It's always called with join(), so I wouldn't return CompletionStages.join()
It's a bit unclear that we could share most of the existing test cases with removeFromStoresAndNotify().
New PR looks good now.
New PR looks like a typo.
New PR looks good.
clean up message
since this is a test and these are not reporting errors, please change to logger.info()
since this is a test and these are not reporting errors, please change to log.info()
No need for the? here.
No need for the surrounding if statement.
No need for the surrounding brackets (no break)
I don't think debug is enough here.
I don't think metrics should be set here.
I don't think debug is the right thing here.
The count(*) is the same as DISTINCT keyword, which is more expressive than >
The count(*) is the same as DISTINCT keyword, which is more expressive than >.
The count(*) should be > 1 since it seems to be the same as >.
Please remove System.out
Could you remove the System.out
Please remove this.
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
Since Date instances are mutable, a copy of endDate should be passed into getTime() method.
Since Date instances are mutable, a copy of endDate should be passed into getTime() -> endDate.getTime()
Can be replaced with CheckForNull
I believe that this map is unused now
Can be removed
unneeded check
unneeded instanceof check
unneeded check?
seems like we can have a class for this.
would be nice to have a message like "Invalid key type"
I would include the keyObject in the message, to help debugging in debugging
mPublishedSequenceNumber == 0
Boolean.valueOf()
Boolean.valueOf() is unnecessary.
Is this correct? AIUI the only thing that you're trying to test is that lineOffset is not 0 and lineOffset is always less than lineOffset.
Is this correct? I don't see any tests.
Is this correct? AIUI the only thing that you're trying to apply here is that you only apply to the value.
can be simplified as:.map(Object::toString)
can be simplified as:.stream().map(Object::toString)
can be just diamond new ArrayList<>();
You can change the scope of this method to: private static List<Filter> filters = filters.add(filterId);
You can change the scope of this method to: public static List<Filter> filters = filters.add(filterId);
You can change the scope of this file to filters.add(filterId).
Minor: might be easier to read?
Formatting
shouldIgnoreCase be null.
Should we be parsing in here?
Can you please add a validation that the value is valid?
Can you please add a validation that is not empty?
Maybe use message "Config job.name is missing"?
Maybe use message "Config job.getName()" instead of "Config job.name"?
Maybe use message "Config job.name()" instead of "Config job.getName()"?
Is this really needed? If not, perhaps we should use a State class to auto generate debug state?
Is this really needed? If not, perhaps we should have a State.State.OPEN constant, to make it final.
Is this really needed? If not, perhaps we should have a State.State.OPEN constant, if we are going to use a state change to one of those places.
this should be moved to the getService method
this should be moved to the base class
this should be public
assertFalse(...);
CrashReporter.storeUnhandledException might be better
assertFalse(...);?
Why does the default constructor return null? I'm not sure the right thing to do here - it's still needed when using the builder yet?
Why does the default constructor return null? I'm afraid the red flag is false here.
Why does the default constructor return null? I'm not sure the right thing to do here is to remove the Client so how to handle the null case.
This log message seems unnecessary, we can call onShutdown()
You may want to move this log into beforeCompleted?
This log message seems unnecessary, we can call onShutdownRequest()
should be key equals to hashcode unless key is not allowed
should be value 'key'
should be method 'getAnonymousUserFactory()'.
You have to do it just once before returning true. Either you would do the check here or remove the condition.
You have to do it just one case
You could just do nothing when initializing the ShellIsAvailable
needs to be explicit on the web side, not on the computer.
needs to be explicit
needs to be explicit on the web side, not on the computer().
Are you sure about that? I think we should be doing the tenant check here and make sure that we're using SecurityContextHolder. I'm not sure if this is the case.
Are you sure about that? I think we should be doing the tenant check here. If not, it should be moved to the service.
Are you sure about that? I think we should be doing the tenant check here and make sure that we're using SecurityContextHolder. I'm not sure if this is a case.
mIsValid field is redundant
mIsValid variable is redundant
mIsValid variable is redundant here
If we don't care about the implementation of this method, I think we can just return new AuthorizationGroupBean().addNewAuthorization().getRule()
If we have a new AuthorizationGroupBean().getRule() then this method can be modified to fix the API.
If we have a new AuthorizationGroupBean().getRule() then this method can be modified to fix the issue
This should be if(log.isDebugEnabled()) { throw new IllegalStateException("Cannot set logging level without a configuration in " + level); }
This should be if(log.isDebugEnabled()) { throw new IllegalStateException("Cannot set logging level without a configuration including level in the level."); }
This should be: if(level!= null) { throw new IllegalStateException("Cannot set logging level without a configuration including level in the metadata."); }
Wouldn't this be the first time after the constructor above?
Wouldn't this be the first time after the constructor?
Wouldn't this be easier with the old version?
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
this "creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating a new array here
This should be done with DiskListModel
why not checking isRunning()?
This change should be made also for ListModel
I think it's better to keep this function in a static way
I think it's better to keep this method public.
I think it's better to throw an exception and not return null.
ToStringBuilder?
java return actors.isEmpty()?
java return the List?
...this should be colegator.createSubject(sd);
leg(sd): should use the variable name
legator is not a constant
Could you please change this to use System.out.println()
Could you please change this to if (cfg.isHistoryEnabled())?
Could you please change this to use System.out.println for the tests?
Why should it return false here?
I think it's better to add a break; after the "if" statement.
Why should we not make it return!isThisPart(partRef)
Nit: You can use [Nullable Long](<LINK_0>
This line can be combined to the previous line.
Nit: I think we don't need to log the REPO_NAME here?
You can use the builder directly here.
You don't need the builder here anymore.
You don't need the copy here either.
Are you sure that this should be 0.0.0.0 rather than null?
Should this be wrapped with parenthesis?
extract constants
can you please put these statement in curly braces and on a new line?
can you please put these kind of checks in curly braces and on a new line?
can you please put these statement into curly braces and on a new line?
Shouldn't this use the collapse else?
Shouldn't this use the CheckForNull?
else return isTemporError?
suggestion if (privateFeedData()!= null) {
suggestion if (privateFeedData(MediaFeedData data)) {
suggestion if (privateFeedData == null) {
Let's not use public HiveStorageFormat getHiveStorageFormat(ConnectorSession session)
This is not the only place this method is used. If the HiveStorageFormat is non-static, it will fail silently.
Let's not use public HiveStorageFormat getHiveStorageFormat() method, instead of public. HiveStorageFormat is very specific.
What's the purpose of this change?
I don't see any reason to change this method from protected to public.
Do we need the lock here?
move this to a constant
move this to a constant?
make this a constant?
else is redundant here
else is redundant
else if
Looks like this bug fix is in a separate PR.
Looks like this line needs to be in a else block
Looks like this line needs to be in a new line.
nitpicking: move all the SOME_RESOURCE_NAME here.
nitpicking: move all the SOME_ prefix to constant SOME_RESOURCE_PATH
nitpicking: move all the SOME_ prefix to a constant SOME_KEY/response
should this be the last segment of the buffer instead of the buffer?
should this be the last segment of the buffer, not the offset?
should this be the last segment of the buffer, not the buffer?
Is this worth having a null check?
I think this can be replaced by a call to this.queryList.setIsLastPage(queryList);
I think this can be replaced by a simple this.queryList = queryList.copyOf(queryList);
You could remove "lvs" from this variable
You could remove "lvs" from this variable description.
You can remove "lvs" from this variable
@gilleycro :may be this should be val.get(val) instead of val.get(val)
@gilleycro :may you mind adding a'recovery' as a constant?
@gilleycro :may be this should be val.get(val) instead of val
This is busy, but I guess it would be better to put it in the test case instead.
This is busy, but I guess it would be better to put it in the test class instead.
This is busy, but I guess it's better to line wrap the test in a util method in this class.
Isn't EMPTY for an empty string?
Isn't EMPTY for an empty string better?
Don't catch Exception.
Unused variable
Unused variable, you could use it here.
Missing final
What if there are multiple host parameters?
What if there are multiple host references?
What if there are multiple host calls to this portGroupSpecs?
We should have a unit test for this method.
Perhaps you could use the unit test for this method?
We should use the unit test for this method.
Unnecessary I think.
Maybe I don't think we need this log line. Same for the other one.
Why do we have this log line? I think that it would be better if we leave it info.
Consider this as aBooleanField.TRUE.equals(ObjectWithBooleanField.class) for consistency.
I can say that it should be Boolean.TRUE.equals(Object.class)
Consider this as aBooleanField.TRUE.equals(ObjectWithBooleanField.class) - hashCode may be null.
Generic Operations aren't used. Please use the new OperationsBuilder().
Generic Operations aren't used.
Generic type?
Let's use a ElasticsearchContainer here.
Let's use a ElasticsearchContainerBuilder here. It's not big deal.
Let's use a ElasticsearchContainerBuilder here.
put this out to a logger?
put this out in a finally block.
put this out in a finally block?
needs 2  also.
needs 2
needs 2 _arguments_
Is this not a regular exception or an error?
TargetEditor_3
Can this return null?
This is not correct. assertNull(e.g. assertNotNull(e.getName(), "Project ID: " + category);
This is not correct. assertNull(e.g., "Project ID: " + category);
This is not really correct. assertNull(e.g., "Project ID should not be null");
Consider switching the drainExecutor to a ReentrantLock and use it here. <LINK_0>
Consider switching the drainExecutor to use a ReentrantLock instead of synchronized block: <LINK_0>
Consider switching the drainExecutor to a ReentrantLock and use it here.
HarmonizationDataset is not used anymore
HarmonizationDataset is not used anymore.
You should use HarmonizationDataset here instead
You should fire the thread if you are not running the current thread
You can't directly compare to "true". I also prefer using Double.TRUE.equals(r.get()) where you are using Boolean.TRUE.equals(r)
You can't directly compare to "r"
I'm not sure if this is a good idea. In fact, I'd add a default port to the host name, and it would be helpful to add another configuration setting that is in the future.
I'm not sure if this is a good idea. In fact, I'd add a default port to the host name, and it would be helpful to know which host it is.
I'm not sure if this is a good idea. In fact, I'd add a default port to the host name, and it would be helpful to add another configuration setting that is in the configuration file.
We could bail out earlier by changing the order of the action and moving the logic to ClientProperty.
We could bail out earlier by changing the order of the action and moving the logic to a different method
We could bail out earlier by changing the getWebClientProperties() method?
To be consistent I would use: ReviewedCheckBox.add(reviewedCheckBox.getValue()); reviewedCheckBox.add(reviewedCheckBox.getValue()); reviewedCheckBox.add(reviewedCheckBox);
To be consistent I would use: ReviewedCheckBox.add(reviewedCheckBox.getValue()); reviewedCheckBox.add(reviewedCheckBox);
To be consistent I would use: ReviewedCheckBox.add(reviewedCheckBox.getValue()); reviewedCheckBox.add(reviewedCheckBox.getValue()); I think it is a bit better to read.
use string constant here
use string constant instead of ""
use string constant instead of int.
It would be good to have unit tests for both to test the new condition.
It would be good to have unit tests for both to test the new condition and test both.
It would be good to mix.
Consumer.ofLastOpComplete(cb);
Consumer.ofLastOpComplete(cb)
Consumer.empty().
Should we please add curly braces here?
Should probably be collapsed into Collections.reverse().
Collections.reverse()?
Seems like this and the one below could be removed
Seems like this and the above can be moved to the right below the check.
Seems like this and the above can be moved to the just below the check.
This should be annotated with @Nullable
Please annotate with @Nullable.
This should be a static method.
Create a separate defaultToWorkspace() method that doesn't need to be repeated
Create a separate defaultToWorkspace() method that doesn't need to be used here.
Create a separate defaultToWorkspace method for this if you're setting it to null.
The executor service should be initialized to this class, also you don't need to make sure it's used in the base class.
Actually, I think it would be good to move this stuff to the base class, like it's done in the lzService class.
The executor service should be initialized to this class, also these changes are not needed.
What if it's absent? In my account it may be absent, for example
What if it's absent? In my account it may be absent, as it's not used.
What if it's not used? In my account it may be absent, as it may be absent, for example
better to wrap with a null check.
Add a null check on mBannerSpot, too.
Add a null check on mBannerSpot, too
This makes a bit easier to read.
This is confusing, I'd use getAxiss() and getName()
This is confusing, I'd use getBru to get this
should this be more strict? i.e. require at least one character inside the parens?
should this be more strict? i.e. require at least one character inside the paren. i.e. require at least one character inside the paren.
not sure what this does. i.e. require at least one character inside the parens?
Nit: What about using Integer#valueOf instead of -1?
Nit: What about using Integer#valueOf instead of 0?
Nit: no need for the else here
Can you also capture stats on the hit ratio, load them as well?
Can you explain a bit more here?
Can you also capture stats on the hit ratio?
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces here
Would this be Eureka.setEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEureka
Would this be Eureka.setEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaClient
Would this be Eureka.setEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaEurekaClient with
You can keep this method package private, so I think it needs to be changed.
You can keep this method package private, so I think it's not necessary.
This Method really needs to be changed.
Make this a final field
Make this a final field - it's used only once.
Make this a final variable.
No need for null check.
No need for null check. The usage of the analyzer method would be the analyzer if no analyzer is provided.
No need for null check. The usage of the analyzer method would be the analyzer if the user didn't specify the analyzer definitions.
You can use getClass().getSimpleName() to do this: java if (optDimensionType!= null) { return Optional.empty(); }
You can use DimensionManager.getInstance().getJavaType(Object.class) to take a java type.
You can use getClass().getSimpleName() to simplify this code.
I think this should be: return (excludee == null? null : excludee;
I think this should be: return (excludee == null? null : excludee)?
We should have this method findChildren() or is there a reason to go there?
Why is this required?
Why is this required? I think it's not generic
Why is this required?
lets remove this if
please add braces for these if statements
please add braces
This is a public method. I could have a quick look here: <LINK_0>
This is a public method. I could have a quick PR to simplify it
This should be public
Iterator<Chain> iterator = Iterators.iterator(); while (iterator.hasNext()) { iterator.next(); } }
Iterator<Chain> iterator()
Iterator?
Better in the first place when a value is null.
Better: do not use a null value if the value is null.
Better: do not use a null value if the value is null, e.g. calling getValue()
assertThat(e.getMessage(), containsString("out of range occurs")); is a better check that it's the exception message?
assertThat(e.getMessage(), containsString("out of "+nonIntegerValue+": "+e);
assertThat(e.getMessage(), containsString("out of range occurs")); is a better check that it's the exception message.
suggestion this.public TestElasticsearchNodeFactory.getTables(() -> createElasticsearchNode(EmbeddedElasticsearchNode, TpchJoinNode, TpchJoin));
delegate to the super constructor.
delegate to the constructor.
I think this should be the AbstractPageView.refresh() method
I think this should be the super.refresh() call.
I think this should be the AbstractPageView.refresh() call.
The "connection" field will be null.
The "connection" field will be either null or empty.
Let's remove this check, it's not necessary to have the reconnect.
Why not move these to the top of the class?
Why not move these 2 lines above to the top of the class?
Why not move these to the top of the class and use the Utils.validate(..) method?
please decrease log level to trace or better remove statement
please decrease or remove this statement
please decrease log level to DEBUG
Since you have to print it out, we should probably use SiteUtils.out.println.
Since you have to print it out, we should probably use SiteUtils.out here.
Since we have to print it out, we should probably use SiteUtils.out.println.
I would rather create a new method getOutgoingRepository() which does the same thing and should be used here.
I would rather create a new field with this getter.
I would rather create a new method getOutgoingRepository() to perform this exact same code.
It's better to give a hint what this can be.
Use final
Use final variable for the throws clause.
Agreed with RSPEC, that's not the intention.
Agreed with I see. I don't think we can do this here.
Agreed with I see. I don't think we need to change this.
Thanks, I'm not sure this can be simplified.
Thanks, I'm not sure this pattern is good.
Thanks, I'm not sure this "if" is really necessary.
nit: could you please remove this line and use a logger?
nit: could you please use a variable and assert for the name?
nit: could you please remove this line and use a message in the fail() call?
You can use a try-with-resources block here.
You can probably use Files.newInputStream() here instead of keyStore.
you can use a try-with-resources block here.
I think that the receivingTask is thread-safe and so it should be maxceivingTask.cancel(true)
I think that the receivingTask is thread-safe and so it should be maxceivingTask.dispose().
I think you should call receivingTask.cancel(true) here instead.
This isn't the listener I was worried about. The entityChangedEvent is called after the user has selected the disk content update. Wouldn't it be easier to keep the event listeners as part of the event listener?
This isn't the listener I was worried about. The entityChangedEvent is called after the user has selected the disk content update. Wouldn't it be easier to keep the event listeners as part of the event listeners?
This isn't the listener I was worried about. The entityChangedEvent is called after the user has selected the disk content update. Wouldn't it be easier to keep the event listeners in the main thread?
Similarly here, you may be able to use a mock: java.first(() -> b.getTotalSize()).containsExactly(1, 2, 3);
Similarly here, Arrays.asList(1, 1, 1)
Similarly here, you may be able to use a pair of strings instead of a pair
Can you use an assert, or add a return statement?
Maybe we should add an assertion?
Can you use an assert, or add a return value to the method?
Use try-with-resources so you don't need to manually close the session.
Use try-with-resources so you don't have to manually close the session.
Use try-with-resources so you don't need to manually close the connection.
What is the reason for this change?
what is the reason for this change?
What is the reason for this change? I think it is a mistake.
Nit: Can we have this config in the exception message for debugging purposes?
Nit: Can we please use String.split() here and above?
Nit: Can we have this config in the exception message for easier debugging?
Shall we add a constant in the message to conform to the log message?
Shall we use warn here?
Shall we add a constant in the message to conform to the other error messages?
Missing <.
Missing <>, this is wrong.
Missing final.
Add this logic to the VmHelper.runPageNumer().
Add this logic to the VmHelper.runPageNumer() method
Add this logic to the VmHelper.runPageNumer() method?
Why the change from getControl() to getViewer().getControl().
Why the cast?
Why the change?
Can be simplified to just return getfboManager(Subscribers.size());
Can be simplified to just return get();
Can be simplified to just return get().
Could you rephrase this line to something like: questions.get(r).isExistingResponse();
Could you rephrase this line to: java questions.get(isExistingResponse); return true;
Could you rephrase this line to: java questions.get(isExistingResponse);
We need to get a new context here
We need to get a new Context here
We need to get a new StructuredSelection for each question
Is this going to be decl = decl.jjtGet();?
Is this going to be decl = decl.jjtGetNumChildren() - 1?
Is this going to be decl = decl.jjtGetNumChildren();?
Is it OK to have a MongoCodeList entry instead?
Is it OK to go from this sponge?
Is it OK to go that this constant somewhere?
Please use this.logger.warn("[\n]+"")
Please use this.lastIndexOf instead of first.
Use firstNonNull.
I don't think "refs/for/master" is the default. It's not clear what the ref is.
I don't think "refs/for/master" is the correct name. It's not a real name.
I don't think "refs/for/master" is the default. It's not clear what the ref is about.
super() is usually called from other constructor.
super(eventBus, view, "clq");
super() -> super()
Only the 2s in this file should be changed.
Only the 2s above should be changed.
Only the 2s is necessary and the variable name is changed.
What if the storage domain was inactive and you moved it to maintenance and failed.
What if the storage pool was inactive and you moved it to maintenance and failed.
What if the storage pool is inactive and you moved it to maintenance and failed.
> We don't need to sitate the! if we're going to generate the same line. Yes, yes, I can see that. Otherwise, we're going to generate a way to remove this condition.
> We don't need to sitate the! if we're going to generate the same line. Yes, yes, I can see that. Otherwise, you just copy paste in the code, but now I can see that.
> what?
Instead of an empty list, you could use Collections.emptyList() to check the returned list.
Instead of an empty list, you could just check for snapshots.isEmpty() and return false.
Instead of an empty list, you could use Collections.emptyList() to check that snapshots.isEmpty()
Objects::nonNull instead of a -> a!= null
Objects::nonNull instead of a -> a
I would rather return the result of getUserRole()
possible NPE
possible NPE in the constructor
possible NPE?
This sounds pretty dev-like. Shouldn't we include the 'get' in the exception message?
This sounds pretty dev-like. Shouldn't we include a 'get' method?
This sounds pretty dev-like. Shouldn't it be easy to derive this from the Technical interface?
rename to something like selectParameterSize
rename to something more specific to that
rename to select
this should return null
this should return a constant
this should return a int
can you make sure that the size is of the list?
can be replaced with return getSelectedSpecs()
Can you make sure that the size is of the list?
In what way is this necessary? This is a lot of if-else.
In what way is this necessary? This is a little verbose. There are other places
In what way is this necessary? This is a little verbose.
In this case I think it would be better to keep the driverPool.instantiate.remove(new Driver()) and reuse it in the other constructor.
In this case I think it would be better to keep the driverPool.instantiate.
What do you think about a synchronize on driverPool to avoid a race condition?
Can we add a null check on messageHolder.getMessage()
Can we add an assertion on messageHolder.getMessage()
Can we add a meaningful message
Long.MIN_VALUE and Long.MAX_VALUE may work better!
Long.MIN_VALUE and Long.MAX_VALUE may work better?
Long.MIN_VALUE and Long.MAX_VALUE may work better for these two, since they may use the min/max value.
Is it possible to get the position from the tabs file?
Is it possible to get the position from the tabs file, not the text?
Is there a reason that we are using tabs?
shouldn't the message be "APIID cannot be found"?
shouldn't the message be "APIID"?
Avoid the use of assertTrue.
I would use a different path than the previous line. Here you're getting the CountInputStream from the previous line. So, what do you think?
I would use a different path than the previous line. Here you're getting the CountInputStream from the previous line. So, what do you think about adding a new method like for the body? java Iterator<ObjectNode> map = new Iterator<>(); map.put(csvSource, value);.withHeader(csvSource); return new CsvSchema(csvSource, options);
I would use a different path than the previous line. Here you're getting the CountInputStream from the previous line. So, what do you think about this approach?
Add Pagelogging
Add 'driver' parameter
Add'into factory method
return new ArrayList<>( container);
return container;
return new ArrayList<>(this.container);
Could you move this to the top?
Would be good to move this to a css class.
Would be good to move this to a constant in Context.
It might be worth creating a new DAO method for this given statement.
It might be worth creating a new DAO method to prevent code duplication from these changes.
It would be good to check the returned value as well.
Do we need this else check if the return value of this method is duplicated?
Do we need this else check if the return is a composite project?
Do we need this else check if the return value of this method is a composite operation?
I think this should be guarded by a isDebugEnabled check.
I don't think this is the best effort to build the XML in the exception message. We will need to add that one to the list of messages.
I don't think this is the best effort to build the XML in the message. We will need to set the configuration back to what is needed to do.
Make this package private and remove the public modifier
Make this public and the other two package private
checkNotNull
while we're at it, could use.map(UserCreatableMetacardTypes::getAvailableTypes)
Use.flatMap(Collection::stream)
while Actually, I think this code would be simpler if you used a method reference.
Since getProjectSet() returns an instance of Config, we need to do this in one line.
Since getProjectSet() returns an instance of Config, you can call Config.class.getName() instead.
Since getProjectSet() returns an instance of Config, you can call the ConfigServiceImpl.class. Config that needs to be converted to the base class loader.
Can be empty.
Please use assertThrows()
Please use assertThrows here.
Shouldn't this be wrapped in a try... finally block?
Shouldn't this be wrapped in try... finally block?
Shouldn't this be wrapped in a finally block?
Access static fields directly, e.g. AbstractUndertowSubsystemTestCase.INSTANCE.
Access static fields directly, e.g. AbstractUndertowSubsystemTestCase.INSTANCE
Access static fields directly, e.g. AbstractUndertowSubsystemTestCase. The class is removed from the test.
Maybe it should be this: return stop()?
Maybe it should be this.public.Nullable?
Maybe it should be this: return stop()
Is this required? It seems identical.
Is this required? It seems like the first time you switch the file, there is already a.forEach loop.
Where is this used?
suggestion LOGGER.debug(" jmxAttribute jmxAttribute: {}", rank);
suggestion LOGGER.debug(" jmxAttribute jmxAttribute:", " + rank);
I don't think it should be ignored anymore.
can we also call removeFromListAndUnlock twice?
can we also call removeFromListAndUnlock here?
can't we just call tryLock?
Not sure if this is strictly necessary here. Will getSession().getLoggedInUser() return null if the user is not logged in?
Not sure if this is strictly necessary here. Will getSession().getLoggedInUser() return ""; be null?
Is it an existing user? Can't we use a session API with a user id?
shouldn't this be!Strings.isNullOrEmpty(indices[0]))?
should this be!indices.isEmpty()?
should this be!indices.length!= 1?
I think this is wrong. This should be fixed in the following code: java private static final Pattern replaceAll("-", "");
I think this is wrong. This should be case insensitive
I think this is wrong. This should be fixed in master.
Why not checking ExitStatus.COMPLETED inside the ExitStatus.COMPLETED?
Why not ExitStatus.COMPLETED?
Why not checking ExitStatus.COMPLETED = ExitStatus.COMPLETED?
It seems like this isn't used outside of the test class. I would prefer to use getRight() and getConfigConfig() here.
Isn't this the same as the one above?
It seems like this isn't used outside of this class. I would prefer to use getRight() and getConfigConfig() here.
As toString() is not obvious, it is better to rename it to something like assertTrue(timestampMatcher.isEmpty())
As John wrote: **and** the same test as *. The same for all changed tests.
As toString() is not obvious, it is better to rename it to something like assertTrue(timestampMatcher.isEmpty()).
Can you use checkState(parent instanceof PipelinedApproximateSubpartition); here? It will get rid of the IllegalStateException if the injector already does that.
Can you use checkState(parent instanceof PipelinedApproximateSubpartition); here? It will get rid of the IllegalStateException if the injector is not available.
Can you use checkState(parent instanceof PipelinedApproximateSubpartition); here? It will get rid of the IllegalStateException if the injector already fails.
Probably better to move this into a constant?
Probably better to move this to a constant?
maybe extract a constant?
Does this really need to be public?
nit: extract path.toString() into a constant
nit: extract path.get(path) into a variable
is this method always true?
is this redundant?
is this method redundant?
I think you should use the [argument constructor](<LINK_0> instead.
I think you should use the forEach here instead of the for loop.
I think you should probably call the new class mouse listener, if the editorTextWidget is null.
Doesn't pad do this when it is on a stream?
Doesn't pad do a null check?
Doesn't pad do this when it is on a different thread?
Minor: Include the user's email address in the exception message.
Minor: Include the user entity in the exception message to make it more clear what's wrong?
Minor: Include the user entity in the exception message to make it easier to read.
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
In updateChart(), the collection fModules is updated first and then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
In updateChart(), the collection fModules is updated first, then this method can remain the same. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
I think this is not needed
I think this is not needed.
requireNonNull
@lautarobock Here too, let's declare throws Exception.
@lautarobock Same here, let's declare throws Exception
@lautarobock Same here, let's declare throws Exception.
concatMap(address) would be sufficient as we use map() instead of flatMap.
Couldn't this beconcatMap(address)? Does it work if there is no index?
Couldn't this beconcatMap(address)?
Needs to be in a finally block.
Needs to be in the finally block.
Needs to be in an finally block.
I have a feeling this should be.map(Stream::of).orElse(null)
I have a feeling this should be.map(List<String>)
I have a feeling this should be.map
why do you need an object here?
why do you need an if here?
why catch?
We could consider renaming this: @Override public Set<V> get(Set<V> elementgetDryRunFormatType) { return (prevFormatType) element; }
We could consider renaming this: @Override public Set<V> get(Set<V> elementgetDryRunFormatType) { return (prevFormatType) field; }
We could consider renaming this: @Override public Set<V> get(Set<V> elementgetDryRunFormatType) { return type.get(); }
Remove this
camel case?
Remove this try catch block.
It should close on its own, no need to close it.
It should close on its own, no need to call manager.
It should close on its own, no need to call it.
Right now, there is a problem with this: The messages will not be translated. So either we have to add a period between the end and the highest supported ones.
Right now, there is a problem with this: The messages will not be translated. So either we have to add a period between the end and the end of the loggable.
For Java files :k:
We should probably log the IllegalArgumentException that is thrown from this method.
We should probably log the IllegalArgumentException that is thrown by this method.
We don't need to catch NPEs.
the command should be on the storage domain, not on Host
the command should be on the storage domain, not on the storage domain.
the command should be on the storage domain, not on the storage domain
nit: can just be log.log-messages-count
nit: would be good to have this log messages in your class
nit: would be great to have this log messages in the log
can we just use a constant for this?
can we make this a constant?
can you make this a constant?
Shall we catch specific exception?
FileOutputStream is created via try-with-resources
FileOutputStream is not a good idea. Better to use specific format
I think this logic could be moved to a common interface for all the serviceLoadService and the DAOLoadService. We shouldn't need to do this if it shouldn't be done.
I think this logic could be moved to a common interface for all the serviceLoadService and the DAOLoadService. We shouldn't need to do this if it's only used once.
I think this logic could be moved to a common interface for all the serviceLoadService and the DAOLoadService. We shouldn't need to do this if it is not done.
Isn't there a reason to have the totalSize be a multiple of the first?
isn't there a reason to have the totalSize be a multiple of the first?
Isn't there a clearer way to do this? int totalSize = Math.max( totalSize); return int?
Should the order be reversed?
Should the order of metadata mappings be based on the current metadata source?
Should the order of metadata mappings be reversed?
This method can be return subscribedPattern!= null? "Duplicate" : "static"
This method should be: return Objects.requireNonNull(this.toLower())
This method should be: return Objects.requireNonNull(this, "Duplicate subscription is null");
Make this a protected method rather than private.
Make this a static final variable for VERSION
Make this a static final variable for VERSION.
can be assert childId == null
can we assert that collation == RelTraitSet.EMPTY);
Can we assert that collation == null
should we also clear the state in the transaction?
don't we need this?
should this be a different configuration?
@fanifieiev the same above.
@paulodamaso the braces and return are the same
@paulodamaso use final
This is not used anymore.
This can be rewritten to use filterOptions().
This can be simplified to filter type parser.
rename to SnippetType
rename to includedSnippetType
rename to something like snippetGenerator or something
RuntimeException?
RuntimeException? Why it is not a RuntimeException?
;)
Line longer than 120 cols. Also, please make this line as below
Line wrapping is not needed.
Space after =
I don't like this logic. The logic is correct. If it is full page then it should return true, otherwise it is pointless.
I don't like the logic here. The logic is correct. If it is correct, it should be put in isComplete(), not on this line.
I don't like this logic. The logic is correct. If it is full page then it should return true.
Use getRule() instead of 'this'.
Use getRule() instead of calling the super method.
Use getRule() instead of 'this'. You can also use 'this'.
[optional] How about to move the "isRevisionSupported" part before the "isRevisionSupported" call?
[optional] How about to move this to NotebookRepo.void these methods?
"isRevisionSupported" is better?
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "1000a" 3 times. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "String" 3 times. [![rule](<LINK_0>](<LINK_2>
extract to constant
Is it okay to have excludedColumns as a variable, and then do the following: return excludedColumns.stream().anyMatch(indColumn::equals);
Is it okay to have excludedColumns as a variable, and then do the calculation there on the next line?
Is it possible to have excludedColumns as an empty boolean variable instead of a make it return true?
This could be null, but is this even used anymore?
can it be null?
I don't see any effect here. Is this needed?
You can use Try() to create the singleton instance.
You can use Try() to create the singleton object.
You can use Try() to create the new StringSketchesAvailable objects.
Better to not use Jenkins.CONFIGURE here to keep the getRequiredPermission() call in the Jenkins.CONFIGURE_LINK_0>
Better to not use Jenkins.CONFIGURE here to keep the getRequiredPermission() call in the Jenkins.CONFIGURE_CONFIGURE bellow or for better readability.
Better to not use Jenkins.CONFIGURE here to keep the getRequiredPermission() return Jenkins.CONFIGURE;
test overlap and dehist == null isn't needed.
test overlap and dehist == null?
btw, code style is off.
The condition should be replaced with!TextUtils.isEmpty(assignmentId).
The condition should be replaced with!TextUtils.isEmpty(assignmentId)
The condition should be moved to the if (assignmentId!= null) { event.putString(eventId, event.getBundleId()); }
Again, should should be value == null
Again, is this null case necessary?
Again, should should be value
Maybe we can extract a static final variable here?
You can probably extract as a constant with the class name.
You can probably extract as a constant
this one is not needed
one line
one line.
isVirtIoScsiSCSI?
please add brackets surrounding the if condition
isVirtIoScsiValid(..)?
I guess we can use Assume.assumeTrue(mUseCaseGroupActive); here rather than catching an exception.
I guess we can use Assume.assumeTrue(mUseCaseGroupActive); here.
I guess we can use assumeTrue here.
Style-nit: Space after @Override
Style-nit: Space after if
Style-nit: Space after cast.
remove double a valid from test & implementation
remove double a valid or implementation
remove "is not a valid"
Can we move this logic into the declaration of the cursor initialization? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Can we move this logic into the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I don't think it's a possible issue.
Can we move this logic into the declaration of the cursor initialization? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I think it'd be awesome to make this a bit more readable.
SourceControl.SourceControlList?
SourceControl:sourceControlList?
SourceControl
Rather than introducing a new change value other than checking whether the value is already present in the View. I think we should implement it here as well: private boolean changeToolbarVisibilityInFullscreenMode(Object arg) { return (new File(arg)).child, arg); }
Rather than introducing a new change value other than checking whether the value is already present in the View. I think we should implement it here as well.
Rather than introducing a new layout test helper class what we need to do in the View. I think we should implement it here as well.
use.getUuid instead of getArtId, which will go away
use.getUuid instead of getArtId
use assertTrue instead of assertEquals
This is the same as the one in the field declaration, might be a premature optimization
This is the same as the one in the other class, might be a good candidate for a constant.
This is the same as the one in the field declaration, might be a good candidate for new java.util.DateTimeFormatter
Should we return List<IDevice> when certClass is not null?
Should we return List<IDevice> when the return value is invalid?
Should we return List<IDevice> when the return value is 0?
I think you should also check for an empty list instead of an array
I think you should also check for an empty list instead of an array first.
instanceof
same here, can you move this to a lambda
can we also call delegate.execute?
can we also call subscribe here?
If fArg2 is op_throw, we need to return true :)
If fArg1 is op_throw, we need to return true :)
If fArg2 is always non-null then we need to return true :)
why do you need this if?
why do you need this check?
why do you need this?
I'd use null-check here.
I'd use Objects.isNull() for this.
I'd use Objects.isNull()
can you explain how this change fixes the problem?
does this need to be in the new code?
can you explain how this changes?
![MAJOR](<LINK_1> Make "isAncestorOf" a "static" method. [![rule](<LINK_2>](<LINK_0>
@vilchik-elena Shouldn't it be!parentTree.isAncestorOf(JavaScript)?
@vilchik-elena Shouldn't it be!parentTree.isAncestorOf(JavaScript)? Otherwise you don't need to check that.
Before we always had non-null returns
Before we always had non-null skip (fixed-string offset)
Before we always had non-null skip (fixed-string offset) since the setting of the offset is no longer used.
Shouldn't this be ConcurrentHashMap instead?
Why use ConcurrentHashMap here?
Why use ConcurrentHashMap instead of ConcurrentHashMap?
there is no need to print the exception here - remove the "not closed" or at least add a new exception
there is no need to print the exception here - remove the throws clause
there is no need to declare a variable here.
Wouldn't we want to unify these names and pick either on the name or not?
Wouldn't we want to unify these names and pick either on the name or rather a bit of these names and pick either on the name or not?
Wouldn't we want to unify these names and pick either on the name or rather a bit of these names and pick either on the name or not? I'm somewhat uncomfortable.
I think it's better to use Integer.valueOf(this.commitChanges()) here.
I think it's better to use Integer.valueOf(this.commitChanges()) here instead of mmm because there is no other synchronization.
I think it's better to use RemoteException() instead of get(this).
Is there a reason that you are using this ConverterAttributeMapValidator instead of a new String[]?
Is there a reason that you are using this ConverterAttributeMapValidator instead of a new String?
Is there a reason that you can't use a simple String[][]?
return Util.toUpperCase(nameOrNumber)? : Character.toUpperCase(nameOrNumber));
return Util.toUpperCase(nameOrNumber);
You can use toUpperCase() here
checkNotNull(input, "null")
checkNotNull
looks like this method is not used?
return context;
return this;
return context here
Would it be better to use the constant for this?
Would it be better to use a constant for this?
Would be good to use the constant for this?
Rather than catching exceptions in these tests, I think we should let them bubble up to the test too.
Rather than catching exceptions on the tests I think we should let them bubble up, which will be aid in debugging.
Rather than catching exceptions on the tests I think we should let them bubble up, since this is aidious exception.
Is it possible to make this method final?
Is it possible to make a call to mCallTrackers, asking tracker as a parameter to checkTracker?
This method will be called for each call to mCallTrackers on a new call.
Why are you catching InterruptedException? Can we just return?
Why are you catching InterruptedException? Can we just propagate the InterruptedException?
Why are we printing the thread in the main thread? Can we log it?
suggestion if (castTargetTypes[i] || castTargetTypes[i]) { return Util.equalsIgnoreCase(clobCompatibleCast.class); }
nit: java if (castTargetTypes[i] || castTargetTypes[i]
nit: you can simplify this
This modification looks a bit weird. I think you can use a map instead of a set.
This modification looks a bit weird. I think in GerritGlobalModule we still want to use a set which has higher priority than the number of distinct levels, in this case it is not very clear what's the difference.
This modification looks a bit weird. I think you can use a visitor similar to Java8 method.
This should also be handled by the caller
This should also be done in the two-arg constructor. I don't think we're doing anything with this.
This should also be done in the two places
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 003 to break dependency from 001 and 002 to be successful
This will be unexpected if we change the test to use another element. From this method name it will be easy to change the test.
Is "Failed to process HEAD"?
Is this the same as the baseRequest.isHandled()?
Is "Failed to process HEAD"? Should this not include HEAD?
Maybe better to use builder.isEmpty()?
Maybe better to use isEmpty()?
Maybe better to use builder.isEmpty()?
As discussed, please rename this to a more accurate name
As discussed, we should rename this to a more accurate name
Let's make this package-private
Should this try/catch be moved outside of the catch block?
Should this try/catch be moved outside of the if block?
Should this try/catch be moved outside of the try block?
If there are cases where this could be null, we probably want to explicitly set the field to null.
Why do you need this public?
Why do you need this cast here?
Should we be using this as the only argument instead of its null? This method is used only in one case I believe its fine.
Should we be using this as the only argument instead of its null? This method is used only in one case I think its fine.
Should we be using this as the only argument instead of its null?
From the commit message you can reuse: <LINK_0>
From the commit message you may simply want to change the message to: "sortTypes is null"
From the commit message you may simply want to change the commit message to: "sortTypes is not null"
I think you mean (d<=0)
I think you mean (d d<=0)
I think you mean!(d<=0)
I think we should also check mQuickStartAdapter!= null, and we save the state to onSaveInstanceState.
I think we should also check mQuickStartAdapter!= null, and we save the state to onSaveInstanceState(outState) here. Otherwise the state and onSaveInstanceState will not be the default.
I think we should also check mQuickStartAdapter!= null, and we save the state to onSaveInstanceState(outState) here. Otherwise the state and onSaveInstanceState can be null.
If I correct, we can remove 'client' field at all, field in 'getConfiguration' method of 'getConfiguration'.
If I correct, we can remove 'client' field at all, and use in 'getConfiguration' method from: if (!client) {
If I correct, we can remove 'client' field at all, field in 'getConfiguration' method from: if (!client) {
We should probably move this up a line if we don't want to make it public.
We should probably move this up a line if we don't want to make it public
We should probably move this up a line if we don't need it.
Empty line?
Empty line here :)
Empty line here
nit: I would prefer to use String.format("%s=%s", _clusterName, mbeanName) instead of %s.
nit: I would probably use String.format("%s=%s", _clusterName, mbeanName) instead of %s.
nit: I would prefer to use String.format() here.
I don't think this is correct.
There is no need to use this static variable.
I don't think this is correct, as there are other executors in this class.
oomedEventList is not used. It should be the set to null, not the class.
> It should be final.
Unnecessary?
I don't think this class needs to be in the interface. All the components have a MarshallerContext, and this method would only call getComponent(Marshaller) inside the MarshallerContext constructor.
I don't think this class needs to be in the interface. All the implementations in MarshallerContext are in the component.
I don't think this class needs to be in the interface. All the components have a MarshallerContext, and this method would only call getComponent(Marshaller) there, so it does not need to be in both the classes.
follow proper parenthesis pattern.
follow proper parenthesis pattern. it should return null
follow proper parenthesis pattern..
I am a bit worried about what we are going on here. What about a plain old condition? public boolean visitIfStatement(Tree tree) { if (this.is(Kind.BOOLEAN_LITERAL) { return true; } if (condition.is(Tree.Kind.BOOLEAN_LITERAL) { ExpressionTree condition = tree.get(Tree.Kind.BOOLEAN_LITERAL) { return false; } }
I am a bit worried about what we are going on here. What about a plain old condition? public boolean visitIfStatement(Tree tree) { if (this.is(Kind.BOOLEAN_LITERAL) { return true; } if (condition.is(Tree.Kind.BOOLEAN_LITERAL) { ExpressionTree condition = tree.get(Tree.Kind.BOOLEAN_LITERAL) { return true; } }
I am not sure why we need this condition.
create method to create index.
use getCurrentIndex() method create index.
create index.
I think this is better to use Objects.equals() to make sure all fields are set to default values.
Should equals be used?
Should equals be used to compare objects using ==?
Don't need to declare this that it's declared as a static method in NioClient.
Don't need to declare this that it's declared as a static method in NioClient. (I think I'm also missing something)
Don't need to declare this that it's declared as a static var, and can be replaced with, as a member variable.
can you use one syntax here?
can you use the ParseInModule instead?
can't this be one line?
Should be mIter.isValid() instead of mIter.isValid()
Should be mIter.isValid() instead.
Should be mIter.isValid() instead of mIter.isValid()?
If we make the constructor private we don't need to create an instance, we can get rid of the this. (and the setter in the builder itself)
If we make the constructor private we don't need to create an instance, we can get rid of the code duplication. (here and below)
If we make the constructor private we don't need to create an instance, we can get rid of the this. (and the setter in the builder).
Can do name.get(name).
Can do throw new IOException("name " + name + " can't be null
Can do throw new IOException( name.get(name));
Can you use more descriptive names for variables? m_memberId, and etc.
Can you use more specific names for variables? m_memberId, and etc.
Can you put this "MockRoot" in a variable that is used both to keep the previous behavior?
Isn't this the same as deleteEntity()?
Isn't this the same as for deleteEntity()?
move into the try block?
do we need this?
do we need this in a try/catch block?
do we need this in a try-catch block?
simplify with return handlers.get(uuid)!= null
simplify to return handlers.get(uuid)!= null
simplify code by using single return statement
No.
No need for this variable
any difference?
This isn't strictly needed as EEELLL doesn't appear in the dd yyyy-MM-dd yyyy-MM-dd few lines above.
This isn't strictly needed as EEELLL doesn't appear in the dd yyyy-MM-dd yyyy-MM-dd'T'
This isn't strictly true. Some lines will be blamed onto the commit, as it will be more efficient.
I think this change is wrong. I'd fold the code into the new function into the new function.
I think this change is wrong. I'd fold the && into the new function.
I think this change is wrong. I'd revert it
Can you delete all the changes in this file? I'm going to write proper tests for stuff like this after merging. I don't want to overly clutter this example (more than it already is). I'm going to write proper tests for stuff like this after merging. I don't want to overly clutter this example (more than it already is).
Can you delete all the changes in this file? I'm going to write proper tests for stuff like this after merging. I don't want to overly clutter this example (more than it already is).
Can you delete all the changes in this file? I'm going to write proper tests for stuff like this after merging. I don't want to overly clutter this example (more than it already is). I'm going to write proper tests for stuff like this in this example (more than it already is).
This equals() should probably be checked first. It's a bit hard to read.
This looks like the wrong way to implement these kind of checks. It should be part of a reference set from the underlying class, but that's not another class.
This looks like the wrong way to implement these kind of checks. It should be part of a reference set from the underlying class, but that's not the case.
i.e. getMetricObjectValue(rowOffset, aggs)!= 0
i.e. return null;
i.e. int getMetricObjectValue(int rowOffset, aggs) will be null
Please move this logic outside of this class, it doesn't need to be synchronized also. Also, the whole method could be synchronized like this: @Override public void stop() { try {.. } catch (JarFile jarFile.Entry("Closed %s jar file that was added as resource root for %s jar file {}", jarFiles.getName(), jarFiles.getName()).toString()) { log.debugf("Closing %s jar file, jarFiles.getName()); } }
"Closing %s jar file is missing". Also, this should be constant.
Please move this logic outside of this class, it doesn't need to be synchronized also.
This isn't a big deal, but you can make this a private method.
This could be this.operation.skipField(logLevel)
This could be private.
It's better to add this to thread log.
It's better to add a message to the Exception.
It's better to add this to PolicyMetaData.
I'd replace lines 272-275 with an assertion, as this is clearly a code bug. Using a HashSet would be faster and more efficient.
I'd replace lines 272-275 with an assertion, as this is clearly a code bug. Using a HashSet would be better and more efficient.
I'd replace lines 272-275 with an assertion, as this is clearly a code bug. Using a HashSet will make it even more clear.
orElseThrow() should be omitted
orElseThrow?
orElseThrow() is wrong here
Don't set statusCode in this class, just delegate to the appropriate constructor.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode, we could avoid that.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode, we could avoid that?
I would like to get the parent and call the method twice in this class.
I would like to get the parent and call the method twice in this class. Maybe the next line would be clearer?
I would like to get the parent in a class (org.eclipse.org/apache/commons.lang3.builder package)
I think MODE_NIGHT_AUTO_TIMESIGHT_AUTO_TIMESIGHT_AUTO_TIMESIGHT_AUTO_TIME > 0 should be true.
I think MODE_NIGHT_AUTO_TIMESIGHT_AUTO_TIMESIGHT_AUTO_TIME > 0 should be true.
I think MODE_NIGHT_AUTO_TIMESIGHT_AUTO_TIMESIGHT_AUTO_TIMESIGHT_AUTO_TIME > true can be removed.
replace with switch (InstGmosCommonType.LGS_NAME)
replace with switch (InstGmosCommonType.LGS_TypeName.getInstrumentGmosCommonType.FPUnit)
replace with switch (InstGmosCommonType.LGS_TypeName.getMode()) {
Really minor thing, but is there a reason we need to use constructor from Context? It's a common practice in general, but it makes me wonder if we could use the fields directly
Really minor thing, but is there a reason we need to use constructor from Context? It's a common practice in general, because it makes the code easier to read.
Really minor thing, but is there a reason we need to use constructor from CommonContext? It makes the test easier to read.
static import the Log method
static import ;
static
Use 'value' cannot be null.
Null-value should be added to strings.xml
Put a space after,
The final keyword is not needed here, so it could be removed.
The final keyword is not needed here, hence can just return "this".
final?
Great!
Nice!
Great first!
I believe this is one of the following issue: if the phaseResult.invalidIndexRowCount is 0 but the phaseResult.invalidIndexRowCount is 0 because the phaseResult.invalidIndexRowCount is 0. Also it seems that this method is called after the operationResult.invalidIndexRowCount which is before the operation operation operation.
I believe this is one of the following issue: if the phaseResult.invalidIndexRowCount is 0 but the phaseResult.invalidIndexRowCount is 0 because the phaseResult.invalidIndexRowCount is 0. Also it seems that this method is called after the operationResult.invalidIndexRowCount which is before the extra operation operation.
Should we log it here? It seems that the operation result in invalidIndexRowCount is absent as the condition after the operation operation operation.
MAybe refactor this test to always check response code, it should be part of equals().
Indentation looks a little off here
Indentation looks a little off here.
probably don't need the parenthesis here.
I'm wondering if it's better to make sure the key is consistent with the other map implementations.
probably don't need the parenthesis
Do we need all these autogenerated methods?
Do we need all these auto-generated strings?
if we use just one empty line, can we stick with current one?
This is not a required change.
Is this check necessary?
This is not a good change.
maybe shutdown()? Same for other places.
maybe shutdown()? Same for other places
maybe shutdown()?
Need to verify the exception is thrown
Need to verify the exception is thrown?
Need to verify the index is not null
We should re-add this to the existing TimeoutExpression, just in case we ever add a.sendTimeoutExpression.
We should re-add this to the existing ConfigExpression.
We should re-add this to the existing TimeoutExpression, just in case we ever add a.sendTimeoutExpression here
@vilchik-elena this could be done with the View.
the null check is useless here.
the null-check is useless here.
use 8's
use 'timestamp' instead
use 8's }
Does the order matter here? I think the getMaxLength() should be the first PDataType instead of PDataType.getMaxLength().
Does the order matter here? I think the getMaxLength() will return 0 for the PDataType.MAX_VALUE, right?
Change the PDataType.getMaxLength() to the first row key
This is wrong. We should use Objects.hashCode(o) for the parameters.
This is wrong. We should use Objects.hashCode(o) for the following.
This is wrong. We should use Objects.hash() for the parameters.
This method should simply invoke the removePacket() method. The interceptors must not be called concurrently.
This method should simply invoke the removePacket() method.
This method should simply remove the element from the list if there is no interceptors.
should this be in the URLClassLoader constructor?
are we sure this is the correct thing? If m URLClassLoader is the parent directory then it should be the last one.
should this be in the URLClassLoader constructor instead of the type request?
Please make the constructor private (see Invalid).
Please make the constructor private.
Please make the constructor private static.
we need hostName only to log error. Please call it there.
we need hostName only to log error. Please check if queue is empty.
we need hostName only to log error. Please check if queue is null.
Any reason to encapsulate the Exchange pattern as a separate method?
Can we add this to the setExchange helper?
Can we add this to the Exchange file and change it to private?
nit: you can use the iterator() method here instead of Iterator
nit: you can use the iterator() method here instead of iterator() on the return value
nit: you can use the iterator() method here instead of iterator() on the return impl
if null checks are not required
if the List is not required here
if null?
I'm not sure we should be able to remove this. If we just invoke the existing method, we should remove the "set" method.
I'm not sure we should be able to remove this. If we just invoke the existing method, we should be able to remove the "retrieveObserver".
I'm not sure we should be able to remove this. If we just invoke the existing method, we should be able to remove the "reset" method.
remove
remove this return in line
remove public
Why do you need to check sock.isClosed()?
Why do you need to check for sock == null here?
Why do you need to check sock == null here?
Wouldn't it be easier to use l here? IIUC
Wouldn't it be easier to use l here?
suggestion l;
shouldn't the init also be called?
shouldn't the init also be called here?
shouldn't this be private?
"Thrown after" is less than or equal to a test. Can we make this more specific?
"Thrown after" is less than or equal to a test. Can we make this more explicit?
"waitFor" is clearer.
I think the super.dispose() should be called here
I think we should be super.dispose() here
This should be super.dispose()
style nit: we don't use braces around single line blocks
That doesn't look right. Can you create a private method to do this?
style nit: missing braces
Verify the recorded request
Verify that the returned definitions are useless
Verify that the recorded request
Might want to add the.abilty name here, since it's not a good idea to view
Might want to add the 'pattern'
Might want to add the 'gff' as a field name
change to if (!isLiveSnapshot()) {
change to if (!isLiveSnapshot())
you missed to add a new line
can you please replace with'result'
can you please replace the line before the write?
can you please replace with'result' instead?
This will reference the hashCode() method from the regular integer value (avoiding it via an hash map). It would be better to use Objects.hash()
This will reference the hashCode() method from the regular integer value (avoiding it via an hash map). Any reason to use Objects.hash() instead of using Guava?
This will reference the hashCode() method from the JDK right?
add this to the ofNullable
this.
Optional.ofNullable
Hard-coded "...this"
Hard-coded "...no"
Hard-coded "...no string"
hook!= null? hook : hooks
hook.onPostReceive(rp, commands);?
hook.onPostReceive(rp, commands) could be inlined here
Is the forEach loop necessary?
Is threads.interrupt() necessary?
Is threads.interrupt() needed here?
The super call is unnecessary.
I am not sure why we need to unsubscribe here.
The super call doesn't actually stop the events.
I believe this can be replaced with <LINK_0>..
I believe we need to clean up the redundant check for returned value.
I believe we need to clean up the redundant check for returned value. It should be coigrator#createStorage(Storage) and not just that
Make it stream a bit more functional.
Make it stream a bit more readable
Make it static
Are we sure we are sending in JSON? Should we send a valid error message to the user?
Are we sure we are sending in JSON? Should we send a valid error message to the BundleAnalytics.
Are we sure we are sending in JSON? Should we send a uid here?
this doesn't need to be public
this could be made static
this could be done shorter
nit: could you use instanceof here?
nit: can you use instanceof here?
nit: can you use VIRTUAL_VIEW here? We don't need to use a local variable for tableType.isView()
I would extract this to a method since it is used twice.
I would extract this to a method since it is used only in this class
I would extract this to a method since it is used only once
This should be a constant.
This should be a normal runtime exception. return null;
This should be a constant
Why is this printing the stack trace? There is no reason to log it?
Why did you catch RuntimeException instead of RuntimeException?
Why is this printing the stack trace?
We should use alias.toUpperCase()
We should use MissingKey.getSimpleName() for the name.
We should use MissingKey.getSimpleName() for that name.
These line is proof you don't need QuotaConsumptionParametersWrapper
if missing storagePool, the flow has errors. return false?
if (!getStoragePool() == VdcActionType.NONE) { return false; }
seems like these should be set in the getProperty method instead of loadBuildProperties
seems like these should be set in the Utils class instead of loadBuildProperties
seems like these should be set in the getProperty method instead of loadBuildData
Should the name of the thread be maxwell-kafka-worker instead?
Should the delay be maxwell-kafka-worker instead?
Should it be maxwell-kafka-worker instead?
please use a self-reference path
please use a better name for this variable
you should use a cleaner name for this variable and other fields.
Should we use pushInlineDeployments here?
wrong format + should be changed to use pushInlineDeployments
should we use pushInlineDeployments here?
Should be a null check to see a getDataObject().
retrieving properties for a property and then retrieving it, rather than doing a logic.
Should be a null check.
Shouldn't this be using new PortalItemView(portalItemView) instead of setting the string?
Shouldn't this be using PortalItemView.setDefault(sceneView) instead of this?
Shouldn't this be using PortalItemView.setDefault(sceneView) instead?
Wouldn't it be better to have a util method for this? It can call the new method then.
Wouldn't it be better to have a util method for this? It can call the new method like getFeedScopedId(arg)
Wouldn't it be better to have a util method for this? It can call the new method like getFeedScopedId(String), then.
is there a reason to put this in some static method?
is there some constants for this?
is there a reason to put this in a separate method?
use Objects.hash() which simplifies this method.
use Objects.hash() instead of the ternary expression
use Objects.hashCode()
parentheses please ;) return (number == null? null : (number.longValue()));
parentheses please ;) return (number == null? null : 0);
parentheses please () and return 0
nit: missing space after if
nit: please add a timeout for the cause.
nit: missing finals
getLong() returns long, so why not the long type?
getLong() returns an long, so why not the long type?
getLong() returns an int, so why not the long type?
Use try-with-resources here to ensure the stream is closed.
Use try-with-resources here to ensure explicit close is closed
Use try-with-resources here to ensure explicit close is not closed.
getSurveys() will iterate in getSurveys() and getSurveys() will render it.
getSurveys() will iterate in getSurveys() and getSurveys() will return null.
getSurveyByTournament?
Maybe check if batch update exception has nested SQLNonTransientException?
I am thinking if we can move this to caller method and use separate metrics for AccountService and AccountStatsReport. Thus, we have a clear view that how may QPS from AccountService.
I am thinking if we can move this to caller method and use separate metrics for AccountService and AccountStatsReport. Thus, the name of the class may be also "operationType".
What about Ospins like this? "warnings": "status".equals(ResponseStatus)
What about Ospins like this? "warnings".equals(ResponseStatus)
What about Ospinio magic strings like this?
This can be: BigInteger asInteger = BigInteger.convert(uuid); BigInteger asInteger = BigInteger.valueOf(uuid); if (uuid == null) { UUID.compareTo(uuid); }
This can be: BigInteger asInteger = BigInteger.convert(uuid); BigInteger asInteger = BigInteger.valueOf(uuid); BigInteger asInteger = BigInteger.valueOf(uuid);
This can be: BigInteger asInteger = BigInteger.convert(uuid); BigInteger asInteger = BigInteger.valueOf(uuid); if (uuid == null) { UUID.compareTo(uuid.getLeast()); return asInteger(value)) }
Can this be private?
Can this be changed to something like: boolean frozen = mask - boolean
You can't find a result from IllegalArgumentException.
Should this not happen in the constructor?
This doesn't work for remotePage. The variable is never used.
Should this be a SecureStoreUtils.isGitStore?
Actually, this can be simplified to java future.completeExceptionally(timeoutMsg);
Actually, this can be simplified to java future.completeExceptionally(new TimeoutException("My timeoutMsg"));
Actually, this can be kept as timeoutMsg.
This should be handled properly.
This does not need to be a set.
This does not return the list right away!
Same here. You are comparing the IDs too.
Should you check if object is null here?
Same here. You are comparing GlusterGeoRepSession from o.
we can store this in a constant and call it from here
we can store this in a constant and call it from time unit.
we can store this in a constant and call it from here?
_verify
As I mentioned before, should we check the specific error message here?
As I mentioned before, should we check the specific error message too?
Why does this need to be added now-why is it in this PR? Was JENKINS-20398 somehow related?
Why does this need to be added now-why is it in this PR? Was 'JENKINS-20398 somehow related?
Why does this need to be added now-why is it in this PR? Was it in the first PR?
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply); (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply); (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return map(partialFunction::isDefinedAt).map(partialFunction::apply); (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
I would rename 'traversalIterator' to something like 'traversalIterator' or 'traversalIterator', what's?
I would rename 'traversalIterator' to make it clearer
I would rename 'traversalIterator' to make it clearer.
I think we don't need to use String.format because this is only for logging
Improve warning text.
I think we don't need to use {} for String concatenation.
Seems like this could be having an assert on m_syncedSinceLastEdit.
Seems like this could be reset() on m_syncedSinceLastEdit.
Seems like this could be reset() on m_syncedSinceLastEdit. I think it's a bit cleaner to reset these.
Change the return type to PatternBasedHeaderMatcher(this.public).
Please don't store the patterns in the middle of the set.
Please don't use a List any more.
I don't get why we are doing this method again.
I don't like this method being public.
I don't get why we return the API.
we should validate (and the feature support check) it in the validate() method.
we should re-use the 'and' for the feature, not the template
we should re-use the feature, not the domain
Are we sure we don't want to reuse the exception type in the getNextTemporalArgumentException? If not, we should use _know_ that the exception is up, not always by the parser.
Are we sure we don't want to reuse the exception type in the getNextTemporalArgumentException? If not, we should use _know_ that the exception is up to the "cause" of the message.
Are we sure we don't want to reuse the exception type in the getNextTemporalArgumentException? If not, we should use _know_ that the exception is up to the "cause" of the exception.
Please change to externalSearch =
Missing an isEmpty check
Not sure why this is global to "referer"
Can we use DanillaUtils.isMethod_get(obj).equals(method) instead?
Has a MethodHandle get() method be used on line 4.5?
Can we use DanillaUtils.isMethod_get(obj).equals(method) instead here?
Seems like we should throw an exception here instead of logging it.
Seems like we should throw an exception here instead of logging it?
Seems like we should throw an exception here?
Shouldn't it be isEnabled()?
Would it be better to return isEnabled() here?
Would it work if isEnabled() is false?
@inverno rename to isStringLiteralExpression
@ivandalbosco This whole condition can be replaced by!isStringLiteral(tree)
@inverno remove redundant parentheses
We may want to move this into a closeQuietly method, so we don't do a null check before calling closeQuietly.
We may want to move this into a closeQuietly method, so we do not have to do a null check before calling closeQuietly.
We may want to move this into a closeQuietly method, so we don't do a null check before it.
Can schema instanceof ArraySchema?
Can you check schema instanceof ArraySchema?
static?
you can use CuratedContentPageObject(driver) method
you can use "CuratedContentPageObject" instead of "Content"
you can use "CuratedContentPageObject" here
IMHO, so best to do something like try { } catch (SQLException e) { throw new RuntimeException("Unable to retrieve the current user for the user", e); }
IMHO, so best to do something like try { } catch (SQLException e) { throw new SQLException(e); } so that callers can deal with the exception related to that
IMHO, so best to do something like try { } catch (SQLException e) { throw new SQLException(e); } so that callers can deal with the error case
Integer.parseInt
maxSimulQueryParam is null
Log.e()
I think this should be package-private.
I think this should be public
I think this should be package-private and not public.
Can we extract spliterator -> ero?
Can we extract spliterator -> ero style value into a variable?
Can we extract.defaultBlock() - at least for readability?
you can simply return getGlusterVolume().getVolumeType().isReplicatedType()
you can simply return the boolean value here - no need to check for getParameters().isReplicatedType()
you can simply return getGlusterVolume().isReplicatedType()
equals(elements) not!= null?
equals(elements) not!= 0)?
equals(elements) not!= 0,?
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
I think there is an exception being thrown here. If there is an exception, there will be double logging. Could you change this to debug level?
I think there is an exception being thrown here. If there is an exception, there will be double logging. Could you change this method to be a one-liner?
Can we find a better name? I mean, when you read quickly, you can easily read it as java Objects.requireNonNull(realm, "null");
Can we find a better name? I mean, when you read quickly, you can easily read it as a RealmObject.
Can we find a better name? I mean, when you read quickly, you can easily read it as e.g assertFalse(realm.getMessage());
Doesn't this need to be on the new line?
Shouldn't this be on the new line?
Shouldn't this be on the higher bound?
please use the proper name for the parameter as well
please use the static import for the last parameter, when you use the same parameters
please use the variable name as well
static import
stats should be added here
this check is redundant.
remove this
remove this and instead of remove this
remove empty line
Should we check that the file is actually found instead of file.xml?
Is it possible to create the file in the same directory and then check it again?
Is it possible to create the file in the same directory where the problem is actually found?
Does this method need to be synchronized?
Create an array instead of using a String
Create an array instead of using a List here
not sure about this.
not sure about this..
Not sure about this..
Maybe we should log the exception, not just the message.
Maybe logging the exception as well?
Maybe logging the exception as a second argument?
should be replaced with return super.protected I think
remove empty line
invert the condition
For consistency, should this be renamed to getClientPublicKeyedKey or something like that?
For consistency, should this be renamed to getClientPublicKeyedKey or something similar?
For consistency, should this be renamed to getClientPublicKey
Possible to log only one debug line here?
Possible to log only one debug line here for readability?
Possible to log only one debug line here.
I would extract "/web/overview **Done** to a constant
[optional] I personally prefer to use any(status().isFound()) here
I would extract "/web/overview **Done** to a constant.
Is this line meant to be removed?
getNonWhitelistedKeys() is not called from all the app.
getNonWhitelistedKeys() is not called from all the Preference views, so you should just remove the check here.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, PlainOldUser.class); avroItemWriter.set(false); Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, PlainOldUser.class); avroItemWriter.set(null); avroItemWriter.set(this); Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, PlainOldUser.class); avroItemWriter.set(false); avroItemWriter.set(this); Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
I don't think we can do this kind of checks on any vanilla code in the superclass. Maybe it would make sense to add a terrain constructor into the addStars method and make sure we never call this method.
I don't think we can do this kind of checks on any vanilla code in the superclass. Maybe it would make sense to add a terrain constructor into the addStars method and make sure we never call addStars() on these, even when they are needed.
I don't know, but I think it's safe to remove the addStars here: if (cache.getGeocode()!= null) { add(cache); } else { add(cache); } So when we have a ResourceFactory we can create a Resource type of the factory.
remove?
Remove?
Remove this?
@vilchik-elena Why not return null and have it be a!= null check?
@vilchik-elena Why not return null and have it be a default?
@vilchik-elena Why not a!= null check and have it be a!= null?
Use [Assert.assertFalse](<LINK_0> instead.
nit: Use hamcrest matchers :)
Use [Assert.assertFalse](<LINK_0>
Integer.parseInt
Integer.parseInt(config.maxSubscriptions(), Integer.parseInt(config))
you should return the enum, not the whole class.
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions.
Not all announcement activity is public. Wondering if there is a rationale for this API call...
DateRange is not used now.
We should make this package private and annotate it with @VisibleForTesting.
These should all be set in the constructor
These checks can be done in the constructor.
- listFiles can return null if empty, so you don't need to check for null here. - Have you considered using listFiles() rather than calling dir.listFiles()?
- listFiles can return null if empty, so you don't need to check for null here. - Have you tested that this is a directory, not a directory? - Shouldn't we fail if it is in the directory, or can we return empty list? - Like listFiles()?
- listFiles can return null if empty, so you don't need to check for null here. - Have you tested that this is a directory, not a directory? - Shouldn't we fail if it is in the directory, or can we return empty list? - And is this ok?
The constructor can be private.
The expression should have the same behavior as in the constructor.
The expression should have the same return type
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know.
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know..
Adding this to a field is good manner.
Adding this to a field is safe.
Adding this to a field is good manner too
Please rename queryStateMap to something reasonable, as the class is not a field.
Please do not use final (or the variable is final)
Please rename queryStateMap to something reasonable, as the class is already a field.
Is it worth Class<?> instanceof Class<?> && ((Class) type).isPrimitive()?
Is it worth replacing Class<?> by Class<?>?
Is it worth doing this cast on PrimitiveType()?
nit: you can use assertThat( artifacts.getResults(), contains(branch.getExactlyOne().getName()).
artifacts to artifact - remove.
artifacts to artifact are not used.
Shouldn't this be removed?
Shouldn't this be just testDisabledRelativeLinks (or following)?
Shouldn't this be removed?
Are we sure WFieldIndicatorWebElements would still be enough? It may be IMHO necessary to add element as well
Are we sure WFieldIndicatorWebElements would still be enough? It may be IMHO necessary to add element as well.
Are we sure WFieldIndicatorWebElements would still be enough? It may be IMHO necessary to add element as well..
Why is this only used for the OperandTypes?
Why is this only used for the OperandTypes?
Why is this only done on the last line?
Add check for null by default
Add check for null before binding
Add check for null
Is it okay to use the same URL as the resourceRetriever?
Is it okay to use the same URL as the resourceRetriever.retrieveResource(url) method instead of the one below?
Is it okay to use the same URL as the resourceRetriever.retrieveResource() method instead of the one below?
Why not use the Objects.hash1?
Why not use Objects.hash1?
Why not use java.util.Objects.hash1?
Is this change necessary?
Does this need to be public?
Is this test necessary?
I'd rather use a less general approach like this: java String msg = ctx.getmsg().get(context); if (msg instanceof FullByteBuf) { handleWebSocketFrame(ctx, msg); } else { handleWebSocketFrame(ctx, msg); }
I'd go for these (same lines)
I'd go for these (same lines) :)
Don't you think it's better to create a new factory method to register the ObjKey and the ObjKey, instead of creating a new one?
Don't you think it's better to create a new factory method to register the ObjType and call the constructor on it instead of passing it everywhere?
Don't you think it's better to create a new factory method to register the ObjType and call the constructor on it?
maybe s3Client.doesObjectExist() would be clearer?
maybe s3Client.doesObjectExist() be clearer?
maybe warn?
YesNoType() would be a bit more natural here to use the YesNoType.getJavaTypeDescriptor.INSTANCE.YesNoType() instead.
YesNoType() would be a bit more readable than YesNoType(). I think it's worth adding a new constructor here to avoid the problem.
YesNoType() would be a bit more readable than YesNoType(). I think it's worth adding a new constructor here to avoid the double parameter.
Will this show the user how it's logged in?
Will we want to display a user how they should look into the app?
Will we want to display a user how they should look into it?
Interactor: Should be added in the interactor to the inputStream. <LINK_0>
Interactor: Should be added in the interactor to the inputStream. <logic
Is it necessary to override the updateInteractor here?
Do we need to make this method final?
Probably should check for this.
Do we need to make this method public?
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, String, Logger) constructor that accepts Duration to encapsulate this type conversion.
super() is unnecessary here
super() is unnecessary here.
super() is implied
I think it's better to change this to "Failed to note" in future
I think it's better to change this to "Failed to note" in the commit message, in case of any change
I think it's better to change this to "Failed to note"
Thanks for this solution!
Thanks for cleaning up this looks very similar to original test
Thanks for this.
Could you please extract as method here and in the above method? It would make this method more readable.
Could you please extract the steps in a method so we are sure in future we are skipping "continue".
Could you please extract the steps in a method so that we are sure in future we are skipping "continue".
This doesn't really need to be public. It can be package-private as well.
This doesn't really need to be public. It can be package-private.
This doesn't really need to be public. It can be package-private if it's only used internally.
And the message is wrong.
You need to correct the message here.
You need to rebase the config.
this should be private
should this be private?
MAX_LISTING_LENGTH
It's enough to make sure that a string is a localized and a constant must be defined as a constant.
It's enough to make sure that a string is a localized and a constant must be defined as a constant somewhere, e.g. private static final int ONE_PORT_NUMBER = "Value"; this class is a constant, it might be better (as well as the IP_BYTES option).
It's enough to make sure that a string is a localized and a constant must be defined as a constant somewhere, e.g. private static final int ONE_PORT_NUMBER = "Value"; this class is a constant, it might be better (as well as the IP_BYTES case).
You could do a contains and remove the ACCEPTED_ENTRY_PIDS.
You could do a contains and get that do a null check
You could do a contains and get that do a null check.
That's preferred to everything via orElseGet.
That's strange. So we might not want to store the hole directly for the simple store. It would be better to avoid using lambda when we can.
That's strange. So we might not want to store the hole directly for the simple store.
could we use StringUtils.isNotEmpty(nullable) instead?
could we use strings instead?
could we use constant instead?
I think we should stick to this approach, as it will allow some time to change this behavior.
I think we should stick to this approach, not a hasSize.
I think we should stick to this approach as well, not a full stop.
Since you are modifying the above code, could you move it to a private method and have a single call to the same method?
Since you are modifying the above code, could you move it to a private method and have a single protected method?
Since you are modifying the above code could you move it to a private method and have a single call to the same method?
Why do we need this change?
Why do we need this. I'm not sure if the implementation is working well if we have two constructors in ClassFileConstants. Can we just use the parsed number of threads?
Why do we need this. I'm not sure if the implementation is working well if we have two constructors in one.
runAsync() should already use AbstractRunnable.run(). And I believe that's the best option here.
runAsync() should already use AbstractRunnable.run(). And I believe that it will delay the thread to interrupt the execution.
asyncClient?
We should be able to use ImmutableList.of()
We should be trying this, I think.
We should be trying to use PS.
Please move the shutdown stuff into the executor logger where the executor is shutdown.
Please move the shutdown stuff into the executor logger where the executor is called.
Please move the shutdown stuff into the executor service, to avoid the risk of creating the thread between threads
All the other'maxRetries' names don't make sense.
All the other'maxRetries' names don't use it for each call.
All these booleans can be removed.
suggestion return!executingJob.getCategories().contains(category.getCategories().contains(category)));
suggestion if (!executingJob.contains(category.getCategories().contains(category)) {
suggestion return!executingJob.getCategories().contains(category.getCategories().contains(category));
I don't think that we need this log message because it is a good practice. This method is used only for testing purposes and in the case of system flag.
I don't think that we need this log message because it is a good practice.
I don't think that we need this log message because it is a good practice. This method is used only for testing.
I don't think you can use stream api here.
You can use stream() method.
Please use stream api here
This will return 0 if the expiry is null. And should the test be run as an error?
This will return 1 if the expiry is null.
This will return 0 if the expiry is null.
Can we use the activator here as well?
@jigasi Can you make this kind of info?
Can we use the activator here?
SA == SERVICE_ACCOUNT? avoid abbreviations
SA_CLIENT_EMAIL_TOKEN ACCESS_TOKEN and ACCESS_TOKEN_KEY_EMAIL_TOKEN
SA_CLIENT_EMAIL_TOKEN ACCESS_TOKEN_PREFIX
The nested if can be removed.
The nested if can be nested as a single return statement as well.
The nested if can be nested as a single-line lambda
You could use result.dismiss() here
You could use result.dismiss() here with a guard clause.
You could use result.dismiss();
i18n
i'd put this into getHowTo() method?
i'd put this into getHowTo() method? wouldn't it be more of a difference?
I think we have a problem here. If we aren't using this anywhere, can we make it final?
I think we have a problem here. If we aren't using this anywhere, can we make it final? Maybe we can use Util.toPreDrawListener here?
I think we have a problem here. If we aren't using this anywhere, can we make it final? Maybe we can use Util.removeOnPreDrawListener?
What's the purpose of this operation?
What's the purpose of this method?
Revert this change?
Is there a reason we shouldn't use this.appActivity = appActivity.get();?
Is there a reason we shouldn't use this and the above constructor? It should be set in the caller.
Is there a reason we shouldn't use this.appActivity = appActivity;?
Maybe a switch-case to be more precise? return CommonImages.getImage(ReviewsImages.GREEN_INIT);
Maybe a switch-case to be more explicit? return CommonImages.getImage(ReviewsImages.GREEN_INIT);
Maybe a switch-case to be more precise? return CommonImages.getImage(ReviewsImages.GREEN_TABLE);
Java 8 has a constant for the magic number, please use that here.
Java 8 has a constant defined in this class, so we can drop the magic.
Re-use the validator here and below
Just use the Exception's Context.jboss.weld.environment.se.logging.Logger at debug level
Just use the Exception's Logger.debug(...).
Just use the Exception's Logger.debug(...)....
I don't think this can be false. You can just do return true;.
I don't think this can be false. You can simply do return true;.
I don't think this can be false. You can simply return true; to avoid the check for isInit() call.
Can you also remove the public ByteBuf createByteBuffer(int maxBytes, long res, int maxBytes) method?
Can you also remove the public ByteBuf createByteBuffer(int maxBytes, long res, long size) method?
Can you also remove the public ByteBuf createByteBuffer(int maxBuffer, int maxSize) method?
here you can get rid of the duplication, and just do: return new OperatorDTO(id).as(id).as(Json.class).as(Json.class).as(id))
oldOperatorDTO is not the new one, maybe it is better to have a single base class that you can use in this context
oldOperatorDTO is not the proper name
should be new OAuth2Configurer<HttpSecurity>
Can you explain this API?
Can you explain why we need this change?
It's possible to assert a getActivity()!= null with an empty string, in case the fragment is not visible, and that's what you wanted to assert.
It's possible to assert a getActivity()!= null in the previous line. I don't think it's necessary either.
It's possible to assert a getActivity()!= null with an empty string, in case the fragment is not visible, and that's what you wanted to do.
I think this could call to setCipherSuites(arguments.setFactor(supportedProtocols))
I prefer setting a default value for supportedCipherSuitesOrder before to call getCipherSuitesOrder() as well.
I prefer setting a default value for "supportedCipherSuites"
I think we want to reuse the "Paused" constant here.
If we want to reuse the "enabled" set, then we should reuse the "enabled" constant.
If we want to reuse the "enabled" set, then we should reuse the "enabled" method.
should be done in a finally block
should be a space after "try"
should be a space after "try".
Looks like we can't use local var for this.
Looks like we can't use String.format() directly here.
Looks like we can't use String.format() directly in the code.
Instead of using the context class loader, use the class loader of the first annotation factory.
Instead of using the context class loader, use the class loader of the first class loader of the class loader.
Instead of using the context class loader, use the class loader of the first class loader of the annotation factory.
synchronize on the test
synchronize on the test instead
synchronize on the test classes
do we use static import here? It does not use any methods.
do we use static import here? it is the same from other tests.
use static import
Please use diamond operator.
here can be replaced with forEach
here can be replaced with Collections.singletonMap
Inline the variable name.
Duplicated code
Inline the variable
This should probably be shutdown, not shutdownNow.
@Gr1f0n6x, please use ExecutorServiceManager.shutdownGraceful
@Gr1f0n6x, please use a variable reference.
@SuppressWarnings("garbage") is not needed.
@SuppressWarnings("garbage") is never used.
You can just call throw new Exception("garbage") here.
I think this should be: java super.init(scene);
I think this should be: java super.init(settings, context);
I think this should be: java super.init(settings, this);
shouldn't this just be public? it's only used by ActiveMQDestination constructor.
Should this just be public ActiveMQDestination()
shouldn't this just be public? it's not used outside of the class.
HTTP_HEADER_CSP
HTTP_HEADER
HTTPHeader
If you use a comparator you could simplify this code a bit: assertThat(query.get column() > 1 >1Cte).setQuery(term(FIELD_timestamp).get() > 1.get()
If you use a comparator you could simplify this code a bit: assertThat(query.get column() > 1 [] {... }
If you use a comparator you could simplify this code a bit.
ins't KEY2STRING_MAPPER missing?
ins't KEY2STRING defined?
ins't KEY2 supported by all auto-persists
Formatting
Formatting note: indentation is 2 spaces
Formatting!
We do not need to call it backoffMs() at all, so we don't need to pass backoffMs back to the constructor.
I'm not sure the replacement changed here. This is correct: <LINK_0>
Any reason we keep the old constructor of the class?
Is it possible that two parameters are empty at the same time?
Use one-liner style.
Is it possible that two parameters are the same?
This line can be replaced with java return Version.toLowerCase(Locale.US).endsWith("")).toLowerCase();
This line can be replaced with java return Objects.equals(currentVersion, previousVersion);
This line can be replaced with java return Version.toLowerCase(Locale.US).endsWith("")).toLowerCase().substring(1)
suggestion return super.getCannedACL();
suggestion return "canned ACL value",
suggestion return cannedACL.getCannedACL();
Since we're only using this method, just call the method like this: java ResourceVerifier.verifyAttributeVisible(address, value);
Since we're only using this method, just call the method like this: java ResourceVerifier.verify(address, value);
Since we're only using this method, the code should be able to refactor the method that uses ResourceVerifier instead of getInstance.
Why so complicated? Why not LOGGER.debug("Could not process citation", e");?
Why so complicated? Why not LOGGER.error("Could not process citation", e");?
Why so complicated? Why not LOGGER.error(grobidService.ConsolidateCitations());?
Think this should be private.
Think this should be private and called from the configure method below.
Think this init method should be private.
Please make this public
public
Please make this private
This line seems to be unnecessary. And I don't think we need a line break at all.
This line seems to be unnecessary? And I don't understand why we need a flatMap in this case.
This line seems to be unnecessary
This is a weird place to add a listener.
This is a weird place to add a listener. But it's ok to ;)
This is a weird place to add a member variable.
Since there's a potential bug here, suggest that the logic added to the UserHandleManager instead of having a LocalBroadcastManager, when we want to retrieve the pPanMode, I suggest: java if (current == null) { return; } if (current == null) { // No need to override the logic }
Since there's a potential bug here, suggest that the logic added to the UserHandleManager instead of having a LocalBroadcastManager, when we want to retrieve the pPanMode, I suggest: java if (current == null) { return; } // Should the logic be in onCreate instead of here?
Since there's a potential bug here, suggest that the logic added to the UserHandleManager instead of having a LocalBroadcastManager here.
Migration::size is redundant.
Migration::getId
Migration::has
You must be able to replace this with c.close() since it's not the one that's must.
You must be able to replace this with c.close(c) since it's not the one that's must be closed.
You must be able to replace this with c.close(c) since it's not the only place that calls close()
Is this threadsafe?
Is this intended to be package-private?
Is it okay to initialize this this?
Looks like a good candidate for a GResourceManager to be able to use the same package as GResourceManager.LIBRARIES_LIBRARIES_LIBRARIES.LIBRARIES_LIBRARIES
Looks like a good candidate for a GResourceManager to be able to use the same work as GResourceManager.LIBRARIES_LIBRARIES_LIBRARIES_LIBRARIES_LIBRARIES
Looks like a good candidate for a GResourceManager to be able to use the same work as GResourceManager.LIBRARIES_THREAD_FILE_PATH
why not make DbFacade.getInstance().getQuotaDao() field?
why not make the getInstance().getQuotaDao() private?
why not make an array?
Easier to use a static import for this field.
Easier to use a constant of this class.
Easier to use a static import for this method.
you can use here VmValidator.getVmNotLocked()..
you can use here VmValidator.isVmNotLocked()..
you can simply use getVmValidator()
Can you import this method please?
Can you import this method and use it from below?
Can you import this method and use that instead of casting?
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
Why overriding it here? If you don't really want to add, don't initialize the variable when it is declared and use copyOf here.
Why do you use a Builder here? If you don't really want to add it here, I suggest using Arrays.asList() as it will be much more efficient.
why not use isEmpty()?
why not use.isEmpty()?
Why not use isEmpty()?
don't you want to use a newly added method to get the resource request?
don't you want to use a newly added method to get the resource request
This block of code is already handled.
@njhill, some more digging this code is exactly the same as _this.logger.error(message, message, message)_...._...._....
@njhill, some more digging this code is exactly the same as _this.logger.error(message, message, message)_...._...._...._....
@njhill, some more digging this code around. I think it needs to be in this way: if (logger.isDebugEnabled()) {... }
Since AbstractForm.equals already checked in AbstractObject at the end, AbstractObject in fact, AbstractObject in this case the method should be AbstractForm.equals (in fact AbstractObjectize) so at the end the previous line can be removed.
Since AbstractForm.equals already checked in AbstractObject at the end, AbstractObject in fact, AbstractObject in this case the method should be AbstractForm.fromToken(String in) and AbstractObject in fact, AbstractForm.java needs to be modified.
Since AbstractForm.equals already checked in AbstractObject at the end, AbstractObject in fact, AbstractObject in this case the method should be AbstractForm.fromToken(String in) and AbstractObject in fact, AbstractForm.java needs to be changed to AbstractObject.
You don't need a new ArrayList, you can just use the TradeList directly.
You don't need a new ArrayList, it's just a set.
You don't need a new ArrayList, you can just use the 'null' member.
Should the same issue as before?
Should we assert the principalDecoder is null?
Should we assert the principalDecoder is null too?
Just a small remark: Why do we need to catch LargeObjectException instead of getCachedBytes? Also other methods in LargeObjectException and LargeObjectException are not supposed to be used? Are there cases where getCachedBytes() will work for them?
Just a small remark: Why do we need to catch LargeObjectException instead of getCachedBytes? Also other methods in LargeObjectException and LargeObjectException are not supposed to be used for max length of them. Maybe we should just move this method to the LargeObjectException.
Just a small remark: Why do we need to catch LargeObjectException instead of getCachedBytes? Also other methods in LargeObjectException and LargeObjectException are not supposed to be used for max length of them. Maybe we should just move this method to LargeObjectException.
nit: we could put this down to the top of the class
nit: we could avoid this +1 here and the long-line are doing the same thing
requireNonNull
I know this is not related to this PR, but looking at the code this method that is used to check the name variable. Shouldn't it be getKieServerInstanceAccount instead?
I know this is not related to this PR, but looking at the code this method that is used to check the name variable. Shouldn't it be possible to skip the presence of the name?
I think this method could be static and reused.
Can you add a check that the fields are not null before the get call?
Can you add a check that the fields are not null before the.get() call?
Can you add a check that the new fields are not null before the.get() call?
Safer to do this only if the URL is changed.
Safer to change: <LINK_0>
Safer to do this.
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
You can do this? return SanitizationHelper.sanitizeForHtml(name);
You should not do this. The unsanitized name only presents problem when displaying it.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
what's the point? The method seems to return false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your change.
LOG.error("Failed to open {}, size {}, offset {}: ", path, e)
LOG.error("Failed to open {}, e)
LOG.error("Failed to open {}, e) - ", path, e)
I'm not sure the following is correct here. Square assumes that the if statement is true, and if a entity is being checked, the code should be: if (!isPassable() &&!entity.isPassable() &&!entity.isPassableEntity()) { throw new RuntimeException("Cannot add second impassable entity to " + Square); }
I'm not sure the following is correct here. Square assumes that the if statement is true, and if a entity is being checked, the code should be: if (!isPassable( entity)) { throw new RuntimeException("Tried to add second impassable entity on impassable entity"); }
I'm not sure the following is correct here. Square assumes that the if statement is true, and if a entity is being checked, the code should be: if (!isPassable() &&!entity.isPassable() &&!entity.isPassable() &&!entity.isPassableEntity()) {
Just calling this here is unnecessary, initialize it in the constructor
Just calling it here is unnecessary, initialize it in the constructor
Just calling this here is unnecessary, or?
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if...)
Why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if...)
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if...) This makes sense.
Can be simplified to return this.values.count() < size
Can be simplified to return this.values.count + 1
Can be simplified to return this.values.count() > 1
I'd rather have written = channel.write(buffer); try { written = channel.write(buffer); } finally { written = channel.write(buffer); }
I'd rather have written = channel.write(buffer); if (isSendComplete()) { written = channel.write(buffer); } written = channel.write(buffer);
I'd rather have written = channel.write(buffer); return written;
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Could we store this in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the current class.
Why is this needed?
Why need this.
Why need this..
This isn't needed - driver.
This isn't a big deal, but I generally prefer to keep a reference to the Java object directly, rather than a class object.
This isn't a big deal, but I generally prefer to keep a reference to the Java object directly, instead of a real object here, as for me it seems like a waste of resources
I know that this class is use forstringify in the base class but I'm not sure if it is worth to move back into ParamUtils class.
I know that this class is use forstringify in the base class but I'm not sure if it is worth it.
I know that this class is use forstringify in the base class but I'm not sure if it is worth to move back to ParamUtils class.
Can we please keep the class name the same. It looks like you did for the other methods.
Can we please keep the class names the same. It's a little confusing to me that these methods are the same.
Can we please keep the class name as a class variable? Maybe import the method?
Unnecessary change
Unnecessary /
Unnecessary / above?
Or use Objects.requireNonNull, this is a null check before the call to super.getComponentName.
We should return the name of the getter, not the super.
And why is this protected?
whitespace
these 2 conditions can be merged
whitespace :/
"else if" is redundant here
"else if" is sufficient?
"else if"?
Thoughts on changing this from using withContext and a Map to how the other methods are doing it?
Should this be in a helper method?
Should this be in a try-catch block?
It seems to me that the.edgeSchemas() can be moved inside the try block, since we're doing a no-op here and an exception will be thrown all the time. So leside exception shouldn't be wrapped.
It seems to me that the.edgeSchemas() can be moved to a dedicated method, since we're doing a lot of work multiple times. I would prefer to have a method like getInVertex, or.edgeSchemas(); instead of uniQuery.getProperties()
It seems to me that the.edgeSchemas() can be moved to a dedicated method, since we're doing a lot of work multiple times. I would prefer to have a method like getInVertex, or.edgeSchemas(); instead
I think we need to fully qualified these names, otherwise, the context would not be visible in the current context.
I think we need to fully qualified these names, otherwise, the codebase will be appended properly when the context is not available.
I think we need to wrap these lines with lambdas, otherwise it will be hard to read
Why assertEquals()?
Please use assertEquals instead.
Please use assertEquals instead
:+1: this could probably be an Optional<PrimitiveType>
:-1: just a null check.
:-1:
Does this need to be a list or can it be list?
Does this need to be a list or can it be a list?
Does this need to be a list or can it be just for loop?
Should we deprecate the old constructor?
Should we consider protected to be package private?
Should we add non-null assertions here?
Same as tapTarget -> tapTarget
Same as tapTarget. Shouldn't we change the equals to target?
Same as tapTarget -> navigateTarget
Change to BadRequestException. An object is a BadRequestException but don't have a supported request type
Change to BadRequestException?
Change this to BadRequestException.
This should be synchronized.
Can we cache metric name in metric?
Should this be public?
Maybe include the buffer's getInputStream().length in the message?
Maybe include the 'position' in the message?
Maybe include the buffer's getInputStream().
Would be better to use storageDomainDao.get(GlusterStorageDomainDao.class);
Would prefer to use storageDomainDao.get(GlusterStorageDomainDao.class);
Would be better to use storageDomainDao.get(GlusterStorageDomainDao.class)
this seems wrong. now you keep track of the last one and not the first one.
this seems wrong. now you keep track of the last one and not the last one.
this seems wrong.
Must be great.
Must be great, just to use the previous case.
Must be great, just to use the working world instead.
I don't like the idea of this... @romani What is your thoughts? Why isn't this left in the same scope?
I don't see why this is static?
I don't like the idea of this.
Could you avoid these awkward blocks by making numerator and denominator an AtomicLong?
Could you make numerator and denominator an AtomicLong?
Could you avoid these awkward blocks by making numerator and denominator.
This is a bit confusing, as it's not a Set<Vector>, but rather a Map<String, Object>.
This is a bit confusing, even if the bit is a Set. What's the purpose of this change?
This is a bit confusing, as it's not a Set<Vector>, but rather a Map<Boolean, Object>.
statusCode is never null, just delegate to statusCode.
statusCode is never used? And it can be removed.
statusCode is never used?
Is it possible for the object to be null? The only non-null object is the check done in the constructor, so it can be: if (obj instanceof OldObject && (obj instanceof DummyObject)) { return false; }
Is it possible for the object to be null? The only non-null object is the check done in the constructor, so it can be: if (obj instanceof OldObject && ((Object) obj).equals(obj)) { return false; }
Is it possible for the object to be null? The only check if the object is instance of the object, without checking for instanceof.
Let's check the exception message too!
Let's check that exception is thrown.
Let's check that exception is thrown
One thing to think about here is that the Subject from token.getSecurityToken() will throw an exception. In the case of null, we will end up with a null SecurityException. So we should log the exception here.
One thing to think about here is that the Subject from token.getSecurityToken() will throw an exception. In the case of null, we will end up with a null SecurityException. So we should log the exception message here.
One thing to think about here is that the Subject from token.getSecurityToken() will return null, so this might not be caught. In general, in general, we should log the exception here.
suggestion assertThat(actual).s).hasMessage(consumers);
suggestion assertThat(actual).s).contains(consumers);
can use assertThat(actual).s()).hasMessage(consumersatisfy(consumers)); the same for other methods
Is this needed? Removing it should work as well
I don't like this change. Removing it should work as well
I don't think it is necessary to create a new UserUserSettingsFactory here.
final?
final as well.
final
My suggestion is to have a single private static final Logger logger = Logger.log("CaseDbSpec: {}", reference resolution, reference resolution will do the trick.
My suggestion is to have a single private static final Logger logger = Logger.log("CaseDbSpec: {}", reference resolution, reference resolution will do the job.
My suggestion is to have a single private static final Logger logger = Logger.log("CaseDbSpec: {}", reference resolution);
It would be nice to be consistent and not return null if it is not found.
It would be nice to be consistent and use a constant to be between the name and the criteria.
It would be nice to be consistent and use a constant to be between the name and the value of the URL.
If vxLanPortIds is null, it's an empty list.
If vxLanPortIds is null, we'll return an empty list.
If vxLanPortIds is null, it's a NullPointerException.
fullName should be enough here too.
Should we just return simpleProperties.getSimpleClassFactModel();?
fullName should be enough.
you are testing java (b1).css("display"); (b1).css("display");
you are testing (b1).css("display"); (b1).css("display");
you are testing (b1).css("display");
Objects.requireNonNull()
needs to be public
requireNonNull
Null check instead of Optional if it's null
Null check needed here
Null check instead
times(1) is the same in other tests, can we extract a variable to improve readability?
times(1) is the same in other tests, can we extract this to a variable?
final is not needed
We could assert that the DRepresentation is not null
we could assert that the DRepresentation is not null
we could assert that the DRepresentation is null
put lock() before try
add a log here?
put lock() in a finally block
can you use a different debug message for this case?
can you use a different meaning?
can you use a different debug message for the test?
rename to pack
rename to action
rename to fragment
Can we assert that the result is empty?
Shouldn't we assert that the result is empty?
Can we verify that the result is an empty set?
I'd say createClusterConfiguration(this.serverConfiguration, "Cluster URI cannot be null"
This is missing the value.
This is missing the validation.
If I understand this right, the state machine cleans itself up after it disconnects?
If the state is set to null, the state can be set to null.
If the state is set, the state can be set to null. I'm not sure this is necessary.
It seems that both of these else if statements are redundant.
It seems that you introduce a local variable for that value and use it in both cases.
It seems that you introduce a local variable for that value and use it in both if/else.
Is it possible to use result.isFailed to stop watch.
watch = null?
Move this into the try block.
Use the one-argument version of convert, two arguments for the second one.
progress.split(1)? Interestingly, the counts seem to off quite frequently. Here you convert 5 seconds to 5MB lines below under a single monitor. Maybe you should convert the number of progress into a SubMonitor in the base loop.
progress.split(1)? Interestingly, the counts seem to off quite frequently. Here you convert 5 seconds to "4 of 3" or "6" in the proper order. The whole monitor should be progress, not SubMonitor.convert(monitor,MakeProjectRunner.IProgressMonitor)
Move line 78 to 'if'
Move the logic up to the line 78 to 'if'
Move line 78 to 'if'.
This seems to be the same as cipherInformation == null?
This change seems incorrect. It should be cipherInformation == null?
This seems to be the same as cipherInformation == null.
Shouldn't this be public?
Shouldn't the parent be -1?
Shouldn't this be ForestryCommand parent.type?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
I'm in favor of just using a LinkedList and remove during the iteration..that's unneeded.
I'm in favor of just using a iterator and remove during the iteration..that's unneeded.
perhaps, but I would rename that method to shouldShowAnnotationsAllowMissingJavadocMessage and make clear.
perhaps, sincet is a switch?
perhaps, but I would rename that method to ex.
remove this empty line
remove qualified name
remove import
We probably need to set the defaultSearchStepNumber to make it clear that this value can actually be null.
We probably need to set the default specified in the properties file.
We probably need to set the defaultSearchStepNumber to make it clear
please move to line 91, directly before runInternalAction
please move this to the top of the method.
please move to end of method.
Should it be allMatch?
Should it be UNKNOWN if the session is null?
maybe its worth adding <?> method as well
Style issues: This line can be removed: java Subscriber<SynchronizeDataSet> setSubscriberMethod(new GitSynchronizeDataSet());
Style issues: This line can be removed: java Subscriber<SynchronizeDataSet> setSubscribers = new GitSynchronizeDataSet();
Style issues: This line can be removed: java Subscriber<SynchronizeDataSet> setSubscriber in this case.
FYI something like this is typically the above code, do you think it is possible for two different PRs to avoid the null checks?
FYI something like this is typically the above code, do you think it is possible for two different PRs to avoid the null checks? It makes no sense to do this.
FYI something like this is typically the above code, do you think it is possible for two different GuideEnvironment to encapsulate this?
Should we use one of the core executors here?
Should we create a method for it?
Should we create a constant for "cacheManager"?
I think the second arg should be the first one
I think it is better to have the class name in the first place i.e. new ParquetValueScheme()
I think the second arg should be the first one.
:disappointed:
This will need to be called for every serverRoute?
This will need to be called for every connection or event.
The ReviewView should be created by the constructor. That way, you don't need this.
You don't need this. The ReviewView should be passed in through the constructor.
The ReviewView should be created by the constructor. That way, you don't need this initialization code.
This doesn't seem to be correct.
This can be null any more.
This should be final
suggestion lines.setFormat(this::lineNotInExcluded);
suggestion lines.setFormat(this::widget);
suggestion
return getA() && return true;
return getA() & 0xffc_TO_BEAN
return getA() & 0xff
Again, return "" + create?
String.format?
Again this logic is broken.
You may want to put "[R" here
You may want to put "[R" here.
You may want to put "[R\n" here
The final modifier could be here: if (actionCommand!= null && actionCommand.canBeAdded()) { return guiComp.canBeAdded(); } else if (actionCommand!= null && guiComp.canBeAdded()) { return guiComp.canBeAdded(); } else { actionCommand = null; }
The final modifier used here is not needed.
The super.. is unnecessary here.
Use unmodifiableSet instead.
Use unmodifiableSet instead of a set.
Use unmodifiableSet instead of a new ArrayList
UseunmodifiableList() instead.
Use this field instead, it's unnecessary.
Use LinkedHashSet instead of a HashSet
I am wondering if we should updateHostList to be able to use a new host list instead of modifying it in-facts of the searchHostList. In other words, can we change the scope of this PR to reflect the change?
I am wondering if we should updateHostList to be able to use a new host list instead of modifying it in-facts of the searchHostList. In other words, can we change the scope of this PR to reflect the change?
I am wondering if we should updateHostList to be able to use a new host list instead of modifying it in the DB. In other words, do we need this listener?
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
OK, so maybe at least just write it to the end of the VM. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging. But at least info in the future, at least warn the user.
@gianm can you clarify that valueOfMethod.invoke(null, "valueOfMethod") is not supported?
@gianm can you clarify why we cast the return value to int?
Shouldn't it be valueOfMethod.invoke(null, text);?
add deleteOnExit() after creating files.
add finally block to finally block
add deleteOnExit right before creating files.
This should probably just be java if (!isConnected()) {... }
This should probably just be java if (!isConnected()) { return false; }
This should probably just return the http status code and let the client do it.
You don't need to synchronize this method. In fact you can make this method synchronized as you are setting it to null in the base class.
You don't need to synchronize this method. In general, you can just make this method synchronized.
You don't need to synchronize this method. In fact you can make this method synchronized as you are setting it to true and "this" does nothing.
Magic value?
[minor] This should be safe.
[minor] This should be static.
This should be System.lineSeparator()
This should be Pattern.compile.
This should be Pattern.compile("Cookie")
Why are we setting both "biologicalMetric" and "biologicalMetric" in this test class? This seems like the wrong place to me.
Why are we setting both "biologicalMetric" and "biologicalMetric" in this test class? This seems like the wrong place to me. I'm not checking both params in this test.
Why are we setting both "biologicalMetric" and "biologicalMetric" in this class? This seems like the wrong place to me.
Please extract the for each loop to a separate old school for each loop
Please, use the for each loop that the list is initialized.
Please reformat the code using.duplicate()
I think we should have a message for fail("") here, or NPE instead of assertNull(x)
I think we should have a test for this one, or am I wrong?
I think we should have a message for fail("") here, or NPE instead of a NULL
getById
constant
getNonNull
you can just do return startTimestamp > getStartTimestamp();
Pull this out of the constructor
you can just do return startTimestamp > getStartTimestamp()
I think this should be: if (getContext().getPrincipal().getName().equals(status.getUsername()))
I think this should be BulkStatus.UNKNOWN
I think this should be BulkStatus.UNKNOWN.
I think it should be better to use VariantErrorStatus.NOT_FOUND.
I'd prefer not to use VariantErrorStatus.REQUEST. VariantErrorStatus.NOT_FOUND.
I think it should be better to use VariantErrorStatus.NOT_FOUND instead of null?
Is the following line correct? public static void stub(String tableName, String storeName) { // do stuff }
Is this correct?
Is this the right method to return true?
Can't we use.submit() as done in line 59?
Can't we use.submit() as the argument?
Can we use AssertJ?
The file is missing ".."
The file is missing "file".
The file is missing ".." file.
@super132 I don't think we need to do this on the other line.
@super132 I don't think we need to do this on the other line, too.
@Override is missing
Revert or add more details
Revert or remove this?
Revert or add more details here.
EurekaClient should be provided as a wrapper of both EurekaClient and EurekaClient.
EurekaClient should be provided as a wrapper of both EurekaClient and a EurekaClient.
[optional] This can read as a [this](<LINK_0>
Shouldn't this be using the default implementation of the interface?
Shouldn't we use the same object for all the other properties?
Shouldn't we use the same object for all of these properties?
This is unnecessary, given that tokenClient1 and tokenRequest are already set in the next line. There is no need for this.
This is unnecessary, given that tokenClient1 and tokenRequest are already added in tokenClient1
This is unnecessary, given that tokenClient1 and tokenRequest are already set in the next line.
Is this method really intended to return true?
Is this method really intended to return true? I don't see anything in the original code.
Is this if test is disabled?
This would seem redundant since the synchronized block above will handle the null case.
This would seem redundant since the synchronized block above will handle the null check in a separate synchronized block.
This is a bit weird to have it happen that any threads might see the table and buffer is empty.
suggestion return UtilMethods.isSet(filterKey) && filterKey.getOrDefault(filterKey,defaultFilter);
suggestion return UtilMethods.isSet(filterKey) && filterKey.getOrDefault(filterKey, defaultFilter);
suggestion return UtilMethods.isSet(filterKey) && filterKey.getOrDefault(filterKey, defaultFilter.values());
use String constant? :)
replace String constant? :)
typo
Check error code/description
Check that both URL and url are different. It is not possible to use constants here.
Check that both URL and url are different. Will be easier to use constants here.
This could be simplified to if (target!= null && target.isInstance(target)) { return target; } return this.isInstance(this);
This could be simplified to if (target!= null && target.isInstance(target)) { return target; } return this;
This could be simplified to IState.isInstance(target)
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "jobId". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "jobId". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this use of "jobId". [![rule](<LINK_2>](<LINK_0>
Why isn't this missing an exception?
Why isnt this missing an exception?
Why isn't this missing an exception?
It doesn't seem to make sense. Couldn't you just stopAllGrids in the test?
It doesn't seem to make sense. Couldn't you just stopAllGrids in the container?
Maybe just append afterTest =?
For async methods, exceptions should be passed into the base class.
For async methods, exceptions should be passed in the parameters.
For async methods, exceptions should be passed into the ObjectHelper class
You can use add() instead of sleep(). The test fail fast and it doesn't wait for anything.
You can use add() instead of sleep(). The test fail fast and it doesn't wait for any time.
You can use add() instead of sleep().
I think instanceof ryaType should be false here. Even though you're not implementing your own ryaType, it should be = ((ryaType) o;
I think instanceof ryaType should be false here. Even though you're not sure about that. I think it should be null-safe for ryaType to be null.
I think instanceof ryaType should be false here.
Can return directly.
Can we return directly here?
Can return directly, without need to save a local variable
don't return null, add a null check in the constructor.
don't return null, add a null check.
don't return null, instead pass null as the constructor parameter.
input is not @Nullable, remove annotation or add null check.
input is not @Nullable, remove annotation or use null check.
input is not @Nullable, remove annotation or add null check
This needs to be an update of the interceptor
This needs to be an AtomicBoolean
This needs to be an update of the latch
context -> digest?
context -> client
context -> context
This should be protected.
can we call this constructor from different builder?
should we call FeignTarget instead?
I don't think it should be this.
I don't think it should be public, it should be package protected.
Unnecessary?
This is getting long, wrap wrap the arguments
This is getting long, wrap the arguments
This is unused.
pass null for metadata and throw IllegalArgumentException if metadataMap is null
I don't think you need to catch here as this exception will be handled by the caller
I don't think you need to catch here as this exception will be handled by grate.
HttpServletResponse.SC_NOT_FOUND
HttpServletUI.SC_NOT_FOUND
HttpServletUI.getInstance() can return null
Why not just use stateTableIndex < 0?
Why not just use stateTableIndex < 0?
Why not just put else if around?
Is it possible to use.getSamzaContainerContext() instead of.getInstance()?
Is it possible to use.getSamzaContainerContext() instead of.size()?
Is it possible to move this line down to the top?
Remove this code from the underlying lookup.
Remove this code from the underlying converter.
Remove this code from the method and simply invoke this method from here.
consider extracting this into a method like getSingleBatchWithTimePeriod().
consider extracting this into a method like findSingleBatchWithTimePeriod().
consider extracting this into a method like findSingleBatchInGivenTimePeriod()
you should use getDbFacade().getEngine() instead of this code
you should use getDbFacade().getEngineSessionDao() instead of this code
you should use getDbFacade().getEngineSession() instead of this code
We could have the variable declaration and just use return decoratorClass.newInstance();
We could have a variable declaration and just use return decoratorClass.newInstance();
We could have the variable declaration and just use return decoratorClass.newInstance(getClass().getClassLoader());
reopening -> openClientConnection
reopening -> open
reopening -> openClientConnection.
You can just call this.metadataKeys() here.
You can just make this return an void
You can just make this return a boolean.
Use a constant for empty strings.
Use a constant for empty string.
Use a constant instead of empty string.
public?
this method should be private, so that it is only used in tests.
this method should be private, and only use it in the public interface.
Idea for improvement: Map<String, String> partitionSpec = ExceptionUtils.parse(LinkedHashMap<String, String>).and(LinkedHashMap<String, String>)..
Idea for improvement: Map<String, String> partitionSpec = ExceptionUtils.emptyLinkedHashMap( partitionSpec, Exception.class);
Idea for improvement: Map<String, String> partitionSpec = ExceptionUtils.parse(LinkedHashMap<String, String>)?
Could use Objects.setLabel(label) here instead.
Could use Objects.setLabel(label) here.
Could use StringUtils.isBlank here.
Can these loggers be guestbookResponse to be consistent?
Can these numbers moved to constants?
Can these constants be moved to the blocks?
what about bandwidthLimit is available?
Please add a space between the strings
Please add a space
This should return true if the view is empty.
This should return true here.
This should return true if the view is null.
you can make the same optimizations here as you did with the other ones: java _metricRegistry.counter(classSimpleName, key, metricName).orElseGet(() -> new SimpleName); private static void checkCache(String name, String value, metricName, metricName).orElseGet(() -> { if (typeSimpleName == null) { throw new RuntimeException(e); } else { throw new RuntimeException(e); } }
you can make it protected, and remove the static import
you can make the same change to make the other change.
Shouldn't this be transactional?
Shouldn't this be transactional? Also, isn't it be transactional?
Shouldn't this be transactional? Also, isn't this be transactional?
I think this is too late. Need to use the constants from the SdkConstants class instead.
Nit: remove the?
I think this is an error, no?
Will need to check if siddhiManager.startTask returns true
Will need to check if siddhiManager.startTask is called
Will need to check format like below
I think this can be private
I think this can be checkNotNull
I think this can be private.
Generally it's better to do this in the constructor instead of protected to avoid potential race condition.
Generally it's better to do this in the constructor instead of private.
The pattern never used.
You could use the file.exists() method instead of contains().
You could use the file.exists() method instead of both.
You could use the file.exists() method instead of both using Path.
What about try-with-resources? Would it make sense to put the close() in the finally block and have it return a try-with-resources block?
What could happen if the result is empty? Wouldn't it be better to write a try-with-resources block?
What could happen if the result is empty? Wouldn't it be better to write a try-with-resources block and put a close() statement in the finally block.
What's the purpose of this line? I don't see any difference if the original method is void.
What's the purpose of this line? I don't see any difference if the original method is void
What's the purpose of this line? I don't see any difference if the url is correct or incorrect.
is this logical slot supported as the provided node?
is this a public API?
can't we make this return a List instead of a HashMap?
Can you please have a meaningful message here?
No need for null check
Please don't remove the public modifier
Concern: these changes are definitely "default map" operations... They can change and burned.
Concern: These changes to the callers are definitely passing the values to the filters collection. I wonder if this is better to return a Filters instead of a Filters.of()?
Concern: These changes to the callers are definitely passing the values to the filters collection. I wonder if this is better to return a Filters instead of a Filters?
I think you should also have if (this.context.getKeyword() == null) return; or else we have a thin chance to close the c's class. So I think you should also have if (this.context.getKeyword() == null) return; or else we have a thin chance to close the c's class.
I think you should also have if (this.context.getKeyword() == null) return; or else we have a thin chance to close the c's class. So I think you should also have if (this.context.getStartOffset()!= c) { c = c.offset(); } else { c = fItem(Integer.class); }
I think you should also have if (this.context.getKeyword() == null) return; or else we have a thin chance to close the c's class. So I think you should also have if (this.context.getKeyword() == null) return; or else we are not doing that somewhere in the constructor.
Assert.notNull()
Assert.notNull() to be safe.
Assert.notNull()?
trace
you could use tracef here.
trace?
Not needed, the next statement handles it in the DB.
Not needed, the next statement handles it in the DB
Not needed.
- you may want to replace this with the java ocList.size() == 0
- you may want to replace this with the java Collections.emptyList() - use ocList.get() to iterate over ocListRef
- you should call ocListRef - this method can be simplified to just ocList reference
1. what about committing the storage domain? 2. If you're committing the storage domain, what about the storage domain? 3. You should be able to append the disks and then have the same disks.
1. what about committing the storage domain? 2. If you're committing the storage domain, what about the storage domain? 3. You should be able to append the disks and then have the storage domain of the disks.
1. what about committing the storage domain? 2. If you're committing the storage domain, what about the storage domain? 3. You should be able to append disks of the disks and then have the same disks.
This can be done in one line.
This can be intersect with o.
This can also be done in the container object
Hm, I think you should also change this to a conventional explanation. _EditAppId = siddhiAppId._
Hm, I think you should also change this to a conventional explanation. _EditAppId = siddhiAppId;_
Hm, I think you should also change these to this.AppId = siddhiAppId.
Please use the following pattern:.append(SESSION_DIR, session.getId()).delete().toString();
Please use the following pattern:.append(SESSION_DIR, session.getId()).delete()
Please use the following pattern: user.getId().toString() + microServiceSession.get() + ".delete");
Can you throw the existing exception from the check to pass.
Can you throw the exception from the check to pass.
Can you throw the existing exception as well?
return new ArrayList<>(this.public);
return new ArrayList<>(this.size());
Collections.emptyList()
The name of the constant is misleading here.
The output here should be %d.
The output here should be mean the new job name is invalid
String name = NLS.bind("{0}/{1}", name);
String name = NLS.bind("{0}/{1}/{1}", name);
Use NLS.bind is not appropriate in new code
Make this a builder?
No need for this.
Drop this.
this probably should probably be catch (event.getTargetId() == GameEvent.MANA_PAID)
Use event.getTargetId() to catch GameEvent.MANA_PAID
this probably should probably be catch (event.getTargetId() == GameEvent.MANA_PAID) here
nit:.equals()?
nit: private?
nit:.equals()
Missing final
A missing space after comma
final
this should be in an exception
this seems to be incorrect
this should be in a FBNNode
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName");
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type);
You can use SUBSTUDIES to check its value.
You can use SUBSTUDIES.USER_SUBSTUDIES to be specific to test.
You can use SUBSTUDIES to be consistent with the other tests.
Can we put this in a constant?
Can we put this in a single line?
Can we put this in a @Before method?
This test does not appear to cover input data.
This Exception is not covered.
This test does not appear to test Exception.
AFAIK, this constructor should be protected (or at least protected)
return keySize;
AFAIK, this constructor should be protected.
suggestion } else if (a) {
Since you're already doing this check, can you make use of equals here?
Since you're already doing this, can you make the code more clean?
Why is this changed?
Why is this change needed?
Why does this use nested classes?
suggestion List<String> blobDetails = Collections.singletonList(dirPath);
suggestion List<BlobDetail> blobDetails = Collections.singletonList(dirPath);
suggestion LOG.info("Uploading container: {}", dirPath, containerPath);
Never call setAlternate() while holding a child.
Never call onNext while holding a lock.
Never call local variables directly.
Could you rephrase this to "if (client!= null)"
Could you rephrase this to "if (client == null)"
Could you re-throw this exception?
return false here?
return false here
return false
Have a check whether the target is an instance of the AnchorTarget type, that is more reliable?
Have a check whether the target is an instance of the AnchorTarget type, that is more reliable.
Don't do this, check to see if the target is an instance of the AnchorTarget type.
use Collections.EMPTY_SET
Boolean.EMPTY_SET
useEMPTY_SET
If you want to include the cause you should probably use checkArgument instead.
I would recommend UnsupportedOperationException instead of a generic Exception.
If you want to include the cause you should probably use checkArgument here.
we can remove the status variable by calling "return addEndpoint(endpointData, true);"
we can remove the status variable by calling "return addEndpoint(endpointData);"
we can remove the status variable by calling "return addEndpoint(endpointData.startTenantFlow());"
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
verify(fragmentMap.containsKey(id), "fragment id not in map: %s",id), id);
change this filter to.map(fragmentMap::get)
This class isn't set since it's the default values of a typo.
This class isn't set since it's the default values of a typo. I'd argue it's not set to "of least a maximum".
This should be a constant
Can we have a default if for all exceptions?
Can we have a default if case for the ObjectMapper?
Can it be extracted to a constant?
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'd want to override the DurationLink EditParts)
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshSomething() methods should be usually called #refreshSomething() or something.
actually, the clearCache() is only used for these types. Should it be set to null here?
actually, the clearCache is evicted by the descriptor. Do we want to keep this?
actually, the clearCache is evicted by the descriptor. Should we instead use the method clearCache()?
You need to save the object creation as well.
You need to also store object in codec.encode(object, codec)
You need to also store object instance as a member variable.
better collect all XML files in the name.
@vilchik-elena This line could be replaced by a call to jpa
@vilchik-elena This could be better in a separate PR.
I'm not sure the right thing to do here - we are checking url by default. WDYT?
I'm not sure the right thing to do here - we should be checking Client BID as well.
<LINK_0>
Can you please use spaces between parameters?
Can you please use braces even for single line blocks?
Can you please use braces even for single statements?
This should be named setPort
Typo?
Typo? Seems unnecessary
Why are we returning all the results?
Can be reverted
Can be deleted
There are many other places in this class where we might want to be able to use / at least one time.
There are many other places in this class where we should probably be using ERO_Time rather than tickTime.
There are many other places in this class where we might want to be able to use / reference to the time.
We should not align on columns.
We don't align on columns.
We should not align on columns. HardSoftLongScore.ofSoftLongScore.
final
I suggest to return type here
Absolute path?
Style-nit: We don't cuddle catch with the closing brace on the same line.
Codacy complains here: "break;" is missing
please spell the type
the activity shouldn't be created here, but already created by the parent activity.
Why do we need to call newInstance here?
We can remove this.
error log will be more appropriate : LOG.error("Unable to expose RPS/JSON", e);
error log will be more appropriate : LOG.error("Unable to expose RPS/JSON failure field: {}", e);
error log will be more appropriate imo
s/public// This is not strictly needed here.
s/public//
s/public// This is not a good name.
filters method argument should be passed to isMessageInLogFile as an argument
filters method argument should be passed to isMessageInLogFile as an argument.
filters method argument should be passed to shouldMessageInLogFile as an argument
I think DEFAULT_BARRIER_TIMEOUT_MS and DEFAULT_BARRIER_TIMEOUT_MS are not used anywhere in the code base. You may want to consider using DEFAULT_BARRIER_TIMEOUT_MS here as well.
I think DEFAULT_BARRIER_TIMEOUT_MS and DEFAULT_BARRIER_TIMEOUT_MS are not used anywhere in the code base. You may want to consider using DEFAULT_BARRIER_TIMEOUT_MS here as well to avoid leaking out of static constants.
I think we should forbid null being passed in as well.
consider updating this to be a constant
consider updating this to avoid race condition when looping over the rest of the class
consider updating this to avoid race condition when looping over the response
Can we revert this constructor argument change for classes that don't implement ResultBearing?
Can we revert this constructor argument change for classes that don't implement ResultBearing? This method could be used to use the builder.
Is this method still needed?
This is repeated code and could be extracted to a constant.
This is repeated code and could be extracted to a method.
This is repeated code and could be moved to a constant.
you don't need to log it
you don't need to log and return
you could log in this method
@rui-castro Why this?
@Happy-Neko Same here. Can be package private.
@rui-castro even if this.target = tr; return tr;
I suggest to add a new method in the 'pushedVms' that calls the 'pushedVms'.
I suggest to add a new method in the 'pushedVms' that calls the 'pushVms'.
please add a new line
Here we need to validate the timezone: onedDateTime.parse(onedDateTime.ISO_DATE_TIME, "onedDateTime.WRITE_DATE_TIME)
Here we need to validate the timezone: onedDateTime.parse(onedDateTime.ISO_DATE_TIME, "onedDateTime.WRITE_DATE_FORMAT");
Here we need to validate the timezone: onedDateTime.parse(onedDateTime.ISO_INSTANT_MILLISECOND_DATE_FORMAT);
Remove
Remove empty line
Remove?
Remove entire wrapper finally block
Let's remove this try/catch block
Let's remove this catch block
I assume there is a problem with the expectation that the test should fail on the result of the assert.
I assume there is no need for this given that the assertSame checks for the null value.
I assume there is a problem with the previous assert.
Add a message to the exception.
Add some message here, to help debug issues.
Add some message to this exception.
What if the method has to be called with the new name?
What if the purpose has to restore?
What if the method has to be called from here?
I suggest to use Map<T, T>. This method is private.
I suggest to use Map<T, T>.
I suggest to use Map<T>.
Can you please explain why you don't use super.setCurrentPrincipal() here?
Can you please explain why you don't use super.setCurrentPrincipal(doc) here?
Can you please explain why you don't use super.setCurrentPrincipal(doc)?
I assume this can be hash.hashcode() and Objects.hash(position, sequence, hash); to use Objects.hash(position, items).
I assume this can be hash.hash(position, sequence, sequence, sequence);
I assume this can be hash.hashcode() and Objects.hash(position, sequence, sequence), but it does not check hashCode.
Why don't you use hamcrest matchers?
Why don't you use assertFalse(... )?
Why don't you use assertFalse(....)?
Keep the suggested implementation of this method for getting @Nullable
Keep as one line or refactor.
Keep the suggested implementation of this method via @Nullable
Maybe you can use something like Arrays.asList("en-US", "en-US"))
Maybe you can use something like Arrays.asList("en-US", "en-US")), nonUserNamespaces);
Maybe you can use something like ImgurImageFactoryConfig.getDefault() here?
I think this is slightly better. You may use Optional here.
I think this is slightly better.
I think this is slightly better. Please use a at least the field name.
make IOIterator a final class and use it here.
make IOIterator a final variable for this.hasNext()?
make IOIterator a final class and use it here and below?
Can you make this protected?
Can you please put this in a field?
Can you return this?
This should not be here, as we assert that the cause is a runtime exception.
This should not be here. Could you explain why we check for a fail method?
This should not be here
Can you keep the old constructor? I would prefer this(null, null);
Can you keep the old constructor? I would prefer this(null, non-null);
Can you keep the old constructor?
requireNonNull
You can use requireNonNull on all the parameters.
You can use this on the parent parent.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Rename "ann" to "rules", "rulesAnnotation" or something more meaningful.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive...
Must be Outcome.Benefit to keep good card
Must return true.
Must return false on code above.
This is not the same as the previous logging, let's remove this.
This is not going to be used, let's remove this.
This is not the same as the previous logging, let's avoid this.
At this point, we could use the builder with null.
At this point, we're repeating the image name from the image name. Instead we could say: Url configBuilder = this.imageBuilder.fromConfig(configBuilder.image(NO_IMAGE)? ConfigBuilder.build() : this;
At this point, we're repeating the image name from the image name. Instead we could say: Url configBuilder = this.imageBuilder.fromConfig(configBuilder.image(NO_IMAGE)? ConfigBuilder.build() : null;
I think you can use <LINK_0> suggestion list = new ArrayList<>(); list.add(SecurityConstants.AUTH_SERVICE_CONFIG_UPDATE_SETTING.length);
I think you can use <LINK_0> suggestion list = Arrays.asList(SecurityConstants.AUTH_SERVICE_CONFIG_PREFIX_SETTING.length);
I think you can remove the String setting here.
This is not thread safe. Consider returning a local variable.
This variable is not needed
This variable is not needed.
It would be good to keep the full name of the ExternalResourceConstants.EXTERNAL_RESOURCE_CONFIG_KEY_SUFFIX to use here.
It would be good to keep the full name of the ExternalResource.
It would be good to keep the full exception message for the ExternalResource.
same suggestion about static comparator
same suggestion about final Comparator<T> compare(Object o1, Object o2)
same suggestion about static comparator?
Does this mean if there is only one element in the group?
Does this mean the user has "sort" attribute?
Does this mean if there is only one element, we could make the code more complex?
Missing @Override
Missing @Nullable
Missing @Override annotation.
what is the new behaviour now that you don't setSucceeded to true?
what is the new behaviour now that we'll setSucceeded to true?
what is the new behaviour now that we're going to move to the end of the method?
Should this try { innerIterator.next() } finally { innerIterator.hasNext(); }
Should this try { innerIterator.next() } finally { innerIterator.next(); }
Should this try { innerIterator.next(); } finally { innerIterator.hasNext(); }
Let's put a space between if and (
Variable name is a little confusing; I prefer that the method name is a String
Variable name is a little confusing because it is called aliases
use changeAssertion.MERCURY_TAG_ATTRIBUTES_NOINDEX instead of hardcoding url.
use changeAssertion.MERCURY_TAG_ATTRIBUTES_NOINDEX to be consistent with new change
use changeAssertion.assertTrue(wikiURL.isRobots())
An exception without any messages or stack traces.
Should this be caught and put into the try block?
I think you should throw exception here.
The string literals should be stored in a constant, so it is more clear when you have this integer value.
The string literals should be stored in a constant, so it can be updated in the same place.
The string literals should be stored in a constant, so it is more clear when you have this and the other implementations.
Should this really be return Optional.empty()? It's never null
Should this really be an Optional<Reference>? It seems like you can still return null
Should this really be an Optional<Reference>? It seems like you can still return any value that can be null
Check if there is a field in Decimal in Decimals and as a string it will always be there.
move to field
move to field and make it a double, and remove the if
please make this final.
please use Collections.singletonMap
please give some meaningful name for the command
This doesn't count on the end of the method. I think there's a slight behavior to get actual number of upperBound - 1s. For example, 1s becomes a single long.
This doesn't count on the end of the method. I think there's a slight behavior to get actual number of upperBound - 1s, 1s)
This doesn't count on exception anymore, right?
Maybe it would be better to also check that the shape is either shape or ARRAY_SIE (Like is one of the standard values) :+1:
Maybe it would be better to also check that the shape is CharSequence, and the corresponding x coordinate. Also, you could have a default constructor that takes the shape and a array of shape and a builder to be added in the constructor.
Maybe it would be better to also check that the shape is CharSequence, and the corresponding x coordinate. Also, you could have a default constructor that takes the shape and a array of shape types. java this.shape = new IndexCoordinates(value);
Why these changes?
Why did you change this?
Why these changes are necessary?
We can use the following code to avoid anonymous inner classes when possible: java @Test public void testConnection() throws Exception { Connection conn = ConnectionFactory.getInstance(); try { Action action = ConnectionFactory.tmpDir(TEST_UTIL.class, USER_GROUP_READ, USER_GROUP_LOCAL); } catch (IOException e) { Connection conn = connectionFactory.getInstance(); try { ConnectionFactory.createTableStateInMeta(new TableState(TEST_UTIL)); } finally { ConnectionFactory.createTableStateInMeta(new TableState(TEST_UTIL)); } }
What are you trying to do with the import statement?
Should we use the USER_CREATE_DIR instead of USER_GROUP_READ?
It would be nice if the key could be valid at the beginning of the method.
It would be nice if the key could be valid at the end.
It would be nice if the key would be offset2's to be consistent with the old code.
This can throw if!request.getHeaders().containsKey(name)
This can throw if value is null.
This is not needed, I think
The version check should come before the call to this method
The version check should go before the call to this method
The version check should go before the loop
do we need to check for an empty list here?
the service name is not enough to filter out more than one thing, date or time
the service name is not the expiration name, but the name should reflect that
where are we doing the initialization blocking call inside a method, the Properties object is not thread-safe?
where are we doing the initialization blocking call now?
where are we doing the initialization blocking call inside a method, the Properties object is not good?
As discussed, please remove the Null values
As discussed, please remove the emoji map
suggestion emojiemoji;
I don't think it's necessary to clear the lifecycle here
I think it's clear enough to use the m lifecycle.
I don't think it's necessary to clear the lifecycle. Just clean up this.
I think this if-else block is too complicated for a very long chunk of code. For a simple if-else block it seems both we go here and in the very next line. I think it might be simpler to just say to add a single level of if-else without a ||, i.e. the following operation: if (isSubscription(pid)) { topicConstraintsCache.remove(fromQualifiedName(path)); } else { topicConstraintsCache.remove(fromQualifiedName(path)); }
I think this if-else block is too complicated for a very long chunk of code. For a simple if-else block, I think it could be simplified. We do not need to block a very complicated if-else block.
I think this if-else block is too complicated for a very long chunk of code. For a simple if-else block it seems both we go here and in the very next line. I think it might be simpler to just say to add a single level of if-else without a ||, i.e. the following operation: if (isSubscription(pid)) { topicConstraintsCache.remove(fromQualifiedName(path)); } else { topicConstraintsCache.remove(path); }
need to handle null case
isn't it possible for use of a String.toString() when calling toString()?
isn't it possible for a null case?
assertEquals(context.getFocus(), true)
assertEquals(context.getFocus(), true);
assertEquals
I think the default would be easier to read if it were in the method name _does_ have_ the default properties.
I think the default would be easier to read if it were in the method name _isPrivateRepository_
I think we should use the default properties we have in the no-args constructor.
You use this exact log message in the AuditLogger class, do we need a statement both places?
You already log an error if the message is null. Do we need this else statement?
You already log an error if the message is null.
Doesn't this line contain SchoolDataIdentifier? If this is an identifier, the two should be returned.
Doesn't this line need to be: SchoolDataIdentifierUtils.addLargeValue(dataSource, String)?
Doesn't this line need to be: SchoolDataIdentifierUtils.addLargeValue(dataSource, String.class)?
This is redundant in Mockito 2
This is redundant in Mockito 2 and it doesn't really matter, but it would be nicer if it was extracted to a method...
This code is redundant in Mockito 2
Should this be getGlusterStatus()?
Should this be brick.setStatus?
Should this be using getGlusterVolume()?
Can you a little worried about this method? It doesn't have to be called with the defaultDisplayRefreshRate, just to avoid doing it at the end.
Can you a little worried about this method? It doesn't seem to check if the defaultDisplayRefreshRate has a range of values. Wondering if it's better to just always make sure and do a 100ms delay for the time, even if it keeps sense.
Can you a little worried about this method? It doesn't seem to check if the defaultDisplayRefreshRate has a range of values. Wondering if it's better to just always make sure and do a 100ms, with a 100ms and just check the config flag directly?
Why not use stepExecution.getReadCount() here?
Why not use stepExecution.getReadCount() here as well?
Why not use stepExecution = Context.getReadCount() + stepExecution :
This should probably be checked here too
This should probably be checked here, and not throw an exception if something goes wrong
This should probably be checked here, and not throw an exception if something went wrong
Same here - dont pass the 'this'.
Same here - no need to fetch the 507 collection.
Same here - no need to fetch the 507, but not the next line.
Magic Number...
Couldn't this be extracted to a constant to avoid duplicating this literal.
Couldn't this be extracted to a constant to avoid duplicating this code?
This is not a test, and I don't understand why it tests :( Double.class, String.class, Boolean.class)
This is not a test, and I don't understand why it fails. The test will try to run with a different Blue Book I would say it should be something like "blue": not a HostnameVerifier"
This is not a test, and I don't understand why it tests :( Double.class, String.class, Boolean.class);
Can it be on the end of the method?
You don't need to catch NPE when input is null
You don't need to add a catch block to this.
This is the only place that calls getStoresDisabled. Why not just store.getStoresDisabled(store) directly?
This is the only place that calls getStoresDisabledCompaction() without running if the store is already enabled. Instead, if the store is not null, then the cache should remain unchanged. This will return false when the store is already acquired.
This check is redundant.
Should be meanSingular on the return type.
Should be meanSingular on the return value.
Should be meanSingular() not > player().
Shouldn't this be splitted?
Shouldn't this be splitted into several methods?
Shouldn't httpClient be closed too?
webhookSigningKey.isEmpty()?
If webhook is null, then you'll get a NPE.
If webhook is null, and an empty string is valid, throw error?
Doesn't this line compile?
Doesn't this line need to be "hej"}
Doesn't this line need the "component" parameter?
Maybe use Locale.ENGLISH instead of "win" here
Maybe use Locale.ENGLISH instead of Locale.ENGLISH?
Maybe use Locale.ENGLISH?
suggestion assertEquals(1, () -> {
suggestion assertEquals(1, () -> assertEquals(1, SECONDS));
suggestion assertEquals(1, "1");
can we make the building of the module a static final String?
can we make the unit test final please?
can we make the building of the module a static final field?
you can merge ifs here
I think you can merge ifs here
you can merge if and else if branches
Please log this exception.
please log this exception.
please catch specific exception(InterruptedException) instead.
Looks like some issue with static imports is worth to simplify the code.
Looks like some issue with static imports.
Looks like some issue with static imports is worth to simplify code.
Log and throw an error about using asserts
Log and throw an error about using assert.
Log and throw an error.
I don't think it's a good idea to use the message() here, since it's always the same
I don't think it's a good idea to use the message() here, since it's always a trace() message
I don't think it's a good idea to use the message() here, since it's always returning a response
The previous version was more readable now, not sure if it is.
The previous version was more readable now, not sure if it is any better :)
The original error message might be better?
need to use the constructor with a default value.
need to use the constructor with a default value of jpaQuery.
need to use the constructor with a default value of Integer.
This should be java return namedQuery((Long) query).uniqueResult();
This should be java return namedQuery((Long) query).uniqueResultEntries();
This should return a Long
Can you return directly the contentMD5 here?
Can you return directly the contentMD5 directly?
Slightly confused. Why are we returning an Object instead of Form?
Can we use Objects.equals instead?
Can we use Objects.equals here?
Can we use the Objects.equals methods here?
Suggest adding a new artifact to the artifact artifact
Suggest adding a new artifact to the artifact itself (e.g. "Artifact vs Arts")
Arts is not guaranteed to be a List according to the name.
As discussed offline, please use the log-only logger instead.
As discussed offline, please use the log-level formatting.
As discussed offline, instead of checking the log-only event for null-check, you could use the isDebugEnabled() instead.
Easier to say this. is it expected to be > 0?
Easier to say > this.
Easier to say > this. is it expected to be > this.
suggestion if (getArguments()!= null) { I know it's not part of the getArguments() call, but we can keep it consistent.
suggestion if (getArguments()!= null) { I know it's not part of the getArguments() method, but we can keep it consistent.
Override
should the constructor do the check here?
should the interface not the implementation suggestion public void setTopics(String partitions) {
should the constructor do the validation here?
1. you can just create vmDao with vmId, instead of calling Guid so you don't have to repeat it again in the test
1. you can just create vmDao with vmId, instead of calling Guid so you don't have to repeat it again in the call
1. you can just create vmDao with vmId, instead of calling Guid so you can use just "guid". 2. The vmDao should be injected in the test
I don't think we need the return type here.
I don't think we need splitting the return types in the next lines.
checkState
New to always use 0 here, even in this case.
New to always use 0 here, even in that case.
New to always use 0 here.
Oh! No! You have just introduced this setter :innocent: Why don't have this setter setId(id) as well?
Oh! No! You have just introduced this setter ;)
Nit: these setters should not be public
this can be condensed to one line
return true
return false
This is an interesting pattern of returning the list ofAccessControlList, not the list ofAccessControlList. I think you can write: java return accessControlList.stream().map(AccessControlList::getAccessControlList).collect(Collectors.toList());
This is an interesting pattern of returning the list ofAccessControlList, not the list ofAccessControlList. I think you can write: java return accessControlList.stream().map(AccessControlList::new).collect(Collectors.toList());
This is an interesting pattern of returning the list ofAccessControlList, not the list of ofAccessControlList. I think you can write: java return accessControlList.stream().map(AccessControlList::getAccessControlList).collect(toImmutableList());
It would be worth calling unmodifiableList() here instead of calling keySet().
what's the point of calling keySet() here instead of copying the values?
It would be worth calling unmodifiableList here instead of calling keySet().
This can be simplified to: return value == null? Boolean.valueOf(value) : Boolean.parseBoolean(value);
This can be simplified to: return value == null? Boolean.valueOf(value) : value;
This will return null, I think it should be Boolean.valueOf(value);
Typo: unlockSimpleLockServices -> unlockSimpleLock
Typo: unlockSimpleLockServices -> unlock
Why fakeThread
no need to call this variable
no need to return a variable here
no need to have this attribute here
Can't we use ObjectUtils.reflectionEquals(this, that); as <LINK_0>
Can't we use ObjectUtils.reflectionEquals(this, that.get()) here?
Can we use a custom object for the associated object?
This should be a static constant.
Could we use sessionId as the key?
This should be sessionId, not sessionId.
I guess you should use ctx.release() here
I think you should return ctx.channel.parent() at the end
I think you should return ctx.release() here
It seems this given statement is not necessary anymore.
remove this line
remove this line.
Maybe it would be nicer to return Optional<SessionEditor> here
Maybe it would be nicer to extract the getActiveEditor() into a method, and reuse it in the activeEditorPart class?
Maybe it would be nicer to return Optional<Session> instead of Optional<SessionEditor>
You could probably use seek(seek(position) here, right?
You could probably use seek(seek(position)?
You could probably use seek(seek(position) here instead of that.
Should be renamed to criteria, to be consistent.
Should be renamed to criteria, not nit
Should be an empty string.
either handle cocoa like carbon or remove carbon on the fly maybe change "cocoa" to "cocoa" by separate change before? carbon is unsupported.
either handle cocoa like carbon or remove carbon on the fly maybe change "win32" to "cocoa" by separate change before? carbon is unsupported.
either handle cocoa like carbon or remove carbon on the fly maybe change "cocoa" to "cocoa"? carbon is unsupported.
Shouldn't we keep the old message as well?
Shouldn't we keep the old message as a constant?
Shouldn't we keep the isOperationSucceeded()?
specific equals method
specific equals method is missed
specific equals would be clearer
If one of the two conditions is true, it may be slower, but it's not enough to have a null check.
If one of the two conditions is true, it may be slower, but it's not the same thing. Might be safer to use if (condition) { notifyProducer = null; } or add a null check.
If one of the two conditions is true, it may be slower, but it's not the same thing.
Please use getReader() here
Please use getReader instead in here
Please use getReader() here.
Please use Objects.hash() for consistency
You can use Objects.hashCode(config, spec).
You can use Objects.hashCode(config, spec) here.
declare throws please
declare throws please.
Could we declare throws please?
please extract the?: operator to a separate field
please extract the?: operator to a constant
these two could be merged
nit: e -> e.getValue().toString()
nit: e -> e
nit: e -> e.getMessage()
Missing!isAwake() &&!isAwake()?
!isAwake() &&!isAwake()?
!isAwake() &&!isAwake() as same condition
Why not just do getNumRubricRows(questionNum).findElements(By.id("tm-detail") here?
Why not just do getNumRubricRows(questionNum).findElements(By.id("tm-detail");
Why not just do getNumRubricRows(questionNum).findElements(By.id("tm-detail");?
You can use fNextStateChangeAction == null to prevent the next few lines below.
You can use fNextStateChangeAction == null to prevent the next job from being disposed.
You can use fNextStateChangeAction == null to check the state action.
Is it possible to use onLoad() instead of calling this method?
Is it possible to use onLoad() instead of calling this
Is it possible to use TextUtils.isEmpty() instead of cursor()?
null
null?
null => return
please use curly braces
you should just do warn
you should say warn
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value to this drug's none
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none concept
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value
Is this really needed?
Should we reset the postStop signal here?
Should we reset the post index here?
Please copy the checkers into a variable to avoid adding a new ArrayList.
Please put message with parameters to parameters.
Please put message with parameters to parameters
Can you put this on the same line as the method declaration?
Can you put this on the same line as the method implemented.
Can you declare those as static final variables?
Why do you need startsWith? AIDL_LAYERS_PREFIX here looks looks like it should be removed. Not sure why it needs to be modified in the future.
Why do you need startsWith? AIDL_LAYERS_PREFIX here looks looks like it should be removed.
Why do you need startsWith? AIDL_LAYERS_PREFIX here looks looks like it should be removed. Not sure why it is using the same pattern.
use an overridable getOperationTimeout() method instead
Please use an overridable getOperationTimeout() method instead
use an overridable getOperationTimeout() method instead?
could be replaced with Objects.hashCode(projectUuid, ceTaskUuid)
can be replaced with Objects.hashCode(projectUuid, ceTaskUuid)
can you use Objects.hashCode(projectUuid, ceTaskUuid) for this?
Do you think this may return null if map is empty?
Why don't you keep the map in the same scope as above?
Why don't you keep the map as a Set and return it for no reason?
Should we use JdbiOptionals.findFirst instead?
Should we use the DDBiOptionals.findFirstPresent here?
Should we use JdbiOptionals.findFirst rather than keeping null?
What is the reason behind this change?
seems to me like there is an order of parameters here... should be (should be dial) to debug level.
camelCase
why do we need a print here?
why do we need a copy here?
why the output?
I think it would be nice to have a more descriptive name. It's almost totally clear which variable is going on, but the formatter could look like: _We'd_ setMethodDescriptorRowsMethod_ (which was set on the local variable), this way, we'd only have to calculate on the value of onGetOptions().
I think it would be nice to have a more descriptive name. It's almost totally clear which variable is going on, but the formatter could look like: _We'd_ setMethodDescriptorRowsMethod_ (updateOptions)_ or - from here on elsewhere.
I think it would be nice to have a more descriptive name. It's almost totally clear which variable is going on, but the formatter could look like: _We'd_ setMethodDescriptorRowsMethod_ (updateOptions)_ or - from inside the if...
This is something that should not be applied to the returned map. The labels map should just return a Map<String, String>. java return new HashMap<>(labels).getLabels(), labels.getLabels(), labels);
This is something that should not be applied to the returned map. The labels map should just return a Map<String, String>.
This is something that should not be applied to the returned map. The labels map should just return a Map<String, String>. Maybe the returned Map<String, String>.
Remove
Remove System.out.println statements.
Remove this.
Rethrow CompletionStage<T>?
Rethrow this as a RuntimeException.
Rethrow CompletionStage<T> result = null;?
Minor: remove this or use a logger.
Minor: remove sysout
Minor: remove System.out
Wouldn't it be more robust to use a predefined charset such as UTF8?
Wouldn't it be more robust to use a String here? (that is, the same as the line)
Wouldn't it be better to use a constant for the arithmetic operation?
optional: can we rename this tovoidClass?
optional: can we rename the test to something like booleanThrows = new SetResponse(-1)
Can you rename the method tovoidContainsNull?
CCWL.x.kface.js
CCWL.x.kface.uri
CCWL.x.vface.uri
s/any(vmDao.getAllForVdsGrouped())/any()
s/any(vmDao.getAllForVdsGrouped())/any()/
s/any(vmDao.getAllForVdsGroup(), Collections.emptyList())/
Is this method supposed to return a list or immutable list? If this is the case that the getSCMSources() should return a copy of the list.
Is this return an empty list or is it intended?
Is this method supposed to return a list or immutable list?
as clickable, there is no need to wait for a string (this is the main method of this class) than a click(). I suggest to use this instead: <LINK_0>
as clickable, there is no need to wait for a string (this is the main method of this class) than a click(). I suggest to use this string in order to have it more transparent.
as clickable, there is no need to wait for a string (this is the same UI thread). It would be better to have this error message in the UI thread and see if it is open
UUID.fromString() could be replaced with UUID.compareTo(traceUuid)
UUID.fromString() could be replaced with UUID.compareTo(traceId)
UUID.fromString() could be omitted.
ArrayList<LogMessage> is confusing with localization friendly
ArrayList<LogMessage> is redundant with new ArrayList<>()
ArrayList<LogMessage> is confusing with new ArrayList<>()
we should not print the stack trace if we can ignore it.
we should not print the stack trace if we can find it.
I remember we normally swallow exceptions, but wrap them in Exception
Could you please give a tip in truth to this: if (fluid.getType() == fluid.STATIONARY_WATER && block.getType() == fluid.Type.AIR) {
Could you please give a tip in truth to this: if (fluid.getType() == fluid.STATIONARY_WATER && block.getType() == fluid.AIR) {
Could you please give a tip in truth to this: if (fluid.getType() == fluid.STATION && block.getType() == fluid.AIR) {
this can be inlined
assertion failure text > 0?
index difference?
Can we add this in a separate file as it is not sensitive to the user?
Can we add this in a separate file as it is not important to the user.
Can we add this in a separate file as it is not changed?
Could you rename baseUrl to getTaskOptions?
Could we constant something like baseUrl, baseUrl, r?
Could we constant something like baseUrl?
It can be null?
Could we add informationEntities?
Could we use informationEntities?
The synchronized block needs to be removed.
The need to runInternal() again is a no-op.
The need to be synchronized here.
suggestion (private void generateBuildRequires(StringBuilder buffer) {
suggestion (private void generateBuildRequires() {
suggestion m.append("BuildRequires(); ");
Please use String.join instead of parens.
Please use Joiner instead of + if you're doing it like: java this.ref = new String(ref);
Please use Joiner instead of +.
No need to check for the isnon null before this is called, interceptor.
No need to check for the isnon null here.
No need to check for the isnon null here, it is always false.
Should this method be static?
Should this be a singleton method?
Should this be a singleton method.
Remove this?
Remove this
Remove
No tabs please.
No tabs please. Use a more meaningful exception.
No tabs please - please.
This method should not be invoked in the ScenarioResolver constructor.
This method should not be invoked in the ScenarioTest.
This method should not be invoked before leaving the Overview.
Please use ternary operator here.
Please use getColorByClause(int) instead.
Please use getColorByTitle() instead.
What does this mean to you do not use feedLabels?
What does this mean to you do not use multiple feed ids?
What do you think about removing null checking and adding a map to class?
return new Object[] { new Object[ptr] }
return position.isNull()?
return new Object[] { new Object[ptr] };
can you write this and the following code a bit more readable: return dimValue == null? dimValue : dimValue;
can you write this and the following code a bit more readable: return dimValue == null? dimValue : dimValue.length() + len;
should this be private or package-private?
Why are we doing this so?
Why are we doing this.resource() here?
Why are you doing this so?
Should this be in the if/else chain?
Why not use streams here?
Should this be in the if() above, or else?
the annotation should not be public
the method should not be public
public
This is almost the same as isListEmpty(). I think that's the intention of this test - we should use just assertj assertions
This is almost the same as isListEmpty(). I think that's fine. We should use assertj assertions, please.
This is redundant, we should use assertj logger
This does not look right. Nothing to worry about a non-functional interface.
This does not look right. Nothing to worry about a non-functional/ref
This does not look right. Nothing to worry about a non-functional/ref.
same as before, loop 512
same as before, loop over metrics
same as before, loop over result.
Also need to put this in the first line of the method
Also need to put this in the first line of the method above.
nit: explicit map() should be the first thing we see in the list.
This date format is used in multiple places. Consider making this a constant.
This date format is used in multiple places. Consider making this a string constant.
This date format is used in multiple places. Consider making this a method static final.
s/public//
Is it possible to use this.getGroupIdCount() == 0?
:+1:
I think this should be getVdsGroupDAO().get(vdsGroup.supportsGlusterService());
I know this is not part of your patch, but I think we should do this only if initVdsGroupDAO() were called from the same way.
I think this should be setVdsGroupDAO().get(vdsGroup.supportsGlusterService());
There is no need to call cancelLongPress() here.
There is no need to call cancelLongPress() here
There is no need to call cancelLongPress on a lambda.
This can be simplified to just return bases[0] == '.' || bases[0] == '.'
Use bases.length - 1 instead of bases.length == 1
This can be simplified to just return bases[0] == '.' || bases.length <= 1
I think you could use Long.valueOf(topString).
I think you could use GWT's MAY here as well.
I think you could use GWT's getStringElement instead of this String
I'm a bit confused by this. All the other getters of this class do this check. I think you can have two constructors: containersMap = containers.stream().map(ContainerPlan::getId).collect(Collectors.toMap(container -> containers.getId(), containers::getId));
I'm a bit confused by this. All the other getters of this class do this check. I think you can have two constructors, one for example.
I'm a bit confused by this. All the other getters of this class do this check. I think you can have two constructors, one inside the public constructor, and one with the proper factory.
Is this going to be called from after the server startup?
Is this going to be called from after the server startup? What is the purpose of this monitor?
Is this being called from after the test? It doesn't seem to be that much, the default is reset to true.
I don't think we need to check Encountered while processing request. What you just want to do is to call Encountered while processing request.sendString is called only once?
I don't think we need to check Encountered while processing request :P
I get a NullPointerException here when status is null
Again, why are these casts needed?
Does this work with touch?
Again, why are these casts required?
The else if looks very complex, could you please move it to some helper method? Something like getPage("Only one modal dialog should be visible");
The else if branch is not necessary because of the if/else statement.
The else if looks very complex, could you please move it to some own method?
can we use this(delegates, selector, extractionFn).optimize();?
can we use this(delegates, selector, extractionFn); here?
is this used anywhere?
@dskalenko yes I have the idea why we need to load all modules from this class?
@dskalenko yes I have the idea why we need to load all modules from this class? This means we should have a single method available for all of the runtime config classes.
@dskalenko yes I have the idea why we need to load all modules from this class? This means we should have a single single method available for all of the runtime config and load.
why this?
why this is a String, not a boolean?
why?
I'm not sure it is the right place to add the new version. It is the old one, why not just pass the cluster compatibility version in the migration?
I'm not sure it is the right place to add the new version. It is the old one, but the unrequired version is set on the later in the future. Can you elaborate more?
I'm not sure it is the right place to add the new version. It is the old one, but the unrequired version is set on the later in the future. Can you elaborate more? Also, why is the change necessary?
I don't think you need the null here. If an empty model is returned from the DataObjectRemove/Refresh(), it has the problem that the DataObjectView is not building, so I would remove the need for null here.
I don't think you need the null here. If an empty model is returned from the DataObjectRemove/Refresh(), it has the problem that the DataObjectView is not building, so I would just do the null here.
I don't think you need the null here as the value is not an Optional<String>.
WeightComparator should be private in the FactorComparator class, i.e. non-static method in this class should be private.
WeightComparator should be private in the FactorComparator interface, i.e. non-static method in this class should be private.
WeightComparator should be private in the FactorComparator class, i.e. non-static method in the comparator class
No need to log here, please.
How about "IOException should be thrown."
How about "IOException should not have been thrown"
these methods should probably be into an utility class, in which you're in the Offline mode.
these methods can be moved into the wipe method, right after these calls
these methods should probably be into an utility class, in which you're actually using it here!
createFromEsriGeometry(new Point(x, y), SpatialReference.DOUBLE) can be replaced by OGCGeometry.DOUBLE?
Spatial reference?
Spatial reference is always the same
I don't think this can be removed since it was passed directly to the constructor.
I don't think this can be removed since it was done in the filter above.
I don't think this can be public.
Use StandardCharsets.UTF_8
Use StandardCharsets.UTF_8 here.
Use closeQuietly()
@Override is missing here.
@Override is missing here
@Override
suggestion mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
suggestion METADATA_KEY_DURATION);
suggestion mediaMetadataRetriever.extractMetadata(file)
These changes are required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
These changes are required a few times, because @AddonDependency now adds an implicit dependency. Try it out.
These changes should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
I think this should be private
I think this should be private and remove the @Override
I think this should be private and remove the public modifier
I think this should be index < length, index
I think this should be index < length
I think this refactoring is wrong. The index can be index < length, index
Can/should we return an empty list?
Shouldn't this return an Optional.empty()?
Shouldn't this return an Optional returned by emptyList()?
I would remove the 'null' here
I don't think you need to call unregister()
I would remove the null : here
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
as long as it's the same event id that's fine i guess, though i don't really see the problem with using just one. but i don't mind
as long as it's the same event id that's fine i guess, though i don't mind
Call getString(String) (there are no parameters in the resource messages).
Call I18N.getString(String).
Call getString(String).
This method should be synchronized, otherwise it will need to be persisted
This method should be synchronized, otherwise it will be re-used
This method is public
Do we need to check if nodeToContainer is not null? I think that we should do this check and throw an exception in that case.
I don't like this, we need to check if the uuid is not null (i.e. do we need to check if the node is not found here)?
I don't like this, we need to check if the uuid is not null (i.e. do we need to check if the uuid is not empty).
It might be better to make "address" a constant
It might be better to make "name" a constant
consider making "address" a constant
It could be cleaner to directly use orElseGet.
Should this be Instant.now.isAfter(now)?
Should this be in the orElseGet?
shouldn't this be the same as in the constructor?
minor nit: can we keep this one private static final?
shouldn't this be checked in tests?
setTrace(trace)
you could return directly
formatting
I think it'd be better to use '\n' for the delimiter separator instead of '\n\n
I think it'd be better to use '\n' for the delimiter separator instead of '\n'
I think it'd be better to use a StringBuilder here.
I would do: if (value == null) { return value.toUpperCase(); } else { return null; }
I would do: if (value == null) { return value.toUpperCase(); } else { return value.toUpperCase(); }
I would do: if (value == null) { return null; }
getStoragePool().getstatus()!= StoragePoolStatus.Up
Definately should have something of the sort. Perhaps worthwhile extracting to a helper?
getStoragePool() == StoragePoolStatus.Up
Put braces around if/else/if/else for readability.
Put braces around if/else/if/statements for readability.
Put braces around if/else for readability.
different audit message for the case only the key was updated is good :)
different audit log message for the case only the key was updated is good enough
different audit message for the case only the key was updated is inferred with the db
You already have the DescriptorFactory.INSTANCE. I don't think it's necessary to keep the registry as the ImmutableSet.copyOf(adapterFactory.INSTANCE) should work here. The list is already the default data provider (by creating it, but the registry registry will also end up in the future)
You already have the DescriptorFactory.INSTANCE. I don't think it's necessary to keep the registry as the ImmutableSet.copyOf(adapterFactory.INSTANCE) should work here. The list is already the default data provider (by creating it, but the registry registry will also end up in the future).
You already have the DescriptorFactory.INSTANCE. I don't think it's necessary to keep the registry as the ImmutableSet.copyOf(adapterFactory.INSTANCE) should be able to pre-compute the result of the factory, i.e. the constructor, but you won't need the adapter until the name change
Should we use parameterized logging here? LOG.trace("Getting file for object_id: {}", organization.getJSONArray());
Should we use parameterized logging here? LOG.trace("Getting file for {} with object_id: {}", organization, node);
Should we use parameterized logging here? LOG.trace("Getting file for object_id: {}", organization.getProperties());
@ochaloup I remember why I added this onePhase check here. The line below is not clear.
@ochaloup I remember why I added this onePhase check here. The line below is not fixed
Is it safe to put as @ochaloup?
nit: Make "wait" a static constant.
I would move this up to the end of the class.
nit: Make "wait" a static constant for ">".
Perhaps we can use the LanguageSmartmeteringKeys.id() method instead of the parsing?
Perhaps we can use the LanguageSmartmeteringKeys.KEY_BEGIN_DATE constant here (and below) as well?
Perhaps we can use the LanguageSmartmeteringKeys.KEY_BEGIN_DATE constant here (and in the next method)?
you can use StringUtils.isEmpty()
use StringUtils.isEmpty()
use StringUtils.isEmpty() instead of StringUtils.isEmpty()
Why skip this if we don't have it?
Why skip this if we don't do it?
Why skip this if we don't have the state?
s/cwl/bwl = true
Returning a boolean[] instead of a boolean, you can simplify the code a bit (same for FastSwlFilePath)
Returning true would be better, no?
Why are there two methods (one, one for the same) for the other? It seems the same.
Why are there two methods (one, one for the same) which could be reused?
Why are there two variables that are not used?
Could you please rename expectedYear to expectedYear and use this? <LINK_0>
Could you please remove HavePeriod?
Could you please rename expectedYear to expectedYear and use this?
nit: You could just declare new nonce()
suggestion Uri builder = new UriBuilder();
suggestion UriBuilder uri = new UriBuilder();
Err with this. I think now we should add an updateStatus method to SnapshotStatus.
Err with this. I think now it'ss length and you don't need to add an if.
Err with this. I think now we should add an updateStatus method in SnapshotStatus.
Can we add a function on the interface?
Can we add a function on the interface String?
Can we add a function on the String?
What would be the case where this configuration is not available?
What would happen if the stateClass is not a VisibilityGuarded set?
What would happen if the stateClass is not a VisibilityGuarded by the check?
can you make this a constant?
are these methods public?
can you make this a getter?
debug/trace
debug and trace
debug and else
suggestion return unitsToKill == 0? true : unitsToKill;
suggestion return unitsToKill;
suggestion return unitsToKill && unitsToKill;
Consider using the lambda syntax: LOG.info("LocalApplicationRunner will run by " + jobName);
Consider using the lambda syntax here.
Consider using the lambda syntax.
Could you please remove this line? I think it is the same as assertValidation(expected, checksum);
Could you please remove this line? I think it is generally better to read when you read the checksum.
Could you please remove this line? I think it is the same as assertValidation(expected, actual)
A more specific assertion that simplify and simplify are pruned in one place.
A more specific assertion that simplify would be added here?
A more specific assertion that simplify and simplify are pruned in one place?
to be consistent with other formats, we use this format: <LINK_0>
this should be public
this should be a format()
I assume we can remove a warning if we are going to add the normal Exception to the event.
I assume we can remove a warning if it is explicitly logged.
I assume we can remove a warning if we are going to add the normal Exception to the event type.
Nit: remove this.
Nit: Would a break if (hasWifiEnabled()) {
Nit: Would test this with a large wifi config (WifiManager)!= null?
Can we return Message<?> here?
Can we return this.public? I know it wasn't there before, but it is just a type-safe override.
Can we return this.public? I know it is not part of the public API but just a style...
This seems like a generic error. Why is this handled?
This seems like a generic pattern. Why are we passing UndertowOptions through a RuntimeException? It seems like the right behavior to get the right exception is logged.
This seems like a generic error. Why are you not passing the URL here?
Could you please extract the common part to a method? I suggest to avoid the switch and use it here as well.
Could you please extract the common code into a method to avoid duplication? I'm fine with this case in the other class.
Could be a bit shorter: java switch (text.toLowerCase()) { case : super.text:... }
I think this should be a static string.
I think this should be a static constant.
I think this doesn't need an else clause here.
This needs to be done before <code>super()</code>.
This needs to be done before <code>super()</code>. I think before this change we will have to touch this class.
This needs to be done before refactoring.
should have a space before "and"
should have a space before "position"
should have a space before the comma
Why do we need this line?
Why do you need this line?
Why do we need this if we're doing anything?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Message here is incorrect - it should be illegalArgumentException.
Message here is incorrect - it should be illegalArgumentException
I think this method should be private
I think this method should be private, no?
I think this method should use the new method
in case of stackType, you could use SaltPillarProperties.decoratePillarByClouderaManagerCsdDownloader
in case of stackType, you could use SaltPillarProperties.decoratePillar(cluster, servicePillar) instead
in case of stackType, you could use equals method.
If we use the enum, than the key types, then it will be more interesting to have the resource types stored in the entry types.
If we use the enum, than the key types, then it will be best to go through the resource resource below.
If we use the enum, than the key types, then it will be best to go through the resource case.
Curious: why not return null?
This is the same as the other methods in this class. I don't think it needs to be synchronized
Missing final
I think it would be good to have two return statements: one for () { if (inactivityDuration == null) { ttlLatch.await(inactivityDurationInitialDelay, TimeUnit.MILLISECONDS); } ttlLatch.await();
I think it would be good to have two return statements: one for () { if (inactivityDuration == null) { ttlLatch.await(inactivityDurationInitialDelay, TimeUnit.MILLISECONDS); } and second.
Please move this into a function to make it clearer.
I think this method should be defined in a local variable. No need to do it in multiple places.
I think we should use the INJECTED_TYPE.setEnabled(getConfiguration().isEnablePermissions(getConfiguration().isEnablePermissions()) here.
I think we should use the INJECTED_RS constant instead of the String.
Since leap-day/year-day aren't part of any actual month, you need to return the zero range
Since leap-day/year-day aren't part of any actual month, you need to return the zero-before-default values.
Since leap-day/year-day aren't part of any actual month, you need to return the zero-time or just the length.
Replace this and make the tests use a reference to the main image
Replace with this, makes the tests pass >
Replace this line
This could cause a NPE, instead use Optional.
This could also use the aggregateValue
Same here. Remove this.
Personal preference but I don't like the use of the java.util.Objects.requireNonNull
Personal preference but the stream version might look cleaner than the array iteration version.
Personal preference but I don't like the use of the java.util method.
Please move this line inside requireDynamicFBO() method.
Please move these above requireDynamicFBOs.
Please move this line inside requireDynamicFBO() so that it is used only once.
Can properties be null?
Add this to constructor
Add this to the constructor
Shouldn't they be disabled as well?
Maybe define a class/var to retrieve the button string?
Maybe define a class/var to retrieve the button string.
Since this block is used twice, perhaps pull it into a private method?
Since this block is used twice, perhaps pull it out into a private method?
If this block is used twice, perhaps pull it out into a private method?
I don't think you need this change. if (this == obj) return true; if (obj instanceof TypeAndTime) { equals(event); }
I don't think you need this change. if (this == obj) return true; if (obj instanceof TypeAndTime) { equals(event); } return false;
You need to include the time in the hashCode method.
Need to consider offset + 1
Please don't remove this extra line
Please don't remove this extra line.
Can you saved out in scope and re-use it instead of constantly?
Can you saved out in scope and re-use it instead of important delay?
Can you saved out in scope and re-use it?
I don't think we want to be sure that we're actually going to be getMetaMethod, which was expected to be a recursive call.
I don't think we want to be sure that we're actually going to be able to resolve the original exception, but I think we should be more explicit about what went wrong.
I don't think we want to be sure that we're actually going to be getMetaMethod, which was expected to be a null or empty :)
won't this return?
won't this get changed?
won't this return null?
I don't think it's necessary to check for mSystemServer!= null in this case.
I don't think it's necessary to check for mSystemServer.getTestDevice(). The message of the failure should not be localized.
I don't think it's necessary to check for mSystemServer.getTestDevice().
This can be a bit shorter: return getImage().setActive(active) || active == active;
This can be a bit shorter: return getImage().setActive(false) || active == active;
setActive(false) is enough
Same here. Couldn't you unlock the repository first?
Same issue.
Same issue here.
This test is very pre-existing. I think you can't create a custom IBundleGroup with a known type of collection.
This test is very pre-existing. I think you can't create a custom IBundleGroup with the current group if you want to keep the equals.
This test is very pre-existing. I think you can't create a custom IBundleGroup with the current group if you want to keep the approvals for the different groups
The message is in the wrong layer, but rather than the'magic numbers' limit (though I would expect the value to be in the database)
Shouldn't this be >= threshold?
The message is in the wrong layer, but rather than the'magic numbers' limit, I would expect the value to be in the mappers.
Better use ObjectHelper.isEmpty instead.
Some else if statements could be merged
Better use ObjectHelper if possible.
Instead of using a concrete HashMap, could we use listener.getLargestPoolSize() here in the next line?
You can use a more meaningful variable name here, for the assertion to pass that the handler0 is not simply a Thread.sleep().
You can use a more meaningful variable name here, for the assertion to pass that the handler0 and the actionSent.
Please have a space after if.
Please create a new constructor for this.
Please have a space between if and (
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
You should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang3.StringUtils.equals
This check is not necessary as there is already a check for null 'eref' field.
This check is not necessary as there is already a null check in the superclass.
This check is not necessary as there is already a null check in the command.
you don't need use replaceAll, because above you used normalizeJson
you don't need use SafeText because above you used normalizeJson
why don't you use replaceAll instead of single quote? Is it possible?
We call listModelOptions.getIncludeModel(this) twice, we are calling listModelOptions.getIncludeModelOptions().
We call listModelOptions.getIncludeModel(this) here as well, we are calling listModelOptions.getIncludeModelOptions().
We call listModelOptions.getIncludeModel(this) twice, before.
Use Guava's [this](<LINK_0>
Use Guava's Ints.checkedCast(count)
Use Guava's [this](<LINK_0> suggestion int count = 0;
Better to use toString() instead of toString()
Better to use toString()
Better to use toString() instead of this
should it be the first condition? why not use the array's size?
should it be the other way around and avoid the cast?
should it be the first condition? why not use the array's capacity?
Shouldn't we put this in PageView class?
Can we put this in a field?
Shouldn't we put this in PageView class,  section?
For the light of the contract, how about <LINK_0> if (channel == null) { channel = null; } else { channel = new Channel(name); }
For the light of the contract, how about <LINK_0> if (channel == null) { return; } // do something }?
For the light of the contract, how about <LINK_0> if ( channel == null) { channel = null; } // do something }?
I don't see any reason to check if the log level is enabled?
Please use Level.AGGREGATION_CLIENT_ID instead of "Sending a message" code.
Please use Level.AGGREGATION_CLIENT_ID
Please use interfaces where possible.
Please use interfaces which implements IComponentName as well.
Use interfaces where possible.
@vkuchyn one time variable not needed
@vkuchyn same here, why have you changed it?
@vkuchyn same here, why have you changed the matcher?
Second condition is unnecessary (checked in while loop below)
nit: can be final Vector<URL> searchResourcesInBundles = new Vector<>();
nit: can be final Vector url = new Vector<>();
You can put the filter at the end of the method.
You can replace this lambda with the previous one
You can do this via Objects.requireNonNull(item, "isValid")
Should we return null or empty?
Should we assert null; return Collections.emptySet();?
Should we assert null; return Collections.emptySet()?
Static import
Shouldn't this be a normal if
Shouldn't this be a normal warning?
Could we assign value to int at the constructor directly?
@bdragan this method can be static.
final
Can this method be private?
I'm not sure this is correct. In this case, we always use streamConsumer.size() == 0
I'm not sure this copy is correct. In this case, we always use a streamConsumer.size() == 0
I'm sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course)?
I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course)?
I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register?
as with the others, need to "remember" the first via, not the last.
as with the others, need to "remember" the first via, not the first via, but still...
as with the others, need to "remember" the first via, not the last....
I believe this should be private right?
I think this should be private right?
I believe this should be private
I don't know if this can be public, but it can only be used by subclasses.
I don't know if this can be public, but it can only be visible in the public API.
I don't know if this can be public, but it can only be visible in the subclasses.
Shall we assert that CalcFoundRows<SqlCalcFound> returned by CalcFoundRowFactory.parse()?
Shall we assert that CalcFoundRows.parse() is called?
This can be tested with TupleCalcFoundRows.parse()
I would move the actual column name into a static import as it's widely used :-)
I would move the actual column name into a static import of the class
I would move the actual column name into a static import as it's widely used.
duplicate regex as above, can we reuse it?
duplicate path as above, can we reuse it?
duplicate regex as above
keep this to synchronized
keep this to locked
keep this to separate
It would be better to move this constructor to another class.
It would be better to move this constructor to a simple one-time setup method.
It would be better to do this in the constructor.
Are we sure's always non null?
Are we sure about the null case or empty string is always non-null?
Are we sure about the null case or empty string is returned?
use CollectionUtils.isNotEmpty()
This should use a LinkedHashSet.
use getSchoolClass(I endpoint)
This could be assigned to a local variable for better readability.
This could be assigned to a variable for clarity
This could be assigned to a local variable for clarity
Why include these before casting?
Why not public?
Why include these before adding?
this can be simplified with Optional.ofNullable(address).orElse(address);
this can be simplified with Optional.ofNullable(address).orElse(null)
this can be simplified with Optional.ofNullable(address).orElse(address)
May be also good to use RuntimeException here?
May be also good to use MessageListener here?
May be also good to use RuntimeException?
would this be better called RestApiClientClient.process?
would this be better called addAll?
would this be better called RestApiClientClient?
Should it be the same as the referenceSetId?
Should it be the referenceSetId referenceSetId?
Should it be the referenceSetId?
should be new DefaultParameterizedType(null, Block.class)
This should be new DefaultParameterizedType(null, Block.class).
I think this should be new DefaultParameterizedType(null, Block.class).
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
Is this line here on purpose? It doesn't seem to make much sense as it is not relative to the currently selected entry.
Is this line here on purpose? It doesn't seem to make much sense as this is not relative to the currently selected entry.
I think this might be cleaner as... Optional<FormStatus> form = Optional.ofNullable(customConfigurations); return Optional.empty();
I think this might be cleaner as... Optional<FormStatus> form = new FormStatus(FormStatus.class).orElse(null); return Optional.empty();
I think this might be cleaner as here: return Optional.ofNullable(customConfigurations.getForm()).map(FormStatus::get).orElse(null);
nit: Objects.requireNonNull?
nit: move this into the synchronized block
nit: Objects.requireNonNull
Remove the public modifier, and use it here.
Remove the public modifier from all injection methods.
initialize
user will definitely not need it, it is quite internal exception, which we can track in the current state.
user will definitely not need it, it is quite internal exception, which we could track in the current state.
user will definitely not need it, it is quite internal exception, which we could track in the logs
missing { }
Redundant type check here.
missing { } around if body
please remove (as with other logs).
Please put the { (bracket) in the same line.
Please put the { (as with other logs).
We should do something similar to what you did in addLinks()
We should do something similar to what you did in addLinks method
maybe add populate()?
Is there a way to pass sourceExtractIteration or sourceExtractIterationIteration instead?
Is sourceExtractIteration required here?
Is sourceExtractIteration possible here?
Please use TransportHeaders.getTransportHeaders()
Please use TransportHeaders.getTransportHeaders() here
Please use TransportHeaders.getTransportHeaders() everywhere
Initialize to immutable if present.
Initialize this to immutable if present.
Initialize empty to immutable if present.
we can replace that with findAny/findFirst as we don't really need to know those vms
we can avoid that by using findAny/findFirst as we don't really need to know those vms
we can replace that with findAny/findFirst as we don't really need to know those vm names
Should we include the underscores in the field names?
Should we include the Objects.toStringHelper(this) call?
Should we include all the fields part?
Does it ever return null?
Why can't we use instanceof here?
I think we can use instanceof here.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_2>](<LINK_0>
!StringUtils.isBlank()
use ShellIsAvailable
Use ShellIsAvailable
just ShellIsAvailable
Maybe add a helper method that takes in ARRAY_BYTE_ARRAY and ARRAY_BYTE_ARRAY_SIE. Otherwise the number of inputs will be confusing.
Maybe add a helper method that takes in ARRAY_BYTE_ARRAY and ARRAY_BYTE_INDEX_SCALE
Maybe add a helper method that takes in ARRAY_BYTE_ARRAY and ARRAY_BYTE_ARRAY_SIE.
This should be a long.
This should be a long. It can be double.
I think this should be a long. It can be double.
Shall we change this to "Unable to resolve the hostname of the....". there are few other places as well.
Shall we change this to "Unable to resolve the hostname of the....". there are few other places as well..
Shall we change this to "Unable to resolve the hostname of the....". there are few other places as well with same typo.
Since init() returns an RjectJson, it could just be: java if (args.getBucket().isEmpty()) { return init(args.getEjectLabel(); } else { return null; }
Since init() returns an RjectJson, it could just be: java if (args.getBucket().isEmpty()) { return init(args.getEjectJson()); }
Since init() returns an instance, wouldn't argsjectStatus be set at the end?
Better to have a new empty list and use Collections.emptyList() to keep it as a final variable.
Better to have a new empty list and use Collections.emptyList() to keep it concise.
why not final?
Not your fault, but could you make this a static variable since it's used in multiple places?
Not your fault, but could you make this use a local variable instead?
Not your fault, but can we make this use of the default Locale.
why public? I still don't understand this class. They're not required by the base class. I think this would be necessary for the new addComponent(new MockChartDataFile(name, dataFileSource));
why public? I still don't understand this class. They're not required by the base class. I think it would be better for the method to be package private.
name
Why two "else" blocks here? The logic is hard to read.
Why two "else" blocks? The "if" and "else" blocks should be removed.
Why two "else" blocks here? The "if" may be removed.
Shouldn't this do nothing in the callback?
Wouldn't this timer be triggered in the callback itself?
Shouldn't this do this now?
I'm guessing we're checking the cache type now? Shouldn't we make it configurable and let the client decide how to handle cache?
I'm guessing we're checking the cache type now. Shouldn't we use a.maximumSize here?
I'm guessing we're checking the cache type now? Shouldn't we make it configurable and let the client decide how to handle it?
Maybe wrap the return value on the catch block?
Maybe wrap the return value around the catch block?
Fix this.
pull this out into a hasSize method so we can keep doing the lookup twice
pull this out into a hasSize method so we can keep doing the lookup twice.
pull this out into a hasSize method so we can keep doing the lookup for all queries?
This can be removed
This can be removed, and the next line in this method does not return anything
This can be replaced with addVesselCrew3()
Typo here. should be service_type
you should be able to cache the query mapper
you should be able to cache the query mapper.
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so it can be overloaded, can we do that too?
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that instead?
A typo: looks weird
A typo: it should be sFooterIsPresent?
A typo: it should be 2
I think we should cache the credentials here, that way we don't need the token cache anymore, right?
I think we should cache the credentials here, that way we don't need the token cache anymore, any time.
I think we should cache the credentials here, that was a token cache.
this should be this.operationVal == null
this should be this.
this need to be changed to LogLevel.
Is this really intended to return UNSAVED_ID?
Is this really meant to return UNSAVED_ID?
Is this really intended to return true? If so, return " printer" instead of null?
Add an assertion on the length of that?
Add an assertion on the list before the length?
Add an assertion on the list before the return.
Is this the correct way to wait for the latch to get here?
Could extract this to a constant for the exact purpose
Could you extract this to a constant?
same as above with deleteObjectsRequest
same here and in deleteObjectsRequest
same as above with deleteObjectsRequest().
should we use httpProtocolHandler instead of httpProtocolHandler?
should we use httpProtocolHandler in the httpProtocolHandler?
should we use httpProtocolHandler?
String.format?
String + SEPARATOR + 1?
Better to keep this as-is.
Do we need String.format here? Seems like this would be necessary.
Do we need String.valueOf() here? Seems like this constructor should be public.
Do we need String.valueOf() here? Seems like this constructor should be private.
Same here. Actually, this can be done in a try-with-resources block.
Same here. Don't put the FileInputStream in a try-with-resources.
Same here. Don't put final
I'm not sure you can get rid of the class and directly invoke filterAnnotations.add(CacheEntryStore.class, CacheEntryStore.class) here.
I'm not sure you can get rid of the class and directly invoke filterAnnotations.add(CacheEntry.class, CacheEntry.class) here.
I'm not sure you can get rid of the class and directly invoke filterAnnotations.add(CacheEntry::class, CacheEntry::class) here.
I don't think it's necessary to keep this for oldMessages.addFirst(oldMessages, oldMessageCount) sync. I feel it is clearer.
I don't think it's necessary to sync on old messages.
I don't think this is necessary.
* Can we use showButtons() in this method? * getButtons(showButtons)/ showButtons(true); * That's a code smell ;)
* Can we use showButtons() in this method? * getButtons(showButtons)/ showButtons(true); * That's what I think imo :)
* Can we use showButtons() in the constants? * You don't need to worry about the value.
xPathFuncList and xPath are so similar they're confusing.
xPath are so similar they're confusing. I would rename the list to list.
xPath are so similar they're confusing?
This should be Collections.singleton
This should be Collections.emptySet().
This should be Collections.emptySet()
this.tabFolder!= null is not required.
this.tabFolder!= null is redundant
this.tabFolder = null;
We might want to add this to the end-user dependencies as well.
We might want to add this to the end-user.
We might want to add this to the end-user dependencies as well
no need for the empty constructor.
no need for the new constructor.
IllegalStateException()
Why not return getCreatableProperties() anymore?
I think we need DelegatingResourceDescription here, no?
I think we need DelegatingResourceDescription here, no need to cast.
Shouldn't this be getTest()? I'm not quite sure about the ctor.
Shouldn't this be done in the ctor instead?
Shouldn't this be getTest()?
I don't think this is a behaviour change. Let's keep it if there is an error mapper in the map.
I don't think this is a behaviour change. Let's keep it.
I don't think this is a behaviour change. Let's keep it if there is an error mapper in the parameter for every errorMapper.
static
nit: it would be easier to read if we use String.format() for the exception message.
nit: it would be easier to read if we use String.format() to write the exception message
workflowStateDto::new is simpler
workflowStateDto::new
workflows
I know it's an extra postgresql, but not a string that's an unknown or 0?
I know it's an extra _defaultValue here, but seeing null isn't really a bad idea.
I know it's an extra _defaultValue here, but seeing null isn't a lot of aggregating the references of BigDecimal
TheHtmlConstant are already started
WhyHtmlConstant was started in the constructor?
TheHtmlConstant was already started
Assert.notNull
startDate can be removed here
startDate can be removed
Put two lines in one to make it more readable.
Put in a local variable to avoid multiple return statements.
Put in one line.
if (cursor!= null) {
if (cursor.execute()) { } else {
if (cursor.execute()) {
Please add final to the end of method
Please add final to the variables
Please add final to the variables of the class
Would be nice to pull this out into a constant (and maybe will be more readable)
Would be nice to pull this out into a function and call it from x and y (and maybe have a dedicated method).
Would be nice to pull this out into a function and call it from x and y.y?
I think it should be warning
I guess this should be an error?
I guess this should be an error
Could you update lines of code to use NameValuePair#baseNameValuePair() instead?
Could you update lines of code to use NameValuePair#getName() instead?
Can you remove this since this is an explicit type.
I think this method should return an instance of UNKNOWN if i is not null.
I think this method should return an instance of UNKNOWN if you is getting an instance of UNKNOWN.
I think this method should return an unperformed unacceptable ClosedChannelException.
what about return value of'selection' instead of selection?
what about return value of'selection'?
what happens when selection == null?
!formatString is not nullable
!formatString in new calls.
!formatString should be more readable
[minor] I think this can be improved as below - try { exchange.getIn(); } catch (BeanCreationException e) { exchange.getException().isError(e); }
[minor] I think this can be improved as below - try { exchange.getIn(); } catch (BeanCreationException e) { exchange.getException(); } catch (Exception e) { // Empty method invocation }
[minor] Empty method?
add a message to the assert
Please add a message to the assert
add a message to the stream instead of the length
if (isMetricAttributeDisabled(type)) {
if (type == null ||!isMetricAttributeDisabled(type)) {
if (type == null ||!isMetricAttributeDisabled()) {
Torn down the line, I'd rather see a new RuntimeException(DefaultProvisioningRecord whatWeShouldSpinUp, SlaveData.fromStdout()).
Torn down the line, I'd rather see a new RuntimeException(final Context action) method being used in the jclouds constructor.
Torn down the line, I'd rather see a new RuntimeException(DefaultProvisioningRecord whatWeShouldSpinUp, SlaveData.fromStdoutNode(slaveName)); to avoid cloning the a new Node instance.
The implementation of this method should be: private static List< getListFromSerializableCollection> mainThread() { return new ArrayList< getListFromSerializableCollection(List<String> iterator); }
The implementation of this method should be: private static List< getListFromSerializableCollection> List(Collection<String> iterator) { return Stream.of(new Object()); }
The implementation of List should be enough here.
There is no need for null checking in this case - second condition is enough
There is no need for initialize in this case - second condition is enough
There is no need for initialize method in this case - second condition is enough
I would maybe use static import for the whole class, so it is easier to read.
I would maybe use static import for the whole class, so the exception is clear.
I would maybe use static import for the whole class, so the test is easier to read
How about using getName instead of getNameOfClass?
How about using Fqn and what is the use of this message?
How about quoting the offending path here?
Redundant tap with the same name.
Redundant tap with the wrong name.
Redundant tap
add a warning message
we should throw an IllegalArgumentException
we should add a warning message
Please put a space after if.
Please invert the if condition and put a space after if.
Please put a space after if
If you don't need the check here, I think it would be better to throw an exception.
If you don't need the check.
If you always use an Integer here, the check will be useless.
This may get logged as a warning, so it should only be logged as a warning.
This may get logged as a warning, so it should only be logged as a warning, and not a warning.
This may get logged as a warning, so it should only be logged as a warning, and not a log.
IMO should be || u == UseNDT || u == UseNDT || u == UseNDT;
IMO should be || u == UseNDT || u == UseNDT || u == UseNDT || u == UseNDT;
IMO should be || u == UseNDT || u == UseNDT;
Your test fails, this exception is not logged. Change to: assertFalse(access);
Your test fails, this exception is not thrown. This can be removed.
Bad copy/paste?
This is now unused.
This is no longer called. RevCommit is.
This is no longer called.
FYI, can you add a check at the beginning of value to avoid Integer#compute?
These are not needed
FYI, this whole block can be replaced with > 1
Change log level to debug
Change debug to debug.
Change debug to debug
just return value
just return directly
just return directly here
"*to* throw exception" here instead of Exception
No need to throw this exception, you can drop the declaration.
No need to throw this exception, you can keep the original message and move to the catch block.
do we need this check if assignment is null?
do we really need this check?
do we really need this condition? The test can be skipped if element is null
why is this necessary?
This can be private.
Is this check necessary?
Mecise: suggestion config.withFallback(path).render());
Mecise: suggestion config.withFallback(path).render();
Mecise: java return config.withFallback(path);
why is this line not placed before the assertEquals?
why is this line not placed before the test?
why is this done? The line quayandand tests are not "only"
I think we should put the call to super.callFunction() in the end of the visitVariable method, no need to override the visitVariable method, as I think it would be easier to read.
I think we should put the call to super.callFunction, is there any reason we don't put it in the visitVariable method?
I think we should put the call to super.callFunction, is there any reason we don't put it in the visitVariable method, so I would have to override end method from end().
Can you use synchronized here? And possibly the other thread calls to check the state.
Can you use synchronized here?
This should be synchronized.
This should be package private.
This should be public.
This should be static.
can be omitted
remove the true
remove the try/catch
Throw an exception here.
Throw an exception here instead of returning null.
Throw an exception here instead of returning false.
I think we might want to remove the incrementer, given that it's a consumer method.
I think we might want to drop the incrementer, at this point we're only going to use the consumer to know whether the job is in the queue or not.
I think we might want to drop the incrementer, at this point we're only going to use the consumer to know whether the job is at this point or whether the job is at all.
We should use CollectionUtils.isEmpty() here.
We can use CollectionUtils.isEmpty() here.
We should use isEmpty() instead of contains().
The above code does not use the lock but the check for context is lock. It should be done within the synchronized (this) statement.
The above code does not use the lock but the check for context is lock. If you want to do this, it should be done under the lock.
The above code does not use the lock but the check for context is lock. If you want to do this, it should be done under a lock.
I believe this should be like Objects.requireNonNull(masterServices, "hbase.master")
I believe masterServices.getConfiguration() should be getInt("hbase.master")
I believe this should be like Objects.requireNonNull(masterServices, "hbase.master").
will need to add a newline after the comma
will need to add a newline
Remove this
Please add @Experimental and @since 2.1.7 - experimental to all of them.
Please add throw new IllegalStateException("The symbolic value should be defined by another checker has already been defined");
Please add throw new IllegalStateException("The symbolic value should be defined by another checker should be configured");.
return null if there is no result
Put result variable in the try block.
Put result variable in the same line.
This seems like a change, shouldn't the name be unique?
This seems like a change in a different way (like making the name of the interface) to indicate that there is no way to add the class to the interface.
This seems like a change in a different way (like making the name of the interface) to indicate that it is a bit of a type-cast.
return this;?
return this;?
return this;
The action and the name is the same as the default and so this will not work. I think it's better to make the change to kConnectString to kConnectString.
The action and the name is the same as the default and so this will not work. I think it's better to make the change to kConnectString to zkConnectString.
The action and the name is the same as the default and so this will not work. I think it's better to make the change to ookeeper connect to kConnectString. In this patch, I would suggest to only change the name to ookeeper related
You don't need a transaction here
You don't need a lock here
You don't need a lock on the result
why are we using this one?
why are we creating this with the other one?
why are we creating this with the default?
should be final.
This should be private.
This should be private. PutAsync()
Why not call deleteAll() directly instead of making delete()?
Why not call deleteAll() instead of just delete()?
Why not call deleteAll() instead of lookup?
your PR, but now you're using the right path for getting a list with isEmpty. Did you mean to add a check for anything here?
your PR, but now you're using the right path for getting a list with isEmpty. Did you mean to add a check for anything?
your PR, but now you're using the right path for getting a list with isEmpty.
> I am wondering if we should add the class name to the exception message here, just in case. > Class<? extends Throwable>.
> I am wondering if we should add the class name to the exception message here, just in case. > "Unable to load class " + className, e);); which does the same thing.
> I am wondering if we should add the class name to the exception message here, just in case. > "Unable to load class" is used.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the presenter.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format
I think this could be: return Objects.hash(listDelimiter(), columns, columns, indexed, columns);
I think this could be: return Objects.hash(listDelimiter, columns, columns, indexed, columns);
I think this could be: return Objects.hash(listDelimiter, columns, columns, indexed, columns, HeaderRows);
This is always true. For debugging it would be better to do it in the constructor itself.
This is always true. For debugging it would be better to do the same as in Utils.java
This is always true. For debugging it would be better to do the same as in Utils.join()
Use 'public' instead of 'this'.
Use 'this' currencySymbolLookup' instead of'master'
Use 'public' instead of 'println'
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces here
Can we do try { 'throws Exception' here to preserve the stacktrace?
Can we do not need to call verifySignatureException here?
Can we do try { 'throws Exception' here to drop the try/catch?
nitpick: I would prefer to have single throw for these exceptions, to make it consistent.
nitpick: I would prefer to have single exception for throw instead of DIST.
nit: I would rather use Preconditions.checkArgument
I feel like this should be a warning.
Missing parenthesis around the parameter.
Missing parenthesis.
NIT: could be refactored into a method to avoid duplicate code.
Is there a reason not to use the <LINK_0> here?
Is there a reason not to use the <LINK_0> here? I think it's better to use the <LINK_1>
Can this be extracted to a separate method?
Can this be extracted to a method?
Can this be shortened to: ui.getProgramFor(awardLabel.getSum()))?
should returnJenkinsJVM.isJenkinsJVM()
should returnJenkinsJVM()
should returnJenkinsJVM to create a Action after creation.
nit: you can remove the else here as you return in the if
nit: you can remove the else here as you return in the if below
nit: you should remove the else here as you return in the if below
@dalifreire let's get rid once time used variable
@dalifreire let's get rid once used variable
@dalifreire let's get rid once time used variables
nit: this code is repeated in multiple places.
nit: this check is repeated in L120497.
nit: this check is redundant
It would be better to check the two reconciler strategy here, or have a null return type.
It would be better to add a null check here, and make sure no reconciler is null, or to create an empty list.
It would be better to check the constructor of CompositeReconcilerStrategy here, and in case there's only a single reconciler strategy.
(optional) this can be simplified to just Mockito.never(): Mockito.never()
(optional) this can be simplified to just Mockito.never(): Mockito.never(): Mockito.never()
(optional) this can be simplified to just Mockito.never(): Mockito.never(): Mockito.never() (in this case if you are implementing a mock Mockito interface).
I'm not sure silent catch is good as after that url is null and it will create exceptions
I'm not sure silent catch is good as after that url was null and it will create exceptions
I'm not sure silent catch is good as after that url is null and it will create exception
Why using getAdapter here?
Why these constants?
Why?
I think you want to first check here not to use a PageViewStateCallback with a appropriate name.
I think you can just use a PageViewStateCallbackStateCallback.onPageDisappear(); here.
I think you can just use a PageViewStateCallbackStateCallback.onPageDisappear(); here and in line 148
shouldn't be SnapshotStatusOK itself?
shouldn't need the 'else' part?
shouldn't be SnapshotStatusOK.StatusOK itself?
Please remove this single return false;?
Please remove this single return false.
Please remove this single return false;.
nit: throws
throws
throws for consistency and clarity.
I don't understand this. Why not just get the hashKeyHashIdentifier if its key is null and doesn't have to be changed to weakReferencesTolocks.
I don't understand this. Why not just get the hashKeyHashIdentifier if its key is null and doesn't have to be initialized with something like KeyHashIdentifier lockKey = keyInSet;
I don't understand this. Why not just get the hashKeyHashIdentifier if its key is null and doesn't have to be changed to something like KeyHashIdentifier lockKey = keyInSet;
Is it worth setting this to the button status here?
Is it necessary to set the button event here?
Is it necessary to set the button here?
You can just use Util.isEmpty() here. It will ensure that linkage always returns null if the value is null.
You can just use Util.isEmpty() here. It will ensure that linkage always returns null if they don't have reference name.
You can just use Util.isEmpty() here. It will ensure that linkage always returns null if they don't have this value.
What are your thoughts about using assertEquals(String message, boolean expected)?
What is the reason why you do so?
What are your thoughts about using assertEquals(dockerExists, dockerPath)?
This is check in the overriden enqueue method. I think this check is extra here.
This check is extra
This is check in the overriden enqueue method. I don't think this check is needed.
Could you add a guard check for isDisposed() here?
Could you add a guard check for isDisposed()
Could you add a null check for location!= null?
Should we keep a reference to the Bundle here?
Should be a static - I don't know what is written with the current state but can we keep a reference to the language (you might need to store the state in a variable?)
Should be a static - I don't know what is written with the current state but can we keep a reference to the language (you can set the @Override annotation?)
delete tempTempFile
should this be cleanup()
delete the file
I think you should use Pair::toString() here.
I think you should use Pair::toString for this.
I think a better way to use toString
Please use lowercase as it refers to the argument: disposables is null.
Please use lowercase as it refers to the argument: Objects.requireNonNull(disposables, "disposables is null");
Use lowercase as it refers to the argument: disposables is null.
Use static strings.
mcr/vcr/vcr/> -> zk
Use vcr.getkConnectString.
Perhaps try-with-resources? And there is no need to close the resource here.
Perhaps try-with-resources? And then you may not need to close the resource.
Please use try-with-resources.
should this have a final field?
should this have external annotation?
should this have a final variable?
Let's put all this in the field declaration
Let's put all this in the field declaration.
Let's put all this in the entityStore.remove() function.
please move if statement
please move this to method
please break
Shouldn't it be this.askUserForDependencyActivationHandler?
Shouldn't it be this.askUserForDependencyActivation.
Formatting
What about this.public boolean isAnonymous() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication().getResource().getAuthentication().getName(); return authentication == null || (currentUserHasRole(AUTHORITY_ANONYMOUS) || (currentUserHasRole(AUTHORITY_USER)); } else { throw new AuthenticationRequiredException("Cannot authentication info"); }
What about this.public boolean isAnonymous() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication().getResource().getAuthentication().getName(); return authentication == null || (currentUserHasRole(AUTHORITY_ANONYMOUS) || (currentUserHasRole(AUTHORITY_USER)); } getAuthentication().logErrorIsAnonymous()
What about this.public boolean isAnonymous() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication().getResource().getAuthentication().getName(); return authentication == null || (currentUserHasRole(AUTHORITY_ANONYMOUS) || (currentUserHasRole(AUTHORITY_USER)); } getAuthentication().logErrorIsAnonymous()?
Text is slightly better but I still think it is better to use File.separator instead of /.
Text is slightly better but I still think it is better to use java.util.Objects.toStringHelper(secrets)
Text is slightly better but I still think it is better to use java.util.Objects.hash(secrets...)
Can you please change this to java.equals(url.getAttribute(WebAppService.HTTP_PORT)))
Can you please change this to java.equals(get())?
Can you please change this to java.equals(url.getAttribute(WebAppService.HTTP_PORT))).
Maybe it's better to use @Rule ExpectedException rule instead?
Maybe it's better to use @AfterClass method which is used in tests instead of @AfterClass?
Maybe it would be better to use @AfterClass method which is used in other places in this class?
Stray Log.d here and below.
Stray Log call
Stray Log call?
I'd have expected a null check here, and make sure that the job is executed. Is it really necessary?
I'd have expected a null check here, and make sure that the job is executed.
I'd suggest to externalize this constant.
should you have this method at the top of the class?
should you have this method at the top?
constant
<LINK_0>
To be consistent, don't you also need to pass the exception when you use a builder?
To be consistent, don't you also need the exception message here?
It's better to use SeleniumWebDriverHelper#waitAndClick() method instead
It's better to use seleniumWebDriverHelper here
It's better to use SeleniumWebDriverHelper#waitAndClick() method instead to simplify the code.
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void getTokenShouldSetToken() {
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClient();
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this.
This is a nitpicky, but in the other words add a method called DEFAULT_FILE_EXT or DEFAULT_FILE_EXT, it should call this one.
This is a nitpicky, but in the other words add a method called DEFAULT_FILE_EXT or DEFAULT_FILE_EXT
This is set in AndroidManifest
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a local variable?
public static? Is that keyword ordering important in this codebase?
You created forks and created forks in MkForksTest, which is not correct
You created forks in MkForksTest, which is not MkForkWithOrganization
You created forks and created forks in MkForksTest, which is not MkForks
the isImagesAlreadyOnTarget method is not needed anymore. the 'isImagesAlreadyOnTarget' method already checks the actually of isImagesAlreadyOnTarget()'. Please remove it.
the isImagesAlreadyOnTarget method is not needed anymore. the 'isImagesAlreadyOnTarget' method already checks the actually of isImagesAlreadyOnTarget()'.
the template is not located here..
Can we make this a static final variable in the parent class? I think it's a better name for the region cache
Can we make this a static final variable in the parent class? I think it's a better name for the region cache.
Can this affect the tests?
Fail the client with the default request endpoint name.
Dont do that. Let's remove "Microsoft" from the code
Dont do this. This is the default callback we need to change.
Can keep line 228 and the other constructor (in this case) and the default to an INTERNAL_SERVER.
Can keep line 228 and the other constructor (in this case) and the default to the JsonCreator?
Can keep line 228 and the other constructor of that exception.
Throw an exception instead of returning null
> Use osgi.getAuditLogConfiguration(IMFFormsDatabinding) instead of Activator.getService(IMFFormsDatabinding(databindingServiceReference))
> Use osgi.get.emf.EMF {databindingServiceReference = bundleContext.getbindingServiceReferences.getEMFFormsDatabindingServiceReference = bundleContext.getService(databindingServiceReference.class);
Ditto, please remove System.out.println().
Ditto, but since this is a standard library it should be used, please remove this line.
Ditto, but since this is a standard library it should be deprecated too.
You'd still want to tear it down. How about using a straight-forward if-else?
You'd still want to tear it down. How about using the 'else'?
You'd still want to.equals here.
I think it would be better to add the @ExperimentTaskResult annotation for the parameters. What do you think?
I think it would be better to add the @ExperimentTaskResult annotation for the parameters.
I think it would be better to add the @ExperimentTaskResult annotation for the parameters. What do you think about it?
You shouldn't expose a static instance similar to how it's done in timbuctoo-instancev4/src/main/java/nl/knaw/huygens/timbuctoo/security/dto/Login
You shouldn't expose a static instance similar to how it's done in timbuctoo/security/dto/Login.java
You shouldn't expose a static instance similar to how it's done in timbuctoo/security/dto/Login.java?
Can it be checked that the default value is not null?
Can we use the default value in the refresh method?
Can it be checked that the default value is not NULL?
I'm not sure we can have this logic in all versions of Android. I believe the old code was just moved to the if (uri == null) { return; } if (uri!= null) { // mor handleDeeplink(uri); } else { return; } }
I'm not sure we can have this logic in all versions of Android. Is there a reason to retain an API change here?
I'm not sure we can have this logic in all versions of Android. Is there a reason to retain the old code?
shouldn't clusterId be null?
shouldn't have getDbFacade() been replaced with getDbFacade()?
shouldn't have getDbFacade() been replaced with getDbFacade().getFacade().getInstance().get(clusterId);?
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one every time
Shouldn't this be a field so we don t have to create one each time
@manuelplazaspalacio why did you add this change?
@manuelplazaspalacio why did you move this line back?
@R.string.notification_creation_created
Should we use the field in the first place?
Should we use the getter rather than the setter?
Should we use the getter rather than create a setter?
Very minor: this can be simplified to java BigInteger capacity = BigInteger.ONE.shiftLeft(length); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); if (signed) { BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); return BigInteger.ONE.encode(BigInteger.ONE); } return BigInteger.ONE.encode(BigInteger.ONE);
Very minor: this can just be: java BigInteger capacity = BigInteger.ONE.shiftLeft(length); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); if (signed) { BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); return BigInteger.ONE.encode(BigInteger.ONE);
Very minor: this can just be: java BigInteger capacity = BigInteger.ONE.shiftLeft(length); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); if (signed) { BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); BigInteger capacity = BigInteger.ONE.shiftLeft(BigInteger.ONE); return BigInteger.ONE.encode(BigInteger.ONE); } return BigInteger.ONE.encode(BigInteger.ONE);
Is it the same as the enum "file" to describe it?
Is it the same as the enum "file" to make it more efficient?
Is it the same as the one above?
No need for try/catch here. In fact, you could drop the try/catch and just have the test for InterruptedException to be more explicit.
No need for try/catch here.
No need for try/catch here. In fact, you could drop the try/catch and just have the thread sleep for the while loop to acquire the lock.
s/site/"/site/"
CONTACT_US_SUFFIX may be not enough.
s/site/"/site/
I think we should move this to the top? If we spill for user memory, it should be easy to read.
I think we should move this to the top? If we spill for user memory in case of write memory in memory, it should be easy to read.
I think we should move the request to the end of the method. If we break more than one page per page, it will be easy to read.
Missing "0000".
This seems like it should be inside the if?
Missing "0000"?
I am not sure that this code relies on the order of arguments. Do the following code work or not? java if (this.stoppedDueToThrottling then it should be false) { if (this.stopped.compareAndSet(false, true)) { return; }
I am not sure that this code relies on the order of arguments. Do the following code work or not? java if (this.stoppedDueToThrottling then it should be false) { if (this.stopped.compareAndSet(false, true)) {.. }
I am not sure that this code relies on the order of arguments. Do the following code work or not? java if (this.stoppedDueToThrottling then it should be false) { if (this.stop!= null) { // Should the default be false } else if (this.stoppedDueToThrottling(...); return true; }
Isn't connection closed createConnection() redundant?
Can you write createConnection() instead?
Isn't connection closed?
not sure why this should be done in the other methods?
not sure why this should work?
not sure why this should be done?
It would be better if you rewrite this like isQuery = isQuery? p : parameters.INSTANCE; and take extra if (explain) { return true; } for (ParameterInterface p : parameters) { if (isQuery) { return true; } } return false; }
It would be better if you rewrite this like isQuery = isQuery? p : parameters.INSTANCE; and take extra if (explain) { return true; } for (ParameterInterface p : parameters) { EXPLAIN = (ParameterInterface) p.setValue(value); }
It would be better if you rewrite this like isQuery = isQuery? p : parameters.INSTANCE; and of course you find any better name than isQuery
This should be a WARN since we're not using a valid value.
This should be a WARN since we're not using the access token.
This should be a WARN since it's an ERROR.
suggestion ifGrowGrowTime(root, vineComponent);
suggestion if (!GrowGrowTime.length < 2)
again
Is this really a good idea?
I don't know if this is can be null here, but what if this property is null?
I don't know if this is can be null?
Add the exception as the second parameter of terminateInstancesWithoutInstanceIds or something like that.
Add the stackService as the last parameter of terminateInstancesWithoutInstanceIds or something like that.
Add the debug message as well
Please add at least of project in order to check that the result is empty because it return an empty list
Please add at least of project in order to check that the result are empty because it return an empty list
please add at least of project in order to check that the result is empty because it return an empty list
Include the name of the class in the error message, and in case it is what we want to do.
Include the name of the class in the logging message, and in case it is what we want to do.
Parameterized logging please.
Can the name be updated to something like chunkCounter++; if (latestBlock!= null) { chunkCounter++; }
Can the name be updated and the chunkCounter++; before the for loop?
Can the name be updated and the chunkCounter++?
What is the reason for appending 5 to the variable name?
What is the reason for appending one to the variable name?
What is the reason for appending 5 to the variable instead of double?
Should this be the same as this.public?
Should this be the same as this.lock?
Should this be the same as incompleteTransactionsContain?
getAndIncrement() should be rendered, no?
getAndIncrement() should be replaced by just ctx
getAndIncrement() should be replaced with just 1L
tracker is not thread safe
tracker is not synchronized.
tracker is not synchronized
maybe rename to IPV6_MIN_MTU
maybe rename to IPV6_MIN_MTU - 1 or similar?
maybe these two lines could be merged into one.
a bit more about this.fail() message should be something like "Failed to getSCHEMA test: " + 'p1', \"p2', p2');
a bit nitpicking: if one of the schema has been changed, rename to analyze
not needed?
Maybe use jobName to be consistent with underscore?
Use a ternary operator instead of one parameter.
Use a ternary operator instead of a condition to guard against null value.
Maybe all of these "symbolStatistics" could be made final?
Maybe we could return symbolName.estimateStatistics(symbolName()) here?
Maybe we could return symbolName.estimate();
I think we need to do this in the IntegrationContextUtils.getEvaluationContext() implementation, because we don't deal with the bean's IntegrationContextUtils.getEvaluationContext() implementation in IntegrationContextUtils. See bean.getDefaultEvaluationContext() for example.
I think we need to do this in the IntegrationContextUtils.getEvaluationContext() implementation, because we don't deal with the bean's context.
I think we need to do this in the IntegrationContextUtils.getEvaluationContext() implementation, because we don't deal with the bean's context class yet.
I would suggest to use [this](<LINK_0> here.
I would suggest to use [this](<LINK_0> here to reduce the number of addrs.
I would suggest to use addrs.length here, as well.
Make this method synchronized
Make this the method @Nullable
Make this the method synchronized
This should be the default filter param to singleMetricFilters.
This should be the default filter.singleMetricFilters().
This should be the default filter param to singleMetricFilters I think.
Error message "layerGroupId == null"?
Error message is missing
Error message "layerGroupId cannot be null"?
Use constant variable for re-use
Use constant for re-use
Use constant variable for re-use.
should be closed
why would the entry be null?
why?
Exception again
Exception again instead of throwing same exception again
Exception again instead of IOException
@bamboo3250, a stop. There's no reason to use String.format, it's much easier to just use String.format to go through the string to find the response.
@bamboo3250, a stop. There's no reason to use String.format, it's much easier to just use String.format to go through the string to find explanatory text if possible.
@bamboo3250, a stop. There's no reason to use String.format, it's much easier to just use string formatting.
isn't defaultValue always null?
IllegalStateException, not IllegalArgumentException
IllegalStateException is a bit misleading
lets put this errorIndicatorValue = errorIndicatorValue.checkNotNull(key, "The errorIndicatorValue cannot be null.");
lets put this errorIndicatorValue = errorIndicatorValue.checkNotNull(key, "The errorIndicatorValue cannot be null");
lets put this errorIndicatorValue = errorIndicatorValue.checkNotNull(key, "The errorIndicatorValue cannot be null."); Configuration errorIndicatorValue cannot be null
uploadItem1 does not need to be public
uploadItem1 is not used in this file, is it intentional?
uploadItem1 is not used in this file.
Nitpick: return this.dir;
Math.max
Math.min()
could probably inline, won't be null
could probably inline, won't work.
could probably use fPartListener.dispose() and dispose().
options.setDefaultFlowStyle(datanode, options.dump())
options.setDefaultFlowStyle(datanode, options)
options.setDefaultFlowStyle(datanode, options.dump())?
I think you should keep this check because it's not missed if mTetheringCoordinator is null or not. EndToUpstreamIface: if (mTetheringCoordinator!= null) { mUpstreamNetworkMonitor.stop(); } mUpstreamStateMonitor.stop();
I think you should keep this check because it's not missed if mTetheringCoordinator is null.
I think you should keep this check because it's not missed if State uses StateMonitor. In this case you may want to add a state field to PartitionNetworkStateMonitor.
should be able to revert this change
should be able to revert this change, since it's reverted
should be reverted
Can you please apply this to the PR description and make sure it's the right thing to do?
Is this the right way to do? The Impl class implements Comparable, so it should be the more general way to go.
Can you please apply this to the PR description and make sure it's the right type for job name?
This should be wrapped in another RuntimeException
This should be changed to :P
this.
Maybe we should add an assertion instead of assertPlatform.values() to make sure that we don't run into this code.
Maybe we should keep explicit assertionPlatform.values() method to replace testPlatform.values() by assertPlatform.values()
Maybe we should add an assertion instead of assertPlatform.values() to make sure that we don't run into problems in production?
Can you also add the RATE_MULTIPLIER to RATE_MULTIPLIER?
Can you also add the host address as well?
Can you also add the TAG?
Don't you think that this line should be removed?
Don't you think that this line is necessary?
Don't you think that this path should be moved at least?
return openFile()?
return openFile()?
return openFile() to both code
Let's only use DsfDebugOptions... as mentioned above
Let's only use DsfDebugOptions... as mentioned below
Let's only use DsfDebugOptions... as mentioned above.
use parameters.getAPITypeParameters()
isn't parameters already passed in the exception?
can be removed
nit: return findAndDelete(query, options) >= 0;
nit: return findAndDelete(query, options);
nit: return findAndDelete(query, options, options);
The formatting looks off here. It should not be reformatting.
The name should be printWriter, not included in the name. This is not used anywhere.
The name should be printWriter, not included in the name.
return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
I think it should be return executeCommand.execute(action, resultCallback);
return executeCommand.execute(action, resultCallback);
what happens if there is an assert?
what happens if there is an error?
what about developers like this?
We could just always return true here, right? Pretend it never happened?
Maybe we could just always return true here, right? Pretend it never happened?
Maybe we could just always return true here, right?
I think the arguments are reversed, the constructor does nothing?
I think the arguments are reversed, which is where you have a NPE on a line, which makes it think its a future year, a future year,...?
I think the arguments are reversed, which is where you have a zone, a runner.
Should probably make it final.
Should probably check and make sure it is "Failed to create".
Should probably check it?
"A fault zone cannot contain more than 1 replicas"?
"A fault zone cannot contain more than one replicas"?
this seems a bit strange.
you import ByteBuffer, no need to use the full package path
you import ByteBuffer, no need to put the full package path
you import ByteBuffer, no need to use ByteBuffer
Assert.notNull here
Assert.notNull() for symmetry
Assert.notNull for symmetry
Need this to be Assert.assertNotNull(StringUtils.EMPTY, "text");
Need to use Assert.hasText() here.
Need to go with an empty doc.
please just define on the next row.
missing: a test for an empty ("") description and a null description.
missing: at least a test for an empty ("") description.
Consider to use ErrorManager.SpmStatusError.getCode() == VdcBllErrors.SpmStatus().getCode()
Consider to use ErrorManager.SpmStatusError.getCode() == VdcBllErrors.SpmStatus.getCode()
You should not add the error to the log, it's unneeded.
If this prefix is a local variable, can we keep it as a local variable?
If this only applies to TopologyDetails, we should keep a local variable here.
If this only applies to TopologyDetails, we should keep a local variable here ("String")
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the encoding during the git clone or other editor that changed the encoding. On my clone :  file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest
Why not make this private?
Shouldn't this be: messageBus.getMessageBus()?
Why not use the following? <LINK_0>
getIpv4DefaultGateway() already checks whether the Gateway is present, but this is not the right way to go.
getIpv4DefaultGateway() already checks whether the GatewayServers is present, but it is connected to the request.
getIpv4DefaultGateway() already checks whether the GatewayServers is present, but it is not connected to any host.
I think this should be public, not a local variable.
I think the original code was easier to read.
I think the original code is unused.
I think it's better to use original method to throw an exception if the user does not have access to configFile KConfig.
I think it's better to use original method to wrap it in an atomic method.
I think it's better to use original method to throw an exception if the user does not have access to configFile KConfig. I think it's better to omit them.
use an overridable getOperationTimeout() method instead
Please use an overridable getOperationTimeout() method instead
use an overridable getOperationTimeout() method instead?
I think you want to use setClientAuthenticationMethodAsString(auth) here.
I think this should be clientAuthenticationMethodAsString.setClientAuthenticationMethodAsString(auth)
I think you want to use setClientAuth method instead.
domainNamesToRemove. regex will probably make more sense here, since it is just a constant.
domainNamesToRemove. regex will probably make more sense here, since it is just a constant
is there a reason to check for domainNamesToRemove?
What happens if you just swap the arguments? Does it make sense to throw an exception?
What happens if you just swap the arguments? Does it make sense to throw an NPE?
What happens if you just swap the arguments?
getClients(this, null)
getClients()
Hm
I think it's better to call this(retries, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX);
I think it's better to call this(retries, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX);
I think it's better to call this(retries, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX, DEFAULT_PREFIX); instead of hard coding the definition of the class
Use Guava Iterables.any?
Use Guava Iterables.stream()
static import
Maybe throw RuntimeException as well, to make it more obvious that you are missing.
Maybe throw RuntimeException as well, in case of invalid data, b)?
Single statement per line.
I think we can add the value of the merge result, which will use the same logic as in the mergeResult
I think we can add the value of the merge result by using System.getProperty("Automatic merge failed in ").append(...) which will show up in the warning.
I think we can add the value of the merge result, which will use the same logic as in the mergeResults for other widgets.
In the other files we could use Locale.UKNOWN or Editor.
Can you please extract this to a constant?
Can you please extract this to a variable?
Consider using an anonymous inner class instead of anonymous inner classes.
Consider using a lambda here instead of anonymous inner classes.
Consider using an anonymous inner class rather than anonymous inner classes.
duplicate method
duplicate transform method
duplicate transform(DB_VIEW)
Can you replace this with the lockSemaphore.tryAcquire method
Can you replace this with the switch statement with a java if (tryAcquire) { } block?
Can you replace this with the switch statement with a java if (poolSemaphore.tryAcquire()) { }
Wondering if we should have a metric for ignored param?
Wondering if we should have a metric for ignored nodes or to use treenode here?
Wondering if we should have a metric for ignored param here instead of being ClassCastException.
exception does not need to be caught.
exception doesn't need to be caught.
exception cannot be caught.
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within write() when you do other checks within addToResponseBody()?
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write(), when you do other checks within addToResponseBody()?
sprint should be executed before the iteration to insert a new line.
Is this the correct behavior?
sprint %s
This is pretty verbose. How about using a library for this instead? Maybe [TextView](<LINK_0>
This is pretty verbose. How about using a logger instead?
This is pretty verbose. How about using a library for this instead? I think that would be more verbose here.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here. Or, if you want to keep the originalViewItem.getSlavesState(). instanceof HostNetworkInterfaceBondedListViewItem.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here. Or, if you prefer, you can keep the originalViewItem.getSlavesState().instanceOf(HostNetworkInterfaceBondedListViewItem.class) in this line.
Redundant 'this'
Redundant 'finally' block.
Catching a RuntimeException from a runtime exception is bad practice.
@prondzyn Let's use Hamcrest matchers for consistency.
@prondzyn Let's use Hamcrest matchers for consistency. There is also assertThat(unproper).equals(proper).
@prondzyn Let's use Hamcrest matchers for consistency. There is also assertThat(proper).isEqualTo(true).
I would factor this out into a separate method in the if (humanTpService!= null)?
I would factor this out into a separate method in the if (humanTpService!= null) to avoid duplication
I would factor this out into a separate method in the if and remove the else entirely.
I think this could be Objects.requireNonNull(tableId, "Added tableIds cannot be null");
I think this could be Objects.requireNonNull(tableId, "Added table ", tableId);
I think this could be Objects.requireNonNull(tableId, "Added table manager")
Lets use kernal.activeResource()
Lets use kernal.activeError(log);
Lets use kernal.active()
What if we don't want to set it? Is there a way to do that?
What if we don't want to set it? How does the test fail?
What if we don't want to set it? Is there a way to do this?
consumer.getConsumer().contains(consumer.getConsumer().getConsumer()).remove();
consumer.getConsumer().contains(consumer.getConsumer()).remove();
consumer.getConsumer().contains(consumer.getConsumer().getConsumer())?
You should keep this public and the implementation should follow the pattern of first 'public'.
You should keep this public.
You should keep this public and the implementation should follow the pattern of this.
The asyncClient should be used.
The async client should be closed.
The async client should be used.
I think that this is the same as the first check: if (sshProperties.isStrictHostKeyChecking()) { session = sshProperties.getHostKeyChecking(); } else { session = sshProperties.getHostKeyChecking(); } if (sshProperties.isStrictHostKeyChecking) { session.bs(); } }
I think you can remove the three lines of code in the else if: if (sshProperties.isStrictHostKeyChecking()) { session = session.getHostKeyChecking(); } else { session = sshProperties.getHostKeyChecking(); } session = sshProperties.getHostKeyChecking(); if (sshProperties.isStrictHostKeyChecking), session.getHostKeyChecking()); } session.getHostKeyChecking(); }
I think you can remove the three lines of code in this method as well.
why mockIdString is not enough?
why mockIdString is not used?
why need to log here?
Should this be printed out in a finally block?
are a good idea to print a message on a native exception?
spacing
missing {}
missing logging
missing a break here
Please remove this catch and add the following 3 catches.
Please remove this try catch and add the test to fail.
Please remove this try catch and add an assertion to make sure that the exception is thrown.
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds?
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return what happens when fetcher is not present?
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds? that would avoid calling the new variable just once
You can use ExpressionUtils.methodName(mit) for that.
I would use ExpressionUtils.methodName(mit) for that.
You can use ExpressionUtils.methodName(mit) for that. <LINK_0>
please revert back this change and implement the required method in entity api please
please revert back this change and implement the required method in entity api
please use the required method in entity api if required.
nit: i think we could create a private helper method for this, like we do on other places.
nit: i think we could create a private helper method for this as well, like we do in other places.
nit: i think we could create a private helper method for this, like we do on the other places.
if we use the setEnabled above, we do not need this flag.
if we use the setEnabled above, shouldn't this be enabled?
I am not sure this is the correct behavior. We have other problems, but we need the disabled options.
Would it be possible to define this as a constant at the top of the class?
Would it be possible to set this to null here? If not, I would expect no logging at all (as someone may have no idea).
Would it be possible to define this as a constant at the top of the file?
unnecessary cast?
this should be in the caller thread, not here.
this should be in the caller thread, not in the class.
Looking at these 3 lines, you could extract you to a method and use it to reduce code duplication.
Looking at these 3 lines, you could extract you to a method and use that for the size of the stream.
Looking at these 3 lines, you could extract you to a method and use that instead
looks like the double "\n" at the end of this line
looks like the double "\n" at the end of this method.
looks like the double "\n" at the end of this method, are there any other error message?
It seems like we could share the code here? super.fill().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPABILITY
It seems like we could share the code here? super.fill().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPABILITY_REDSCAPABILITY
It seems like we could share the code here?
I'm not sure if we should leave this log message in. The call of resp.get().sendEvents() is unnecessary.
I'm not sure if we should leave this log message in. The call of resp.get().sendEvents() is deprecated. Any way we can drop it?
I'm not sure if we should leave this as is since it will add the "while" to the debug message
Move this to the top of the method?
Move this check down to the top?
Move this to the top of the method.
Why not initialize all of those fields at the declaration site? This @BeforeClass in my opinion doesn't add much value. (It would make sense if any of these constructors threw exceptions.)
Why not initialize all of those constructors at the declaration site? This @BeforeClass in my opinion doesn't add much value. (It would make sense if any of these constructors threw exceptions.)
Why not initialize all of those fields at the declaration site? This @BeforeClass in my opinion doesn't add much value.
please format
please remove TODO to add the commands
please remove the redundant space
replace with: Mono.when()
replace with the single element's #get.
replace with the single element's #size
Can we use Arrays.asList(...) here?
Can we put this above the if block? I agree this is more succinct than the else block.
Can we put this above the if block?
Shouldn't this be inside the if?
Shouldn't this also be inside UX?
Shouldn't this also be moved into the UX constructor?
does this need to be wrapped in try/catch so that the getPartitionId() returns an Optional?
does this need to be wrapped in try/catch so that the getPartitionId() can return null?
does this need to be wrapped in try/catch so that the exception is logged?
When will this be null?
When will the student not be an getStudentForGoogleId?
When will the student not be an instructor of the student?
You could give a name for the libraryCacheEntry instead of the actualCacheEntry directly.
You could give a CacheEntry as a parameter and use it in the cache...
You could give a name for the libraryCacheEntry instead of the actual?
A ternary statement is fine here.
A ternary statement is fine here: fboNameManager.get(fboName).getFbo()
A ternary statement is fine here: fboNameManager.get(fboName).
Null check for Context?
Null check for km not constant
Null check for km not encrypted string
assertReplicationFactorMismatchError might be an AssertionError and not an exception message.
assertReplicationFactorMismatchError might be an AssertionError but it doesn't have an assertion failure.
Typo?
IMO it would be better to have this return the isInitialized() && rule.isFalse() right? So we don't have to check for other cases.
IMO it would be better to have this return the isInitialized() && rule.isFalse() right? So we don't have to do all it right now
IMO it would be better to have this return the isInitialized() && rule.isFalse() right? So it would seem to have to do the check right after the isInitialized().
This seems like it should be the other way around, rather than re-creating the buffer for every call to getSchema(). I think it's better idea to make the other methods delegate to that.
This seems like it should be the other way around, like it's being passed into the constructor.
This seems like it should be a private method.
MetaTypeService is already available in the constructor.
MetaTypeService is already available in BundleContextImpl class.
MetaTypeService is already available in BundleContextImpl.
Does it make sense to log this value? It looks like there is no need for this field.
Does it make sense to log this as 'after'?
Does it make sense to log this value?
I'm not sure about the purpose of this method. An attribute should have a getSoleAttributeValue(IAttributeType attributeType, boolean), and not the one above.
I'm not sure about the purpose of this method. An attribute should have a getSoleAttributeValue(IAttributeType attributeType, boolean) and do this on the end of the method. Also, why not use getSoleAttributeValue(...) instead of getSoleAttributeValue?
I'm missing something, why has this method return a boolean?
Do we need a cast here?
Why do we need a cast here?
Why do we need a Object array?
I believe we need to mention that the commit operation is supported here - "The commit operation is not supported"
I believe we need to include the commit operation here, right?
space
I think it's more readable to use String.format() for other arguments, not Calendar.
I think it's more readable to use String.format().
I thought it was ms
please show me a new line.
please show me a new user how to handle the error and have log, while we're using it
please show me a new user how to handle exceptions. Please catch it and print an error and use it.
nit: this.id = id
nit: this.s
nit: this.s = id;
Can you change this to return Void.ERO;?
Same question as above. NumericBinding
Same question
This should really not be public.
This should be synchronized
This should be synchronized too.
Name this will throw a NPE if the listBox is null.
I know this is existing code, but shouldn't we use this instead of leaving this as is?
1. Why not use Objects.requireNonNull(listBox)? 2. Does this matter?
Are you sure whether it is better to use DelegatingClassLoader rather than the one that sets it to the default? To be honest, I am not even sure why we need it.
Are you sure whether it is better to use DelegatingClassLoader rather than the one created by one? To be honest, I am not even sure why we need it.
Are you sure whether it is better to use DelegatingClassLoader rather than the one that sets it to the default?
I prefer to leave this as package-private to avoid a synthetic accessor.
I prefer to make this a bit shorter: this.clientCapabilities = Objects.requireNonNull(clientCapabilities, "client is null");
I prefer to make this a bit shorter: this.clientCapabilities = Objects.requireNonNull(clientCapabilities, "clientwantLimit is null");
hash = hash;
I think it's better to keep hash = hash.hash; and return hash.hash; here and remove hash = hash.hash;.
I think it's better to keep hash = hash.hash; and return hash.hash; here and remove hash = hash.hash;
use the getter as well
add the annotation on the field. Here it's a good idea
add the annotation on the field declaration
Please add the feature flag ID in the constructor to prevent duplicate entity operations.
Please add the feature flag ID in the hash map
Please remove this (and the following line)
this one is the same for this else, can we simplify?
both alarm and dataone are the same, can we simplify?
both alarm and dataone are the same
this can be a single return statement
this can be made private
this can be a boolean
rename to action
maybe it's better to call clear() only once?
I think this should probably be > 0 here
You should also call super.localQryIter() here.
You should also call super.localQryIter() here
A read-only iterator is missing here.
It might be better to declare a constant for the scannerThread and use that here.
It might be better to declare a constant for the scannerThread and use that constant.
It might be better to declare a variable for the scannerThread and use that variable instead of creating a new variable.
Could this be made static?
runAsync is already implemented. You already have access to runAsync
runAsync
this.portIdsForRoots -> authIdsForRoots
this.portIdsForRoots -> authIdsForRootsToroots
this.public SecurityConfig() need to be deprecated?
You can use try-with-resources
You can remove that line.
You can use try-with-resource
String.format() isn't needed
String.format() isn't necessary
String.format() is unnecessary
I think we don't need to duplicate :D
I think we don't need to duplicate :smile:
I think we don't need to support?"
can be static
can be final
can be final.
Avoid the use of Objects.requireNonNull(path, "The normalized")?
Objects.requireNonNull(path, "The normalized")
Avoid the use of Optional.
that's not exactly what is tested. Please remove.
that's great!
that's not exactly what is error thrown..
This is a good change in the other tests. I don't think it's working.
This is a test.
This is a good change.
nit: Now the methods are testing the same thing, consider asserting an expected body as a precondition: assertThat(PROJECT_OWNERS, "UNUNYMOUS_USERS");
nit: Now the methods are testing the same thing, consider asserting an expected body as a precondition: assertThat(PROJECT_OWNERS, "UNUNYMOUS_USERS"));
nit: Now the methods are testing the same thing, consider asserting an expected body as a preconditions check.
Use classes that are not used in classes.
use classes that are not used in classes like this.
use classes that are not used in classes.
same here with timeoutFactor
same here with waitFactor
application.
Change this to isEnabled()
Change to isEnabled()
Change this to isEnabled()?
could use Objects.equals() to avoid the null checks
could be simplified to...equals(object) here.
could use Objects.equals() to avoid the null check
Consider using a similar formatting like <LINK_0>
Consider replacing with a single return statement:.add(Query.getClient().get(key))
Consider using a similar formatting like above.
We need new File(temp.next(), existing code, it is always easier to read.
We need it in the finally block?
We need new File(temp.next(), it is always easier to read.
I don't think this is ever called. Is this not the case?
I don't think this will work. Is this just aSINGLETON object, or SINGLETON object?
I think theSINGLETON value can be null, not an empty list. Is it really only to annotate the list as a static method?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in the future.
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks. What do you think?
This class is still beta--I would be OK just making this method non-static and using the registry
Alternatively: > This class is still beta--I would be OK just making this method non-static and using the registry
This class is still beta--I would be OK just making this method non-static and using the registry instead of the registry
Move this to the EditingDomainOperation
ActionContext.getEditingDomainForContainment()
Move this to the EditingDomainOperation.
Can use validatePrimaryLanguage here and below.
Can we add validatePrimaryLanguage here and below?
Can we move this to a safe start method so that there is no need for all this tests?
Can you clarify this change?
Can this ever happen?
should this be Interval.overlaps?
Is it the same as getValue()?
Is this the same as getValue()?
return null
This should be part of the public API
This should be final
This should be protected to be used by the descriptor
Could you mention this as well?
You are using Thread.currentThread().interrupt() instead of this.
Could you mention this.
I think this method may return null.
I think this should just return (new ArrayList<>(), not sure.
I think this method may be final.
Maybe use the version with MINIMUM_SDK_VERSION_CODES.VERSION_OF_TESTING_DEVICE
Maybe use the version with MINIMUM_SDK_VERSION_SDK_VERSION_CODES.VERSION_OF_TESTING_DEVICE
Maybe use the version with WildFly version 0.
It should be package-private and not public.
It seems like we should remove vanillaed too.
It seems like we should remove Override annotation.
My guess is that the new constructor already has been added for this constructor. In the new constructor, we shouldn't have to change this constructor.
My guess is that the new constructor already has been added for this constructor. In the new constructor, we shouldn't have to change this line too much.
My guess is that the new constructor already has been added for this constructor. In the new constructor, we shouldn't have to change this constructor. It should be removed.
should this be setStartTime? I personally prefer the latter.
should this be setStartTime? I think that's in this case so it's not necessary to have the 3 states.
isPaused actually needed?
I don't think "getString" is needed when you call getString()
I don't think "getString" is needed for this object.
I don't think "getString" is necessary.
I am not sure why you want to make this public.
I am not sure why you want to make the copy here.
I am not sure why you want to include this to be mutable?
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, Integer.toString(byte[]) }
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, Integer.toString(addressBytes)); }
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, ptr };
Is this correct? It's am I missing something.
Is this correct? It's am I missing something?
Is this correct?
I'd suggest using the Factories#resolve() method instead of making this method relative to the new class. At the moment I am not sure why one should use the conversion method below.
I'd suggest using the Factories#resolve() method instead of making this method relative to the new class. At the moment I am not sure why one should use the conversion method on the graph class.
I'd suggest using the Factories#resolve() method instead of making this method relative to the new class. At the moment I am not sure if we should use the conversion method in this class though.
I would do this as it is just a single field in AdminkClient.MODULEkClient.createTopic(zkClient);
I would do this as it is just a single field on the class.
it does not seem to be the same as this.
Could you also expand the %s value into a static final field so that you don't have to pass it twice?
Could you also expand the filter name for the invalid file?
Could you also expand the %s value into a static final field so that the 3 arguments are used?
Line wrapping is not needed
Line wrapping is a bit odd here, especially when there's a test for the matching line number.
Line wrapping is a bit odd here, could we avoid if statement?
It might be wise to put this log on the same line as the exception message.
It might be wise to put this log on the same line as the method above.
Since this callback is only called from the listener, I think we should use a listener.
@andreaspalacio you don't need the? :)
@andreaspalacio you don't need the?:
@andreaspalacio you don't need the?: and this.
synchronized?
Log messages should be great.
Log messages should be wrong here
If this fragment is a simple replacement, you might want to move this line into the top of the method.
If this fragment is a simple replacement, you might want to move this line into the fragment instead of duplicating the code
is this really needed?
I think it's better to make this a trace message
I think it's more thread safe
findbugs
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed.
Change this to Suggest adding a link in the report to the deleted artifact. Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it.
Recommend adding a link in the report to the existing log
Can this be a bit more concise? And the same below?
Can this be a bit more concise? And the same below
Can this be a bit cleaner? And the same below for the other method
Should this be on the same line as the log.isTraceEnabled()?
nit: use!log.isTraceEnabled() to reduce duplicate code.
Should this be on the same line as the log.trace("Using existing connection to be closed")?
I think the strings can be replaced by allOf() to make it clear that it's not the case.
I think the strings can be translated.
I think the strings can be replaced by allOf() and should be good.
You can just call getWakeLock() here.
You can just call java Preconditions.checkNotNull from the nested class.
You can just call java Preconditions.checkNotNull from Guava.
This isn't needed
I think we need to keep ROLE_TAG.
I think we need to keep a reference to the Bundle here.
Ah, I think that local variable should be renamed to options.
Ah, I think that the 0s should be a constant since it's referenced from all threads.
Ah, I think that the 0s should be a constant.
Do we need this? The old method is not a good way to implement such an interface.
Do we need this? The old method is not a good way to implement such an Iterable<GraphQLDirective>, shouldn't it?
Do we need this? The old method is not a good way to implement such an Iterable<GraphQLDirective>, shouldn't we use a list here instead?
I would prefer if you can use -1L here
I would factor this out into a TaskStatusPlus.
I'm not sure if this should be in tests.
I don't think this is correct. Suggestion: I would move this check to the start of the method and make them static.
I don't think this is correct. Suggestion: Instead of doing a null check, why not just do.equals(lifeSpanSeconds)
I would move this check into the checkNotNull
This condition is redundant: if (buffer.hasRemaining()) { channel.write(buffer); } else { buffer.write(buffer); }
This condition seems redundant - you can just return the buffer == null.
This condition is redundant: if (!buffer.hasRemaining()) { channel.write(buffer); }
same question as above
same question as above?
same question as above, would prefer to have it static
Don't return, just do a continue so other modules can still add their state systems as children.
I'm not sure I like this, but I'm not sure if it's as a good idea.
I'm not sure I like this, but I'm not sure if it's as good practice to go in the analysis module. Because of that, it's easier to do: module.dispose().setData(); //motor (fast)
again.
Final.
again i.e. Final.
The code should be: if (urlIndex == null) {... }
If urlIndex is empty, this should throw an exception instead of returning Mirror.
Put it in the if()
We can use CollectionUtils.isNotEmpty()
Can we use CollectionUtils.isNotEmpty here?
Can we combine these three into a single line?
Could we just use: if (!audio/getMimeTypeFromName().startsWith("audio/")) { return getMimeTypeFromName().startsWith("audio/"))? -1 : getMimeTypeFromName().startsWith("audio/")); }
Could we just use: if (!audio/getMimeTypeFromName().startsWith("audio/")) { return...; }
Could we use == here instead of startsWith?
This should go before the for loop.
I would call this test method without the ExtensionList.
This should go before the line 44.
This should be replaced with a guard method.
This should be replaced with a static method.
Should be replaced with a guard method.
This is repeated. And I wonder if it would be better to create this only once in the constructor
This is repeated. And I wonder if it would be better to have a static constant for the rest of the code?
This is repeated. And all the other classes have the same code.
We need a case where we dont want to clear the entry if we are going to do that.
this should be clear as well.
It might be worth throwing a SHARED.
I think 'lockHostDevicesLock' is a better place to handle this.
I think 'lockHostDevicesLock' is a better place to handle this. What happens if we change the call to 'lockHostDevicesLock' to 'lockHostDevicesLock'?
I don't think we need to call  acquireSnapshotDevicesLock. This will simplify this method.
why not the return in the catch block?
Possible NPE here in case of misconfiguration
Possible NPE here
Could you please throw a meaningful message?
Could you please use {}?
Could you please move error message here?
Should we have this constructor? Since we have a builder, we could use [this](<LINK_0>
Should we have this constructor private?
Should we have this constructor?
@manuelplazaspalacio I think there is no need to log this, right?
@manuelplazaspalacio I think there is no need to log this exception, right?
@manuelplazaspalacio why do we need this change?
Perhaps rename to "bolt" or "bolt".
Not sure if you can rename this variable.
Not sure if you can rename this variable..
better to have fail(); in the onSuccess()
better to have utility methods for this.
better to have fail(); in defaultAuthentication().
I think it's better to use fail("Raised incorrect exception"); in this case.
I think it's better to use fail("Raised incorrect exception") here.
I think it's better to use fail("Raised incorrect exception") here, which will do the same thing.
Nit: you could use diamond operator: new ArrayList<MainType>
Nit: you could use diamond operator: new ArrayList<>();
Nitpick: you could use diamond operator: new ArrayList<>();
Should this be getNonNullRequestParamValue?
This can be combined onto one line.
This can be combined with previous line.
Please use the getName()-method instead of the fully qualified class name
Please use the getName()-method instead of hard coding the prefix.
Please use getName()
Why do you need this if/else block?
Why do we need this if/else block?
Why do you need this if and not just return with(...)?
FIXME: This always returns 0.
FIXME: This should be a getItemViewType() method.
Null check
This is not thread-safe, but you can simply remove the count variable and use get() directly.
This is not thread-safe, but you can simply remove the count variable and the set directly return value.
This is not thread safe
why?
Missing proper name.
Why?
Why do we need a super constructor?
Why do we need it?
Do we need a validatorLocator here?
Could you please explain why do we need to delete the container and it was removed by default?
Could you please explain why do we need to delete the container if it's already deleted by container?
Could you please explain why do we need to delete the container if it's not deleting a file?
The spec says: As of JAX-RS 2.0, the participantStatus is still a local variable. Do you think we should still handle that case?
The spec says: As of JAX-RS 2.0, the participantStatus is still a local variable. We should still have to use the same participantStatus object in response.
The spec says: As of JAX-RS 2.0, the participantStatus is still a local variable. Do you think we should still handle that?
Can you use logger.debug or trace level?
Can you use logger.debug here?
Can you use logger.debug or remove the exception?
@ekondrashev > I'd like to see this constructor being used here, same as in other builders.
@inverno Why public?
@ekondrashev Add a check for port param?
why have we use this map?
why have we use this method?
why public?
while you are at it, can we make this more readable? if (Objects.isNull(ImmutableStorageProvider.isNull(storageProvider)) { return SwarmProvider.isNull(); } return SwarmProvider.values();
while you are at it, can we make this more readable? if (Objects.isNull(ImmutableStorageProvider.isNull(storageProvider)) { return SwarmProvider.isNull(); }
while you are at it, can we make this an ImmutableStorageProviderFactory, and then return isNotNull on these calls?
You are doing more than one database call here. Can we make it more consistent and do better than expose a static method that does this in the parser?
You are doing more than one database call here. Can we make it more consistent and do better than expose a static method that does this for you?
You are doing more than one database call here. Can we make it more consistent and do better than expose a static method like DEFAULT_ERROR_CONFIG_STRUCTURE_FIELD_CONFIG_STRUCTURE?
Should be in a field declaration.
This is also wrong.
Should this be in the map?
Should return the family itself.
family cannot be null.
Should not be cloned
Why don't we just throw the RuntimeException? I don't see any specific reason to do it here.
Why don't we align the name with the method name?
Why don't we just throw the RuntimeException? I don't see any specific reason to keep stacktrace information.
Exception is never thrown.
equals!
Exception is never thrown here
I'm not sure if this is introduced in this patch. Should we remove the public?
In this case we're going to remove the reference from the repo, which is called from the web thread. We should instead make this this method synch.
In this case we're going to remove the reference from the repo, which is called from the web thread. We should instead make this this method sync with the ContextSyncer's reference.
Good idea. I think I'd rather we skip the null value here, and have it create the key (and the map could be empty).
Good idea. I think I'd rather we skip the null value here, and have it create the key (and the map will be empty).
Good idea. I think we can do this.
I don't see you overriding this in the KafkaProducer here. It seems like you're doing this in the first place, but not actually using a real value. I think your change is correct.
I don't see you overriding this in the KafkaProducer here. It seems like you're doing this in the first place, but not actually using a real implementation, so I'm not sure if it matters.
I don't see you overriding this in the KafkaProducer here. It seems like you're doing the correct thing, not to.
How is this expression different from "this"?
How is the reference name different from "this"?
How is this expression different from "this" to "this"?
... encodings?
Use encodings here
... encodings?
nit: merge with previous line seems a bit excessive?
nit: merge with previous line
nit: oneline
revert
static import
revert.
Stringtt need this
Stringtt need this String since you call tt using junit.
String concat
Please check here also - require require non null checks
Please check here also - require require non null checks for the parameters
Please check here also - require require non-null values for headers
couldn't just be initialized in the constructor? I also saw this is not meant for this case.
couldn't just be initialized with a single check instead of two?
terminated = true
style: s/fsroot/fsroot/
style: s/fsroot/groot/
style: s/fsroot/fsroot/g
Is there a metric to add this to runAsync()?
Is this something we want to know about? Wondering if there is any difference between this "if" and the new check with warn().
Is this something we want to know about?
while toString or this makes sense.
if it returns null, should we check this?
if it returns null, should we check this too?
Should we have a final bp = new AbstractBackupPath(file); here?
Should we have a final bp = new AbstractBackupPath(file); and do the check within this method?
Should we have a final bp = new AbstractBackupPath(file); and do the check within this method? I don't think we should be doing this here.
new: try to avoid the new code here.
new: try to avoid the new code.
new indexed
I guess the message should be: "Invalid API ERROR_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE"
I guess the message should be: "Invalid API ERROR_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE"
IN_LARGE_TOO_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_INTERVAL == ERROR_LARGE_BYTECODE_TOO_LARGE_BYTECODE_TOO_LARGE_LEVEL
I shouldn't be magic numbers. Maybe this can be configurable? <LINK_0>
I shouldn't be magic numbers. Maybe this should be configurable? <LINK_0>
I shouldn't be magic numbers. Maybe this can be constant? I shouldn't be like magic numbers.
The two asserts can be merged into one
The two asserts can be merged in one test
why is it necessary to assert the file name?
A better approach would be to write ": setupListViewAdapter();"
A stream can be created on the setupListViewAdapter below
A better approach would be to add default setupListViewAdapter();
single quotes not needed here
reverse the left and right curlies not needed here
reverse the left and right in case of empty list
Asserting here if it doesn't match rather than silently ignore silently?
Asserting here if it doesn't match rather than silently ignore errors might make more sense.
Asserting here if it doesn't match rather than silently ignore.
You don't need to do gw -> gw.values().forEach(chainMap -> gw.destroy());
Isn't this the default value of the gw parameter?
You don't need to do gw -> gw.values().forEach( cm -> gw.destroy(values().forEach(chain));
nit: ignore case for config
nit: ignore case config
nit: ignore case result
I recommend this method to be private, as the other fields are not meant to be passed into this class
I recommend this method to be private, as the other fields are not meant to be passed to this class
I recommend using UnixResolver API, because that would be more consistent with the other option
Should use thrown.expectMessage("one", null)
Should use a named constant for the name.
Should use thrown.expectMessage("one", false)
@lorobode Instead of duplicating the code inside these methods, you could call the second param!
@lorobode Instead of duplicating the code inside these methods, you could call the second getId method inside the createJob method
Is this method really needed?
This catch clause is not needed, because you do not want to throw an IOException when the file is not found.
This seems wrong/redundant. The check to see if a file is a directory and if so, that the error message makes sense.
This seems wrong/redundant. The check to see if a file is a directory and if so, that's why?
nit: space between if and (
nit: space between ) and {
nit: space between (longReachableValue)
Need to be consistent with equals()
Objects.equals() instead of!=
comparisons should be equal to equals()
You can call this.setTimestamp(long timestamp) from here.
If this.setTimestamp(long) is null we should make a no-op.
Add this.setTimestamp(long timestamp) to be non-null.
Is it possible to move this more specific exception handling out of the looper? If this is the only thing that should be done by the update() method (like it calls the update() method), then I'm not sure if it's worth changing the resource here.
Is it possible to move this more specific exception handling out of the loopField, then I'm not sure if it's really necessary.
Is it possible to move this more specific exception handling out of the loopField, then I'm not sure if it's worth having this separate method.
extra blank line
I think it should mark the @NonNull
extra space
See above, I think its better to move the index to the field, because it is really used in many places.
Redundant permission, because the field is mutable.
See above, I think its better to use the index variable
use java.util.Objects.hash()
Should use Integer.hashCode(int) here.
Should use HashUtil.combineHashCodes
Shouldn't a cast to int be enough?
Shouldnt a cast to int be enough?
Shouldn a cast to int be enough?
forgot to use system.out.println()
wait, do you have a better description for this?
forgot to use system.out.println().
@vmaletta add final
@vmaletta add final to list
@vmaletta use String.isEmpty()
Why not the following like this: public Eval eval(String variableManager) { Eval eval = new Eval eval(interpreter); return eval.get(EefPackage.EEF_WIDGET_EXPRESSION); }
Why the static import?
Why the need to test this?
Typo: "connection"
Probably fail the test? Also please log the error.
Probably fail the test? Also please log the error but error.
Please add LOG.info("Source task attempt {} received at {}", attempt, attempt);
Please add the LOG.info statement to the log message.
Please add info logging here.
I would extract the updateUsernameChangerFragment into a local variable to avoid duplication.
Do we need to do a update check here?
I would extract the updateUsernameChangerFragment into a function called something like isUserInitialized()?
For Exceptions where possible please pass in a enum and the signature is null and that way it is clear what is happening.
For Exceptions where possible please pass in a enum and the signature is null and that way it is clear what is wrong in this case.
For Exceptions where possible please pass in a enum and the signature is null and that way it is clear what is wrong in this case
NIT: I think we don't need it at all, since it seems to be just a static choice.
NIT: I think we don't need it at all, since it seems to be just a static import
NIT: I think we have the place where it is deleted.
Can we move this logic to a separate class?
Can we move this logic to a separate method?
Can we call this from the ForkJoinPool to use a common method?
why we need to check for getQuota==null? I don't see the usage of getParameters().getDiskInfoDestinationMap().get(diskImage.getId()) in the canDoAction method
why we need to check for getQuota==null? I don't see the usage of getParameters().getDiskInfoDestinationMap().get(diskImage.getId()) in the canDoAction message.
why we need to check for getQuota==null? I don't see the usage of getQuota() here.
don't use a constant for this.
don't use a variable for this, use the previous method
can we use the strings.xml in this case?
nit: this can be private?
nit: this can be a method reference?
nit: this can be a constant, and not a local var?
Why change this?
Why don't we return a IMicroblockContainerTile and not the one you change?
Why don't we return a IMicroblockContainerTile and not the one you change it?
Catching Throwable would be a bit more appropriate.
Catching Throwable instead of just RuntimeException would be better
RuntimeException?
please make sure you are rebased. this method was renamed on Feb 11.
please make sure that you are rebased. this method was renamed on Feb 11.
please make a method with descriptive name
This should be a nested if-else block, so we don't repeat it every time.
No need for this check, we can use a ternary operator: if (this.apnsConnection!= null) {
No need for this check, it's always the same.
We should make this method private since its part of the 'if' block is inside the same package.
We should make this method private since its part of the 'if' block is at same time.
We should make this method private since its part of the 'if' block is inside the 'if'.
I think you can use the value of System.getDefaultWriteMode() here instead of having to create a new one.
I think you can use the value of System.getDefaultWriteMode() here instead of writing it to a file.
I think you can use the value of System.getDefaultWriteMode() here instead of duplicating the logic for the readAsCsv method.
Can you replace this code with one
Can you replace this code with one?
Should the strings be constants?
nit: can you put the null check on the next line?
nit: no need for this. here
nit: no need for this.
are these kems used for naming? I don't think it's a good idea to use the kem term rather than the whole program name.
are these kems used for naming? I don't think it's a good idea to use the kem term rather than the kem term...
could you use the syntax to make it more readable?
... I don't think this is necessary. Let's discuss about it.
... I don't think this is the best way to write a unit test for this.
Let's drop the this.
I think you will find that the other Predicates.Terminated() being called instead of timeL.
I don't think you need this condition. The toNanos() basically does nothing.
I don't think you need this condition.
It would be better to have a message saying "Failed to close the client"?
This does not seem to be a specific exception, you should have a log message.
It would be better to have a message saying "Failed to close the client."
isn't 1 or 2?
return permission / 2 + permission
return permission / 2 + permission;
reduce to debug
decrease to TRACE
reduce it to debug
I don't think we should use the assertThat and the error message here.
I don't think we should use the generic lang API here...
I don't think we should use the full config here... especially for the other messages...
Why not use an Iterable here?
Why not use "return listIncompleteUploads(bucketName)" here?
Why not use null here?
I'm not sure if it's valid for 5 seconds, I suggest to modify it.
I'm not sure if it's valid for 5 seconds, I would use: timeout, timeouts (e.g. 5 seconds, 5 seconds).
I'm not sure what timeout value actually does.
can use 'else if'
can use 'public static'
can use Catching Throwable and returning as the cause.
This switch statement should be in the switch.
This switch can be removed
This switch statement should be omitted
Let's just put this in a synchronized block to avoid the potential concurrent hash map.
Let's also put synchronized on the next line for loop.
Let's just put this in a synchronized block to avoid the potential concurrent declaration.
In onError method the class is unable to get the player and an IOException, do we want to show error?
Apply code to all such try/catch blocks to ensure that we throw an exception is thrown during execute method.
Apply code to all such try/catch blocks to ensure we throw a RuntimeException.
Check if obj is null.
Check if the bit is not XBee64BitAddress.
Check if the bit is open or not.
I'm not sure this is going to create a new HashSet with references to every date in the calendar every time isHoliday() is called. This seems pretty expensive given that isHoliday() is called many times by the uniqueId.
I'm not sure this is going to create a new HashSet with references to every date in the calendar every time isHoliday() is called. This seems pretty expensive given that isHoliday() is called many times by the uniqueId. The state of this class is either a simple contains()-type lookup or a static instance.
I'm not sure this is going to create a new HashSet with references to every date in the calendar every time isHoliday() is called. This seems pretty expensive given that isHoliday() is called many times by the uniqueId. The state of this class is a simple contains()-type lookup.
Also add message for the exception?
Also add message for exceptions
Also add timeout?
should we log to warn?
should we log the exception?
should be e.printStackTrace();
Shouldn't this be Ensures instead of getClass().getSimpleName()?
Shouldn't this be getClass().getClassLoader()?
Shouldn't this be Ensures instead of getClass().getSimpleName() as well?
I think you should create a new instance of the setUp() method and call super.onClass() in the tearDown method.
I think you should create a new instance of the setUp() method and call super.onClass() on the next line.
I think you should create a new instance of the setUp() method and call super.setUp(); or in the tearDown method.
nit: should be called Capable canUpload the same for the non-standard git state
nit: should be called something like "isPushToAtLeastOneRef"
nit: should be called Capable canUpload the same for the non-standard git data
Please revise this statement
Please revise this statement in this file
Please revise this file
Is this going to be fixed? Could you change it to a logger instead?
Is there a reason to use milliseconds here?
Is this going to be fixed?
Because of the changes to supported item types, this throw message should probably be updated to something like "Items of type {} are not supported."
Because of the changes to supported item types, this throw message should probably be updated to something about the item type.
Because of the changes to supported item types, this throw message should probably be updated to something else
should it be context.identTableDefinition() instead of visit()?
Shall we make it more readable as: String p = context.identTableDefinition(); context.identation();... ident
Shall we have a method for this one with more arguments?
suggestion if (newAttributes.isEmpty()) {
If you have to specify an explicit type, you should use throw IllegalArgumentException as second argument.
If you have to specify an explicit type, you should use throw IllegalArgumentException as second argument. <LINK_0>
Couldn't you just do System.exit() with the default value then?
do you want to leave the System.exit() call in?
Couldn't you just do System.exit() here?
I would prefer to make this protected, as it is part of the public API.
I'd prefer to make this protected, as it is part of the public API.
I'd prefer to make this protected instead of public.
I would suggest making this a Configuration class that contains some sort of "multipart" as part of the code.
I would suggest making this a Configuration class that contains some sort of "multipart" as part of some code.
I would suggest making this a Builder, it'll be more robust.
Missing a bracket.
Does this need to be protected static?
It's a waste to create a protected static field here.
Shouldn't this be stream()?
Shouldn't this be stream's.map()?
Shouldn't this be stream's forEach?
is this method deprecated?
is this method used for tests?
is this method called in tests?
Why not Thread.currentThread().interrupt()?
Runtime.currentThread().interrupt(); should be more explicit
Runtime.currentThread().interrupt();
Why not call the return value in the catch block for delete?
Why not call cache.computeIfAbsent in the return value of create?
Why?
Check for null "" first.
please don't change the indentation level
please don't change the indentation level.
This is super minor but you can use a variable for the action.
This is super minor but you can use a single line statement
This if statement is not necessary.
See isAccessible()
See if you can use resource.toFile() instead of isAccessible()
See if you can use method reference.
I would rename this to secondDiagnoses, as it is an Encounter object
I would remove the Encounter object from the methods below
I would rename this to secondDiagnoses, as before
should be false, true?
should be false, and be true?
should be false, and be true.
I would remove the for loop here, since the addedNetworkAttachments isn't doing the same thing.
I would remove the for loop here, since the addedNetworkAttachments call does the same thing.
I would remove the for loop here, since the addedNetworkAttachments call may remove the extra network...
This method seems to be missing a test case.
This method seems to be missing a test case. Can it be a display string?
This method seems to be missing a test case. Can it be a display string? Also, is there any special reason to use different meaning for this?
I found a bug in Presto: - Is there a specific reason to not check for null (i.e., Boolean.isNull(0.1 * totalCount)) - Float.isNull(0.1 * totalCount)?
I found a bug in Presto: - Is there a specific reason to not check for null (i.e., Boolean.isNull(0.1 * totalCount)) - Float.isNull(0.1 * totalCount) Maybe instead of assert?
I found a bug in Presto: - Is there a specific reason to not check for null (i.e., Boolean.isNull(0.1 * totalCount))? - : ;)
I think the message here is incorrect, shouldn't it be "request spent" --> "request spent"
I think we should update the message here to something like "ToThe transport buffer is backed up"
I think the message here is incorrect, shouldn't it be "request spent..." --> "Request spent"
Revert?
Revert if you make this
Revert if you make this method.
Should be user.getName()
All the above throws GroupNotFoundException
Should be non-empty?
As the assert is not null in the order by and we want to assert on the value of the file path in the error message.
As the assert is not null in the order and the asserts are redundant, I think this could be assertNull
As the assert is not null in the order in the assert.
can use boolean parameter to avoid NPE
can use boolean parameter to avoid NPE.
can use lamda
The following two test methods should also be executed in the [createUpdate()](<LINK_0>
The following two test methods should be executed in the same order as in the other tests.
The following two test methods should also be executed in the [create()](<LINK_0>
Do we need this?
Do we need this if we're going to have truth?
Do we need this check?
I saw this as a part of the PR, but when I asked to roll back and it would still be the same. Did you check the app with the phone manager?
I saw this as a part of the PR, but when I asked to roll back and it would still be the same. Did you check the app with the phone manager to get the app?
I saw this as a part of the PR, but when I asked to roll back and it would still be the same. Did you check if the app is auto-generated value?
This throws an UncheckedIOException. You should use UncheckedIOException.
This throws an UncheckedIOException. You probably want to use closer.register(() ->  UncheckedIOException.
This throws an UncheckedIOException. You probably want to use closer to the caller?
Can we use StringUtils.isNotBlank here?
Can we use StringUtils.isBlank here?
Consider using StringUtils.isNotBlank()
is it the reason for the test to return false?
is it covered by the test?
Assert.fail() the whole stack trace is not relevant
I'd guess we should use an instance of this for each class, not a singleton.
I'd guess we can use an ArrayBlockingQueue, as it is not a good practice.
I'm not sure we need this..
I think we should use / or the value of /importsHome/importsHome instead of /importsHome/importsHome/
I think we should use / or the target path instead of /importsHome/importsHome/importsHome/
I think we should keep the value without exponent to variable names.
In Java, it's better to use Jackson (JSON) library here.
In Java, it's better to use Jackson (JSON) library here and in these cases rather than using System.out.println().
In Java, it's better to use Jackson (JSON) library here and through the Java API.
We have constant for "mobile:md" and "mobile:md"
We can use constant
We have constant for this type: "mobile:mdunit"
You should check that the generated patient is the same as the id.
You should check that the generated patient is not null
You should check that the generated patient is the same as the ID.
Could use Objects.hash()
Could use the Objects.hash() method here
Can you use Objects.hash()?
Can we use UTF-8? Properties#getBytes("UTF-8")?
Can we use the Locale.ROOT to not worry about the charset here?
Can we use the Locale.ROOT to not worry about this for debugging.
Should this be mappedEntity.values() instead?
Should this be catch instead?
Should this be mappedEntity.values() instead of null?
1. let's create JaxbJobReader to store it, instead of using it. 2. JaxbJobReader = new AnalysisJobXmlInputStream(_dataCleanerConfiguration) Then we don't have to worry about creating it, but not using it.
1. let's create JaxbJobReader to store it, instead of using it. 2. JaxbJobReader = analysisJobXmlInputStream.read()
1. let's create JaxbJobReader to store it, instead of using it. 2. JaxbJobReader = new AnalysisJobXmlInputStream(_dataCleanerConfiguration); to create JaxbJobReader by using _dataCleaner which is needed to find the name.
you can use String.format here
use String.format here
use String.format
why we need to synchronize here?
why we need to change this?
why we have to synchronize on the test method?
Why these magic numbers?
Do these magic numbers get used twice?
Why 2?
Any particular reason that you published an Igneous ProcessingManager instead of publishing an item? Remember that pumpEvent exists.
Any particular reason that you published an Igneous ProcessingManager instead of publishing an interval?
Any particular reason that you published an Igneous ProcessingManager instead of publishing an item?
Is this fixed? I see it not handled.
Is this fixed? Why not use reuse the default method from the init method?
Is this fixed? Why not use the default cal-tra parameter?
These are not necessary - and this test can be run without the @Before
These are not necessary - and this can be removed
These are not necessary - and this test can be run without the save.
Add final keyword.
At some point, we now have to declare and then return IT.
At some point, we now have to declare and wrap it in curly brackets
shouldn't we assert fileStream is not null?
shouldn't we be closing the fileStream in finally?
please use FileOutputStream instead
Optional
null check
null
I would say that this would be a different method than remove the "deploy"
I would prefer to make this method final
I would say that this would be a better place to make a method on the Context interface. Just like "deploy"
did you consider to use IncrementableEntryVersion.incrementVersion() instead of this?
did you consider to use IncrementableEntryVersion.incrementVersion() instead of 0?
IncrementableEntryVersion.incrementVersion() always returns 0. Would drop the not-null check here?
I think we should use org.apache.commons.lang3.StringUtils.isEmpty(value) here.
I think we should use org.apache.commons.lang3.StringUtils.isNotEmpty(value) here.
I think we should use org.apache.commons.lang3.StringUtils.isEmpty(value)
RESET_INSTALLPOINT, and getMarkerMessage?
RESET_INSTALLPOINT, getMarkerMessage?
setAttribute is not needed.
The constructor should delegate to the new Path("file:/ ") method
This method could be private and called by subclasses
The constructor should be here?
Is it necessary to have this.distanceTolerance < MIN_TOLERANCE?
Is it necessary to have this here?
Is it necessary to have this if statement in the constructor?
Has this actually changed to include agreement_id?
Has this actually changed to include agreement_id? i.e. include "mandate"
there is no need to create another value for this?
It seems like this should be a Set instead of an array.
It seems like this should be a Set instead of a Map?
It seems like this should be a Set instead of an array of Map?
Can we use the isEmpty() syntax here? java if (tail.isEmpty()) { return false; }
Can we use the same iterator syntax here? java contains(tail) &&!tail.isEmpty()?
Can we use the isEmpty() syntax here? java contains(tail) ||!tail.isEmpty()?
Should it be a LinkedHashMap?
I don't think this should be a Set
I suspect this should be a set instead?
java.util.Objects.hash(helper.getDeletion(), this.helper.hashCode());
java.util.Objects.hash(helper.getDeletion(), result).hashCode();
java.util.Objects.hash(helper == null)? 0 : ((Command<T>) obj).hashCode();
Might want to possibly use java.net.whitespace here.
Might want to strip or trailing whitespace.
Might want to possibly use java.net.SQL here?
nit: keep the order consistent.
nit: keep the order concise, and move it after the checks.
nit: keep the order concise, and move it after the registration.
nit: Keep the copyOf on the line above?
nit: Keep the copyOf on the line above.
nit: keep the order consistent.
exception is never propagated?
exception is never thrown?
exception could be improved
Please don't use a local variable for this (line 25 and 27)
Please don't use a local variable for this (line 61-79).
Please don't use a local variable for this.
I think you may want to move this block to line WARN instead of ERROR.
Imho, you may have to add a new method boolean isFlushing(String) for the 'performedWarning'.
Imho, you may have to add a new method boolean warn(String s) which calls up to you. Then you don't need the conditional.
I'm not sure that the correctness of the code is safe. We should use the Folder Artifact to make sure that the correctness of the returned value is in the expected state.
I'm not sure that the correctness of the code is safe. We should use the Folder Artifact to make sure that the correctness of the value is in the expected state.
I'm not sure that the correctness of the code is safe. We should use the Folder Artifact to make sure that the correctness of the returned value is the expected one.
I guess this is OK, but for future reference, it is better to log the exception.
I'd propose to log the exception and print it.
I'd propose to log the exception and print the stacktrace.
you could use brackets around labelsObject.addAll
you could use brackets around labelsObject.add("label")
you could use constants from getField
java String courseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(courseName1); return desanitizedCourseName1.compareTo(courseName1.courseName2);
java String courseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(courseName1); return desanitizedCourseName2;
java String courseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(courseName1); String courseName2 = SanitizationHelper.desanitizeFromHtmlSanitized(courseName1); return desanitizedCourseName2;
Maybe it would be good to have a return type of property so we don't have to support it in the factory?
Maybe it would be good to have a return type of property so we don't have to support it in the new code.
Maybe it would be good to have a return type of property so we don't have to cast it here
I don't think it's particularly safe to do this. Could you update the metadata object to ask if the metadata exists?
I don't think it's particularly safe to do the null check here. Could you update the implementation of metadatas.add(metadataName); and keep this method unchanged?
I don't think it's particularly safe to do the null check here. Could you update the code to make this more explicit?
nit: suggestion Objects.requireNonNull(text, "'text' cannot be null.");
suggestion Objects.requireNonNull(text, "'text' cannot be null.");
nit: > 0, so the default behavior is to be consistent with the other implementations.
it doesn't work for multi reference + complete tests please.
it doesn't work for multi reference + complete tests please
probably don't work for multi reference + complete tests please.
Could you please use another name for the 'NPM_NAME_PATTERN' constant? It is a bit easier to read.
Could you please rename this to shouldUnPM_NAME_PATTERN?
Could you please use another name for the 'NPM_NAME_PATTERN' constant?
how can it be null?
it's better to have the viewer.getParent() as a parameter?
it's better to make sure element is not null before view. (ConcurrentHashMap)
what about the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to be called here?
what about the permissions in ImportVmCommand and ImportVmFromExternalProviderCommand?
what about the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to be called?
other.recipient_id can be null if it is not a OSCoreCtx
other.hashCode() can be simplified by using Objects.equals()
other.recipient_id could be null, I think we should include a test for it
This is similar to Decryptor
This is similar to Compressor
This is similar to SubmitterContext#getFailureCollector(). Should do that.
You can set the label test in the ui binder file for both versionLabel and userNameLabel.
You can set the label test in the ui binder file to the user.
You can set the label test as well.
I don't think you want this condition to be true. It is always false.
I think you want to use the comparison operator to compare booleans. It will also enable you to USE_CACHE_MODE_LOCAL in future.
I think you want to use the comparison operator to compare booleans. It will also enable you to USE_CACHE_MODE_LOCAL
Do we need to apply this? It seems that creating a new ExportAlarmDue value would be strange to encapsulate the logic of getting weightDueTimeOnBind into a method.
Do we need to apply this? It seems that creating a new ExportAlarmDue value would be strange to remember that there is a request issue.
Do we need to apply this? It seems that creating a new ExportAlarmDue value would be strange to encapsulate the logic of getting weightDueTimeOnBind into the Elide logger
here, we can only do if (costFunction.add(costFunction.add(costFunction))
here, I think we should change this to debug level.
here, I think we should change this to debug.
Is this a static method? Allowing non-static, can we make it static?
Is this a static method (e.g. parse()? )
Is this a static method? Allowing non-static, can we make it public?
Should this be assertThat(conf.loadConfiguration()).isFalse()?
Should this be assertThat(conf.loadConfiguration(), hasSize(1));?
Generics on the right are redundant since Java 8
I don't think this is right. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
I don't think this is right. Even if we do this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
I don't think this is right. Even if we did this for immutability, we'll have to do this again in getter methods.
Change this to return scriptRunner.runScript(jobInstance);
Change this to debug
Change this to a single log statement
this synchronized block is essentially no-op, but some do "gc/runFinalization/gc".
this does seem to cover some people who might have a legit reason. but some do "gc/should be initialized".
this synchronized block is essentially no-op, but just a wrapper.
Integer.hashCode(inputOffsets) will be the same as this.
Use Integer.hashCode(...)
Integer.hashCode(...)
do not use getters; just return in the middle of an appointment
do not use getters; just return in the middle of the method
do not use getters; just return in any case. Use an appointment_SUFFIX, you should always have id: java.lang.AssertionError
If you are going to have a null check expires time, there's no reason to use that here. The function is called from expires to get expires time.
If you are going to have a null check expires time, there's no reason to use that here. The function is only called once per process, this method is called.
If you are going to have a null check expires time, there's no reason to use that here. The function is only called once per process, this method is called twice.
Can we use Flux.fromNullable to avoid null checks?
Can't this be Flux<Message>?
Can't we use Flux.fromNullable to avoid NPE?
Typo: invalidConfiguration
Can be simplified to this: return invalidConfiguration
Can this be package-private?
Wouldn't it be faster to just add a method to the super class?
Wouldn't it be faster to just compute the next iteration only once and return early?
Same question
Can we please throw a IllegalArgumentException when the value is null?
Can we please throw an IllegalArgumentException when the timeoutMs is greater than 0?
Can we please throw a IllegalArgumentException when the timeoutMs is greater than 0?
Why is the second possible mismatch between the results of expected?
Why is the second possible mismatched here?
Why is the second possible mismatched?
This method should check for null just in case it can't be null.
This method should check for null just in case.
This method should check for null just in case
Maybe this.name -> REQUIRED == field.requirement)?
Maybe this.map line should be indented.
Maybe this.
I think this should be sanitized for null elements
I think this should be sanitized for start and end of the call to fail.
I think this should be sanitized for start and end.
wouldn't it be more readable to use single statements for (List<String> attributeList : attributeList) {... }
wouldn't it be more readable to do attributeList.size() - 1?
change to 'ArrayList<String>'
How about replacing this with if (this.hasNext()) for consistency?
How about replacing this with if (this.hasNext()) {
How about replacing this with if (this.hasNext())? I don't see why you need this entire if statement...
should use listeners.add(listener) instead.
should use listeners.add(listener,...); instead.
should use listeners.addAll(listener,...
Can we use MockProtocolFactory.startTransport() instead?
Can we use MockProtocolServer.startTransport() instead?
Can we use MockProtocolFactory.startTransport() here?
negative logic
negative logic: negative logic
negative logic I think
I'm not sure why this change is needed. The caller of getSegments() has to know about the copy of the data.
I'm not sure why this change is needed. The caller of getSegments() has to know about the read length
I'm not sure why this change is needed. The test only include the first segment.
I think we can simplify this code by just calling value.toString()
I think we can simplify this code by using Objects.firstNonNull(value, "null"); return value.toString();
I think we can simplify this code by using Objects.firstNonNull(value, "null")
.filter(paramType::cast)
.filterMethodParameters(paramType) is already a request
.s/private//
We should use StringUtils.isBlank here.
We should also check for null here.
We should not throw InvalidSettingsException, this line is duplicated
Log and throw.
what if m_client!= null?
what if m_client is null?
I think this should not be needed. The only reason to put the catch statement is that the test fails is that it should catch all exceptions in the **fail** method.
I think this should not be needed. The only reason to put the catch statement is that the test fails is that it should catch all exceptions in the **Test** method.
I think this should not be needed. The only reason to put the catch statement is that the test fails is because of the @Test annotation.
Should this be in the constructor?
Should this be in an else statement?
Should this be in an else block?
intellij suggests indentation here.
intellij suggests using streams/defer but
.
Maybe add a warning log here?
Maybe add this check to the param in the exception?
Maybe add this check to the param?
This can be simplified to return getSnapshottableDirListing(snapshotRoot, snapshot.getSnapshottableDirListing());
This can be simplified to return getSnapshottableDirListing(snapshotRoot, snapshot.getSnapshottableDirListing()); as per the doc above?
This can be simplified to return getSnapshottableDirListing(snapshotRoot, snapshot.getSnapshottableDirListing()); as this is already abstract.
style nit: we're using braces around single line blocks
style nit: we're using "jgit" style elsewhere, I'm going to cherry-pick this directly onto master.
style nit: we're using "jgit ls-files"
.equals and hashCode are redundant in the client.
.equals and fromGetter can be null safe.
else
What are the deserializers used for? Could we not just use the deserializer itself?
Could this be private?
Could this be private? It is only used in tests.
Can we check that there are other modes if we have to make changes in the future?
Can we check that there are other modes if we be able to create a wrapper for this.
Can we please make this method private?
@ekondrashev remove this one
remove the use of this one
remove the use of the parameter?
Can you use isEmpty()?
Can you use isEmpty()?
Can you change this to isEmpty?
Please revert this file.
Please extract this to a constant.
Please remove this so that we can have a single return statement.
Is it a good idea to use the constant from parser jar rather than magic number?
Is it not possible to use the constant to DEFAULT_EN_PREFIX?
Is it a good idea to use the constant from Character and add it to it?
Can we remove writeLong(k) or use primitive int?
Maybe we can add an writeLong(k) to the slice model?
Maybe we can add an writeLong(k) to the map and fail
We should add logging to indicate what's going on (why we warn it?)
It isn't good to throw an exception with a message (why we are verifying doThrow)?
We should add logging to indicate this condition
should be getNode(TokenTypes.IDENT)
same here (using getNode)
should be getNode(TokenTypes.IDENT)?
Can't we use an Optional here?
Could be simplified to use Optional.ofNullable(groupName)
Could be simplified to use Optional.ofNullable(key).
This seems to be a copy of the map, but it is not safe to use it in other places.
This seems to be a copy of the map, but it is not safe to use it to grab it.
This seems to be a better place to define it.
I don't think it's correct. the.isEmpty() check is required (the number of checks in this case)
I don't think it's correct. the.isEmpty() check is required (the number of checks in this commit)
I don't think it's correct. the.isEmpty() check is needed (the number of checks in this case)
There's a lot of duplicated code here in the test. I think you can extract a private method for this.
There is a lot of duplicated code here in the test. I think you can extract a private method for this.
There's a lot of duplicated code here, you could extract a private method to simplify this.
We don't want to calculate anything.
We don't want to use dynamic parameters.
We don't want to use dynamic values of the sort algorithm.
use Collections.emptyMap() (same for other methods)
use this here, Collections.emptyMap() is enough
use Collections.emptyMap() (same for other methods).
Arrays.asList is a bit better.
should it be ArrayList?
Doing it this way will not crash if program doesn't use sorted
static import
static import?
static
can we declare start + end of the loop? I think it can be checked in the first place.
can we declare start + end of the loop? I think it can be checked in the current implementation.
I think this can be checked with a NullPointerException, I think.
linuxNameToOS would be simpler: LOGGER.warn("{}s are currently not supported.", osType);
linuxNameToOS would be nicer, even if it's not supported.
linuxNameToOS would be nicer, even if it's not supported on Windows.
I believe it would be more understandable to do the following: // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
I believe it would be more understandable to put the following: // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
I believe it would be more understandable to do the following: // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", ".", format);
Should be Override
Should be private
Should be append
URI instead of URI?
URI can be null
URI instead of URL?
This is confusing. Where does it come from?
This is confusing. Where does the cache come from?
This is confusing. Where does it happen?
should we just use SVG or Collections#addAll()?
should we just use SVG or Collections.unmodifiableMap?
perhaps should we just use SVG or Collections#addAll()?
Please don't use lazySet here. It actually leaves them as much as possible.
Please use lazySet instead of lazySet here.
Please don't use lazySet here. It is only used in old code.
I think this exception should be added to update() method signature. In this case, it would have been better to remove this line.
I think this exception should be added to update() method signature. It is not here, but it would have been better to offer it back. In this case, i.e. outstanding.remove(this)?
I think this exception should be added to update() method signature. It is not here, but it would have been better to offer it.
Please use diamond operator.
Please use streams here
Please use Map.of
Space before {
Should return getDescription()
Make this private
Could be simplified to Collections.singletonList(signedHeaders);
this should be copied from the constructor.
this should be copied to the top. Could throw all these.
don't think this should be delegatingResourceDescription
don't think this should be REFS
don't think this should be delegatingResourceDescription then to the base class.
use Files.newInputStream
use Files.newBufferedWriter(jsonString, "pathToJsonFileStats")
use Files.new FileHelper(jsonString, pathToJsonFileParam)
Should this be a switch?
Should this be a switch statement?
Should be a space after,
What if the key was not a ReentrantLock before? If you want to use it, then you can use getLockForKey instead.
What if the key was not a ReentrantLock before? If you want to use it, then you can use getLockForKey.
What if the key was not already encoded? Guessing it would be simpler.
This can be simplified to return networkSettings.getString(NETWORK_SETTINGS) && (jsonSettings.isNull() || networkSettings.getString(NETWORK_SETTINGS) && (json.getString(NETWORK_SETTINGS) && (json.getString(NETWORK_SETTINGS) && (json.getString(NETWORK_SETTINGS) && (json.getString(NETWORK_SETTINGS))))
This can be simplified to return networkSettings.isNull()
This can be simplified to return networkSettings.getString(NETWORK_SETTINGS) && (jsonSettings.isNull() || networkSettings.isNull()
Should this return ImmutableList.copyOf(hits.size());
Should this return ImmutableList.copyOf(hits.size()); instead?
Enforce immutability.
Can regName be null?
Can regName be null? I think it's safe to use ENGLISH here.
I think it's safer to use substring here.
use the try-with-resources block
use the try-with-resources statement here
use the default constructor which does this automatically.
You can use SingleTokenStats.None.equals(tokenUuid) here.
switch on enum constants?
switch on your equals method and here.
Can we use generic exception here? It's a RuntimeException already in this class.
You shouldn't need to use generic exception here. Can you just add it as a parameter of the fragment and call the newInstance method?
Can we use generic exception here? It's a RuntimeException
Please add the type to the Map<Startpoint>
Just a suggestion, but we can't use the optional here.
Just a suggestion, but we can't use the iterator directly here.
No need for checkNotNull(id) here.
No need for public.
No need for checkNotNull(id) please.
Remove unnecessary this
Move this into the second branch if (focusView!= null check )
Move this into the second branch if (focusView == null) check.
This seems to return the old connection since it's opening an old connection
This seems to be a leftover from the change
This seems to be obsolete
It seems like this should be a no-op as the id of the entity manager.
It seems like this should be a no-op as the entity manager.
It seems like this should be a no-op as the id of the entity factory.
Should this be containsKey?
should this be containsKey?
Should this be Integer?
return only if there is an computeIfAbsent?
return only if there is an AnalysisModule?
return only if there is no AnalysisModule?
Think string is better to add method name to VillagerEntity.
Think string is nice to add ischeckNotNull() method
Think string is better to add method name to the api method
Why is this needed?
Why false is used here?
remove the extra parentheses
Again we can use ArrayList for the list.
Again we can use Set.
Can we cache the list of nodes to avoid list?
why public?
you have a static variable which is parameterized.
you have a new line between statements, please.
Ternary would be easier to use.
Work<?> work =...
Ternary would be easier to read.
Is there a way to do this using replace(Base64.getDecoder().decode(base64.getBytes())? The advantage of doing that is, I don't understand why this works.
Is there a way to do this using replace(Base64.getDecoder().decode(base64.getBytes())?
Is there a way to do this using Base64Util.getBase64(String) instead?
Could be replace with StringUtils.isNotBlank(text.isBlank())
Consider using StringUtils.isNotBlank instead
Could be replace with StringUtils.isNotBlank(text.isNotBlank())
Might be worth having a displayName?
Might be worth adding a displayName?
Can we localize this?
Doesn't mSignatureBitmap be null?
Is this correct? mSignatureBitmap is null and mSignatureBitmap is null
Is this correct? mSignatureBitmap is null and mSignatureBitmap can be null?
this doesn't seem to be testing anything.
this doesn't seem to be used anywhere.
what about using randomAlphanumeric? I think it will be easier to use that.
Can we put the url in a variable? The url could be passed to it without any problem.
Can we put the url in a variable? The url could be passed to it without any context.
Can we put the url in a variable? The setter should look up to the first line.
So this allows an env prop to enable a feature that is really defined, right? I'm fine with this.
Does this need to be a containsKey()?
So this allows an env prop to enable a feature that is really defined, right? I'd imagine it would be slower than just returning true.
suggestion LOG.error("Failed to pop the queue of "+ counter.get();
suggestion LOG.error("Failed to pop the queue of " + counter + "?");
We should add a log.error statement here.
static import COL_ID_PROCESSNAME and COL_ID_PROCESSNAME_PROCESSNAME
static import COL_ID_PROCESSNAME_PROCESSNAME and COL_ID_PROCESSNAME_PROCESSNAME
static import COL_ID_PROCESSNAME and COL_ID_PROCESSNAME
This should return Task, not Task.
Same here, should we throw an exception if the task has already started, instead of calling.withSideEffect(new Callable<>());?
Same here, should we throw an exception if the task has already started, instead of calling.withSideEffect(new Callable<T>()?
Maybe we could use the constant here?
Maybe use the constant here?
Maybe we could use the constant in the State class?
I think this is not necessary. We don't store the metricAttribute, but we don't need this.
I think this is wrong. We don't need to do this. The empty string code is present.
I think this is wrong. We don't need to do this. The empty string code is present only.
Would it be better to have a.ling journal here? Then we'll get a ride of the day.
Would it be better to have a.Precondition(T...) here instead?
Would it be better to have a.ling journal here? Then we'll get a ride of how the day.
I think this is not enough. If we want to validate the metric name, we can call MetricRegistry.name() instead.
I think this is not enough. If we want to validate the metric name, we can monitor it.
I think this can be removed.
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return statement
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return statement.
Let's make this method private. This can be called from the first place.
same here, must be atomic
Missing @Override
IndexOutOfBoundsException
i would rather add theRuleName to the rule name, as it is also changing the rule name. It is also more clear that rules areRuleName will not be rule rule, but for cases where the rule can beRuleName will be restarted.
i would rather add theRuleName to the rule name, as it is also changing the rule name. It allows for cases where a rule can beRuleName will be restarted.
i would rather add theRuleName to the rule name, as it is also changing the rule name. It is also more clear that rules areRuleName will not be rule rule, not the rule name.
We could also use this.data to be consistent with Visibility
We could also use this.data to be consistent.
We could also use this(data, data, false, data.
we shouldn't be calling the userkeyPreferenceRepository.setToolTipText(Messages. store_user_url); replace the user user.reference(Messages.setToolTipText(Messages.SendzillaRestRepository.isValidUrl(url));
we shouldn't be calling the userkeyPreferenceRepository.setToolTipText(Messages. store_user_url); replace the user user.reference(Messages.setToolTipText(Messages.SendzillaRestRepository.run(Messages.properties));
we shouldn't be calling the userkeyPreferenceRepository.setToolTipText(Messages. store_user_url); replace the user user.reference(Messages.setToolTipText(Messages.url).
What would you mind about the following? java SetViewClass<?> aggregateClass = flatten(a, b); return aggregateClass;
What would you mind about the following? java SetViewClass<?> aggregateClass = flatten(a,b) -> { if (a) { return sinkClass; } else { return new HashSetViewClass(); } };
How about using a SetView class instead of a Map? Just a thought.
I think it would be better to use the builder here instead of a real regex, as in <LINK_0>
I think it would be better to use the builder here instead of a local variable.
I think it would be better to use the builder here instead of a real index, as we are not changing the first character anymore.
extra space.
static import parseMessageType
also change to "\n"
singular
zoneId should still be used
zoneId should still be null
Would be nice to have a constant for "hidden" and "show"
Would be nice to have a constant for "hidden" and "hidden"
Would be nice to have a constant for "hidden" and "hidden".
Can return null
Can return Collections.emptyList()
Can be package private.
this field name is confusing since the parameter passed to the constructor is a File but this is a PackExt, maybe better packFileName
this field name is confusing since the parameter passed to the constructor is a File but this is a PackExt. I would expect this to be a valid name.
this field name should be the name of the pack file
There is no need to call super explicitly. Same applies to other constructors.
There is no need to call super explicitly. Same applies to other constructors. Add this in the other constructors.
There is no need to call this on a new instance. I believe it can be null. Add a @param annotation to the other constructor.
I think it will be better to create the corresponding recipeFileContentProvider instead of java RecipeContainer recipeFileContentProvider.devFileToWorkspaceConfig(devfileToWorkspaceConfig.devFileToWorkspaceConfig(devfileToWorkspaceConfig))
I think it will be better to create the corresponding recipeFileContentProvider instead of java RecipeContainer recipeFileContentProvider.devFileToWorkspaceConfig(devfileToWorkspaceConfig.devFileToWorkspaceConfig(devfileName));
I think it will be better to create the corresponding recipeFileContentProvider in java java <LINK_0>
Could we use Message here?
Could we use a more informative message?
Could we use a more informative log?
This test checks topic creation. Why do you call replyTopicStubs?
This test checks topic creation. Why do we call replyTopicStubs?
This test checks topic creation. Why do we wrap wrap in try block?
Should it be!JavaVersion.class.isAssignableFrom(major))?
Should it be!JavaVersion.class.isAssignableFrom(major) && other.major == other.major?
Should it be!JavaVersion.class instead?
Maybe we should move the status check to a private method? This way we can reduce the amount of code duplication
Maybe we should move the status to a private method? This way we can reduce the amount of code duplication
this could be private
Leverage on Files#exists and Files#isDirectory
Consider using Paths.get() to get the directory. <LINK_0>
Consider using Paths.get() to get the directory.
Why need this change?
Why need this?
Why need the second parameter?
same question as above.
same here. For instance a method is used to handle the case of meta.
same here.
Did you take a look at this? <LINK_0>
Did I take a look at this? <LINK_0>
Did this take a look at this? <LINK_0>
Looks like this can be simplified to : java return pageName.toLowerCase(Locale.ENGLISH).toLowerCase(Locale.ENGLISH).substring(1, pageName.length()).toLowerCase(Locale.ENGLISH);
Looks like this can be simplified to : java return pageName.toLowerCase(Locale.ENGLISH).toLowerCase(Locale.ENGLISH).substring(1, pageName.length()).toLowerCase(Locale.ENGLISH));
Looks like this can be simplified to : java return pageName.toLowerCase(Locale.ENGLISH).substring(Locale.ENGLISH);
This could be done with the this.o = ImmutableList.copyOf(pushOptions);
This could be unmodifiable
This could be made more useful.
@fanifieiev put the same content to share this in the same local variable.
@fanifieiev move the same content to share this in the same local variable.
@fanifieiev put the same content to share this in the same local variable
We should probably move this into the isChangeProgressValue method.
This should be done in LiteState#void updateProgressValue.
This should be done in OnChangeProgressValue, not on the index.
Same here, I'd prefer assertEquals() or assertThat().
Same here, I'd prefer assertEquals() or assertEquals().
Same question as above
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack? What you think?
shouldn't the test throw the exception, it will stay the same code
I think it would be better to create a constant for this string.
I think we could simplify this check by taking the boolean parameter.
I think we could simplify this check by taking the boolean value of the param.
Following the implementation we may get a random partition partition by the leaderId, so we should check if there's a partitionName, otherwise return that.
Following the implementation we may get a random partition partition by the leaderId, so we should check if there's a partitionName, otherwise, and if it is true, otherwise return false.
Following the implementation we may get a random partition partition by the leaderId, so we should check if there's a partitionName, otherwise, and if it is true, otherwise update the metric.
If the repository is null, this method can return null
style nit: no braces around single line blocks
If the repository is null, this method can be deleted.
This method is not thread-safe. I think it can be replaced by oldValue += value;
This null check is unnecessary. I think it would be better to just delete the oldValue, no?
This method is not thread-safe. I think it can be done with write.
please just use this.getClass().getSimpleName()
just curious... why would we need this?
please just use getClass().getSimpleName()
can we do this only if debug logging is enabled?
can we do this only if debug is enabled?
can we do this only once in the queuePurged loop?
if we want this to be a normal toString I would say "Traced a call to the client would be better recv to the others."
if we want this to be a normal toString I would say "Traced a call to the client would be better recv to the trace name."
if we want this to be a normal toString I would say "Traced a call to the client would be better recvGraph".
It seems like we should introduce a new method here that accepts both currentUser and securityAuthConfig, and command.
It seems like we should introduce a new method here that accepts both currentUser and permission, wdyt?
It seems like we should introduce a new method here that accepts both arguments.
Same thing here, we can avoid the loop if the reference is not null.
Same thing here, we need to clear referenceIndex list if it's not null
Same thing here, we can avoid the loop if the reference is not null
The maximum number of K properties should be configured to a constant.
The maximum number of K properties should be configurable.
The maximum number of K_s is a constant.
Shouldn't this be new SecurityExpressionRoot(SecurityContext)?
Shouldn't this be final?
Shouldn't this be getAuthentication()?
Is it required?
Is it guaranteed that the leadershipEventProcessor is different than leadershipEventProcessor?
Is it necessary?
Are you sure that one of the magic numbers are they?
Are you sure that the magic number here is the same?
Are you sure that one of the magic numbers are correct?
I think you should use innerList.remove(o) here.
I think you should use innerList.remove(o); here.
I think that innerList is an internal class, so you should not have to use it here.
No need to use static.
No need to use static member
Null check?
Why the previous line? I don't understand why we use a string. E.g. "deAwaitility.getTimeout().toString()". Is the debug level correct?
Why the previous line? I don't understand why we use a string. E.g. "deAwaitility.getTimeout().toString()".
Why the previous line? I don't understand why we use a string. E.g. "deAwaitility.getTimeout().toString()". Is the debug level what we want here?
Why do we need this for INSERT_INSERT/UPDATE/etc?
The switch statement seems redundant for the if.
The switch statement seems redundant.
Be careful here. I see that you have very many empty lines here.
Be careful here. I see that you have very good reason for this, and the previous one here will end up with spaces instead of spaces
Be careful here. I see that you have very good reason for this, and the previous one here will end up with very confusing values.
Why was this change needed? I have no idea why the test was to ensure a non-Acknowledged method is ignored.
Why was this change needed? I have no test for it.
Why was this change needed? I have no idea why the test was to ensure a non-null response is valid.
please move expression in parentheses to improve readability.
please move expression to a single check. This is more readable.
please move expression in parentheses
We can simplify the logic here by skipping the first segment ("if (operandsNum == 3 && "(" ").isOneLiteralTree()); If the boolean is always false, it will be true.
Unless there is a reason to change the first operand to true here, it should be just literalsNum == 3 && NumberNum <= literalsNum && atLeastHalfLongLiterals((TreeTree) >= atLeastHalfLongLiterals);
Unless there is a reason to change the first operand to true here, it should be just literalsNum == 3 && NumberNum <= literalsNum && atLeastHalfLongLiterals((TreeTree) >= atLeastHalfLongLiterals)
Shouldn't the exception be occurException?
Shouldn't the exception be Exception?
+1
suggestion "The future must not be cancelled.");
Setting the future.getmillisecond(false) to the timeout?
suggestion "The future must not be cancelled.";
Can't we use System.out.println(methods)?
Can't we use System.out.println here?
Is there a reason to use System.out?
Do we want this does not use compareAndSet?
What is the purpose of this change?
What's the purpose of this change?
Can this be package-private?
Can this be package private?
This constructor seems the best use the new constructor to call this one.
Please use a logger instead of println
Please use logger instead of System.out
Please use a logger instead.
By composition, do we need this?
By composition, do we need this? Could we add a checkArgument?
By composition, do you need this?
Once the test is in config, this can be removed.
Once the test is done, this should also be removed.
OOPS!
The second parameter of the getControl() method should go to the base class (e.g. getChartViewer()).
The second parameter of the getControl() method should go to the base class (e.g. getChartViewer()). Otherwise, it's not related to the data view.
The second parameter of the getControl() method should go to the base class (e.g. getChartViewer()). Otherwise, it's not related to the view.
Can you please revert this to the next PR and fix it tomorrow when both channels are different?
Can you please revert this to the next PR and fix it tomorrow?
Can you please revert this to the next PR and fix it tomorrow when there is a channel.
I don't like this.marshalSingleMessage. Let's make the squash the common location.
I don't like this.marshalSingleMessage. Let's make the squashing.
I don't like this.marshalSingleMessage. Let's make the squash the common interface instead.
should probably use Restricted(NoExternalUse.class)
Is this a special case for a sync attempt?
Is this a special case to load multiple properties?
space between ) and {
space after,
adding a space after the comma
Please replace the assertRequestObjectType with a proper message.
Please replace the actual type check with: throw new ProtocolAdapterException("The request object has an incorrect type.");
Please replace the assert with a more meaningful message.
Would be better to write something like this: java if (StringUtils.isBlank(dataType) ) { throw new ParseException(candidate); } //...
Would be better to write something like this: java if (StringUtils.isBlank(dataType) ) { throw new ParseException("Unsupported value type"); }
Would be better to throw IllegalArgumentException here
Do we really need a lock if tx.getTxMap() returns null?
Do we really need a check here? I think that TxMap.getTxs() returns null
Do we really need a check here?
Should throw an exception instead of checking for null
Please add braces to your change.
Please add braces to your if-statement.
Can you use id.getObjectForNodeId() instead?
Can you just use id.getObjectForNodeId() instead of id?
Can you just use id.getObjectForNodeId() instead?
Why are we exposing the map in the concrete implementation?
Why are we exposing the map in the concrete classes?
Why the set?
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line -> is
wrong formatting
Let's make this synchronized.
This logic is duplicated into this.settings = sslContext;
This synchronized is unnecessary.
nitpick: change this to FinFSState.newAccount().
nitpick: change this to FinFSInformation.newAccount().
nitpick: change this to FinFSState.newAccount().?
Should this be done in a different PR?
Should this be done in the resource builder?
Should this be done in a different PR, or a flag named "hasDefined".
Why does this method have to be public?
Why does this method need to be public?
Why does this method need to be called from the registry?
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
nit: this is Optional.ofNullable(metricName.safeTags().filter(x -> x.equals(String.valueOf(currentLeader)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
nit: this is Optional.ofNullable(metricName.safeTags().filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
Can't we just call Optional.findFirst() here? It would avoid the need for null checks below
Can't we just call Optional.findFirst() here? This would avoid null altogether.
Can we please avoid calling Optional.ofNullable here?
I think it makes sense to add 5 userInput.ERO; :)
This one can be static
This one can be static.
add spaces between () and {
add spaces between () and {.
add spaces between () and ".
@vrushaliwaykole @dhanasp -- There is a null check inside updateEntityWithTwoSessions() method and we have a test as there is only one usage of it here. Why should we remove the null check here?
@vrushaliwaykole @dhanasp -- There is a null check inside updateEntityWithTwoSessions() method and we have a test as there is only one usage of it here. Why should we remove the test?
@vrushaliwaykole @dhanasp -- There is a null check inside updateEntityWithTwoSessions() method and we have a test as there is only one usage of it here. Why should we remove the null check?
does this need to be public?
does this need to be ordered?
same here, perhaps globalId should be enough
Why not add @NonNull for all these arrays?
Why not add @since Exception instead?
Why not add @NonNull for all these arrays too?
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super.getForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we ever change the super method content and will allow to make forceCloseTimeMillis private
assertEquals(appliances, appliances);
assertEquals(appliances, appliances)
And this one
I'm not sure we need this. I'm not sure we need this. I would prefer to rely on the MethodInvocationTree constructor, so you can skip the if.
I'm not sure we need this. I'm not sure we need this. I would prefer to rely on the MethodInvocationTree constructor, (which would allow you to filter out non-empty flows): if (!visitedOtherConstructor &&!visitedOtherConstructor.isPresent()) { throw new IllegalStateException(c -> { }
I'm not sure we need this. I'm not sure we need this. I would prefer to rely on the MethodInvocationTree constructor, (which would allow you to filter out non-empty flows): if (!visitedOtherConstructor &&!visitedOtherConstructor.isPresent()) { throw new IllegalStateException(c -> "Unknown"); }
suggestion territory.add(new Point(1, 2, 3), gocounting, territory);
suggestion territory.add(new Point(0, territory.getTerritory());
suggestion territory.add(new Point(1, 2, 3), gocounting, territory));
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
Please use a Typo in variable name.
This is not needed
This has to be a command line: DiffCommand diff = diff. getResource(new GerritException("DiffInfo for Gerrit");
This has to be a command line: DiffCommand diff = diff. getResource(new GerritException("DiffCommand diff")); You also need to use a logger.
why not performActionForServicesOfServer.isNullOrEmpty(clusterId)
why not performActionForServicesOfServer.
no need for else
It might be better to rename the variable to currentConfigForEdit; here would be clearer.
It might be better to rename the variable to currentConfigForEditing.
It might be better to rename the method to viewsForEditing.
Consider using the qnNumberDownloadIndex method to take a String argument as an argument.
Consider using the qnNumberDownloadIndex method to compare a string with an appropriate name for the path.
Consider using the qnNumberDownloadIndex method to take a String argument as an argument to a @Nullable annotation
Why not call this(value, false)?
Why not call the other constructor?
This should be public
Should be logged in user
Should be a more meaningful check
Should be meaningful
Please use StringBuilder instead.
Please use StringBuilder instead of StringBuffer.
Please use the StringBuilder instead.
The problem should be somewhere else :-)
The problem should be somewhere else :-) if (title == null &&!title.isEmpty()) { return; }
The condition should be!title.isEmpty()
this appears to be duplicated -- can you extract this into a separate method?
this appears to be duplicated, might want to extract this into a separate method?
this appears to be duplicated, might be worth extracting them into a separate method?
rename to deleteFilePath()
Remove else clause.
rename to deleteFilePath or deleteFilePath
I think the buildFinalizerManager can run in a different way. Check the inspiration on how to do it.
I think the start and the cache can be read for one local variable.
I think the start and the cache can be loaded when needed.
Use computeIfAbsent
Use precondition check
Use precondition check :)
Why not use RSExF in Version? It is more robust.
Please make the shell final.
Please fix the checkstyle
Use Guava Streams.stream(entityType -> EntityType.getSheet(entityType)) instead of StreamSupport.stream(entityType.spliterator(), false)
Use Guava Streams.stream(entityType -> EntityType.getSheet(entityType)) instead of StreamSupport.stream(entityType -> EntityType.get(entityType.spliterator(), false))
Use Guava Streams.stream(entityType -> EntityType.getSheet(entityType)) instead of StreamSupport.stream(entityType.spliterator(), false).toStream(entityType -> {
Can you explain this change?
Can you add a log here please?
Can you put this in the constructor?
You need to make sure to initialize the activity in the view is visible.
You need to make sure to initialize the activity in the menu.
You need to make sure to initialize the activity in the view.
Can you use File.separator instead of "/"?
Please use File.separator instead of "/"
Can you use File.separator to avoid typos?
You can remove this else block instead and set the default function return to false.
You can remove this else block instead and set the default function returns.
You can remove this else block instead and set the parameter since this method returns a default function.
typo "my://"
is it possible to use getPath() here?
typo "my://" and "my://"
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully handle exceptions where the application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully handle exceptions where the application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-close fails.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully handle exceptions that must be configured in the UI. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
please decrease severity to "info"
please decrease severity to "debug"
please decrease log level to trace or better remove statement
This should be INFO since it's not a "m_getCurrent truncation handle"
This should be INFO since it's no longer available.
This should be INFO
I think it's better to use a [Thread.currentThread().interrupt();](<LINK_0>, and rethrow the exception.
I think it's better to use a [ThreadPoolExecutor](<LINK_0> as well.
I think it's better to use a warn log here.
From <LINK_0> I'm not sure this can be part of the public API, it's a breaking change.
From <LINK_0> I'm not sure this can be part of the Type member.
This can be simplified using anyMatch()
[Checkstyle] INFO: '200' is a magic number.
[Checkstyle] INFO: '200' is a magic number. Please use that instead.
Line longer than 120 characters.
If we have a Umbry data directory, we wouldn't have to update the index if it's false.
If we have a Umbry data directory, we wouldn't have to update the index, at least change the method name to upsertMode
If we have a Umbry data directory, we wouldn't have to enable it.
sourceFormats is an empty string, so the null check on sourceFormats is not needed.
sourceFormats is an empty string, so the null check for blank and empty string is not needed.
sourceFormats is an empty string, so you don't need to check for blank and empty
List<WebElement> equals = notifications.stream().filter(notifications ->!notifications.isEmpty()).collect(Collectors.toList());
List<WebElement> els = Lists.stream().filter(notifications ->!notifications.isEmpty()).collect(Collectors.toList());
List<WebElement> equals = notifications.stream().filter(notifications -> card.getAttribute("class")).collect(Collectors.toList());
java.get(() -> batchContext.loadPluginClass(JDBC_PLUGIN_ID))
java DBRunContext.getTranslationContext(JDBC_PLUGIN_ID, driverClass);
java.get(() -> batchContext.loadPluginClass(JDBC_PLUGIN_ID));
probably better to have a log message here.
probably better to have a log message here?
probably better to have a log line before the if.
please add a log here, in case it ever fails
please add a null check in the super class to avoid NPE
not sure why we need to add these checks?
not sure why do you use standard indexed methods like this?
not sure why do you use java sleepUntilLoginDisplays?
not sure why do you use java sleepUntilLoginDisplays?
change this to analysisReady
externalize
change
Firing event in finally block? What if it does not happen?
Firing event in finally block? What if it does not mean?
activatorPath is never null
This method is only ever called in this test.
This method is only ever called from the test method.
This method is only ever used in this test.
Why do you need to catch RestServiceException here?
Why do you need to catch exceptions here?
Why do we need to catch exceptions here?
this is already called in the test above. I think it would be good to make sure that the dirAllocator is closed before the test is made and just used in the DiskErrorException.
this could be extracted and reused.
this could be extracted to a method, just once.
why do you need to define the default keyword here?
why do you need to define a default here?
why do you need to define the default keyword here?
Hmm, actually if you're going to allow to getVdsGroup() should return it, maybe you meant to keep it and do getVdsGroup() in the superclass?
Hmm, actually if you're going to allow to getVdsGroup() should return it, maybe you meant to keep it and do getVdsGroup() in the enum?
Hmm, actually if you're going to allow to getVdsGroup() should return it, maybe you meant to keep toString()?
Do we need this method? Can't we make it void?
Do we need this method? Can't we make it public?
Do we need this method? Can't we do this only if GrillServices is enabled?
What is this checking?
What is this local?
Do we care that this is invalid?
do you want to do this?
PickupPickup is OFF
PickupStatus
Actually, there's no reason to have this.skip = skip. It should be like in the previous implementation: this.skip = skip.
Actually, there's no reason to have this.skip = skip. It becomes the same as in the previous implementation.
Actually, there's no reason to have this.skip and skip.
Can we use the context.getApplicationId() here?
Can we use the constant from DiscussionsOperationsAction.java instead?
Can we use the constant from DiscussionsOperations#getDefaultCategory() here?
Use StringBuilder
Use ErrorNode.getParent()
Use ErrorNode.getName()
Is this a standard way of getAlias() -> getName() == getAlias()? I don't think it does.
Is this a standard way of getAlias() -> getName() == getAlias()?
Is this really needed? A getAlias() already does the owner of getName()
Revert this change please.
Revert this change please
Revert this change please - Minecart.getBoundingBox() is marked as @NonNull, so this is marked as @NonNull.
Is it confusing to have brokerRelatedInfoLogging += "The active broker is not supported for " + "contain PackageName is not supported"); and "The active broker is not supported"
Is it confusing to have brokerRelatedInfoLogging += "The active broker is not supported for " + "contain PackageName is not valid");
Is it confusing to have brokerRelatedInfoLogging += "The active broker is not supported for " + "contain apache." + " not support PR."
why this has to be public?
why this "openid"?
why Arrays.asList("openid", "email")?
If prefix is null, you can use Preconditions.checkNotNull
You can use StringBuilder
You can use Preconditions.checkNotNull for all arguments.
I don't quite understand the code, this will create a URI that contains columnFamily so perhaps it's not necessary to extract the code here? private String getFileName(final Path getFileName) { return toString().replace("\\.", "/"); } private String getFileName(final Path toString()) { return getFileName(toString().replace("\\.", "/"); }
I don't quite understand the code, this will create a URI that contains columnFamily so perhaps it's not necessary to extract the code here? private String getFileName(final Path getFileName) { return toString().replace("\\.", "/"); } private String getFileName(final Path getFileName) { return String.replace("\\s+", "/"); }
I don't quite understand the code, this will create a URI that contains columnFamily so perhaps it's not necessary to extract the code here?
Would it be better to use Double.valueOf() here?
Would it be better to use Double.valueOf(previousValue) here?
@gianm > Any reason for this line? I would test it as well.
nit: you can use assertEquals?
nit: this should use splitsManager.
this should use splits.
Can you add a note to the handler that is being called after this method was called?
Can you add a note to the method that is being called after this?
Can you add a note to the handler that is being called after this method?
Hmmm, I think this would be a bit cleaner as it was. WDYT?
Hmmm, I think this would be a bit cleaner as it was. WDYT about changing the logic to be more clear?
Hmmm, I think this would be a bit cleaner as a 'final' variable? Avoid duplication with the variable names.
i18nfcNfcNeverMessage() should be moved to a parametrized method.
i18n?
i18n
Frontend.setFilterQueries does nothing for this purpose, I don't see any reason to keep it here. It's not only used in the command Frontend. Let's drop drop it from here.
Frontend.setFilterQueries does nothing for this purpose, I don't see any reason to keep it here. It's not only used in the command Frontend. Let's drop it.
Frontend.setFilterQueries does nothing for this purpose, I don't see any reason to keep it here. It's not only used in the command Frontend.
Maybe you can use Completable.fromAction( ) here?
Maybe you can use Completable.fromAction(latch::countDown) instead.
Maybe you can use Completable.fromAction(latch::countDown) instead?
Why not using the join() method?
why not using the join() method?
why not using the duplicate set of the option?
you can ignore public
you can use public
you can use public here
I would call this(intervalBiFunction, this.intervalBiFunction)
I would move this assignment to the previous line
I would call this(intervalBiFunction)
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
You've added a bunch of methods in between the two overloaded versions of initializeAppResources(). Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to understand.
Could we use articleContentString.sanitizedContent() here instead of \n so that it's only called once, if articleContentString is not null.
Could we use articleContentString.sanitizedContent() here instead of \n so that it's only called once, if articleContentString is not null?
Could we use articleContentString.sanitizedContent() here?
This should be orElseThrow(() -> new RuntimeException("The parameter named 'type' is missing"));
I would prefer to orElseThrow with an appropriate message instead of returning null.
I would prefer orElseThrow with an appropriate message instead of returning null.
This is unnecessary
This is where it should be public
This is where it should be.
I'd prefer to name these methods a bit more specific like: boolean hasAnnotation(String annotation) { if (descType == null) { return false; } else if (descType.equals(annotationType)) { return false; }
I'd prefer to name these methods more specific like: boolean hasAnnotation(String annotation) { if (descType == null) { return false; } else if (descType.equals(annotationType)) { return false; } }
@marchof syntheticInvisibleAnnotations should be false by default.
can we use a constant for "CUSTOM"
can we use a constant for "(" at the top of the file?
can we use a constant for "(" at the end of the file?
I think we can help ourselves when debugging if we include some information about the displayName?
I think we can help ourselves when debugging if we include an error message in the build sentence.
I think we can help ourselves when debugging if we include an error message in the build sentence?
requireNonNull is redundant here
requireNonNull is redundant here.
requireNonNull
File.separator + ". This does not work in Windows. You can use new File(prefs).
File.separator + "/" + File.separator + ". This will give you a Windows Windows when using \r\n".
File.separator + "/" + File.separator + ". This will give you a Windows Windows when using \r\n.
I think you can replace "package1" with "package2"
I think you can replace "package1" with "package2".
I think you can replace "package1" with "package2". Should be removed
This does not seem to be tested.
This does not seem to be the right thing to do. If you have multiple mods add their own mods, then they would get an error instead of a single tick.
This does not seem to be the right thing to do. If you have multiple mods add their own mods, they might get a single tick.
use final
use ints instead of 0
use random names instead of empty
Unless I'm missing something, this assertion will pass. This is the only one that you have.
Why not print the entire stack trace? In the test cases the entire failure won't print.
Unless I'm missing something, this test doesn't seem to run on production, but I wonder if we can make the tests more reliable.
I think you can get rid of the spaces
I think you can get rid of the one you're testing. Let's create a new test to validate.
I think you can get rid of the the way the test is supposed to test.
I would have expected is a call to isIncrementOrDecrement() within this synchronized block depending on the check.
I would have expected is a call to isIncrementOrDecrement() within this synchronized block depending on the check. It might be safer to have the check before calling scan.
I would have created a variable for the expression.
I would rename this to "0.10"
I would make this "0.10" configurable as this allows getting quite frequently for each source.
I would make this "0.10" configurable as this allows broken ones to create multiple ITs
The idea of the "template" parameter is that you can pass an object that will be created even if the feature is not found. That is the only way to create a new instance, so if you create a set of featureFeature, it will be reused multiple times.
The idea of the "template" parameter is that you can pass an object that will be created even if the feature is not found. That is the only way to create a new instance, so if you create a set of featureFeature, it will be initialized in the future.
What about making the templateFeature method private?
The field should be renamed to setDead()
The field should be protected, not package protected.
The field type can be changed to use a private final field.
Any reason why this is different than the above?
Any reason why this is static?
Any reason why this is different than the above variable?
Why not use System.arraycopy(pn, 0, qn, 0, qn.length);?
Why not use System.arraycopy(pn, 0, qn, 0, qn, 0, qn.length);?
Why not use System.arraycopy(pn, 0, qn, 0, qn, 0, qn.length);?
or List<T> filteredItems = new ArrayList<>(pred);
or List<T> filteredItems = new ArrayList<>(pred); And then use equals instead of ==.
or List<T> filteredItems = new ArrayList<>();
I think search operator expects a String as input validation error. If you want to check this, you can create a new array of Strings that will contain the parameters.
I think it's better to throw exception here (and for other similar cases below)
I think it's better to throw exception here (and for other similar cases)
Why not just Stream.of(b)?
Please don't use Stream.of() in tests.
Please don't use Stream.of() here are unnecessary.
Typo:'quoteString'
Typo:  quoteString must be added
Typo:'quoteString' is a '
Is it possible to use null strategy here?
Is it possible to use same serializationStrategy instead of creating new one?
Is it possible to use null?
I think we should make this a follow-up change instead of failing until we encounter the warning. I know it's not part of your commit, but for the message, we can deal with it anyway.
I think we should make this a follow-up change instead of failing until we encounter it. I know it's not part of your commit, but for the moment, we must try to remove the first one anyway.
I think we should make this a follow-up change instead of failing until we encounter it.
this is confusing if you didn't set the result at all maybe?
I didn't know this is going to work in the case when a config is with null it is absent with some values.
I didn't know this is going to work in the case when a config file has been set.
This may be a bit cleaner: if (messageEntity.createInstanceAction()) { MessageActionDTO user = userEntity.createInstance(); MessageActionDTO user = userEntity.createInstance(userEntity); if (messageEntity == null) { messageEntity.updateBuddyInfo(userEntity, messageEntity); } } else { messageEntity.updateBuddyInfo(messageEntity, messageEntity); }
This may be null at this point. Could you move the check for null on BuddyInfoDTO and do the check for null?
This may be null at this point. Could you move the check for null on createInstance()?
should return null for query and return it
And for query, parameters, and queryWithParams are not null
should be params, not null
I think it's not that way, it's required, if there's a reason not to use it?
I think it's not that way, it's required, if there's a reason not to use putIfAbsent()
I think it's better to use putIfAbsent() here
API breakage errors. You should declare another method and mark for deprecation this one.
API breakage errors. You should declare another method and mark for deprecation this one. And actually you can declare another method and mark for deprecation this one.
API breakage errors. You should declare another method for deprecation this one.
Minor: it could be replaced with a function reference instead of creating a new list.
Minor: you can use the static import for Collectors.toList() instead.
Minor: use the static import for Collectors.joining
Maybe it makes sense to add this before we start initializing
Maybe it makes sense to add this before we start initializing with frozen results?
Maybe it doesn't worth to add some assertions on between them?
Why not just'returned'?
Why not just'return false'?
Why not just do: if (started) { continue; }
suggestion LOG.log(Level.INFO, failedContext);
suggestion LOG.log(Level.INFO, "Failed to onNext context");
"Failed to close Context"
Verify that the body contains the expected body?
Verify that the body contains the data?
Verify that the body contains the expected body.
you're not removing alias here, remove that line.
instead of undoing you've done method which has to be removed in setUp.
instead of undoing you've done method which has to return true
Have we considered using the non-default default value in the options field instead of this.context = isSandbox?
Have we used this(true) but now we have to create a new instance of this? Does it make sense to have a statically initialization of the options?
Have we considered using the non-default default value in the options field instead of initializing them here?
Shouldn't this just call onSelectedItemChanged()?
Shouldn't this just be inlined?
Shouldn't this just be onSelectedItemChanged()?
getId() creates a SegmentRef: you can use Objects.requireNonNull(this.id, "Can't create reference for "+location+": "+e);
getId() creates a SegmentRef: you can use Objects.requireNonNull(this.id, "Can't create reference for "+name+" as ID")
oh, I see, you are just using a standard ObjectUtils.nonNull
I would prefer to have this method return void, economy() { final Economy = (public)con; } public Economy() { final Economy = new Economy(); final Economyconomy = (public) System.out.println(econ.myStream); }
I would prefer to have this method return void, economy() { final Economy = (public)con; } public Economy() { return econ; }
In Gherkin v4 the  identification of this param is not needed.
Can it be reduced to LOG.info("Repl policy is not set for database {}.", m.getParameters(), replPolicyId);?
Can it be reduced to LOG.info("Repl policy is not set for database {}: {}", db.getParameters(), replPolicyId);
Can it be reduced to LOG.info("Repl policy is not set for database {}: {}", db.getParameters(), replPolicyId);?
if the log level > info should be added as part of GetBlobInfoError
if the log level is not enabled, we can't stop doing anything on the Router here
if the log level is not enabled, we can't predict all the opportunity to find the size useful?
remove "this"
remove "this."
remove "else", here
I think we should use getTransactionManager() here instead of the commit().
I think we should use getTransactionManager() instead of the commit().
I think we should use getTransactionManager() here instead of the commit.
Can we add a method to the base class that is called by the caller? The getQueue() do the job.
Can we add a method to the base class that is called by this simplification?
Can we add a call to other method that does this?
please add @Override annotation here as well.
please add @Nullable please
please add @Nullable please.
So it's not possible to run vmDevice?
So it's not needed anymore?
So it's not needed to run the VM?
wdyt if we could have the same indentation in the beginning of the method w/o prefix?
wdyt if we could have the same indentation in the beginning of this method if you could do it once in the constructor and store it as a variable if you instantiate the first argument.
wdyt if we could have the same indentation in the 2 places with a parentheses.
I'm not sure, I like the convention that the status should be restored. I suggest the following code: public void testValidate() { try { F.log(null, status); } catch (InterruptedException e) { F.logTrace(e); } } It's a good practice to use it in tests.
I'm not sure, I like the convention that the status should be restored. I suggest the following code: public void testValidate() { try { F.log(null, status); } catch (InterruptedException e) { F.logTrace(e.getMessage(), "Duplicatedtrace"); } } It's not easy to understand where the problem is the job.
I'm not sure, I like the convention that the status should be restored. I suggest the following code: public void testValidate() { try { F.log(null, status); } catch (InterruptedException e) { F.logTrace(e.getMessage(), "Duplicatedtrace"); } } It's not easy to understand where the problem is the job here
same question
return Arrays.sort(index);
same question and intent here.
should it be final?
should it be a synchronized method?
should it be all the else?
I can't understand why you are doing this
I can't understand why you are doing this one here
I can't understand why you are doing this this
this appears to be unused
this appears to be unused.
this seems unused
Why use Integer and not int?
Why use Integer and not Integer?
Why use Integer.BYTES?
Do we need this case?
Do we need this?
[optional] think we could break this out into multiple cases
The method actually determines if the given processor starts with ephemeralPath. The reason is that in this case, the method name is "node".
The method actually determines if the given processor starts with ephemeralPath. The reason is that if the secure processor is using the given processorName and the secure processor is not the root cause the node to be executed. The action we take on duplicate is stopping the processors. Can you please update the doc?
The method actually determines if the given processor starts with ephemeralPath. The reason is that if the secure processor is using the given processorName and the secure processor is not the root cause the node to be executed. The action we take on duplicate is stopping the processors. Can you explain how this is related to the issue?
Should be null, not getGroupedJobInitializer()
Should be getGroupedJobInitializer()
Should be 1 for consistency with the other way around.
this is hard to read. I would keep it on separate line
this is no longer needed
this is no longer needed, you could remove it
can you have a message with "InjectableBehaviourObject is null"?
can you have a message with "InjectableBehaviourObjectStore" here instead?
Do we need to have a string format for this?
Is there a way to get rid of sleep() and sleep() here?
Is there a way to get rid of sleep() here?
Is there a way to get rid of sleep?
same opinion here :) (though break logic
same remark
same code
can it be a constant?
should return a Map
lets return a Map
revert this string
Excellent!
Don't use hardcoded string, use constant
[MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
Indentation is off here, can be else if statement?
Indentation is off here, can be else if
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
Is that intentional to remove check for dhg.getDomainName() is null.
Is that intentional to remove check with dhg.getDomainName() is null. We would have null string appended to dhost name.
I don't think you need this if block
I don't think you need this if
I don't like this kind of locking. This is needed every time you filter out the findAny().
I think the 'this' is not needed anymore.
I think the 'this' is not needed.
I think the request could be null here even though it's not.
you may use Smart.tag instead of json() here
you may use Smart.class instead of json() here
you may use Smart.tag instead of json().
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> The Cyclomatic Complexity of this method "isOutput" is 13 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> Provide multiple methods instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
No spaces
No spaces around arguments
Use the argument constructor
Does this not have to be conditional?
Does this not have any effect?
Declare this variable final
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem. Thanks!
For Right to Left tests, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Why the empty parent? With empty nodes, the parent node won't be empty.
Why the empty parent? With empty nodes, the parent node won't be empty, so you don't have to perform any checks.
Why the empty parent? With empty nodes, the parent node won't have any effect.
style-nit: no braces here
why not put this line at the top?
space?
I don't fully understand the purpose of this assert. It's odd to have a test that would be expected and actual.
I don't fully understand the purpose of this assert. It's odd to have a test that would be expected and not just assertOpen span.
I don't think we should assert anything here... It's inconsistent with the logic below.
I think it would be safe to use the ArticleIdentity object here as well.
I think it would be safe to use the ArticleIdentity object here instead of the reference.
Can we combine these two methods together into one?
are you sure this makes sense? Does the view need to be public?
are these checks needed?
are you sure this is safer?
have you considered introducing a new variable here?
have you considered introducing a new function ID(s) you can use?
have you considered introducing a new function ID(s) you can use as the
Java return products.getUnconfirmedAllowed(null);
Java Boolean getUnconfirmedAllowed does the same thing, but the method name is not...
Java Boolean getUnconfirmedAllowed(String product)!= null
Should we do all the same request for all the local variables?
Should we do an Assert.assertTrue on the return value of test.
Should we do all the same about final variables?
@guiseco here as well, this method should be synchronized
@guiseco here as well, this method is no longer invoked.
can we have a null check?
Can be simplified to return AccountLinkingStatus.ENABLED.equals(status);
Can be optimized to return AccountLinkingStatus.ENABLED.equals(status) && getStatus() == Status.ENABLED.equals(status);
Can be simplified to return AccountLinkingStatus.ENABLED.equals(status) && Objects.equals(status, getStatus());
Why not do this: public void run() { super.run(); } protected void run() { super.run(); }
Why not do this: public void run() { super.run(); } public void run() { super.run(); }
Why not do this(x, yeah? ;)
getChildren() should return null if it is not.
getChildren() should return null if it is not a valid item.
getChildren() should return null if it is not of type internal.
Definitely restricted, especially if we consider moving JDK installer into plugin.
Definitely restricted, especially if we consider moving version into plugin
Definitely restricted, especially if we consider moving version into plugin.
Can we make it a constant?
Can we make it final?
Does it mean that checkpointRootPath is not the same as checkpointRootPath? Should we make it consistent?
same here, I wonder if we should add a special case for this and the t?
same here, I wonder if we should add a special case for this and the param input
same here, and in other classes
Doesn't seem like there's a leak here. If you are going to clean up the lock, perhaps it's a no-op?
Doesn't seem like there's a leak here. If you are going to hold a listener, perhaps it's a no-op.
Doesn't seem like there's a leak here. If you are going to hold a listener, perhaps it's a no-op?
As I wrote in patch set 8- you should have the same validation for moving the network to a new commit.
As I wrote in patch set 8- you should have the same validation for moving the network to a new network or so. Either way, use NetworkUtils.isLabeled(getNetwork()) && NetworkUtils.isLabeled(getNetwork().getLabel().getLabel().toString()) or even NetworkUtils.isLabeled(getNetwork().getLabel().getLabel()...
As I wrote in patch set 8- you should have the same validation for moving the network to a new network or so. Either way, use NetworkUtils.isLabeled(getNetwork()) && NetworkUtils.isLabeled(getNetwork().getLabel().getLabel()...
use the same hashCode instead of comparing every time
use the same hashCode instead of comparing each time
use the random stream instead
Take the limit (50) as a parameter, this will be useful for later
Take care of the style here - we should be consistent with the rest of the code
Take care of the style here - we should be consistent with the rest of the codebase.
These two lines probably can be combined into one.
These two lines probably can be combined easily.
These two lines probably can be combined to one.
I'd rename this variable to memberValue.
I'd rename this method to something like memberValue.
I'd rename this method to memberValue.
Can we use selectHyperLinkLabel.setEnabled(false); here?
Can we use selectHyperLinkLabel.setEnabled(true); here?
Can we use selectHyperLinkLabel.setEnabled(false); here and above?
I think it would be nicer to go with the RmfTraceStub to be a static constant and use it in the tests rather than the "Blaine" one.
I think it would be nicer to go with the RmfTraceStub to be a static constant and use it in the tests rather than the "Blaine" literal.
I think it would be nicer to go with the RmfTraceStub to be a static constant and use it in the tests rather than the "Blaine" constant.
Check if credential and registry are null before creating the Builder.
Check if credential and registry are null before creating the Registry.
Check if credential can be null.
Couldn't you use this.key.equals(Object) here instead? If so, you can remove the line above and swap the if/else.
Couldn't this be public? Please find all usages of this method.
Couldn't you use this.key.equals(Object) here instead? If so, you can remove the line above and get rid of the if/else below.
@Restricted(NoExternalUse.class)
@vilchik-elena Why not throw an exception instead of using RuntimeException?
@vilchik-elena Why not throw an exception instead of returning a value?
I would put the extension.set(Class<NoAnnotationBean>()); in the if-else block.
I would put the extension.set(Class<NoAnnotationBean>()); in the else block.
I wouldn't use the AnnotatedTypeWrapper defined here, instead of the extension.
OneOrigin that have a OneOrigin that may be null.
OneOrigin.Raptor(null) could be null?
OneOrigin?
This can be simplified to return the key to the cache.
I do not understand the need for this boolean.
This can be simplified to return key!= null? key : null
you can remove throws Exception
you can remove the throws Exception
why not using a CloseWebSocketFrame of the class?
not null?
not null
redundant
Can you throw an exception instead?
Can you use key instead of value and do something else in this method?
Can you use { and } in this method?
can you please also add method WaitUntil(new JobIsRunning()), that would return new WaitUntil(new JobIsRunning())
can you please also add method WaitUntil(new JobIsRunning(false)) and then try when waiting for shell completion.
can you please also add method WaitUntil(new JobIsRunning(this))
A lot of this logic seems to be reused for each handler. Is there a need to generify it to save some code duplication?
Is there a need for this change?
A few empty line
I don't think we want to do this in the synchronized block.
I don't think we want to do this in the lock.lock() case...
Do we need the lock here?
Can we move the activity into the constructor?
Can we move the activity into onCreate and use it in onDestroy?
Can we move the activity into onCreate() and use that in onDestroy().
We can put this inside the if block
We can put this before the if statement in process
We cannot know how to do this?
this may return null if the item is not a valid event.get() returns null
this may return null if the item is not a valid item. Shouldn't we return Direction.ROOT?
this may return null if the item is not a valid item. Shouldn't we return null?
The getValue method is only called from the Symbol and it seems to be used in many places. Are you sure it's worth it?
The getValue method is only called from the Symbol and it is a sub symbol. So the getValue could be called for every field.
The getValue method is only called from the SymbolicLoader. Are you sure it will be worth it?
How about using a configurable timeout here?
How about using a configurable timeout instead?
How about using a daemon thread?
@pynicolas why not use a list to avoid creating a new list?
@mTopic may be > 0. Did you mean to use util.fine instead?
@mTopic may be > 0. Did you mean to use util.Set?
same here, could be package private
doc
same here, could be checked before return
Could be inlined
Unneeded code re-use
Unneeded code re-use, remove
Any latitude will be greater than MIN_LATITUDE's?
Any latitude will be greater than 255 in this check?
Any latitude will be greater than MIN_LATITUDE'?
What's the purpose of this?
What's the purpose of this change?
What happens if it doesn't rename?
should it be a constant?
should the interface not use public?
should the interface not use public?
The case where isUnitTest is expected to be the empty string. That's what I suspect.
In addition to methods, we could also cover functions and variables. That way we don't need to override isUnitTest() method.
The case where isUnitTest is expected to be the empty string?
Thinking about it, is it possible to define new ArrayList<>() inside the for loop, or create entries?
Thinking about it, is there an alternative way to do this? So the list of added things will be slower, but the list of slower than the hoc maps at the same time?
Thinking about it, is there an alternative way to do this?
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE); // NON_CANCELLING, EMPTY_VALUE);
suggestion EMPTY_VALUE); // NON_CANCELLING = EMPTY_VALUE;
should it be an empty string?
should it be an error condition or log something?
should it be an error condition?
Shouldn't it be resolved? It's better to use the TradeDate tradedPrice tradedPrice tradedPrice()
Shouldn't it be resolved? It's better to use the TradeDate tradedPrice tradedPrice()
Shouldn't it be resolved? It's better to use the TradeDate#resolve(null) method instead of building the ref data
Can candidateService.getCandidate() be null?
Can candidateService.getCandidate() be null? Same for the other methods..
Can candidateService.getCandidate() be null? Same for the other methods.
I think we should be consistent and let the exception bubble up the call to session.isOpened()
I think we should be consistent and let the exception bubble up the stack if it's not null.
I think we should be consistent and let the exception bubble up the stack if it's not done.
You can push this directly to the frame so you don't have to pop it manually.
Is there a reason why you are using SpongeEventFactory.stackFrame override this?
You can push this directly to the frame so you don't have to pop it twice.
Let's keep the same code style here for readability
Let's keep the same code as the original.
Let's keep the same line
Remove the {}
Remove
remove
why is this noncompliant?
please use EqualsBuilder as mentioned above
please use the primitive boolean instead.
Would it be useful to have a checkNotNull on the list?
Would it make sense to just use a reference to the main Activity?
Would it be better to just use a reference to the main Activity?
Why synchronized?
This synchronized block should be removed.
This synchronized block is not needed.
use [try-with-resource](<LINK_0> to ensure that they are closed in same try block
use [try-with-resource](<LINK_0> for better readability
use [try-with-resource](<LINK_0> to ensure that they are closed in same try block.
when would it be problematic to have a query that returns a query? In addition, I suggest to export the query as a query (it does not exists until we subscribe to the "default" entity.
when would the query be non-static?
when would the query be non-empty?
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
calling this method will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVdsCommand
This is not a valid index for these, since we have to be careful of using a regex compare. Does this make sense? private static boolean isCaseSensitive() { return true; } public boolean isCaseSensitive() { return false; } }
This is not a valid index for these, since we have to be careful of using a regex compare. Does this make sense? private static boolean isCaseSensitive() { return SCHEMA; } public static boolean isCaseSensitive() { return SCHEMA; } public static boolean isCaseSensitive() { return NULL_VALUE; } }
This is not a valid index for these, since we have to be careful of using a regex compare. Does this make sense? private static boolean isCaseSensitive() { return SCHEMA; } public static boolean isCaseSensitive() { return SCHEMA; } public static boolean isCaseSensitive() { return SCHEMA; } public static boolean isCaseSensitive() { return VERSION; } }
I don't think you need to check for partitionedSplits here, since it's a table.
I don't think you need to check that partitionedSplits is not null here, since the table can be closed.
Could you please remove the synchronized here?
Is this the same as in the other place?
Is this the same as in the previous commit?
Is this not needed?
I'm not sure why you need to have this config.getAutoTeleportEnabled() here.
I'm not sure why you need to have isAutoTeleportEnabled() here.
I'm not sure why you need to do this.
Should probably use a different exception text, like "Unable to send a notification to slack error" instead of a stack trace.
Should probably use a different exception text, like "Unable to send a notification to slack error"
Should not use thread id, as it is currently done by other threads.
suggestion if (interceptorManager.isPlaybackMode()) {
suggestion if (interceptorManager.isPlaybackMode()) { We don't need this if/else.
suggestion if (interceptorManager.isPlaybackMode()) { We use the constant setting in the getKeyManager().
Why not make this change? This doesn't seem to be unrelated to cube size.
Why not make this change? This doesn't fix anything
Why not make this change?
This variable is useless. Please just use return in your try block.
This variable is useless. Please just remove it.
This variable should be declared final.
Could be simplified to if (!customPageMap.computeIfAbsent( cpType, Boolean.class))
Null check?
Looks like this could be private.
nit: check if the variable is actually non-null before performCheck()
nit: performCheck() should be before doCheck()
nit: check if the variable is actually non-null before perform check
Is there a reason not toString()?
Is there a reason to toString() it will be treated as NotNull?
Is there a reason to toString() it will be treated as Nullable?
Alternatively, this could be rewritten with a single constructor and avoid the copy here.
Multiple indentation issues here.
Multiple indentation issues here?
The field name is misleading. I think it should be the other way around the responseData.
The field name is misleading; it is a bad idea to have a proper data structure as well.
The naming makes sense.
Let's not use the earlier mkdir() here. Instead, we should just check if the directory exists and if it returns false.
Let's not use the earlier mkdir() here. Instead, we should just check if the directory exists and if it is empty.
Let's not use the earlier mkdirKey here. Instead, we should just check if the directory exists and if it returns false.
You don't need to check theTCCL, just pass it through.
You don't need to check theTCCL, just pass it as parameter.
You don't need to check theTCCL, just pass it to the method.
return value.get(key);
return value.get(key); or return null
return value.get(key); or throw exception
This should have a static logger method with a code
This was a static logger method, should this be synchronised to avoid blocking?
This was a static logger method, should this be synchronised?
Where does this come from? I don't see it's used anywhere.
Where does this come from? I don't see it being used anywhere.
Why are there two log messages being logged?
s/type/col/
s/type/col
s/type/name/
need to do this for the input schema and the message too.
need to do this for the validate and print the message too.
need to do this for the validate
We are using a for loop here?
We can merge these 2 if conditions into 1
we can use this method to get the parent
should be wrapped in a try-with-resources block.
should be wrapped in a try catch block to have a return type.
should have a return type here.
Doenix, Doenix, since this is only for DMLTable. Check if Doenix, there are more binary files.
What about Doenix, since this has a mechanism in it.
What about Doenix, since this has a mechanism in it?
s/ NativeInterface.MessageType.DELIVER_PENDING_ID
s/ NativeInterface.MessageType.DELIVER_PENDING + getValue()
s/ NativeInterface.MessageType.DELIVER_PENDING + getValue();
Can you make this method synchronized?
I think there should be a test for Pausable methods that are not the same
Can you make this method private?
I believe we try to run it the way discussed in #124 (but don't support it officially)?
I believe we try to run it the way to suppress the warning. Otherwise you have to update the message to FatJar as a different kind of error.
I believe we try to run it the way to suppress the warning. Otherwise you have to update the message to FatJar as a different constant.
Missing @Override
Style-nit: This 'if' can be replaced with the new code of hashCode().
Style-nit: This 'if' can be replaced by a reference to the its value.
We should probably check if the message is correct here as well.
We should probably check if the message is correct here, just like "body text.
We should probably check if no properties found.
Just catch Exception.
Let's catch the IllegalArgumentException that is thrown by the method so that we can just do throws Exception.
Just catch NullPointerException.
InternationalizedString is YYYY-MM-DD here instead.
Internationalized string can be used instead.
InternationalizedString is YYYY-MM-DD
I don't think this check is relevant
I don't think this file needs to be prepended with a different value. The reason is that the startAppiumServer() method wouldn't describe what happened, but don't we expect it to be.
I don't think this file needs to be prepended with a different value. The reason is that the startAppiumServer() method wouldn't describe what happened.
I think it would be more readable to use Set<String> filtered = new HashSet<>(Arrays.asList(folder))
I think it would be more readable to use Set instead of LinkedHashSet.
We should probably use Set instead of LinkedHashSet.
It's better to use a newSQLServerQuery method.
It's better to use a newSQLServerQueryRewriterContext.INSTANCE.
It's better to change this to java8SQLServerQuery.onContext.
This shouldn't be here...
This shouldn't be here... It should be Port
This shouldn't be required anymore.
nit: No need to add InputFormatSourceFunction<RowData>, StreamExecutionEnvironment>.
nit: No need to add InputFormatSourceFunction here?
nit: plural InputFormatSourceFunction?
final?
api is bit confusing on this and all other occurrences. I'd prefer to keep the field as final.
api is bit confusing on this and all other occurrences. I'd prefer to keep it as final.
Either use a Preconditions.checkState to take a message.
s/lookup is already a source/symbol?
s/lookup is already a constant
Should we be setting this to null on the factory? (and other tests)
Should we chain the zeros?
Should we chain this into a single try statement? (Or just use lambda?
This seems wrong, a black index is question of the substring of the index. The index is [less than deckName](<LINK_0>, so this would throw an exception. I think the following code would be more appropriate: index = deckName.substring(0, index-1)
This seems wrong, a black index is question of the substring of the index. The index is [less than deckName](<LINK_0>, so this would throw an exception. I think the following code would be more appropriate: int deckName = 0; int index = deckName.indexOf("::"); if (index == -1) { index -= 1; } return 1;
This seems wrong, a black index is question of the substring of the index. The index is [less than deckName](<LINK_0>, so this would throw an exception.
you need call addColorSettingsListener on the new instance.
you need call getViewSite().getStateTable().getStateTableId() here.
you need call getViewSite().getStateTable().getConfig().
Should we use an argument instead of the default value here?
why is this needed?
Should we use an argument instead of the getter here?
I'm not sure if processFuture.isCancelled() should be executed but the, in this case an exception will be thrown.
I'm not sure if processFuture.isCancelled() should be executed but this.processFuture.get() is called in this thread.
missing braces
shouldn't you use lower case?
Can you use lower case?
why lower case?
it is not necessarily a good idea to have a component for this, but I would expect that deleting a remote resource should be done in order to make sure the method does not return anything.
it is not necessarily a good idea to have a component for this, but I would expect that deleting a remote resource should be done in order to obtain the PodPath from the URL
it should be synchronized
objects.hashcode()
objects.hash()
objects.hashCode()
Well, but just check the exception to avoid the casting in these cases.
Well, but just check the exception to avoid the cast in Exception to float.
Well, but just check the exception to avoid the casting in Exception is not necessary.
should this be done in the synchronized block below?
should this be done in the synchronized block above rather than here?
should be synchronized
Why not use the long value instead of the long value?
Why not use the long value?
We do not need the long value. Just use the long value.
org.eclipse.core.blink.util.EventFilter#testFilterIsTest
org.junit.Assert.fail("a", null);
org.junit.Assert.fail("a", null)
suggestion return getStats().getStats().getStats().getStats().isEmpty();
suggestion return getStats().getStats().getStats().isEmpty();
This is not good.
Argument name
No space name
No name
You can use Integer.compare() to avoid KEY here
You can use Integer.valueOf() to make the view a little shorter.
You can use Integer.valueOf() to make the view more readable.
java return service.getClass().cast(service.getClass().getName());
java return service.getClass().cast(service.getClass().cast());
java.map(service::getClass)
Can this be moved to after the first line?
Can this use SalesforceSDKManager instead?
Can this method be refactored to SalesforceSDKManager?
We can't do this, but I think the oneId.of() is the same.
We can't do this, but I think the oneId.of() in the previous code was a thing.
We can't do this, but I think the oneId.of() in the previous code was a bit safer.
Please, add the following code: - List<VM> vmsToImport = Arrays.stream(disksToImport.get(0).getClusterArch(), vmsToImport.get(0).getClusterArch(), vmsToImport.same(constants.get(0).getClusterArch(), vm.getClusterArch(), vmsToImport.get(0).getClusterArch(), vm.get(0).getClusterArch(), vm.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch()
Please, add the following code: - List<VM> vmsToImport = Arrays.stream(disksToImport.get(0).getClusterArch(), vmsToImport.get(0).getClusterArch(), vmsToImport.same(constants.get(0).getClusterArch(), vm.getClusterArch(), vmsToImport.get(0).getClusterArch(), vm.get(0).getClusterArch(), vm.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch()
Please, add the following code: - List<VM> vmsToImport = Arrays.stream(disksToImport.get(0).getClusterArch(), vmsToImport.get(0).getClusterArch(), vmsToImport.same(constants.get(0).getClusterArch(), vm.getClusterArch(), vmsToImport.get(0).getClusterArch(), vm.get(0).getClusterArch(), vm.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch().equals(vmsToImport.get(0).getClusterArch()).get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch().get(0).getClusterArch() is the default. I think it would be clearer if you call the 'null' method instead
I'm not sure why we need to wait for the stop to be called as part of stopAwaitility. The reason is that we can't use Thread.sleep here is that we need to wait for the reconnect to stop.
I'm not sure why we need to wait for the stop to be called as part of stopAwaitility.
I'm not sure why we need to wait for the stop to be called as part of stopAwaitility. The reason is that we can't use Thread.sleep here is that we need to wait for the reconnect to finish.
This can be final and will be consistent with the rest of the codebase where this would need to be.
This can be final and will be consistent with the rest of the codebase when I don't see the point.
This can be final and removed.
The use of System.err.println is not really helpful.
The use of System.err.println is not really appropriate.
The use of System.err.println is not really helpful. Don't use a magic number.
We should have unit tests for this method.
We should have unit tests for this method
We have unit tests for this method
ProgramState.Kind.OK?
ProgramState.Kind.REQUEST_TYPE
ProgramState.Kind.REQUEST_COUNT + 0; should be used only in this method
For consistency, looks like you can do return (val instanceof Number) || (val == null)
For consistency, looks like you can do return (val instanceof Number) || (val == null)??
Up to you, but isn't that a good idea?
Why not use the get(0) here?
Why not use the getDiskProfileIds() method?
Why not use the getDiskProfileIds() method here?
I think this would be easier to follow if you move the assertQuery methods into the SUM method and remove the @Nullable annotation.
I think this would be easier to follow if you move the assertQuery call into the "test" method. The assertQuery(...) would be easy to put in the future.
I think this would be easier to follow if you move the assertQuery methods into the SUM method and remove the @Test annotation.
I'd recommend moving the "templates" to "Messages".
I'd recommend moving the "generators/" and "templates" to the CommonApplicationMessages class.
I'm not sure we should do this. It would be better to annotate the "templates"
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
Consider the CollectionUtils.isNotEmpty(this.applicationDefinitions) instead
Consider the CollectionUtils.isEmpty(this.applicationDefinitions)) instead
I would suggest this instead: @VisibleForTesting static Type UNLISTED_PROPERTIES = UNLISTED_PROPERTIES;
I would suggest this instead: @VisibleForTesting protected Builder<BlockState> getBlockState() { return this.protectedBlockState(this, UNLISTED_PROPERTIES, UNLISTED_PROPERTIES); }
I would suggest this instead: @VisibleForTesting protected Builder<BlockState> getBlockState() { return this.protectedBlockState(this, PROPERTIES, UNLISTED_PROPERTIES); }
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (int) tileCount.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (right below)
Please use try-with-resources, <LINK_0>
please use try-with-resources, <LINK_0>
please use logger, not System.out.
static import?
method reference on 'public static final'
static import
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
I don't think we need this assumeThat. We'll probably need to do a check just for what we expect (3121).
I don't think we need this assumeThat. We'll probably need to do a check just for ws.http://test-api-data-api-model.
Do we need to update this in the setup method?
Do we need to update the database in the setup method?
Do we need to clear this?
missing check that vm exists. (getVm()!= null)
missing check that vm exists.
missing check that vm exists..
TouchScreen should be closed, not before it's used.
It seems that this.TouchScreen.NONE can be removed, and it's not used anymore.
It seems that any time the TouchScreen throws an exception, couldn't this cause NPE?
It's better to make a LOG.debug message. In case there were more than one, it might be good to log the exception.
It's better to make a LOG.debug message. In case there were more than one, it might be good to have a log.
It's better to make a LOG.debug message. In case there were more than one log line, it would be good to have more info.
So what's buggy about the CopyOnWriteArraySet?
So what's buggy about the CopyOnWriteArrayList?
So what is missing here?
This catch isn't needed, right?
This catch isn't needed anymore.
This catch isn't necessary. Could be removed.
suggestion assertNull(pherf.defaultString());
suggestion assertEquals(pherf.default("pherf.default.dataloader", null);
suggestion assertEquals(pherf.defaultString());
It's really not a big deal, but it would be good to put in a service so we can more sure it's really the same instance there.
It's really not a big deal, but it would be good to put in a service so we can more sure it's really the same list.
It's really not a big deal, but it would be good to put in a service so we can more sure it's really the same list of services.
should check baseNameSet.isEmpty() in the constructor and return baseName + "_"?
should check baseNameSet.isEmpty() in the constructor and return baseName + "_".
should baseNameSet be null or empty?
can be package private?
Can be package private?
Can be null?
spacing here looks off
Should we use a else if here?
Should we use a similar password here?
You can use a list here
You can use a stream here.
You can use a stream here
This should probably be refreshTargets.refresh()
This should probably be refreshTargets.refresh();
This should probably be refreshTargets.refresh() ;-)
please inspect checkstyle
please apply formatting
double
Can you look into this? this.data = null;
Can you update this to java doc please?
Can you update this to java doc explaining the purpose of this class?
I think it's better to move this code into an extra method.
I think it's better to move this check to the ctor as the fallback handler may be null.
I think it's better to move this up to the method.
should it be this.beanName?
should it be this.beanName!= null?
should probably use getComponentName here too
I would put this in the Processor#initializeConsumer() method.
I think this is the consumer method of the Processor, not the consumer itself.
I would put this in the KafkaConsumer's class.
when you make this a non-final variable, you don't have to use static imports
when you make this a non-final variable, you don't need a local variable
when you make this a non-final static, you don't need a second local variable
Looks like this can be simplified to: while (inClosed == null) { while (inClosed == null) { Thread.currentTimeMillis(); } }
Looks like this can be simplified to: while (inClosed == null || inClosedClosed && inClosedClosed == null) { while (inClosed == null) { Thread.currentTimeMillis(); } }
Looks like this can be simplified to: while (inClosed == null || inClosedClosed && inClosedClosed == null) { while (inClosed == null) { Thread.currentThread().interrupt(); } }
same here as for Check other classes.
same here as for CheckSink
Looks like everything in the toString() method can be reused?
Remove this line and add.thenReturn(event); to the when(...).
Remove this line and add.thenReturn(event); to the when(...) clauses.
Remove this line and add the.thenReturn(event); to the when(...).
use the interface, I don't know what the size is.
use the interface, the editor is much more flexible.
use the interface, the lambda is shorter
This should be an exception, because it does not happen. Might be better to handle this through an InvalidExpirationTimeException.
This should be an exception, because it does not happen?
This should be an exception, because it does not happen when the key is null.
Should it also be log.error, not info.
Should it also throw if the rulesProcessor would not be initialized?
Should it also throw if the rulesProcessor is not initialized?
Let's make this assertion fail inside a try block and have catch like this: java Assert.fail(); throw new IllegalArgumentException("Foo canonical = fieldNames.poll(); //NON-NLS-1
Let's make this assertion fail inside a try block and have catch like this: java Assert.fail(); throw new IllegalArgumentException("Foo canonical = fieldNames.foo");
Let's make this assertion fail inside a try block and have catch like this: java Assert.fail("Foo Converter fieldNames = fieldNames.foo");
Is this triggerable? I think it should be set in the constructor instead.
Is this triggerable? I think it should be set in the constructor instead?
Is this triggerable? I think it should be already running on the executor.
Static import
Static imports
Static importing
Is this null check necessary? workflowDefinitions.values() creates a new array. Moreover, when workflowDefinitions is not null you will have NPE.
Is this null check necessary? workflowDefinitions.values() is already a forEach and this remove method is missing here.
Is this null check necessary? workflowDefinitions.values() creates a new array. Moreover, when workflowDefinitions is not null it means that the workflowDefinition is not initialized.
Style-nit: We don't mark field as final.
Why does this need to be public?
Style-nit: We don't mark local variables final.
Why not use new ArrayList<>() in the constructor, two lines below?
Why not use new ArrayList<>() in the constructor, two lines below
to remove
new Double is redundant here
new Double is unnecessary here
other Double is redundant here
return getQueryUri(Query);
return new UriBuilder<Query>();
return this;
I don't think the getFactoryIds() is necessary?
It is weird that you are using the returned decorators, not the data set.

use same type for instanceof and force casting
use same keys for instanceof and force casting
use same type for instanceof
Do you need this?
isAssignableFrom?
Could you please use isAssignableFrom?
do we need this?
do we need this list or just return.
do we really need this?
Should be moved to the View and hide section, e.g. GONE.
Should be moved to the View and remains as it is.
Should be moved to the GONE object as it's a constant.
it will be more secure to do: java Authentication authentication = authentication instanceof AnonymousAuthenticationToken? Authentication.getContext().getAuthenticationToken();
it will be more secure to do: java Authentication authentication = authentication instanceof AnonymousAuthenticationToken? Authentication.getContext().getAuthenticationToken(AuthenticationToken) : authentication);
it will be more secure to get the authentication in the request
would it be easy to interleave a bad operation with good operations and ensuring that the good ones are not affected?
would it be easy to interleave a bad exception with good operations and ensuring that the good ones are not affected?
would it be easy to interleave a bad exception with good operations and ensuring that this is the same error
suggestion.subscribe(out -> new PrimitiveLongArrayQueueWithRandomCapacity( 7 ) );
suggestion.subscribe( new PrimitiveLongArrayQueueWithRandomCapacity( 7 ) );
suggestion assertThrows( 5 ) );
If it is null, requireNonNull will fail trying to invoke methods with null. What do you think?
If it is null, make the variable be 'null'.
If it is null, requireNonNull will fail trying to invoke methods on line 82, since it was null.
Can be written in a different way: verify(processor!= null)
Can this be written in a finally block?
Can this be written in a different way?
Let's give it a more clear exception (see the class for an example).
Let's give it a more specific exception (see the class).
Let's give it a more clear exception (see the class for an instance).
how about adding getByName(name) as a default method in setActiveEditor(String) and then leaving it as smth like setActiveEditor(boolean) and remove the explicit null check?
how about adding getByName(name) as a default method in setActiveEditor(String) and then leaving this as smth like setActiveEditor(boolean) and remove the explicit null check?
how about adding 'SimpleColumn' and setActiveEditor' in the next commit? This would make it easier to maintain.
try-with-resource?
try-with-resource is a no-op here (same for close)
try/finally?
Shouldn't it be an IllegalStateException?
Shouldn't it be in the initBatchStatusCallback instead of the condition?
Shouldn't it be in the initBatchStatusCallback?
What we are waiting here on?
Are we really need these sleeps on the web element?
Are we really need to wait 2 seconds if we are waiting here?
I know this isn't part of your change, but we should probably do it in another test case.
I think this should be done in every test method.
I think this should be done in other tests.
qry -> query
qry -> query Is this better?
qry -> query;
Let's throw an IllegalArgumentException here if the parameter is missing.
Do you need to check the return code?
Let's throw an IllegalArgumentException here.
In this case, I think it would be better to go with SpecialNewPages.openSpecialContent(articleTitle); at the top of this method.
In this case, I think it would be better to go with SpecialNewPages.openSpecialContent(articleTitle, ArticleContent articleTitle)
In this case, I think it would be better to go with SpecialNewPages.openSpecialContent(articleTitle); java ArticleContent articleContent = new ArticleContent();
It may be better to put these in the map method: java this.output = Arrays.asList(JwsAlgorithm, expectedJwsAlgorithm);
It may be better to put these in the map method: java this.outputAlgorithm = Arrays.asList(key);
It may be better to put these two lines in it instead.
why not use java.util.Objects.hash()?
please use java.util.Objects.hash()
Can you use HashCode.compute()
retrieving result is OK
I think this method belongs more in the BulkResponseDto
retrieving the result from a similar method.
Why are we using the existing one? This could cause a runtime exception if the maps are not available
Why are we using the existing one? This could cause a runtime exception if the maps are not available.
Why are we using the existing one?
synchronization is a little scary here. It can cause deadlocks because the syncSession will be executed concurrently. In that case it would be possible to lock the whole "client" object before we close the session, and we'll leave it to another PR.
synchronization is a little scary here. It can cause deadlocks because the syncSession will be executed concurrently. In that case it would be possible to lock the whole session, openSessionWithConfig method, and then synchronize on the lock. The was synchronized would be a better fix.
synchronization is a little scary here. It can cause deadlocks because the syncSession will be executed concurrently. In that case it would be possible to lock the whole thing before invoking the syncSession.
I would have thought you will use I18N.tr here.
I would have thought we will use I18N.tr here.
I would have thought that :+1:
Are we sure about the stack trace?
Are you sure about the stack trace?
Are you sure this is right?
You can merge this if with &&.
You can merge this if with && and else if, else return false.
You can merge this if with && by ||
This isn't quite the test you wanted, I think. Shouldn't it be "0020.".
This isn't quite the test you wanted, I think. Shouldn't it be "0020".
This isn't quite the test you wanted, I think. Shouldn't it be "return new sArray(0020.get(0)).
Why is client being passed here? Can't we use TimelockRpcClient.class?
Why is client being passed here? Can't we want this method to be used at all?
Why is client being passed here? Can't we want this method to be called through create?
you should have it be this.fStreamInputReader = streamInputReader;
you should have it in the class itself.
you should have it be this.fStreamInputReader = streamInputReader
This is more complicated than the previous line. Can you please extract this to separate method?
This is more complicated than the previous line. Please use Java 8's Duration API.
This is more readable now, but please open another project so you can easily use Assert.assertEquals
It would be nice to include the original exception as the cause, e.g. throw new InetSocketAddress("localhost:08:27226")
It would be nice to include the original exception as the cause, e.g. throw new InetSocketAddress("localhost: replicated");
It would be nice to include the original exception thrown here.
We should have a style here to avoid the 'delay' field, which can be marked as a final.
We should have a style here to avoid the 'delay' unless it's a part of the code
We should have a style here to avoid the 'delay' unless it's a part of the class.
Should this be synchronized?
Probably should be synchronized?
This should be synchronized, also?
I don't think you need this variable (this is what is happening here in this PR)
I don't think you need this variable (i.e. use a KafkaProducer here)
I don't think you need this variable?
It might be better to return directly, so that we don't have to load the same media twice.
It's not necessary to return uploadingPost. I think we can just return emptyMap() instead of null.
It might be better to return directly, so that we don't have to keep track of the same thing here.
Adding this to a field is good manner.
Adding this to a field is safe.

Can you add a space before the comma?
Maybe use listed character instead of'skip_after_exist'
Can you add a space after the comma?
can we create the feedRanges.addAll, this becomes more readable?
can we create the feedRange object outside the lambda expression and use only once?
can we create the feedRange object outside the lambda expression and use only once.
Consider replacing this by a call to GregorianCalendar. The user can set it as a final variable.
Consider replacing this as a constant
Consider replacing this as the previous line.
I would prefer not to use public String copyModalStatusMessage(String request) { return copyModalStatusMessage(driver.findElement(By.id("feedback-copy-modal-status)).getText(); }
I would prefer not to use public String copyModalStatusMessage(String request) { return copyModalStatusMessage(driver.findElement(By.id("feedback-copy-modal-status", WebElement.driver).getText()); }
I would prefer not using WebElement here as it is more flexible.
This is perhaps a good idea to call indexMapper.closeAfterCompletedRecovery(true) and shutdownAfterCompletedRecovery.values().forEach( index -> index.addSuppressed(close));
This is perhaps a good idea to call index -> flush method for all the time. Maybe just call index -> flush method?
This is perhaps a good idea to call index -> flush method for all the time?
It may be worth expanding this to include say: + "'Push' rights on " + GitRepositoryManager.REF_CONFIG
It may be worth expanding this to include say: + " + GitRepositoryManager.REF_CONFIG
It may be worth expanding this to include say.
I am just wondering whether this should be a method. I am starting fqdn and putting it in the host name.
I am just wondering if this should be a method. I am starting fqdn and then using variables to get the value from the given storage.
I am just wondering if this should be a method. I am starting fqdn and then using variables to be used for changing the value.
I'd use the ternary operator here.
I'd use the boolean operator here, this will enable us to send a simplification.
I'd use the boolean operator here, this way, we can use the code directly without needing to handle the null case.
Boolean.TRUE.toString() unnecessary
Boolean.TRUE.toString() is unnecessary
Boolean.TRUE.toString() is used for type equality.
Code style: please use this.v4Codec = new ArrayList<>()
please move the initialization to the top (it's the same line)
Code style: make it static
Perhaps this could be a simpler method of SqlUtils.appendParsingUtils(filename, extension)
Perhaps this could be a bit more readable with a switch statement instead of returning null here.
Perhaps this could be a bit more readable with a switch statement instead of a regular expression.
Returning a List directly feels problematic. Better than returning an empty list.
Returning the list directly would be useful - please don't add another null check.
Returning the list directly would be a bit hard to read. Instead, why not have the FQCN?
Is there a reason not to do this in the factory? Because there is a requirement that storedAccount is an instance of OAuth2AuthStatus, which is not an instance of Credentials.
Is there a reason not to do this in the factory? Because there is a requirement that storedAccount is an instance of OAuth2AuthConfiguration.
Is there a reason not to do this in the EndPoints?
Same here, return ImmutableSet.of(this.resultStream, this.resultStream);
Same here, return ImmutableSet.of(this.resultStream);
Same here, return ImmutableSet.copyOf(this.resultStream, this.resultStream);
remove.
at least log debug
At least log at debug
state.getTime()
state.getTime() can be removed
state.getTimestamp
Eliminate the if and else clauses - if (!proxyHost == null) { return null }
Eliminate the if and else clauses - if (!proxyHost == null) { return...; }
Eliminate the if and else - if (!proxyHost == null) { return null }
assertFalse(...);
assertFalse(...); is redundant
assertFalse(...);?
There is a space between ) and {
There is no need to convert 2 to Strings, just use builder.charAt(index ) == )
style nit: missing spaces around =
should we return a CqlQuerySpec instead of querySpec?
should we return a querySpec instead of params?
should we return a querySpec instead of params? Spec are a bit of a querySpec.
"data" is already a plural noun.
"PE" is a very unusual word for the version.
"PE" is a very unusual word for the version?
can we write this as if (getSession.isEmpty()) {... }
can we write this without the Codacy/clustering?
can we write this as if (getSession.isEmpty()) {... }?
Why not simply Arrays.asList(name)?
Why not Arrays.asList(name)?
How about reusing 'name' and'"\""?
for the sake of consistency, could you change the message to "candidate not found"?
for the sake of consistency, could you change this to LOG.info?
for the sake of consistency, could you change the message to "candidate not contain"?
nit: I don't think we need this method anymore.
nit: I don't think we need the leading "/" here. Why not just.equals()?
nit: I don't think we need the leading "/" here. Can we just use.equals() instead?
can be simplified to return getFileName(url);
can be simplified to return ((url == null)? null : title);
can be simplified to if (title == null ||!title.isEmpty())
This can be written more concisely with a single line: if (page.getRowPercentageComplete( event.getActivity(), new AsyncExecutionStatus(this)) { ReportProgressEvent.setPercentageComplete( event, new AsyncExecutionStatus( event, 0); }
This can be written more concisely with a single line: if (page.getRowPercentageComplete( event.getActivity(), new AsyncExecutionStatus(this)) { ReportProgressEvent.setPercentageComplete( event, new AsyncExecutionStatus( event, 0); }...
This can be written more concisely with a single line: if (page.getRowPercentageComplete( event.getActivity(), new ReportProgressEvent(this)) {
Just use toLowerCase
Just use toLowerCase here.
Just use [StringJoiner](<LINK_0>
publishEvent() -> handleException
publishEvent() is now redundant.
publishEvent() -> handleException(event);
java if (ENABLE) { FMLPreInitializationEventRegistry.registerEventForgeTick(BlockFire.class); }
java if (ENABLE) { FMLPreInitializationEventRegistry.registerEventForgeTick(this); }
java BlockEventRegistry event = new BlockEvent(BlockFire.EVENT_BUS);
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could we check AsyncClient.findEventLoop?
Did you check AsyncClient.findEventLoop?
Can we check AsyncClient.findEventLoop?
Suggest log.info("getBankState() to getBankState())
Suggest log.info("getBankState() to bank state to a non-null state",
should we use parameterized logging here?
@ivandalbosco Why not to use tree.getResourceResolver(tree) here?
@ivandalbosco Why not to use tree.getResourceResolver(tree) here as well?
@ivandalbosco Why not to use RULE_MESSAGE here?
Use the JSONCountResponseTypeResponseType?
Use a JSONCountResponseType?
Use the JSONCountDeviceType for such cases.
suggestion this.map = child.map(this::map);
this.map(View::get) can be removed now.
suggestion this.map(View::get, true);
Think we should log the exception at debug, if it happens, it could be helpful.
Thinking about it, that the log at the warn log-level is printed.
Is warn sufficient?
isn't this breaking backward compatibility? If the reload() method is called anywhere in our driver code a client did override the supportsReloading to return false before, he will get the UnsupportedOperationException in their code (whereas it was not a case before this change)
isn't this breaking backward compatibility? If the reload() method is called anywhere in our driver code a client did override the supportsReloading to return false before, he will get closed in their code (whereas it was not a case before this change)
isn't this breaking backward compatibility? If the reload() method is called anywhere in our driver code a client did override the supportsReloading to return false before, he will get the UnsupportedOperationException in their code (whereas it was not a case before this change) Shouldn't we make this method private?
Looks like it's used only in one place. Could we please avoid it?
Looks like it's used only in one place. We can probably remove it?
Looks like it's used twice.
I think you could use this (check if the BlockState.WATERLOGGED) here.
I think you could use this (check if the BlockState.WATERLOGGED)
I think you could use this (check if the BlockState.WATERLOGGED) here can be removed?
I realize that the color is not a good hash function. It will always return a value in the range [0..255]. Why not just treat RGBA as a single int? ((alpha << 24) | (blue << 16) | (green << 8) | red as in org.eclipse.swt.graphics.RGBA gives a much better distribution.
I realize that the color is not a good hash function. It will always return a value in the range [0..255]. Why not just treat RGBA as a single int? ((alpha << 24) | (blue << 16) | (green << 8) | red as in org.eclipse.swt.graphics.RGBA gives a better distribution.
I realize that the color is not a good hash function. It will always return a value in the range [0..255]. Why not just treat the min value as a single int? ((alpha << 24) | (blue << 16) | (green << 8) | red as in org.eclipse.swt.graphics.RGBA gives a much better distribution.
Should this be synchronized?
Should this be in the synchronized block?
Should this be in the @Override annotation?
Can just use new booking / userOwningReservation
Can just use new booking / userOwningReservation?
Can just use new booking / userOwningReservation(...)
You can use HandlerDataList.getAllContacts() here.
I think it would be better to have the exception bubble up where this is called.
I think it would be better to have the exception bubble up where this method is called.
Missing "instantiation" in line 4.5: ==> PMD
Missing "instantiation" in the configuration
Nice attempt to use a constant, in case you want a more coherent name.
Remove else clause.
Remove else clause
Remove this if statement.
Is it possible to account for the currentAccount?
Is it possible to account for the current account?
Is it guaranteed that the account has an account that has the deleted account?
Please avoid using focusSplitter if possible.
Please avoid unnecessary wrapping lines
Please avoid unnecessary casting.
Might be simpler to use the ReceiveCommitProducer.class.
Might be better to put this into the field declaration.
Might be better to put this into a properties file, given that there is no client.
We can use Collections.singletonList() here
Collections.singletonList?
We can use Guava's Lists.singletonList() here
Thoughts on putting a null Intent.ACTION_VIEW first?
Thoughts on putting a null Intent.ACTION_VIEW first, I think you can use isEmpty() instead.
Thoughts on putting a null Intent.ACTION_VIEW first, i.e. ==0?
@antonini please name it user
@antonini please name it user, and initialize it with Opt.Empty
@antonini please name it user, and rename it to use Besides
Can you add instanceof check?
Can you add instanceof check to see if the list is empty or if it is empty?
Can you please use logger.debug("{} ReadView for SubpartitionView", getSubPartitionIndex());
I'd use << 3 to match MemoryTrackingExecutor.COUNT
Why are you using maxSize here?
Why use maxSize?
super() is not needed here, it will always be true and will be removed
Is this line needed?
super() is not needed here, it will always be true and will affect the other constructors.
Same here, check for null and empty string?
Same here: check of null and empty strings
Same here, check for null and empty strings
wrap with Collections.unmodifiableMap()?
wrap with Collections.unmodifiableMap() or Collections.unmodifiableMap()
can be removed
I'm not sure about this. If the reason is empty, the reason is that trim() will fail.
I'm not sure about this. If the reason is empty, the reason is that trim() will return false.
I'd go with comparison the reason and use isEmpty() to compare enums.
Is there a reason why this is public? I would say it would become a private method (instead of a public)
Can this be replaced by a constant (same for the other one)?
Is there a reason why this is public?
Why is this check needed?
Why this change?
Why is this check required?
Please use constants for the name
Please use constants for that
Please use constants.
"\"(argNumber - 1 >= MIN_LENGTH_OF_HARD0, MESSAGE_ARGUMENTS)
"\"(argNumber - 2 >= MIN_LENGTH_OF_HARD0, MESSAGE_ARGUMENTS)
"\"(argNumber - 1 >= MIN_LENGTH) && argNumber > MIN_LENGTH_OF_HARD0,
suggestion numberOfSpecialChars = value.toCharArray();
suggestion numberOfSpecialChars[count] = 0;
suggestion numberOfSpecialChars[count] = value + 1
Could be good to close the stream. Please use try-with-resources
Could be good to explain why this one is required
Could be final
Why not just shift?
Why not just use < 3)?
Why not just return (private) 0?
Could use a path and path for this.
Could you use path.contains() for this?
Could use a path, same for both get and delete for.
I am not a PrometheusMetricsTracker in the same package.
I am not a PrometheusMetricsTracker in the same package. It appears to only be used by rometheusMetricsTracker in the same package.
I am not a PrometheusMetricsTracker in the same package. It appears to only be used with rometheusMetricsTracker in the same package.
What is the reason for calling getEncountersModifiedOnOrAfter(date) twice?
I don't think this should be public
What is the reason for initialize date and time?
NIT: this can be shortened to final Duration.ofSeconds(10).
NIT: this can be state.getState() + 1 instead of 200?
NIT: this can be inlined at the top of the method, since there's no item yet.
static import scrollId, ScrollRequestBuilder.NONE
static import it, ScrollRequestBuilder.getInstance().setScroll(scrollTime).
static import it, ScrollRequestBuilder.getInstance().setScroll(scrollTime);
what about replacing with "} "
what about replacing with "} VmStatusExists" with "return true;"?
what about replacing with "} VmStatus.getStatus()"?
Should this throw a specific exception instead of silently catch? Or should we throw a RuntimeException?
Should this throw a specific exception instead of silently catch?
Should this throw a RuntimeException?
Can you add project name to the thread?
Can you add query that will be sent at the end?
Can you add project name to the list
please don't write final for local vars
please don't write final for the variable.
please don't write final for local vars.
This only asserts that this entry is not null.
optional: can narrow scope
exactRef
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers'motif' also as Linux, along with 'win'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers'motif' also as Linux, along with 'win'. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers'motif' also as Linux, along with 'win' that motif' is a motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
This does not compile.
This does eventually emit the CompositeException. Is this really what we want?
This does eventually emit the CompositeException. Is this really intended?
Another option would be to set the flight flag here if the next line makes sense.
Another option would be to set the flight flag here if the distance is null.
Another option would be to set the flight flag here if the next line is turned on.
Shouldn't this be done in the constructor, both here and in the other tests?
Shouldn't this be connect to the SCMManager instead of the EE_ADMIN_TASK_DEFAULT?
Shouldn't this be 0?
Move the logic of sessionSet.put into the addListener block.
Move the Preconditions up to the checkState chain?
checkState?
You are not using the default.
You can also use our default.
You can also use the default size here, as it's not used?
Can you assert that the correct text is changed?
Can you assert that the correct text is set?
Can you assert that the correct assertion on the string value?
negative logic
negative logic. I don't think negative logic is necessary.
negative logic maybe?
mStatus == null || result.mStatus.mCode == mStatus.mCode.mCode); should be enough: return result.mStatus!= null && result.mStatus.mCode == mStatus.mCode;
mStatus == null || result.mStatus.mCode == mStatus.mCode.mCode);
mStatus == null || result.mStatus.mCode == mStatus.mCode);
should return streamConsumer here.
should it be StreamConsumer?
should it be return streamConsumer?
assertThat(map).doesNotContainSize(new HashSet<>());
assertThat(map).doesNotContainSize(new HashSet());
assertThat(map.keySet())
We should not show this dialog in the case of the user name.
We should not show this dialog in the case of the user name. I'd use _foo_ and _foo_bar_ instead.
It seems to me that this is not being tested for the user with a dialog?
HttpServletResponse.SC_NOT_FOUND
Can't this be void?
Can it be publicationRepository.findById(id)
If we can use a switch statement or if (parts.isNumber() &&!amzx.isNumber()) {... } else { // do stuff }
If we can use a switch statement here.
If we can use a switch statement or if condition we can use two-case
Do we really want bitwise and &? In this case they are roughly the same so it probably doesn't matter too much.
Do we really want bitwise and &? In this case they are roughly the same so it probably doesn't matter too much. We don't want either.
Do we really want bitwise and &? In this case they are roughly the same so it probably doesn't matter too much. Please revert.
I am not sure about this. Can't this line be removed?
I am not sure about this. Can't this line be replaced with below?
this again looks like other parsers
Use Config. OkHttpClient instead of TimeUnit.MILLISECONDS.
Use.get() instead of creating a new OkHttpClient instance for each one-time.
Use.get() instead of creating a new OkHttpClient instance that is not very clear.
Nit: We can make getType() == FN_COST_FACTOR or TYPE_COST_FACTOR.
Nit: remove "public"
Nit: remove curly brackets for ()
Do we need to use the containsKey()?
Do we need to use the containsKey if possible?
Do we need to use the containsKey() function?
We should not fail the test because it's not a Exception.
We should not fail. In any case, we can get rid of this.
We should not fail the test because it's not a RuntimeException.
why are you using!ambiguous instead of!ambiguous?
why are you using Boolean.TRUE.equals()?
why are you using!ambiguous instead of Boolean.
Intellij says that this variable should be removed before the method.
Intellij says that this variable should be removed.
Intellij says that this variable should be removed before the methods.
Remove final here.
extract to a method, e.g. setupUI
Remove final,.
Returning a raw Object is pointless
Returning a raw Object is unnecessary.
Returning a raw Object is pointless.
This is not equivalent, it's the way I tested it was to use fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY.E
This is not equivalent, it's the way I tested it was to use fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY,
This is not equivalent, it's the way I tested it was to use fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY, BLOCK_SIETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY.ETERNITY, fExperiment.getIndexer().buildIndex(0, TmfExperiment.ETERNITY.ETERNITY, f
Should the caller to close() the reader?
Should the caller to init the data to the database?
Should the caller do the init() here?
static imports
Why first the connect, then the check and disconnect?
suggestion "The disconnect should be executed.";
I think we should dispose both the labelControl and the labelControl.
I think we should dispose all the labelControl; labelControl = null;
I think we should dispose the control.
Could you add a method to the base class that takes the ftmfRawPacket.offer(p); here?
Could you add a method to the base class that takes the ftmfRawPacket.offer(pStatistics); here?
Could you add a method to the quarksPacket object?
Not sure how that would work this way for this, but if it is better to use NumberUtil::getMaxStackSize
Not sure how that would work this way for this, however you have a lot of code that does this method inside of the parent class, which seems very dangerous. Could you try to do this instead?
Not sure of this, what do you think of the above extract?
You should be able to use assertCopy and assertCopyWithMessage.
You should be able to use assertCopy and assertNull just for the values in the same line.
You should be able to use assertCopy and assertNull just for the return value.
Check for the second argument as well
Check if the first terminal is open.
Check if the first terminal is open?
It might be faster to use append instead of StringBuilder.
It might be faster to use append instead of StringBuilder here.
It might be faster to use append instead of StringBuilder in this method
So, we can do that for consistency?
So, we can do Arrays.asList(streamJoinOrder, new ArrayList<>()).add(streamJoinOrder);
So, we can do Arrays.asList(streamJoinOrder, streamJoinOrder) instead of the singleton list?
Should make this constructor final, here and below.
Should make this constructor final, here and other constructors.
Should make this constructor final, and no need to call it twice.
.. this is not necessary.
.. this doesn't use exceptions for control flow.
.. this doesn't use exceptions for control flow reasons.
Null check is not required here
Null values should be returned aspageContext
Null values should be returned here
Please add message to case when the server is not found.
Please add KieServicesFactory.getCKieServicesFactory() as a parameter.
Please add KieServicesFactory.newKieServicesFactory() and assertSuccessMessage().
This code can be simplified to a simple: return options.equals(option.observable, option);
This code can be simplified to a simple: return option.equals(option.observable, option);
This code can be simplified to a simple if (Option.TRUE.equals(option.observable, option))
:)
objectId
{}
can't it be MixClass.class.equals(MixClass.class)
can't it be simplified to assertSame()?
can't we use MixClass.class.equals(MixClass.class) here?
This method should be named addOsTypes
This method should be synchronized, as you are using the getOsTypes method.
This method should be synchronized, as you are using the getOsTypes for the version.
Can we change back to heartbeatInterval?
Can you change back to private for the purpose of the class?
Can you change back to private for the rest of the class?
This variable does not need to be at all.
This variable is no longer necessary.
This is the same as the previous file.
Shouldn't this be a static?
Shouldn't this be a public static?
return this.public?
Where does this line come from?
How about adding this method (time) and call the method directly?
How about adding this method to the superclass?
this can be converted into a list to set the userRoles variable
this can be converted into a list to set the userRoles variable.
this can be replaced with List<String> roles = new ArrayList<>(wsSecurityManager.length);
it can be initialized to -1
why not use windows?
It might be better to define a static variable for windows
From what I see, this is changing from public to public, which is not the best practice. If, we need to change TemplateManager to public.
From what I see, this is changing from public to public, which is not the best practice. If, we need to change getPreviousNode and remove original * from TemplateReplica.
From what I see, this is changing from public to public, which is not the best practice. If, we need to change getPreviousNode and remove original * from TemplateReplica. It's not a good idea to change the existing method TE.
I think that theskipWriteDelegate!= null check is redundant, since skipWriteDelegate.onSkipWriteItem(item) does the same thing.
I think that theskipWriteDelegate!= null check isn't needed here.
I think that theskipWriteDelegate!= null check isn't needed here right?
I don't think there is a need to check data to see if it's empty or null?
I don't think there is a need to check data to see if it's empty or not.
I don't know if there is any reason to have a public
Use InvalidArgumentException instead
Use InvalidArgumentException instead instead
Use InvalidArgumentException
Thanks for the fix!
Please use the same formatting as in if.
Please use the same formatting as in.getExtras()
you meant StringUtils.hasText()
Seems like you meant StringUtils.hasText()
you meant StringUtils.hasText()?
I'm not sure this can be done in ctor. If so, please make it package-private.
I'd make this package private, since it is only used in test code.
I'd make this package private, since it is only used in tests.
I'd take a look at 'VM::updateVmFromDb' for reference.
I'd take a look at how we're doing this.
please extract to a separate method
Can we rename this as well to P.S.NO_GATHER
Honestly I don't like the idea of this. I've been trying to read the code, not your code.
Honestly I don't like the idea of this. I've been trying to read the code, not your code...
I thought the previous check was on the same if. Is this really needed?
I thought the previous check was on the isEmpty but this could be removed.
I think the other toLowerCase methods do not need to be public.
Leftover debug statement (we can log it anyway)
Leftover debug statement (we can remove it)
Adjustment
Please use "enabled=" for consistency
We can use Objects.toStringHelper(this) here
We can use Objects.toStringHelper(this) here.
IMPORTANT This is not a pure function, or another another boolean expression..?
IMPORTANT This is not a pure function, otherwise after the first event is executed it will break.. Can this be a problem?
IMPORTANT
I would just add java additionalSchemes = filterConfig.getInitParameter("schemes", filterConfig); and move the rest of the logic into getInitParameters() method.
I would just add java additionalSchemes = filterConfig.getInitParameter("schemes").getInitParameter();
I would just add java additionalSchemes = filterConfig.getInitParameter("schemes", filterConfig); and move the rest of the logic into the init method
This looks wrong: policies = nodeTemplate.stream().map(policy -> this.getType().getId().getId().equals(policyType)).collect(Collectors.toList());
This looks wrong: policies = nodeTemplate.stream().map(policy -> { // TODO: policies
This looks wrong: you need a list
import com.google.common.base.Preconditions.checkNotNull;...
import com.google.common.base.Preconditions.checkNotNull;... the same for other fields
import com.google.common.base.Preconditions.checkNotNull;... the same for other...
I think I would do this in other places: java optionsHelper.getGenerationSuffixSuffix("this").all(); return MathHelper.min(processingEnv, optionsHelper);
I think I'd do this in other places too.
I think I would do this in other places: java optionsHelper.getGenerationSuffixSuffix("configuration").this(processingEnv)
This can fail, since it's not a ByteArrayOutputStream.
This will unnecessarily wrap RuntimeExceptions on the next line.
This will unnecessarily wrap RuntimeExceptions with another RuntimeException and should be fine.
solveSymbolInType is already a variable and you don't need to call it twice
solveSymbolInType is already a variable and you don't need to call it twice.
solveSymbolInType is already a variable that can be null.
This is a breaking change, right? We have [doExport](<LINK_0> for now.
This is a breaking change, right? Please revert.
??
why this call here?
why this one?
why this call?
return ratingDao.get(id).map(listener -> rating.delete(id)).collect(Collectors.toList());
return ratingDao.delete(id);
return ratingDao.get(id).map(listener -> rating.delete(id));
nitpick: This seems unnecessary, if you want to resolve the certificate you should just return the same thing.
nitpick: I think you can simplify this as return findPrincipalInternal(certificate).contains("Resolving principal from certificate")
nitpick: I think you can simplify this as return findPrincipalInternal(certificate).contains(certificate).
I think the ENGINE_END is also a literal ENGINE_END, maybe the code should be extracted in a separate method?
I think the ENGINE_END is also a literal ENGINE_END, maybe the code should be extracted into a constant as we do in other places?
I think the ENGINE_END is also a literal ENGINE_END, SCRIPT_START_ONION_START_ON FALSE is used here too
Minor suggestion: you could use Objects.equals(this.className, other.methodName); here.
Minor suggestion for consistency: this could also use Objects.equals(this.className, other.methodName);
Might as well use the class name instead of the implementation?
Does this method need to be public?
Does this need to be public?
Does this method need to return a Collections?
You need to ask the chart viewer for the chart viewer, as you already know it in super class
You need to ask the chart viewer for the chart viewer, as you already know it in the constructor
You need to ask the chart viewer for the chart viewer, as it is done by another thread
should use {} instead of string concat
should this be wrapped in a try/catch?
should use the logger instead of a string concat?
In the original code, you had a method synchronized on the Level class which returns the executor. This synchronized block is not necessary.
In the original code, you had a method synchronized on the Level class which returns the executor. This synchronized block would be unnecessary.
In case of exception, synchronized block is not needed.
I think the CosemDateTime class is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTime instance is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTime class is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside of the class.
Can it be final? It is only used for initialization. Please remove.
Can it be final? It is only used for logging.
final
This is not really needed.
This is not needed.
This is not really reliable, since the distinct operation may change in a different thread.
Not sure what is the best way to get the revision, but if it is not in the DB, then pass the whole action like in the other code to the revision, this method would be much better.
Not sure what is the best way to get the revision, but if it is not in the DB, then pass the whole thing as listActions call as a parameter.
Not sure what is the best way to get the revision, but if it is not in the DB, then pass the whole action like in the other code to the revision, keep the original.
Does this mean that banner service is added to the list with newbanner?
Does this mean that banner?
<LINK_0>
nit: removeStyleName
nit: removeStyleName?
nit: removeStyleName?
Why do you have to change this?
Why do you need to return the buffer?
Why do you have to make this private?
return filter == null;
return filterIdx++;
return filter == null? false : nextFilter;
why public?
why static?
why not final?
I think we should assert that the exception is not thrown as well
BuildTypes.get(0) and it does the same thing
I think we should assert that the error is not thrown as well
Missing a regex here, this is a bit strange.
Missing a regex here, this is a bit confusing.
Trailing space here?
This can also use covariant return types
This can use covariant return types
This can also use Predicates.v, given that all likelihoodMap are in the same object
Extract common error codes to constants.
Extract this to a constant and also use it in tests.
Extract a constant to be sure it's used everywhere
Can't you reuse the same adapter here, too?
Can't we use the same adapter here, too?
Can't you reuse the same adapter here?
THE PROBLEM!!!! Look, it needs to be final
A blank line needed :)
THE PROBLEM!!!! Look, it needs to be removed
If we need this, I think it should be fine to go the the K config first.
Since this is the same for K, I think it would be better to go the the K propertiesAccessor.
If we need this, I think it should be fine to go the the K config is not there.
What's the reason behind this change?
@kuujo is it ok to make it public? If no, then make it public
@kuujo is it ok to make it public? If no, then make it public?
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
@garydgregory Please use Args.notNull for consistency with the rest of the codebase.
@garydgregory please use Args.notNull for consistency with the rest of the code base.
can we remove the method-call and just return the object from the method-call?
can we remove: declare-response, useless-assign and just return the object from the method body
can we remove the method-call?
Minor readability suggestion suggestion alarmCounter.addPropertyChangeListener("alarmCount", ignored->{
Minor readability suggestion suggestion alarmCounter = new AlarmCounter().addPropertyChangeListener("alarmCount", ignored->{
Minor readability suggestion suggestion alarmCounter = new AlarmCounter().addPropertyChangeListener("alarmCount", ignored);
These 2 lines can be made private. Also if you really want to change the name of the class, you could simplify the code like this: Set<IMethod> result = new HashSet<>(methods.size()); for (IMethod iMethod : methods) { if (methods == null) { return ImmutableSet.of(iMethod.getDeclaringType.getName()); }......
These 2 lines can be made private. Also if you really want to change the name of the class, you could simplify the for loop.
These 2 lines can be made private. Also if you really want to change the name of the class, you could simplify the code.
For my google style, we don't use braces around single line blocks
Nit: Don't requires Format. Format this file. Use the Eclipse formatter.
Nit: Don't requires Format. Format this file. Please rename the file to something like InputSeparatorWrapAfter
Duplicated code, should be 'text string' not 'text'.
Duplicated code, should be 'text string' rather than 'text'.
Duplicated code, should be 'text string' not 'text string'
whitespace
we can merge these 2 lines since the operation is the same in both cases (already and other usage)
we can merge these 2 lines since the operation is the same in both cases (already and other Snake)
you can just use "x64".equals(arch.get64())
Can we use Objects.equals(arch, arch); here?
Can we use Objects.equal here?
Would be good to have a test case for this.
Would be simpler to have a throw new UnsupportedOperationException("ForClass non-null") method for this purpose.
Would be simpler to have a throw new UnsupportedOperationException("ForClass non-null")
consider extracting to a method as this is called before the Guid#isNullOrEmpty
consider extracting to a method as this is used several times.
consider extracting to a method as this is used several times
nit: line break between CacheDistributionTaskResult and CacheDistributionTaskResult
I think we don't need to keep line 133
nit: line break between CacheDistributionTaskResult and GridClient.
s/Data mismatch/expected
shouldn't we use equals instead of!=?
shouldn't we use equals here?
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the bytes).
Better to get the bytes before the file.
We should rename importToGroupList to importToGroupList
We should rename importToGroupList to something that will not be applied here
We should rename importToGroupList to something that will not cover the underlying metadata
any reason why this is needed?
same here. can leaseDuration be null.
same here. can we use this instead?
Use Display.DEFAULT_ESH_getDisplay instead.
Should be synchronized
Use Display.DEFAULT_ESH_ID
use a plain null check
use a different name for the class
use a different name for the path
Why is this needed?
Why did you add the fatal message here?
Why are we adding afterFatalError here?
This seems like a unnecessary log.
This should be done conditionally, not in the UI thread.
This should be done conditionally, not in the database
nit: I think it would be better to do "if (public ValidationResultsType.BIOS_TYPE_INVALID_CLUSTER) && cluster.getBiosType() == null)" instead of checking for null.
nit: I think it would be better to do "if (public ValidationResultsType.BIOS_TYPE_INVALID_CLUSTER) && cluster.getBiosType() == null)". This can not be null at all.
nit: I think it would be better to do "if (public ValidationResultsType.BIOS_TYPE_INVALID_CLUSTER) && cluster.getBiosType() == null)". This can not be null if cluster is null.
You can use the shortcut method : java FmsGroup fmsGroup = new FmsGroup(this); FmsGroup fmsGroup = umsGroup.withName(umsGroup.getGroupName()); fmsGroup.withName(umsGroup.getGroupName()); fmsGroup.withName(umsGroup.getGroupNameGroupName()); fmsGroup.withName(umsGroup.getGroupNameGroupName()); remove the redundant assignment
You can use the shortcut method : java FmsGroup fmsGroup = new FmsGroup(this); FmsGroup fmsGroup = umsGroup.withName(umsGroup.getGroupNameGroupName()); fmsGroup.withName(umsGroup);
You can use the same format for the above. TmsGroup is a little more descriptive.
consider inlining the value of isNulls, e.g. getNullBlock(positionCount, Optional.empty(), nulls) to make it clear that the original value is always non-null.
consider inlining the value of isNulls, e.g. getNullBlock(positionCount, Optional.ofNullable(actionCount)). I don't think we need this if (isNulls == nulls) to make it clear that we never hit the nulls if the input parameter is null.
consider inlining the value of isNulls, e.g. getNullBlock(positionCount, Optional.ofNullable(actionCount)). I don't think we need this if (isNulls == nulls) to be consistent with the instanceof operator.
Please add curly braces around "else" clauses.
Please add curly braces around "if" clauses.
Please add brackets around index.
Please find a better name.
Please remove the return type.
Should be final
I'm not sure if IllegalStateException is appropriate here.
I'd prefer IllegalStateException instead of Throwable.
I'd prefer IllegalStateException instead of Throwable, since it's more specific to users that their state was not maintained.
I don't think this is a good idea. It could be private.
I don't think this is a good idea. It could be private or package-private.
missing {
Shouldn't it be error?
Shouldn't it be error level?
It would be great to have this in the transaction <LINK_0>
s/medic/medic/medic/g
s/medic/medic/medic/g/
We should probably store appUrl with getRootUrl().
Nit: this could be: java return Collections.emptyList();
Nit: this could be shortened to return Collections.emptyList();
Could not be null for this case
Why are you changing this?
Why are you overriding this?
Why are you changing this to implement the hashCode?
return throwable;
Add this to the end of the class?
Add this to the end of the method.
Should this be warn or warning?
Should this be warn or error?
should this be warn?
you can use the instance of SnomedNamespaceAndModuleAssignerProvider.DEFAULT_ASSIGNER
you can use the instance of SnomedNamespaceAndModuleAssignerProvider and SnomedNamespaceAndModuleAssignerProvider
you can use the below overload
I don't think you need to downcast the builder variable here. It will be picked up by the next method anyway.
I don't think you need to downcast the builder variable here. It will be picked up by the next statement by the builder.
I don't think you need to downcast the builder variable here. It will be done by the next statement in the builder.
Can you use shutdownNow instead?
Can you use shutdownNow() to stop the executor?
Can you use shutdownNow() to interrupt the thread.
I think we should still have a lock.
I think this should still be done outside the lock.
@Nullable
Could you please check the scheme too?
Could you check the scheme too?
Could you please check the scheme here?
Oh, is it possible that published ignoring a non-null data? If so, can you just remove the upstream?
Can you rename published and publish?
Can you remove this block?
Redundant brackets suggestion return tryActivateAndGet(e, item);
Oops, should we have a test for this method?
Can we have a return statement here?
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the string
I'd probably format this to only the following : { }
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value
The empty string in the error type should also be printed from the log statement.
The empty string in the error message should also be printed as a constant.
The empty string in the error type should also be printed as a constant from the trace.
Is there a particular reason we can't use Context.get(context) instead of Context?
Is there a particular reason we can't use Context.get(Context) instead of Context?
Any particular reason why we are using  0.5f, but not from the Center.
Needs fixed filename
Needs a space before the commas
Needs a space before the colon
rename to path
rename to path and use appendPath
rename to just type
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(smartRequestBuilder::setState);
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(smartpayTemplateData::setState);
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(smartParallelism -> { // Feb docs }
Use parameterized logging instead of string concatenation.
Can you remove this condition? If not, why not use two different approaches?
Can you remove this condition?
shouldn't we call into the future?
shouldn't we call bootstrap() as well?
Remove this.
The position parameter is in NatTable coordinates and could be out of range in the scrollableColumn. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
The position parameter is in NatTable coordinates and could be out of range in the scrollableColumn. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(viewportPosition.column); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(viewportPosition.column); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
Does this need to be a constant?
How about this.path = Objects.requireNonNull(System.getProperties());
How about this.path = Objects.requireNonNull(System.getProperties());?
Why not make this method synchronized?
why not make this method synchronized?
Why do we need this?
Make this private and add the @Override annotation.
inline fileInfo
Make this private and add a @Override
Data result = toData.get(key); if (valueData.isData()) { ttlUnit = toData.get(key); } else { ttlUnit = new Data(); }
Data result = toData.get(key, ttlUnit);
Data context = Data.Data.Data.toString(value);
nitpick... this should be renamed to simply gammaId, it's not necessarily new.
nitpick :) this should be renamed to simply gammaId, it's not necessarily new.
nitpick: this should be renamed to simply gammaId, it's not necessarily new.
Let's use a new MediaType object here. Then we can have test cases without validations.
Please keep the style of the surrounding file, it's easier to read. java matcher.setUseEquals(true);
Please keep the style of the surrounding file, it's easier to read. java matcher.setUseEquals(request);
assertFalse(...);
assertFalse instead of assertTrue?
assertFalse instead of assertTrue
It feels like there's a lot of context here that's being done at that point in the future. This should be fine, but maybe it's also fine to change this to ExtUtil.readBool(in);
It feels like there's a lot of context here that's being done at that point in the future. This should be fine, but maybe it's also fine to change this to readExpressions()?
It feels like there's a lot of context here that's being done at that point in the future. This should be fine, but maybe it's not worth making that change, since they're never actually reading any state at all?
Please create a constant with an empty array with a single element instead of re-sorted array.
Please create a constant with an empty array with a single element instead of re-wrapping.
Please create a constant with an empty array with more than one element.
This kind of breaks the really clean streak of "new Client()" calls with no arguments. Could we make it adhere to this pattern?
This kind of breaks the really clean streak of "new Client()" calls with no arguments. Could you make it adhere to this pattern?
This kind of breaks the really clean streak of "new AnnouncementClient()" method.
Please use ==, it can be Objects.equals() without the if/else block.
Please use ==, it can be Objects.equals() without checking if java.util.Objects is null.
Please use ==, it is the case with : ||
nit: can you use a constant for all these constants?
nit: This should be a constant reference.
Should be a constant?
KafkaSystemConsumer has a new variable e.g. KafkaSystemConsumer.originals = new KafkaConsumer();
KafkaSystemConsumer has a new logic for this.
This is not required
Integer.MAX_VALUE?
Integer.MAX_VALUE for a decimal number.
Integer.MAX_VALUE for a decimal type.
Should use 'equals' like in all the places as well.
Should use 'equals'
Should use 'equals' like in all the places (as well as in Line 89).
This could be done in a teardown method, instead of at the end of the database layer.
This could be done in a teardown method, instead of at the end of the database until the database starts.
This could be done in a teardown method, instead of during the setup method.
Can collapse both if statements?
Can this be null?
Can we rename this to targetObject?
does superclass installs one?
does superclass installs one? If not, and you need to instantiate them.
is there any reason for doing this?
uri == null &&!cls.equals(parent)
uri == null &&!cls.equals(web.xml)
uri == null &&!cls.equals(web.edge)
So why does it have to be a string literal here? Shouldn't it be a constant somewhere?
So why does it have to be a string literal here? Shouldn't it be the property name?
So why does it have to be a string literal here?
Could these use String.formatCriteriaNumber?
Could use StringUtils.isNotEmpty to check for null
Could these use String.formatCriteriaNumber or Util.
ColumnHandle does not exist. Please use this.dataType to be able to throw exception.
This can be replaced with column name.columnName()
This can be done much simpler.
Should this be a asyncExec?
Should we make this action a asyncExec?
Should we make this method final?
Is this test really necessary? Isn't the test you can do this before you test the plugin?
Is this test really necessary? Isn't the test you can do this before you test the structure?
Is this test really necessary? Isn't the test you can do this before you test the rest?
It's really minor, but it would be nice to use CRYPTOGRAPHY_STATUS in this method.
It's really minor, but it would be nice to use CRYPTOGRAPHY_STATUS in this method and have a separate method for the different path.
It's really minor, but it would be nice to use CRYPTOGRAPHY_STATUS in this method and have a separate method for the two methods.
This is not doing anything. The check for inflight state is now redundant.
Stylistically, either "inflight" or "out progress" are different (i.e. the check for inflight means)
Stylistically, either "inflight" or "out progress" are different
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside our fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this would be the case.
Can it be empty?
Can it be final?
Why wrap this in a list?
> Version [](start = 15, length = Version.getNumber())
I remember that there was a reason why this change was removed?
> Version [](start = 15, length = 4) remove #6
You can put this line and the previous one so it's more readable.
This line and the next should be omitted.
It would be nice if you could use hamcrest matchers here.
Why it's here? Please try to understand what went wrong.
Why it's here? Please try to understand what belongs to the first thing.
Why it's here? Please try to understand what belongs to the list.
This variable seems unnecessary.
Change this to assertSame instead.
Change this to assertSame
can just catch LockRefreshTokenException?
can we add a JUnit assert that exceptionCounter[0] is not null?
can just catch LockRefreshTokenException? return null;
Return bytes.hashCode() instead of bytes.hash()
Return bytes.hashCode() instead of bytes.hash().
same here for the member variable?
I think you can also use the DEFAULT_BROWSER_HEIGHT constant here.
I think you can replace this if/else with a single return statement
I think you can also use the DEFAULT_BROWSER_HEIGHT_RANGE.contains(itemHeight)
Is there a reason why this is called forEach on a loop?
Is there a reason why this is needed?
Minor: We could use.forEach here.
log lvl rather to trace here?
log javassist even if "input built" can be a leaf that validates that it doesn't match?
log javassist even if "input request is a leaf".
use ExceptionUtils, don't get update
Use ExceptionUtils, don't get update
Use variable name instead of Context
You can probably use LOCALE_CACHE.name().toLowerCase() instead of toLowerCase(), but you don't need the toLowerCase() here.
You can probably use LOCALE_CACHE.name().toLowerCase() instead of toLowerCase(), but you don't need to keep it.
You can probably use LOCALE_CACHE.name().toLowerCase() instead of toLowerCase(), but you don't need to keep it as is.
I think we can do this: java Objects.requireNonNull(value, "value");
Maybe Objects.requireNonNull(value)
I would use Objects.equals here, no?
I'm guessing the call to super.logTransactionMergeFailure() could be removed.
I prefer to keep the public scope.
I'm guessing the call to super.logTransactionMergeFailure() could be removed?
is this method no longer used?
else if on the isRemotePassword method.
else if on the isRemotePassword call?
Wouldn't it be better to use StringBuilder?
Wouldn't it be better to use StringBuilder?
toString() is unnecessary here (and could be replaced by String.valueOf() from the string
Rather than casting, can we ensure that the adapter is a Draggable(isAttached)?
Rather than casting, can we ensure that the adapter is a Draggable(isAttached())?
Rather than casting, can we ensure that the adapter is already registered?
public?
change to public
change to private
Again, it is better to use super.toString() here.
This is an extra toString() call that is usually in the code base.
Again, it is better to use ToStringBuilder.
we don't need this handling - it's hard to maintain in two lines
we don't need this handling - it's hard to find a way to make sure this has no effect.
we don't need this handling - it's hard to maintain when handling many blocks
For non-public methods checkWidget() is not required.
For non-public methods checkWidget() is not needed.
The null check can be removed
It might be better to use Objects.equals for comparing
Please use Objects.equals for comparing
Please use Objects.equals for comparing strings
This doesn't look like it belongs here.
This doesn't look like it belongs here, but why can't we put that in the constructor?
This doesn't look like it belongs here, but why can't we put that in the context itself?
I think you should not use the constants for these exceptions, it's used in three test cases.
I think you should not use the constants for these assertions.
I think you should not use the constants for these assertions. It's used in all test cases.
Let's move this line to just before the FBO is initialized.
Let's move this line below the FBO.readOnlyGBufferFbo().
Let's move this up please.
Maybe we should use a specific CompositeType instance instead of CompositeType.isPartControl()?
Maybe the 'public' is not needed?
Maybe we should use a specific CompositeType instance instead of CompositeType?
I don't know if this can be a 'public' state, but I'm missing something.
I don't know if this can be a 'public static'
I don't know if this can be a 'public' state.
So AIUI the basic problem is that one or more of the threads that called task.run() when paused == true is executing findForcedTask and has drained some tasks from taskQueue into the'storage' list. And at the same time null is returned. Is that a correct summary?
So AIUI the basic problem is that one or more of the threads that called task.run() when paused == true is executing findForcedTask and has drained some tasks from taskQueue into the'storage' list. And at the same time rc.run' Task will never be called. But at this point null is not possible.
So AIUI the basic problem is that one or more of the threads that called task.run() when paused == true is executing findForcedTask and has drained some tasks from taskQueue into the'storage' list. And at the same time rc.run' Task will never be called. But at this point null is the same as'ret'. Please add a check.
rename to pointShape here
rename to pointShape
why not an instanceof?
Can we use System.out.println() instead?
Shouldn't this be printed out in the finally block?
Can we use System.out.println()
This could be moved to @Before rather than in @After.
This could be moved to @Before rather than in @After. Also please use @After.
This could be moved to @Before also.
couldn't we simply fail the TenantAware tenantAware?
couldn't we just fail the TenantAware tenantAware?
couldn't we simply fail the TenantAware tenantAware?
inline bloomFilterWriteStore
inline
renamed
I know this isn't necessary, but it should make the code more explicit and fail on the bles
I know this isn't your change, but it should make it public here. And it should be called from the test...
I know this isn't your change, but it should make it public here.
Can you sync on the COL object here, and keep the synchronized block in the COL object?
Can you sync on the COL object here, and keep the synchronized block in the same line? I think it does not need to be synchronized as you would have it in multiple places.
Can you sync on the COL object here, and keep the synchronized block in the same line? I think it does not need to be synchronized as you would have it in another thread.
Why is it public?
Why is it thread safe?
if you have that logic here, it means you need to go into the map again
Shouldn't this be false?
I think it should be false?
I think we should have a default constructor to call super(MissingOverrides)
It's better to log a message no matter compression is enabled or not, it'll always be 0.
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's wrong.
It should be error no?
What does getCDSExonRangesForward mean? It doesn't make sense to check.
What does getCDSExonRangesRequested mean?
This is an unneeded check
This will throw NPE if there are no <class> default.
This should be replaced with <> on the declaration right? <LINK_0>
This will throw NPE if the <inner> is not available.
since bookkeeping is not constant, there can be possibility of failure/exception.
since bookkeeping is not constant, there can be possibility.
since bookkeeping is not constant, there can be possibility of failure reporting errors.
s/RemoteInstallEnabled/setLocalFile
s/Remote installationEnabled/install
s/RemoteInstallEnabled/setLocal installation is disabled/
@ivandalbosco please use CheckUtils#asString instread of toString (+ one more case)
@ivandalbosco please use CheckUtils#getNumberOfCommas(expression) instead.
@ivandalbosco It seems that we don't need to test binaryExpression. I think there might be more advanced expression.
I think isClient() can be replaced with isClient()
I think isrelevant changes?
I think isClient() is needed, since this is the only way to calculate the value back is needed.
exiting, so STDERR
exiting, STDERR
Do we have a default exit code?
shouldn't this return thehreadLocalRandom itself?
shouldn't this return the value?
shouldn't this return the value be legal?
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight.
elevatorControl
I think it is better to throw an exception here instead of setting the key manager to null.
Could use containsKey() method instead.
Maybe remove the condition and throw the exception?
You can combine these two lines into one.
Inline this object
You can combine these two into one.
I'm not sure if the logic is the right place to update the pre-existing cache if we're in the registry directory. What if we end up doing an pre-existing cache here?
I'm not sure if the logic is the right place to update the pre-existing cache if we're in the registry directory. What if we end up doing an pre-existing cache here and we're not going to change the cached directory?
I'm not sure if the logic is the right place to update the pre-existing cache if we're in the registry directory. What if we end up doing an pre-existing cache here and we're not going to change it?
currentBuffer -> currentBuffer
Add a message like: "totalBytes should equal to currentBuffer"
Add a message like: "totalBytes should equal to new byte[]"
PAD [dynamicText](<LINK_0>
Just use PAD.
Just use the PAD.
Same here and above.
You can use the logger here and below.
Same here.
this function can be private
minor typo: SEPARATOR
minor typo: CurrentSegmentCount
you can just use string here instead of string
you can just use string here instead of Long
can you call toString on it?
I don't think 'this' is needed, we use 'this' below.
I don't think 'this' is necessary, we use 'this' below.
I don't think 'this' is needed, we use the 'this' keyword is not necessary, and it is already handled by the parent class.
MANAGER_log = new M_log(request, response);
MANAGER_log = new M_log(request);
Why do you need the 'else' here?
You can use Locale.ENGLISH here
Please use Locale.ENGLISH here
You can use Locale.ENGLISH directly
Why not use the SshClient.newSshClient(node) method?
Why not use the SshClient.newSshClient(node) constructor?
Is there any better way to do this?
nit: what about if((expression instanceof CallExpression) && isNode((CallExpression) expression).getFunctionMetadata());
nit: what about if((expression instanceof CallExpression) && isNode(ST_DISTANCE))?
nit: what about if((expression instanceof CallExpression) && isNode(ST_DISTANCE == null))?
should filterUnpublish, not filter & report.
should filterUnpublish, not filter/save.
should filterUnpublish, not filter/count
I think it's better to keep the StatusChangeListener interface and make it @StatusChangeListener, and make StatusChangeListener be called from onInstanceStatusChanged() at that point.
I think it's better to keep the StatusChangeListener interface and make it @StatusChangeListener, and make StatusChangeListener be synchronized. Then the other code calling setStatusChanged() at the same time is called.
I would rather keep the old value assignment only.
Could you please add a getStorageDomainId() here?
Can you please use getStorageDomainId() here?
Can you please use getStorageDomainId() instead of getStorageDomain?
debug or maybe include this line in the name
debug or maybe include this line in the name?
+":"++":"+private="]>" instead of "private"
> I think it can be removed as it is not needed later. The only non-nullable stream is in the map.
> I think it can be removed as it is not needed later.
> I think it can be removed as it is not needed later (which will be >)
throws
unsure if this should be a ConcurrentModifificationException.
unsure if this needs to be done, right?
Minor: Should this assert that the result is a non-null list?
Minor: Should this assert that the result is a non-null string?
TAG?
Please revert this change for enriched files.
Please revert this change for the others in the future.
Please revert this change for HIGH_ACC_ID and create a separate Entity for "core.schema"?
Why?
What's the reason for this change?
This whitespace change shouldn't be necessary.
Was this change intended?
What is the reason that no CHROM?
Was this change intended to use a lambda when you need it?
using a ternary operator here might be cleaner.
using a ternary operator here might be easier to read instead of multiple returns
using a ternary operator here might be easier to read here
Can you make this method private?
Can you make this method private please?
Can you make this package-private?
value is a list, maybe use a LinkedList instead.
value is a list, maybe use a LinkedList instead?
"... and value cannot be empty"
Add link to the warning message.
Add.this.
Add this.
We need a null check here to make sure that the fields of the query are not null.
We need a null check here to make sure that the fields of the query builder are null.
We need a null check here to bring that.
Nit: could you please use assertFalse (byte)
Nit: could you please use getShort() here?
Nit: could use getShort() here.
This call will lead to an NPE if no thing is found for the thing.
This call will lead to an NPE if no thing status is found for the thing.
This call will lead to an NPE if no thing type is found for the thing.
Can be replaced with foreach loop.
Can't you use diamond operator?
please use static imports for (...)
I think we should have an equals check instead of ==. That's the same for the other fields.
I think we should have an equals check instead of ==. That's the same for the other field types.
I think we should have an equals check instead of ==. Same for the other methods.
Can we use ArrayType here?
Can you use ArrayType here?
Can we use assertThrows here?
This should be @Override
This should be public
@Override
This is needed not overriden
This is needed not used.
This is necessary.
You can use the evictedCount variable directly and save the value from the loop.
You can use the evictedCount variable directly
You can use the evictedCount field directly and save the overhead
MetricsInterceptor ioExecutor.shutdown()
add the list of available request id
MetricsInterceptor
It would be better to log the exception stack trace and print the stack trace.
It would be better to log the exception stack trace.
It would be better to log the exception stack trace and print it to logger.
I'd prefer to use "isGlusterSupportEnabled()" just to be consistent with 'isGlusterPeerProbeNeeded'
I'd prefer to use "isGlusterSupportEnabled()"
I'd prefer to use "isGlusterSupportEnabled()" just to be consistent with 'isGlusterPeerProbeNeeded'.
This is a bit of a nasty way around the exception handling. I'd prefer to do the try/catch instead. It's a little cleaner to read.
This is a bit of a nasty way around the exception handling. I'd prefer to do the try/catch instead. It's a little cleaner to keep the code simpler.
This is a bit of an unexpected exception. Should use the extended error codes.
Is this the same as before?
Do we have a test for this?
Is this the same as in test?
You can store the value of this in the class instead of the field again.
You can store the value of this in a field instead of the class.
You can store the value of this in a variable and return it instead.
You can use iterator.values().forEach((BondMode.values())?
You can use iterator.values().stream().filter(BondMode::getValue).findAny().orElse(null); and then return the value.
You can use iterator.values() to do this.
The getter doesn't need to be public in the caller.
The getter doesn't need to be public.
Minor: there's a default method in the map.
Is there a reason to use theActorRef for this?
Is there a reason to keep the order here?
Is there a reason to keep the order here? The list is supposed to be mutable so why not just return a copy of the map?
I'd personally prefer to have this as if(execution.getEventSubscriptions().getAttribute(subscription)) { subscription.getEventSubscriptions().getAttribute(subscription); } which is more readable.
I'd personally prefer to have this as if(execution.getEventSubscriptions().getAttribute(subscription)) { subscription.getEventSubscriptions().getAttribute(subscription); } which is more general.
I'd personally prefer to have this as if(execution.getEventSubscriptions().getAttribute(subscription)) {... } which is more consistent.
Why switch from the if branch of the switch? If we use switch, then we should probably switch on the code
Why switch from the if branch of the switch? If you have a screen reader then the code will be easier to read
Why switch from the if branch of the switch? If we use switch, then we will need switch for the else
It looks like we can get rid of the public API if you are not using it anymore
It looks like we can get rid of the public API
It looks like we can get rid of the public API if you are not using it?
You can use findFirst().orElse(null) to avoid the unnecessary else block
You can use findFirst().orElse(null) to avoid the unnecessary null check
Why not using findFirst().orElse(null)?
extract constant
extract property name for consumerLag
extract constant?
s/public//
Redundant null check.
s/public/unnecessary.
This could use.get() instead of.getSpellA()
This could use.getEntity() instead of.getSpellA()
This isn't wrong, use.get() instead of.get().
You can extract the map.map(BibEntryType::getType) into a local variable to avoid repetition.
You can extract the map.map(BibEntryType::getType) into a local variable.
You don't need to specify the optional because you can use ifPresent()
Is there a reason why you don't use this method?
is there a reason why you don't use this method?
Is there a reason why you don't use the interface here?
Let's use a ConfigDefaulleRule here.
There's no need to mock this. I would use the super.setUp() method.
There's no need to mock this. I would use the super.createRule() here.
times(1) is the same in all tests.
times(1) is the default for verify?
times(1) is the default for the times(1)?
I think this could be merged with my PR on VDSM.removeObserver(this); so that we don't need the if (useDefaultDisplayVsync) check.
I think this should be unregisterDisplayListener
I think this could be merged with my PR on jclouds
Im a little confused. Why are you catching the exception and rethrow it as a second? I think this should be a checked exception.
Im a little confused. Why are you catching any exception and rethrow it as a second? I think this should be a checked exception.
Im a little confused. Why are you catching the exception and rethrow it as a second? I think this should be a runtime exception.
assertThat(isWorkspaceMetacardImpl()).isWorkspaceMetacard() is more readable than assertTrue(isWorkspaceMetacardImpl())
assertThat(isWorkspaceMetacardImpl()).isWorkspaceMetacard() is more readable readable and has the same result.
assertThat(isWorkspaceMetacardImpl()).isWorkspaceMetacard()?
loadTrackers could be accessed directly from setTracker in the constructor instead.
loadTrackers could be accessed directly from setTracker in the constructor, avoiding a load listener
loadTrackers could be accessed directly from setTracker in the constructor, avoiding a load listener in the db.
I would probably drop the tmp variable and just call the tmp variable here.
We should probably check only if the note text is already existing, rather than simply creating it here.
I would probably drop the this.
these should probably be: java @Override protected String getBinaryName(final String binaryName) { return Util.getBinaryName(element); }
these should probably be: if (elements.getBinaryName() == null) { return ""; }
these should probably be: java @Override protected String getBinaryName(final String binaryName) { return.getBinaryName(element); }
Is this the same as this.webview is not used anywhere?
Is this a global default behaviour? If it isn't we should leave it in, it is not necessary to define announcementWebView on this class.
Is this a global default behaviour? If it isn't we should leave it in, it is not necessary to create a new default announcementWebView on this class.
This check is not needed, we do it in the constructor.
This check is not needed.
This check is redundant.
please verify that templateUuid is not null
please verify empty msg. <LINK_0>
please extract to a constant
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
maybe just call this.addUpdateTask(operation, value, "") and remove the overload in BoxMetadataUpdateTask
maybe just call this.addUpdateTask(operation, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need Boolean.
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need a manual null-value checks below.
Can you add these listeners to the CliOption class?
Can you please create these methods with the input to avoid duplication?
Can you please create these methods with the input to avoid duplication of the read options?
I'd go with a private static method called validatePort(String currentPort) that returns a URL, otherwise it will be called twice.
I'd go with a private static method called validatePort(String currentPort) that returns a URL
I'd go with a private static method called validatePort(String currentPort) that returns a URL, otherwise it could be called twice.
The filter is missing here.
The filter should be missing here.
The filter is not needed here.
To be honest: I would prefer to have a DAY_COUNT defined here.
"DAY" -> "DAY"
To be honest: I would prefer to have a DAY_COUNT cached inside a single line
Hm, is this OK to call on Windows? If not, can we use org.junit.Assume.assumeTrue(SystemUtils.IS_OS_WINDOWS)?
Hm, is this OK to call on Windows? If not, can we use org.junit.MICROS for the test?
Hm, is this OK to call on the same line as WINDOWS?
Why are you comparing ints?
I would use diagnoses for the sake of consistency
I'd use diagnoses for the above ones
should be e.printStackTrace(), not System.err
should be e.printStackTrace();
should be e.printStackTrace, not System.err
Remove this line
Remove all these extra brackets
Remove this change
Wouldn't getCurrentDataType be a better name?
Wouldn't getCurrentDataType.getMarketDataType() be a better name?
Wouldn't getCurrentDataType.getMarketDataType().equals(...) be a better name?
Just out of curiosity, when the slots are empty, the correct one is 1. Did you mean > 0 instead of < 0? It seems like this is only the first slot index.
Just out of curiosity, when the slots are empty, the correct one is 1. Did you mean > 0 instead of 1.
Did you mean to say "Slot 0"?
What do you think about introducing a new method in the interface?
What do you think about introducing a new method e.g. updateAgentRuntime(task, jobIdentifier, agent, jobIdentifier, agent);
What do you think about introducing a new method e.g. updateAgentRuntime(task, jobIdentifier, agent, jobIdentifier, agent)?
I do not like this. Isn't there a better way to do this? File f = new File(repo.getDirectory(), url).getAbsolutePath()? url : null;
File.separator
File
here you should use the same code as in SW360Exception, so here you don't have to create a new ReleaseHelper instance
here you should use the same code as in SW360Exception callback.
here you don't need the last line.
Pull this into a static final variable
Pull this up into a static final variable
Pull this up into the static final variable
Do we need to guard against a URI containing a URL?
Do we need the following? request.getPathPrefix()?
Do we need the following? URL.toString()= 1: return baseURI;
Does this mean that the path is absolute?
Not sure if we want to include this.
Why?
May be rename variable to maxOptionOptionByVersion
May be rename variable?
May be rename variable to maxOptionInVersion
this should be in the doPopulate() not in deprecatedPopulate()
this should be in the vm as well, not only when required
this should be done in the mapper, not in the backend, right?
Looks like conditions are repeated here. Could we refactor it?
Looks like conditions are repeated here. Could we refactor it to be more readable?
@smanstis I know your opinion, but please, fix indent of code
Shouldn't this be >?
Shouldn't this be >protected?
Shouldn't this be warn?
Use ChargeDTO in return responseEntity instead of?
Use ChargeDTO.INVALID_TYPE_FAILED in this case
Use ChargeDTO.INVALID_TYPE_FAILED in this case.
Could you please remove the Assumption.assertNotNull check?
Could you please remove the Assumption.assertNotNull
Please remove the following line.
Is this append operation redundant?
Is this append needed here?
Is this append needed?
Why not use tree.is(Tree.Kind.CLASS)?
why not use tree.is(Tree.Kind.CLASS)?
why not use tree.is(Tree.Kind.CLASS_DEF)?
Use entrySet instead of a map.
Use entrySet() instead of a map.
Use entrySet instead of getJsonViews()
VariantType.MNV can be extended to make it clearer
VariantType.MNV can be extended to make it easier to read.
VariantType.MNV can be extended to make it easier to read
It's bad for me to figure out what the thread has been created when you call prepare(). Maybe it is called after the thread has been interrupted?
It's confusing to create a new instance of Sleep and [this](<LINK_0> in load(). Maybe it would be better to have a static class in the same class?
It's confusing to create a new instance of Sleep and [this](<LINK_0> in load(). Maybe it would be better to have a member variable for the thread name.
You can use TestConstants.DEFAULT_FWIDTH999999 etc.
You can use TestConstants.DEFAULT_FWIDTH999999 etc. The reason is that you can use TestRoot.test() or TestRoot.
You can use TestConstants.DEFAULT_FWIDTH999999
I think this should be a recordAwareNRecord.
I think this should be a recordAwareNRecord now.
I think it should be a record here.
I think you should generalize this code a bit, too.
I think you should do this, in onResume()
useless
return ansiSupported && ansiSupported;
return ansiSupported && ansiSupported
Awesome!
I know this is nitpicking, but perhaps the message in the exception message could be better?
I know this is nitpicking, but perhaps the message in the exception message should be something like "ReleaseId was not found in container kieContainer." or similar.
I know this is nitpicking, but perhaps the message in the exception message should be something like "ReleaseId was not found in specfied kieContainer."?
same here
rename to deltas
same, rename to deltas
This can be: java bind(Glacier.class).toInstance(Glacier.class);
This can be: java bind(Glacier.class).toInstance(ConsistencyModel.class);
This can be: java bind(Glacier.class);
You should change the error message here to be about AWS rather than GCR.
You should change the error message here.
You can change the signature of this method to be consistent with other RegistryAuth* bindings.
this is the only place to catch throwable. If there is something wrong with the reader, we should be able to throw exception.
this is the only place to catch Exception.
use try-with-resources?
I'd rather flip the comparison to if (newText.length() == 9) if (newText.length() == 9) {
I'd rather flip the comparison to if (newText.length() == 9) if (newText.length() == 1) {
I would rather check whether the newText is null and not every part of the text.
I think these 2 statements should be DbCacheManager cacheManager::getCacheManager(...).
I think these 2 statements should be DbCacheManager cacheManager::getCacheManager().
I think these 2 lines should be 1.
I wonder if it would be better to let the consumer know what the message is?
I wonder if it would be better to have a static method in sendMessage and use that?
I wonder if it would be better to have a static method in sendMessage and use that in the RequestProcessor
If the anonymous context is provided, we could call new permitAll()
If the anonymous context is provided, we could call new permitAll for '/username' endpoint.
If the anonymous context is provided, we shouldn't allow calling request.
nit: We could do the same by using JodaUtils.sanitizerUrl(version)
nit: we could do away with the static method and return an empty string to avoid the risk of throwing an exception.
nit: We probably should avoid throwing an exception and return a constant.
shouldn't it be assertQueryIsFrom()?
shouldn't it be assertQuery("SELECT 1", 2, 3)?
shouldn't it be assertQuery("SELECT 1", 2, 3 and 4)
Don't use printStackTrace() here, instead of printing the stack trace.
Don't both catch Exception and rethrow it (also below)
Don't use printStackTrace() here, wrap the exception in a RuntimeException.
Consider using apolloEnabled property to see if the value is null or not.
Consider using apolloEnabled property instead of apolloEnabled.equalsIgnoreCase("true")
could these be simplified to just apolloEnabled = true?
you could use getParameters().getDestinationVdsId() instead of calling it twice
you could use getParameters().getDestinationVdsId() instead of the id, i.e.: @Override protected void setActionMessageParameters() { getParameters().getDestinationVdsId() }
You can use getParameters().getDestinationVdsId() instead of calling it twice
Should be getX().getPreviousNodesCount() - wrapper.getPreviousNodesCount()
Should go into the previous line
Should be getX().getPreviousNodesCount() - refactor to make this clearer
I see what you are trying to register before using the service to register the services. Can you add in an Activity context as well?
I see what you are trying to register before using the service to register the services. Can you add in an Activity context?
I see what you are trying to register before using the service to register the service.
Why not just use memberId == null?
Why not just use the groupInstanceId in the constructors?
Why not just use memberId, since you have already used in some constructors?
If the sync file isn't set, this method will throw an NPE. Objects.requireNonNull(type, "type");
If the sync file isn't set, this method will throw an IllegalArgumentException if it doesn't exist. I'd say that it should be public.
As discussed offline, I would throw an IllegalArgumentException if the type is null.
This is kinda a smell in the code, as we already wait in the page object? A method that should be extended to wait in the page object.
This is kinda a code smell, as we already wait in the page object at the end.
This is kinda a smell in the code, as we already wait in the page object at the end. I suggest to extract or a method or method or something.
Could just make lambdas here since LOC is relatively rare
Could just make lambdas here since LOC is actually used
Could just make lambdas here since LOC is a nested if (!true)
/translation//
.toString() is not needed.
.toString() is not needed here
We probably should explicitly mention that this is the way we are trying to do.
We probably should explicitly mention that this is the first language param.
We probably should explicitly mention that this is the way we are trying to exit.
This test is wrong, it should be SWTBotTree.DEFAULT_TABLE_NAME
Could we have a test that confirms the case where the table is active and the visibility is different?
This test is wrong, it should be SWTBotTree.DEFAULT_TABLE_NAME.
can use smallestReadPoint.
can we use smallestReadPoint.
can you use smallestReadPoint.
Typo: Unable
Typo: : Unable
Typo!
anyRequestConfigured -> "Can't configure anyRequest after itself:.anyRequestConfigured = "Can't configure anyRequest after itself"
anyRequestConfigured -> "Can't configure anyRequest after itself:.anyRequestConfigured = "Can't configure anyRequest after itself"); It will be more efficient.
anyRequestConfigured -> "Can't configure anyRequest after itself"
Does this need to be a constant?
Let's use TimeUnit.MILLISECONDS.toSeconds(TEXT) here?
Let's use a constant for that.
Wouldn't it be better to do Long.valueOf(actual.longValue())?
Wouldn't it be better to do Long.valueOf(actual)?
Wouldn't it be better to do Long.valueOf(actual).longValue() instead?
If you need to specify the text here, you can use 'Illusion' instead of hardcoding 'Illusion' as its id.
If you need to specify the text here, you can use 'Illusion' instead of 'Illusion' as its id.
If you need to specify the text here, you can use 'Illusion' instead of hardcoding 'Illusion' as its argument.
hell no
hell not 2 times
hell not sure
Can you use the class name here? It will be much better to have the pool id or name.
Can you use the class name here? It will be much easier to have the pool id or name.
Can you use the class name here?
shouldn't you convert the logType.getAuditLogTypeValue() to millis?
shouldn't you convert the logType.getAuditLogType().get... into a dedicated method?
shouldn't you convert the logType.getAuditLogType().getAuditLogType().get...?
Check the env variable before returning true.
This should check the environment variable before returning true.
Check for the env variable before returning true.
Can we have a method in SpiTransactionManager like the DownTransactionError? This would be a cleaner way?
Can we have a better name for this?
Can we have a better name for this method?
Do you have a test that peeks the next sequence number?
Do you need a test that peeks the next sequence number?
Do you have test that the number of events were actually returned?
either make this method private or use a Set<TestInfo> TIME_UNIT_FOR_DIRECT_UNIT_FOR_DIRECT_UNIT_FOR_AUTH = ImmutableList.of((float) TIME_UNIT_FOR_DIRECT_UNIT_FOR_AUTH))
either make this method private or use a Set<TestInfo> TIME_UNIT_FOR_DIRECT_UNIT_FOR_DIRECT_UNIT_FOR_AUTH = ImmutableList.of((float) TIME_UNIT_FOR_DIRECT_UNIT_FOR_AUTH) ); or make TestInfoPriorisation a one-liner that should have mentioned above
either make this method private or use a Set<TestInfo> TIME_UNIT_FOR_DIRECT_UNIT_FOR_DIRECT_UNIT_FOR_AUTH = ImmutableList.of((float) TIME_UNIT_FOR_DIRECT_UNIT_FOR_AUTH) ); or make TestInfoPriorisation a one-liner that should be used in the PR.
Can be simplified by: java return getArrayUtils(String.isNullOrEmpty(value))
Can be simplified by: java return isEmpty(value) || cs.get(css);
Can be simplified by: java return isEmpty(value) || cs.isEmpty(css);
I think the logic here should be "isPartOfBond". It should be consistent with the used name in the 'bondsToRemove.addAll' but is obscured by the name of the bond.
I think the logic here should be "isPartOfBond". It should be consistent with the used name in the 'bondsToRemove.addAll' but is obscured by the name of the method.
I think the logic here should be "isPartOfBond". It should be consistent with the used name in the 'bondsToRemove.addAll'.
Should we add logging for exiting the executor?
Should we add logging to indicate successful executor for flow only?
Should we add logging to indicate successful executor for flow only
This can be simplified to java if (instant == null) { return new SimpleDateFormat(instant); } else { return df.toString(); }
This can be simplified with java return new SimpleDateFormat(instant);
This can be static.
We don't need to keep this method since we're not using it in the service.
We don't need to keep this method since we're not using it anywhere else.
We don't need to keep this method since it's used for anything else.
Since this is a public API, I don't think we need to have the absoluteUris in the current InitData. But in that case, we could just do the following: initializeData -> initData.isCached(absoluteUri, InitData.canBeCached(absoluteUri()));
Since this is a public API, I don't think we need to have the absoluteUris in the current InitData. But in that case, we could just do the following: initializeData.isCached(absoluteUri, InitData.canBeCached(absoluteUri(), InitData.PREFIX) + initData.isCached(absoluteUri(), InitData.canBeCached(absoluteUri()));
Since this is a public API, I don't think we need to have the absoluteUris in the current InitData. But in that case, we could just do the following: initializeData.isCached(absoluteUri, InitData.canBeCached(absoluteUri()));
I suggest dropping this catch, but switching to Optional.empty() makes it look like this: if (clientDnd == null) { return false; } if (!clientDndExpires.isEmpty()) { return true; }
I suggest dropping this catch, but switching to Optional.empty() makes it look like this: if (clientDnd!= null) { return false; } if (!clientDndExpires.isEmpty()) { return true; }
I suggest dropping this catch, but switching to Optional.empty() makes it look like this: if (!clientDndExpires.isEmpty()) return null;
I don't think we need this class. TranslatorUtils
I don't think we need this line. TranslatorUtils.toIterable() should do the work
lambda
Should this be 'public static'? Because there is no test for this method.
Should this be 'public static'?
Should this be 'false'?
hashCode and equals are inconsistent here.
Should use the same hashCode here.
should use the same hashCode here as well
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 118-119. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90 and 118-119. Do the same for the others.
Can we use java.util.Objects.equals? Also possibly an intrinsic in JDK9.
Can we use java.util.Objects.equals or equals? Also possibly an intrinsic in JDK9.
Can we use java.util.Objects.equals() to be consistent with the rest of the code?
Why do we not throw an exception in the constructor if we are not parsing an exception?
Why do we not throw an exception here instead of returning null?
Why do we not throw an exception in the constructor if we are not parsing an integer?
Prefer new LazyValue<>(preserveHeadersCase) instead.
Suggest new LazyValue<>(preserveHeadersCase) instead.
Suggest new LazyValue<>(preserveHeadersCase)
Can rename the variable name to CloudConfig
Can rename the method name
Can rename the variable name to 'other'
Is it possible to suspend the node before invoking suspend()? I don't think it's necessary to suspend the FBO before it can be stopped.
Is it possible to suspend the node before invoking suspend()? I'm not sure what it does, but it's better to make it a "public static"
Why does it need to be synchronized?
result is a list - precisibility.
result is double
result is always null
Don't we want to keep this deprecated, create a new one if required?
Don't we want to keep this _only_ be consistent as well?
Don't we want to keep this deprecated, create a new one if required above?
I'd just use row.get() here instead of row.get()
I'd just use row.get() here instead of 'get'.
I'd just use row.get() here instead of 'get'
Is there a reason for this change?
Can you change this to just "http|https|https|https://"?
Can you make this a static variable?
I think this could be a bit simpler: java private void dmnContext(Context context) { DMNContext dmnContext = registryContext.get(name); if (config.getContext()!= null) { DMNContext dmnContext = registryContext.get(name); dmnContext.set(name); } }
I think we could avoid the DMNContext dmnContext.set(name) method by using: java dmnContext dmnContext = registryContext.get(name); if ( registryContext.supports(name)) { dmnContext.set(name); } else { DMNContext dmnContext = registryContext.get(name); dmnContext.set(name); }
I think we could avoid the DMNContext dmnContext.set(name) method by using: java dmnContext dmnContext = registryContext.get(name); dmnContext.set(name);
I don't think you test the case where the undefined dataModelAttribute could be null. It looks like your tests are failing because the null-check is wrong.
I don't think this line is necessary because even if the your fix is wrong, it will be anyway dependent on the exception.
I don't think you test the case where the undefined dataModelAttribute could be null.
Can be simplified here.
Can be simplified in TreasureChestItemIterator to use a concrete class.
Can be simplified in TreasureChestItemIterator.
This is a main test. Could we maybe have a unit test for this subfolder? suggestion Keras -> GenericTypes. The classpath would have to turn this output into a reference.
This is a main test. Could we maybe have a unit test for this subfolder? suggestion Keras -> GenericTypes. The classpath would have to turn this output into a unit test.
This is a lot of code. Could we maybe have a unit test for this subfolder? suggestion Keras -> GenericTypes. The classpath would have to turn this output into a unit test.
minor: use parameterized logging java logger.info("Unvoid remove from StatsManager: {}", entry);
minor: use parameterized logging java logger.info("Blob {} is removed from Stats {}, is removed from PartitionId", id);
minor: use parameterized logging
if close is called twice (see line 96)
if close is called on another thread, then there is a potential race condition here.
if close is called on another thread, then there is a chance it will be null
Why are we setting the same attribute twice?
Why do we need to override the set?
Same here, we don't need else
I think it's better to do this in a provision method. This listener isn't responsible for provisioning listeners, ideally it's already registered in the provision method. Otherwise do we only want to do it in one place as well?
I think it's better to do this in a provision method. This listener isn't responsible for provisioning listeners, ideally it's already registered in the provision method. Otherwise do we only want to do it in one place?
I think it's better to do this in a provision method. This listener isn't responsible for provisioning listeners. It may be better to eagerly handle all listeners in the createees method, or at least at the create-in case of provision result.
if the DTO has no columns in the given row, we should return the short description, am I missing?
if the variables are all the same, return null instead of void.
if the DTO has no columns in the given row, we should return the short description of the transaction
We don't log the exception in the other log statements. I also don't think there's a need to log the exception here.
We don't need to log the exception in the other log statements.
We don't need to log and throw there.
System.out is no longer needed.
System.out again?
System.out again....
If you need to go only to the end of this method, it will probably be left there.
If you need to go ahead and call it in a finally block there is no need to unlock the first one.
If you need to go ahead and call it in a finally block there will still be a chance of an exception.
Why aren't you using 'this' immutable?
Why aren't you using 'bufferList'?
Why are you using 'this'?
final
final?
Maybe we should extract this to a constant?
I am unsure about this one. Will DLNAThumbnailInputStream.toThumbnailInputStream still get what it wants after this change?
I am unsure about this one. Will DLNAThumbnailInputStream.isUrl not get what it wants after this change?
I am unsure about this one. Will DLNAThumbnailInputStream still get what it wants after this change?
is this method really necessary? it's own test method so it doesn't just use the first one?
is this method really necessary? it's own test method so it doesn't just use the first one.
is this method really necessary? it's own test method so it doesn't really matter if it's doing anything
use reflection, for private
use reflection to remove this
static import
Would not this be always true?
Would we add @HiveConfLocal to the HiveConfLocalConfig constructor as well?
Would we add @HiveConfLocal to the HiveConfLocalConfig constructor?
I think this can be inlined.
Call this.clear() as well.
I think this can be written as: add().add()
This seems like a side effect, i would suggest splitting it of to a separate method/service if needed at all.
this seems like a side effect, i would suggest splitting it of to a separate method/service if needed at all.
Formatting seems off, this would be hard to read
This should be a Logger.error or propagate it to the exception.
This should be a Logger.error(message, e);
This should be a Logger.error(message, e);.
You can use jQueryHelper.getFieldValue(selector); here
Why not use return type == String.class?
You can use method reference here
The last condition is inverted here to avoid unnecessary!TextUtils.isEmpty(mPluginStore.getSlug()
The last condition is unnecessary here, we already check for isFinishing() first.
The last condition is unnecessary here, we already check for isFinishing() before fetching the event.
can you use if-else instead?
can we use the boolean as mentioned above?
can we use the boolean directly?
final
final / on a setter
final <?>
Missing space before "String"
String.toLowerCase(rec.charAt(0));
toLowerCase
In the lifecycle of an activity this would cause a lot of memory leak. You can probably move it to a static method or use an instance variable to the class field.
In the lifecycle of an activity this would cause a lot of memory leak. You can probably move it to a static method in class or use an instance variable to access the fragment.
In the case of an exception, you can just map the map (which is a duplicate of the code).
shouldn't it be 'equals'?
seems like you can remove the 'else'
can be shorter by using stream
I suggest using 10000000 as a timeout for a timeout. Is there a reason you don't use a timeout?
I suggest using 10000000 as a timeout. Is there a reason you don't use a timeout for /etc/constant?
I suggest using 10000000 as a timeout for a timeout. Is there a reason you don't use a custom timeout?
Please replace with dbFacade.loadDbFacade() which is called by other places in this class.
Please replace with dbFacade.loadDbFacade() which is called by DbFacade.loadDbFacade()
Please replace with checkArgument() statements.
can be simplified by stream().map(r -> r.getKey())
can be simplified to stream().map(r -> r.getValue())
lhs -> r
Do we want to treat this as a cancel as well?
Do we want to treat this as a transport exception as a cancel?
Do we want to treat this as a cancel as opposed to being cancel?
This is not thread safe. In the previous code, we may fail to use the isEmpty() condition when it is false.
This is not thread safe. In the previous code, we may fail to use the isEmpty method instead.
This is not the same as it used on [templateOptions](<LINK_0>, so it may be safe to use the copy instead?
nit: put this into a constant (e.g. startPos) or or some such)
nit: put this into a constant (e.g. startPos) or something like that would make it easier to read and compile the valid linkify.
nit: remove this space before (
we need to make the mVariableNames synchronized
I think we need to make the mVariableNames synchronized
we need to make sure the producer is logged in stdout level code.
This can be reduced to a single line suggestion return properties.get(supportedProperty).contains(supportedProperty);
Just return "Supported convention property: {} found: {}", supportedProperty, prop,
Just return prop;
I think that in this case any reason not to use String.format() instead of concatenation?
I think that "http://" should be a constant, so it can be reused more easily.
I think that in this case any reason not to use String.format()?
Nitpicking: do you mind to use node.set(field, value); here, too?
Nitpicking: do you mind to use the same naming here for other node implementations?
Nitpicking: do you mind to use the same naming here for other node types?
replace with this method.
combine line?
combine line
can this be changed to schema.getFieldNames(fieldNames)
can this be changed to schema.getFieldNames(fieldNames);
can this be changed to schemas.getFieldNames(fieldNames)
Wrong method name in the error message.
Wrong class name in the error message.
Wrong error message.
should we call telephonyRegistryManager only once so this is more efficient?
should we call telephonyRegistryManager only once
now you can use telephonyRegistryManager
you can use the return type here.
return MongoFeedStatisticsStore.build()?
return MongoFeedStatistics?
why is this not using the constant?
why is this needed?
why is this not using the custom severity?
As this should be removed
As long as we are at it maybe better to use an else here
As this should be before the if, it does not need to be here
Style inconsistency: space after if
Please fix the formatting here. It was there but there is no reason for the space after if
Please fix the formatting here. It was there but there is no space after if
I'd suggest to move this out of the for loop
I'd suggest to make this a constant.
I'd suggest to move this out of the for loop.
You should remove the else after a return statement.
You should remove this if block all over the place.
You should remove the else clause: final IndentLevel result = new IndentLevel(getMainAst());
Should we have a better name for the schema?
Should we have a catalog name for the name of the schema?
Should we have a catalog name that would be helpful to understand?
I think we should change the method name the same as "Configured Jasypt".
I think we should change this to a constant (e.g. "Configured JasyptAuth");.
I think we should change the method name the same as in the Log.ept algorithm.
You can put a new FileAudioException(key, fileName, sink) here.
You can put a new FileAudioException(key, defaultValue) here.
You can put a new FileAudioException(key, fileName, sink) in here.
Can you use the constants in the mkdirs?
Can we use the constants in directory and this on one line?
Can we use the constants here?
We should be using List<IProposalProvider> proposalProviders = Collections.emptyList();
Not sure why we need to start with a list here.
We should be using List<IProposalProvider> proposalProviders = proposalProviders.getAllProviders();
same here, we don't need to have both KafkaLogAppender and KafkaLogAppender
same here, we don't need to have a hard coded KafkaLogAppender here. We can just set the message here.
same here, we don't need to have a getter for each message
You can write this as: java assertTrue(viewNameMethod.invoke(viewNameMethod.invoke(viewNameMethod.invoke));
You can write this as: java assertTrue(viewNameMethod.invoke(viewName, "Browse_items_name", "file:///file/"), getViewName);
You can write this as: @Browse_items
M-m-m. I'd expect this to return null, not NPE, right?
Why not 'null'?
Why not instanceOf?
I think we should deprecate this and keep the old method as it was before.
I wonder why we need to keep this and it must be done BEFORE rc? I think in general, we should always do it for session listener.
I wonder why we need to keep this and it must be done BEFORE rc? I think in general, we should always do it for sessionListener.
So was it possible to use a constant for the delimiter name? I think escaping can be used for encoding when creating JSON
So was it possible to use a constant for the delimiter name? I think escaping can be used for encoding if the delimiter is not defined.
So was it possible to use a constant for the delimiter name? I think escaping can be used for encoding if the delimiter is not present.
same here, we can use Objects.hash(...)
Evil.
Evil
should be equal to other.equals(other)
should be equal to other.equals(Object)
should use Objects.equals(this, other)
Why use getProject() and not getRepository()?
Why?
Why use getRepository() instead of getName()?
Yes, that's the best place to put it.
Should this be an ObjectId?
Should this be continue?
Please don't add this. You can use Collections.emptyList()
Please extract this block as a separate method.
Please add this to the logger and not do it in one place.
Lines 34-36 can be extracted into StageConfigDetails
Lines 34-36 can be merged into one line
Lines 34-36 can be merged into one if statement
Can we use empty string as in the field declaration?
Can we use empty string instead of the empty string?
Can we use empty string as the parameter to avoid the wrapping?
I would say that we should always reset the time after this method is called.
I don't understand why you need the synchronized here.
I would suggest you mark this method as volatile and put it into the field directly
I'm not sure this method should be called only for image disks... Also, what if getImage().getDiskStorageType() == DiskStorageType.IMAGE? true : false?
I'm not sure this method should be called only for image disks... Also, what if getImage().getDiskStorageType() == DiskStorageType.IMAGE?
I'm not sure this method should be called only when the disk is created, no?
toString() is redundant here.
Missing a space between ) and {.
toString() is redundant, since you are using string concatenation.
Is there a better way to throw a Exception here?
Is there a way to throw a Exception here?
Why throw the exception here?
throw new SamzaException("key " + key); would be better
throw new SamzaException() if you're going to handle this exception
throw new SamzaException();
I think this should be: super(name, Hierarchy hierarchy)
Is this a param?
I think this can be package-private as well.
It should be fixed in a different PR for this.
It should be fixed in Keycloak.java for consistency with other modules (container in this file)
It should be fixed in KeycloakSessionTest.java for consistency.
move this into its own method
move this into startRequest method
move this to startRequest() method
Same as above regarding the method. No need to set the to true.
Same as above regarding the method. No need to set to true again.
Same as above regarding the method. You don't need to set the to true. Just set the next parameter and then return as the if
Can this be private or at least package private?
Can this be package private or is there a reason we can't instantiate this with the factory?
Can this be private or at least package protected?
Please use BL layer to get destination and facilities.
You should check also VOOBSERVER and not return all facilities.
You should check also VOOBSERVER.
I don't think we need to catch this exception if we don't throw.
I don't think we need to catch this exception if we don't throw. We can remove catch clause and add a runtime exception to the DB.
I don't think we need to catch this exception if it's not defined.
java doc please:
I think this change is not related to this PR.
java doc
no need to use the full package path
you don't want to use the full path here. Use the full path
no need to create a separate array for size
I don't think we can guarantee that the value will be null.
Please use <code>value.toUpperCase()</code> here.
Please use <code>value.toUpperCase()</code> here
pass reportedConfigurations as an argument
pass reportedConfigurations as an argument?
rename this to reportedConfigurations
Shown on the end of the test so it is not necessary to put it in an static method.
Shown on the end of the test so it is not necessary to put it in the test class.
See for the test.
Can't we use the getInteger() method?
Can't we have only one getInteger() method?
Can't we have this variable is redundant?
missing this.
endkey is never used.
end
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "UTF_8" here for consistency. [![rule](<LINK_1>](<LINK_2>
Consider removing the return type from the method signature.
Why this line is removed?
Why the cast to Optional?
Why the cast?
This doesn't seem to be used.
This doesn't seem to be necessary, I'd prefer this to be a constructor.
This doesn't seem to be necessary, I'm not sure why we need this.
Do we think that oversizedMediaWarning is enough?
Do we think that oversizedMediaWarning is enough? As on purpose, I think it would be a good idea to just overwrite the warn so we don't get too picky about what the actual file size is.
Do we think that oversizedMediaWarning is enough? As on purpose, I think it would be a good idea to just overwrite the warn so we don't get too pick up the same message.
Maybe max here is too big?
Maybe max here is too large?
Maybe max is too small so we can put the max here?
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this use of "PluginConfigurationImpl" by "Loading". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this use of "info. [![rule](<LINK_1>](<LINK_2>
suggestion log.info("Loading plugins to load plugin configuration for plugins to load plugin configuration", pluginConfiguration);
This is not used.
This is used in cancelOperation() right?
This is used in the lock.
This method always returns null. I'd add a null check to return, just in case: String defaultApp = getAut(); if(defaultApp == null) { return defaultApp; } return defaultApp;
This method always returns null. I'd add a null check to return, just in case: String defaultApp = get(); if(defaultApp == null) { return defaultApp; } return defaultApp;
This method always returns null. I'd add a null check to return, just in case: String defaultApp = getAut(); if(defaultApp == null) { defaultApp = getDefaultApp(); } return defaultApp;
parent.toString() will be null
parent.getTime()?
parent.getTime()
@pynicolas It is never used in the remainder of the code block.
@jfanifieiev please use Objects.equals(techName) instead of creating an additional variable.
@jfanifieiev please use Objects.equals(techName) instead of creating a variable for this.
Should null be added to the styles file?
Should the null case be added to the styles interface?
Should the null case be added to the styles file?
Why do you use a constant for "HTTP" and 0 if it's not going to be used? Im not sure what the value is for.
Why do you use a constant for "HTTP" and 0 if it's not going to be used? I'm not sure what the value is for.
Why do you use a constant for "HTTP" and 0 if it's not going to be used? I'm surprised two different values are constant strings.
Why is this line needed? It is always false.
Why is this line needed?
Why is this line needed? It is always true.
I don't understand why this is necessary here
Here you can use orElseThrow
Here you can use orElseThrow.
can be removed
can be inlined
needs to be 1
@xupyprmv wouldn't it be better to store a real result of the above line in a constructor?
@xupyprmv wouldn't it be better to store a real result of an object here?
@xupyprmv wouldn't it be better to store a real result of the above line in a utility method?
ITmfStateSystemBuilder.this.checkAttribute(event.getTimestamp()).getValue() here
ITmfStateSystemBuilder.this.checkAttribute(event.getTimestamp())
ITmfTrace is the same from this method below, but you could have a different string for the state system and call directly.
Shouldn't we check the waiter timeout here (queueMaxSize)?
What is the waiter bound bound? "_task" is "_ waiter.".
What is the waiter bound bound? "_task" is "taskTimeout".
"This call can be done with an empty statement on the right line.
"This call can be done with an empty line before."
"This call can be replaced by.map(expr -> expr.getClass())"
How about this.data = data.data;
I suspect this isn't necessary, because MockGameData should not be used.
I suspect this isn't necessary, because MockGameData is the default data.
Do we have to increase our batch?
Is this meant to be a container?
Is this type of mistake?
nit: No need to print out organizationDiscoveryIntervalMillis.
nit: No need for log.error inside the method.
nit: No need for log.error below.
Could you please change this to something like sslFactory.createSSLContext(sslFactory, sslEchoServer); to avoid the need for this test.
Could you please change this to something like sslFactory.createSSLContext(sslFactory, sslEchoServer); to avoid a NPE?
Could you please change this to something like sslFactory.createSSLContext(sslFactory, sslEchoServer); to avoid the need for this test?
why not use r0? this will be a failure
why not use r0? this should be a failure and not a failure
why not use r0? this will be a data structure
log the exception?
log the error?
log the exception
Could you please make this constructor private and call the other constructor with appropriate parameters?
Could you please make this constructor private?
Could you make this constructor private?
You should add comma.rtf it here, since there is a possible case when we have to do the same thing.
You should add comma.rtf it here, since there is a difference in both tables set to FETCH_COUNT.
You should add comma.rtf it here, since there is a possible case when we have to do it in a row (partrtf it to a set).
should return t;
should return "public" or "public"
should return t; here, though.
I would delegate to the new method directly
This method should delegate to the new method, no?
This method should delegate to the new method which does this already.
Is this needed? You can do just stripe.add(stripe);
Is this needed? You can do just stripe.add(stripe)
nit: you can simplify this (same for the following constructor).
There is no need to catch Exception since RuntimeException is checked inside of Rule
There is no need to catch all exceptions in a RuntimeException, it is unnecessary to throw a runtime exception if there is no index.
There is no need to catch all exceptions in a RuntimeException, it is unnecessary to throw a runtime exception if there is no match.
please remove the Objects.equals()
please remove final
please remove
can we use the generics java Map<SimpleInterval, Integer> entries = new HashMap<>();
can we use the generics java Map<SimpleInterval, Integer> entry = new HashMap<>();
Where is the [SimpleIntervalToIndexMap](<LINK_0> unused?
This should be a RuntimeException
This should probably be a RuntimeException
This should be a Visitor
See ByteByReference.java
See ByteByReference#toString
See ByteByReference.Object
value.matches() should also take into account the case where valuePattern is a regex, right?
value.matches() should also take into account the case not found case.
value.matches() should also check for null.
Can we use a for loop here?
Can be replaced with a for loop here.
Can be replaced with a for-loop here
why is this a public method?
why is this a public API?
this could be a constant
It seems that an indexInMemory is not a Boolean, so can be missing here?
It seems that if an indexInMemory is false, we will get the indexInMemory flag anyways right?
It seems that any time an index file is created, we will have to acquire the lock for both the data and the if
add: import org.ovirt.engine.core.common.utils.Pair;
add: import org.ovirt.engine.core.utils.Pair;
add: import org.apache.commons.lang.Validate;
I don't think you need to keep the new output anymore, because the old XML does it (which is the new way).
I don't think you need both of these, the new new size is the same as the old one
I don't think you need to keep the new output anymore, because the old code uses the new format
ContextCompat.onOpened(screen, () -> screen.onOpened(cell))
ContextCompat.onOpened(screen, () -> screen.onOpened());
ContextCompat.onOpened(screen, V)
Shouldn't we be checking for tenantDomainToEntry and tenantDomainToEntry if possible?
Shouldn't we be checking for isEnableEventToEntry() here?
Shouldn't we be checking for isEnableAddIdP instead of!isEnable in this method?
I'd move these checks to the constructor of PrestoException
I'd move these checks to the constructor of PrestoException.
I think it would be nice to have a utility to load the config, that could be implemented in the resource system.
I think this should also allow something like: java ALLOWED_ANNOTATIONS  annotationType.stream().anyMatch( annotationType.getClass().annotationType().equals( annotationType.getClass().getSimpleName()); //NON-NLS-1
I think this should also allow something like: java ALLOWED_ANNOTATIONS  annotationType.stream().anyMatch( annotationType.getClass().annotationType().equals( annotationType.getClass().getSimpleName()); //NON-NLS-1 if ( annotationToCheck!= null) { return false; } return.anyMatch(annotation -> ignored.getName().equals( annotationType.getClass()));
I think this should also allow something like: java ALLOWED_ANNOTATIONS  annotationType.stream().anyMatch( annotationType.getClass().annotationType().equals( annotationType.getClass().getSimpleName()); //NON-NLS-1 if ( annotationToCheck!= null) { return false; } return.anyMatch(annotation -> ignored.getName().equals( annotationType.getClass())); }
you can use this instead of regex
you can use this instead of regex.
you can use this regex as well
Could you add a check for nextElement!= null?
Shouldn't this check be (nextElement!= null && nextElement!= null)?
Shouldn't this check be (nextElement!= null && nextElement!= null)?
I would log the remote address being set.
IMHO this should be DEBUG logging.
suggestion } else {
In the current patch, the fields are always non-null, so this check can be removed.
override the pipeline when the pipeline is selected,
override the pipeline
space before the {
space before the curly braces.
space before the curly brace.
I assume this method should be private.
I assume this function should be private.
I assume this method should be called after the extensionId is set.
I wonder how we should make this a warn since it is not really a failure.
I wonder how we should make this a warn since it is really noisy.
I wonder how we should make this a warn since it is really expected to be called too?
CHANGE it to TypeConstants.TypeDeclaration
CHANGE it to TypeConstants
CHANGE it to Type
You may want to put that call into the adapter position if it's not null
You may want to put that call into the adapter class, so that it's clear which one is doing.
SWT.NONE?
You can use the new ParameterHelper.randomStringString(stateData) here.
I think you can use the new ParameterHelper.randomString(stateData) here!
I think you can use the new ParameterHelper.randomString(stateData) here...
Don't need to call to View.process() here, just pass it to the shadowActivity.
Don't need to call to View.process() here, just pass it to the presenter.
Don't need to call to View.process() on the presenter.
Mind fixing the copy and paste error, %n%n
Mind fixing the copy and paste error, %n
Mind fixing the copy and paste error, %d%n
I still don't think we need this patch anymore. You can use the other version formats, and use the HFS version in Version.GLUSTERFS.
I still don't think we need this patch anymore. You can use the other version formats, and use the HFS type from Version.GLUSTERFS.
I still don't think we need this patch anymore.
"googleId" -> "id"
suggestion return new Object[] {id};
suggestion return new Object[] {id}, nameParam
Only one should throw an exception.
Only the first call to throw the exception.
Only the first call to throw a RuntimeException.
I think we should deprecate the backward compatibility and deprecate the backward compatibility. The support for the backward compatibility is about these changes.
I think we should deprecate the backward compatibility and deprecate the backward compatibility. Since we probably need to support these types for the maven version as well.
I think we should use the backward compatibility check as well.
ArrayList should be constructed with fixed capacity.
you don't have to do iterator.next()
You don't have to do iterator.next()
Why not use if ( connection!= null && connection.isOpen() || connection == null) { return false; } else { return currentConnectionIsOpen(); }
Why not use if ( connection!= null && connection.isOpen() || connection!= null) { return false; } else { return currentConnection.isOpen() }
Why not use if ( connection!= null && connection.isOpen() || connection.isOpen())?
Since there are two places using "qe-menu-Resource-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-on- those fix fix.
Since there are two places using "qe-menu-Resource-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu
Since there are two places using "qe-menu-Resource-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data-item-menu-item-menu-data
suggestion: asyncCommand(ReplicableCommand command, boolean sync, rpcManager, command, rpcManager.invokeListRemotedTo(workList, command, false));
suggestion: asyncCommand(ReplicableCommand command, boolean sync, rpcManager, command, rpcManager.invokeListRemotedTo(workList, command, rpcManager.getSyncRpcOptions()),
suggestion: rename to asyncCommand
Points could be a static method on Pixel.
Points could be a static method on the top of this class, no need to go through the array.
Points could be a static method on the top of this class, no need to create the array each time
Better to use org.apache.commons.lang3.StringUtils#isEmpty()
Better to use org.apache.commons.lang3.StringUtils.isEmpty()
Better to use Commons Lang as it works.
extract a constant for "firstmodule"
extract a variable for more clarity
static import
Surely the set of IndexModule should be done in a finally block?
Surely the index should be restored using @AfterClass?
Surely the index should be restored?
Yeah, here's where I was thinking of using the custom exceptions. IdpResponse.fromError(...) to check that the intent is null.
Yeah, here's where I was hoping we could use naked in here. :) Don't we need to define this local variable in the null check?
nit: specify space after (
Why not use @Rule-test-test-test-function?
Why we need to pass the empty ValidationFailure?
Why not use @Rule-test-test-case as the annotation?
This seems a bit unrelated to that.
I think this should be a synchronized method.
@Override
I'd prefer a constant string for the size of the log message so it is clear what we are doing.
I'd prefer a constant string for the size of the log message so we don't repeat that much.
I'd prefer a constant string for the size of the array.
to be immutable.
Please use immutable list.
immutable copy
Is there a reason to use e.printStackTrace() instead of sleeping?
Is there a reason to use e.printStackTrace()?
This should go to a logger.
you should put this in MobileSpecialUserLoginFactory.initElements method
you should again call initElements() method (same as other method below)
you should again call initElements() method (it's called in BaseApi)
Suggest to use StringUtils.defaultString(consoleProxyUrlDomain).append()
Suggest to use StringUtils.defaultString(consoleProxyUrlDomain)
Suggest to use StringUtils.defaultString(consoleProxyUrlDomain).get()
Remove all whitespace.
Remove
Remove?
Do not use this utility method. These methods can be private.
Do we need this? This config is 'this' in the constructor
Do not use this utility method in the constructor
can you please add a helper method for this? this code is repeating itself in all of this patch edited classes.
can you please add a helper method for performing it? this code is repeating itself in all places throughout the patch.
extract to getter
I would prefer to have the nested if statement to make it more readable: java final Object temp = innerMap.get(temp); if (temp!= null) { innerMap.put(JOBS_KEY, innerMap); }
I would prefer to have the nested if statement to make it more readable: java final Object temp = innerMap.get(temp); if (temp!= null) { tempMap.put(JOBS_KEY, innerMap); }
I am not sure this is correct. Why not use java temp.get(temp); instead of this code?
I wonder if we should wrap this entire method in a RuntimeException and re-throw it as a runtime exception. I think this will become visible in our code base.
I think this can be simplified to call JacksonUtils.readEntity(Response.class);
I wonder if we should wrap this entire method in a RuntimeException and re-throw it as a runtime exception.
I am not sure this is the best place to update it.
I am not sure about this change.
I am not sure this is the place where it is used.
return waitInvisibility(By elementLocator, DEFAULT_TIMEOUT);
return timeoutInvisibility(By elementLocator, DEFAULT_TIMEOUT);
returning boolean type is useless here because it can only return **true**.
The SchedulingTopology schedulingStrategy's SchedulingTopology schedulingStrategy by the RepliceStrategy constructor could not be set to SchedulingTopology. It's the responsibility of the SchedulingTopology is that it will create all the children for the SchedulingTopology.
The same here, this does not need to be public.
The SchedulingTopology schedulingStrategy's SchedulingTopology schedulingStrategy by the RepliceStrategy constructor could be considered the best effort. In this case, we would have to add a TODO as for the SchedulingStrategy.
Why not store this in the buildAndTag method?
Why not store this in the buildAndTags method?
Why not store the buildAndTag in the buildAndBuildImage?
Can this be private? It should be accessed by a static method.
Can this be private? It is only used by tests.
Can this method be private? It is only used by tests.
Makes sense to fall through the upload() call below, with a little more neater, but you could also use perform(String filename, String filename) here.
Makes sense to fall through the upload() call.
Makes sense to fall through the upload() call below, may be a bit more concise.
Lets fix the naming. "Unable to move to start because the directory has been initialized."
"Unable to move the...."
"Unable to move the attribute for that matter"
JavaConversions.collection.stream().map(this::equals).collect(Collectors.toList()
Probably this method should be private?
We should return a List here
again, assertion for!= null since you have no way to assert that the :scream:
again, assertion for!= null since you have no way to assert that :scream:
extra line?
If we make this one configurable, could we make this one configurable?
If we make this one configurable, could we make this return an Optional.
If we make this one configurable, could we make this check be explicit?
I might as well use thecontrols instead?
I might as well use thecontrols instead of a local buffer
I might as well set this tocontrols instead?
Minor: There can be multiple segments in this method.
Minor: lost this one.
Minor: exists -> contains()?
This is a bit confusing. Can we say if we can't get a requestEmpty with 0?
This is a bit strange. Can we say if (list == null)
This is a bit too lintense.
should we use this for the return value of the method?
should we use this for the return value of the method? :)
should we use this for the return signature?
check if art is an instanceof art && (AtsUtilCoreException)
check if art is an instanceof art
check if art is an instanceof List
Intellij tells me that these firstEntry!= null is redundant
It might be worth adding a utility method which calls these methods
It might be worth adding a utility method/Api that calls these methods
nit: can you use CompletableFuture.withLedgerEntries()?
nit: can use CompletableFuture.withwithEntries(...)
nit: I don't think you need fully qualified path name
This doesn't have to be public.
This could be omitted.
This could use the package name here.
Use Math.max()
Use Math.min()
Use Math.min() to skip the count
You may also want to call: java Appender.getLoggerName(loggerName, rev, suffix)
You may also want to call: java Appender.getLoggerName(loggerName, rev, suffix);
You may also want to call: java Appender.getLoggerName(loggerName)
This should be part of the decoder
This should be part of the logic as before, otherwise the value is null
This should be part of the logic in the setter
Add requireNonNull for parameters.
Why static import?
Add message to these two lines
Please revert this change. The map is not used anywhere as far as I can see.
Is it safe to do that here? The old code was straightforward to me.
Is it safe to do that here? The map is not used in any case.
I think we should have this constructor as well.
I think we can remove this public.
I think we should have this constructor as protected.
My preference would be to use else if and else branches like: if (condition) { return false; } if (condition) { return true; }
My preference would be to use else if and else branches like: if (condition) { return false; } if (cond) { return true; }
My preference would be to use switch statements like if (condition) { } else if (condition) { }
Why an empty map instead of null?
Same, zks, noNodeException?
Better to use KDatabaseException here?
no need for cast int
no need for cast int and int
what's the cast?
assertNotNull
assertNotNull?
assertEquals
Can we use the same approach here? The restriction has setContent(simulation); it should be fine.
Why do we need to check here if the simulation is in the scenarioGridPanel? It shouldn't be visible on UI thread
Can we use the same approach here? The restriction has setContent(simulation); it should be the same.
I think we should avoid changing the method name to something like EXTENSIONList<String> FormsMigrationConstants.BPMN_EXTENSION
I think we should avoid changing the method name to something like EXTENSIONList<String> FormsMigrationConstants.BPMN_EXTENSION or KEY_EXTENSION_KEY_EXTENSION
I think we should avoid changing the method name to something like EXTENSIONList<String> instead.
nitpick: This could be extracted as well.
nitpick: 0.6f? Might be better to use extracted as a constant.
nitpick: This could be extracted to a static final constant.
This is more like a code duplication, <LINK_0>
The message should be the same here, as in the other examples.
The message should be the same here, as in the other handlers.
I would prefer to rename this to free vars from the definition. Same in other places.
I would prefer to rename this to free vars from the definition. Same in free vars of this method.
I would prefer to rename this to free vars from the definition. Same in free vars of the definition.
Oops to be public.
Just a nit: you can use anyMatch here.
public?
You can use Schema.Type.STRING.
You can use Schema.Type.STRING.equals(type) here.
Better use.equals() instead of ==.
@tumijacob Rather invert this logic and throw if the user is null. We can then remove the else block and indent the remaining code one level less.
@tumijacob Rather invert this logic and throw if the user is an invalid one instead of returning?
@tumijacob Rather invert this logic and throw if the user is an invalid. You can then remove else block and indent the remaining code one level less.
return false please
return true?
return void
Use a null guard here instead
Use a null guard here instead of a null guard.
Use a null guard instead
This may not be needed since you are setting the expected value to null.
This may not be needed since you are setting the auto-generated value
This may not be needed since you are setting the expected value to true in this test.
These assertEquals() calls the expected and actual values are mixed up. In general it's good to keep them as clean as possible.
These assertEquals() calls the expected and actual values are mixed up. In general it's good to keep them as possible, so in terms of the values and the other assertEquals() calls the expected.
These assertEquals() calls the expected and actual values are mixed up. In general it's good to keep them as consistent with the other parameters.
I think we should use circuitBreaker.getName() and circuitBreaker.getName() instead of the single name.
I think we should use circuitBreaker.getName() and circuitBreaker.getName() instead of the name.equalsIgnoreCase
I think we should use circuitBreaker.getName() instead of circuitBreaker.getName()
No need for this.
No need for this. here?
:+1: I'd prefer this.
I was thinking what you mean by this line: return table.putAsync(ignored, message, Result.emptyMap(), message.getValue());
Typo: 'ignored' is optional.
Why make this method final?
I'd do a getStringsFromJSONArray() instead.
I'd do a newArrayList on the list.
I'd do a newArrayList() here.
we should get rid of logging in this case
we should get rid of this string
we should get rid of logging for this.
You don't need the filter method of this.
SecurityException?
You don't need the explicit replacement of this.
use 'final' for this method.
use 'this' instead of this line.
use 'this' instead of the string type.
This is an unexpected exception.
This exception is swallowed. See line 135.
This is an anti-pattern that we are using [String#](<LINK_0>
"hey" there's no space here.
"hey" instead of "!
typo
Is this line necessary?
Is this line correct?
is this line correct?
Can you rename this to warningsSeen ->...
Can you rename this to container?
Can you rename warningsSeen -> emptyIfNull()
You could use!nulls.isPresent() &&...
You could use!isEmpty here.
You could use!isEmpty instead.
Remove sysout.
Use logger instead of System.out
Use logging framework instead of System.out
instead of new GoraException() you can remove this and just add the class of DataStoreFactoryType
instead of new GoraException() you can remove this and just add the new boolean flag that toggled between DataStore.createDataStore() and DataStoreFactoryStores
Use DataStoreFactoryType
Add a message to the exception.
Can we add a message to the exception.
Add a message to the exception
We have the dialog already defined the text element. This is not the case to search the registry. What if the color is configured?
This is a constant symbol.
We have the dialog that has the style provided by the shell. This is more.
Can we extract to isInRestored?
Can we extract this into a method to make it easier to read?
Can we extract this into a little more readable to clarify the previous two?
We should probably catch the RuntimeException here too.
We should just catch and ignore exceptions here.
Should this if statement be removed?
I'd like to see more a way of splitting this method into two methods - one for early return and one for the both cases
I'd like to see more a way of splitting this method into two methods - one for early return and one for the both
I'd like to see more a way of splitting this method into two methods, one for early return and one for the both cases
This should not be changed (the set of scene was the same as currentScene is updated directly). I think you should return the old Scene instead of null.
This should not be changed (the set of scene was the same as currentScene is updated directly). I think you can just return the old Scene instead of null.
This should not be changed (the set of scene was the same as currentScene is updated directly). I think you can use <code>return getCurrentScene</code>.
No need to initialize current implementation here. We try to avoid current implementation if PMD will complain about it.
No need to initialize current implementation here. We try to avoid current implementation if PMD is disabled.
No need to initialize current implementation here. We try to avoid this?
I would use a shorter version of this: for (VM vm : vm.getImages()) {... }
I would use a shorter version of this method, this is more readable: for (VM vm : vm.getImages()) {...
I would use a clearer name for this variable
We can use a try-with-resources block here.
We could use a try-with-resources block here.
The while loop is unnecessary.
Is it correct to use connectedTokens instead of refTokens?
I think it would be better to throw here if refTokens is empty.
I think it would be better to throw here than return.
Will this need to be public?
Can this be a ternary?
Will this need to be protected?
I think we need to move this method over view to a view rather than create a new view and add it again.
I think we need to move this method over view to a view rather than create a new view.
I think we need to move this method over K explicitly to a view instead of K.
**USB**
**USB**- Lame
**USB**-cleanup**
final
return Arrays.asList(this.public, List.toArray(RAND.nextInt(7);
Can this code be simplified to sort the list?
You do not need to copyRepresentationFromAnalysis anymore. You can use DRepresentationQuery query = new DAnalysisSession(representation); DRepresentationQuery query = new DAnalysisSession(representation); DRepresentation query = null; and remove the next break from here
You do not merge this with previous ones
You do not need to copyRepresentationFromAnalysis
I used to be the "Page" object, and to help explain why it is needed again. It just makes the code easier to read.
I used to be the "Page" object, and to help explain what it is doing
I used to be the "Page" object, and to help explain why it is needed again.
I don't think "Commons" is necessary here.
I don't think "Commons" is necessary here. Perhaps it could be moved to the last line?
I don't think "Commons" is necessary for this method.
you can use assertEquals("You shouldn't be able to send", e);
you can use assertEquals("You shouldn't be able to send", e)
you should also change the message of the exception
wait.forElementClickable() should be used before
why we need to wait for the element at all?
why we need to wait for this?
@fanifieiev the same above.
@dalifreire add Href("<LINK_1>
@dalifreire this single task is static, so just add a single call here
Windup/Discover/Java?
Windup/Discover/Index?
Windup/Discover/Debug?
What about negative values? And also please, add {} arround the procedure.apply(...)
It seems Math.abs() is missed. What about negative values? And also please, add curly braces.
It seems Math.abs() is missed. What about negative values? And also please.
Instead of Boolean.parseBoolean you should just check if the properties are passed directly to the constructor.
Instead of Boolean.parseBoolean you should just check if the properties are passed directly to the constructor of initialize().
Instead of Boolean.parseBoolean you should just check if it is true and return false if it is true.
Fantastic coverage, thank you!
Fantastic coverage, thank you! Thanks!
Fantastic coverage, thank you
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces here
I think english should be on the previous line.
I think english should be on the next line.
I think ;)
why 1024 * 1024?
nit: define size -> calculatedSize
why 0?
Can we check if the object is a member of the AuthorityAuthority object? What do you think?
Can we check if the object is a member of the AuthorityAuthority object?
Can we check if the object is a dynamic id or not, and if it is possible to create a new instance of the current instance?
This can be simplified to java nearCacheStats.incrementInvalidationEvents(); if(removed) { nearCacheStats.incrementInvalidationEvents(); }
This can be simplified to java nearCacheStats.incrementInvalidationEvents(); if (removed) { nearCacheStats.incrementInvalidationEvents(); }
This can be simplified to java nearCacheStats.incrementInvalidationEvents();
We are missing the way we found this: <LINK_0>
You can use the method I found: <LINK_0>
We are missing the case where the user press the 'from' button. I think the 'track' an image should be shown to the user but not the resize icon.
mationkey % 17
to put each filter line
add assertion.
We should not be able to retrieve the whole ClaimException here. You should be able to do something like invalidClaims instead of a String.format("The value doesn't match the required issuer: " + invalidClaims, must be an error.", PublicClaims.toString(String.format("The Claim '%s't match the required issuer: " + invalidClaims,
We should not be able to retrieve the whole ClaimException here. You should be able to do something like invalidClaims instead of a String.format("The value doesn't match the required issuer: " + invalidClaims, must be an error.", PublicClaims.format(String.format("The '%s' value doesn't match the required issuer: " + invalidClaims,
We should not be able to retrieve the whole ClaimException here. You should be able to do something like invalidClaims instead of a String.format("The value doesn't match the required issuer: " + invalidClaims, and then the validation should be done.
foreach
what if the powers is not added?
what if the powers is reached?
requireNonNull(key)?
Check for this one too.
requireNonNull(key)
@lautarobock Here too, let's declare throws Exception.
@lautarobock Here too, let's use throws Exception.
@ekondrashev Too much indentation here
Should this be in GctoCluster.takeOutGarbage()?
Should this be in Gcto4? It seems to me there's no guarantee the order in which this method is called.
Should this be in GctoCluster.takeOutGarbagePair?
Shall we do the same for the other methods?
Shall we do the same for the other method?
Not formatted
Shouldn't we call addExecuteStatement.execute(() -> addAddStatement(methodElement, context, ExecutableElement.getReturnType(), typeParameters, /** * Adds the specified HttpResponse at the end of the method. * * @param value The object to add() method should be used */ public void addExecuteStatement(Binding<String> type, ExecutableElement, String typeParameters) { throw new GeneratedCodePatterns add(method.getReturnType(), typeParameters); }
Shouldn't we call addExecuteStatement.execute(() -> addAddStatement(methodElement, context, ExecutableElement.getReturnType(), typeParameters, /** * Deletes {@code true} * @param version of the result of the OPAQUER.
Shouldn't we be returning an overload?
the put will remove the previous mapping
the put should be remove the previous mapping
the put will remove the old mapping
This is probably better handled with a socket.toString() instead.
This is a bit complicated. Why not get the socket address from the toString?
This is probably better handled with a socket.toString()
Should these be assertSame? Might be worth leaving them as they are.
Should these be assertSame? Might be worth leaving them as-is
Should these be fail() instead?
c --> connectionlessProtocol
add debug output
make unmodifiable
It's possible to use ObjectUtils.getRdnForAttribute(valueRdn) here.
It's possible to use ObjectUtils.getRdnForAttribute(valueRdn) here, as it is used in the same place
It's possible to use ObjectUtils.getRdnForAttribute(key) here, Wondering if we'll want to pull it out into a private method.
This variable is too long. It's not used outside this class
This variable is unused, so remove the need to convert it to string.
This variable is too long. It's not used outside of the loop, but I would prefer to capture the result of substring(0, input.length()).
house style is to put the braces in a separate line
house style is to put the logical in a separate line
missing space after =
What do you think about taking the lock in the constructor and using a_000_000L?
What do you think about taking the lock in the constructor and using a_000_000L here?
What do you think about putting host_logger.getPartitionId() and.getPartitionId() in the lambda?
Can we rewrite this loop to use deferredRecords.clear() because we need to always use records.clear()?
Can we use ArrayList constructor that way?
Can we rewrite this loop to use ArrayList constructor?
i'm not sure if it's the right term to use "token_hash" as token.
Should we define "token_hash" as String as the default?
i'm not sure if it's the right term to use 'token_hash' as token.
I think it's better to remove the "Trying to start" part
I think it's better to remove the "Trying to start" part - is it possible that the setting isn't empty?
I think it's better to remove the "Trying to start" part - is it possible that the setting is empty?
retval not validated.
retval not validated?
retval => return poolSize
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private "get" method. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
use String wikiPath = url.getUrlForWiki(wikiName);
use String wikiPath = wikiName.getUrlForWiki(wikiName);
maybe go with the name in the message?
maybe use the same message?
maybe go with the name?
Instead of checking for null, you can use the ItemTypeConfigTypeAmbariToOriginalPattern itself.
Instead of checking for empty string, you can use StringUtils.isBlank() from Utils.
Instead of checking for empty string, you can use StringUtils.isBlank()
replace with fType.hasAL
EnumSet
replace with EnumSet
Is there a reason why this method doesn't return an unmodifiable list?
Is there a reason why this method doesn't return a Collection?
Is there a reason why this method doesn't return a Collection? It seems like an unnecessary cast to a concrete class.
This getString() can be called dozens or hundreds of times in a single line.
This getString() can be called from multiple places.
This getString() can be called dozens or hundreds of times in a single row.
you could use the other format method
extract as constant
extract the values
Wouldn't it be better to use Message.log(Level.WARNING, message)?
Wouldn't it be better to use Message.log(Level.WARNING, message)?
Wouldn't it be better to use MessageBuilder for the message()?
the @NonNull annotation is missing.
the @NonNull annotation is missing here.
revert this and use TmfTraceManager instead.
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
I think we should use the org.mozilla.internal.Sys class here.
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking..
Shouldn't this be enabled = false?
This is redundant with the next line.
This is redundant. You should probably use the DISABLED_MODE constant in the setter.
please add __TS("typical") here
Use __TS("typical") here.
Use __TS("typical") here
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing a exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true"? Or, at the very least, log a warning.
We actually have to be careful here.
This part should be added to the map to Splunk.
We should be consistent here, I think it should be createR.
Could you please add a message to the exception
Could you please add a message stating that the user is not able to call ActionDeniedException?
Could you please add a message to the exception that was not thrown by the runner.
Does this line need to be done again?
Does this line need to be done again? I think it would be better to put this outside of the list list.
Does this line need to be done again? I think it would be better to put this outside of the try block.
Why did you change the method name? Also, can you rename the variable to just pipe?
Why did you change the method name?
Why did you change this?
Could you please throw RuntimeException?
Could you please throw UnsupportedOperationException?
UnsupportedOperationException
Can you check if shutdown is invoked with shutdown?
Can you check if shutdown is invoked?
Can you elaborate?
You can avoid new line by using softly.hasSize(1) and isTrue() from the set.
You can avoid new line by using softly.hasSize(1);
You can avoid new line by using.hasSize(1) and.isTrue() from the next 2 lines.
If this was at the PaymenttCreateRequest validator level it would use Set<ConstraintViolation<T>> constraintViolations = validator.validate(telephoneUrl); and then it could be passesValidationForNullCardExpiry() and the assertion would be assertThat(constraintViolations.isEmpty(), isNumber(0));, but it's not so it should test what the actual constraint violation is (applies to all validation tests). For other validator tests - they're not at the deepest validator level (which in some cases seem either impossible or difficult to do), and there is no general test for CreateTelephoneChargeCreateRequest, so checking for the actual not null violation should be a part of them.
If this was at the PaymenttCreateRequest validator level it would use Set<ConstraintViolation<ConstraintViolation<>> constraintViolations = validator.validate(telephoneUrl); and then it could be passesValidationForNullCardExpiry() and the assertion would be assertThat(constraintViolations.size(), isNumber(0));
If this was at the PaymenttCreateRequest validator level it would use Set<ConstraintViolation<ConstraintViolation<>> constraintViolations = validator.validate(telephoneUrl); and then it could be passesValidationForNullCardExpiry() and the assertion would be assertThat(constraintViolations.isEmpty(), isNumber(0));
remoteViews.hashCode() should be enough here.
Objects.hash()?
remoteViews.hashCode() could be enough here.
Let the user pass invalid data without a crash suggestion m = requestVer!= null;
Let the user pass invalid data without a crash suggestion m = fail("snippet <version>: " + data);
Let the user pass invalid data without a crash
You can write this shorter: buffer.length = Math.min(buffer, read);
You can write this shorter: buffer.length = Math.min(buffer.length, offset, read);
You can write this shorter: buffer.length = Math.min(buffer.length, offset, read.length);
why not use runVdsCommand here?
why not use getVds() instead of casting the callback yourself?
you can use here getVds() instead of the callback yourself
In success response you return json, but when fail - trying to return plain-text. It is not an good idea
Hope you will refacto it in future, and will return valid Object instead of string and allow Spring do the work about result
Is returning ResponseEntity<Object>
Can be replaced with assertEquals
Can be inlined
Use assertEquals
missing {}?
'{}' is missing around the format {}.
'{}' is missing in place, as there areCook-calls
Please add.trim() to the previous line.
Please add.getProperty() to the system property.
Please add.trim() to avoid duplication.
You should return the selected trace with the current time
You should return the selected trace before calling getCurrentTrace
You should return the selected trace before calling getTrace
Extra line.
Unnecessary.
Redundant calls.
Suppose makes sense to convert value to lower case before comparing.
Suppose makes sense to convert value to lower case before comparing. Also, I don't know if value == "true".equals(value) will throw an exception.
Suppose makes sense to convert value to lower case before comparing. Also, I don't think equals() will do the trick.
Is this really needed?
Should it be this class's default?
Should it be this?
the getTenantAsString() could be moved to the ValueMapper
the getTenantAsString() could be extracted to a constant
the getTenantAsString() could be extracted to a constant?
nit: could use the simpler: java return (context == null)? null : this.map(Class::cast).put(type, object);
nit: I know we don't really need this, but could we just do: java return (context == null)? null : this;
nit: I know we don't really need this, but could we just do: java return (context == null)? null : this;?
Same question about losing all precision here instead of during formatting %.1f
Same remark about losing all precision here instead of during formatting %.1f
Same question about losing all precision here instead of during formatting %
> What about assertThat(restTemplate.equals("MESSAGE.equals(""), equalTo(name)); ) instead of assertEquals(messageRoutingInformationEndpoint.equals("The message")); The message should be something like "The message should be provided");.equals(name) is redundant and should be fine.
> What about assertThat(restTemplate.equals("MESSAGE.equals(""), equalTo(name)); ) instead of assertEquals(messageRoutingInformationEndpoint.equals("The message")); The message should be something like "The message should be provided");.equals("The message should be provided"); If you assertion, we are comparing the equals method and the exception message should be on the message content.
> What about assertThat(restTemplate.equals("MESSAGE.equals(""), equalTo(name)); ) instead of assertEquals(messageRoutingInformationEndpoint.equals("The message")); The message should be something like "The message should be provided");.equals("The message should be provided"); If you assertion, we are comparing the equals method and then checking the value of the message content.
consider moving the compiled pattern into a static final field. Regex compilation is a slow process to be done on the fly, specially for constant patterns.
consider moving the compiled pattern to a static final field. Regex compilation is a slow process to be done on the fly, specially for constant patterns.
consider moving the compiled code into a static final field. Regex compilation is a slow process to be done on the fly, specially for constant patterns.
throws RestApiException not necessary.
throws RestApiException not needed.
throws Remove.
shouldn't this be "" +?
Why are we doing this?
shouldn't it be "" +?
what about java if (resourceLocation.equals(resourceLocation)) {... }
what about import static org.eclipse.core.runtime.Assert.isNotNullOrEmptyOperation?
what about java if (resourceLocation.equals(resourceLocation)) {... }?
shouldn't it be buf.append("-", buf.getOldImage().getStartLine());?
shouldn't it be buf.append("-", buf.toString())?
we can put the new getNewLineCount(String).append("-", "," + ") on it
This should return a String, not a NON-NLS
This should return a String, not a Object or Object
This should return a String, not a Object or Object.
please replace with verify(adminDAO, never()).executeSQL(null, never());
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
please replace with verifyNull
Add checkState(lifespan == null, "Lifespan cannot be null");
Add checkState(lifespan == null, "Lifespan cannot be null");?
Add requireNonNull for lifespan.
I think you want to call the new method which gives servers based on glusterPeerStatus
I think you want to check getVdsDao()!= null, which ensures vdsId will be null
I think you want to check getVdsDao() first, if not empty, otherwise get rid of the check
Are you sure this is not needed? The lines below are not needed
Are you sure this is needed? The lines below are not needed
Are you sure this line is needed? The lines below are not needed
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct), but let's not get into corner cases :) )
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) ;)
s/Count/ count
s/send/mon threads are used/
s/send/mon threads
Can we put @Override on a separate line? I'm not sure that 09/05/05 may be clearer in the future
Can we put @Override on a separate line? I think that 09/05/05 may be clearer in the future
Can we put @Override on a separate line? I'm not sure that 09/05/05 may be clearer in the previous test.
Please use the assert message
Please use the assert message..
Please use the assert message.
It's a bit strange to have a deterministic component to do this. I'd prefer to keep the default constructor package-private and use a new one.
nit: better to use a junit assert.
nit: I'd prefer to use a junit assert.
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
I'm not sure about the method name though. Why not "protected abstract" like in the class? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
I'm not sure about the method name though. Why not "protected abstract"?
Maybe this will already be immutable. And a list.
Maybe shouldn't be immutable. And a list.
Maybe this will already be immutable. And a copy.
Please use the super.visit(e) as well
Let's use a more descriptive name.
Remove the public
Seems like you're doing this multiple times.
Seems like this will iterate over the keys and only replace the first one.
Seems like this will iterate over the keys and only one of the lines.
Could you please put this in the previous "clone" method? That way, it makes the test easier to read.
Could you please put this in the previous "clone" method? That way, it makes the test easier to understand.
I think that you need this extra copy constructor
this one can be empty
this one can be private right?
this one could be empty, not null
Could you extract this code so it is repeated in the 'getConverterLookup()' method?
In this test you probably wanted to pass null as the default value of the test method so it becomes clear which one is a null value.
In this test you probably wanted to pass null as the default value of the test method so it becomes clear which one is a valid value.
This method can be extracted to a common method
This method can be extracted to a common interface
This method can be extracted to a common interface.
From <LINK_0> > I don't like the form of regex manipulation of string should come from baseName. When baseName does not contain '-' this code will fail. @haozhun any thoughts.
From <LINK_0> > I don't like the form of regex manipulation of string should come from baseName. When baseName does not contain '-' this will fail. @haozhun any thoughts.
From baseName would be null and not null.
If you're reading this correctly, the background task should be executed when there's no stage.
If you're changing the background anyway, why not just read the code from the background thread?
If you're reading this correctly, the background task should be executed when there's an event to be scheduled.
Nit: I think the OracleDataContext constructor is not needed here. And I think it should be OraclePropertyStrategy.
Nit: I think the OracleDataContext constructor is not needed here. And I think it should be OracleDataContext or IndexEngine.
Nit: I think the OracleDataContext constructor is not needed here. And I think it should be OraclePropertyRewriter" and the default implementation (and the same below).
This syntax seems way more clunky
why not have the formatting method in UserAgent?
Why not have the formatting method in UserAgent?
suggestion return (verbose!= null &&!verbose.isEmpty())
suggestion if (verbose!= null) {
suggestion returnverbose.isEmpty();
To save a context for a reference comparison with SSLContext() on the classpath, you should use a dynamic SSL context for the keystore types here.
To save a context for a reference comparison with SSLContext() on the classpath, you should use a dynamic SSL context for the relatedSSLContext() here.
To save a context for a reference comparison with SSLContext() on the classpath (which is available in the JVM)
"Maximum tag length is exceeded". So it's not clear.
"Maximum tag length is exceeded". Why not use "MAX_TAG_LENGTH"?
"Maximum tag length is exceeded". Why not use "MAX_TAG_LENGTH_TAG_LENGTH"?
I think that if we have enum as first parameter, then we can replace the type-checking of operatorSpecs with the rest of the method.
I think that when the first parameter is of type OperatorSpec we don't have to cast to OpCode()
I think that if we have enum as first parameter, then we can replace the type-checking of operatorSpecs with the rest of the method (i.e. type parameter).
This method doesn't need to be public
This method doesn't do the job, because it has no owner to be null checked.
This method doesn't do the job, because it will throw NullPointerException if owner is null.
Java does not contain the keyword null.
Java does not contain the keyword nulls.
Java does not contain the input names.
I don't like this arbitrary limit of line Height. Instead, I would prefer: public boolean isShowingEntireContents(StyledText widget) { if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return bottom; } // Move the last line to bottom line so that it doesn't have to be checked. Another way is that I would invert the if-clause and then break out of the last line: if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return false; } // Check whether the last line is fully visible int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)); return bottom; } //NON-NLS-1
I don't like this arbitrary limit of line Height. Instead, I would prefer: public boolean isShowingEntireContents(StyledText widget) { if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return bottom; } // Move the last line to bottom line so that it doesn't have to be checked. Another way is that I would invert the if-clause and then break out of the last line: if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return false; } // Check whether the last line is fully visible int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineIndex(widget, bottom); return bottom; } // Check if the last line is fully visible int bottom= widget.getLineIndex(lastVisiblePixel);
I don't like this arbitrary limit of line Height. Instead, I would prefer: public boolean isShowingEntireContents(StyledText widget) { if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return bottom; } // Move the last line to bottom line so that it doesn't have to be checked. Another way is that I would invert the if-clause and then break out of the last line: if (bottom + 1 < widget.getLineIndex(lastVisiblePixel)) { return false; } // Check whether the last line is fully visible int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineIndex(lastVisiblePixel); bottom= widget.getLineIndex(lastVisiblePixel); bottomLastPixel= bottom); } return bottom;
should specify an expected exit code
should specify an expected number
should specify an expected number of entries
Can you use Integer.MAX_VALUE instead of Integer.MIN_VALUE?
Can we use -1 to be consistent with how many values are serialized?
Can we use -1 to be consistent with how many magic numbers are being used?
kStateChangeListener:: A; is simpler
Format
kStateMap.of
Same as above, please move this line under the SetViewport line and add an empty line after it.
Same as above, please move this line under the SetViewport line and add an empty line before it.
Same as above, please move this line under the SetViewport line and add an empty line after it and return.
Shouldn't this be protected?
Shouldn't this be protected as well?
Shouldn't it be protected?
Could you extract a method for plural resolution? kEventThread.handleHexSessionId(session)
Could you extract a method for plural resolution? kEventThread.handleHexSessionId(String)
Could you extract a method for plural resolution? kEventThread.handleHexSessionId(String id)
And here as well.
And here.
Add a message.
nit: make this final
nitpick: make this final
nit: make this final?
Looks like remaining can be null, right?
I'd rather throw an exception here. It's not a big deal, because it will be hard to identify where it is.
I'd rather see more than one result, because it's most likely that remaining would be the same.
I don't think we need this log.debug(String, Throwable) - should the exception be the fourth argument to the method so that it is logged as it is?
I don't think we need this log.debug(String, Throwable) - should use Exception instead of Throwable.
I don't think we need this log.debug(String, Throwable) - should use isAssignableFrom for this instead
@paulodamaso the braces and return are not needed here
@paulodamaso I'd prefer to use an Integer here instead of a long
@paulodamaso I'd prefer to use an Integer here instead of a double
Is there a reason you can't use the indexOf(':') and then just do a colon there? Or is it possible to add another trailing slash?
Is there a reason you can't use the indexOf(':') and then just do a colon there? Or is it possible that an empty string?
Is there a reason you can't use the String literal directly?
Revert the changes here.
You can use a diamond operator here.
You can use diamond operator here.
@garydgregory Please use StringUtils.startsWith("/")?
We can use StringUtils.startsWith("/") for this.
@garydgregory Please use StringUtils.startsWith("/")? 1 : ""
we need to include the sizeLimit in the error message?
we need to also add the sizeLimit here?
we need to also support the "NRecordUtil.hex" for example.
It's the table that this change is required. Is this intentional?
It's the table that this change is not necessary. Is the first time this method called?
It's the table that this change is not necessary. Is the constant here intended?
Test is a test class, so please assert that the test is annotated with @Test(expected=IllegalStateException.class) test is not enough.
Test is a test class, so please assert that the test is annotated with @Rule.
Test is a test class. It doesn't reflect the change of the test.
static?
static"?
static
Is there a test for passing a single config?
Why not assert?
Why not assert the state here?
We should be able to use the activationKeyCurator. The problem is that the activation key does not define any internal value, so they will be locked until the activation key is being updated. So I don't think we need to be able to tell the activationKeyCurator. Note that the activationKeyCurator.updateActivationKeyCurator does it
We should be able to use the activationKeyCurator. The problem is that the activation key does not define any internal value, so they will be locked until the activation key is being updated. So I don't think we need to be able to tell the activationKeyCurator. Note that the activationKeyCurator.updateActivationKey() is being called for a particular activationKey.
I'm not a big fan of this particular thing. I recommend catching an exception and returning null
Again, move line 138 and Format.
Again, move line 92 above.
Again, move line 92.
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info.
same with the return code here, you could return a boolean to indicate success/failure. the channel doesn't have to be addChannel(), but the get() method should be marked as @Nullable
same with the return code here, you could return a boolean to indicate success or not
Typo: event_id -> flow_id
Typo: event_id -> item_id
Typo: event_id -> event.
Make this into a local variable.
Make this private?
Make this or use a local variable.
Should we have the other assertEquals() methods?
Should we have the assertEquals() to assert the exact string?
Should we have the assertEquals() method?
not sure if it's necessary but you can use the @Override annotation here
not sure if it's necessary but you can use the @Override annotation here <LINK_0>
not sure if it's necessary but you can use the @Override annotation on these lines directly.
Can we please have elses on the same line?
Can we please use JPA criterias?
Can we please have elses on the previous line?
Call the super. onResume() at the top of the file instead.
Call the super. onResume() at the top of the parent fragment with the super.
Call the super. onResume() at the top of the parent fragment with the super class coordinates.
If you don't need the log field, you can directly use EvaluatorUtil.log(Level.INFO, "Evaluator completedEvaluator completed");
If you don't need the log field, you can directly use parameterized logging instead of string concatenation.
When will happen? Let's pass a Evaluator to theEvaluator constructor and use it here.
equals
Please use Java 8 streams here
equals() missing here?
This method should only be called if WrongAttributeValueException is true.
This exception is only for generic parameters.
This cannot be true.
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
Could you replace the sole use of Guava's Files in this class with java.io.File.copy() and then avoid fully-qualified class name?
Please use HadoopDruidIndexerConfig.JSON_MAPPER instead.
...and again...
This can be a stream, filter.
This can be a Stream
Can't this constructor call this(Replication replication, false)?
Can't this constructor be private?
Can't this constructor be made private?
Let's rename this method to getRoutingTableRequestIdToStoreId
Let's say "Cannot initialize routing table for block % numTotalBlocks"
Let's rename this method to getRoutingTableRequestIdToStoreId()
In what situations are we throwing an exception? Why not readUnsignedInt for the field and only throw an exception?
In what situations are we throwing an exception? Why not readUnsignedInt for the input?
In what situations are we throwing an exception?
suggestion mAnnouncementFragment = mAnnouncement.makeDeleteRequest(mAnnouncement);
I don't think this should be on AndroidAnnouncementFragment too.
This should probably be on the same line as the activity lifecycle.
This is not needed.
This is unnecessary as you are calling analyze() two times.
This is unnecessary as you are calling analyze() twice.
If you make this package-private, it should be a private constructor.
If you make this package-private (and the @VisibleForTesting can be removed) this class is a public API.
Yes, I think we should return a copy of the property.
Code style: Do we need a variable here? String configSource = null;
Code style: Do we need a variable here?
Code style: Do we need the variable configSource in this test?
when address is null, you should check if address is null
when address is null, it should be empty
when address is null, it should be private
Can you change to List<Property> ret = new ArrayList<>(property);?
Can you change to List<Property> or List<Property>?
Should you use List interface instead of the concrete class?
I think it would be clearer to use Integer.valueOf instead of refundAmountAvailable
I think it would be clearer to use Integer.valueOf() here rather than object.
I think it would be clearer to use Integer.valueOf instead of refundAmount
suggestion return new DbSpace(environment, sorted);
suggestion return new DbSpace<>(environment, sorted);
<LINK_0>
create a buildServingTrucks method or something similar in the Trucks class instead of doing it here
create a buildServingTrucks method or something similar in the Trucks method instead of doing it here
As an aside, you can pass a boolean here. Also in content values. They get converted correctly. No need to change it here
Shouldn't you use getSystem bitmap here?
Shouldn't you use getSystem?
Shouldn't we add a default value for docker?
delay is already completed.
check if delay is completed?
BiasedEntryWrappingInterceptor is checking if the delay == null. Is it missing here?
Would be great if we can check if the envelope.hasMessages() is not null.
Would be great if we can check if the envelope.hasMessages() call is not null.
Is there any reason for this change?
Better to use Java 7 syntax like: public List<BaseQueryBlock> getBaseQueryBlock(String search, List<String> categories, String reason) {
Better to use Java 7 syntax like: public List<BaseQueryBlock> getBaseQueryBlock(String search, String search) {
If there is no categories, will this still be needed?
As I see it is used in the other places, I don't see it being used anywhere else. Can we use the string constant instead?
As I see it is used in the other places, I don't see it being used anywhere else. Can we make an enum or constant instead of using a magic number?
As I see it is used in the other places, I don't see it being used anywhere else. Can we make an enum or constant instead of using a string literal?
Can we throw an exception instead of returning null? It would mean caller doesn't have to handle null first.
Can we throw an exception instead of returning null? It would be better to indicate caller doesn't have to handle this.
Can we throw an exception instead of returning null? It would be better to indicate caller doesn't have to handle it.
Is this check needed? Does it mean that three flows can be raised?
Is this check needed? Does it need to be done in the XMLOutputter class?
Is this check needed? Does it mean that three threads might be able to run this code simultaneously?
Needs to be logged at the end
Needs to be logged at the end.
Needs to be at the trace level.
naming this variable doesn't seem accurate
FsckError?
naming this variable doesn't seem accurate.
Shouldn't it be a warning?
Shouldn't it be runtimeProvider?
Shouldn't it be a runtime exception?
Please check for these changes in this file.
Please check for the invocations of this method
Please change to ensure they are senior.
It looks like all of the calls to createFakeHeader pass in the same empty metadata and additional code here.
It looks like all of the calls to createFakeHeader pass in the same empty metadata and additional code to createFakeHeader.
try block.
this is a good pattern in TaskProcessCallback since it doesn't have a taskProcessCallback.
this is a good pattern in TaskProcessCallback since it doesn't implement the task definition.
same as above, this should be a static method
I think it should be the first parameter in the getSourceAttributeFriendlyName() method, because I am not sure how to name it.
I think it should be the first parameter in the getSourceAttributeFriendlyName() method, because I am not sure how I can see it.
I think it should be the first parameter in the getSourceAttributeFriendlyName() method, because I don't understand what this command is doing.
nit: return getExtractedType()
nit: blank line between methods
nit: return Type.valueOf()
Is this calling.get() on an instance of ApplicationReadyEvent to prevent the wrong threadedness?
Is this calling.thenReturn(10) necessary?
Is this calling.get() on an instance of ApplicationReadyEvent to prevent the wrong Exception?
This should have a default value, i.e. making it hard to understand.
This should have a default value, i.e., add if you want.
This should have a default value, so that it doesn't repeat. Same for other places.
Please remove this exception.
Please follow the TODO over PR.
Please don't swallow exceptions.
why not use the existing ConfiguredRangeContainer here?
why not use the existing test method to verify the case that would work?
why not use the existing test method?
How about: "bookie-shell"
How about making the commander a field?
How about: "bookie-shell"?
Should we replace this with: String PKCE_STATE_PKCE_KEY_PKCE_KEY_PKCE_KEY_PKCE_KEY_PKCE_KEY_PKCE_KEY_PKCE_KEY_PKCE
This should be accessed using a reference to the Bundle.
This should be accessed by a static map.
Can we make this private? Since there is no public API, just make it package-private.
Can we make this private? Since there is a public API, just make it package-private.
Can we make this private? Since there is no public API, just make it final.
I see the same logic as createWriteAdvHandleWithoutData. Can you explain me what's the use?
I see the same logic as createWriteAdvHandleWithoutData. Can you explain me what's the use case?
I feel like receiveWriteAdvHandle> is clearer
Is it possible to rename the field to SimpleName to be null?
Is it possible to rename the field to SimpleName to distinguish the root cause?
Is this really needed?
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
I guess you could put the key on the query?
You could have returned this if statement by componentType.cast(this)?
Could be static?
You could have returned this if statement by componentType.cast(this)
same here, do we need to make sure that we do not match the algorithm?
same here with so.
same here with the other platforms
Use else instead of if else since the if is a duplicate.
Use else instead of if else since the if block returns false.
Use else if here instead of two lines.
Please add this error message to the INNER join type, since it is more specific to this exception.
Please add this error message to the INNER join type, since it is not well known to use ERROR.
Please add this error message to the checkArgument call.
J) scope=%s is --> access_token or refresh_token
J) scope=%s is --> access_token
J) scope=%s is --> access_token=%s
not sure if we could have a stream for the first time, especially in production code.
not sure if we want to expose this protected, or is it just the subclass?
not sure if we want to expose this?
The default cached fields are not used.
The Builder method doesn't support setting the default rendering.
The Builder method doesn't provide much details.
This should be a String, so we can have something like this: >  inventoryId = "}";
This should be a String, since it's an abstract method.
This should be a String, since it's an abstract class
log.trace
log.debug
log
Agree. DataRadioStation station = DataRadioStation.getInstance(); if (station!= null) { DataRadioStation station = radioDroidApp.getFavouriteManager().execute(currentStationId); if (station!= null) { RadioDroidApp.execute(currentStationId); } } return RadioDroidApp;
Agree. DataRadioStation station = DataRadioStation.getInstance(); if (station!= null) { DataRadioStation station = radioDroidApp.getApplication(); DataRadioStation station = activity!= null; DataRadioStation station = activity!= null; DataRadioStation station = activity!= null;
Agree. DataRadioStation station = DataRadioStation.getInstance();
modelFieldsMap.get(factName, modelField); return toReturn;
modelFieldsMap.get(factName, factName) is more readable
modelFieldsMap.get(factName, factName) is more readable than this one
We don't need this.
We can use this.queryEngine = queryEngine; instead.
We don't need this. This can be done inside the ctor.
This line is unnecessary, given it is called in the constructor.
This line is long enough for me. We don't localize this.
This line is redundant.
I think this should be in the Request.prepare().
I think it should be a Request.isObserve() check.
I think it should be a Request.isObserve() call.
You should close the connection after exception is thrown
You should close the connection before throwing of exception
You should close the connection after exception is thrown.
Is this change related to the meaning of this PR?
You should be able to use the string format here, since this is a string literal by a compiler warning.
You should be able to use the string format here, since this is a string literal by a compiler warning. Also, if this is a debug statement it should be like that.
Shouldn't this be index.get()?
Shouldn't this be index.get(index) instead?
Shouldn't this be index.get(index)?
Isn't there a reason to have the totalSize be a multiple of the first?
Isn't there a clearer way to do this? int totalSize = Math.max( totalSize); return localDiskSize;
Isn't there a reason to have the totalSize here?
nit: this can be replaced with: if (message.getResult().getHermes()) {
nit: remove "this." in the if statement.
nit: remove "this." in the if block.
Multi return is forbidden.
duplicate the 2 lines
duplicate the
We could add a tiny bit of clarity if we could have something like: private static final OptionsParsingException = input.replaceAll("-", " or ") => " + input.replace(" *, ") ); private String convertLegacySyntaxToBoolean() { return input.replaceAll(" *, ", ") ); }
We could add a tiny bit of clarity if we could have something like: private static final OptionsParsingException = input.replaceAll("-", " or ") => Options.replace("-", ") => "; then OptionsParsingException = input.replaceAll("-", ") and call.replace("-", " or ") to make the code more readable?
We could add a tiny bit of clarity if we could have something like: private static final OptionsParsingException = input.replaceAll("-", " or ") => Options.replace("-", ") => "; then OptionsParsingException = input.replaceAll("-", ") and call.replace("-", " or ") to make the code more readable.
Can you remove this?
Can you remove this line?
Can be removed
change to equals instead of ==
change to equals instead of hashCode
Default playerController is used here too
This should have a return statement... no?
This should have a return type.
This should return the same value.
This should be RestView.
I think this should be RestView.
Shouldn't we have this as RestView.
Is there a reason for this to be public?
Is there a reason for this explicit test to throw?
Is there a reason for this explicit check?
Should we also check forbearing on the ".jar" being set?
Should we also check for bearing on the ".jar".
Should we also check forbearing on the ".jar". We already have an answer, but there is no code to make it?
I think this should be a shut down than the scheduler
I think this should be a shut down
I think this should be a shut down than the scheduler.
I think you can use ServiceResponse here, both response and response are not really meaningful. It will result in a longer message though and not very readable.
I think you can use ServiceResponse here, both response and response are not really meaningful. It will result in a longer message though and not very descriptive.
I think you can use a String.format here
Make this a constant.
Should be final
Make this a constant?
Can the return List<String> instead of String? If not, it's better to use List.of
Can the return List<String> instead of String?
Can the return type be List<String> instead of String?
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
@public abstract? Or may be removed?
is this really needed?
We can use static imports for Preconditions, throughout the code ones.
Please add null checks for the error message and the null checks.
We can use static imports for Preconditions, but we are doing this nicer.
suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
UnsupportedOperationException shouldn't be used.
UnsupportedOperationException shouldn't be here.
nit: can be final
nit: can be removed to simplify the pattern.
nit: can use  fn.apply(e) directly
java return Collections.unmodifiableList(Arrays.asList(unistd.h>));
Prefer getHeaderFiles() to wrap with getHeaderFiles(). I think the getHeaderFiles() should be equivalent: java return Collections.unmodifiableList(Arrays.asList(unistd.h>));
Prefer getHeaderFiles() to wrap with getHeaderFiles(). I'm not sure we want to need to wrap things like this.
Use InjectableAttribute = context.getServiceReferences();
Use InjectableAttribute.INSTANCE.getServiceReferences().isEmpty() instead?
Use InjectableAttribute.getName() instead?
I am wondering if we could use Rule.purgeLocalStreamsStateDir here. What do you think?
I am wondering why metrics we need to be different here. Can we just use different metrics scope tests?
I am wondering why metrics we need to be different here. Can we just use different metrics scope than we?
Shall we make this a constant so it's easier to put if/else without the need to have a variable?
Shall we make this a constant so it's bigger than once?
Shall we use a constant for this?
You can put this line into a method, so it can be called more than once.
You can put this line on top of the class, right?
You can put this line on top of the method, so it will be more readable.
What about authorization gutSystemEntry? I mean, it can be moved to jdoc-only.
What do you think about adding a method that takes a filterInBindable or a Stream?
Missing white space between methods.
remove this.
use containsKey?
use containsKey
Can we use the t.add(t) method?
Can we use the intention to keep the previous line?
Can we use the generic constructor to define the exception?
IPath.SEPARATOR
IPath.SEPARATOR + uriString
IPath.SEPARATOR should be used for the key
I only see that with the field names are used. I don't think the field names need to be set to true.
I only see that with the field names are used. I don't think the field names need to be set?
I only see that with the field names are used. I don't think the field names should be consistent.
Should this check if countss are empty?
Should this catch Exception instead of Throwable?
Should this catch Exception instead?
what about initializing with a factory in the constructor?
what about initializing with a copy-paste error?
what if you re-purpose it?
please use the same for tests
please use the same for tests (other than the other method)
please use the same for tests (other than the previous one)
Both lines 115 and 116 can be moved together, i.e.: public void dispose() { session.removeListener(this); }
I think we should clear the session here.
I think it should be disposeSessionAction(this, null); and in dispose you don't.
This line should probably be removed
This line should probably be omitted.
This line should probably be removed.
[2019-10-01T07:16:01.665] /home/jenkins/jenkins_slave/workspace/Catroid_PR-3353/catroid/src/main/java/org/catrobat/catroid/ProjectDefinition.java:98: error: cannot find symbol [2019-10-01T07:16:01.665] return; INSTANCE.schedule(project);
[2019-10-01T07:16:01.665] /home/jenkins/jenkins_slave/workspace/Catroid_PR-3353/catroid/src/main/java/org/catrobat/catroid/ProjectProperties.java:98: error: cannot find symbol [2019-10-01T07:16:01.665] return; INSTANCE.schedule(project);
INSTANCE.get(project)!= null is enough
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this use of "private" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this use of "super. [![rule](<LINK_2>](<LINK_0>
Why it returns a string?
Why it returns a Long instead of a int?
Why it returns a Long instead of a String?
I think a else is necessary here. if (useTimeout!= null &&!useTimeout) { return Optional.absent(); } else { Optional.of(Deadline.from(Deadline.from(contextDeadline)); }
I think a else is necessary here. if (useTimeout!= null &&!useTimeout.after(contextDeadline)) { return Optional.from(Deadline.from(Deadline.from(contextDeadline)); } else { return Optional.absent(); } }
I think a else is necessary here. if (useTimeout!= null &&!useTimeout.after(requestTimeoutMs)) { return Optional.absent(); } else { Optional.of(Deadline.from(Deadline.from(contextDeadline)); }
why not use a ConcurrentChildCommandsExecutionCallback()?
why not use this instead of a callback function
why not use a ConcurrentChildCommandsExecutionCallback to keep it consistent with the other map operations?
Missing a logger.
Missing a sysout.
Missing a sysout?
@vilchik-elena Why do we need this test?
@vilchik-elena Minor: we should also use TestUtils.waitForFileOnWindows() as well.
@vilchik-elena Minor: we should have here a different method.
Instead of asserting the message again, just assert that the re-thrown exception is thrown.
Instead of asserting the inputs, just to ensure that the re-thrown exception is thrown. I don't see any reason to not assert the original message again.
Instead of asserting the inputs, just to ensure that the re-thrown exception is thrown. I don't see any reason to expected the actual / exposing it.
Can this method be synchronized?
Can we use the following style: java if (publicKey == null) { return; } try { key = new TokenServiceException(null); } catch (NullPointerException e) { LOG.error("Failed to verify token dependencies"); } }
Can we use the following style: java if (publicKey == null) { return; } try { key = new TokenServiceException(null); } catch (NullPointerException e) { LOG.error("Failed to verify token dependencies"); } };
maybe add a log.info here?
maybe add a log message here?
maybe add a log line here?
can we move this string to a constant?
can we change this to private String join("\n")?
can we change this to private String join("\n\n")?
use {}?
use {} to log format
use {} to remove warning
Is it worth defensive?
Sounds like a defensive copy/paste. Is it possible?
Sounds like a defensive copy?
I don't think this is atomic.
I don't think this is atomic, and this is atomic.
I don't see this is atomic.
InvocationStarted seems to be a common place, why do we need to support it?
InvocationStarted is no longer used.
The mInvocationStarted method is not exposed. Is it guaranteed that it will return the given value?
Can return nit, no need to use ==?
Can return nit, not a blocker
Can be simplified.
Is there a reason why this method is called so much?
I am still confused by this.
Is there a reason why this method is called after all?
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use timeout.
How about setup(Long.class) instead of setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Why don't you want the prefix to be color instead of dgif?
Why don't you want the prefix to be color instead of dur?
Why don't you want the prefix to be colored?
It looks like this more or less takes us to a context where we retry auto update every 2 hours, right? Server load-wise I think that's quite often if we retry-wise the majority of users?
It looks like this more or less takes us to a context where we retry auto update every 2 hours, right? Server task: <LINK_0>
Same here, right? Server task is never set at this point.
Consider using String.valueOf(uriHost.toString())
Consider using String.valueOf(uriHost) here instead of toString() (also below)
Consider using String.valueOf(isPageview())
I don't like the need for the separate method. 'offer' is for the lambda function, it's a bit odd to put in method addTask, right?
I don't like the need for the separate method. 'offer' is for the lambda function, it's a bit odd to put in method.
I do not like the backporting change. I agree with this one at some point it's a bit different from the one used to be annoying.
The CAS could be a bit tighter with you so you should use liftPerformed, but you can use the new test already so that you can do: if (t!= null && upgradePerformed) { return false; }
The CAS could be a bit tighter with you so you should use liftPerformed, but you can use the new test already so that you can do: upgradePerformed = desired.get().assertNonNull(cas, ts);
The CAS could be a bit tighter with you so you should use liftPerformed, but you can use the new test already so that you can do: upgradePerformed = desired.get().assertNonNull(cas, t);
Is this line necessary?
These two conditions can be removed.
Is this line needed?
Is the BSIIndex file going to be generated as part of this method?
Is the BSIIndex file going to be copied as well?
Is the BSIIndex file going to be generated as part of the index?
I don't think this check is required. The test should be also if the set of 'null'.
I don't think this check is necessary...
I don't think this check is necessary... remove it
I think you'll want to use spaces before and after the =
I think it's better to use spaces, also trim() *.
spaces around =
Note that it's not the [this](<LINK_0> element for an association in one go. The responsibility of this method is to use the same implementation as the AssociationRowFactory.createAssociationRowFactory( row ); from both the "shared" and the structure. The same holds for the AssociationRowFactory.createAssociationRowFactory( row ); Is there a reason to do it here?
Note that it's not the [this](<LINK_0> element for an association in one go. The responsibility of this method is to use the same implementation as the AssociationRowFactory.createAssociationRowFactory( row ); from both the "shared" and the structure. The same holds for the AssociationRowFactory.createAssociationRowFactory( row ); Is there a reason to do it here? I think it's the better choice, if we can.
Note that it's not the [this](<LINK_0> element for an association in one go. The responsibility of this method is to use the same implementation as the AssociationRowFactory.createAssociationRowFactory( row ); from both the "shared" and the structure. The same holds for the AssociationRowFactory.createAssociationRowFactory( row ) method.
This should be a separate method
Looks like this should be a separate method
This should be a separate method.
replace this with createContent() method
replace this with createContent()?
inline
Can we put the indentation in the return Arrays.asList()?
Can we have a @EncryptionLevel that takes a list of encrypted passwords, which I'm trying to use?
Can we put the indentation in a few lines above?
Unfortunately there's no need to wrap this with a try/catch, you can just let it throw.
Unnecessary synchronized block.
Unfortunately there's no need to wrap this with a try/catch!
This magic number is not necessary.
This magic number is incorrect.
This range is incorrect.
This method is called only if the feature is not found. Consider removing the "supportedFeatureSupported" method.
This method is called only if the feature is not found. Consider removing an entry from the list and just add to the supported feature.
This method is called only if the feature is not found. Consider removing an entry from the database.
I would use a different path than the previous line. Here you're doing something else, but that can make the code more readable: try { CountInputStream count = csvMapper.readValue(countInputStream); CsvSchema.readValue(countInputStream); }
I would use a different path than the previous line. Here you're doing something else, but that can make the code more readable.
I would use a different path than the previous line. Here you're doing something else, but that can make the code more readable: try { CountInputStream count = csvMapper.readValue(countInputStream); CsvSchema firstLine = csvMapper.readValue(count); }
This should probably be java if (log.isTraceEnabled()) { if(log.isTraceEnabled()) { log.trace( " satisfied = checkAccess(ctx)); } else { if(satisfied) { satisfied = checkAccess(ctx); } } return satisfied; }
This should probably be java if (log.isTraceEnabled()) { if(log.isTraceEnabled()) { isTraceEnabled(); } else { if(satisfied) { > " satisfied = null"); if(mAccess(ctx) { continue; } } The logic itself is now that the caller already calls checkAccess().
This should probably be if (log.isTraceEnabled()) return; no?
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low.
... It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low.
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than MIN_LOW_OR_MARK.
Let's make this protected to avoid exposing methods that consumers of the API do not care about.
Let's make this protected to avoid exposing methods that consumers of the API do this.
Let's make this protected to avoid exposing methods that consumers of the API do this
why do we need to catch a RuntimeException here?
why do we need to catch any RuntimeException here?
why do you need to catch a RuntimeException?
Please keep this TODO
please keep this TODO
Please return this
This is the expected behavior. Shouldn't it be synchronized?
This is the expected behavior. Shouldn't this be synchronized?
This is unnecessary since it's already synchronized.
Again, needs a context.restoreAuthSystemState();
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior.
Again, needs context.restoreAuthSystemState();
Shouldn't we still log the exception message if the level level is WARN? There is an example of what if it is not supported.
Shouldn't we still log the exception message if the level level is WARN? There is no guarantee that the message will be displayed.
Shouldn't we still log the exception message if the level level is WARN? There is no guarantee that the message does not make sense to me.
Can you use anyMatch instead of filter here?
Can you use anyMatch instead of filter?
Can you use anyMatch() here?
Use the same format as in getBackend()
Use the same logic as in getTaskIdList()
Use the same format as in line 62
The output of this should be included: <LINK_0>
The docs and day of one, could we make this more readable?
The output of this should be included in the assert.
Minor: creating a local variable instead of calling isEmpty()?
Minor: creating a local variable instead of calling isEmpty()
local variable classLoader?
Please use Objects.hash() instead of building the hash code yourself.
Please use Objects.hash() instead of equals()
Please use Objects.hash() instead of building your own code yourself.
This can be made more compact.
This can be made simpler as: new Scanner() { }.
This can be made more compact: useDelimiter = new Scanner()
this should be inside the try block as well.
this should reset all rwLockSources.values() in the constructor.
this should reset all rw.writeLock().lock(); in the finally block.
I think vmBase.isAutoStartup() is already called before the 'isAutoStartup()' call. Please change the name to 'isAutoStartup()'.
I think vmBase.isAutoStartup() is already called before the 'isAutoStartup()' call. The 'isAutoStartup()' method is already called when vmBase is unavailable.
I think vmBase.isAutoStartup() is already called before the 'isAutoStartup()' call. The 'isAutoStartup()' method is already called when vmBase is being set.
I am not sure I like the idea of using streams here, but I find it simpler?
I think we should use Collections#emptyList() here instead of ArrayList<Object>.
I think we should use Collections#addAll
please refactor
please extract the pipe as a class variable
entry.getValue()
It seems like this line can be removed.
It seems like this line can be deleted.
It seems that we could have this as a static constant.
Can be simplified to just: java return map.get(locationId);
Can be simplified to java return an empty map instead of null?
Can be removed?
getMessage() and getMessage() will not print the stack trace.
getMessage() and getMessage() will not print anything.
getMessage() and getMessage() will not print anything. Please verify.
I think to be consistent, the code is correct, but not sure if there is any exception, is it safe to modify or not?
I think to be consistent, the code is correct, but you need to use Exception to underlying token
I think, you need to correct this.
add a message here?
add assertCountTotalNumberOfVariants?
add assertCountTotalNumberOfVariants() < 0
if (messageFormat == null || messageFormat.isEmpty()) {
Should be warningFormat.isEmpty()
if (messageFormat == null && messageFormat.isEmpty()) {
Shall we move this to a checkNotNull()?
I think this should be a checkNotNull
I think this should be a checkNotNull.
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/.... maybe make the test do foreach(String zk : new String[]{"localhost", "up");
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/.... maybe make the test do foreach(String zk : new String[]{"localhost", "up"); etc}
could the variable be renamed?
That's not the contract of hashCode.
That's not the contract of getInstance().
That's not the contract of PropertyManager.
getGeometry call here is redundant, because once super.serialize() is called, this line gets invoked.
getGeometry call here is redundant, because once super.serialize() is called, this is a static method on a enum instance.
getGeometry call here is redundant, because once super.serialize() is called, this is a @Before method.
What about the following cases: java if (parentMethods.isEmpty()) { return childMethods.get(childMethods); } return childMethods.isEmpty();
What about the following cases: java if (parentMethods.isEmpty()) { return childMethods.get(childMethods); } return childMethods.stream().map(childMethods::get(0), parentMethods);
What about a local var with a name such as parentMethods?
Would be better to use the method assertFalse(currentWorkingDir) here.
Would be better to use the interface Exception such as ps.getFileDirectoriesAsPaths(fileDir)
Would be better to use the method assertFalse(currentWorkingDir)
Does this need to be moved to TransportMode?
Objects.requireNonNull(getTransportMode(), "HTTP");
Objects.requireNonNull(getTransportMode())
Please rename factoryUrl to url
why is this hardcoded here?
minor: rename factoryUrl to url
Was it somehow related to this issue? I think it would be nice to have a test for this case.
Typo, should be _public
Typo, should be XXX
Slightly more readable: java if (s.equals("0") || s.equals("1").equals("1"))) {
Slightly more readable: java if (s.equals("1").equals("1") || s.equals("1").equals("1"))) {
You can use ==.
Why FTP Job Trigger.execute in the constructor?
Why FTP Job Trigger.getNode, VirtualFile")?
Why this change?
I would suggest we simplify this logic: java private static String PROTOCOL_HTTP(Auth2Utils.PROTOCOL_HTTP_HTTP_S3PublishingEndPoint) { if (protocol == null ||!protocol.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(protocol); } else if (currently the same thing) { return new StaticPublishingEndPoint(protocol); } else {.. }
I would suggest we simplify this logic: java private static String PROTOCOL_HTTP(Auth2Utils.PROTOCOL_HTTP_HTTP_S3PublishingEndPoint) { if (protocol == null ||!protocol.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(protocol); } else if (currently the same thing) { return new StaticPublishingEndPoint(protocol) } else {.. }
I wouldn't reformat this whole if/else block with a single return statement.
This line is strange, isn't it?
This line is strange, why you changed that?
You need to fix the indentation.
Assertion seems to be missing?
if the server was already initialized, then we don't need to do it here?
if the server was already initialized, then we don't need to re-add it.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
@vilchik-elena Should we use instanceof instead?
Instance string is not always hardcoded, so use toString() method.
Instance string is not always hardcoded, so use toString()
Instance string is not always hardcoded, so use String.valueOf()
Is this the correct way to do this? I would expect a Preconditions.checkNotNull(value, "Project name cannot be blank".
Is this the correct way to do this? I would expect a Preconditions.checkNotNull(value, "Project name cannot be empty".
Is this the correct way to do this? I would expect a Preconditions.checkNotNull(value, "Project name cannot be null").
Why isn't this object called waitForElementPresentInElementsAttributeByCss?
Why are we passing the value into the waitForValueToBePresentInElementsAttributeByCss?
Why isn't this object called inline?
This test can fail. I guess you meant to remove the first non-null test.
This test can happen often. I think you meant to do ignore.isAssignableFrom(manip).
This test can never happen.
What is the reason to define an MyQData class?
What about raising the exception from MyLoginException?
What is the reason to define an MyQDataException?
nit: no need for the new computed values since it is static.
nit: no need for the new check as it can never be null.
nit: no need for final and newBitrate.
There are utility methods in graph operators to get the kind of an operator invocation.
There are utility methods in graph operators.
There are utility methods in general.
Can't we just return ServletUriComponentsBuilder.fromCurrentRequest()?
Can we just return ServletUriComponentsBuilder.fromCurrentRequest()?
Can the requests with null?
It should be queuedQueries.decrementAndGet() at the end of this method, causing the issue to be refreshed.
It should be queuedQueries.decrementAndGet() at the end of this method, causing the query to be skipped because the queued queries may never be null.
It should be queuedQueries.decrementAndGet() at the end of query.
- first of all it is a map, not a list :) - I want to say it also for the display result.
- s/EmulatedMachine/EmptySnapshot
- s/EmulatedMachine/EmptySnapshot/
Does this need to be public?
Should this be wrapped in a try catch block?
Should this be wrapped in a try-finally block?
I'm assuming this method is combining the two maps? If so, didn't we just get the jobCoordinatorkBasePath from config? Do we need to keep it accessible everywhere?
I'm assuming this method is combining the two maps? If so, didn't we just get the jobCoordinatorkBasePath from config? Do we need to keep it remain in this particular case?
I'd suggest renaming this method to something like getkJobCoordinator(SystemBasePath, jobCoordinatorkBasePath, config).
This looks a bit strange?
This should be a Enforcer, not a boolean.
This looks a bit of a double check ;)
looks like in the place where you use the var, so it's not deterministic
I don't think we can use the reflection code here. Can we sold on the line without any parameters?
looks like in the place where you use the var, so it doesn't give you anything more readable.
Perhaps StringUtils.parseDoubleOrDefault would be better?
Should this be Path or String?
||
Too long
Too complex logic
Too long string concatenation
Should we have a null check for a non-null value?
Should we have a check for a null7\u4 directory in the users?
Should we have a check for a null7\u4 directory in the database?
Ah, lightweight way to use isSet(PRESERVE_AUTHORIATION_KEY) here. I think it should be done in its own helper class.
Ah, lightweight way to use isSet(PRESERVE_AUTHORIATION_KEY) here. I think it should be done in its own test class.
Ah, lightweight way to use isSet(PRESERVE_AUTHORIATION_KEY) here. I think it should be done in its own utility class.
didn't you want to add one more call to cmdLine?
didn't you want to override the 'public' class?
didn't we want to support this?
big, why are you creating a new ArrayList and not the iterator? Also, why do we do not store the result of this variable?
big, why are you creating a new ArrayList and not the iterator? Also, why do we do not store the result of the loop?
big, why are you creating a new ArrayList and adding the same elements when it's equal? Also, why are they different?
Cool that seems like a good solution
Cool that seems like a good solution but Modern Java does not need StringBuilder any more.
Cool that seems like a nice solution
The variable should be renamed to verifyMethod(" would be more meaningful.
replace with verify(targetMethods.isSet(method), times(1))
replace with verify(targetMethods.isSet(method), times(1)).
Feel free to ignore: Do we really want these this there?
Feel free to ignore: Do we really want these Version -> Version?
Feel free to ignore: Do we really need these this there?
"private" might be better to put this after theNeighbour.
"private" is not important and I think it would be better to put this after theNeighbour.
"private" is not important and I think it would be better to make theNeighbour.
Is it really a good idea to have a public constructor that takes a Comparable? It will be more general than the default implementation.
Is it really a good idea to have a public constructor that takes a Comparable? It will be more general than that...
Is it a valid b.
I'm not sure this is correct. The LayoutEditor would need to be reset when you're done. The LayoutEditor would need to be reset.
I'm not sure this is correct. The LayoutEditor would need to be reset when you're done. The LayoutEditor would need it.
I'm not sure if it's correct or not. The LayoutEditor would need to be reset when you're done. The LayoutEditor would need it.
"VN" -> "EN"
"Location" is a magic number, please extract to static method.
"VN" -> "TESTS"
i'd add "perform"
getMessage() and debug trace?
i'd add "perform failed"
Actually it is not enough to fail the Frankly.
Why not fail the Frankly?
I prefer fail-fastso first == 0
It could be just check for initialSchemes == null, but I'm not sure.
It could be just one line.
It could be just check for null, and throw an exception instead.
mFamilyName?
Maybe FamilyName?
Is this the param?
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "set" in com.vaadin.flow.demo.registration.ui.RegistrationForm.java:[rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "Thread.sleep()". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "set" in com.vaadin.flow.demo.registration.ui.RegistrationForm.java:[rule](<LINK_2>](<LINK_0>
This null check is unnecessary, File.getFile can return null.
This null check is redundant.
This null check is unnecessary.
Is it possible to return false in this case?
Is it possible to return false here?
Is it possible to return false to define the group of this?
Same as above:.getAllOfType(VDSType.forValue(-1)
Same as above:.getAllOfType(() -> dao.getAllOfType(-1)
Same as above:.getAllOfType(new SimpleDSType().forValue(-1)
Could we put this as a switch (selinuxEnforceMode == null) to avoid NPE?
Could we put this as a switch, even if it is null? And it seems to be a safe operation as there are no syntax to put into the switch.
Could we put this as a switch (selinuxEnforceMode == null)? So that we would be consistent with the switch.
could be simplified to: int c = 0xff; do { r = depth[p++] = shift; } while ((c & 0xff) << shift);
are we sure there's a constant for this?
could be inlined
Is there a better solution to this? It auto skips in the first place when you do that.
Is this better? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in memory when you do that.
rename to target
remove this
rename to child
IntermediateDataSetID has a param-less ctor I think.
please break this line into multiple lines.
please break this line into two separate methods.
you may want to use ParquetFileWriter instead.
you may want to use ParquetFileWriter here since it's a non-final field
you may want to use ParquetFileWriter here since it's a non-fatal
Why is this change necessary?
Why is the default method still necessary?
Why is the default method still throwing exceptions?
I'd move the algorithm parameters to the vanilla code so we get it from the DB, we are correct that the consumer of the library can change later on.
I'd move the algorithm parameters to the vanilla code so we get it from the DB, we can see it where to mess up the auth, and someone not adjust it from the surrounding diff.
I'd move the algorithm parameters to the vanilla code so we get it from the DB, we can see it where to mess up the auth, and someone not adjust it from the surrounding code.
No need to create temp file here, you can use try-with-resources
No need to create an empty file here since this can be moved to the finally block
No need to create temp file here, you can use "from testContent" to remove the file.
This can be replaced with Activity.setArguments(args);
This can be replaced with UVCDialog.setArguments(args);
This can be replaced with UVCDialog.setArguments(args); return dialog;
I am pretty sure this is in sync with the other code. Is that intentional?
I am concerned about how you delete this method. At some point I feel like to reduce the scope of this method, but I am not sure how to use it, wouldn't it be better to rename it to something like getAllWorkerDirCleanup? Then you can drop filter(...).
I am concerned about how you delete this method. At some point I feel like to reduce the scope of this method, but I am not sure how to use it, wouldn't it be better to rename it to something like originalCleaner?
this should be: return Ticker.class.getName();
this should use the ticker in order to check the return value
this should use the currencyPair.
I'm not sure this check is sufficient. The port itself does not check the port itself.
I'm not sure this check is sufficient. The same check is done here.
I'm not sure this check is sufficient. The port itself does not check the port's actual.
onVideoSelected() should be called here since you are onRewardedAdCallback is no longer used.
onVideoEventRewardedAdCallback is already set to null. Why do we need to skip this?
onVideoSelected() should be called here since you are onVideoCompleted().
should it be final?
(also change to)
(also change to final)
what are you trying to achieve here?
what are the reasons this is null?
what are the reasons this is checking?
Where is this constructor called? I don't see the signature for the input parameter.
Where is this constructor used?
Where is this constructor called?
Use.class.getSimpleName() instead.
Use the CacheUtil.
Use.class.
Isn't this the same as the other commit?
Isn't this the same as if (inputStream instanceof BlockCompressedInputStream) { return new AsciiLineReader(new BlockCompressedInputStream()); }
Isn't this the same as the other way around? I don't think it can be implemented.
Should this be: log.debug("Stopped %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: %s", failures.count(), failures.count());
Should this be: log.debug("Stopped %d failure: %d failure: %d failure: %d failure: {}", failures.size());
Should this be: log.debug("Stopped %d failure: %d failure: %d failure: %d failure: %d failure: %d failure: {}", failures.size());
Why is this method final?
Why are we creating a temporary component here?
Why are we creating a temporary state for the reason?
Should this be [this. prefix](<LINK_0> instead of [this. prefix](<LINK_1>?
Should this be [this. prefix](<LINK_0> instead?
Should this be [this.organisationIdentification="] as well?
Can we make this configurable?
Ccan we also make this configurable?
Ccan we also make this a constant?
We need to keep autoGenJarOutput prior to this change.
We need to keep autoGenCompilerOutput
We need to keep autoGenJarOutput and autoGenCompilerOutput.
I think this should be 'public static'.
I think it should be 'public static'.
Why do you use a list for the same monitor?
why introducing the blocks?
why introducing the blocks? Please do not use them in the tests.
Why introducing the blocks?
You should probably use synchronized here instead of synchronized (this)
You could probably just reset if it's not null
You should probably use synchronized here rather than synchronized.
I wonder if value.value() is a better name than value.
We should use assertThat(value, is(not(value)).hasSize(2)
we can use "value".
We should probably move this to the context variable, so it's not duplicated.
We should probably move this to the context variable since it's used just once
We should probably move this to the context variable since it's used just once?
Do you want to test that sequence number is greater than 0?
Do you want to test that the sender is valid?
Do you want to test that the sender is valid
Is this still needed?
Shouldn't this still lock if the lock is removed?
Shouldn't this be synchronized?
use Map.put()
use Map?
use Map.computeIfAbsent
Maybe add a check that exception is not thrown to close?
Please add a space after the close, like it was before.
Maybe add a check that close() is not called?
add it to slf4j to log
add it to description
Annotations
Is it going to be supersed? It seems to me that NestedFieldInitTypeResolver would be a better name.
Is it really worth doing this change? Should it be a static import?
Is it really worth doing this change? Should it be ((klass) == 0).
Add the shutdown hook to the'shutdown' field, to avoid any race condition.
Add the shutdown hook to the'shutdown' field, to avoid the need for AtomicReference.
Add the shutdown hook to the'shutdown' field, to avoid the need for AtomicReference here.
I think it's worth both of these.
I think it's worth having both the Disposable and dispose() methods in this class, so that it's only called once.
I think it's worth both of these DataProviders.
Would you mind extracting a bit of this into a private method?
Would you mind extracting a.getId() method to make it more readable?
Would you mind extracting a.getId() method to make this more readable?
I guess we can do it this way?
I guess we can do it this way? In any case, could we avoid introducing a new method in TDClientHttpException?
I guess we can ignore this boolean?
this can be declared private.
this can be declared private (but not the variables).
this can be implemented as m_is
You can use directly super(value, value)
You can use AssertionUtils.unencodeError().
You can use AssertionUtils.assertNull
Can you change this to LOG.info("Deleted called for deleted {}", path);?
Can you change this to LOG.info("Deleted called for deleted {}", path, e);?
Can you make this message more specific?
I think we could get rid of the empty line here.
I think we could get rid of the cast here.
I think we could get rid of the empty line in list.
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
The status of a pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify the new value, then update it to a different value, fetch again and verify the new value.
Why are you doing this? If you want to send a client error, it should be set in the constructor.
Why are you using a <code>this.getVaultUrl</code>?
Why never use Integer.toString()?
No need to do this.
Remove this.
Remove the if condition, the code is cleaner.
Use an String[] so we can collapse these into one
Use an String[] and avoid the pattern of the library
Use the String[] and is faster with a StringBuilder.
Can be @VisibleForTesting
Can be simplified to return getArtifactCoordinates(ox);
Consider @Nullable annotation
Can be simplified: this.tx = new ArrayList<>();
Can be simplified: this.txPaths = new ArrayList<>();
Can be reduced to this.tx.
Isn't the task parameters still field?
Isn't the task parameters still a String?
Isn't the task parameters in the constructor?
I think this should throw an unsupported operation exception instead.
I'm not sure this is really needed as compressedSize will have 0 lines before 175 and 43
I'm not sure this is really needed as compressedSize will have 0 lines before 43:46 and 43 line 634.
shouldn't it be named shouldThrottle()?
shouldn't it be...?
You can call.that() for this
What is the purpose of this change?
What is the purpose of this logging?
What is the purpose of allOf in close?
Please use same formatting as in the project.
Please use same formatting as in other files.
use containsKey
nested objects should be the first argument to convert(...)
nested template might be more meaningful
nested objects should be the first parameter
typo: of -> or
typo: it should be "**".
typo: it should be _.
You can use this.public ITimeEvent(long splitTime, long fDuration, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) );
You should use this.public ITimeEvent(long splitTime, long fDuration, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) );
You should use this.public ITimeEvent(long splitTime, long fDuration) here.
It might be better to filter out the isEnabledForMultipleContexts() condition to throw an exception, so that the isEnabledForMultipleContexts() condition is always false.
It might be better to filter out the isEnabledForMultipleContexts() condition to throw an exception, so that the isEnabledForMultipleContexts() never returns false.
It might be better to filter out the isEnabledForMultipleContexts() condition to throw an exception, so that the isEnabledForMultipleContexts() condition is enough.
Probably simpler as: this.initialEventPosition = EventProcessor.initialEventPosition();
Probably better to do eventPosition!= null, because it is creating an EventProcessor and gets the value.
Probably better to do eventPosition!= null, because it is creating a new EventPosition object.
I'm not sure this is correct. Could be if (obj instanceof BackendApiResource) { ((ApiApiResource) obj).getRSDLDL); }
I'm not sure this is correct. Could be if (obj instanceof BackendApiResource) {... }
I'm not sure this is correct. Could you please explain why the change?
elementSizeInBytes <= 0?
elementSizeInBytes
useless
oldValue should never be null; otherwise the merge function wouldn't get called.
oldValue should never be null; otherwise the merge function wouldn't return the same reference.
oldValue should never be null; otherwise the merge function wouldn't return the same reference;
Consider moving this return page.map( pf -> Profile.findProfilesInDirectory( fs, dir ) ).toArray( new Profile[]::new);
I think you should be able to merge the 2 for loops into one.
I think you should be able to merge the 2 stream calls here into one.
> return V2 * V3
> return V2 * V4
> return V2 * V3 == V3
Can we use this?
Can we have this as a field?
Can we have this as a constant?
A better approach would be to check whether the list is empty, not in this case.
A better approach would be to check ifuseDynamic is not null for use, e.g. in this case.
A better approach would be to check ifuseDynamic is!= null
Probably should be closed in this case?
Probably should be closed in finally block?
What happens if you call rawQuery directly?
Why not use org.jboss.as.test.Assert#debug("Registering event Loggers: {})?
Why not use org.jboss.as.test.Assert#assertEquals?
Why not use org.jboss.as.test.Assert#debug("Registering event Loggers: {}:{})?
use new names?
use new char[]?
use new name?
Please change the type to use the == operator and use it in the rest of the patch. It will make the code shorter and easier to read.
Please change the type to use the == operator and use it in the rest of the patch. It will make the code easier to read.
Please change the type to use the == operator and use it in the rest of the patch. It will make the code easier to read if you used the opposite.
variables are never used.
variables not needed.
for header statically imported?
Why always true for the current track?
Should we always true for the current track?
Why not just reuse the current track?
I don't think this is necessary for.orElse(null) and we can just do: return child.getType() >= tokenType && child.getType() == tokenType;
I don't think this is necessary. We can just use.filter(child -> child.getType() == tokenType && child.getType() == tokenType).findFirst().orElse(null);
I don't think this is necessary. We can just use.filter(child -> child.getType() == tokenType && child.getType() == tokenType)
Please move "org.myprocess.myprocess.DefaultDeployment(PROCESS_ID)" into a local variable and reused.
Please move "org.myprocess.myprocess.DefaultDeployment(PROCESS_ID)" into a local variable and use it in constructor.
Please move "org.myprocess.myprocess.DefaultDeployment(PROCESS_ID)" into a local variable and use here and in other tests.
please split into 2 lines
please split into 2 methods
Would it be better to define a private method with staff only?
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "this"; it is deprecated. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_0> 'Severity: MINOR') Remove this use of "this"; it is deprecated. [![rule](<LINK_1>](<LINK_2>
I am not sure if this is the best way to do this, but I think it is better to keep the map and clear the map, so that it is not added to the map.
I am not sure if this is the best way to do this, but I think it is better to keep the map and clear the tree
I am not sure if this is the best way to do this, but maybe it should be done as in the superclass and then to add the map.clear() method to the NodeMapImpl.values().
I would prefer this instead: Guid Guid = Optional.ofNullable(fToPfMapByHostId.class()), Guid.defaultQueryIsHostIdQueryParameters).map(QueryReturnValue::getReturnValue).orElse(Collections.emptyMap());
I would prefer this instead: Guid Guid = Optional.ofNullable(fToPfMapByHostId.class()), Guid.defaultQueryIsHostId(id)); return queryIsHostLockedOnNetworkOperation(Collections.emptyMap(), Guid.EMPTY, Guid.EMPTY));
I would prefer this instead: Guid Guid = Optional.ofNullable(fToPfMapByHostId.class()), Guid.defaultQueryIsHostId(id)); return queryIsHostLockedOnNetworkOperation(Collections.emptyMap(), Guid.EMPTY, Guid.EMPTY);
I think that the connection is never closed. For this reason, we should probably use a try-with-resources
I think that the connection is not closed. For this reason, if conn is null, we will end up with a NullPointerException.
I think that the connection is not closed. For this reason, if conn is null, we will end up with a NPE.
I think you meant to do!isTrim() || defaultValue!= null && defaultValue.trim().isEmpty()
I think you meant to do!isTrim() || defaultValue!= null && defaultValue.trim().isEmpty())
I think you need to do the empty checks here.
Why are we creating a new list? Wouldn't it be better to just return a variable?
Why don't we just return a list? Wouldn't it be better to use a variable?
Why don't we just return a list? Wouldn't it be better to use a variable for the iteration?
I would rename to hostSetupNetworksValidator, to be more explicit, similar to name
I would rename to hostSetupNetworksValidator, to be consistent with the other validations
I would rename to hostSetupNetworksValidator, to make it clearer that the parameter is the same.
"==" should be intended further to right, as it is not the same level of execution as "&&"
"==" should be intended further to right, as it is not the same level of execution as "=="
">=" should be intended further to right, as it is not the same level of execution as "&&"
please remove [Symbolic](<LINK_0>
You have to send every single AUTH_ERROR to the log, since it is the only messageId.
please remove parens here.
Use LOGGER.log(Level.FINE, "HTTP status")
Use LOGGER.log(Level.FINE, "HTTP status").
No need for this variable.
maybe you should also use UMI_BASE_USER_FORM_USER_FORM_EMI_BASE_EXPECTED_NMI_ED_UMI_USER_FORMLY_UMI_BASE_EXPECTED_NMI_ED_UMI_USER_FORM);
maybe you should also use UMI_BASE_USER_FORM_USER_FORM_EMI_BASE_EXPECTED_NMI_ED_UMI_USER_FORMLY_UMI_USER_FORMLY_UMI_ED_UMI_USER_FORMLY
maybe you should also use UMI_BASE_USER_FORM_USER_FORM_EMI_BASE_EXPECTED_NMI_ED_UMI_USER_FORMLY_UMI_USER_FORMLY_UMI_ED_UMI_USER_FORM);
Remove
Remove to call
Remove.
This test is duplicated below, but it may be possible to simplify it to something like: java FluentIterable<CustomerImages> customerImages = Matchers.stream().map(customer -> api.getCustomerImages().map(v -> v.getImageApi().getCustomerImages())).collect(Collectors.toSet()); assertEquals(customerImages);
This test is duplicated below, but it may be possible to simplify it to something like: java FluentIterable<CustomerImages> customerImages = Matchers.stream().filter(customer -> api.getCustomerImages().map(CustomerImages::getCustomerImages)).collect(Collectors.toSet()); assertEquals(customerImages);
This test is duplicated below, but it may be possible to simplify it to something like: java FluentIterable<CustomerImages> customerImages = Matchers.stream().map(customer -> api.getCustomerImages().map(v -> v.getImageApi().getCustomerImages())).collect(Collectors.toSet()); M<Container> customerImages = new FluentIterable<>();
Please add this error.
Maybe add this error message to the error log statement?
Maybe add this error message to the error
This adds the caps a second time.
This adds the caps a second time. The following change is not the best practice.
This adds a caps a second time.
I meant: return new StorageDeviceListReturnForXmlRpc(this.storageDevicesList);
What about using a constant instead of "GlusterHost.storageDevicesList"?
What about using a constant instead of "GlusterHost"?
You can use Long.valueOf() instead of new PollingTaskRunner(this.pollingInterval)
You can use Long.valueOf() instead of new PollingTaskRunner(this) in here.
You can use Long.valueOf() instead of new String() in here.
should be the parentId, not the name of the parent, it's the parent, so that the new values are always quarks from the start, and end, etc.
should be the parentId, not the name of the parentId.
should be the parentId, not the name of the parent, it's the parent, so that the new values are always quarks from the start, and the end time
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalsInstance?
Does it make sense to keep this class getInstance(Context c) and merge this with createGlobalsInstance?
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
I think this can be: return results.stream().collect(Collectors.toMap(this::address, this::getAll)));
I think this can be: return results.stream().collect(Collectors.toMap(this::address, this::address));
I think this can be: return results.stream().collect(Collectors.toMap(this::address, this::getAll));
I think we should use this.clazz = checkNotNull(clazz, "clazz");
I think this should use the Assert.notNull() for consistency
I think we should use this.clazz = checkNotNull(clazz);
Is it necessary to use debug level for this?
Is it necessary to use debug?
Is it necessary to make this an info log?
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
We should replace previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
We should remove previous call to setOnPageChangeListener a few lines above as it will be re- play here as well.
This is a BadCredentialsException.
This should be getToken()
This is a BadCredentialsException, which is not a supported exception.
Is it okay to ignoring the returned locations?
Can we keep the remove(id) method and use it here?
Is it okay to remove the add() here?
This is repeated multiple times, could we move it to a method?
This is repeated multiple times, could be worth making a static method.
This should be necessary, right?
Can we add method canContinue(cruiseConfig) to check the result?
Can we add method canContinue(cruiseConfig) that takes a Config object and returns the same reference?
Can we add method canContinue(cruiseConfig) that takes care of this?
I think it should return Array here
this should return Array here.
this.
I would suggest using ConverstionPatterns.MAP_REPEATED_NAME here as well.
I would suggest using ConverstionPatterns.LIST_name() instead of intValue().
I would suggest using ConverstionPatterns.LIST_name() instead of intValue()
You can use cacheManagerMock.getApplicationContext().getCacheManager().getCacheManager(). That will remove the need for cacheManager form.
You can use cacheManagerMock.getApplicationContext().getCacheManager().afterPropertiesSet()
You can use cacheManagerMock.getCacheManager().afterPropertiesSet()
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "kie-deployment-descriptor". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "kie-deployment-descriptor". [![rule](<LINK_1>](<LINK_0>
constant?
Use CalculationRequirements instead of CalculationRequirements
Use a constant
Use a constant instead of a magic number.
Add final keyword.
Can check if this is the right name
Can be removed.
@vilchik-elena Why is it needed?
@vilchik-elena why is it needed?
@vilchik-elena Why not send the action to the user?
Consider using String.format()
Consider using String.format here
Consider using String[] here
I just don't know if it is correct or not, but I think it is better to keep the sendToAffected method there. What do you think?
I just don't know why we have to check if the buffer is not null and just cancel the rest of the array. We just don't need to initialize the array.
I just don't know if it is correct or not, but I think it is better to keep the sendToAffected method private. What do you think?
unrun on container?
this should be refactored to be consistent...
unrun -> id
It's possible for a location to be null. I think StringUtils.equals would be better than location.equals.
It's possible for a location to be null. I think StringUtils.equals would be better than checking for null.
It's possible for a location to be null. I think StringUtils.equals would be better.
Why are all checked and unchecked exceptions being caught and ignored?
Why are all checked and unchecked exceptions being caught and ignored? It seems like the log message should be more appropriate.
Why are all unchecked and checked and unchecked exceptions being caught and ignored?
This should probably be checkState
this should probably be checkState
this is probably my fault :)
do we need to add a null check for LocalService for a parameter?
we should use a static import for LocalService for consistency...
do we need to add a null check for LocalService for a Module?
Please extract the braces into a method.
Please add braces, even when the statement is in the same loop.
Please add braces, even when the statement is executed on the same line.
The currentRowFilter is not null since we are using a com.google.gwt.safely.
The currentRowFilter is not null since we are comparing a whole set of RowFilter.
The currentRowFilter is not null since we are using a com.google.RowFilter.
Should we check if mzMLFile is null before trying to load it? It is possible to load all the images on one line.
Should we check if mzMLFile is null before trying to load it? It is possible to load all the images in one place.
Should we check if mzMLFile is null before trying to load it? It is possible to load all the images in one place. This code won't execute the code that does it.
Why not rename this line to maybeGameProfileData?
How about making this line a method instead?
Removing it will break you.
Should be "SecurityServicePostProcessRequestTimeInMs"
Should be "Security service is closed."
Remove timer.
You can use FiltersHelper.Constants.HEADER_AUTHORIATION here.
You can use FiltersHelper.Constants.HEADER_AUTHORIED_AND_ORDER_TAG
Please use FiltersHelper.Constants.HEADER_AUTHORIATION here.
Can this be removed?
This line should be removed
This line should be removed.
Codacy has a method for this, but I think it can be simplified to: public static void handleNewSession(final String sessionId) { return sessionId; }
Codacy has a method for this, but I think it can be simplified to: public void handleNewSession(final String sessionId) { this.public = sessionId.get(); final String sessionId = this.publicSession(final String sessionId);
Codacy has a NPE here, I think it is better to have a throw IllegalStateException than to rethrow it (in this case).
This is a Multimap, we perhaps don't want to use the key
This is a Multimap, we perhaps don't want to use the key?
This is a Multimap, no?
Return a SlaveDescriptor object here
Return a SlaveDescriptor here
Return a List
Here's an element.
Here's an element.add(new ProblemImpl(errorMessage, element.getName()));
Here as well, I think this method needs to be public.
This should be java } catch (RuntimeException e) {
This should be java } catch (Exception e) {
I would use warn.
can we initialize onMessage() with a name for the message?
shouldn't we guard against getRandomFoundCounter()?
can we initialize onMessage() with a different name?
This is still possible because the current assignmentFailures will not be reached after this.assignmentFailures.add(assignmentFailures).assignmentFailures();
This is still possible because the current assignmentFailures will not be reached after this.assignmentFailures.
This is still possible because the current assignmentFailures will not be reached after this line.
Please just use System.out.println's before the ombieData.
Please just use System.out.println's before the Sponge object.
Please don't use System.out.println(...) calls. Please remove them.
Should we log the potential error?
Should we log the potential error? Maybe we should log the potential error?
Should we catch the potential error?
this can be collapsed to a single if statement
this can be collapsed to a single if
this check is redundant.
Why not just pass the empty string?
Why are you not using else?
Why not just pass null?
Minor: it would be more clear to do: if (cached == null) { return null; }
s/public//
Minor: it would be more clear to separate the two cases (which we can make.
It would be better to catch RuntimeException and rethrow as IllegalStateException
It would be better to catch
It would be better to catch RuntimeException here.
You can just call this.public StandardBuilder.
You can just call this(public StandardBuilder.
Change this to: return this.public StandardBuilder.toFailure();
I think this can be private, so it could be overridden outside the class
I think this can be private, so it could be overridden outside the subclass
I think it should be fName.toString() here
use assertThat instead of assertEquals
add a message saying that exactly was invalid
add a message saying that exactly how fast this assertion fails
While you're here could you change this to: FileTokenizer.DEFAULT <LINK_0>
While you're here could you change this to: FileTokenizer.DEFAULT <T> String.format?
externalize?
I think you can use [TextView.class](<LINK_0> instead.
I think we can remove these 'final' modifier from constructor.
I think we can remove these 'final' modifier from constructor to keep consistency.
why do we need to check this?
why do we need to explicitly check the null pointer?
why do we need to check the null pointer?
I think this will be better written as: File f = new File(string); File f = new File(string, f); return f;
I think this will be better written as: File f = new File(string); File f = new File(string, "tdat"); return.createTempFile("sdat");
I think this will be better written as: File f = new File(string); File f = new File(string, "tdat"); return f;
Why has this validation been changed? Let's have: test case INVALID_NETWORK_NOT_SUPPORTED_PROFILE_PASSTHROUGH_PROFILE_Credit == 0
Can we fallback to the previous behavior? Please check that it's the same error message.
Can we fallback to the previous behavior?
do we need to filter out the roles?
let's do it using lambda approach
do we need to filter out the whole authentication type?
You can use path.endsWith("/")
Use path.endsWith("/")
You can use path.endsWith("/").SEPARATOR instead.
HQL/JP-QL
This should be moved to the if statement below
This should be moved to a new line above
Is it possible to extract a method for this line, i.e.: public void useClientCertificate(Object obj) {... }
Is it possible to extract a method for this line, i.e.: public void useClientCertificate(Object obj) {... }?
Is it possible to extract this into a method?
Should we do an Assert.assertTrue on the path being K?
Should we do an Assert.assertTrue on the path returned by.hasRouting()?
Should we do an Assert.notEmpty here?
Can we override this method to return true? The new method is not used anywhere else, so I'm not sure why it's removed.
Can we override this method to return true? The new method is not used anywhere else, so I'm not sure why it should be removed.
Can we override this method to return true? The new method is not used anywhere else, so I'm assuming these two lines can be removed.
That's wrong. It should be the first parameter to the regex.
That's wrong. It should be...
That's wrong. It should only be once and result.
Extract method and reuse
Extract method and use setProperties(List)
Extract method and use setProperties(endpoint)
Probably best to keep the EnvUtil.splitAtCommasAndTrim(links) same in the above
Please keep the style here.
And this one
we should not validate the hashToken here. remove validation in client
we should not validate the hashToken here. Instead of grabbing it from client
we should not validate the hashToken on client
**Couldn't we use PushImage.getClient().pushImageCmd()** here?
**Couldn't we use PushImage.getClient().pushImageCmd()** here?
**subRule**
nit: can we make this private?
nit: extra line
nit: can we make this method final?
The AbstractInstanceFactory is also often injected so it can be used in the constructor. Would be nice to have a static class that extends HazelcastInstanceFactory { @Override public void run() { HazelcastInstance hz2 = new HazelcastInstance(); hz2 = new HazelcastInstance(); @Override public void run() throws Exception { try { connectionManager.shutdown(); } catch (Exception e) { throw new HazelcastInstance(); } } }
The AbstractInstanceFactory is also often injected so it can be used in the constructor. Would be nice to have a static class that extends HazelcastInstanceFactory { @Override public void run() { HazelcastInstance hz2 = new HazelcastInstance(); hz2 = new HazelcastInstance(); @Override public void run() throws Exception { try { connectionManager.shutdown(); } catch (Exception e) { HazelcastInstance hz2 = null; } } }
The AbstractInstanceFactory is also often injected so it can be used in the constructor. Would be nice to have a static class that extends HazelcastInstanceFactory { @Override public void run() { HazelcastInstance hz2 = new HazelcastInstance(); hz2 = new HazelcastInstance(); @Override public void run() throws Exception { try { connectionManager.shutdown(); } catch ( Exception e) { HazelcastInstance hz2 = null; } }
Please have a constant for 0.
Please have a constant for packedVersion Strings
Please have a constant for packedVersion string
Do we need to add the Savings savings at the line 208?
dup. <LINK_0>
dup.
don't need this, the new RuntimeException will be thrown
what about making is not supported by the DB instance?
don't need this, the new RuntimeException will be handled by the protocol
IIRC, fboName is null the first time the fboName is null. We need to enforce that a non-null fboName is passed.
IIRC, fboName is null the first time the fboName is null. We need to rename the field of fboName to fboName.
IIRC, fboName is null the first time but I feel it's an NPE. In the second world I would have added a null check.
Is this supposed to always reset the crypto status? It's hard to check if phrasing is the same.
seems like this should always be false since isEnabled()
seems like this should always be false
StoreMode.DEFAULT_Mode and here as well.
CacheMode.NONE?
StoreMode.NONE?
You should use the method restartQQ() to get the url.
You should use the method restartQQ() to get the connection.
You should use the method restartQQ() method to get the color based on currentUrl.
You should special case the type name here to match the TypeName.
You should special case the type name here to lowercase TypeName.
You should special case the type name here to match the TypeName enum
I'm surprised it works on Travis, because of this.getEnclosingElement() == null -> getEnclosingElement().getKind() == ElementKind.CLASS
I think it would be easier to read if it were written like:.addType( enclosingClass.getEnclosingElement() == ElementKind.CLASS)
I'm surprised it works on Travis, because of this.getEnclosingElement() == null -> getEnclosingElement().getKind()
This should be <LINK_0>, right?
This should be updateMarkInfo().
This should be updateTime, right?
any reason for this method to be public?
any reason for this method?
any reason for this to be VideosModule
I think it would be useful to have log line
Can we move this condition to the top of the method, what do you think?
I think it would be easier to read if this if block could be moved inside the if block, right before the continue line.
remove empty line
remove debug log
remove debug log?
If this is an int, shouldn't we use Integer.compare(public Version, int) here?
If this is an int, shouldn't we use -1 (or -1) instead of 0?
If this is an int, shouldn't we use -1 (or -1) instead of -1 as this is a constant?
Can we please extract this into a method?
Can we please extract this into a method and call it from both test methods?
Can we please extract this into a method and call it from both places?
should this use note.getNote(position) instead of getPositionForNote(position)?
should this be note.getNote(position) instead of getPositionForNote(position)?
should this be note.getNote(newNote(position), note.get(0) instead?
It is better to have switch statement instead of case.
static import
static
should it throw exception if nothing is emitted?
should it throw exception if nothing is done?
should it be pending?
i don't think it should be the responsibility of the caller
i don't think it should be the responsibility to set the source
i don't think it should be the responsibility of the caller to set the source
Should use a final static variable.
Should use a final static variable
Should this be final?
This needs to return a completable future, not null
This needs to return a completable future. I think you should use a static field.
This needs to return a completable future. I think you should use a static method.
please use createdVolume
please use lambda style
please use getDbFacade()
This test does not seem to make sense.
This test does not seem to make sense. It may be NOT_INCLUDE_DEFAULTS
It would be better if these two lines were written to each test.
Could you add a NO_DATE_OFFSET; here to match the regular expression?
Could you add a constant to this Function<oneOffset, TimeoneOffset>?
Could you add a NO_DATE_OFFSET; here for consistency?
remove
remove this
remove these
Lots of duplicated code, so this is a no-op.
Name zone is missing?
Lots of duplicated code, so code here are better.
here we have GraphByTypeResolvingVisitor - it should not be here.
I think the expression here should be "input", not "type".
I think the expression here should be "input", not "type". And we have null literal here.
"for "
"public boolean"?
"for("
use waitAndClick() instead
add assert - when the test fails?
add wait() method to trim the compilation failure
Can't this be done via a framework?
Can't this be done once?
Can't this be List<String>
This one needs to be in a variable so you don't need to assign it again
This one needs to be updated in another file, so you will get the benefits of the increased complexity.
This one needs to be updated in another file
Do we need this?
Do we need to check it? If not, could we use the logger as well?
Do we need to check it?
this is a normal test. Just use Assert.assertEquals(image.tar(), "Can't find image after loading from a tar archive.");
this is a normal test. Please use try-with-resources.
this can be removed
presumably it should be method that you see in the getActivePage() method
seems like the getActivePage() should not be called here but should be removed from the method itself
presumably it should be method that you see in the DiagramEditor
This is changing to use @Test(expected = IllegalStateException.class)
This is changing to use @Test(expected = IllegalStateException.class) and the other tests here is not necessary.
This is changing to use @Test(expected = IOExceptions)
[minor] "container" can be renamed
[minor] "container" can be removed
[minor] "container" can be removed?
same here, and again: should be on the same line
same here, and again: should be on the last line
same here, this should be the exception from the thrown exception
This should be called on SpillableFinalOnlyGroupedAccumulator.
This should be called on LillableFinalOnlyGroupedAccumulator.
This should be called on L176.
same here. if BusReceivedMessage is null check will be more expensive.
same here. if BusReceivedMessage is null check will do.
same here. if () { return null; }
You should use [minecraft.getId](<LINK_0> here.
You should add to [this](<LINK_0> here.
You should use [minecraft class](<LINK_0> here.
This is not a good way to work with SkullOwner. They be different from <LINK_0>
This is not a good way to work with SkullOwner. They be different from <LINK_0> for a new PR.
This is not a good way to work with SkullOwner. They be different from <LINK_0> for old PRs.
Minor thing, but if we want to extract info.getCustomValue(final StatementInfo info, final Statement<QueryInfo> query) to a local variable and reuse it within the single statement.
Minor thing, but if we want to extract info.getCustomValue(final Statement) to a local variable and then use the variable in the else branch.
Minor thing, but if we want to extract info.getCustomValue(final Statement) to a local variable and then use the variable in the execute method.
I think you can do away with this new code: timeSinceTelescopeService = DateTime.now().plusHours(1).isBeforeNow(); Then you no need to startReporting()
I think you can do away with this new code: timeSinceTelescopeService = DateTime.now().isBeforeNow(timeSinceTelescope);
I think you can do away with the "if (timeSinceTelescope == t.Type.EQUIVAL) {" (telescope #endReporting)
please use System.out.println() instead of System.out.println
please use System.out.println() instead of system.out.println
please add assertion on System.out.println()
Is this cast necessary?
Is this casting necessary?
Is it cast to RuntimeException here?
add the 'this' keyword here.
add the 'this' keyword here...
add the 'this' prefix here.
nit: By.id("session".equals(elementClassNamePrefix)) could be a better name.
nit: By.id("session".equals(elementClassNamePrefix)) this is a bit confusing, as we are comparing it with "session" or "session".
nit: By.id("session".equals(elementClassNamePrefix)) could be a better name?
super.stop() on serverInventoryLock
super.stop() should only be called if the stop is active.
super.stop() on stop?
s.append(" * s)
nit: no need for a variable
s.append(" * s")
I'd make this return deserializer, without if (null!= deserializer) {... }
I don't think we should synchronize the deserializer, just to make it volatile?
I'd make this return deserializer, without if (null!= deserializer) { return deserializer; }...
same here, we should use a static list
use a static import here?
same here, use a static list
the workspace should be passed to the constructor.
there is a NPE in the Eclipse environment.
possible NPE
Will this not work with OS X? Shall we check for e.g. OS X and Windows?
Will this also work with OS X? Shall we check for e.g. OS X and Windows?
Will this not work with OS X? Shall we check for sure that looseApp.isFile() is called?
Same argument as with the DeadlineJob.
Same argument as with the DeadlineJob. This is weird.
Same argument as with the DeadlineJob
I'd do the following:.findFirstToken(TokenTypes.LITERAL_PUBLIC)!= null && modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC)
I'd do the following:.findFirstToken(TokenTypes.LITERAL_PRIVATE) && modifiers.findFirstToken(TokenTypes.LITERAL_PUBLIC)
I'd do the following:.findFirstToken(TokenTypes.LITERAL_PUBLIC)!= null && modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE)
Can we use the new TestingServer(boolean start) method to keep the test clearer?
Can we use the new TestingServer(boolean start) method? It would be nice to avoid the need for these null checks...
Can we use the new TestingServer(boolean start) method? It would be nice to avoid the need for the null tests.
The constant should be defined in a common place. You can extract the expression to a constant.
The constant should be defined in a common location. Java import static org.eclipse.core.util.Constants; if ((SHAPESOUT[])) { return; }
The constant should be defined in a common place. You can extract the constant for this.
I think it mayTracksChanged due to MediaPlayer L3008 in the same patch set.
I think it mayTracksChanged due to MediaPlayer L3008 in the selected patch set.
I think it may be better to return task data here.
Why use a StringBuilder here?
Why aren't you using the one from sysprep?
Why use a buffer here? Is it used anywhere?
I'd like to see the code of getting the directory cleanup, something like: private void deleteRecursively(@Nullable file, final Path path) { Stream<DeclaredIntentionToWrite declaredIntentionToWrite = new Stream<>(declaredIntentionToWrite, path, ImmutableList.of()); for (DeclaredIntentionToWrite : declaredIntentionToWrite) { @Override protected void deleteRecursively("/tmp directory cleanup", "staging directory cleanup"); } }
I'd like to see the code of getting the directory cleanup, something like: private void deleteRecursively(@Nullable file, final Path path) { Stream<DeclaredIntentionToWrite declaredIntentionToWrite = new Stream<>(declaredIntentionToWrite, path, ImmutableList.of()); for (DeclaredIntentionToWrite : declaredIntentionToWrite) { @Override protected void deleteRecursively("/tmp directory cleanup", "staging directory cleanup"); }
I'd like to see the code of getting the directory cleanup, something like: private void deleteRecursively(@Nullable file, final Path path) { Stream<DeclaredIntentionToWrite declaredIntentionToWrite = new KubernetesLauncher(declaredIntentionToWrite, path, ImmutableList.of(), path, ImmutableList.of())); }
Should we verify that we never call externalID?
Should we verify that we never call externalId()?
Should we verify that we never call ExternalId.create?
This will be NPE if the field is not set, with the UnsupportedOperationException or transientAttribute.
This will be NPE if the field is not set, in which case the constructor will be null
This will be NPE if the field is not set, with the UnsupportedOperationException or transientAttribute.getAttribute() method.
Make this: fail(printInvalidFunction(String textPattern, StandardErrorCode.class));
Make this java fail(e.getMessage(), e);
Make this: fail(printInvalidFunction(String messagePattern, StandardErrorCode.class));
java Map<AnnotationMapperReference, MapperReference> mapperReferencesForConstructor = mapperReference.stream().map( (AnnotationMapperReference) mapperReference ).collect(Collectors.toList());
java mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference )
java Map<AnnotationMapperReference, MapperReference> mapperReferencesForConstructor = mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference )
Consider to use a constant for this.
Consider to use same code consistently: return issue.equals(issueShouldNotBeReported(issue, excludedLinesByRule));
Consider to use same code as in the equals method.
Should we define a constant for this?
Should we use Objects.equals() here?
We usually use Objects.equals().
I think this is not the right place to catch this exceptions and log it
I think this is not the right place to initialize this
I would recommend to pull this out into a method which is more consise with the boolean
I think you should use Double.MAX_VALUE in this method.
I think it should throw an RuntimeException.
I think you should use Double.MAX_VALUE for this method.
@jdgarresonn Please fallback to Assertions.assertThat(new ArrayList<>()).add(Math.observable(status).
I would go for favoriteFolders
@jdgarresonn How about { this.status}?
throw NullPointerException with the cause.
throw NullPointerException to keep the old code.
throw NullPointerException to keep the old exception.
Please throw unsupported operation exception instead.
Please throw explicit message.
Please throw explicit message. It's not clear much.
Please change the name of the variable to error.
We should have a constant for this field.
Please change the name of the variable to match the condition.
It would be better to move this line into the MesosGenerator constructor.
It would be better to move this line into the StormSchedulerImpl constructor.
It would be better to use StormScheduler.getInstance() here, as the StormScheduler interface does not automatically get the currently selected list. We should append this to the constructor of MesosGenerator.
you can use method getUrlForWiki (so you don't need to add empty string for article path)
you can use method getUrlForPath (so you don't need to add empty string for article path)
you can use method getUrlForWiki (so you don't have to add empty string for article path)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
nit: we don't usually use final on method. (Also, as a side note: we don't usually use final for tmp variables)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for method)
It's a problem here. TRASHED_APPROVED. This way if a APPROVED Type TRASHED is set, it will always get a APPROVED
It's a problem here. TRASHED_APPROVED. This ReportingTracker should be set to TRASHED_AS_SPED. Is this intentional?
It's a problem here. TRASHED_APPROVED. This ReportingTracker should be set to TRASHED_AS_ON.
@Serranya There are many ways to use this instead of checking for the status code. It's a bit confusing to me, not the standard way to write it. What do you think?
@Serranya There are many ways to use this instead of checking for the status code. It's a bit confusing to me, not the standard way to write it. What if responses.contains("HTTP/1.1 400") or something like that?
@Serranya There are many ways to use this instead of checking for the status code. It's a bit confusing to me, not the standard way to write it. What do you think @Serranyamony Can you add a check for that?
Add the full exception to U.log, the SYSE0001 message is not very clear.
Add one more indent for start of 2 for loop
Add the full exception to U.log, the SYSE0001 message is not very helpful.
This fails the test, which is more deterministic. How about ImageType.GENERIC_IMAGE_ORIGIN?
This fails the test, which is more deterministic. How about ImageType.GENERIC_IMAGE_ORIGINATOR?
This fails the test, which is not the GENERIC_IMAGE_ORIGIN
iirc it's initialized in the ctor, check that it's not empty.
you already know that it is IMAGE, don't you?
you already know that it is Disk==DiskImage. Please remove the redundant checks.
why not search for "empty" user?
I was wondering if this isn't the right term to use our service for this. It's how it is used in other places.
Why here "join" and not "all"?
Why do you need the previous check here?
Why do you need the previous check?
Why do you need the previous line?
The existing putAll method is missing.
The existing putAll method is missing. I think the method can simply return a Map<String, Object>.
The existing putAll method is missing. I think the method can simply return a Map<String, Object>
Please create a constant for this.
Why is this needed?
Why not use urlForWiki() here?
@sekmiller This logic should be else if (getParameterDunningCampaignCode()!= null) { String parameterDunningCampaignCode = getParameter(DunningCampaignCode); if (getParameter(DunningCampaignCode)!= null) { // ArConstants.DEFAULT_DUMPL_PARAMETER_NAME, ArConstants.DEFAULT_DUMPID); }
@sekmiller This logic should be else if (getParameterDunningCampaignCode()!= null) { String parameterDunningCampaignCode = getParameter(DunningCampaignCode); if (getParameter(DunningCampaignCode)!= null) { // ArConstants.DEFAULT_DUMPL_PARAMETER_NAME, ArConstants.DEFAULT_DUMPID); } }
@sekmiller This logic should be else if (getParameterDunningCampaignCode()!= null) { // ArConstants.DEFAULT_DUMPID = getParameterValue"; }
I'm not sure if usingkillArgs.killArgs() makes the assertion error prone. Why not use a prefix for "killkillArgs" with an underscore?
I'm not sure if usingkillArgs.Capability makes the difference since it's in an endpoint of killArgs. Why not use a prefix for these?
I'm not sure if usingkillArgs.killArgs() makes the assertion error prone. Why not use a prefix for "killkillArgs" like "after usages".
hurtResistantTime is removed, should there be a cast to EntityLivingBase or something?
All above should be static.
this should be a public static int
Consider extracting this into a local variable.
Consider adding else if given that it's not necessary.
Consider adding null check.
This was not necessary, because you have added the addRowsFromFromTsvFile method which should not be called.
This is not necessary.
This was also removed in master
Can make this an else if since you are doing if'return' at the end of the method.
Can make use of the early returns here?
Can make this one line?
use URLBuilder instead
the original version suggests that there are spaces in the tab
put back
==
cannot you be sure that ss.queryOngoing() is not null?
cannot you be sure that ss.isEmpty() is not null here?
Add this.download(null, false).
Add this.download(null, null).
Add this.download(null, null);?
The clear() call seems unnecessary because it could just clear the deadWatchers map.
The clear() call seems redundant.
The clear() call seems redundant
suggestion List<String> results = results.stream().filter(this::isExtra).map(RecognizerIntent.EXTRA_RESULTS).filter(this::isExtra).collect(Collectors.toList());
suggestion List<String> results = results.stream().filter(this::isExtra).map(RecognizerIntent.EXTRA_RESULTS).collect(Collectors.toList());
suggestion List<String> results = results.stream().filter(this::isExtra).map(RecognizerIntent.EXTRA_RESULTS).filter(this::isExtra).findFirst();
What is the purpose of this change? The method should be static as well. Also, comparisons of the form "0". '90' should be used in '36-64'.
What is the purpose of this change? The method should be static as well. Also, comparisons of the form "0". '90' should be used in '36-28' which only used in this file.
What is the purpose of this change? The method should be static as well. Also, comparisons of the form "0". '90' should be removed from the name, but this method isn't used in the SurfaceProvider.
This can be simplified to return hasParent();
This logic could be simplified to return hasParent();
This logic could be simplified to return hasParent() || hasParent();
Please use containsOnly instead of contains otherwise looks good.
please use containsOnly instead of contains otherwise looks good.
use containsOnly instead of contains otherwise looks good.
should this be: newTime=" + baseTime + ", "LwM").toString() or something like that?
should this be: newTime=" + baseTime + ", "LwM").toString()?
should this be: newTime=" + baseTime + ", "LwM").toString() + baseName + extension?
if (signed) is enough. We try not to compare boolean variables to boolean constants.
if (signed) is enough. We try to avoid the "switch" block below.
if (signed) is enough. We try to avoid the "switch" branch where we have to compare boolean variables.
I would prefer : if (this.name == null) { this.name = attr.name(); } else { value = attr.name(); }
I would prefer : if (this.name == null) { AttributeSetTracker.remove(name); } return attr.toString();
I would prefer AttributeSet.EMPTY_STRING.
Can this be made into a constant?
Can this be replaced with: dx dx;
Can this be replaced with a dx for refactor?
_nit; _
Why did you add a _check for the text?
Argument class
Hmmm, shouldn't it be required? It should be stopped as BundleContextImpl.start()
Hmmm, shouldn't it be done when BundleContext is used? It also follows stop()
Hmmm, shouldn't it be done when BundleContext is used? It should also be in the BundleContext context.
warn
externalize
You should externalize the string
This should not be public
Unnecessary synchronized.
Unnecessary?
Please don't use Optional
Please use a final variable for the return.
Please use a variable for the name "enumValue"
Add a message to the exception to fail.
Add a message to the exception.
Add a message to the IllegalArgumentException
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
context#getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
We should avoid this build check, can use support library functions where possible.
You don't need this event logger and call eventLogger.showDialog(...)
You forgot to add this eventLogger.showDialog(...) to the end of the code, and the previous should be this.
You forgot to add this eventLogger.showDialog(...) to the end of the code.
Since this is a testing wrapper, I'm not sure we want to make it public here.
Since this is a testing wrapper, I'm not sure we want to make it public, we may want to make the client thread safe too to set the token to null here.
Since this is a testing wrapper, I'm not sure we should make it public here.
please use VmBase.libvirtName instead of getVmBase
how about to use VmBase#libvirtName?
please use VmBase instead of getDbFacade()
Now here we're checking removeSucceeded, not 'false'.
Now here we're checking removeSucceeded, shouldn't it be done before?
Now here we're checking removeSucceeded, shouldn't the end date be logged?
I guess you could add a method getVariablesByProcessDefinitionId(processEvent()) directly because it calls the getVariable() method.
I guess you can remove this local variable to processExtensionModel
I guess you could add a method getVariablesByProcessDefinitionId(processEvent) directly since it calls the getVariable() as well
please rename to ReactorClient
please change this to store the replacement of this map.
please inline this variable
The statement is confusing here - we are logging the failure, but it doesn't seem suitable to me, and if I'm missing something, why don't you call cleanupPassthroughVnics? Currently, it looks like you're doing something similar to the following: boolean failedVnics = false; try { cleanupPassthroughVnics = true; } catch (EngineException) { cleanupPassthroughVnics = false; } catch (EngineException e) { cleanupPassthroughVnics(e); } cleanupPassthroughVnics(e); }
The statement is confusing here - we are logging the failure, but it doesn't seem suitable to me, and if I'm missing something we don't catch it, why do you log it?
The statement is confusing here - we are logging the failure, right?
Do we need to make this method public?
Do we need to make a new 30000 here?
Do we need to change this method?
You should use REQUEST_STATUS_REPORT as the default value for this method.
You should use getRawElasticAgentExtensionConverterV2 instead of the default implementation.
You should use REQUEST_STATUS_REPORT as the default value
shouldn't we use url for this?
can we use url for this?
can we use the url in if scope.
wait for element
wait for element before click on it
wait for element before click
I think you can keep this as TYPE.DECLARED_METHODS on the matter of taste, but I wouldn't think.
I think you can keep this as TYPE.DECLARED_METHODS on the matter of taste, but I wouldn't.
I think that peekType should be a separate TokenType type instead of TokenType.TYPE.DECLARE
And this one
And this one, please.
And this one.
Optional: I very much prefer to catch ErrorCode and then rethrow it as a runtime exception. It will also make logs easier to see when there is a problem with other error messages.
Optional: I very much prefer to catch ErrorCode and then rethrow it as a runtime exception. It will also make logs clearer if you create a factory for this.
i.e. catch (Exception | IllegalAccessException e)
suggestion assertThat(got).contains("Description");
suggestion.contains("Description") || (got).contains("Description");
suggestion.contains("Description");
I don't think synchronized does anything here.
I don't think this is the right place for a CompletableFuture.completedFuture(null);. This does the same thing.
I don't think this is the right place for a CompletableFuture.completedFuture(null);. This is a little confusing, as it does the same thing.
please use assertEquals instead of assertEquals
please use assertFalse instead of assertEquals
please change to assertEquals(findAllUsers(), findAll())
Parsing xpath expressions is not error prone. Could this be simply done so that it does not break the loop later?
Parsing xpath expressions is not error prone. Could this be simply done so that it does not break all the parsing logic?
Parsing xpath expressions is not error prone. Could this be simply done so that it does not break all the parsing logic that is met?
We should not use assertTrue here, as it is a failure message.
We should not use assertTrue here, since it is a failure message.
We should not use assertTrue here, as it is a good practice in tests
no need to cast the field here, just use this.s.
no need to cast the methodProxy, just do this: java private Object methodProxy methodProxy;
no need to cast the method backing
As you already need to touch this file, I think this empty line could be removed.
As above, I think this empty line could be removed.
As you already need to touch this file, I think this empty line can be removed.
StringBuilder would be better here.
You are missing spaces in the += operator.
Long Long
Perhaps try to make this method synchronized?
close(this)?
close()
As we're going to use streams, I think it'd be better to use StreamUtils.stream() instead of a stream.map().filter(avEntry -> sagaType.isAssignableFrom(avEntry.getValue()))
As we're going to use streams, I think it'd be better to use StreamUtils.stream() instead of a stream.map().filter(avEntry::getValue).map(avEntry::getKey)
As we're going to use streams, I think it'd be better to use StreamUtils.stream() instead of a stream.map. That will allow a single stream to be used here.
Component can't be null here, so it would be more clear to use an Optional<String> instead.
Component can't be null here, so it would probably be easier to read if this is null.
Component can't be null here, so it would be more clear to use an Optional<String>.
Same as above, just put the ______TS("Not enough parameters");
Same as above, just inline the ____TS(...) test method.
Same as above, just verify htmlParameterFailure() and verify htmlParameterFailure().
Does it make sense to add a parameter to the super class in the case of RelNode?
Does it make sense to use [replacement_MAP_NAME](<LINK_0> instead?
Does it make sense to use [replacement_MAP_NAME](<LINK_0> to handle this case?
Can use ImmutableList.of(Integer)
Maybe a stupid question, but why isn't the diamond operator here?
Can use ImmutableList.of(Integer) instead of Arrays.asList("");
remove @Nullable
remove
remove @Nullable?
Shouldn't this be setRewriter() method to prevent the same value?
Shouldn't this be setRewriter() method to prevent the same copy of the list?
Shouldn't this be set to false?
Should use the context stringValue instead of this.
Should this method return Mono<String> instead?
Should use the context stringValue here as it's a static variable.
why not using getVdsGroupCompatibilityVersion?
why not use getVdsGroupCompatibilityVersion()?
osRepository is not used - please use getVm() instead
Please, reuse your extracted method for checking if a file is an Erlang source file.
Please, reuse Java 8 for checking if a file is an Erlang source file.
Please, reuse your extracted method for checking if a file is an Erlang source file?
Just to make the code more readable, I'd move the common logic that you have here as well.
Just to make the code more readable, I'd move the common logic that you have here as well..buildNext(chargeEntity, chargeEntity) to a separate method for readability
Just to make the code more readable, I'd move the common logic that you are using in two places for the same parameters.
1. Please mark methods as final. They are not final. 2. Remove the public modifier and make it final.
1. Please mark methods as final. They are not final. 2. Remove the public modifier from the method.
1. Please mark methods as final. They are not final. 2. Remove the public modifier and make it final here.
The try-with-resources aren't needed here.
You need to close the stream here.
You need to close the stream.
It would be better to make this constructor private and have clients use the other constructor. That way, we don't need to public constructor.
It would be better to make this constructor private and have clients use the following signature: public OffHeapServerStoreImpl(PortStoreConfiguration storeConfiguration, PageSource pageSource) { this(pageSource, 16); }
It would be better to make this constructor private and have clients use the following signature: public OffHeapServerStoreImpl(PortStoreConfiguration storeConfiguration, PageSource pageSource, 16);
Why don't you check here that the type of the object is resource and not the string?
Why don't you check here if the type of the object is bad, instead of a string list?
Why don't you check here that the type of the object is bad, instead of a string list?
Should be replaced with with lowercasePolicy
Should be replaced with with StringBuilder
Should be replaced with {}
Can be && size == 0
Can be written as return size == 0 || size > 0
Can be written as return size == 0
"assert false" will always fail. I think this is because this is a mistake.
"assert false" will always fail. I think this is because this is a mistake?
"or" should probably be a constant.
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push"."
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push" the REF_CONFIG"."
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push this entry use 'Submit' rights on push"."
Please do not use Long here. I think it makes sense to return null.
Please do not use Long here. I think it should be primitive long.
Please do not use Long here. I think we should use Long and check here.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'defaultSwitchType' as a parameter.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'defaultSwitchType'.
I don't think this is necessary, as the callback is already called in the callback.
I don't think this is necessary, as the OkHttpResponse already does that.
I don't think it's a good idea to just create the Retrofit object. That way it is easy to lose the response code.
we can move this (I guess) inside the if (object == null) block, and just return true here
we can move this (I guess) an init() method in ListModelListBoxEditors. Please move it to a static method and reuse it.
we can move this (I guess) an init() method in ListModelListBoxEditors. Please move it here and have it just a one-liner
Same question as above : is this method needed?
Same question as above. Just a note: We can't do this operation in the constructor. Same as below.
Same question as above. Just a note: We can't do this operation in the constructor. Same below.
The leaseId is not used, so it should be removed from the leaseId
If it fails the leaseId is not set to null, better to log it and avoid typos.
The leaseId is not used after this statement.
Check error code/description
Check NPE
Check NPE here.
Duplicated code.
Small nitpick: Could it be replaced with org.wildfly.microprofile.event.impl.ResourceRegistration.class.
Small nit: Could it be helpful to validate capabilities with optional requirements?
Check for equality of error code
You could use directly create the list that throws the exception
You could use directly create the list to save at the next iteration.
I think this should be changed to: java try (File defragmentedPartFile = defragmentedPartFile.exists()) { handleIoException(e); return defragmentedPartFile(workDirIC_MOVE); }
I think this should be changed to: java try (ByteArray try (File workDirIC_MOVE = new Ignite(workDirIC_MOVE, partId)) { handleIoException(e); return; }
I think this exception should be removed.
I am concerned that we might want to add some logging here to indicate that the stream is closed or not.
I am concerned that we might want to add some logging here to indicate that the stream is being closed.
I am concerned that we might want to add some logging here to indicate that the stream is unknown?
This should probably be containsKey()
This is not really needed. You should always use.substring() when creating the String
This should probably be.else if
setup of getArguments() is deprecated and should be removed to avoid any confusion.
setup of getArguments() is deprecated and should be removed to avoid misusage in tests.
space after if
why do you use a mock here?
why do you use it?
why do you need it?
please use for the simplicity of the test.
please use for the simplicity of the test
you can use here assertEquals
I am not a fan of isDebugEnabled() if debug is enabled.
I am not a fan of isDebugEnabled() since we know that we are not logging anything.
I am not a fan of isDebugEnabled() since we know that we are not logging any string.
Can we wrap this with Bytes.toBytes(slice.getBytes()) or should it be > 0?
Can we wrap this with a try/catch like so: try { return buffer. read(..., buffer.length); } catch (RuntimeException) { return null; }
Can we wrap this with Bytes.toBytes(slice.getBytes()) or should it be > 0?
Nit: "Creating ephemeral nodes..."
Nit: "Create ephemeral nodes..."
Reword the exception message.
protected?
protected? Or package private?
protected? Or can we have protected access?
why is this public?
why is this constructor private?
why is this a public constructor?
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
It allows overriding config files by placing them into /etc/sw360
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into a /etc/sw360
nit: this.json = checkNotNull(json, "json");
nit: this.json = checkNotNull(json, "json")
nit: this.json = checkNotNull(json);
wait.forElementClickable() should be used before
this should be WebElement.deleteLinkByLink(...)
this should not be deleted
return a more specific exception than IOException
return a more specific one, is it possible to do that?
return a more specific exception than IOException here?
I'm concerned about the purpose of this line. The else statement above it is right?
I'm concerned about the purpose of this line. The else statement above it seems to be wrong.
I'm guessing we can remove this line.
@vilchik-elena The new tree should be created new translatable
@vilchik-elena The new tree should be created new test.
@vilchik-elena Why not make newCompilationUnitTree() return new EntityTree[] {newCompilationUnitTree(tree)); }?
We need to include the product's id in the error message.
We should have a unit test for the product, name, and the product id.
We need to also test this product.
can we use logger here
can you use logger here
can you use logger here?
Is this parameters really mandatory? I thought its default was false.
Is this parameters really mandatory? I thought its default was true.
Can we use JobParametersNames.INPUT_ID, JobParametersNames, JobParametersNames, White and same file in the same file?
Missing validation for epochMillis.
Missing validation for epochMillis?
Missing synchronization.
please use 'guid' instead of new GuidFromString(model.getReturnValue())'.
1. please use 'guid' instead of new GuidFromString(model.getReturnValue())'. 2. please use 'guid' (which is already a field in 'guid')
1. please use 'guid' instead of new GuidFromString(model.getReturnValue())'. 2. please use 'guid' (a 'guid' is a new instance) and use it.
This test is wrong, check that the expected exception gets thrown using the @Test annotation
This test is wrong, check that the expected value is not the one you expect
This test is wrong, check that the expected value is actually the one you expect and you are testing here
I think it would be better to make it protected (and any other method below) to avoid code duplication.
I think it would be better to make it protected (and any other method below) to avoid coupling between members.
I think it would be better to make it constructor protected (and the field is final)
Is this keeping of already modified by a copy of the buffer?
Is this keeping of already modified while we're in the super class?
Is this keeping of already modified while we're in the super class
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. pipeline....
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on?
Can we roll this into configToManager.get instead of config?
All text node should be updated after the return statement.
All text points to user_id in name should be updated.
All logs are with different exception messages.
You should also lazily initialize the exclusionList with an empty array.
You should also lazily initialize the exclusion list and cache it.
You should also lazily initialize the exclusionList in L8 and shared when exclusion is most likely a bad practice.
I'm not sure if throwing an exception is the best place to catch it. The code will fix the checkstyle, I think it'd be better to throw a forward exception and let the calling thread handle the exception.
I'm not sure if throwing an exception is the best place to catch it. The code will fix the checkstyle, I think it'd be better (and it's totally reasonable to fail with this).
I'm not sure if throwing an exception is the best place to catch it. The code will fix the checkstyle, I think it'd be better (and it's totally reasonable to have a line break before the if).
Can't we just use object.isMergeable() here? Or are you sure that the former code is more reliable?
Can't we just return object.change(dbProvider) here? Or are you sure that the caller is always returning null?
Can't we just return object.change(dbProvider) here? Or are you sure that the caller is always sending in the path?
Is the anyMatch condition really needed?
Is the anyMatch condition really necessary?
Is the test a little bit quicker than the previous?
I can't think we can do this: String render = getSizeInGigabytes(sizeInGigabytes); if (isUnavailable(sizeInGigabytes)) { return Double.valueOf(sizeInGigabytes); } return sizeInGigabytes;
I can't think we can do this: String render = getSizeInGigabytes(sizeInGigabytes); if (isUnavailable(sizeInGigabytes)) { return Double.valueOf(sizeInGB); } return sizeInGigabytes;
I can't think we can do this: String render = getSizeInGigabytes(sizeInGigabytes); if (isUnavailable(sizeInGigabytes)) { return Double.valueOf(sizeInGB); } else { return sizeInGigabytes; }
Is it possible, that the context is null?
Is it possible, the context is null?
Is it possible, that the context is null here?
more precisely: java static String substring(String rawMessageHref) { return rawMessageHref.substring(rawMessageHref.lastIndexOf('/') +substring(rawMessageHref)); }
more precisely: java static String substring(String rawMessageHref) { return rawMessageHref.substring(rawMessageHref.lastIndexOf('/') +substring(rawMessageHref.lastIndexOf('/') + "\\."); }
more precisely: java static String substring(String rawMessageHref) { return rawMessageHref.substring(rawMessageHref.lastIndexOf('/') + "\\."); }
Objects.equals()?
Other braces aren't needed.
Other braces aren't needed?
So - /var/tmp/src/test/resources/org/apache/files/user/conf/util/FileUtils.java?
So - /var/tmp/src/test/resources/org/apache/files/user/conf/util/FileUtils.java:1581
So you left this change?
I don't think that to be set to null here
I don't think that to get a reason to set the V value here
I don't think that to get a reason to set the email to null here
Is this the default implementation of LiteralExpression?
Could these be a static import?
Is this the default implementation of this method on purpose?
since fields are provided, simplify this class, Objects.equals() will also work: suggestion Objects.equals(this.getName(), other.getReference());
since fields are provided, do you think we need to check the type here?
since fields are provided, do you think we need to check the type here? <LINK_0>
@vilchik-elena We should not is a abstract method for this.
@vilchik-elena We should not is a abstract Kind.FLOAT_LITERAL here.
We should not support null expressions.
You could remove the empty line
You could remove the auto-boxing and auto-unboxing
You could remove the auto-boxing and auto-generated code
Shouldn't this timeout be value in a constant?
Shouldn't this timeout be a constant?
empty line
@fanifieiev the same above.
@fanifieiev the same above can be replaced with RsWithStatus(res, () -> RsWithStatus.head(res, rsn), r.body())
@fanifieiev the same above can be replaced by RsWithStatus.merge(res, () -> RsWithStatus.head(res, rsn), r);
Danger. I don't think we need to check if it exists: Android.VERSION_CODES.M2 and need to check if it exists.
final
Danger. I don't think we need this check.
Is it really necessary to use dynamicParam.getType()?
Is it really necessary to use cast()?
Use { } for statement.
Not sure that it matters much, but the scheduler is passed to the backend.
Not sure that it matters much, but the scheduler is very generic. Perhaps we should call it something like "getEntity()"?
Not sure that it matters much, but the scheduler is initialized in the command is already initialized.
In the original version of the loop, we might want to implement this method on the "private" side.
Consider renaming i to something like Index.
In the original version of the loop, we might want to implement this method on the IndexCodeMirror instance.
Use Logger instead.
Use Logger instead of sysout
fix
Consider making this a method. It will return VdsEventListener.getAllVdsAddressForOverriddenHostsAreMismatchedVds().
Consider making this a method. It will return VdsEventListener.getAllVdsAddressForOverriddenHostsAreMismatched()
Consider making this a method.
Exception#printStackTrace goes to stderr by default.
Exception message should be logged instead of e.printStackTrace
Exception is never thrown.
The else is redundant and should be removed.
The problem here is that the spec doesn't map the headers. In that case, we shouldn't need a null check.
The problem here is that the spec doesn't map the headers. In that case, we shouldn't need a null check here.
Curious why you're building a list of languages to string.
sb.append("PICPICPICPICPIC");
sb.toString()?
it may be better to call it all the time
it is better to call it all the time
it should be public
This is currently unnecessary. The method will be called only once per representation.
Why not directly use the stream?
This is (relatively) costly, and could be moved out of the loop
I'd simply use the property changed event in the propertyChanged event rather than here.
I'd simply use the property changed event in the propertyChanged event rather than the property changed event.
I'd simply use the property changed event in the propertyChanged event rather than the setter.
scaledData, thread safety and all
scaledData, if this is exposed by the T=null.
scaledData, thread locals and all
Shouldn't this be null?
Should it be null?
Should we move this logic to the sensor methods?
If gpIn!= null is enough, the second assignment will fail.
If gpIn!= null, the param will be used. So do: geo = null; try { gpIn = geoIn; } catch (RuntimeException e) { // do stuff }
If gpIn!= null, the param will be true.
I think it would be simpler to have dedicated SolrQuery method for this.
I think it would be simpler to have dedicated SolrQuery method for this. What do you think?
I think it would be simpler to have dedicated class for storing deque and casting both would be useful here.
I'm not sure this is the right thing to do. It should be a set to avoid any false positives.
I'm not sure this is the right thing to do.
I think this should be a set.
Why not return ResponseType.Status.BAD_REQUEST?
You should return a ResponseType for the status.
You don't need this, StatusType is a ResponseType
@cvrebert why we don't use it here?
@cvrebert why we don't use randomAlphanumeric here?
Let's avoid code duplication.
rename tempVar
initialize tempVar
declare final
Is this method needed? You can use the default value of darkThemeDisabled.
You can use the default value of darkThemeDisabled.
You can use the default value of darkThemeDisabled.get() instead of disabled=true
Extra trailing comma.
Extra trailing comma?
Extra trailing comma
String
log
File
Does this need to be a static string?
Does this need to be a string?
Does this need to be a string literal?
Revert this - please rebase, <LINK_0>
Can we remove this catch block?
Revert this - remove?
This seems to be removed.
This seems to be hardcoded.
This seems like a bit too long.
The else if block returns true - the result is true. This should return false if the expression is (not a boolean).
The else if block returns true - the result is true. This should return false if the expression is a precondition. However, if it is false, it is true, otherwise it will return false.
The else if block returns true - the result is true. This should return false if it is a preconditions check.
To follow the rest of the PR, I would suggest putting the ByteBuffer.slice() in a try/finally block: java ByteBuffer slice = decode(byteBuffer, CharBuffer decode); ByteBuffer buffer = decode( ByteBuffer.slice()); ByteBuffer slice = decode(slice); if (byteBuffer.position() == limit) { ByteBuffer buffer = decode(slice); buffer.position(byteBuffer.position() + size); buffer.position(); }
To follow the rest of the PR, I would suggest putting the ByteBuffer.slice() in a try/finally block: java ByteBuffer slice = decode(byteBuffer, CharBuffer decode); ByteBuffer buffer = decode( ByteBuffer.slice()); ByteBuffer slice = decode(slice); if (byteBuffer.position() == limit) { ByteBuffer buffer = decode(slice); buffer.position(byteBuffer.position() + size); buffer.position(); } return limit;
does this need to be public?
Could you change this to NormalizeFunction<NormalizeFunction>?
Could you change this to NormalizeFunction<NormalizeFunction<Double>>?
Could you change this to NormalizeFunction0(score) + 1?
[minor] I'd rather use matcher.matches instead of matcher.matches() here.
[minor] I'd rather use matcher.matches() instead of matcher.matches() here.
[minor] I'd rather name this like lineOffset to make it more clear
Make this a private static final field
drop the StringUtils.trim() call?
String.valueOf()
Could be reduced to private static final at the top of the file.
Could be reduced to private static final at the top of the class.
Could be reduced to private static final prettyPrint(JsonProcessingException e)
could you make the end of the sentence a bit more explicit?
could you make the end of the text a StringBuilder and not use it for each format?
could you make the end of the sentence a bit more explicit? It might be "Suppressing a total of %d"
@demsey shouldn't this instead be: [thread-safe](<LINK_0>
@demsey shouldn't this instead be: ThreadPoolExecutor<SynchronousQueueUtils>
@demsey shouldn't this instead be >=?
Why still need to include the active thread in the constructor, and if it's null, then we can avoid having to handle it.
Why still need to handle synchronization here?
Why still need to include the active thread in the constructor?
Java 7 only - inline.
Another way to get the array each time, a non-null array is created (same for arrayObject)
Another way to get the array each time, a non-null array seems to be used, is it?
should be the same with the one on the config
Minor: consider having a static method that returns the config map with the same name.
Minor: consider having a static method that returns the Stream/Stream one
space after,
Why 2's magic?
Why 2?
The error message should probably be more accurate, something like "No otted allowedClass.reason().isOneOf(MUTABLE_TYPE_TO_FIELD) && locationDetail.reason().isOneOf(MUTABLE_TYPE_TO_FIELD); (Same below)
The error message should probably be more accurate, something like "No otted allowedClass.reason().isOneOf(MUTABLE_TYPE_TO_FIELD) && locationDetail.reason().isOneOf(MUTABLE_TYPE_TO_FIELD);
The error message should probably be more accurate, something like "No otted allowedClass.reason().isOneOf(MUTABLE_TYPE_TO_FIELD) && locationDetail.reason().isOneOf(MUTABLE_TYPE_TO_FIELD); (probably a call to hasState)
An alternative way to look for this: CPPQualifiedName.get(member)
An alternative way to look for this: CPPQualifiedName.getImport(model)
An if-else would be clearer here?
File.tearDown() throws an exception for missing file
File.tearDown() throws an exception for any reason.
File.tearDown() throws an exception for missing file not found
this.
inline
Inline this
There are two places where this method can be called. Is it worth checking if there are more than one value or the other?
There are two places where this method can be replaced by a method.
There are two places where this method can be called. Is it worth checking if there are more than one value, or the other one?
Why JobStartupDependentResource?
I think we can move the wording of the sentence to a separate line for readability.
I think the wording of the sentence could be removed since we already have the full wording.
You could have implemented the generic way in GerritClient.java as well.
You could define the options in the base class.
You could have implemented the generic way in GerritMultipleAction.
Mappers are pretty much the same. It would be nice to extract the createValidator() logic into a separate method and use it here.
Mappers are pretty much the same. It would be nice to extract the createValidator() logic into a separate method and make it private.
Mappers are pretty much the same. It would be nice to extract the logic into a separate createValidator() method and make it private.
extract to constant
extract the size of clusterBarcodeIndices and keep it empty
extract the name to getName()
nit: you could use Collections.synchronizedListCasts() here
nit: you can use Collections.synchronizedListCasts() here
nit: you can use Collections.synchronizedList(new ArrayList<>()
This should be: java if (data instanceof IConfigurationElement) {
Another occurrence of data is added here.
Another occurrence of List
Shouldn't this be changed to "createApplication"?
Shouldn't this be a Exception?
Shouldn't this be caught?
These tests should have an @Override annotation.
These tests should have an @After annotation for the domain status.
These tests should have an @After annotation for the domain (user, name)
should we also synchronize on this and return a ConcurrentMap rather than null?
should we also synchronize on this and return a ConcurrentMap instead?
should we also synchronize on this and return a ConcurrentMap rather than null?
I don't think we need this line
I don't think this is a good reason to use virtualHost
I don't think this is a good idea.
- [x] Remove the try block?
- [x] remove the try block?
Use assertion method
Can we catch the specific exception here?
Can we catch this exception here?
Can we do: if (StringUtils.isNotEmpty(cipher)) {
I might have missed something here, but I don't know if this is a problem, so I must be missing something.
I might have missed something here, but I don't know if this is a problem, so I might want to make the conversion explicit during construction, e.g. public instead of protected.
I might have missed something here, but I don't know if this is a problem, so I might want to make the conversion explicit around the PersisterAdapter call. I would say. You could have a a custom aggregator function that takes the input parameters as a parameter.
This can be simplified to just this.init(model, model);
This single-line block could be simplified to just: if(getWindow()!= null) { return; }
This can be simplified to just this.init(vm, pool);
Does this need to be static?
Does this need to be public?
How about java return gitSystemConfig.hasdiscoverPullRequestsFromOrigin();
Multiple method(*) methods
redundant method("POST")
Maybe you can use method(*) methods
Can you check that this method exists on the client?
There is already a repository with this.
Can you check that repository is not null?
This condition could be simplified to java if (currentSystem.isenithCharge() && currentSystem.isenithCharge()) {
This condition could be simplified to if (!currentSystem.isenithCharge()) {
This condition could be removed.
You need to assert that unvoid is not null
You also need to assert that unvoid is not null
You also need to assert that the patient is not null
nit: <LINK_0>
suggestion buf.release(); Blackhole.release();
suggestion buf.release();
This isn't right? moveToFirst returns just a boolean, so we know it's going to return null
This isn't right? moveToFirst returns just a boolean, so we know it's going to be written!
This isn't right? moveToFirst returns just a boolean
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
getNodeStart() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails, the assert in the benchmark fails.
Maybe 'updateNetworksCommand' or 'getSelectedNetworksCommand'?
I think you should also call'setHashName' here.
Maybe s/new UIActionCenter().getInstance().getConstants().getInstance().getConstants().centerName()
I think this should be: flushPredicate(flushPredicate, flushPredicate)!= null
I think it is safe to call flushIfNeeded inside the finally block. Let's discuss offline
I think it is safe to call flushIfNeeded inside the finally block. Let's discuss offline.
Should be getText(element)
rename to element
"Element selection" -> "Element selection"
Why do we have to use entityConfiguration here?
Why do we have to use entityConfiguration here.
entityConfiguration = null;
this default value should be on the CLIGitCommand.execute().
this line could be reverted
this default value should be on the same line.
This isn't used at all. We should remove the resourceText parameter by throwing an exception.
This isn't used at all. We should remove the resourceText parameter by default.
This line can throw an exception. We shouldn't check for resourceKindLabel.NONE.
No need to use ConcurrentMap.
Is there a difference between this and the above change?
Is there a difference between this and the above two?
FIXME: I couldn't find a cmd in this case (WPMainActivity.getSelectedSite()!= null && getActivity().getSelectedSite()).
FIXME: I couldn't find a cmd in this case (WPMainActivity.getSelectedSite()!= null) and below this line.
FIXME: I couldn't find a cmd in this case (WPMainActivity.getSelectedSite() == null))
the magic string can be moved to constants as well.
the magic number here can be simplified as return new AppiumDriver<>(builder, serverCapabilitiesSupplier, () -> serverCapabilitiesSupplier.get().withAppiumJS(props));
the magic number here can be simplified as return new AppiumDriver<>(builder, serverCapabilitiesSupplier, () -> serverCapabilitiesSupplier);
Can you extract a method : createNoGoalConflictMessageSent too?
Can you extract a method deleteAllDataRequestConflictMessageSent too?
Can you extract a method : createFromGoalConflictMessageSent too?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Rename this function name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_0>
@vilchik-elena Shouldn't it be simpler to use a regular expression _firstOf(a.array())_ and then use it in _anyOf()?
There is a double? sign here
Can you make this into a constant?
Can you make this into a constant as well?
getCanonicalName seems to return null even if the class is not found. It would probably be more robust to handle it.
getCanonicalName seems to return null even if the class is not found. It would probably be more robust to throw an exception here.
getCanonicalName seems to return null even if the class is not found. It would probably be more robust to have an expected type.
I think we should rather throw an Exception here. That way the caller can decide what to do with the underlying exception if the repository is not configured through the repository.
I think we should rather throw an Exception here. That way the caller can decide what to do with the underlying NPE.
I would rather create the repository as a field and use it here and below.
nit: remove empty line
nit: delete empty line
delete empty line
I don't think this is a test case for an error.
I don't think this is a test case. This is a test case and hence has no assertions.
I don't think this is a test case. This is a test case for an error.
return ImmutableSet.of();
return ImmutableSet.of(); Please make the variables final.
return an ImmutableSet.of()
Could use a concurrent map instead of two concurrent map accesses.
Could use a concurrent map instead of an concurrent map.
Could use a concurrent map instead
I think it should return 10); which is a bad idea
I think it should return 10); which is a bug
why 10?
Consider to replace with "an allowed command".
Consider to replace with "an allowed command"?
Consider to replace with "an allowed command"..
Nitpick: This is way less than 120 chars, I don't think you need to separate the parameters in different lines.
Nitpick: This is way less than 120 chars, I don't think you need to separate the parameters in different lines. Even when you have a different line, I wonder if you should keep that.
Nitpick: This is way less than 120 chars, I don't think you need to separate the line for this.
Why are you not passing the publishers as a parameter of the method?
Why are you not passing the publishers as a parameter?
Why are you not passing the publishers as a parameter to the method?
I think we should avoid passing down the metric here. It's not a good idea to specify a null metric.
I think we should avoid passing down the metric here. It's not a good idea to expose a separate metric
I think we should avoid passing down the metric here. It's not a query metric.
When would the user_id be null?
When would the field be null?
When would the user_id be null? (I think it is)
I would just add a method in the asyncHttpClientMap. This method does not seem to be used in this class, but it seems like a lot of the code is there.
is there a reason we need to check if the asyncHttpClient is a cached client?
I would just add a method in the asyncHttpClientMap. This method does not seem to be used in this class.
Should use Util.fixEmpty(result)
Should use Locale.ROOT to avoid the null check
Should use Util#fixEmpty.
Can we make -1 a constant and have it be final?
Can we make the operator private?
Can we make -1 a constant and have it be calculated each time?
Please use static import
Please use static import.
Please use static imports
I see you"ve moved'reportsWebappDeployed' but what about'retryCount > MAX_RETRY_COUNTS'?
IMO, url in a constant is misleading. I"m not sure how can you get to this point with url, but if it is false- don't you want to return?)
IMO, url in a constant is misleading. I"m not sure how can you get to this point with url, but if it is, how about just return true/false here?
This is not really needed. The token is already taken care of by the token.
This is not really needed. The token is already a member of 401.
This is not really needed. The token is already a token.
Why are we creating a new instance here?
are we keeping this inside the constructor?
Should we make this a singleton?
Prefer to use Arrays.asList instead of a reference.
Prefer to use new HashSet<> here.
addAll
Should this be TYPE_FORM_DELETION
Can you please rename this variable to reason?
Can you please log at debug level here ("Wiping form {}.
- It'd be good to use %d instead of %d here. That will allow us to get the next div for both sides.
- It'd be good to use %d instead of %d here. That will allow us to get the next div on the same device.
- It'd be good to use %d instead of %d here?
Can we define this a constant please?
Can we define if (isOpen(election)) get the HttpRedirect("/election/resultsection/results)?
Can we define if (isOpen(election)) { return getConnection(election); }
I think we can use the same constant for that.
I think we can move version to a constant
I think we can use migrateContent method here
Please remove
instead of cannot be null I would prefer to throw an NPE in the line above.
instead of cannot be null I would prefer to throw an NPE in the constructor.
This is pretty complicated code I think. Maybe we could do something like this: return mAdvertisedFrom().isEqualNow(getAdvertisedFrom().getAdvertised());
This is missing @Override
This is pretty expensive, could we use curly braces
1. I wonder if there is a bug here. 2. Currently there is no way to get an ChargeStatus from a view and then back to the chargestatus passed to it. We don't want the action to happen once ChargeStatus is created. I think that this method should be private.
1. I wonder if there is a bug here. 2. Currently there is no way to get an ChargeStatus from a view and then back to the chargestatus passed to it. We don't want the action to happen once ChargeStatus is created. I think the service layer should not have been canceled yet. But if it is not in this case we'll be doing some kind of states.
s/public//
Should we make a variable for the error message instead of "error"?
Should we make this method much easier to read?
Should we make this?
Should be: accountingLines.stream().forEach((AccountingLineBases) -> sb.append(line.toString()));
Should be: accountingLines = accountingLines.stream().collect(Collectors.joining(line -> sb.append(line.toString()));
Should be: accountingLines = accountingLines.stream().map(AccountingLineBase::get).collect(Collectors.joining(line));
we may be able to use a for here instead of a for loop. E.g.: java final List<Something> out = handle.get(() -> { if (input == null) { return null; } return out; }
we may be able to use a for here instead of a for loop. E.g.: java final List<Something> out = handle.get(() -> { if (input == null) { return null; } return out.get(); }
we may be able to use a for here instead of a for loop.
So I understand: java return relation.getModelClass().map(this::getModelClass).orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { getModelClass().orElseGet(() -> { getModelClass() ); } });
So I understand: java return relation.getModelClass().map(this::getModelClass).orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { getModelClass().orElseGet(() -> { getModelClass().orElseGet(() -> { getModelClass() ); } });
So I understand: java return relation.getModelClass().map(this::getModelClass).orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { return relation.getModelClass().orElseGet(() -> { getModelClass().orElseGet(() -> { getModelClass() ); } });
Doesn't make this method need to be synchronized, otherwise you could use the getColumnName(Column annotation) method here.
Doesn't make sense to have this method return a String instead of a getColumnName(field.getName())?
Doesn't make sense to have this method return a String instead of a String?
replacing this with helper method would be great
replacing this with hawk.getStorage().util.Map maybe?
replacing this with hawk.getStorage().util.Util
Again, use IOUtils.
Again, use IOUtils to do this.
Again, use IOUtils to do this
Please add an error message
Please add the code to the test method.
Please add the code to the test file for Java.
I don't think we need the null check.
I don't think we need the null check all access.
I guess we don't need the null check all access.
I'd prefer we make the string a constant.
I'd prefer we make the string a constant because it's used only once.
I'd prefer we make the string a constant as well.
actually not sure why do we need this method to be public?
actually not sure why do we need this?
actually not sure why do we need this method?
I think we should add a getStorageDomain method so that we don't have to specify the Domains
Maybe worth to add a getStorageDomain method, could be changed to addStorageDomain
Maybe worth to add a getStorageDomain method, and use it in addition to the Provider
If it's not supported, indexWriter.add(marker) is a bad idea (which is why the method is synchronized).
If it's not supported, indexWriter.add(marker) is a bad idea
If it's not supported, indexWriter.add(marker) is a bad idea (static method to avoid the class level).
nit: Use a ternary here (or do the ternary operator)
Use a stream() method instead of a collect.
nit: Use a ternary here.
It's wrong. The test doesn't specify any fields.
It's wrong. The test doesn't show if the format is wrong.
It's wrong. The test doesn't show if the format is wrong. Test should fail
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
shouldn't this be the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
why a check for the viewer here? shouldn't this be the dropdownTableViewer? Now that we keep the table.
I think the volumeFormat string should be private, and only use the public keyword here.
I think the volumeFormat string should be private, and only use the @Nullable here.
I think the volumeFormat string should be private, and only use the @Nullable here
We should move output of "dataSource='")" into its own variable.
We should move publishingTasks to toString() with the given string.
We should move publishingTasks to toString()
Forgotten empty line
Forgotten empty string, should we use String.join?
Forgotten debug logging?
isMatrix()?
isRowVector used in braces around this loop?
is rowVector
Shouldn't this have some logic instead of shutdownNow as we want to call shutdownNow instead of wait?
Shouldn't this have some Thread.sleep if possible?
Shouldn't this have some logic instead of shutdownNow as we want to call shutdown method and have that call fail?
Can you throw an IllegalArgumentException instead?
Can you throw the IllegalArgumentException instead?
Can you explain why we need to throw IllegalArgumentException?
I don't think we need this.
Do we need this extra block?
Do we need this?
This is redundant. The updateTissueMaterialDaoDependencies method will only update the object once.
This should be updateTissueMaterialDaoDependencies method instead
This is redundant
Shouldn't we keep the!workflow.exists() check?
Shouldn't we keep the!read* methods here?
Shouldn't we keep the!workflow.get()?
Could you replace with a defensive copy of the list?
Could you replace with a ellipsis that you're using the StringUtils?
Could you replace with a defensive copy?
Shouldn't we have a CompletionException here?
Shouldn't we at least return a CompletionException here?
Shouldn't LSICredentials type be more appropriate here?
Maybe return an empty string here instead of null?
Maybe return an empty string instead of null?
Maybe return empty string instead of null?
I think it would be better to use o1.equals(o2.getId()) here
I think it would be better to use o1.equals(o2) here
I think it would be better to use o1.equals(o2) here.
Shouldn't we remove the this keyword from the constructor? This IntelliJ can't do this for you.
Shouldn't we check for 0 to avoid a NPE?
Shouldn't we remove the this keyword from the constructor? It's a bit hard to read.
Time for a helper method?
Could also be a helper method for TimeSerializers
I believe a helper method is missing the same?
This variable is not used anywhere. And is it possible to expand on the regionType given that it is PARTITION?
This variable is not used anywhere. And is it possible to rely on the regionType to be REPLICATEGO_PROP? If REPLICATEGO_PROP is null, it will return a boolean.
This variable is not used anywhere. And is it necessary to check for the regionType in the PARTITION?
If you need to iterate through the chain, you can just iterate over the entries in it and check if it is returned if it is null.
If you need to iterate through the chain, you can just iterate over the entries in these and check if the URI is returned.
If you need to iterate through the chain, you can just iterate over the entries in the chain.
Could be replaced with ternary operator
Could be replaced with gwtModules.size() - 1?
Could be replaced with gwtModules.size() - 1?
nitpick: can be final List<String> roles = Lists.newArrayList( );
nitpick: can be Lists.newArrayList(... );
nitpick: can be final List<String> roles = Lists.newArrayList(0.21.0);
return getQueryCount().iterator();
return getQueryCount().addAndGet(1)
return getQueryCount().addAndGet();
pls substitute these three lines with setInternalState( this, "toolchain", toolchain), or set the target properties", toolchain.
pls substitute these three lines with setInternalState( this, "toolchain", toolchain), or set the target properties", "toolchain."
pls substitute these three lines with setInternalState( this, "toolchain.");
Please add @Override annotation here and in jsonPath as well.
Please add @Override annotation here and change the method signature.
Please add @Override annotation here and change jsonPath to return jsonPath.
Silent failing
to be the better value of the bytes to read.
to be the better option
You could use the checkNotNull(position, "position"); constructor.
We should use the checkNotNull(position, "position"); constructor.
We should use the checkNotNull(position, "position"); only.
No need to catch the exception here, it was already done in the overload.
Same here, it was the same as in the other methods.
Same here, it was the same as the other user code, right?
move this to activate() after xmlLoaders?
it doesn't look like xmlLoaders is used so it doesn't matter much
move this to xmlLoader
Needs an @Override annotation.
Needs an else block.
Versioned!
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an int?
I'm still confused. Why are we parsing as an int and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Not sure if the extra space at the beginning is still needed though. Better leave it there and eventually tackle it in a refactor to uniform the set and make it in a different pull request.
Not sure if the extra space at the beginning is still needed though. Better leave it there and eventually tackle it in a refactor to uniform the set and make it in a different PR
Not sure if the extra space at the beginning is still needed though. Better leave it there and eventually tackle it in a refactor to uniform the set of tests.
Should this debug message be removed in the log?
Should this warn be removed?
warn
Missing final
Should be this
Missing final modifier
Why are you creating this correlationID? Shouldn't this be defined as a static field in the CoreEvent?
Why are you creating this correlationID? Shouldn't this be defined as a static field in the Utils class?
Why are you catching CoreEvent here? Shouldn't this be defined as a static field?
TBH I am concerning of creating the temporary byte array for every read. It may be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
TBH I am concerning of creating the temporary byte array for every read. It may be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every read.
TBH I am concerning of creating the temporary byte array for every read. It may be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every read?
Should we close the stream after we do that?
Should we skip setting storeName and getJob() here?
Should we fail if the store is not found?
suggestion final String lookName = lookSettings.getString(selectedLookName, position);
suggestion final String lookName = lookSettings.getString(selectedLookName, false);
suggestion final String lookName = lookSettings.getString(selectedLook.getSettingBundle(selectedLookName));
Fix aliases = aliases =...
need to check aliases = aliases!= null
need to check aliases = aliases =...
(but with the no-arg constructor) you can use a logger instead of System.out
(but with the no-arg constructor) you can use a logger instead of System.out.println
(but with the no-arg constructor) you can use the no-arg constructor.
let's stick to if (styles == null) { return true; } for this patch.
shouldn't this be true?
let's stick to method names
Isn't this message redundant? Would it be more readable to define: "Invalid subfield path: " + path
Isn't this message redundant? Shouldn't it be "Invalid subfield? path: " + path
Shall we replace this with assertEquals("Invalid subfield path: " + path + " is not a failure.");
Duplicate code. Could you keep the code concise? I know you have a lot of code in the PR, but I think it's super easy to read.
Duplicate code. Could you keep the old code?
Missing @Override
This is just a whitespace change; do you have a different formatter?
This is just a whitespace nit; do you have a different formatter?
This is just a whitespace, but did you have a different formatter?
Do we need to wait to see this thread to finish?
Do we need to wait to see this thread?
Do we need to wait to see this thread to finish?
could we solve this better by overriding sendTimeStamp() in the TracingActor? I'd like if all this trace and message could be in the same class.
could we solve this better by overriding sendTimeStamp() in the TracingActor? I'd like if all this trace and message could be inside of it.
could we solve this better by overriding sendTimeStamp() in the TracingActor? I'd like if all this trace and message could be in the same order as in the new code.
Why do you need to send a new ByteBuf? This class is already used in a few places.
Why do you need to sendObject?
Why do you need to send a new ByteBuf? This should use the one you added in getNextObject().
Why are you changing the name of the variable here?
Why are you changing the name of the variable when you use it in the next line?
why not keep it in the synchronized block instead of changing the name?
Let's use a more meaningful name here like "ctx.gridConfig().getDefaultQueryTimeout()" or something similar
Let's use a more meaningful name here like "timeout" or "timeout".
Let's use a more meaningful name here like "ctx.gridConfig().getDefaultQueryTimeout()".
The ID is used to restore old files (from an older release) so this must not be changed!
The ID is used to restore old files (such as <LINK_0> so this must not be changed!
Should be changed to <LINK_0>
1. Do we need to put this? 2. If noVNC_PAGE_URL is needed, we can fail with aVNC_PAGE_URL + "/rest/novncPage.html" and have noVNC_PAGE_URL + "/rest/novncPage.html#novncPage.html#novncPage. Do we need both?
1. Do we need to put this? 2. If noVNC_PAGE_URL is needed, we can fail with aVNC_PAGE_URL + "/rest/novncPage.html" and have noVNC_PAGE_URL + "/rest/novncPage.html#novncPage.html#novncPage. Please replace with: String noVNC_PAGE_URL = "rest/novnc";
1. Do we need to put this? 2. If noVNC_PAGE_URL is needed, we can fail with aVNC_PAGE_URL + "/rest/novncPage.html" and have noVNC_PAGE_URL + "/rest/novncPage.html#novncPage.html#novncPage. Do we need this?
Try string.endswith with this
Try using a string.next
Try using a string.nexted().
Can you assert that the objects are not null?
Can you put one statement around this for loop to make it shorter?
Can you put one statement around this block?
you could take a look to the "APIImpl" variable, and avoid duplicating the code here
you could take a look to the "APIImpl" variable, and avoid duplicating the code
you could take a look to the "APIImpl" variable, and avoid duplicating the code for each call
suggestion return (public String) fileName;
suggestion return fileName;
String.valueOf()?
This validation is done only once. These two lines should be updated as well, since they're the same.
This validation is done only once. These two lines should be updated as well
This validation is redundant, you can inline it.
why do you need to set the property if the user has already been set?
why do you need to set the local filesystem explicitly?
remove this line
Why this?
Why has this been changed?
Why do you use this?
why return the exception?
why return new HashMap<>(herderRequestTimeoutMs);?
why return null?
May be dodgy...
May be dodgy... and make it more readable?
May be dodgy... is it required to use logging?
As I think I mentioned previously, we don't have any other method String impl methods so we can use toString method here (and in the below method). Probably not a good idea to factor out the logic here and make it private.
As I think I mentioned previously, we don't have any other method String impl methods so we can use toString method here
As I think I mentioned previously, we don't have any other method String impl methods so we can use toString method here (and in the super class). Probably not a good idea to factor out the logic here and make it private.
Nit: Could use ImmutableList.unmodifiableList here, and then we don't need the extra List allocation.
Nit: Could use ImmutableList.of(...) here, and elsewhere.
Nit: Could use ImmutableList.unmodifiableList here, and then use an ImmutableList.copyOf here...
@essobedo same here.
@essobedo just use getHost() instead of new RqFake()?
@essobedo just use getHost() instead of new RqFake()
change the name of this method to channelId
change the name to channelOutboundInvoker out or something
change to channelOutboundInvoker out
Style-nit: I prefer this one as: int count = 0; if (offset == 0) { return 0; } int offset = in.read(buffer); return count;
I guess this is just doing offset + count since you are using -1.
I guess this is better than throw an exception.
I think you need to get rid of this null check
nit: this could be private
I think you need to get a more readable error message
This should be this.sizes == 0?
This should be this.sizes == 0.
This should be this.sizes == 0
we can do away with the local variable here @rishabh-997
we can use Objects.equals(aLong, 2L) to reduce the code
we can do away with the local variables here @rishabh-997
State.state instead of this.state
State.setState(this.state, false);
State.setState(this.state, false)
if the Resource is declared as a const please return that instead.
if the Resource is declared as a member, the caller should handle it
Should this be private?
suggestion return pgStartupWait;
Why can the lock not null?
Why not synchronized?
avoid the wait variable and use a string for the start?
shouldn't this check be 10 seconds?
shouldn't this wait for 3 seconds?
please, setSucceeded(true)
please, setSucceeded(true) - this is a good practice.
please, setSucceeded(true) - this is being set to true.
Minor: it would be better to keep this path in a static way and call it from here?
Minor: it would be better to keep this path in a static field.
Minor: it would be better to keep this path in a static way and call it from here.
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do findFirst() with a very simple method that encapsulates the logic?
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do findFirst() with a single call to it?
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do findFirst() with a very simple element that encapsulates the logic?
Here you should just let the DateUtils.addMinutes(now) method.
suggestion log.error("Failed to delete  jobs: {}", nowJobTime);
suggestion log.error("Failed to delete  jobs", e);
better do isNotBlank()
please do not add property value
better do isNotBlank
nit: can use the StandardCharsets#UTF_8 constant here.
nit: can use UTF8.getBytes(utf8.getBytes()) here.
nit: Utf8 is not immutable (unlike String). Should use UTF8 here.
can you throw the exception in the catch block?
can we print the exception in the print?
can we print the exception in the output?
Don't log and throw.
Don't log that situation at all
Don't log this situation at all
This can be simplified to: Set<PageObject> set = pageSet.compute(bucket, pageSet);
This can be simplified to: Set<PageObject> new LinkedHashSet<>(pageSet.compute(bucket, pageSet));
This will be faster as we don't use Set to do the job's key.
is this the right thing to do?
is this the best place to do this?
is this the best check?
This is a clear programming error, right? If so, suggest throwing NPE instead.
Duplicate code. Can't we use netif.getNetworkInterfaceByName(name) here instead?
Duplicate code. Can't we use netif.getNetworkInterfaceByName(name)?
Can you simplify this logic? indicativeSentencesGeneration.DEFAULT_SEPARATOR!
@gdicativeSentencesGeneration Is this really needed?
@Override
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Doesn't this condition always evaluate to true?
Doesn't this condition mean we can only execute the single scan?
Use the constant
Missed the else branch
Missed this change in the first place
Add a "user" field to com.google.gerrit.core.request.IdentifiedAt(UpdateStatus)
Add a "user" field to com.google.gerrit.common.base.Preconditions.checkNotNull(user, "user.isPresent())
Add a "forUpdateStatus" field
Throw the exception, not the entire stack trace.
Throw the exception using a more specific exception class.
Throw the exception instead of returning null.
Do you really need this?
Do you actually need this?
Format
remove
extract Assert.assertStringContains(number, MOBILE_PROMOTION_TEXT);
refactor
Please shorten selector.nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN to something like [this](<LINK_0>
Please shorten selector.nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN to something like getValueCardinality() > getValueCardinality()
Please simplify this code.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
We don't have this line, just remove it.
We don't have this line, just assert it's.
This whole method can be replaced with: getBinding(stack.getOwnerName()).add(new TextComponentTranslation("this.auto.currentOwner", binding.getOwnerName()));
This whole method can be replaced with: getBinding(stack.getOwnerName()).add(new TextComponentTranslation("this.auto.currentOwner", binding.getOwnerName());
This whole method can be replaced with: getBinding(stack.getOwnerName());
I think we can use the findNotEscapedQuery(); like we do with currentIndex it's only input parameter.
I think we can use the findNotEscapedQuery(); like we do with currentIndex it's not really an index.
I think we can't always use && like on the other side
Rebase error - should be used Helper.getCurrentUser.
Rebase error - should return Helper.getCurrentUser.
Rebase error - should be used Helper.getCurrentUser?
I would use existing texts for this, so it is clear where we set the language label to empty.
I would use existing texts for this, so it is clear where we set the language label to be empty.
I see it is set by our existing code, but you have the form name in the message. So when we change the definition to setEnabled(true) and also other properties, it is not a preference.
Maybe use the constants from GravityData.
Maybe use constants for all GravityDataSize.
Maybe use the constant ENTITY_PREFIX to keep the constant?
I would suggest to remove this log.info, this is a debug message
I would suggest to remove this log.info()
I would suggest to remove this log.info, this is a debug message.
Is this if condition intentional?
why are we changing this?
why remove this?
fix workspace name if you're using workspace instead
fix workspace name if workspace is not empty
fix workspaces
Same here, using double.
Same here, using kappa as the return value.
Same as above, using kappa.f.
Are you sure we need a synchronized here?
Are you sure we need the synchronized here?
Are you sure we need a synchronized here? I was thinking of the synchronized flag.
use unmodifiable list
use unmodifiable
use unmodifiable to avoid synchronization
Why not use the empty function instead of two?
Why not use the one param?
Why not use the empty list and have only one?
nit: you can use java.util.Objects.equals
nit: Indentation out of whack here too!
nit: Indentation out of whack here too
This should probably be public
This should probably be private
This should probably be private.
Use dataSharingNotificationForCurrentUserObject, then this can be part of the public API. And it should not be part of the public API.
Use dataSharingNotificationForCurrentUserObject, then this can be part of the public API.
Use dataSharingNotificationForCurrentUserObject, then this can be a bit confused. It doesn't also matter that "allowNotificationForCurrentUserObject" is currently an implementation detail.
Check main entry for bitmaps.
Check main logic about bitmaps.
You can initialize this variable in the while loop.
I mean to put this crash on a null object, cause if it's null here, you'll never get null here
I mean to put this crash on a null object, cause if it's null here and also get NPE
I mean to put this crash after line 28 bytes?
is it better to use Collections.emptyList()?
is it better to use Collections.singletonList(1000) here?
is it better to use Collections.emptyList() instead?
What is the purpose of the check on the presence of the "ThrottlingIfHeader" method? If the feature is true, there is a similar check as property of the "enableThrottlingIfHeader" method. Perhaps the following is more efficient as: private boolean enableThrottlingIfHeader(String extension) { if (enableThrottlingIfHeader) { return true; } if (enableThrottlingIfHeader) { return true; } return true; }
What is the purpose of the check on the presence of the "ThrottlingIfHeader" method? If the feature is true, there is a similar check as property of the "enableThrottlingIfHeader" method. Perhaps the following is more efficient as: private boolean enableThrottlingIfHeader(String extension) { if (enableThrottlingIfHeader) { return true; } if (enableThrottlingIfHeader(enableExpression)) { return true; } return true; }
What is the purpose of the check on the presence of the "ThrottlingIfHeader" method? If the feature is true, there is a similar check as property of the "enableThrottlingIfHeader" method. Perhaps the following is more efficient as: private boolean enableThrottlingIfHeader(String extension) { if (enableThrottlingIfHeader) { return true; } if (enableThrottlingIfHeader(enableExpression)) { return true; } return inflater.toString(); }
Is this not the default value?
Is this not correct? You will need to ensure that the default value is the correct one.
Is this not expected to be null?
should we have a message to the exception?
should we have a message to know about this?
should this be class?
This is a duplicate of the code. Can you extract it to a private method?
This is a duplicate of the code. Can you extract it to a private method? Thanks!
This is a duplicate of what we do in the isSwrveHelper, maybe we should just use the optional?
nit: use ImmutableMap.of()
nit: use ImmutableMap.of()?
Revert the change?
Why is this not List<String>?
Why are we returning the empty list instead of null?
Can we use Collections.emptyList() here instead?
requireNonNull
nit: put "nameResolver is null"
"nameResolver is null"
Hey @aville, could you please put a constant in TestClass and use it in here?
Hey @aville, could you please put a constant in TestClass and use it here?
Hey @aville, could you please put a bump on this (and the tank)? Thanks!
Should we keep this method?
this should be private.
static import?
this method is not a good name, it should be remove from the map
this method is not a good name, it should be remove from the service
this method is not a very clean way of doing it but it would be better if you remove the state of the consumerProcess; that would remove any remaining elements from the sitemap parser.xml.
Can we assert the result of this method on the service names?
Can we assert the result of this method on the superclass instead of changing it here?
Can we assert the result of this method on the superclass instead of completely ignoring it?
What is the reason for this "NON_NETWORK_PROVIDER_TYPE_SEPARATOR"?
What is the reason for this assertThat? I would use equals over arrays.
I would use NON_NLS.isEmpty()
Instead of calling isDisplayed, it would be better to use here, to avoid any confusion.
Instead of calling isDisplayed, it would be better to use here, as it is not visible/she.
Instead of calling isDisplayed, it would be better to use here, as it is not a display element.
You could compare directly instead of using values
You could compare the map directly.
You could compare directly instead of using iterator
I think you can't use the null check here.
I think you can't use the new LegacyBrowserService at all, but as it's not needed
I think you can't use the new LegacyBrowserService.getLegacyBrowserService() method.
If I understand correctly, DbFilter is no more used. So why keeping it?
If I understand correctly, this is no more used. So why keeping it?
If I understand correctly, DbFilter is no more used. So why.
That's a bit hard to read... wouldn't it be simpler to have a single call to 'homoglyph_norm()' here?
That's a bit hard to read... wouldn't it be simpler to just return Collections.singletonList("homoglyph_norm"); in this case?
Does this have to be homoglyph_norm()?
I would rather have a condition like: if (url.endsWith("/")) {... } else if (url.endsWith("/")) { url += link; } return url;
I would rather have a condition like: if (url.endsWith("/")) {... } else if (url.endsWith("/")) { url += link; } return URL;
I would rather have a condition like: if (url.endsWith("/")) { url += link; } if (url.endsWith("/")) { url += link; }...
Use a try-with-resources block
Use a try-with-resources block.
Use {} placeholders in the log message instead of '+'
Perhaps we could use debug level here?
Perhaps we could use debug level here
Perhaps we could use debug here
Please remove the toLowerCase() call.
Please revert this change.
Please add assertion for this.
This validation should be done in the constructor but it's not used.
This validation should be done in a private method that is called from the constructor.
This validation is not needed.
Remove this.
remove this, and use other more readable class name
remove this, and use other more than one?
replace with TestUtil.testRuleTester.test
replace with TestUtil.testRuleTester.test()
replace with TestUtil.testRuleTester.test?
Extra space after )
Extra space after :
:+1: this should use the builder.
save an iterator by using index
save a hash map?
save a hash map
suggestion serviceRegistry.create(serviceRegistry)
suggestion serviceRegistry.getService(new serviceRegistry)
suggestion serviceRegistry.getService(new LeaseDuration());
I think this looks more complicated to me. I think it would be better to pull out this whole block into a method, so that we can reuse the code in this test :)
I think this looks more complicated to me. I think it would be better to pull out this whole block into a separate method, so that we can reuse and call it in the test below.
I think this looks more complicated to me. I think it would be better to pull out this whole block into a method, so that we can reuse the code in this test class.
Should we validate that it's a Message?
Should we validate that this uses the old namespace?
Should we validate that this uses the namespace?
Is there a reason why this is called in the super class? It could be a private class right?
Is there a reason why this is called in the super class constructor?
Is there a reason why this is called in the super class?
please use the fully qualified name
please move this to the previous line
please move this line to the next line
Can you invert this? This should do return URL.concat("_").stream().filter(checkerInfo -> chainLowerCase(checkerInfo.get()).concat("_")
Can you invert this? This should do return String.format("_")
Please use return annotation
nit: you could simplify this to java boolean ableCellRenderer = s == null? s/ s/ s/ s/ s/ s/ s/ s/ s/ s/filePath/g
nit: I don't know this is true, but you could simplify this to java boolean ableCellRenderer = s == null? s/ s/ s/ s/ s/ s/ s/ s/ s/filePath/g
nit: I don't know this is true, but you could simplify this to java boolean ableCellRenderer = s == null? s/ s/ s/ s/ s/ s/ s/ s/ s/filePath/g/
ImmutableList.of()
ImmutableList.of()?
ImmutableList.of()?
nit: I think that in this context we use globalServiceInstance and keep property we intact for RegistrationRepository.
nit: I think that in this context we should use globalServiceInstance and keep metrics for services. As I understand it will be a bit easier to read.
nit: I think that in this context we should use globalServiceInstance and keep metrics for services. As I understand, we have a slight chance to have different configurations which need to be propagated from Registration.
Why is this a 'else'?
Why is this private?
Why is this a 'else' case?
add e to log message
e.sleep(...)?
e.sleep() is probably better than 100
@bdragan this.doc.index() is redundant here
@bdragan this.doc.index() is already an instance of this.
@bdragan this.index() is redundant here
Should the exception be caught here?
Should this be checked by other classes (like "isAssignableFrom")?
Should this be checked by other classes?
Should this return an exception instead of throwing an IOException?
Should this return an exception instead of throwing an exception?
Should this return an IOException instead of throwing an exception?
I assume line.static line should be used here.
I assume line.static line will be executed 100 chars in the string representation of the first line?
I assume line.static line will be executed 100 chars in the string representation of the parent line?
Is there a particular reason these shouldn't be.enableButtons()?
Is there a particular reason these shouldn't be.enableButtons(true)?
Is there a particular reason these shouldn't be.enableButtons(false)?
is there a reason you are not using the other constructor?
is it really necessary to use the super() here?
is it really necessary to remove?
Collections.emptyList()
Collections.emptyList() is enough.
ArrayList
Here too, have a method in DataResultViewerTable
Here too, have to be fixed by #487
Here too, have to be fixed by #487.
Why is this needed?
Why is this duplicated?
Why do we need the synchronized here?
s/a/b/c/
s/a/b/
'a-nitpick'
It should be new TajoRuntimeException(new InvalidCastException(...).
It should be new TajoRuntimeException(new InvalidCastException(...)).
It should be new TajoRuntimeException(new TajoRuntimeException(e));
Why do we need this this? Shall we use our drillDownArray#add method?
Why do we need this? Shall we use our drillDownArray#add method?
See above. Shall we use our drillDownArray#add method?
stream isn't closed?
properties.load() is duplicated
properties.load() is duplicated... remove it
Use assertEquals instead.
use assertEquals instead.
Use Assert.assertEquals
Why are we removing this here? This is for the wrong reason.
Is this needed? This simply says "Create API with the name field, but this is wrong.
Is this needed?
unused?
unused ()
unused
please use static Double.compare
use static Double.compare
please use static import
Please remove.
Please have a Log.
Please remove
Can we wait for this instead?
Could we wait for this instead?
Can we wait for the confirmation dialog?
Scratch that is not needed (see above).
Scratch that is not implemented before merge
Scratch that is not needed (see [L1586](<LINK_0> to have the if statement given that the debug setting is the wrong value.
path.startsWith(pattern) should be checked with StringUtils.startsWith(pattern)
path.startsWith(pattern) is redundant with StringUtils.startsWith(pattern)
path.startsWith(pattern) should be checked with StringUtils.startsWith(beginning) as well, even if it's a string.
If we're not using the writePermission() method, you can remove the getMarshaller() and getParticipantObjectQueryForRequest() altogether.
If we're not using the writePermission() method, you can remove the getMarshaller() and getPhysicalObjectQueryForRequest().
If we're not using the writePermission() method, you can remove the getParticipantObjectQueryForRequest() method.
I guess you mean to pass emptyList()?
I guess you mean to pass Kryo.cast(new Kryo(this))?
I guess you mean to pass PMDCoreUtils.EMPTY_MAP?
Integer.toString(resource)
return resource.getOrDefault(..., null);
return resource.getOrDefault(..., "null");
This should be a direct reference to ActiveMQWebLogger.LOGGER rather than just for debugging.
This should be just a debug.
This should be a debug.
.applyTo() should be used here instead of the ternary operator.
.applyTo() is shorter and easier to read.
.applyTo() is shorter and easier to read
getServicePolicy shouldn't ever return null. You can't have a null check here.
getServicePolicy shouldn't ever return null. It would be a good idea to cache the policy in a field and return the policy immediately.
getServicePolicy shouldn't ever return null. It would be a good idea to cache the policy.
This change should not be needed.
This is not correct, just change it to assertTrue
This looks still at all.
Since you have to remove this line, you can put a "COUGHS.getConceptId()" in a local variable to avoid doing it.
Since you have to remove this line, you can put a "COUGHS.getConceptName()" in a local variable to avoid doing it.
Since you have to remove this line, you can put conceptName.getConceptId().toString() in a local variable to avoid the duplication.
throw new Walker(FormEntryModel.class);
throw new Walker(FormEntryModel );
throw new Walker(FormEntryModel, FormEntryModel )
We should consider the.toLowerCase(InvokeTwice) approach as well.
This would be better as.toggling only on if there's an exception.
We should consider the.toLowerCase(InvokeTwice) syntax.
Need to use Assert.assertNotNull
Need to use Assert.assertNotNull here
@lautarobock This test will fail
Global listener catch each click. You don't need to log it.
Global listener catch each click. You don't need to wait for it.
Global listener catch each click. You don't need to wait for element after click.
We can put the fragment's initialization code inside the DialogFragment as well.
We can move the callback to the DialogFragment constructor. No need to duplicate code here as well.
We can move the callback to the DialogFragment interface. No need to duplicate code here as well.
Shouldn't this be equals()?
Shouldn't this be equals?
Shouldn't this be opposite?
are these constants anywhere?
are these two switch statements necessary?
are these magic strings correct?
The order of the arguments is reversed - it should be assertEquals("Test_123", result);
The order of the arguments is reversed - it should be assertEquals("Test_123", expected", "", result);
The order of the arguments is reversed here as well?
should we also add a check here if the output is null?
should we also add the output to the output?
it should also handle the output in the output
Should return something here, not null.
Should return something here, or throws NPE?
Should the variable be returned?
Same question about unit conversion as earlier.
Not a big deal, but why change this from protected to public?
Same question about unit conversion as earlier
I don't think we want this default. This default setting basically says "If debug mode is enabled (IE: You're probably still running a dev machine with this is 'on'". You probably want a default to "no"
I don't think we want this default. This default setting basically says "If debug mode is enabled (IE: You're probably outside of an app, you're probably want a default for the superuser flag)
This default setting should be MARK I think.
optional: can simplify by using tags.contains(tagName.get(Constants.R_TAGS.BOX) here instead of tags? //NON-NLS-1
optional: can simplify by using tags.contains(tagName.get(Constants.R_TAGS.contains(Constants.R_TAGS."))
optional: can be replaced by tags.contains(tagName.getWidget().getProjectName()).add(tagName.getWidgetName(UIText.R_TAGS.contains(Constants.R_TAGS.")) )
The parameter can bee removed
The parameter can't bee removed
The parameter can't bee added
Use BukkitTagContext instead?
Use BukkitTagContext instead.
Change this to use PlayerUtil.BukkitTagContext instead.
I think it is better to use streams here
I think it is better to use streams API here (and for the other method) instead of the concrete class.
I think it is better to use streams API here (and for the subsequent methods).
here you should check that the argument is an expected value and throw if it just fails.
here you should check that the argument is an expected call and throw if it is not
here you should check that the argument is an expected call and throw if it just fails.
Do we need this?
Do we need to close this activity?
Do we need to close this manually?
This needs to be wrapped into a try-catch block
This needs to be wrapped in a try-catch block
This needs to be removed
rename to mBranch
rename to mRef
missing braces
Let's keep the context.get(messageIndex) and use a regular if test for the return value.
Let's have a look at how we do it. I think we need to have a final static variable for the command execution.
Let's have a look at how we do it. I think we need to have a CommandContext.get(String) method for the String.
I'm not sure this is correct. If this job is cancelled, there should be an error condition.
I'm not sure this is correct. If this job is user run, this must be an NOOP
I'm not sure this is correct. If this job is user run, this must be an error.
Please parse the URI to a local field, with a ternary operator.
Please parse the URI to a local variable, with a ternary operator.
Please parse the URI to a local field, with a ternary to avoid NPE
concat empty str?
concat empty string?
concat empty str
";" at the end of the file
";" at the end?
Pattern could be static.
We should add a message here
We should add something here
....
Thanks for making this a bit more. I didn't try to change this out.
Thanks for changing this to a better name. I didn't notice this before.
Thanks for making this a bit more. I didn't try to change this out. We don't want to make a change in this PR.
This should be: return Util.debug("Unsupported S3Select input format: " + inputFormat);
This log format is wrong (was not 'inputFormat') )
This is a warning.
shouldn't this be cdPath?
shouldnt this be cdPath?
shouldn't it be cdPath?
The exception also needs to be modified a bit.
The exception also needs to be modified a little.
why does the exception have to be here?
nit: Can you please avoid multiple changes in this class?
nit: Can you get rid of the nit, please?
nit: Can you get rid of the last _verify on the new line?
As first issue, the variable name should be mediaListMode = MediaListMode.LIST;
As first issue, the variable name should be mediaListMode - this is actually assigned to the listMode variable.
As first issue, the variable name should be mediaListMode - this is actually a feature of the first letter.
What is the reason that this does not throw an exception instead of returning null?
What are the callers of this method public?
What is the reason that this does not throw an exception?
unnecessary change
Style-nit: Space after "
unnecessary changes
I would prefer that this is the same as I mentioned above.
I would prefer that this is inlined as I do not check the throws IOException.
I would prefer that this is inlined as I do not think its used anywhere.
Can we use method reference here?
need to use method reference here
Nice catch
suggestion return isBlank(queryParam.getValue());
suggestion return isBlank(queryParam.getKey(), queryParam.getValue());
suggestion return isBlank(queryParam) && isBlank(queryParam.getValue());
if you want to put this in the extension, you can set the analysis to the state system instead.
if you want to put this in the extension, you can set the analysis's state systemModule, and initialize the analysis in the state system.
if you rework this, you don't update the state system
s/getKeyGetter/get
Stray.toString()
Stray.
perhaps a lambda?
perhaps a race condition would be more visible?
perhaps a race condition would be better
It's better to use getCurrentUserLogin() here to be called userLogin.
It's better to use getCurrentUserLogin() rather than getCurrentUser().getName()
Please use [equalsIgnoreCase](<LINK_0>
I don't think this is the right thing to do. It's an unrelated change, and could you please review it?
I don't think this is the right thing to do. It's an override method, and called RecordsRetrievedContext, so it can be the current state.
I don't think this is the right thing to do. It's an override method, and called RecordsRetrievedContext, so it should be the current state.
nit: extract this to a method
You should define a "text" field of this class
You should define a "text" field and use that here.
LocalDate.format(Timeone.getTimeone("UTC"));
LocalDate.format(Timeone.UTC);
LocalDate.format(Timeone.UTC)
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "input". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "try with resource". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "Optional. [![rule](<LINK_1>](<LINK_2>
Maybe we should add a requireNonNull here?
Maybe we should add a requireNonNull here?
Why it is null? Can we have non-null a column?
I think it's better to use DEFAULT_FILE_NAME here instead of "/#replace('.', '/'".
I think it's better to use DEFAULT_FILE_NAME here.
In this case, I think it's better to use DEFAULT_FILE_NAME here.
There is no need to add this message.
There are no members defined for this message. You need to write this message.
There are no members defined for this message. We need to write this message to the user.
java if (nextChild == null) { return; } parent.parent = null;
java if (nextChild == null) { return null; } parent.parent = null;
Please add braces.
this should be if (encodings == null)
this should be if (encodings!= null)
should be if (encodings == null)
Suggestion: Consider using a ternary operator: suggestion if (server.getSonarQubeServer() && server.enableNotifications()) { return!settings.isBindingEnabled(); } return null;
Suggestion: Consider using GeodeAwaitility instead of the latter.
Suggestion: Consider using GeodeAwaitility instead of a ternary operator.
make it fail
make this in setUp method
make it fail()
This test is not testing anything. Which tests need to do here?
This test is not testing the rest of the for-loop. I think we need to do the rest of the for-loop here.
This test is not testing the rest of the for-loop. I think we need to do the rest of the test here.
Can we make this into the clientRegistrationId array as well?
Can we make this into the clientRegistrationId array as well? It would be great to split into several test cases.
Can we make this into the clientRegistrationId array as well? It would be great to have the test for it.
from the client point of view won't this getPaddingLeft() every time this method is called?
getPaddingLeft() is an int, but not really a big deal.
from the client point of view won't this getPaddingLeft() every time?
I wonder if this should be part of the callback?
I wonder if this should be part of the callback on the callback?
I wonder if this should be callback.onConnectCallbacks() to on top of the callback?
This will override default visibility, you want to do something similar to what is done in importStorageDomainBackup?
This will override default visibility, you want to do something similar to what is done in importStorageDomainBackup.
This will cause NPE, the storage domain is null, no?
This should be a User ID.
This should be externalized.
This should be a User ID, not a user.
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Still worth using Map<String, Object> commandParameters = Collections.emptyMap(); It's not a big deal, however in this case commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Still worth using Map<String, Object> commandParameters = Collections.emptyMap(); It's not a big deal, however in this case commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); it will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
nameOneMatcher sounds like the term of the last one. But since lineOneMatcher is very similar, maybe we could share the same code?
groupOneMatcher --> lineOneMatcher?
groupOneMatcher --> lineOneMatcher
updatePassword() method in UiCommonInitEventBase
updatePassword() method in CamelCase
fix formatting
"intent may not be null"
can we have this as an inner class?
can we combine the two lines above as checkArgument?
omit?
omit at the end of the constructor
omit at the end of the method?
can be chained onto previous line's assertion
nit: can be chained onto previous line's assertion
nit. keep one of them all together.
IMO it's cheaper to do the lambda: java CompletionStage<Void> stage = delegate.thenRun(() -> { if (Passivate!= null) { return stage; } else { return stage.thenRun(timestamp); } }
IMO it's cheaper to do the lambda: java CompletionStage<Void> stage; if (Passivate!= null) { return stage; } else { return stage.thenRun(timestamp); }
IMO it's cheaper to do the lambda: java CompletionStage<Void> stage; if (Passivate!= null) { return stage; } else { return stage.thenRun(() ->...); }
You can do getStartTime() directly on the start, and end coordinates in the parent class CTFStream. Surely you can have a dedicated method that does the same thing?
You can do getStartTime() directly on the start, and end coordinates in the parent class CTFStateInterval
You can do getStartTime() directly on the start, and end coordinates in the parent class CTFStream. Surely you can only call getStartTime() at the end of the start.
nit: This is not a good practice. Could you create a private method to create the TableName(String tableName)?
nit: This is not a good practice. Could you create a private method to access the TableName(String tableName)?
nit: This is not a good practice. Could you create a private method to create the TableName and creationTime? And btw what about non-static methods for creation?
remove this
remove throws Exception
remove "this"
Can be simplified to use connection = connection == null? null : connection;
Can be simplified to "if ( smart notifications is available in the SonarQube edition."
Can be simplified to "return connection;"
should be parameterized
curly braces are redundant
curly braces
Maybe we can rename this to reserveLastPlayerActive or onPlayerActive
Maybe we can rename this to to reserveLastPlayerActive or onPlayerActive
Maybe we can rename this to reserveLastPlayerActive or remove the field and use that.
Maybe should be an NotificationChannel here.
Maybe should be the channel name - "TelescopeService"
Maybe should be the channel name or something for channel
Add try/catch so that the auto-boxing will work just fine.
Add Override annotation.
Add Override annotation?
Should we update entry to null if included?
Should we update entry to null after setting entry?
Should we update entry to null after setting entry.
there are no assertions here?
there are no options for this.
there are no tests for this change.
I believe we should also change the exception message here.
I believe we should also get rid of the exception from the catch.
I believe we should also get rid of the exception from the catch block.
If this method can be private, then it will be easier to maintain and modular ones.
If the field was null, then it would be easier to read than that.
If this method can be private, then it will be easier to maintain and modular methods.
@exper0 full path HmRsHeader.VALUES_STR
@exper0 no need for all those texts.
@exper0 no need for VALUES_STR
Why don't you set bookmark to an empty list and simply call beginTransaction() here?
Why don't you set bookmark to an empty list and simply call setBookmark(true)?
Why don't we set bookmark here?
Shouldn't we handle the exception here, we don't handle NullPointerExceptions however.
Shouldn't we handle IOException instead? We catch and handle it.
Shouldn't we handle the exception here, we don't handle NullPointerExceptions however?
please make checkExpType('{', null) from empType() (or checkExpType('{bar)). Otherwise, you will be able to distinguish between these cases.
please make checkExpType() method more precise
please make checkExpType() method more simply to avoid the lines in the next test.
Can we please extract this list into a class?
Can we please extract this list into a static method?
Can we please extract this list into a static method.
This logic will be easier to read if we inline everything in the method.
This logic will be easier to read if we inline setBody.
This logic will be easier to read if we inline setBody(new ReactiveStreamsBodyGenerator(setBodysetBodysetBodysetBody)) or similar
Unneeded parenthesis
so it will require various changes without this PR
so it will require various changes without this else
Needs to be in ContainerScheduler.
Inline the variable.
Inline the variable
Why not just use valueConverter.convertAndSend(messageConverter.convertAndSend(message))?
Why not just use valueConverter.convertAndSend(messageConverter.convertAndSend(topic))?
Why not just use a convertAndSend(Message<?>) for consistency with equals?
Wouldn't it be better to wrap and throw in a RuntimeException, rather than suppressing with a log message?
Wouldn't this be enough to just wrap the EurekaClientConfig with a EurekaClientConfig with a eurekaClient API?
Wouldn't this be enough to just wrap the EurekaClientConfig with a EurekaClientConfig with a eurekaClient and and use that for both.
Consider making the strings a constant for this.
Consider making the strings a constant for this
Are you sure about the multiplication by id?
Exception is never thrown
Overdid: should be our own Exception class.
Exception is never thrown.
I'm not sure if this is correct. The method is not used anywhere.
nit: this extra line is unnecessary
I'm not sure if this is accurate - what if the first part of the list is empty?
Could you please use append?
Could you please use toString() instead of escapeAttributeValue?
Could you please use append here?
should this be clusterCompatibilityVersion?
should we use a final variable here?
should this be split?
Why did you change this?
This should be final
This should be final as well.
Can we make this configurable like for the view?
Can we make this configurable like for the view controller?
Can we make this configurable?
style nit: we don't use curly brackets around single line blocks
style nit: we don't use curly braces around single line blocks
lines 62-63 can be combined in the same line.
Do we need to check for converter converter in here?
Do we need to check for converter converter in both constructor?
Do we need to check for null here?
Why do we need to many operations, can't we use a linked list here?
Why do we need to many operations, can't we use a linked list?
Why do we need to many operations, can't we add the limit directly to the collection?
backingStream = null might be better here.
backingStream = null might be better to have the dispose.
backingStream = null might be better
@lmontrieux Wow... Strange. I think in this manner you can use entity.getWebRequest() instead of this.
@lmontrieux Wow... Strange. I think it can be final, but it works pretty well.
@lmontrieux Wow... Strange. I think in this manner you can use entity.getWebRequest() instead of this. Maybe it's best to add it as a method reference.
Missing position = checkNotNull(position, "position");
Please make the copy of inner class closeable.
Missing assert.
Why is this not assert?
Why is the first node not used?
Why is the first node not found here?
put this in a protected method
put this in a field declaration
put this in a protected method?
@yugander Why are there two tests using this method?
@yugander Why are there two tests using this constructor?
It looks like this test is breaking the intend on your recent password in your output.
Unchecked cast.
Unchecked cast to List<CodeSystem>?
Unchecked cast is not needed.
This method is really long, please use isSupported()?
This method is really long, please use isSupported() method.
This method is never used.
So, each sequence has its own comma separated value? Shouldn't this beStructType.isStructSupportSupportReader(type) instead?
So, each sequence has its own declaration, we can have a look at its usages. Shouldn't this be something like below? if (type == null || type.isStructSupport()) { and no need for all the other properties?
So, each sequence has its own comma separated value? Shouldn't this beStructType.isStructSupportEmptySupport(type);?
move up
why is listener needed? RepositorydanWindowListener never returns null.
why is listener needed?
can be simplified to if (SessionStatusChange.SYNC.equals(session))
Could it be SYNC_KEY instead of SYNC?
Could it be SYNC_KEY
Shouldn't we return clientStatusList.get(reg.getEndpoint())?
Shouldn't this be clientStatusList?
Shouldn't we return clientStatusList here? It seems like the clientStatusList will never be null.
Can we have a different name for this method?
Can we have a different name for this?
Can we have a different name?
Recommend assert(HIGH, high.max()).
Recommend assert(HIGH, high, low, high);
Recommend assert(HIGH, high, low, low)
This does not depend on any UI thread. Containers, which is a thread-safe way to do this.  synchronized (mUpdateLock) { if (mLock!= DOWNSTREAM_NONE) { mUpdateLock.compareAndSet(false, true); return; } }
This does not depend on any UI thread. Containers, which is a thread-safe way to do this.  synchronized (mUpdateLock) { if (mLock!= DOWNSTREAM_NONE) { mUpdateLock.compareAndSet(false, true); return; } else { lock.clear(); } }
This does not depend on any UI thread. Containers, which is a thread-safe way to do this.  synchronized (mLock) { if (mLock!= DOWNSTREAM_NONE) { mUpdateLock = true; } } if (setupNotification) { mUpdateLock = false; }
nitpicking: missing { here
nitpicking
nit: missing this. in the if statement
Maybe a check here that getLeft() and getRight() have identical schema?
Maybe we should keep the old version of the exception type (and getLeft() and getRight()) and use ByteStreams.get(InputStream).
Maybe we should keep the old version of the tuplesToRemove check?
That would be a good idea to have exceptions for control flow instead, since exceptions are thrown by the main handlers that can be used by the normal operation codecs.
That would be a good idea to have exceptions for control flow instead, since exceptions are thrown by the main handlers that can be used by the normal ones.
That would be a good idea to have exceptions for control flow instead, since exceptions are thrown by the main handlers that can be used by the one in ServletTools, but not that anything else.
elapsedNanos.
elapsedNanos -> remaining
elapsedNanos -> shutdown
remove this redundant else
I think this should be: shouldBeEqual(actual, other, other); for consistency.
the above should be: if (DeepEquals && DeepEquals && other.isNotSameClass()) {
It should be config.getDefaultClockProvider()
It would be better to move to the constructor.
It should be RuntimeException
it should be: verify(mIccRecords, never()).
0
0?
The "brackets for single statements" cleanup should be done in a separate commit, as we should not mix unrelated changes.
The "brackets for single statements" cleanup
The "brackets for single statements" cleanup cleanup
events are always registered. Your event won't be cancelled if the event is cancelled.
events are always registered. This might be be in the event queue.
events are always registered. This might be in the wrong order.
We might want to check the return value of showStockMediaPickerForResult and check if the method is called, like mSite is null and since we do in the constructor, this kind of thing isn't necessary. Wdyt?
Even if the local variable is not needed, it could be changed to mSite.isEmtpy()
We might want to check the return value of showStockMediaPickerForResult and check if the local uploadStockMediaPickerForResult is used? Wdyt?
Missing flush here.
Missing synchronization.
Missing synchronization?
Why do you use a linked list?
Why do you use an ArrayList?
Why do you use a LinkedList?
IIRC all super.dispose() can be called here.
IIRC all super.dispose() can be done here.
I think super.dispose() is unnecessary
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_3>
What if build.getParent()!= null?
What if build is null?
What if build.getParent() == null?
Please update also the collection after update.
Use { } around if statement.
Please update also the listener.
This needs to check the container doesn't exist.
This needs to return the writer to the caller
This needs to return the writer
Please don't use final for variable names. This can be omitted.
Please don't use final for the method parameters.
Please don't use final for variable names.
This can be simplified to: return Objects.equals(name, name);
This can be simplified to if (o instanceof NameHolder) { return (NameHolder) o; } return super.equals(name);
This can be simplified to: return Objects.equals(name, value);
This should never be false, the context is a IEvaluationContext.
This should never be true, the context is a IEvaluationContext.
This should never be true, the "show" flag should always be set to true.
Please make it _package_ to access the attribute_.
Please make it _package_.
Please make it _package_ to access the attribute itself.
This variable is not needed, the 'throws' is not needed anymore.
This variable is not needed, the 'throws' is not needed.
This variable is not needed, the 'expression' parameter can be removed.
It's a bit strange that you can just call setDefaultModuleSources.start() here. It would be more intuitive. Or, even better, if you don't want to initialize a new one.
It's a bit strange that you can just call setDefaultModuleSources.start() here. It would be more intuitive.
Don't put this in it's own method. It will be called whenever the BundleContext is called.
return this.lastChrom;
why this keyword is not needed?
why this three lines?
This should be an email Id, not a email.
This is not a test. It should be an email Id, not a email.
This is not a test.
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
Is takeLast() always false? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
Is takeLast() meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
I'd change the return value to "peakMemory" to "public". The change in this file is correct.
I'd change the return value to "peakMemory" to "public". The change in is no longer necessary.
I'd change the return value to "peakMemory" to "public". The change in these methods is a bit off.
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full range in the class field.
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in the other methods.
Since this is a legacy record, you can use {}Ls function here.
Why does the 1048576L then MAX_BASE_SIE then call 1048576LONE_LINE_SIE or something.
Why does the 1048576L then MAX_BASE_SIE or something?
Why does the 1048576L then MAX_BASE_SIE then call 1048576LONE_LINE_SIE or something?
Spacing
inline this variable.
inline this variable
use buffer.remaining() when allocating the copy buffer
use buffer.remaining() when allocating the copy part
could use buffer.remaining() when allocating the copy.
This should have a single return statement. Also, I don't think using System.nanoTime makes sense for this user.
This should have a single return statement. Also, I don't think using System.nanoTime makes sense for this user since it's not a valid value.
This should be config.data.getString(UNIQUE_TEXT_FORMAT).
I think this should be removed if we add new Optional.empty(); here, or at least return Optional.empty();
I think this should be removed if we add new Optional.empty(); here, or at least return Optional.empty().
I think this should be removed if there is no filter.
Could we use <LINK_0> as the assert is not very useful?
Could you use <LINK_0> instead?
Could we use <LINK_0> instead?
You can use AssertJ's [ExpectedException](<LINK_0>
You can use a Matcher for this.
You can use a Matcher#replaceAll here.
you should change the foreach to a for loop
you can change the foreach to a for loop
you should change the foreach loop here
Maybe wrap this into logger.info?
Maybe wrap this into logger.warn, since that might be the only thing we are calling?
Maybe wrap this into logger.warn, since that might be the only thing we are getting from here.
else is redundant
And here the address looks wrong.
} else {
use Objects.hash()
use Objects.hashCode(name)
This can be simplified by using Objects.hashCode(name)
If the getCachedVm() method is invoked multiple times, it will result in a null pointer exception. In this case, I wonder if this is not the right place:)
If the getCachedVm() method is invoked multiple times, it will result in a null pointer exception. In this case, we are not sure how we handle internal query correctly. It should be not part of the first place.
If the getCachedVm() method is invoked multiple times, it will have the same result.
Ensure the full stacktrace is logged.
java checkArgument("invalid_request.length > 1 && application == null");
Ensure the full stacktrace is logged so the full stacktrace is logged.
You can use Optional.fromNullable().
You're invoking get() twice. Let's use Optional.fromNullable().
You can use Optional.fromNullable() here.
Extract local variable for readability
Extract the local variable for readability
Extract the local variable for clarity
You should change this to: java final MElement container = getParent(part, left); if (part == null) {
You should change this to protected static?
You should first check if part == null
suggestion logger.warn("Could not remove element: {}", element.getUID(), ex);
suggestion logger.warn("Could not remove element: " + element.getUID(), ex);
suggestion logger.warn("Could not remove element: {}", element.getMessage(), ex);
Can you add a null check here? Otherwise the setter would have a better error message.
Can you do this in the constructor? Otherwise we will have a null pointer exception.
Can you add a null check here? Otherwise the setter would have a valid value.
Charset.forName("UTF-8")?
if the encoding cannot be null, then it will throw NPE
if encoding is null, it will fail to parse
Same as above, use a non-throwing version.
Same as above, use a non-modifyableList() method
Same as above, use a non-modifyableList() call.
I don't know if this is possible, given that you are only interested in the transaction, a BackDoor.
I don't know if this is possible, given that we are only interested in the transaction, a BackDoor.
I don't know if this is possible, given that we are only interested in the transaction, and we already know that it is in the transaction, so there is no need to confirm a pending request.
"{" is used to indicate object boundary, but in all other object.toString methods "[" is used.
"{" is used to be a long parameter, but in all other object.toString methods "[" is used.
"{" is used to indicate object boundary, but in all other object.toString methods "[" is used.", "long" instead of long.
What should be the reason for this?
should it be the other 'public' class?
What should be the other 'public'?
Why did you change the pattern for every pattern start?
Why did you change this?
Why did you change the pattern for every regex?
I don't think TM_RESOURCE_SPEC should be here.
In general, we don't need to create a new array each time.
I think NEEDs should be @Nullable
Here I believe the INSTRUCTION.getSharedPreferences().getStart() should be on the local variable.
Here I believe the INSTRUCTION.get(StartView.class) should be on the main thread.
Here I believe the INSTRUCTION.get(StartView.class) should be around the 'default' case.
Don't we need to do the caching here?
Don't we need to do fileContext.openFileContext(fileContext) here?
Don't we need to do fileContext.openFileContext() here?
I think this should be removed, right?
I think this fix is correct. From my point of view, we should look into pushing category-standalone/default value and change this code to use an enum.
I think this fix is right?
we should test with more than one "/apps/" + resourceExists"
we should test with the plugin name that is included in the test. the jira issue is that the plugin paths are with that name the plugin does.
we should test with the plugin name that is included in the test. the jira issue is that the name the plugin does not work.
Shouldn't you use the new isEmpty method?
Shouldn't you replace the null check with the entry is there in the map?
Shouldn't you replace the null check with the entry is there in the method?
Please remove this empty line
Please make this a NonNull
Please make this a public
since we are also loading the whole objects, I would prefer to avoid empty string, even if we don't have it.
since we are only loading the whole Trace, we should wrap these objects in a class and just use the KubernetesNamespace interface.
since we are also loading the whole objects, I would prefer to avoid empty string, even if it is null
Can you make a constant of this?
Can you make a constant of this class?
Can be inlined into one line
Could this be simplified to return Predicates.instanceofInstance(String name)?
Could this be simplified to return Predicates.instanceof(public, name)?
Unnecessary return type?
I think we need to do this by context.getClusterConf(), otherwise, the cluster configuration is not being used.
I think we need to do this by task executor, right?
I think we need to do this by context.getClusterConf(), otherwise, the leader is not just the configs which are already the IP.
I don't see a change to this method. How about making the default method name a singleton?
I don't see a change to this method. How about getting a list of environment names and then using it?
I don't see a change to this method. How about getting a list of environment names and then using a switch statement?
Why do we need this.directReplyToContainer.this.directReplyToContainer.this.directReplyToContainer.this.RabbitTemplate.this.listener?
Wouldn't it be better to set RabbitTemplate.this.directReplyToContainer.this.directReplyToContainer.this.RabbitTemplate.this.listener.cancel(true);?
Wouldn't it be better to set RabbitTemplate.this.directReplyToContainer.this.directReplyToContainer.this.RabbitTemplate.this.listener?
Things look good. What do you think about moving this logic to the model class?
Things look good so far. What do you think about moving this logic to the model class?
Things look good. What do you think about moving this logic to the client of the model class?
I think that in this case is a good idea to try to avoid calling finish, especially if the user calls dismiss(). It would be a good idea to extract the code in a new method
I think that in this case is a good idea to try to avoid calling finish, especially if the user calls dismiss(). It would be a good idea to extract the code here just to a new method in the Ui class that calls.
I think that in this case is a good idea to try to avoid calling finish, especially if the user calls dismiss(). It would be a good idea to extract the code here just to a new method
Would it be possible to put this to all the log statements at the same time?
Would it be possible to put this in the if statement instead of there?
Would it be possible to put this to all the log statements at the same place?
deletes should be on the same line.
deletes should be on the same line
I think this should be package access.
missing "commands".
missing "commands"?
e?
If requestToSave is null, why we need this line?
why do we need this line? I think it should be removed.
why do we need this line? I think we need request.setSecure(requestToSave.com)
Can we use this on the client side, and return a Response object?
Can we use this on the client side, and explicitly check for response.request.get().
Can we use this on the client side, and explicitly check for response.request.
Can be done in a single line.
Can be done in a single line: return pageLanguages.isEmpty();
Can be done in a single line using return getModel().
This is not necessary, the namespaceCreatableTests is enough.
As the namespaceCreatable, we need to add the namespaceCreatableTests annotation to the most member variables.
As the namespaceCreatable, we need to add the namespaceCreatableTests flag.
Maybe we should use sizeInG instead of sizeInGB?
Maybe we should use sizeInG since this is the only reason we have ero?
Maybe we should use sizeInG since this is the only reason we have > 1 GB?
fileName = "factoryClassName" can be null, see below.
fileName() is unused, can it be removed?
fileName = "Factory.create(path.toString()).toLowerCase();
I think there is a bug in Preconditions class.checkNotNull or similar.
I think there is a bug in the job itself.
I think there is a bug in the job builder, when boon you forgot to add a validation.
Should use a constant instead of a raw String
Should use a variable instead of a raw String
Should use ResistanceAnnotationParser.md
You could also return that to the Math.round call. See other places in this class.
You could also return that to the Math.round call. See other places in this file.
You could also return that to the Math.round call.
Why not use AtomicReference?
Can we remove all of this logic in this method?
Can we remove all of this logic?
You have two DAO calls here, which is the same as in BackendVmsResource.
You have two DAO calls here, which is the same.
You have two DAO calls here, which is the same as in BackendVmsResource, probably a matter of taste.
I think you can create a new method in the presenter and call this method from here
I think you can create an issue to the "presenter" instead of using newInstance() method.
I think you can do this check at the beginning of this method
I think that's enough to have executor and Timer stuff in all executors. We need to be some kind of mechanism for that.
I think that's enough to have executor and Timer stuff set in teardown. We need to figure out how to handle async calls in a normal way.
I think that's enough to have executor and Timer stuff set in teardown. We need to figure out how to handle async calls with the executor and executor.
We need to synchronized here too.
We need to synchronized on this method.
We need to synchronized on this.
Can we reduce this to return Optional<String>?
Can you describe the default machine name in the ds not found?
Can you describe the default machine name in the gerrit user?
Shouldn't we use the fileService.exists() method? This may cause NPE
Shouldn't file.isDirectory() be called from the teardown? And why not set the file.isDirectory() call instead of here?
Shouldn't we use the file.isDirectory() method? This does not cover this case
Just a nitpick: I think it's better to move this line in the synchronized block.
Just a nit: I think it's better to move this line in the synchronized block.
Just put that in the finally block.
if (executor == null) { executor = new Executor(); }
if (executor == null) { executor.removeExecutor(); }
if (executor!= null) { executor.close(); }
I think in this case you are missing a return from Platform.getCommandLineArgs();
I think in this case you are missing a return from Platform.getCommandLineArgs()
I think in this case you are missing a return statement
This is dangerous. A good example is to have a test that either all the fields in the global or none. (not sure if that's the case).
This is dangerous. A good example is to have a test that either all the fields in the global or none. (not sure if that's the case, but it has a way to set it to null which is not my opinion)
This is dangerous. A good example is to have a test that either all the fields in the global or none, but not the one.
There are a sub-base issue: It should be:.subs().base(.meshPart);. This should be simplified, so the code can be simplified.
There are a sub-base issue: It should be:.subs().base(.meshPart);. This should be simplified.
There are a sub-base issue: It should be:.subs().base(.meshPart);. This will also record that the'source' is not null.
Missing first argument of this method
Missing finalsrfc822Format?
rfc822Format must be added here.
nit: just do this: return environment.getArgument("disabled", true);
nit: just do this: return environment.getArgument("disabled", disabled);
nit: just do this as: return disabled;
nit: missing a space after if
nit: missing a space after the {
nit: I also think the checkNotNull would be fine to do that.
Minor: s/public//
Minor: Please add curlies here
Minor: Please add curlies here.
I think, if you're checking this, then, it would be best to move this test to a different class than the one above
I think, if you're checking this, then, it would be good to move this test to a different class
I think this should be in the base class
Is it worth checking that the result will be non-null?
Is it worth checking that the result will be null?
Is it possible to use org.eclipse.egit.util.Objects?
Should this be one line down after site?
Should this be one line down after site? The parcel.writeParcelable calls.
Should this be one line down after site? If so, can be removed.
I believe it's better to add the client.getChildren() to the stream of the ephemeral node names, since it's only the first client.
I believe it's better to add the client.getChildren() to the stream of the ephemeral node names, since it's no longer a path for each entry. (This is the case for which you want to do for instance)
I believe it's better to add the client.getChildren() to the stream of the ephemeral node names here, since it's no longer a path for each entry. (This is the case for which you want to iterate over the stream).
Probably should be a slash, not a separator.
Probably should be a constant.
Probably should be a slash, such as UTF-8
Shouldn't this be Flux.error(t)?
Shouldn't these be Flux.error()?
Shouldn't this be Flux.error()?
please put each parameter in separate line :)
Please put each parameter in separate line :)
please put each argument in separate line :)
I think this should be synchronized
Is this needed? I think setting the buffer to null would remove this check.
Is this needed? I think setting the buffer to null would remove this check since it might be safer to use a guard.
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
You should use a method to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one place.
1. I don't think vm can be null here, it should be verified in the canDoAction when executed, the check is not needed (getVm() == null) 2. you should check if you want to call endActionOnVm() before doing the check
1. I don't think vm can be null here, it should be verified in the canDoAction when executed, the check is not needed (getVm() == null) 2. you should check if you want to call endActionOnVm() before calling endAction().
1. I don't think vm can be null here, it should be verified in the canDoAction when executed, the check is not needed (getVm() == null) 2. you should check if you want to perform the job.
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface?
any reason not to put this method in the isReadOnlyPropertyCompatibleWithInterface?
any reason not to put the isReadOnlyPropertyCompatibleWithInterface?
add purpose?
add missing non-isSupported="
add missing non-null toString
Make this a final field
Make this a final variable
Make this a final
This can be deleted, right?
This can be deleted.
This was already initialized to null.
nit: can be removed
nit: can be removed to make public.
nit: imageName field can be changed to imageName
I think it should be > DEFAULT_EXPIRY_TIME.
should be RuntimeException
Please add validation on the parser.
Do we really need this? AIUI it's only used for authority.
Why is this necessary?
Do we need a second param here?
Should we make InputNoCloneCloneClones?
Should we make test more meaningful name?
Should we make InputNoCloneCloneClonesMessage?
return value!= null && value.trim().isEmpty()
return value!= null && value.trim().isEmpty() ||value.trim().isEmpty()
return value!= null && value.trim().isEmpty() || value.trim().isEmpty()
we can drop the LOG.error("Python Ready mergeinessChange(true)?
we can drop the LOG.error("Python Ready mergeinessChange {}", line.getLocalizedMessage(), line.get());
we can drop the LOG.error("Python Ready mergeinessChange {}", line.getLocalizedMessage(), line.get);
Please move the assignment inside the method.
Please move the assignment inside the method and remove the one below
Please move the assignment inside the if clause.
Shouldn't we use ReflectiveOperationException for the most specific exception?
Shouldn't we use ReflectiveOperationException to catch Exception?
Shouldn't we use ReflectiveOperationException.
This should be a list, not a Set.
This should be a list, not a set.
This is confusing. I don't know why we can't use the List directly here.
Nit: This should be null I think
Nit: This should be null
nit: This should be null I think
You can call beginFromRealm(int) with whatever it was called.
You can call beginFromRealm(int one) and remove the if from start().
You can call beginFromRealm(int) with whatever it was called. The same problem exists in the table in the database
target could be null here
let's keep this condition simpler.
target could be null here.
What if the list is empty?
What if the list is empty? return Iterables.filter(apiRoleList).stream().filter(c -> c.getItems()!= null).collect(Collectors.toList());
What if the list is empty? return Iterables.filter(apiRoleList).stream().filter(c -> c.getItems()!= null).collect(Collectors.toSet());
Is this the right error message?
Is this the right default?
Is this the right switch?
This method could be static.
This method seems to be duplicated by createBlockIdsInLocalStore, but this should be static.
This method seems to be duplicated by createBlockIdsInLocalStore, but this should be private.
static import
Static import
static import?
It would be better to store the Update_id into a field, no need to synchronize on it.
It would be better to store the Update_id into a field, no need to do this twice.
It would be better to store the Update_id into a field, no need to do it twice.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.name: 'xs:string'
We can check action.isNonricks(), since action can be null.
We can check action.isNonricks(), since action can be null in some context.
Since closeStreamAfterSend() throws an exception, we should have a try/catch around this.evaluationContextSet.forEach().
Since closeStreamAfterSend() throws an exception, we should have a try/catch around this.evaluationContextSet.forEach()
Since closeStreamAfterSend() throws an exception, we should have a try/catch around this method.
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jmc with should be disabled");
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jmc with should not supported for Jelly");
typo
throw the exception
throw DeploymentException
why not config.cageHeight()?
Please use ConfigData config = config.getCageHeight();
Please use ConfigData config = new HashMap<>();
Since the message doesn't say anything. The test needs to be changed.
Since the message doesn't say anything, it's not clear what's the point of the test. The Validator is supposed to be used for verification.
Since the message doesn't seem to be used, it's used to be zero.
@erimerturk why you're using RqFake here?
@erimerturk why you're using RqMultipart.Fake here?
@erimerturk why not use RqMultipart.Fake here as well?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!getClassConstantOperand().endsWith("getPackageName().equals(getClass()) can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!isSubtype() can be present, and should be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!isSubtype() can be present, and should be useful to have fallback when the complete class hierarchy can be loaded.
Should we store the input in a field?
Should we store the input in a field instead of recreating it every time?
If data is empty and data is returned by the getter, why not in this case?
I think we should be more explicit about the ContextListener so we don't end up in any case.
super.onAttach() should be called on an Context
super.onAttach() should be called on the Context constructor, so that we're still using the Context constructor.
output.print(...) can be replaced by : new PrintStream( output);
output.print(eventBody) is unnecessary
output.print(eventBody)
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be the last parameter the log
you could use!= instead of.equals here.
I would add a call to repaint here.
This looks like a call to repaint here.
This seems a bit of a call to repaint.
please add call to populate: add(populate(connection))
please add call to populate: add call to populate: add(populate(connection))
please use the mapping locator
probably should be setActionMessageParameters()
please rename to CommandContext
please remove brackets
I think we should use "1.0".equals(version) to avoid possible NPE
I think this should be "1.0".equals(version) to avoid possible NPE
I think this should be "1.0".equals(version)
How about throw an IllegalStateException? Then we can remove the test, and remove the throws clause.
How about throw an IllegalStateException? Then we can remove the test, and remove the throws clause anyway.
Rename command to command
nit: this vs this. wrapper?
nit: this vs this.
wrapper?
If you have a request, it would be better to do that with the current copyAs method.
If you have a request, it would be better to do that with the current copyAs method of the list.
If you have a request, it should be marked as @Nonnull
I think we should use Logger.debug("On index {}", i); instead.
I think we should use Logger.warn
I think we should use Logger.warn.
the 'public' is not needed
why not use the 'public' access?
why not use the 'public'?
As above: private, 100 chars, use error result instead of doOnError.
As above: private, 100 chars, use error result instead.
As above: private, 100 chars, use error result instead of remove
Sure we do not need this event. Maybe just do something like this: java start().map(this::elevatedAccess).flatMap(Arrays::stream); This wouldn't work, since the listener will only be registered if you add the elevatedAccess event, and the listener will be stopped.
Sure we do not need this event. Maybe just do something like this: java start().map(this::elevatedAccess).flatMap(Arrays::stream); This wouldn't work, since the listener will already know when the event is shut down.
Sure we do not need this event. Maybe just do something like this: java scheduler.schedule(this::create);
Can this be extracted to a new method isBinaryValid().
Can this method be made private?
Can this be extracted into a new method isBinaryValid().
Suggest this: if (userChoice == JOptionPane.YES_OPTION) { return CanOpenState.NO_OPTION; } else { return CanOpenState.OPEN; }
YES_OPTION -> YES_OPTION
YES_OPTION = true;?
Does it make sense to check for assignment == null? Because it's not the most common case to find the assignment.
Does it make sense to be getNonStrictParentOfType here? That will return true for arrays of assignment being null.
Does it make sense to be getNonStrictParentOfType here? That will return true for arrays of assignment being null
This looks good.
This looks good. Do we need to make it public?
Should we make it final?
Is this a bug fix?
nit: we can use same pattern here as well.
nit: We don't use final for local variables
Why do we need above change? dbName and schema should be set in the other constructor.
Why do we need above change? dbName and schemaName can be null if we don't set in the DB.
Why do we need above change? dbName and tableName can be null if we don't call dbName.
Minor: " application from {} to {}", application.transitionTo(status, target);"
Minor: "Connection for {} is missing"
Minor: "Connection failure"
Wouldn't it be better to just use DataTypeLibrary.getInstance().getDataTypesSorted()?
Wouldn't it be better to just use DataTypeLibrary.getInstance().getDataTypesSorted().
Wouldn't it make sense to just use DataTypeLibrary.getInstance().getDataTypesSorted()?
this should return the entire hostProviderProxy instead.
this should return the entire hostProviderProxyFactory which returned the providers?
this should return the entire hostProviderProxyFactory which is returned on the command
Speaking of sanity checks, is this: (100 - minLastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Speaking of sanity checks, is this: (100 - minLastVerified) + 1 OR 100 - (lastVerified + 10)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Speaking of sanity checks, is this: (100 - minLastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Left over from debugging?
remove, ;
remove, ;)
Wouldn't it be better to just use "return Objects.toString(o1 == null)" here? I don't think we'll ever get here.
Wouldn't it be better to just use "return reportDifference(o1 == null)" instead?
Wouldn't it be better to just use "return Objects.toString(o1 == null);" instead?
I think that's the same as equalTo, but the methods are actually replace the same. So it would be possible to use something like equalTo(0) here.
I think that's the same as equalTo, but the methods are actually replace the same. So it would be possible to use something like equalTo(0)?
I think that's the same as equalTo, but the methods are actually replace the same. So it would be possible to use something like equalTo(0) instead of count(*).
why do we want to restrict it? the error messsage is relatively harmless and doesn't really alter the flow
why is it needed here? the returnValue is a thawVmFailure, if it's not used yet, why is it needed?
why is it needed here? the returnValue is a thawVmFailure, it's not related to this patch
This synchronization is not needed. listFiles can return null if it doesn't exist.
This synchronization is unnecessary
This synchronized block is unnecessary
I think this method should return RemoteCache<K, V>
This method should return RemoteCache<K, V>.
I think this method should return Cache<K, V>
Isn't pattern should be a the first ? (add extra  a the end)
Isn't pattern should be > 1? (add extra  a the first)
Isn't pattern should be a constant that can be used instead of duplicating this pattern?
this might fail in null pointer exception. I'd do something like: suggestion verifyListeners(poolId, id -> { if (poolId.isEmpty()) {
you need to wrap this.
this might fail in null pointer exception. I'd do something like: suggestion verifyListeners(poolId, id -> {
Make it final static
Ordering.natural().nullFirst()
Ordering.natural().nullFirst()?
nit: we could extract this into it own method or extract it as it's repeated on each callback
nit: we could extract this into it own method or extract it as a private method?
nit: we could have it as final?
why not just dir.exists()?
why not just dir?
why not just dir.get()?
This method should return the interface (e.g. getComptectedRegion(affectedRegion) or similar as well.
This method should return the interface (e.g. getComptectedRegion) as well.
This method should return the interface (e.g. getDiagram()) not / fetchmp3
Can you change the return type to boolean?
Can you change the use of StringUtils.contains() to isBlank?
Can you change the use of StringUtils.contains() to not check for null.
Maybe we could add a check to make sure we don't have a if (instancePlan.isPresent()) return Optional.absent();
Maybe we could add a check to make sure we don't have a if (instancePlan.isPresent()) return Optional.absent().
Maybe we could add a check to make sure we don't get a PackingPlan object if the Plan is empty?
This could be tweaked to return immediately, since the menu is not enabled it does not worth continue.
This could be tweaked to return immediately, since you are not doing continue.
This could be tweaked to return immediately, since we are not doing continue.
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
Doesn't the remove() function return you the UpdateHandler which you want to call onCompletedExceptionally() on?
Doesn't the remove() function return you the UpdateHandler which you use?
mListener should be outstanding requests. Otherwise, you have to call onSuccess() multiple times
mListener should be outstanding requests. Otherwise, we'll have to call it twice
mListener should always be null
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it.
It would be better to read _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwner_
It would be better to name it as _ensureUserIsWorkspaceOwner_
introducing double retrieval from thread local, unnecessary perf hit
introducing double retrieval from thread local, better use an AtomicBoolean
introducing double retrieval from thread local, better to use an AtomicBoolean
Why the this.close()? This should be in the finally block.
Why the this.close()? This should be in the finally clause.
Why the addition of this? This should be done in the try-with-resources
I find it a bit strange to define this in a constant
I find it a bit confusing with the current code. I'd prefer to use this instead:.map(Item.getIdItem(tab.getIdItem()).ifPresent(item -> { tabPane.getId().isEmpty()?
I find it easier to read a bit by name if we use as a constant
Please use log4j.logAndThrow. Ill give some more details about what went wrong.
Please use log4j.provider instead?
Please use log4j.logAndThrow.
Can we use brackets now?
Can we use brackets here?
Can we use Guava's Strings.nullToEmpty?
Can you please reformat this method with the same name as 4th argument?
Can you please reformat this method with the class name so it will be easier to read?
Can you please reformat this method with the same name as 4 times?
The Class isn't a class context, as it is used to be inside of a service implementation. Use the contextService's parentService.getParentId() (instead of context.getParentId())
The Class isn't a class context, as it is used to be inside of a service implementation. Use the contextService.getParentId() method from parentService.
The Class isn't a class context, as it is used to be inside of a service implementation. Use the contextService.getParentId() method from the service to get the parent.
Could you use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
Could you use either class or style. This is entirely possible to have both. The style always takes precedent over the class.
Could you use either class or style. It is entirely possible to have both. The style always takes precedent over the class. The class always takes precedent over the class.
you may return responses; here, if response is null, return responses;
you may want to return responses; here, responses is non-null. since callers are not supposed to use the other keys in response objects.
you may return responses; here, if response is null, return response;
Should log an error and not silently ignore or not.
add logging
Should log at least the stack trace.
I think that the two fields are used here, which is the same as the default one.
I think that the two fields are used here, which is the same as this.difficultyResourceKey.
I think we should add this field to the "options" field
Do we need to create a new object here? I think it would be better to use it in this method.
Do we need to create a new object here?
Do we need to create a new PageSuggestions here?
Can we collapse this to: checkArgument(isValueTypeArgument(), "lambdaInterface".equals(public Class<LambdaInterface>), EnumInterface.class);
Can we use a more meaningful name?
Can we use a more specific exception?
I think this method should be synchronized to prevent two people from reserving the same seatService
I think this method should be changed to public
I think this method should be changed to public.
nit: this.min = max;
nit: make this private
nit: this.min = min;
This should be the type to the dictionary
This should be the type.
This is not necessary.
Can combine the 2 above lines and use the constructor which accepts disk-id
Can combine those 2 lines and use the constructor which accepts disk-id
Can combine this 2 lines and use the constructor which accepts disk-id
I wonder if this needs to be 'public' or 'public'. In other words, are the two lines necessary?
I wonder if this needs to be 'public' or 'public'?
I wonder if this should be 'public' or 'public'?
It would be useful to also store the CachingEnabled object in a field.
It would be useful to also store the CachingEnabled object in a field, and also check it for null.
It would be useful to also store the default and store in a field.
Hm, these two messages are not consistent. They are unnecessarily final.
In slf4j, for better readability, we don't need the exception.
Hm, these two messages are not consistent. They are pretty much different.
Minor: Use this. consistently in the class.
Minor: Use this. consistently in the class. Same for the other constructor.
Minor: Use this. consistently in all other places.
I'd add a checkNotNull here.
Please add a null check.
Why this constructor is public?
Is it necessary to check the configMap itself? Otherwise we may end up with a NullPointerException here.
Is it necessary to check the configMaps from the map? Otherwise we may end up with a NullPointerException here.
Is it necessary to check the configMaps from the map? Otherwise we may have issues with the original Map.Entry.
Can we use hostAffinityEnabled instead of hostAffinityEnabled here?
Can we have a check for "hostAffinityEnabled" method?
Can we have a check for hostAffinityEnabled before the refresh?
Please check the cause of this exception to be thrown instead.
Please use the new message for the null case.
Please check the cause of this exception to be thrown.
I think you can use hotfix.
I think you can use hotfix.get(position++);) here.
I think you can use batch.size() here instead of calling next().
Suggest delaying the delay to 0.
Suggest delaying the delay to 0 would prevent the delay between delay and delay.
Suggest delaying the delay to be after the delay has been passed.
Empty filter? The filter should be turned into a constant, e.g.: java private static final Map<String, Object> filterFields = new HashMap<>(Map.Entry::getKey, Map<String, Object> filterIndex) { return map.values().stream().map(Map.Entry::getValue).collect(Collectors.toList()); }
Empty filter? The filter should be turned into a constant, e.g.: java private static final Map<String, Object> filterFields = new HashMap<>(Map.Entry::getKey, Map.Entry::getValue);
Empty filter? Otherwise, it's defeats the purpose of the filter. Also, should there be a test for that?: java if (properties == null) { return null; }
I don't think this is necessary
I don't think this is the right place to put the free dataChanged in this method.
I don't think this method should be synchronized
public?
protected?
public
suggestion log.debug("Unsupported S3Select serde format found: {}", serdeName);
suggestion log.debug("Unknown S3Select serde format found: {}", serdeName);
This can be simplified to info("boolean serdeName: {}", serdeName);
Perhaps click on the button too?
public?
click on the button here
ISO-8859-1" should always be a "ISO-8859-1"" path, so it is just a "original" literal.
ISO-8859-1" should have a "ISO-8859-1"" literal, so it is just a typo.
ISO-8859-1" should have an extra space.
Should this be a ConcurrentMap instead?
Should we reset this field in the constructor instead?
Should we reset this field in the constructor instead of here?
suggestion Preconditions.checkState(runtimeConfig.get("Either Refreshable or Supplier of runtime config must be provided or none.");
suggestion Preconditions.checkState(runtimeConfig.<String>, "Either Refreshable or Supplier of runtime config must be provided or none.");
suggestion Preconditions.checkState(runtimeConfig.<String>, "Either Refreshable or Supplier of runtime config must be provided or none of them.");
@vilchik-elena I would make it a method
@vilchik-elena I've refactored this method to be reused in the next method
@vilchik-elena I've refactored this method to be reused in the right way.
add { and } around if body
add { and } around if you like
add { } around if body
resolveLiteral() can be private, I think
resolveLiteral(char) is a String, why can't you resolve it?
resolveChar
unsupported
unsupported exception
braces
Add LOGGER.log(Level.SEVERE, "Reschedule Listener"); to avoid the same code.
Add a LOGGER.log(Level.INFO, "Restarted Listener will not be scheduled"); on the console
Add a LOGGER.log(Level.INFO, "Restarted Listener will not be scheduled"); on the same thread.
Consider using HashCodeBuilder to build the value for this String.
Consider using the constant for this.
Consider using HashCodeBuilder to build the value for this string.
Better to use Java 7 String.join()
Better to use Java 7 String.join() to convert to Stream
Better to use Java 7 String.join() to convert to Stream api.
rename to viewStack
Why do you return the viewStack field is void?
This return will be avoided.
Is it worth checking that the tag doesn't exist?
Is this a sufficient check? Should we test for the tag not being deleted?
Is it worth checking that the tag was actually deleted?
This could be made more compact.
This variable can be declared outside the loop.
This could be made more useful as an argument to logPath
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void shouldContain(AssertionError.class) { AssertJ.assertThat(failures).failure(INFO, shouldContain(someInfo())); }
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void shouldContain(AssertionError.class) { AssertJ.assertThat(failures).failure(INFO, shouldContain(someInfo())); } }
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master).
I would prefer to return the result of equals to avoid the need for the comparison
I would prefer to return the result of equals to avoid the need for the else
I would prefer to return the result of equals to avoid the need for the comparison, as you're doing the actual comparison
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
To follow Spring Security conventions, please change Raw password to match the default value.
To follow Spring Security conventions, please change Raw password to use the default value.
This change breaks binary compatibility, but cannot be OK.
This change breaks binary compatibility, but cannot be avoided. Inline.
This change breaks binary compatibility, but cannot be sure.
This is null. For consistency, I find it is better to use getRawCapabilities instead.
This is the same from the method, so there is no need to iterate over the capabilities.
This is null. For consistency, I find it is better to use getRawCapabilities(CapabilityType.TOKEN_TYPE).
The synchronized can be removed.
Naming: I don't think "this." is really necessary.
Naming: I don't think "this" is really a good name.
Add final keyword.
Revert
UncheckedIOException
Map<TableScanNode, Void> result = new IdentityHashMap<>();
Map<TableScanNode, Void> ret = new IdentityHashMap<>();
LinkedHashMap not TreeMap here.
Just return getProperties().getSingleProperty( name, defaultValue);
Just an FYI, there's a.collect(Collectors.collectingAndThen(Collectors.toList(), String::parseInt));
Just an FYI, there's a.collect(Collectors.collectingAndThen(Collectors.toList(), String::valueOf));
Small style nit: no braces around single line blocks
Small style nit: no braces here
Small nit, but could you build a style issue here?
Don't we need these inside the try()?
Don't we need these inside the try block?
Don't we need these inside the try() block?
please don't use getLastWatchdogEvent() == null
please don't use getLastWatchdogEvent().
pls use formatter.
can this be private?
can this be made private?
can this be ever visible?
It should call super.init() first, then fProcessAll() will be called.
I think we should try to use fExperiment.init() here, like you do in fExperiment.init()
I think we should try to use fExperiment.init() here, like you do in fTrace.init()
Include the method name as well?
Include the method name as well
Include the method name as result.
I guess it would be better to add this to the ExpressionPresenter's functions.
I guess it would be better to add this to the ExpressionPresenter's implementation.
I guess it would be better to add this to the ExpressionClicked#onRemoveExpressionBtn.
should this be maxAllowed?
should this be maxAllowed == 0?
should use maxAllowed == 0
Why not return clusterId;?
Why not return clusterId?
return clusterId;
Change this variable declaration to something with meaning in the context. map is unclear here
Change this variable declaration to something with meaning in the reader. map is unclear here
Make this variable declaration a variable.
is this intended to be -1 for blobTimeInMs requests?
is this intended to be -1?
is this intended to be -1 for blobTimeInMs operations?
Same here, let's throw Exception instead of throwing Exception
Same here, let's throw Exception instead.
Same here, let's throw Exception
Use GLOBAL_ROLE_PATTERN
Use GLOBAL_ROLE_PATTERN here, to avoid duplication
Why do you have null check here?
Put the 'if' before the first check.
Please don't remove this.
Please add braces.
1 or 2?
FQN of class, is not very descriptive.
FQN?
can't we use safe assignment if all listeners are in the same thread?
can't we use safe assignment if all listeners are used?
should be synchronized
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a non null, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning.
- This method is not very specific. I think this should use a DhealtcheckRefreshTime rather than the clock?
- This method is not very specific. I think this should use a DDB decision.
- This method is not very specific. I think this should use a DDB
The cache mode doesn't care about the value from the cache, it is resulting in the client configuration.
The cache mode doesn't care about the value.
The client mode doesn't care about the value here.
shouldn't this be /library/file.proto
This should be /library/file.proto
should this be /library/download-commands
I'm not sure if this is the correct error message. Shouldn't it use the new ErrorException(format(message, dd MMM, yyyy),?
I'm not sure if this is the correct error message. Shouldn't it always be ERROR_NOT_FOUND?
I'm not sure if this is the correct error message. Shouldn't it always be ERROR_NOT_FOUND or 403?
could you use singletonList?
could you use isEmpty?
maybe use singletonList
This will create 0 connections. Didn't you mean <?
This will create 0 connections. Didn't we mean <?
Didn't you mean <?
Why don't we just create a Gson from the parser?
Why don't we just create a new GsonBuilder here?
Why don't we just create a new GsonBuilder() here?
Is the KeyPair.509 required here?
Is the KeyPairProvider not available?
I think this method should be synchronized, as the tryLock() method is safe.
Since we are removing the owner of the group, I don't think we should continue to call unsubscribe after emitting the groupIds.
Since we are removing the owner of the group, I don't think we should continue to use the groupIds collection. Actually, I think we should remove the outer groupIds collection from the group.
Since we are removing the owner of the group, I don't think we should continue to use the groupIds collection. Actually, I think we should remove the outer groupIds array as well.
use the pattern where possible, isn't it?
rename the local variable to ascending
rename to ascending
I guess this should be setIdGenerationStrategy.GenerationStrategy.GenerationStrategy.GenerationStrategy.
I guess this should be setIdGenerationStrategy.GenerationStrategy.GenerationStrategy.
Add a null check.
Can this be simplified to Arrays.asList(o);
Can this be simplified to Arrays.asList(whitelist, options)
should this be Arrays.asList()?
This seems to be quite complex! Maybe we can extract it to separate method?
This seems to be quite complex! Maybe we can define a PanelDetailsMap element returned?
Can you use PanelUtils from this?
hmm, what does this exception mean?
hmm, what does this mean?
URI instead of getChild("not implemented")
Guessing this locks should be acquired here.
Guessing this locks should be on the same thread
Guessing this should be parameterized
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
"%s/_job.%s.log" is used in all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId).
This code has nothing to do with a vanilla flag, isn't it?
This code has nothing to do with a vanilla flag, isn't it? This code also only gets called once per json?
This code no longer needs to be inside the synchronized block, only the state and state are different from the pending state.
I'm not sure if this combination is correct. It seems that you should return early on the result of this method. So, to be sure to make it consistent with the rest of the method. I would use a try-with-resources statement here.
I'm not sure if this combination is correct.. it seems that that you should use a try-with-resources statement.
I'm not sure if this combination is correct. It seems that you should return early on the result of this method. So, to be sure to make it consistent with the rest of the code base. I would use -1 values for the state in the unit test.
can be package private?
can be package protected instead of public
can be package private?...
This should probably use Objects.equals to make sure that the interval can be parsed
This should probably use Objects.equals to make sure that the interval can be parsed.
This should probably be && instead of ||
I think this part is redundant with the settings in setupModuleChanged(), isn't it?
I think this part is redundant with the settings in setupCMAS, isn't it?
I think this part is redundant with the settings in setupModuleToCMAS, isn't it?
sysout?
debugging code?
remove
won't this cause NPE?
won't this throw an error?
agree?
Let's change it to get the child commands CommandBase.
Let's use diamond operator.
Let's use java.util.Objects.requireNonNull(commandId, "commandId");
We have a Utils.nonNullString() for this.
We have a hamcrest matcher here.
Looks good.
Redundant parentheses.
Redundant parenthesis.
Redundant "else"
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml(), fieldNames);
Let's rename this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());
Maybe put this on the call to the constructor?
Maybe put this on the call to super, so the error messages are consistent.
Maybe put this on the call to super, so the diff is consistent.
Extra parentheses can be removed
Extra blank line
CaseConstants.format might be easier to read
suggestion log.debug("Unable to find default configuration: {}", DEFAULT_API_KEY_PROPERTIES);
suggestion log.debug("Unable to find default location: {}", DEFAULT_API_KEY_PROPERTIES);
suggestion log.debug("Unable to find default configuration: {}", filename);
suggestion if (keyedStateBackend instanceof CheckpointListener) { Since the instanceof operator always returns false for null, there is no need to have an additional null check.
suggestion if (keyedStateBackend instanceof CheckpointListener) { Since the instanceof operator always returns false for null, there is no need to have an additional null check in the synchronized block.
suggestion if (keyedStateBackend instanceof CheckpointListener) {
I think it is better to use parameterized logging instead of string concatenation.
I think it is better to use java.util.stream.map.collect(Collectors.toList())
I think it is not appropriate to use java.util.stream.map.collect()
write nullable on the same line or don't write it
write nullable on the same line or don't write it more.
use the writeOngoing() method
we need to setVisible() here, since we're not actually using this value.
we have a race condition here. setVisible() is not necessary now.
we should still append here?
"auto" -> "nomous"
"auto" -> "from Built"
"auto" -> "local"
should be written in a finally block
Shouldn't conn be a finally?
should be written in a finally block?
May be worth to use startsWith instead of endsWith.
May be worth to use startsWith instead of endsWith?
May be worth to use endsWith(".
don't a need to check for null, it's true by default
boolean canExecute = false;
don't a need to check for null, it's true by default.
move 0 to private constant as you use it in many places
add PageObjectLogging.log method here
move 0 to private constant as you use it in many lines, please
better to set slaveConnectTimeout to true here to indicate a slave or intermediate timeout.
better to set slaveConnectTimeout to true here to indicate a slave or intermediate packet.
better to set slaveConnectTimeout to true here to indicate a slave or intermediate timeout, to ensure that it can happen as expected.
I think it would be nice to keep the options map, instead of using a new one.
I think it would be nice to keep this method unchanged (to support support for handling options in URL, but I don't think it's a special case).
I think it would be nice to keep this method unchanged (to support support for handling options in the map.)
please rename to source
please rename to mappedToVds
please rename to mappedToVdsUpdate
What is the difference between create and buildAccountUpdater?
What is the difference between createAccountUpdater and GetAccountUpdater?
What is the point of throwing a NoSuchFieldException for these exceptions?
Should this be acid? And not acid?
should this be acid? And not acid?
Should this be acid field? And not acid?
Can you make this a method, and use the [this](<LINK_0> instead?
Can you make this method private? If we want to make it public, then it's better to use the [public static](<LINK_0>
Can you make this method private? If we want to make it public, then it's better to have it static.
Not sure about this, but I find the default. Should this be a primitive long instead of null?
Not sure about this, but I find the default. Should this be a Double instead of Boolean?
Not sure about this. Should this be synchronized?
Did you mean to check that the group does not exist?
Did you mean to leave this if, too?
Did you mean to check that the group is still locked?
can be simplified to just this.version = new StringBuilder();
Nice idea to extract this into a named constant
can just define this
If we are going to change this logic anyway, I'd prefer keeping it package-private.
If we are going to change this class, why not make it static?
If we are going to change this logic anyway, I'd prefer keeping it package-private rather than private.
Consider adding a getFlows method to the criteria, i.e. noFlows
Consider adding a getFlows(Flow) method to the criteria, i.e. noFlows
Consider adding a getFlows(Flow) method to the criteria
This log is redundant. Just use the class name
Better to log here.
We should log this error.
why not use the Java conventions for variable names?
why do we need to log it?
why not logging it?
It could use the following style: java final PopupFlagCustomPageIndicatorMenu = ctx.getIdId();
It could use a lambda expression: java performActionIndicatorMenu(Context ctx) { this.popup = ctx.getIdId(); }
It could use a lambda expression: java performActionIndicatorMenu(Context ctx) { this.popup = ctx.getId().equals("custompages.popup"); }
could use the CommonUtils.toImmutableSet() method here?
could use the CommonUtils.toImmutableSet() method instead.
should probably use the same approach as in the Utils.toHashCode.
The original might not be larger than t11 t01.
The original might not be larger than t11 t11 t01.
The original might not be larger than t11 here.
should it throw an exception instead of returning null?
should it throw an exception?
should we log the exception here?
Let's keep this until it's completed.
deregisterInteresting can be removed
Remove this
We don't need to use a null key here. Use a uploadedFileFilter.
We could extract a common part to a uploadedFileFilter.
We don't need to use a null key here. Use a DEFAULT_IMAGE_AND_FS
Can we use nodeStats.getPlanNodeId() here?
Can we use nodeStats.getPlanNodeId() instead of nodeStatsCalculator?
give this a static method
Shall we define this as a constant?
Shall we use the constant here?
Shall we make this a constant?
I think we should use entrySet instead of keySet.
I think we should use entrySet instead of keySet
could we use entrySet instead of keySet?
are you sure about this exception?
are you sure about this one?
Would IllegalStateException be better here?
Code style issue -t as to have an extra PR.
Code style issue -t as to have an extra tense issue.
Code should have -t been removed
suggestion logger.warn("The JsonPath expression does not contain " + list.size() + ": " + list.size());
suggestion logger.warn("The JsonPath expression does not contain " + list.size() + " for list.", list);
suggestion logger.warn("The JsonPath expression does not contain " + list.size() + " is not present.", list);
Use dataBuffer.getInt instead.
Use dataBuffer.getInt(4);
Use dataBuffer.getInt instead?
Readability is concern here. If the id is not set, it will throw a NullPointerException. Other than that, getId() will throw a NullPointerException.
Readability is concern here. If the id is not set, it will throw a NullPointerException. Other than that, getId() will throw a null pointer exception.
Readability is concern here. If the id is not set, it will throw a NullPointerException. Other than that, getId() will get called as null. Could you double check?
This should probably use TextUtils.isEmpty(items) instead of the language name.
This should probably use TextUtils.isEmpty(pattern) instead of the language name.
This should probably be languageName field.
Same issue as above.
Same question about the above : what about using a Boolean accessor variable as well?
Same question about the above.
Can we rename 'p' or 'p'?
Can you please rename 'p'?
Can we rename 'p' or 'e'?
Instead of overwriting the gamemode from GameModeUtils.prettyPrint(gamemode) could we use the [gamemode](<LINK_0> syntax for that?
Formatting, we don't use tabs in this project (also, I know, but only one variable is the "gamemode" string).
Formatting, we don't use spaces around operators like this
This is wrong. If you use the custom Version all over the place, you should probably also use the resource string.
This is wrong. If you use the version you're hardcoding above, you should use.state("eva-id")
This is wrong. If you use the version you're hardcoding above, you should use.state("eva-version")
Do we need this?
Do you need this?
Do we need this? Can't it be done with normal status?
I'm not sure this is really needed. All TranslationFormat should be format = format.getString("format(Format.USX, format)
I'm not sure this is really needed. All TranslationFormat should be format = TranslationFormat.USX
I'm not sure this is really needed. All TranslationFormat should be format.
Is there a reason for this to be a list of classes that aren't using?
Is there a reason to use a generateDisplayNameForClass method instead of using a getDisplayNameForClass? The reason is that the test method is only used for this test. If you want to make the test method more than one (i.e. convertDisplayNameForClassTypes(testClass), the reason is that the test method has a generateDisplayNameForClass method.
Is there a reason to use a generateDisplayNameForClass method instead of using a getDisplayNameForClass? The reason is that the test method is only used for this test.
This should be 8 bytes. See Bytes::read.
This should be 8 bytes. See BytesWritable(byte[], int).
This should be 8 bytes. See BytesUtils.writeLong(buf, bytes); right?
>byte[] [](start = 11, length = 6) DecryptResult
>byte[] authentication [](start = 11, length = 6) DecryptResult
>byte[] authenticationTag
This can be static
This can be static.
This can't be static
Can we use Arrays.deepEquals here instead?
Can we use Arrays.deepEquals here?
Can we use Arrays.deepEquals for consistency?
1. This can be simplified to: java if (this == o) { return true; } if (o instanceof SerializerConfig) { SerializerConfig that = (SerializerConfig) o;... } return false;
1. This can be reverted. 2. The case where each of these is equal but the other is defined, we don't check whether the type is a boolean.
Extra parentheses
There's no need for the null check here, just return pixbuf.
There's no need for the null check here, just return pixbuf. The Configuration is supposed to be null if there's no configuration
There's no need for the null check here, just return pixbuf. The Configuration is supposed to be null if there's no configuration.
Is it a duplicate the (maybe in a private method) below? I don't think it would be necessary.
Is it a lot clearer to put this in a catch block? This would simplify the code with a single branch?
Is it a duplicate the exception handling?
What happens if job does not have more than one element?
What happens if job does not have more than one job?
What do you think about undoing this change?
Can we call Arrays.asList(operands.getOperandList(), Collections.unmodifiableList(Arrays.asList(operands));?
Can we call Arrays.asList(operands.getOperandList(), Collections.unmodifiableList(Arrays.asList(operands));?
Can we call Arrays.asList(operands.getOperandList() ) here and in below?
Change "true" to an enum
Re-use it, but I would keep the case that if the flag is true, I do not get it.
Change to private
use assertEquals instead of assertEquals
use expected WebApplicationException with the message you need in the test
use assertEquals instead of assertEquals, the actual value is never null
I think this should also be INVALID_TYPE_ARGUMENT
I think you should also have a case for the "verify" case.
I think you should also have a case for the "cannot access during valid".
Use data.getData()!= null && data.getData instanceof Comparison is false
data instanceof Match && data instanceof Comparison is redundant with the "this" check.
Use data instanceof Match instead of == 0
I think it's better to return doubles[this] == null || doubles[index] == null && doubles[index] == null]
I think it's better to return doubles[this] == null && doubles[index] == null || doubles[index] == null]
I think it's better to return doubles[this] == null || doubles[index] == null]
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _context.getScenarioGridPanel().setFocus(true);_
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it will be invoked just once storing the result inside a method variable (in this case I would call _context.getScenarioGridPanel().setFocus(true);_
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentGroup()_ once and store the result in a _context_ variable). As it stands, the _context.getScenarioGridPanel().setFocus(true);_
&& super.untrackView(view);
&& super.untrackView(view)
the first parameter should be the view to be saved.
This does not seem to be used in the tests.
This doesn't look right. Was it introduced in the future?
This doesn't look right.
use ShellIsAvailable
please use ShellIsAvailable
use ShellIsAvailable instead
Please remove this. inbox variable.
Please remove this empty line.
Please remove this enum.
This should probably be Log.e instead.
This should probably be reported only.
This should probably terminate the dialog, not the printStackTrace.
Please change to provisioned => provisioned
Please change to ValidationResult
Please change to provisioned and non-admin
I'd suggest using a org.apache.commons.lang3.ArrayUtils.closeQuietly(Thread.class, "Closed internal ").join();
I'd suggest using a org.apache.commons.lang.ExitCode instead.
I'd suggest using a org.junit.platform.commons.io.ExitCode instead.
can the toString() be removed?
can the toString() be avoided here?
can the toString() be reused?
Please, don't reload the player in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when player is null
Please, don't reload the player in onResume(). Either there is no code calling onResume() before this line is executed.
Format this code
add InfoboxChoiceModal instead of UIPage
add InfoboxChoiceModal instead of UIPage.
return this.driver
We can transform the time to a long end and use the Math.abs call.
We can transform the time to a long end and use Math.abs instead of the delay.
We can make the setters private.
Could this potentially be moved to the end of the method?
How about: java Assert.isTrue(storageSplit == null)
Could this potentially be simplified to: java Assert.isTrue(path == null);
Remember to put {} around if/else/while/for etc.
Remember to put {} around if/else/for etc.
Remember to put {} around if/else/while/for/etc.
change to asyncResponse
nitpick: change to asyncResponse
change to asyncResponse?
Why can't we use an iterator here?
Why is this an ArrayList?
Why can't we use an ArrayList here?
This line can be removed
This line can be removed I think.
This can be declared before the return type.
Make it private
Make this private
Make this private also, please.
can be simplified to int bondOptions = getParameters().getAdAggregatorId(); if (bondAggregator!= null && bond.getName()) { return true; } as well
can be simplified to int bondName = getParameters().getAdAggregatorId(); if (bondAggregator!= null && bond.getName()) { return true; } as well
can be simplified to int bondOptions = getParameters().getAdAggregatorId(); if (bondAggregator!= null && bond.getName()) { return true; } as well.
use [this](<LINK_0>,%20java.lang.String) instead.
Shall we make this translatable?
Override
It is not an issue, but can we do the same thing in the updateTaskAdapters()?
It is not an issue, but can we do this translation as well (e.g..group does not have the same name)?
Do we need to synchronize on the future?
rename 'child'
rename 'child'?
Seeing about the parent in the tree here, so I'd use setEnabled(enabled, true)
ImmutableList.of()
ImmutableList.copyOf()
ImmutableList.asList()
System.equals() which does this check
System.out.println
System.equals()
s/public Config<String> getFromMetricsMessage
s/public Config<Object> getFromMetricsMessage
s/public Config<Object> type
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter low = filters[mid]; int c = methodName.compareTo(filter.getMethodName()); }
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter low = filters[mid]; int c = methodName.compareTo(filter.getMethodName()); if (c == 0) { high = mid + 1; } else { low = mid + 1; } }
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter low = filters[mid]; int c = methodName.compareTo(filter.getMethodName()); if (c == 0) { high = mid + 1; } else { low= mid + 1; } }
Maybe use "proposalId" instead of "proposalId"?
Maybe use "proposalData" instead of "proposalId"?
Maybe use "proposalData" instead of "Transaction"
Should it be [this](<LINK_0>
This is not thread-safe. The use of the [List class](<LINK_0> is probably better.
This is not thread safe. The [List<>](<LINK_0>
If this is an error, then we need to log it. This is a warning.
If this is an error, then we would need to log it. This is a warning.
If this is an error, then we would need to log it as well.
Put this method into a private static < HivePrincipal> Then we can directly return AuthorizationUtils.getHivePrincipal(principal)
Put this in a try-with-resources block.
Put this method on the client-side?
Static import getBytes(...) instead of getBytes().
Static import getBytes(...) instead of UTF-8.
Static import getBytes
Is it the same as the one above?
Is it the same as in the getFilterBlobLimit()?
Is it really necessary to return this?
Multi-line if-blocks should also be done with..
Multi-line if-blocks should also be done with.
Multi-line if-blocks should also be done before.
Could have @VisibleForTesting annotation. Also could public be removed?
Should properties be set? Also what if properties argument is null?
Should this be public? Also what if properties argument is null?
Can be simplified to this(name, dataKey, name, DataKey, ownerUuid, false, DataKey.
Can be simplified to this(name, ownerUuid, false, DataKey, lockThreadId, false, DataKey.
Can we make this protected?
Should be factory.xmlTest(clazz, methodName, null);
Should be factory.xmlTest(clazz, methodName, null).
Should be private.
use new Guid(String) - this literal can be null
use new 'Guid(String)'
use new Guid(...)
initial capacity is less than initial capacity
pluginsInitSteps.getInitSteps() seems a bit strange. It is not clear to me why initStep is not executed?
initial access modifier for initSteps should not be used here
suggestion if (getDefaultOrNull(formField.getValueType(), formField.getValueType())) {
suggestion if (getDefaultOrNull(formField.getValueType(), formField.getValueType())) { return null; } else { return formField.getValue().toString(); }
suggestion if (getDefaultOrNull(formField.getValueType())) { return null; } else if (obj instanceof PHONE || formField.getValueType() == formField.getValueType()) { return null; } // use the toString() method from guava
I'm not a fan of pre-cast and the name probably "length". It's not a part of the constructor.
I'm not a fan of pre-byte-control text segment. It's no longer a valid name but it's not a part of the check.
I'm not a fan of pre-byte-control text segment. It's no longer a valid name but it's not a part of the constructor.
maybe use ByteString.of instead?
maybe use ByteString.of here?
maybe use ByteString.of instead
will add constants, too much configs which nobody will know how to set those and will know how to set them
will add constants, too much configs which nobody would know how to set those and will know how to set them
will add constants for this string
return regionGroupMap.get(regionAndId.regionAndId.name());
return result?
return true?
What happens if the timestamp is null?
What happens if the timestamp is null but the passed in property is null?
What happens if the timestamp is null but the passed in as a parameter?
I think the reassignment in the line above does not make sense. The DnsResolver#release() basically returns a result from the previous attempt, which changes the result in it's marked as failed.
I think the reassignment in the line above does not make sense. The DnsResolver#release() basically returns a result of the reassignment, which it calls doResolveAllCached.
I think the reassignment in the line above does not make sense. The DnsResolver#release() basically returns a result of the reassignment, which it calls doResolveAllCached. That's the correct place here.
This filter should be PERUNOBSERVER.
This filter should be PERUNOBSERVER role.
This filtering should be done in another service.
Can we put this before the new line?
Can we put this with a named constant?
Can we put this with a mock?
I wonder if this would be better as something like: if (this.beanFactory == null) { this.beanFactory = IntegrationContextUtils.getIntegrationProperties(this.beanFactory); }
I wonder if this would be better as something like: if (this.beanFactory == null) { this.beanFactory = IntegrationContextUtils.this.beanFactory; } return this;
I wonder if we should be able to do this without the if (this.beanFactory!= null) check.
Should we use a reference to the ROLE_USER_can_ joins here?
Should we use a reference to the ROLE_USER_store?
Should we use a reference to the ROLE_USER_store_name or Resize_?
Do we want to assert the output index of the file in the output?
Do we want to assert the output threshold?
Do we want to assert the output index of the file in the error message?
This if-block can be removed.
This if-block can probably be removed.
This if will always be true because drop is not a string. Should use the equals method
This is implementation of the wrong method. It should be something like: java if (ren'tLaunchedFromIntent.equals(InvokeSource.INTENT_SHARE)) { return (e.g. public void invokeSource() { if (checkSource!= null && invokeSource.equals(InvokeSource.WIDGET)) { return (source)!= null; } return invokeSource.equals(InvokeSource.WIDGET); }
This is implementation of the wrong method. It should be something like: java if (ren'tLaunchedFromIntent.equals(InvokeSource.INTENT_SHARE)) { return (e.g. public void invokeSource() { if (checkSource!= null && invokeSource.equals(InvokeSource.WIDGET)) { return true; } return false; }
This is implementation of INTENT_SHARE. If this is the case, we should add that to the outer if statement.
In this case, the test isn't immediately clear to me. In fact, this means that the thread that runs out of the stop operation after it has started. The error message doesn't seem to be the case here, but the problem isn't. In the current situation, we should put a failed attempt to initialize.
In this case, the test isn't immediately clear to me. In fact, this means that the thread that runs out of the stop operation after it has started. The error message doesn't seem to be the case here, but the problem isn't. In the current situation, we should put a failed assertion on that variable. In this case, this test will pass if the failure is NOT_FOUND. In the end, the test will fail. The error message doesn't match the state of the test.
In this case, the test isn't immediately clear to me. In fact, this means that the thread that runs out of the stop operation after it has started. The error message doesn't seem to be the case here, but the problem isn't. In the current situation, we should put a failed attempt to initialize the count.
Style-nit: I think this should be if (gsEnvironment!= null)
Style-nit: I think this should be if (gsEnvironment!= null) {
Style-nit: I think this should be return (gsEnvironment!= null && getConfig()!= null)
typo: 'driver' is not needed
typo: s/driver/Screenshot
typo: 'driver' parameter
I am unsure how to feel about the divider. I know it's in the dialog, but on this page, it just seems... off.
I am unsure how to feel about the divider. I know it just in the dialog, but on this page, it just seems... off.
I am unsure how to feel about the divider. I know it just seems... off.
Should be lineRange
Should be!lines.isEmpty() to avoid negation.
The code in line can be moved to a method.
Local variable not required. You can directly populate the class level variable this.servers
Local variable not required. You could directly populate the class level variable this.servers
Local variable not needed. You can directly populate the class level variable this.servers
Why don't you pass null instead of empty?
Why don't you pass null instead of a new empty object?
Why don't you use "this." in the constructors?
Can you use accessor instead of conflictStream?
NPE's here too.
NPEs in this line.
Should this be a private static?
Should this be a protected?
Should this be a warn?
remoteList.contains(true)
remote list
remote
I think we could have a simpler approach with a method in Utils, for example: private static void attemptOnIssue(InputFile issue) { if (IssueLocation location!= null) { currentLocation.endLine(inputFile); } } public static NewIssueLocation issue(final Location location, final Issue issue) { this(issue.startColumn(), issue.endColumn(), issue.endColumn()); }
I think we could have a simpler approach with a method in Utils, for example: private static void attemptOnIssue(InputFile issue) { if (IssueLocation location!= null) { currentLocation.endLine(inputFile); } } public static NewIssueLocation issue(final Location location, final Issue issue) { this(issue.startColumn(), issue.endColumn()); }
I think we could have a simpler approach with a method in Utils, for example: private static void attemptOnIssue(InputFile issue) { if (IssueLocation location!= null) { currentLocation.endColumn(); } }
@fanifieiev please, fix the indentation here.
@fanifieiev move this outside of the for loop.
@fanifieiev move this assignment to the previous line.
either change the method name to refresh or removing the storage pool - this should be done in a transaction
either change the method name to refresh or removing the storage pool - this should be done in a following way
either change the method name to refresh or removing the storage pool - this should be done in a following patch
The cast to ITranslationUnit is no longer needed. We only need to make a change that doesn't require a separate task.
The cast to ITranslationUnit is no longer needed. We only need to make a change that doesn't allow to override it.
The cast to ITranslationUnit is no longer needed. We only need to make sure there is no "final".
map.put("duration", now - startOffset)
map.put("duration", now - startOffset); with a method reference
map.putIfAbsent
This can be simplified to catch (IllegalArgumentException e) { fail("Expected exception expected to be thrown"); }
This can be simplified to catch (IllegalArgumentException e) { fail("Unexpected exception expected: " + e); }
should we use the catch block instead of catching the IllegalArgumentException?
please use.equals instead of ==.
please use.equals instead of == or!=.
please use.equals instead of == or!=
Should this be made into a constant?
Should this be made into a constant so we can use it more easily here?
Should this be made into a constant so we can reuse it?
Unnecessary call to super()
Unnecessary call to super
Change the call to super()
prop: I think we should use TimeUnit.SECONDS.sleep(...) at the top level for the method invocation.
prop: I think we should use TimeUnit.SECONDS.sleep(...) at the end of the method, as it's used in the java code
And if it is a failure, I would use method reference instead of Thread.sleep
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().validateEntity( } remove union (like you did in name validation)
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().validateEntity( } remove union (like you did in name validation)
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().getIsValid( } remove union (like you did in name validation)
All of this can be replaced with an ExecutorService
All of this can be replaced with ExecutorService
All of this should be replaced with an ExecutorService
I think it can be moved out in a finally block
CommitInfo is still required
I think it can be moved out in a finally block.
I would use the Java 8's Asserts.succeedsEventually(...) - that's an assertion that it is a public static boolean variable.
I would use the Java 8's Asserts.succeedsEventually(...) - that's an assertion that it is a public static variable.
I think this test is valid anyway in this case.
nit: new line after {}
nit: new line after comma.
Do you really want a generating to initialize them at this point?
@vilchik-elena Please replace the while loop with a single filter.
@vilchik-elena Please replace the catch with PatternSyntaxException
@vilchik-elena Please replace the while loop with a regular expression.
doesn't check for null, and throw an IllegalArgumentException if not.
doesn't check for null, and throw an IllegalArgumentException if not found?
Not sure why we are using 2 spaces, for indentation?
Use constructor with this.
Use constructor for this.
Use constructor with this. headerData.
I wonder if this change would result in nicer code being simpler: if (ch == null) { return; } char[] value = new char[33]; sb.append('"'); for (int i = 0; i < value.length) { value.append('"'); } if (ch == null) { value = v; } } return new PSQLState('"');
I wonder if this change would result in nicer code being simpler: if (ch == null) { return; } char[] value = new char[33]; sb.append('"'); for (int i = 0; i < value.length) { value.append('"'); } if (ch == null) { value = v; } } return new PSQLState('"'); for this PR.
I wonder if this change would result in nicer code being simpler: if (ch == null) { sb.append("; } sb.append('"'); for this ;) { sb.append('"'); }
I don't think you need to call it twice
Why doesn't we use other executor here?
I don't think you need to use Mockito here
Same deal.
Same here, this variable is not used.
Fix code style.
subsystem.add("cache-container") should be removed
subsystem.add("cache-container")
These should probably be constants.
Same as above: could use searchPacksAgain
Same as above: didn't mention SEARCH output. This could be significant impacts.
Same as above: can use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty().buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } };
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation.
The supplier should fail, because of a big Object.
StringHelper.isNullOrEmpty()
String.format would be more readable
String.format would be more readable.
nit: I think we can use.filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) directly to make code more readable.
I think we can use.filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)) here.
nit: I think we can use entry.getValue() here and in other places.
Why not use a static field? It's not a big deal, but for readability it's better to use a static final field for the instance.
Why not use a static field? It's not a big deal, but wouldn't it be better to use a static final field?
Why not use a static field? It's not a big deal, but for readability it's better to use a static final field for the instance: <LINK_0>
Do we need to keep this method in case it's a text file? If not, do we need it?
Do we need to print the spaces at the end? If so, do we need it to be both formatted.DELIMITER and the spaces?
Do we need to keep this method in case it's a text file? If not, do we need to give two parameters to the constructor?
@vilution, shouldn't this be the exception parameter to the RestException constructor?
@vilution [here](<LINK_0> )
Response is a REST endpoint, so it should be HTTP
Why do you need to duplicate this call?
Why do you need to duplicate this?
Not needed.
minor thing: no need to move slot ", calling isValidSlot().
minor: no need to set slot TYPE_TCP_MEDIA_PACKET_FILTER
minor: no need to move this switch statement around
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
This does not take a message, it takes the id of the resource that was missing. Here I would just use the no-arg constructor.
This does not take a message. Here, you have to use the no-arg constructor.
this needs to be moved to the constructor
are you sure this can't cause a problem?
this needs to be moved to the constructor.
Instead of using try-with-resources for closeSoftKeyboard, which can be explicit in the finally block
Instead of using try-with-resources for closeSoftKeyboard, which should close a connection as well. (The try-catch is in the finally block)
Instead of using try-with-resources for closeSoftKeyboard, which can be explicit in the finally block: try (InterruptedException e = closeSoftKeyboard(); Closeable Closeable AutoCloseable closeSoftKeyboard = TextUtils.join(timeout)).perform(click());
Use logger
please use logger
Use log instead
Use this style {} syntax.
Spacing after line 67
can this be within the if block?
Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
Why is it necessary to have Configuration and YarnJob? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
Why is it necessary to have Configuration and YarnMap? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
this method can be declared private
isForceCreateVG?
this method is called in every command?
we should probably check in the canExecute whether we reached the end of the list
we should probably check in the canExecute whether we reached the end.
we should probably check in the canExecute whether we reached the end of the table
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Usually we use RequestMonitor.isSuccess(). Is there a reason you use a cancellation check here?
Usually we use RequestMonitor.isSuccess(). Is there a reason you use a local variable instead of multiple calls?
Your way to do this is to use VertexiumMissingFetchHints.validateFetchHints().isIncludeAllPropertyMetadata()
Your way to do this is to use VertexiumMissingFetchHints.validateFetchHints(element, property, property);
Could add a check here to ensure that the FetchHints is always created.
The Exception is never thrown.
The Exception is never thrown. The Exception is never thrown.
The Exception will never be thrown.
LOG.info("Could not connect to : " + endpoint);
LOG.info("Could not connect to : " + endpoint, timeout);
LOG.info("Could not connect to : {}, timeout);
The name of this string does not make sense. It is only used in test.
The name of this string does not make sense. It is only used in addRequestParameter.
We don't need all data handler of DataHandler in dataHandler.
nit: not sure why the context.reportError(); is called here, but not in the next line?
nit: formatting
nit: not sure why the extra line here.
Again, since you are using java.util.InternalStyle.getTable method, you can use a try-with-resources
Again, since you are using java.util.InternalStyle.getTable method, you can use a lot of times.
Again, since you are using an IntentService
Check a character of the string.
Check a character to avoid clicking on unescapeIdentifier("self")
Check a character to avoid overriding "Raw".
Do we need to define this?
Do we have to fix wallet-specific? If we don't have a wallet that is used, this isn't the wallet that is correctly omitted?
Do we have to fix wallet-specific? If we don't have a wallet that is watching, and should we push to to the wallet block?
Please add java doc
Please add java docs
Please add java docs here
Basically the same issue as mentioned above, I believe.
Basically the same issue as mentioned above - we should check that the result is a CONTAINER_ID.
I believe the same logic as mentioned above - if a container does not exist, it should remain running.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
Where in the code updates the connectionIdToRequestInFlight queue when a request gets sent to the network.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets sent to the queue?
I actually don't like the name of the method.
I would have put this into the first if to avoid the need for the last.
I would have put this into the first if to avoid the need for the last == null
InfrastructureException can not be thrown here
InfrastructureException is not thrown here
computeIfAbsent
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was an instance var that was mutable.
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was no reason it was an instance var that was mutable.
Do the validate before calling this.instanceMetaData
Do the validate before check for null?
Do the validate before the SlaveFactory.
Please don't use System.out here
Please don't use System.out in places
Please don't use System.out
How about extracting this to a method?
How about creating a list of allocated vars?
Could you inline this?
Just return here if possible
Just return here
Just an FYI this is possible compiler optimizations.
I think test will pass if no "int-and-string" is defined, no need to call isEqualTo.
I think test will pass if no "int-and-string" is defined.
I think test will pass if no "int-and-string" is defined, but the following is expected (for arguments).
rename to PROJECT_LOC
Why not you reuse the existing code in the if here?
Why not keep the variable name "PROJECT_LOC**?
declare throws DbWriteOperationsBlockedException
Remove throws DbWriteOperationsBlockedException
throws DbWriteOperationsBlockedException Same for other exceptions
use it. Sysprep, ex.
use it. Sysprep, ex.getMessage()
use it. Sysprep, path, file.
should this happen before matching the DNS record? If we have a flare DNS requests, it should not be possible that there are multiple issues.
should this happen before matching the DNS record? If we have a flare DNS record, it should not be possible that.
should this happen before matching the DNS record? If we have a flare DNS record, we should probably do it.
Could also change #859 to result.failed(msg)
Could also change the catch to Exception
Could have used failureInterface
This is too broad and is swallowing exceptions that need to be propagated.
This is too broad and should be done at a higher level.
This is too broad and is swallowed.
Small nitpick: I think it'd be easier to do: java AppLog.e(note); AppLog.e(note); AppLog.d(buf, WDYT?
Small nitpick: I think it'd be easier to do the following: java AppLog.e( "Failed to mark note as read via API", "I have seen this in the Listener");
Small nitpick: I think it'd be easier to do the following: java AppLog.e( "Failed to mark note as read via API", "I have seen this in the ViewModel. Note that this is because it's used in the Activity, so you can't do it here.
can use a stream here
can use a hashset here
can you pull '!' into a constant
Defining "web-auth" string as a constant will make the code clear, IMHO, and will allow to avoid duplication.
Defining "web-start" string as a constant will make the code clear, IMHO, and will allow to avoid duplication.
Defining "web-auth" string as constant will make the code clear, IMHO, and will allow to avoid duplication.
Do we really need to cast value to long here?
Do we really need to cast here?
Do we really need to cast value to String and then back again?
Are these files typically named the same across multiple data sources?
Are we sure this (and the others) is going to be running after build and previous state?
Are we sure this (and below) is going to be running now?
@ikhvostenkov please name it just json
@ikhvostenkov please name it json
@ikhvostenkov again json, please name it json
Please add a null check for getActivity() as well. This protects against reading the config options in the activity.
Please add a null check for getActivity() as well. This protects against reading the config options in the view view
Please add a null check for getActivity() as well. This protects against reading the config options in the view view a NullPointerException.
We should mutualize a hasTag (probably in stats)
We shouldn't be using hasTag (probably in stats)
We shouldn't need hasAttribute here since the hasTag will use the class
Can be replaced with call to computeIfAbsent.
Can be replaced with call to computeIfAbsent: java AlarmAssociation association = situation.getRelatedAlarmAssociation();
Can be replaced with call to computeIfAbsent: java association.getRelatedAlarmAssociationAndFacts();
Isn't obs.getObsId() already tested on the previous line?
Isn't obs.getId() already tested on the previous line?
Can we have an else clause here?
Please reformat: } else if (result) {... }
Please reformat: } else if (result) {
Please reformat: else if (result) { } else {
I think Optional.of(AmbiguousSymbolImpl) should be used instead of methods.
I think this can be replaced with Stream.of(resolvedSymbol.get())
I think Optional.of(AmbiguousSymbolImpl) should be used instead of orElse(null)
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway? I think these checks are missing.
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway.
I'd move this above the shader-related lines, as it is related to the FBO instead.
I'd move this line below the shader-related lines, as it is related to the FBO instead.
I'd move this above the shader-related lines, as it is related to the FBO instead. I'd go with the playerCamera line below, as it is re-useful.
Shouldn't it be condition 'null'?
Shouldn't it be condition 'if (n!= null)'?
Shouldn't it be condition!!!
Is this if statement really needed? Because it's not used.
btw, do we want to remove this, or use the trace logging in other cases?
Is this if statement really needed?
method returns WebElement, so you could return item.getMediaInfo().orElse(null);
method returns WebElement, so you could use this method.
method returns null
This is not a closed stream.
This is not closed.
This is not a closed exception.
FakeVertxSession and DummyVertxVertxVertx messages should be updated to reflect the new expectations (return null if metrics are disabled)
FakeVertxSession and DummyVertxVertxVertx messages should be updated to reflect the new expectations (return null if options is disabled)
FakeVertxSession and DummyVertxVertxVertx messages should be updated to reflect the new expectations (return null if metrics is disabled)
I think it's not a good idea to keep the listener in a private method, because we only have a 2 public method for the CacheListener to get the listener. In any case, I think it would be better to create a CacheListener class and have a constructor that takes the adapter.
I think it's not a good idea to keep the listener in a private method, because we only have a 2 public method for the CacheListener to get the listener. In any case, I think it'd be better to create a CacheListener class and have a constructor that takes the adapter.
I think it's not a good idea to keep the listener in a private method, because we only have a 2 public method for the CacheListener to get the listener. In any case, I think it would be better to create a CacheListener class and have a constructor that takes the application context.
Can we use the getProperty method here instead of duplicating the code?
Can we use the getProperty method here instead of duplicating this strings?
Can we use the getProperty method here instead of duplicating this?
I'm wondering, what do you think about: This will always be true since HAProxy address is send essentially a single channel and it will always be processed. So, what is the difference here?
I'm wondering, what do you think about: This will always be true since HAProxy address is send essentially a single channel and it returns not. So, why do we need to do this?
I'm wondering, what do you think about: This will always be true since HAProxy address is not a page?
simpler to say about "=r" rather than "=r"
simpler to say about "if (!component)" rather than "else if"?
simpler to say about "if (!component)" rather than "if (!component)"
I think we can just use stream here, no need for the variable.
I think we can just use method reference here, no need for the setter.
I think we can just use method reference here, no need for this variable.
I suppose we can use a OSUtils.sleepThread() here like we do in the UI thread?
I suppose we can use a OSUtils.sleepThread() here like we do in the UINotification.
I suppose we can use a OSUtils.sleepUINotification().
Shall we move this check to the constructor?
Shall we move the newBucket object to a constant somewhere?
Shall we move the newBucket variable out of the loop?
ProductInfo is immutable, and we'll use it elsewhere
ProductInfo is immutable, and we'll use it everywhere else here.
ProductInfo is immutable, and we'll use it elsewhere.
Call this function directly after Desktop.
Call this function directly (i.e., because it doesn't exist).
Call this function directly (i.e., not )
please check if the exception type is serialized with resource type instead of string
please check if the exception type is serialized with resource type not serialized.
would be nice to change the exception type to a CDP no?
Can we remove this branch?
Can we remove this block and add a merge handler as well?
Can we remove this block?
Is this exception caught in the catch block? If this is a test block, wouldn't it be better to have it fail and throw the assert?
Is it possible to have the 3 are indented in this test? If this is too much HARDCODED_DATE it should be a long, and it will make it more readable to read.
Is it possible to have the 3 are indented in this test? If this is too much HARDCODED_DATE it should be a long, and doesn't require a long time to get the value.
"owner".equals(owner) is always false here, so it doesn't matter what this code is trying to do.
"owner".equals(owner) is always false here, so it doesn't matter what this line is trying to do.
"owner".equals(owner) is always false here, so it is a valid value for the owner, which is if its null. Also, it is always "owner". It should be "owner".
instead of the hard coded value "key" you could use an actual value for the key
instead of the hard coded value "key" you should be able to specify an actual value
needs to be the proper error message
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
prefer String.isEmpty() as it is.
prefer String.isEmpty() as it is used above.
prefer StringPool.isEmpty() as it is used above
ditto about InterruptedException
rename this error code to MappingMetaData
rename this error code to MappingMetaDataMetaData
Should we throw RuntimeException if encryption strategy can not be found?
Should we throw RuntimeException if encryption strategy doesn't exist?
Should we not throw RuntimeException if encryption strategy can not find configured?
Needs to be in this test class.
Remove this.
singletonList
Why do we need to do this? Needs a catch block.
Why do we need to do this? It seems to me that if we go into a catch, then do a check for SimpleDateFormat.parse().
Why do we need to do this? It seems to me that if we go into a catch, then do a check for SimpleDateFormat.compile(), which then happens on the agent.
Could we use a standard import for the constant?
Could we use a constant for the "OR" here?
Could we use a constant for the "OR"?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, charsetMatch);?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new Object()?
Java return element instanceof WidgetAdapter && ((ElementAdapter) element).getNativeWidget(); This is more readable.
Java return element instanceof WidgetAdapter && ((ElementAdapter) element).getNativeWidget().getCssValueType(), new WidgetAdapter());
in case of a color why the element is not a widget?
This is a bit misleading. What about "Returns failed".
Let's invert this if statement to avoid calling return in the continue statement
Let's invert this if statement to avoid calling return in the continue.
rather than catching this, shouldn't we create a new connectionId in the middle of the loop?
rather than catching this, shouldn't we create a new connectionId in the constructor?
rather than catching this, shouldn't we create a new connectionId in the catch block for the same purpose?
Are we sure this equals() will not return true if the server doesn't have the oldPost value? Maybe just remove the isPost field and just call it if the value is null.
Are we sure this equals() will not return true if the server doesn't have the oldPost value? Maybe just remove the isPost field and just call it if the argument is null.
Are we sure this equals() will not return true if the server doesn't have the oldPost value? Maybe just remove the isPost variable?
I think this one is not needed... baseline is still null.
Leftover :)
I think this one is not needed... baseline is already non-null.
you're creating a new ArrayList for each element. Use the for loop instead.
you're creating a new ArrayList for each element. Use the for each loop for better.
you're creating a new ArrayList for each element. Use it here to create a fair amount of overhead.
PLz, same change
.getPartitioningHandle()
PLz, do we want to keep the exchange plan before we merge?
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
The statement is incomplete, because CommandCoordinatorUtil.getCommandStatus() is a FAILED_RESTARTED state for FAILED_RESTARTED and FAILED_RESTARTED are set to FAILED_RESTARTED and FAILED_RESTARTED status
The statement is not needed here.
[minor] ImmutableList.<Toolchest>of should also work and avoid the cast
[minor] ImmutableList.of should also work and avoid the cast
[minor] ImmutableList.of()
Is this needed?
Is it possible to write this to StringBuilder too?
Is this one really needed?
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
This test may fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure what JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
maybe worth adding a method here? (of line 138)
maybe worth adding a method here (ofPopupPanel) that returns the GWT's toString?
maybe worth adding a method here? (ofPopupPanel)
I must be missing something here, but shouldn't it be composed in the loop?
I must be missing something here, but shouldn't it be composed at the end of the loop?
I must be missing something here, but shouldn't it be composed by the service end of the list?
is this sleep necessary?
can we not sleep for a random port?
can we not sleep for a random number?
Can we use either Arrays.asList or Collections.singletonList() instead?
Can we use either Arrays.asList or Collections.singletonList() here?
Can we use either Arrays.asList or Collections.singletonList() instead, depending on the value here.
Do we need to populate these map if the backend is already initialized?
should we do it here too?
Do we need to send these changes at the mappers?
iteration over the list is enough
iteration over the list is faster
iteration over the list is costly.
Shouldn't we throw an exception here?
Shouldn't we throw an exception for both spark and non-null case?
Shouldn't we throw a RuntimeException here?
Do we really want to always assume Latin-1?
Are we sure that we may always want to use Latin-1?
Are we sure that we may always want to use _this.direct_ :-)
Again, just for consistency I think it would be nicer for this to java if (sshGen!= null) { sysModule.setPluginName(pluginName); }
Again, I don't think this should be necessary.
Again, I don't think this is necessary.
Can we have a defensive copy of the type?
Can be a defensive copy of the list.
Can we have a defensive copy of the config?
Why are we no longer controlling the authorization of the principal after the next call? For example, if the current user has been removed from the RealmIdentity, then I would think this method should only deal with the Object returned from the RealmIdentity.
Why are we no longer controlling the authorization of the principal after the next call? For example, if the current user has been removed from the RealmIdentity, then I would still catch this exception.
Why are we no longer reporting if the identity has been set?
No need for this.
No need for this. Just pass the root path here.
No need for this. Just apply the changes made for all directory storage
This is overly broad, we might have more then one place to do it. Is there any reason not to have it at all?
This is overly broad, we might have more then one place to do it. Is there a way to do this?
This is overly broad, we might have more then one place to do it. Is there a way to refactor it, so that any time the old client is started will just be able to update?
Consider extracting the response.getRequest().getPropertyValue() call, since we are now doing the same thing with different headers.
Consider extracting the response.getRequest().getPropertyValue() call, since we are doing the same thing twice.
Consider splitting this into a private method.
Extra parentheses
Extra catch
File
It is probably better to use the "this" model directly, and have it just "this" model available in the getOptions method.
It is probably better to use the "this" model instead of a ModelField class.
It is probably better to use the "this" model directly, and have it just "this".
@fanifieiev please replace the formatting.
@v-stepanov I believe you can inline this variable.
@v-stepanov I believe you can inline this variable
I would suggest to rename this to srsType to srsName or something along those lines.
I would suggest to rename this to srs or something along those lines. The URL is not clear what they are.
I would suggest to rename this to srsType to make it clear what they are?
debug is enough.
please remove this line
probably better to use strings.xml
Again, the warning.
Also, it's better to keep our debug statements cleaner and also log the entire error.
Also, it's better to include the feeding/pdata in the error message.
I think we want to return null here and let the exception be thrown
Please leave the try with resources to place the file needs to be closed.
I think we want to return null here and let the exception be thrown.
I prefer to keep the static import.
I prefer to keep the static import to avoid static import.
I prefer to keep the static import to avoid static imports.
Check the result of new ArcGISMap.
Check which layers are not null.
A new ArcGISMap should only be created once modification.
Isn't there a risk that we don't allow this?
Isn't there a risk that we don't allow updating the index here?
Isn't this the same as user labels?
set to null.
set null check
groups
I think we should add some information about the acknowledgements... with the data. This is not what we want to show in - acknowledgements...
I think we should add some {} around this
"Reporting some" or "Source licenses"
Probably more explicit to use log.debug("Config : " + sqlData )
Do we need to check for any queries parametrization?
Do we need to check for all queries?
Move this to a constant.
Move this to the call to httpContext.MESSAGE_SIE_VALIDATION
I don't think we should assume the message size of the message size
Same question about optional above applies to here and to L159 below.
Do we need to check if it is present or not? I think this looks like it's not related to this PR.
Same question about optional above applies to toBooleanArray.
If we create an entitlements map for the bindings, shouldn't this be added to the list as well?
If we create an entitlements map for the bindings, shouldn't this be added to the list?
If we create an entitlements map for the bindings, shouldn't we just do something to the list?
I think we don't need this boolean (ie: "Already adding the network deleted by the app");
I think we don't need this boolean (ie: "Already adding the network deleted by the offline state.")
I think this is a little bit too long and complex. It might be easier to read if you put the cursors of the whole thing into a method.
If the dataRef is null, we should throw an exception.
If the dataRef is null, should we throw an exception?
If we are going to have this logic in the init block, should we log it somewhere?
same here regarding a function
same here regarding a function call
same here, consider returning function
Why not using slf4j directly?
Can we overload checkAndPut and createPermissions use it here to simplify code?
Can we overload checkAndPut and createPermissions use it here to simplify duplication?
Shall we move this to a private method? Do we need it?
I think this can be moved to the base class. Do we need it? If not, we can just remove it.
I think this can be moved to the base class. Do we need it? If not, we can just remove it
Can you add some debug statements for the future?
Please use debug statements to make this much easier to read
Please use debug quotes.
- spell out colStatsList - null assignment is useless
- spell out colStatsList - null assignment is redundant
- spell out colStatsList
We should have a condition for emptiness of this method. Move the getSelectedResources() inside the 'if' statement so the negation is clearer.
We should have a condition for emptiness of this method. Move the getSelectedResources() inside the 'if' statement so the condition is first redundant.
Will it better to use resources.isEmpty()?
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I would consider doing leveraging function overloading to make this code have less conditionals.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make these two interfaces less conditionals.
You can just create a createParallelGroup (and add it for the vertical group but with a createSequentialGroup() method instead of createSequentialGroup.
You can just create a createParallelGroup (and add it for the vertical group but with a createSequentialGroup() method instead of create a createSequentialGroup.
You can just create a createParallelGroup (and add it for the vertical group but with a createSequentialGroup() method instead of create a new one.
there is a space between ) and {
formatter
Sorry for the delay of this..
We should not use this to set the BitSet size *aclInfo.getRightsList().size()*
We should not use this to set the BitSet size *aclInfo.getRightsList()
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller?
We could declare message in the try-with-resources, then move the null check inside and delete the finally block.
We could declare message in the try-with-resources, then move the null check inside and delete the null check inside.
We could declare message in the try-with-resources, then move the null check inside.
Pass the value of Discrepancy as a parameter.
Pass the value of Discrepancy in Status.
Pass the exception in an argument
Can we create a private method and use it in the class?
Can we create a private method to get the app name?
Can we use the scheduler.create() to create a separate thread.
This method is used from RawIMI, which is wrong. Why not use the above method?
This method is used in SQL, which is wrong. What is the purpose of the first byte is to define a prec.next() which is not used?
This method is used in SQL, which is wrong. What is the purpose of codePoints().?
I think it would be better to extract getNodeInstanceContainer.instance.getNodeInstanceContainer() into a local variable and reuse it in multiple places.
I think it would be better to extract getNodeInstanceContainer.instance.nodeInstanceContainer into a variable and reuse it in multiple places.
I think it would be better to extract getNodeInstanceContainer.instance.getNodeInstanceContainer() into a local variable.
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) { if (selection!= null) {
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) { if (selection!= null) { selectedObj.hasNext(); } }
child modules should not change on each module
Projects
monitor
Shouldn't this be source!= null && source.get()?
Shouldn't this be source?
Shouldn't this be source.get()?
Should this also include the maxAllowedLengthOfLength?
Should this also have a capital?
typo?
check if volume is null and log and return.
check if volume is null and log and continue.
check if volume is null and log.
Should we log out the exception before deleting the file?
Should we log out the exception?
Should we log this?
why is the default value?
why is a hardcoded value?
why is the default value "true" defined?
This doesn't need to be a try-with-resources.
This doesn't need a try-with-resources.
This doesn't need to be a try-with-resources
That should be IntervalQualifier
That should be IntervalQualifier instead of IntervalQualifier
That is not good enough.
Unintentionally. In other hand it's not a problem but for the future we should not have to touch and stop.
Unintentionally. In other hand it's not a problem but for the future we should not have to touch and update.
Unintentionally. In other hand it's not a problem but for the service we should not just have it be a string.
Can we just use instanceof?
Can we just use StringUtils.equals?
Can we just use instanceof instead of two cases?
please add logging in here to keep the message consistent with other messages
I'm not seeing this change. What are you trying to solve in this PR?
please add logging in here for us
in Java, this won't work correctly if the static type is a constant of Types.
in Java, this won't work correctly if file is a java class, so it will be defined twice.
in the static block I'd rather fix it (static)
It seems like we could have to create a new record with the same value (e.g. foo, and no records) in this test.
It seems like we could have to create a builder for this.
It seems like we could have to create a builder, and then use that in the test.
This is in Travis CI. Please move it to a constant.
This is in Travis CI. Please move it to a specific method.
This is in talend.
This is currently the same code a few lines below, we could factor out a method call.
This is currently the same code a bit (relatively), but could be private.
This is currently the same code a few lines below...
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the broadcastSerialDataReceived method was not called.
Add a check here to ensure that the serialDataReceived method was not called.
I think this message can be both an AxonConfigurationException...
I think this error message should be "not found".
I think this error message should be "... is".
Should we include the exception in the log message?
Better to log the exception here.
Should we include the exception in the log statement?
final
invert the condition
invert this variable
Format this file.
Format this to : {}
Leftover debug change?
This is already checked in the VertexRef constructor.
This message should include the namespace in the message
This is already checked in the handle method.
[Entity::v](<LINK_0> always returns a non-null Vector.
Extra space after the if.
[Entity::v]
please remove alias setting (DiskImage)
this is probably not needed for this patch
this is probably not needed
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough to make the code less obvious.
Tool tips can be slightly more detailed. Sometimes just a one word may be enough.
I think you should keep the try
I think you should combine the two try clauses, since you have only two try
I think you meant to keep the try
message should say "Failed to connect to scheduler."
INFO level
{}
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
I wonder if the message should be localized instead of "RST message"?
Did OSCORE specify to use ACK (and not RST) even if the number of items is localized?
The timeoutMs can be set to 0
The timeoutMs can be set to 0 and the timeoutMs can be greater than the timeoutMs right?
The timeoutMs can be set to 0 and the timeoutMs can be greater than the timeoutMs. This is more clear.
you're synchronized on your "this" object. Do you know that it would be thread-safe? I'm assuming that the handshake case is covered below in the else{}
you're synchronized on your "this" object. Do you know that it would be thread-safe? I'm assuming that is also synchronized on the _this_ key.
you're synchronized on the isTraceEnabled() checks, but that's probably not necessary.
nit: extract "job/A" to a constant named DEFAULT_A_B_IN_SECONDS.
nit: extract "job/A" to a constant named DEFAULT_A_B_ALL = "job/A"
nit: extract "job/A" to a constant named DEFAULT_A_B_ALL = "A"
@mderamos modify the assertion description appropriately
@mderamos modify this assertion description appropriately
@4.12 where you can @Rule be used here
nit: maybe it's better to just throw ExceptionUtils.firstOrSuppressed(e, exception) here?
nit: maybe it's better to just throw ExceptionUtils.firstOrSuppressed(e, exception)?
Can this be moved to a private method?
If the Rx Mode is destroyed, getConfig is called on line 74. The PR is a little confusing to me.
If the Rx Mode is destroyed, getConfig is called on line 74. The Rx Mode.None already sets it to (2). ;)
If the Rx Mode is destroyed, getConfig is called on line 74. The Rx Mode.None already sets it to .xml, and can be removed.
rename to child, fChildren, child
rename to child, not child
rename to child
Check whether the result is null.
Check whether the result is a Map or a map
Can it be replaced with getType() == null
Why not just write it out?
Why not just combine the two if statements?
Why not just combine the two ifs?
ReborObject.
ReborObject is fine.
ReborObject?
No need for isEmpty() check, the previous code was more concise and readable.
No need for isEmpty() check since the previous code was more explicit.
No need for isEmpty() check since the previous check will fail if the seed is empty, which will be ignored.
Don't need this.
Can we rename this.policies to this.customerPolicies or projectName?
Don't we need this.
using a listener could be used here instead of using a single field.
using a listener could be used here instead of using a listener.
using a try-with-resource pattern here would be cleaner and safer way
I think we should have a more robust message here, like ProtobufCodec#forName.
I think we should have a more robust message here, like getComponentClass(Class<T>).
I think we should have a more robust message here, like getComponentClass() declares that it provides the Cause class.
maybe a bit more readable to call Guid.valueOf(conn.getInterface()).toString()
maybe a way to support initiators
maybe a bit more readable to call Guid.valueOf(conn.getInterface())
Why do we use Uninstall of the deviceProvider here? If not, I would prefer to use [BundleCloser](<LINK_0> instead of the LogLevel class.
Why do we use Uninstall of the device* methods? If not, should we always create an empty device as a default?
Why do we use Uninstall of the device* methods? If not, should we always create a device for every device as it is?
Please put the "ms" in a constant.
The status is not included in the exception message.
Please use the "else" clause.
No need for else, just return isSymlinkHasAttributes()
No need for else, just return isSymlink();
No need to use isOther(), just add it to the constructor.
"unifyWindingOrder"
"unifyWindingOrder" should be renamed to something like "unifyWindingOrder"
this might be called way too many times. Perhaps a return default?
Maybe we could use panelName.isEmpty() here.
Maybe we can use panelName.isEmpty() here?
Maybe we can use panelName.isEmpty() here.
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the first item. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
You should actually check if it is null and throw a NullPointerException.
Surely we will need to add the annotation or interface?
Surely we will need to add the annotation or method. But I'm not sure if we can go through the annotation array here.
Surely we will need to add the annotation or interface.
why lockKey is not set?
why check and not return immediately?
why synchronized?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
![Codacy](<LINK_0> Issue found: [These nested if conditions could be combined](<LINK_1>
![Codacy](<LINK_0> Issue found: [These nested ifs could be combined](<LINK_1>
Remove unnecessary blank line
Remove a blank line?
Remove unnecessary blank line?
What if there are many files in it?
What if there is no storage?
What is the purpose of this change?
Small style thing, but we usually don't use curly brackets around single line blocks
Small style thing, but we usually don't use final for local variables.
Small style thing, but we usually don't use final for local variables if possible.
Might be better to use just the.setShareIntent(Intent.EXTRA_SUBJECT))
Might be better to use just the.get() here as well.
Might be better to use just the.putExtra() here as well.
For consistency with the rest of the code, use Throwable.
For consistency with the rest of the code, remove extra blank line
You can eliminate the cast here too
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
This won't do. It logs PatternSyntaxExceptions. Just enter [ or \g.
You need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
It's better to introduce a constant here, e.g.: "XSS ignoreUriPatterns"
It's better to introduce a constant here, e.g.: "XSS ignoreUriPatterns" or "XSS"
It's better to introduce a constant here, e.g.: "XSS ignoreUriPatterns" or "XSS" that is used.
same question here, do we account for the colo with single replica?
add curly braces, even if there is only one statement in the for loop.
add curly braces, even if there is only one statement in the for loop is ++i]
Why can't we use StatisticsModel.class.getSimpleName() for this?
Why can't this be done in the constructor?
Why can't we use StatisticsModel.EMPTY_LIST here?
nit: can simply use isEmpty()
nit: can use isEmpty()
nit: can simply use equals()
You may want to go into the map once you're registered.
I think you may want to go into the map once.
You may want to go into the map once you're done.
Shouldn't be postExceptionally(ctx) instead of compute()?
You can create a local variable f with the same name as the return value (ie adding the statement on the future) and then return f.completeExceptionally(new Cancellation(node, r));
Shouldn't be postExceptionally(ctx) instead of computeExceptionally(new Cancellation(node, this)).
Hm, we can keep the old version as a constant and store it as a static final constant (i.e. DEFAULT_VERSION_COLUMNS)
Hm, we can keep the old version as a constant and store it as a static final constant (i.e. DEFAULT_VERSION_CODES.O_VERSION, "6", "6"));
Version?
If we need to instantiate FrameLayout since it will only contain a single view (the mMicToolBar)
If we need to instantiate FrameLayout since it will only contain a single view (the mMicToolBar) and it will contain only the mMicToolBar.
If we need to instantiate FrameLayout since it will only contain a single view (the mMicToolBar) and it will contain only the mMicToolBar.set(false)
You can run./gradlew spotlessApply -- I'm pretty certain that the tab spacing here is wrong (BTW, I personally prefer 4 spaces for tabs, but this project is standardized on 2 spaces for tabs).
You can use the project's./gradlew spotlessApply -- I'm pretty certain that the tests are using 2 spaces for tabs, but this project is standardized on 2 spaces for tabs.
You can run./gradlew spotlessApply -- I'm pretty certain that the tab spacing here is wrong (BTW, I personally prefer 4 spaces for tabs, but this project is standardized on 2 spaces for 4 spaces).
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
objectRefs.get().releaseReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
not necessary to add "due to"
in finally? You're not unlocking it at all!
not necessary to add "due to"? You're already using logError()
The mergeSequences method is never used.
The mergeSequences method can be used by both merge and mergeSequences.
The "if (merge) {... }
You can use just COUNTER_SCOPE
We can use just COUNTER_SCOPE
We can use Objects.requireNonNull() here.
in order to explain why do we need to print the arguments?
in order to explain why do we need to print the exception?
in order to avoid the println() by using arguments to logger?
These arrays are never used. These can be removed.
These can be inlined.
These listProds already have the string pattern. Can we just move the call to line 91?
i18n
i think this is not really needed, given that the notification is set on the same thread
this looks like it was the same as previousNotification().toPath()
Could use a mocked Model to avoid the need to tidy up.
Could use a mocked Model to avoid the need to create a new object.
Could use a mocked Constant here.
Might be worth adding a helper method: org.apache.commons.lang3.StringUtils.isNotEmpty
Might be worth checking the result of the operation so you don't have to worry about it
Might be worth adding a helper method: org.apache.commons.lang3.StringUtils.isEmpty
Should we define a default value to be the FORMAT_CLASS_CONFIG constant?
Should we define a default value to avoid warning?
Should we define a default value to be the HIGH_NONE field?
Would be nice to put the logger.error here in order to get the actual reason?
Would be nice to put the logger.error here so we don't have to get the actual logger.
Would be nice to put the logger.error here so we don't have to get the actual issue?
I don't think the variable name is a good idea, but do you think it is a better name for this?
I don't think the variable name is a good idea, but do you think it is a better name for this method?
I don't think this is a good idea, but are the agencyKFSConstants being a valid agencyKFSConstants.
This line is too long.
This is a side-effect.
This is too long.
Why not use the url.isEmpty() and move the check to inside of the if block?
Why not use url.isEmpty()?
Why not use the url.isEmpty() call?
Again, I would prefer to have more descriptive error messages.
Again, I would prefer to have more descriptive error messages. Maybe this should be something like "Could not find ID with ID " + id
Again, I would prefer to have more descriptive error messages. Maybe this should be something like "Could not find Patch patch " + id
I think this text should be localized as a constant.
I think this constructor should be used here as well.
Is it possible to create a constant for this?
I would change this to: checkState(completed, "Empty lookup source for outer join already exist");
I would change this to: if (lookupSource.isDone()) { checkState(partitions, "lookupSource already existed"); }
I would change this to: if (lookupSource.isDone()) { checkState(completed, "lookupSource already exists"); }
I don't think we can simply use.equals here, we don't want to be consistent. What do you think?
I don't think we can simply use.equals for the rest of this test class. What is the point of doing the same thing?
I don't think we can simply use.equals for the rest of this test class. What is the point of doing the same thing? <LINK_0>
i like this use the same logic as org.apache.commons.lang3.StringUtils.isEmpty()
i like this use the same logic as org.apache.commons.lang3.StringUtils.isBlank
i like the logic you added in the first place
This is not the image.
This is not the image, just read it.
This is unused.
invert this if statement
switch {... }
invert this if statement.
This code should be moved to a separate method.
This code should be moved to a separate method (see line 78).
This code should actually be moved to a separate method.
miss the default value
NPE on a line above
wrong order
Either make this an instance of nanos (to be whatever the last modification time) or use System.currentTimeMillis()
Either make this an instance of nanos (to be whatever the last modification time) or use the System.currentTimeMillis()
Either make this a private method, or move the conversion code into the if block below.
instead of hard-coding a string here could we just use inline instead of creating a new one?
instead of hard coding the path, could we just use inline instead of creating a new line?
instead of hard-coding a string here could we just put the default from the notebookservice to the user?
Why do you change this?
Does it really need to be pinged?
Does it really need this?
You don't need to do this.
You don't need to do this Optional.
You don't need to do this Optional.ofNullable here.
This part should be moved to a finally block.
This part can be moved to a finally block.
This part can be moved to a method.
I don't think we'll need this condition. The test must be here: if (working == null ||!working.isEmpty()) { return; }
I don't think we'll need the "magic" number; otherwise we will still be able to determine whether a user has a task or not.
I don't think we'll need this condition. The test must be here: if (working == null ||!working.isEmpty())
I think using Arrays.asList() is the best option here.
I think using Arrays.asList() is better.
I think using Arrays.asList(cmd.get('\0').extract(null) is more readable.
Please use assertThat.
Please use assertThat.<String>.
:)
I don't think we should have this catch block here
I don't think we should have this catch block. Let's just stop calling Thread.currentThread().interrupt()
I don't think we should have this catch block anymore.
Magic number - maybe a constant?
Magic number - maybe a constant should be added?
Magic number - maybe a constant and put it in SenderHolder?
This needs to contain, return invoiceDetail.getSeqNo(getDate()).getSourceId();
This needs to contain in the invoiceDetail.
This needs to contain, return invoiceDetail.clone().
HealthMap will never be null, so should be added to the driver.
Health SAMRecord.class should be changed to include the health.
HealthMap
Shouldn't this be debug level?
Shouldn't this be moved to debug level?
Shouldn't this be moved to the service?
Can we keep this field?
Can we keep this field? They are used by other tests.
Can you please keep this field?
why not check for null?
not sure why this is a catch block?
not sure why this is so complicated?
This test does not seem to be working. The same is for PluralRules.
This test does not seem to be complete. The case where two files could be found by the example: "return null".
This test does not seem to be complete. The case where two files could be found by the example: "return res!= null".
Could you extract this try-catch block to a method?
Could you extract this try-catch block to a method for this, just into the catch block?
Could you extract this try-catch to a method?
I think this might be frustrating to update since you have to remember to increase the pass count here whenever you add a pass below. How about just putting the count in arrays, and looping over the arrays?
I think this might be frustrating to update since you have to remember to increase the pass count here whenever you add a pass below. How about just putting the count in arrays, and looping through the arrays?
I think this might be frustrating to update since you have to remember to increase the pass count here whenever you add a pass below. How about just putting the number of entries in the queue instead?
if you use empty list instead of null
fix if entry is empty
if you use empty list instead
don't use the loop
don't use the interface
don't use the loop with an index
Why not use elseLp.isDefaultNetwork()?
Why not use elseLp.isDefaultNetwork()?
This NETWORK_IP_CHANGED message is not received. This may be confusing.
Can't this be extracted to a new constant?
Can't this be merged? It's really strange.
> o
rename to editorTopIndex
rename to editorEncodeIndex
rename to editorMaxSize
why did you change to final here? should be outside of the scope of the patch.
why did you change to final here? should be outside of the scope of the patch..
why did you change to protected? should be outside of the scope of the patch.
can use CollectionUtils.isNotEmpty(paramValues.get(0))
can use CollectionUtils.isNotEmpty( pair.get())
can use CollectionUtils.isNotEmpty(paramValues.get())
please use VmDeviceUtils.VIDEO_of_monitors
please use formatter - line exceeds 120 chars
please use formatter
I don't think we need a finally block here.
Style-nit: try-with-resources?
why res?
I bet it should be in another pull request <LINK_0>
I bet it should be in another pull request <LINK_2>
I bet it should be in another pull request <LINK_1>
Actually this condition would always succeed when there is a transformation, because getLayout would return true when there is no entry. That is probably not what you intended.
Actually this condition would always succeed when there is a transformation, because getLayout would return the transformed layout. That is probably not what you intended.
Actually this condition would always succeed when there is a transformation, because getLayout would return true when there is no entry. That is probably why I was not fixed.
Why are you calling this every time, is it possible to only increase the size of the collections?
Why are you calling this every time, is it possible to only increase the size of the array? ;)
Why are you calling this every time, is it possible to only increase the size of the array? Pick one, but it's not as important
I think we should log the exception here.
I'm not sure if it's safe to modify the state of the loop here. The "every action" is bare, it's own implementation. It would be best if we add more features to some sort of state (rather than just filtering the state).
I'm not sure if it's safe to modify the state of the loop here. The "every action" is bare, it's own time. In fact, if we use the iterator this method will loop it every time.
I think this can be removed, because the playbackPlayer can't be null in the getPlaybackParameters method.
I think this can be removed, because the playbackPlayer can't be null in the if statement.
I think this can be removed, because the playbackPlayer can't be null in the getPlaybackParameters method
Couldn't this be removed?
Please remove this.
Remove this.
Why leave the capacityMap read logic outside of the validate()? Note this will diverge the behavior of the check API and real rebalancer API.
Why leave the capacityMap read logic outside of the validate method? Note this will diverge the behavior of the check API and real rebalancer API.
Why leave the capacityMap read logic outside of the validate()? Note this will diverge the behavior and real rebalancer API.
Do we want to still log the error?
should be parameterized
Do we want to still log the exception?
I think it's better to perform the conversion in the CppHelper.getArtifactNameForCategory(PluginClasses, ccToolchain)?
I think it's better to perform the conversion in the CppHelper.getArtifactNameForCategory(URL).isEnabled()
I think it's better to perform the conversion in the linkType itself instead of here.
We should have a null check on mBannerAdRequestListener here.
We should have a banner implementation.
This is just a typo. We should have two-space indents here.
Is this the right way to use.trim()?
Is this a bug fix? If not, you should make sure it is not fixed.
Is this really needed?
Use Double.MAX_VALUE instead of Float.MIN_VALUE.
Use Double.MAX_VALUE instead of Float.MAX_VALUE.
Use Double.MAX_VALUE instead of Double.MIN_VALUE.
should be this.user = false;
should be this.user = runnable;
should be "this."
Can you move this line into the getClientParameters method?
Can you move this line into args?
Can you move this line into final?
Is there any reason to use the same listener twice?
Is there any reason why this change is not needed?
Is there any reason why this change is needed?
Extract the payload to a variable for better readability
Extract a method for better readability
Extract a method for better readability :(
wouldn't it be better to do the KieContainerCommandService.getImplementedCapability()
can be put "getProviders" and not "getImplemented"
can be put "getProviders" and not "getImplemented".
I guess you don't need this check, since GroupSubjectData is not null or empty.
I guess you don't need this check, since GroupSubjectData is not null for you.
I guess you don't need this check.
maybe good to have a utility for deleting all the meta files in this path.
maybe good to have two methods here.
"service" is handled as a utility function.
you can probably replace this with a lambda with a method reference.
you can probably replace this with a lambda + call to the method below.
you can probably replace this with a lambda + call to the method above.
I think this check is redundant; it is already taken care of by the PollStream class.
I think this check is redundant; it is already taken care of by the PollStream constructor.
I think this check is redundant; it is already taken care of by the instanceof
Hardcode not always true.
shouldn't we put this in the AbstractPayloads method?
shouldn't we put this in a single call?
I think it would be better if you could use Collections.emptyList() here instead of Collections.EMPTY_LIST because this change is not really cached in this context.
I think it would be better if you could use Collections.emptyList() here instead of Collections.EMPTY_LIST because this change is not really cached in this file
I think it would be better if you could use Collections.emptyList() here instead of Collections.EMPTY_LIST because generics is generally considered better than using "info".
If this method gets called with a block that is smaller than the packet header size (28), we could get an exception.
If this method gets called with a block that is less than the packet header size (28), we could get an exception.
If this is only working with file, shouldn't it be field pcapPacketHeader?
object -> function?
why removed?
object -> function result
Let's not use this url as a dependency. this is very counter-intuitive. It means that we have already passed a default value as a parameter, so I think this check is unnecessary. Same as in other places.
Let's not use this url as a dependency. this is very counter-intuitive. It means that we have already passed a Charset instance as a Charset instance, rather than a String. Same with the other BigDecimals.
Odd spacing. Also this message should be in new lines.
This is not correct, as you need to assert the version in the list before select 'v9' (same for other methods).
This is not correct, as you need to assert the version is correct before select 'v9'. In the case where we have a version with more than one version and the other is fine.
This is not correct, as you need to assert the version is correct before select 'v9'.
@manuelplazaspalacio I know that we don't need to clean up the path, but is there any reason to clean it?
@manuelplazaspalacio I know that we don't need to clean up the path, but we can't clean up the file directly and clean it up later. We only need to handle it when there's a file. Wdyt?
@manuelplazaspalacio I know that we don't need to clean up the path, but we can't clean up the file directly and clean it up later. We only need to handle it when there's a file.
The eventBus.get() method should only be called when the action is either of the associated action or not. If this method is called more than once, then one can simply do action.get().
The eventBus.get() method should only be called if the action is either of the associated action or not. If this method is called more than once, then one can simply do action.get().
The eventBus.get() method should only be called when the action is either of the associated action or not. If this method is called more than once, then one can simply do action.get() because the plugin is not lazy and could be called multiple times.
s/joinAddresses/size/
s/joinAddresses/size/?
isEmpty()?
Not sure where this would work, but I think that authorities.stream() is the only field which can gives us back to the user. I guess this will only work for Java users
Not sure where this would work, but I think that authorities.stream() is the only _Collections.emptyList_.
wdyt about using authorities.stream() here?
CompressionCodecName compressionCodec is not used?
CompressionCodecName compressionCodec could not be used here.
CompressionCodecName compressionCodec could not be used here
Should use Alate.
Should use BAI_APerald.
Should use BAI_A as well.
this should be: element.equals(element)
we should do a cast here and cast on <? extends IResource>
we should do a cast if elementType is an ICPPPair?
I think it's better to do this in one line
I think it's better to do this in case DuplicatedSubscriptionException is thrown.
You can do it in one line
Please add null check for vdsId
Please add null check for vdsId.
Please return NPE
When we merge operation, it's slightly better to have localOutput <T> result in localOutputToRemoteStore.
When we merge operation, it's more readable to have a localOutput variable.
When we merge operation, it's slightly better to have localOutput <-> localOutput> result in localOutputToRemoteStore.
Here is another one.
Here is another another one.
Here is another one
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting it slip through here.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we we are technically susceptible to letting them slip through here.
Should this not be replaceEmptyValue() with a null value?
Should the following catch block be removed? since it seems to be outside the try block?
Should the following catch block be removed? since it is being used a lot in the same class.
Partitions must be ordered by ID before putting them into the same module
Partitions must be ordered by ID before putting them into the buffer
Partitions must be ordered by ID before putting them into the same module.
With the requireNonNull, the null check would be redundant... I think...
With the requireNonNull, you might as well remove the null check and just use the requireNonNull.
With the requireNonNull, you might as well remove this null check.
@dmzaytsev Now that I understand this change, I think we're making pose a major problem. Let's define a common method for each of the test cases, for example, with a high-level @Test method, which is specific to the purpose.
@dmzaytsev Now that I understand this change, I think we're making pose a major problem. Let's define a common method for each of the test cases, for example, with a high priority error.
@dmzaytsev Now that I understand this change, I think we're making pose a major problem. Let's define a common method for each of the test cases.
I think we can assert the the result of the expected call instead.
I think we can assert the the result of the transform.
I think we can assert the the result of the expected call instead?
I would prefer if you would use findByName method.
I would prefer if we would use findByName method.
I would prefer to wrap this logic inside application.save method and then clean the version.
'this.time' should be visit.after(time.getStopDatetime()!= null && visit.getStopDate().before(time.getStopDate())
'this.time' should be visit.after(time.getStopDatetime().before(time))
'this.time' should be visit.after(time.getStopDatetime()!= null && visit.getStopDate().before(time().getStopDate())
![MINOR](<LINK_1> 'Severity: MINOR') Make a constant of " defined". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Make a constant of "set". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Make a constant of " defined". [![rule](<LINK_2>](<LINK_0>
I'm not sure why we need this test here. If we have a "scoke" test, it is a 500. I can see some other tests that use a real test class (like not only one test) but not all tests.
I'm not sure why we need this test here. If we have a "scoke" test, it is a 500. I can see some other tests that use a real result.
I'm not sure why we need this test here. If we have a "scoke" test, it is a 500. I can see some other tests that use a real result to be the ones you are fixing.
you can mutialize this code
you can collapse to one line
you can collapse to constant
I would use LeadingMargin for '@' character.
I would use LeadingMargin for '@' character here.
I would use LeadingMargin for 100 string to have a base for 0.
This variable doesn't need to be public
This variable doesn't need to be public.
If we want to use an injected version of this test can be used in the test itself.
This line should be moved to line 501. After: i = fromClient(projectInstanceResource, i);
This line should be moved to line 501. After: File entry = fromClient(projectInstanceResource, i);
This line should be moved to line 501. After: File entry = fromClient.get(projectInstanceResource);
No reason to trim it, but is it possible to trim it?
No reason to trim this, but is it possible to trim it?
Are lucene low level properties still supported?
doc
message could also be updated to use here.
size can be 0 here.
i'd prefer to write it as: if (WebFaultException.NOT_FOUND.equals(snapshot.getVm())) { return null; }
i'd prefer to write it as: org.ovirt.engine.core.common.businessentities.VmStatus.NOT_FOUND.businessentities.common.businessentities.VmStatus.NOT_FOUND
i'd prefer to write it as: org.ovirt.engine.core.common.businessentities.VmStatus.NOT_FOUND.businessentities.VmStatus.NOT_FOUND
You don't need a variable here
You can make it an ArrayList here
You can make it an unchecked exception here
I'm wondering why you removed the "adding converter {}" parameter.
I'm wondering why you removed the "adding converter {}" parameter. The converterClass is a bit misleading...
I'm wondering why you removed the "adding converter {}" parameter. The converterClass is a bit not a common class.
The "Assert.assertTrue(condition)" should be before the for-loop body.
Need to test for nulls too.
The "Assert.assertTrue(condition)" should be before the for-loop body to avoid NullPointerExceptions.
new String[list.size()] will replace with toArray(new String[0])
new String[list.size()] variable is redundant.
suggestion filtered = StringUtils.replaceEach(input, searchList);
Instead of modifying this method, what if we change the class name to be a member of this class?
Instead of modifying this method, what if we change the class name to be static?
Instead of modifying this method, what if we change the class name to be static and call this method on class initialization?
Could we use StringUtils.isEmpty() here instead?
If we have a request rather than a single key, we should use request.done() instead.
Could we use request.getElements() here?
Minor: use of constants :)
Minor: use of constants here.
Minor: use of constants here
We should be able to directly call ServiceRegistry.getServiceRegistry(true)
We should be able to directly call.log.error("description", e)
We should be able to directly bind the TransactionalEditingDomain directly
why did we use cast here? can we change it to -1L?
why use cast here? can we change it to -1L?
why did we use cast here? can we use cast?
this should be closed as well
This should be closed as well
This should be closed before return.
Can we change this to getMetaData().size()!= 0?
can we change this to getMetaData().size()!= 0?
Can we change this to getMetaData().size()!= 1 to just check for the empty string?
Isn't it surprising that sharedRealm == null?
Isn't it enough to mark the RealmChangeListener interface with @ChannelHandlerContext?
Isn't it surprising that sharedRealm == null is the same?
style nit: add a space after if
style nit: add curly braces around if statement
style nit: add curly braces for if statement
This variable is not needed here.
checkState( "!= null, " "));
variable is not needed here.
useless
useless. Please remove.
useless.
why not instanceof?
why the instanceof?
why instanceof?
should we also log the error response here in this case?
should we also check with the error message that this happens one time?
should we also allowing to do this in the constructor, in cases when metrics issues?
please use equals instead of ==
Can those two be set here?
any reason not to use equals?
check against errors too
check against this
check against this.
Should we make this a public API?
Should we put this in a finally block?
Should we put this in the try/catch?
exists() is never called,
exists() is never called with deleteOnExit
move deleteOnExit and remove lines?
what if "logUtil.w(address)" is used?
what if "logUtil.interrupted" is a better name?
why is this needed?
Wouldn't it be easier to read if the folder name were not set to the default? Otherwise, the local folder name could change to something like : Build.VERSION_CODES.LOLLIPOP
Wouldn't it be easier to read if the folder folder is not located at this point? So that the folder folder could be set to /foo/bar
Wouldn't it be easier to read if the folder folder is not located at this point? So that the folder folder could be set to /foo/bar instead of /bar
Given the cost of mapSize and map size, I think some of the values would be simpler, rather than the size of the map size.
Given the cost of mapSize and map size, I think some of the values would be simpler, rather than the size of the mapSize.
Given the cost of mapSize and map size, I think some of the values would be clearer.
I don't think this will work if the view is in the view. You also need to call setEnabled(true) here.
I don't think this will work if the view is in the view. Shouldn't the leftSide.getValue() be null?
I don't think this will work if the view is in the view. Shouldn't the fence of the cell be null?
Nitpick: move this assignment to the previous line since it's not needed
Nitpick: move this assignment to the previous line since it's not used in two lines.
Nitpick: move this down, since the previous line is not relevant
assertThat(secondBuild.isInProgress())
assertThat(firstBuild.isInProgress())
assertThat(secondBuild.isInProgress()).containsExactly(RegularFile.class);
Create the tool section between the layer and the first mapping. Then pass it as parameter of createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeCreationDescription
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
createXXxDescriptionMappingYYY
Why are you using more than one scope to test?
Why is it better to use more than one scope?
Why is it better than scope to test?
Shouldn't it be internationalized?
Shouldn't it be in the last line?
Shouldn't it be done in the same commit?
We can throw the exception to client. We can throw the RestAPIException for an own exception.
We can throw the exception to client. We can throw the RestAPIException for an own message.
We can throw the exception to client. We can throw the exception to client.
do we need to clear the headersMap when we are reusing headers?
are we guaranteed the correct values to be null?
do we need to clear the headers map?
We shouldn't reformat this. Just return true when we know it's a single item.
We shouldn't reformat this. Just return true if it's a single item.
We shouldn't reformat this. Just return true when it's a single item.
1 -> numInputChannels?
1 -> numInputChannels?
1 -> channelId?
Integer.parseInt
ints?
Strings.isNullOrEmpty
Missing final
Can you modify this so that the upgrade of the parameter value is now encoded?
Can you modify this so that the upgrade of the parameter value is case sensitive?
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to the new method).
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to the new function).
I'm not sure what the code is doing here. What if one or more query is provided, but no index is specified?
I'm not sure what the code is doing here. What if one or more query is provided, and the other is always in the request?
I'm not sure what the code is doing here. What if one or more query is provided, and the other is null?
we already have a virtioScsiEnabled from this, shouldn't it be true even if the cluster is disabled?
we already have a list of supported VirtioScsiEnabled from this.xml file
we already have a list of supported VirtioScsiEnabled from this.xml (the condition you added is true by default).
I'd prefer to use Arrays.parallelPrefix() since it's a bit more efficient.
I'd prefer to use Arrays.parallelPrefix()
I think this is an extra copy constructor
The configuration must not be null. IRunDockerConnectionConfiguration should be using Boolean.valueOf(useContainerName)
The logic of the first element should be the model, not the widgets.
The configuration must not be null.
For exception(String ("Could not find broadcast address: {}", ex.getHostAddress(), ex);
For exception(String d) {
For exception, we should use xxx.jar
suggestion assertTrue(listener.hasBeenFiredEvents());
suggestion assertTrue(listener.hasBeenFired(event));
suggestion assertTrue(listener.hasBeenFired(event))
java try (FileOutputStream fos = new File(zipFile.getDirectory(), length); ipEntry(new ipEntry(file)); ipEntry(new ipEntry(file)); } catch (IOException e) { logger.log(Level.SEVERE, "multiBundle is not creating zip file", e); }
java try (FileOutputStream fos = new File(zipFile.getRecommendedDirectory(), length); ipEntry l = new ipEntry(relativePath.replace(length); ipEntry(file); ipEntry(new ipEntry(file.getAbsolutePath())) {
java try (FileOutputStream fos = new File(zipFile.get(0)) {
why not add the name of the profile in the message?
why not add if (tokenItem == null) { return; }
why not add if block?
This needs to be upper case. The error message should say "ascii" rather than "foo".
This needs to be upper case. The error message should say "ascii" and "path".
This needs to be upper case.
For the sake of consistency, we should use isUDEnabled or is it in the error message.
For the sake of consistency, we should go into the error message to make sure that this exception is thrown as well.
For the sake of consistency, we should go into the error message to make sure that this exception is encountered.
Will this close the file?
Better to close this dialog in finally block
Better to use localized constant here, with StandardCharsets.UTF_8
Good spot! We could do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent( detailsEntity -> { // });
I would call this setFirstDigitsCardDetails.getAddress().isPresent() instead of calling getCardNo().
I would call this setFirstDigitsCardDetails.getAddress().isPresent() instead of calling getCardNo().get().
Superfluous test.
final
Superfluous test for this one
assertThat(entries).hasSize(2); the same for several occurances below
assertThat(entries).hasSize(2);
assertThat(entries).hasSize(2));
This if can be replaced with StringBuilder
This can be done without StringBuffer
This if is not necessary and is a bit verbose.
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'll want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think you'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
Why variable named m?
Why the new line?
local variable for new ResourcePlannedStatement
replace with persistCommandIfNeeded
replace with persistSucceeded
replace with persistParentIfNeeded
please don't modify this code, here we are trying to duplicate the common code.
please don't modify this code, here we are trying to remove the ModelBridgeInternal.
please don't modify this code, here we are trying to duplicate the same logic.
This should contain the following line, because it's too long.
This should contain the following line, because it's too long. java ParcelUtils.IS_US_ASCII;
This should contain the following line, because it's too long. I believe you should wrap it in ParcelUtils.assertEquals(), or something like that
If this fails you need to catch the exception and log the error.
If this fails you need to catch the exception and log the exception.
If this exception is caught, log it properly.
This can be converted into a List: int remaining = 0; for (int i = 0; i < page.getInstant(i)) { if (remaining == null) { return; } } }
This can be converted into a List: int remaining = 0; for (int i = 0; i < videoVideos; i++) { if (remaining > 0) {... } }
This can be converted into an else if.
ditto about addBlockEncodingFactory
ditto about this. createBlockEncodingFactory
Why addBlockEncodingFactory?
nit: missing "TLS"
nit: missing a space
nit: sslSocketFactory could be static variables?
We have a few more cases where the logic is done. 1. We have the list of ScheduledActivity as a list of listeners 2. We don't need to add it to the list.
We have a few more cases where the check for!updatable.
We have a few more cases where the logic is done. 1. We have the list of ScheduledActivity as a generic component. 2. We need to add it as a map to the list.
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
Variable naming. Be consistent across the entire codebase. why do we use final?
Variable name is usually used in the assertTrue() method
resolvePrevious date stuff will only work for year-day. I'm not sure how karaf works, but we don't have them, so you can just read them from there.
resolvePrevious date stuff will only work for year-day. I'm not sure how karaf works, but we don't have them, so you can just read them from static method.
resolvePrevious date stuff will only work for year-day. I'm not sure how karaf works, but we don't have them, create a year from now.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
can be replaced with String configValue = StringUtils.split(config.getParamValue(), "%") which basically does exactly the same.
can be replaced with String configValue = StringUtils.substring(0, config.getParamValue(), "%") which basically does exactly the same.
Also note that input channels have been empty.
Also note that input channels have a single RIGHT message
Log the actual exception.
please revert this change
@dskalenko can you please revert this change?
Please revert this change.
Can you correct the error message?
Can you correct the exception message?
Can you correct the metric name.
I think it would be cleaner to make computeIfAbsent.
I think it would be cleaner to make computeIfAbsent and add a TODO here.
I think it would be cleaner to make a method reference computeIfAbsent here.
These two lines should come before the if. (Remove in the other branch.)
These two lines should come after the if. (Remove in the other branch.)
These two lines should come before the if. (Remove in the other branch).
Missing the return values, no need to return the result.
Missing the return values, no need to return
Minor nitpick: Missing space after if
for this PR
should we also add the value to the string
should we also add the event?
I don't think, the following is correct: final long a = solverStatus!= null? solverStatus.apply(problemId) : null;
I don't think, the following is correct: final long a = solverStatus!= null; final boolean 157 = problemFinder.apply(problemId); if (solverStatus!= null) { CfgService.apply(problemId); } }
I don't think, the following is correct: final long a = solverStatus!= null; final boolean 157 = problemFinder.apply(problemId);
should this be done in  firehose after log.addCommitter()?
should this be done in  firehose instead of log?
should this be done in getIndexUpdater() since that is the only place the start and runs?
Please do the same for the other variables.
Please do the same for the other fields. It is hard to understand what the response does.
Please do the same for the other fields.
nit: put the lines after the call to password.
nit: put this into a newline
nit: put the lines after the second line
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
This should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
You should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
this should probably be set to false, no?
Magic number
double space
for (Entry<String, String> metricName : name) { remove(name); register(name); }
I think this should be called only when the metric is not null
I think this should be synchronized
ms
ms vs ref?
start
Just want to make sure: do you really want to use StringBuilder for anything else?
Just want to make sure: do you really want to use StringBuilder for anything?
Just want to make sure: do you really want to use stringbuilder for anything?
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
<LINK_0>
debug?
You prefer having a if / else if instead of a or in the first if?
Why prefer having a if / else if instead of a or in the first if?
You prefer having a or in the first if instead of a or in the first if?
I know I am in favour of isEmpty() but nullity check here may be better, however, a null check may be better (as you did below).
I know I am in favour of isEmpty() but nullity check here may be better, however.
I know I am in favour of isEmpty() but nullity check here may be better, however, a null check may be better (as you did below)
nit: what if keyedKeys is empty? I don't think the filter at this point is in httpd.
nit: what if keyedKeys is empty? I don't think the match will mean if not found.
nit: what if there are multiple concurrent calls to this method? I dont see the point of iterating over the results to see the operation.
Consider using a distance here. This will replace the old checkstyle error by a try/finally for robustness.
Consider using a distance here.
Consider using a distance here. This will replace the old checkstyle error by a while loop.
Why not use our own util library here?
Why not getBytes("UTF-8")?
Why not use getBytes("UTF-8")?
Could you refactor the catch block to a separate method? java public void Purged(String msg, long Line 141) { if (log.isDebugEnabled()) { LOG.info("Skipping compaction of {} up to {}.", blobs); } try { System.out.println(ex); } catch (Throwable ex) { logger.info("Skipping compaction of {} up to partition {} up to {}.", blobs); } } catch (Throwable t) { logger.info("Skipping compaction of {} up to {}.", blobs); } }
Could you refactor the catch block in a separate method? Also, are we doing if (isShuttingDown()) {?
Could you refactor the catch block in a separate method?
Should we print the entire stack trace here?
should this be warn?
should this be a warn?
CategoryUtils::isConfigure() should be invoked noly part of the URL.
CategoryUtils::isConfigure() should be invoked no longer take any arguments.
CategoryUtils::isConfigure() should be invoked noly part of the URL returned.
I don't think this is quite right. It should be something like "ProjectedCacheSize >= highWatermarks."
I don't think this is right. It should be "ProjectedCacheSize >= highWatermarks".
I don't think this is quite right. It should be something like "ProjectedCacheSize >= highWatermarks".
@bxf12315 the same as above, please use assertThat.
@bxf12315 please use assertThat instead of assertEquals
@bxf12315 please use assertThat instead of assertTrue with assertThat.
May be great to rename this parameter list to something like originalValueUAL_INDIVID.
May be better to use org.jboss.as.controller.AuditConfigChecker.POST_DEFAULTS
May be better to use org.jboss.as.controller.AuditConfigChecker.POST_DEFAULTS here
I guess.append("ipv4") is more readable.
I guess.append("ipv4") would be more readable.
I guess.append("ipv4") would be more clear.
It is correct to have a fast path here instead of this?
What is this change about?
It is correct to have a fast path here instead of this.
Is there any reason not to declare this method private? It will be hard to test for this.
Is there any reason not to declare this method private but inside the while loop instead?
Is there any reason not to declare this method private?
Why are you using a 'final' for this?
Why are you using a 'final' for a variable?
Why default?
We need to support that on streams here too.
We need to support that on streams as well.
We need to support legacy.
Catch Exception instead of Exception? The general practice is to catch NullPointerException, usually we use @Rule ExpectedException.
Catch Exception instead of Exception? The general practice is to catch NullPointerException, usually we use @Rule ExpectedException, so the specific exception (which will be caught).
Catch Exception instead of Exception?
not needed
not necessary
not needed?
Add a check for getFileSystem().getRawFiles() here to verify that it's getting generated file.
Add a check for getFileSystem().getRawFiles() here to verify that the file is really the correct.
Add a check for getFileSystem().getRawFiles() here to verify that the file is really the same.
@pynicolas Are you sure about this method name? As I know it does the opposite
@pynicolas Are you sure about this method name? As I understand it does the opposite
@pynicolas Are you sure about this method name? As I understand, it does it to be static?
please use the same approach as in ContinuingManager.java instead of error.
please double check that marking the end of things are being done in the right place (see ServerDetails).
please double check that marking the end of things are being done in locksToSkip.
You should probably have a test for SonarQube and version of this builder so that it can be integrated into the constraint
You should probably have a test that checks for null
You can use the constant / directly in the system
Log the event here?
LOG.debug("Channel connected to A NettyServerCnxnFactory: {}", serverCnxnClass);
LOG.debug("Channel connected to a NettyServerCnxn instance");
I'm not sure what is going on here. This method is called before the first try to visit the MI console. I would suggest to add a new method to MIConsoleStreamOutput that checks whether the user is closing or not.
I'm not sure what is going on here. This method is called before the first try to visit the MI console. I would suggest to add a new method to MIConsoleStreamOutput that checks whether the remote or not.
I'm not sure what is going on here. This method is called before the first try to scan the log output. I think it should be called after the check on log.
s/active/ --inactive options are mutually exclusive.
s/active options are mutually exclusive.
s/active options are mutually exclusive."
this is not the same as the requestBody, you should be able to use the same JSON object.
this is not really needed, you can get requestBody from the RestRequest.
this is not the same as the requestBody, you should create a new RestRequest object.
why not indexStoreAdapter.clear()?
why not just index = index; no?
why not corresponding indexStoreAdapter for that?
nit: we might want to reset the interrupt flag here so that we don't have to do it.
nit: this is redundant. I think you can reduce the log level to debug.
nit: we might want to reset the interrupt flag here so that we don't have to handle this.
Let's move this line below, just before the requiresFBO line.
Can be moved to just before the requiresFBO line.
Can be done with the FBO.class.getSimpleName() instead.
![MAJOR](<LINK_1> 'Severity: MAJOR') A "NullPointerException" could be thrown; " returnVal" or something like that. [![rule](<LINK_2>](<LINK_0>
page returnVal = OpenShiftHost.PLUGIN_ID
page returnVal = OpenShiftPort
I think this is a perf issue, but as we discussed, this would be fine as a JSON cast. You have to do a valueOf(port).
I think this is a perf issue, but as we discussed, this would be fine as a default.
I think this is a perf issue, but as we discussed, this would be fine as a JSON cast. You have to do a valueOf(row) here.
Formatting issues : [Use the matcher](<LINK_0>
Formatting-only : keyword: space after if, return;
Formatting-only : keyword: space after if.
Please add.id(...)
Please add.build()
Please add.build() here
this is wrong - diskToUpdate.getDisk() will be null if we're not plugged to the disk
this is wrong - the disk should be plugged to the disk
this is wrong..
assertNotSame checks that the updates are in the same order as in the other tests?
These tests don't need to be run within the same class.
assertNotSame checks that the updates are in the same order as in the test class?
Has this 3 any relation to the one in calculateNumberOfBlocks()?
Fast-based code, previously written it.
3 * eviction code?
Shouldn't this be in a finally block.
Shouldn't this be in a try finally block.
Shouldn't this be in a finally block?
This variable is very badly name if it's about the class name.
This variable is very badly name if it's supposed to be the serializedLocation.
This whole test is very badly formatted.
also use "meter." prefix.
also these *meter* strings should be constants.
also use "meter." prefix
Should be i18n
Should be METADATA_SAP.
Should be METADATA_SAP
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then this will add another *. We shouldn't add the slash if it already ends with *
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another *. We shouldn't add the slash if it already ends with *
Please correct the indent here
Please correct the indent here :)
Please correct the amount of args
again.
This will throw IndexOutOfBoundsException if channelNames is empty
This will throw IndexOutOfBoundsException if channelNames is empty.
should be removed now?
Would it be better to call print(false) here?
Two fields (params and paramsFile ) should be removed now
Should it be a null check?
Must return false on this case.
Must return false
Can you elaborate on why we need this case? I guess it will be a bit hard to understand what's going on here.
Can you elaborate on why we need this case? I guess it will be a bit hard to understand what's going on.
Can you elaborate on why we need this case? I guess it will be a bit hard to understand what "Plugin brokering process for workspace Id.
same as above, this loop could be replaced by assertEquals(host1, scores, newVm());
same as above, this loop could be replaced by assertEquals(host1, scores, vms);
same as above, you need to add scores
Seems we should be passing the MY_PRIVACY as the "gest" button, rather than the MY_PRIVACY
Seems we should be passing the MY_PRIVACY as a "PUSH_TO_ME" directly
Seems we should be passing the MY_PRIVACY as a "PUSH_TO_ME" to the application context.
I wonder why did you remove this for loop and use BooleanUtils
I think you can use BooleanUtils
Do not use BooleanUtils
Please rename this too.
Please rename this too
Please rename this to eObjectMatchEngineFactory
Please don't create empty URL with null.
Please don't create empty URL with null as a parameter.
I would rather see a method called getResourceClassLoader(), which returns null and have that return the same method
I think this should be Splitter.on(",").trimResults()
I think this should be Splitter.on(".omitEmptyStrings").split("..");.
I think this should be Splitter.on(".omitEmptyStrings") as it looks like in the tags model.
What are the hints of values here?
What are the hints of an NPE here?
What are the value of getReset().getReset().get() here?
It is not necessary to use try with resources.
It is not necessary to use nioLoop() only, because it is not a socket.
It is not necessary to use nioLoop() directly.
Do we want to put message into KiePolicyHelper?
Do we want to put message into KiePolicyHelper as we missed this change?
Do we want to put message into KiePolicyHelper as we missed from here
I don't think this optimization of repacing.equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't want to use a comparison path.
I don't think this optimization of repacing.equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't want to use a comparison
I don't think this optimization of repacing.equals by '=' is correct. I suspect there is a mistake here...
hmmm, I'd probably include the try/catch here to avoid catching all the exceptions that use them, or do we really want to catch all exceptions?
hmmm, I'd probably include the try/catch here to avoid catching all the exceptions that use them, or do we really want to catch all exceptions that use them?
hmmm, I'd probably include the try/catch here to avoid catching all the exceptions that use them, or do we really want to catch all exceptions that can be thrown as well?
Doesn't this mean the constructor should be updated only in the builder?
Doesn't this mean the constructor should be updated only in the factory?
there is no need to add this check now.
why not put the size inside the try/finally block?
why not put the size inside the try-finally block?
Use the size() == 0
Maybe put this in the if block after the switch? It's just easier to read and less error prone.
Maybe put this in the if block after the switch? It's just easier to read and understand.
Maybe you can move this back to the if block
How is it related to the broadcasts?
How is it related to the broadcasts? If you have some kind of error they can put in a new custom exception.
How is it possible that the iteration of the broadcasts are not being called?
Are you sure this is not possible?
Are you sure this is not all of the more complicated filter?
Are you sure this is not all of the same AST?
@Serranya same here. See above.
@Serranya use JoinedText to break this line and remove the checkstyle supression.
@raphaelln I'm not convinced about these finally blocks... Can't we just invoke multi.body().close() here?
Please fix the validation logic for feedback.
Please fix the assertion message too.
Please fix the assertion for valid package name.
Shouldn't this be when the user have to read the prefs from?
Shouldn't this be when the user have to read the prefs from, too?
Shouldn't this be when the user have to read the prefs from? I know it's a good point but I could notice.
suggest rename to innerHadoopShardSpecLookup - "schema" is easy to mistake for "hadoop" when someone is reading this code
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is easy to mistake for a class name.
Why not prefer the new one (hadoopy)?
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I am running into the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() is already invoked for all CF which do not execute exceptionally.
I think this should be a guarded by a test.
/s/in/
I did a bit confused here, but it's probably time to have a file not created
could you change the return value?
can you change the return value?
can you change this to a setUp()?
if(StringUtils.isEmpty(parameters))
if(StringUtils.isEmpty(parameters)) {
if(StringUtils.isNotEmpty(parameters))
I don't see a value in this method. Not sure how simple it is to add the future.
I don't see a value in this method. Not sure how simple it is to add.
I don't see a value in this method. Not sure how simple it is to add the lock. If you have a value, then update the head.
Is there a reason why this is a separate public method?
Is there a reason why this is a public method?
Is there a reason why we are using a different variable for the cost?
my guess is my concern here. How does this enable you do so? Are you sure you have the right port in the line above?
my guess is my concern here. How does this enable you do so?
my guess is my concern here. How does this bug fix the problem?
This needs to implement isComInitialized().
This needs to be the opposite of what is happening here.
This needs to be the opposite of what you're doing above.
As it's a static method, we should be delegating to Looper and have the Looper thread name by itself.
As it's a static method, we should be delegating to Looper and not rely on the interface's Looper.
As it's a static method, we should be delegating to Looper and have the Looper thread by itself.
This variable is never used.
This variable is never used and can be removed.
This variable is never used and it can be removed.
This if and else clause seem useless.
pls rename the variable to be consistent with the other roles.
This if and else clause look a little better as it's not used?
Use foreach operator.
Use foreach
Use foreach style for (Map)
Just an FYI, checking [first point](<LINK_0> makes sense. No need to pre-compute progress since the featureTimeRangeBuilder is not final.
Just an FYI, checking [first point](<LINK_0> makes sense. No need to pre-compute progress as the featureTimeRangeBuilder is not null. You could just use featureTimeRangeBuilder.add(cal.getTime()).set(null);
Just an FYI, checking [first point](<LINK_0> makes sense. No need to pre-compute progress as the featureTimeRangeBuilder is not null. you could just set it to 0.
Use of log.log(Level.SEVERE,errorMessage + message, e);
Use of log.log(Level.SEVERE,errorMessage + message, e)
Use string format for logging, since it is the only message that we write.
How about a few simple tests for this condition?
How about a few simple tests for this method?
How about a few simple tests for this one?
logger.warn("Current floor: {}", property, currentFloorName);
logger.warn("Current floor: {}", property, currentFloorCurrency);
i would prefer to leave these info in the error instead of logging.warn
This would be easier to read if you switch to the existing return type.
This might be easier to read as "path" is used in this case, say path.getAllowed(path)
This would be easier to read if you switch to the existing handle method.
This remove will not occur if the underlying Collection is a Set.
This remove will be optimized to a simple messages.get() if the underlying Collection is a Set.
This remove will not occur if the underlying Collection is already thread-safe.
According to the current code style, "application" doesn't have value at all. Let's define this as a constant at the top of the method.
Let;s use: if ((pubKey == null) || (((String pubKey : null)) {... }
According to the current code style, "application" doesn't have value at all. Let's define this as a constant it can be reused here.
Can we change this to serverOption.SO_BACKLOG and.setaccumulateDefaults()?
Can we change this to serverOption.SO_BACKLOG and have the 2 changes you suggested?
Can we change this to serverOption and keep this property property?
Might have accidentally lost a newline here?
Might have accidentally lost a newline here on the last two cases?
Might have accidentally lost a newline here on the last one?
These values should be constants.
These calls could be moved to the base class as well.
These values should be in constants
assertThat(response.getFeature(...)).isInAnyOrder();
assertThat(response.getFeature(), is(equalTo(1))
assertThat(response.getFeature(...))
Can you extract this to a method? There is code duplication here.
Can you extract this to a method? There is code duplication here and in the other places
Can you extract this to a method? There is code duplication here and it
baseId +diagram
baseId +diagram.getXXxFromContainerYYY
baseGroup =
Let's use the same approach as for updateType, i.e.: java.map(QueryUtils::updateType).forEach(group -> updateType.add(m.getId(), emitter.updateType));
Let's use the same approach as for updateType, i.e.: java.map(QueryUtils::updateType).forEach(group -> updateType.add(m.get(), emitter.updateType));
Let's use the same approach as for updateType, i.e.: java.map(QueryUtils::updateType).collect(Collectors.toList());
Not sure if instantiating the attachmentList is a good idea.
Not sure if instantiating the attachmentList makes sense in this context.
Not sure if instantiating the attachmentList in this context is a good idea.
GitHubSCMSource<?> kind = allArrayList.select(all, Messages.class), NamedArrayList.withAnnotation(Selection.class)
GitHubSCMSource<?>. suggestion NamedArrayList.select(all, Messages.class), NamedArrayList.withAnnotation(Selection.class),
GitHubSCMSource<?> kind = allArrayList.select(all, Messages.class), NamedArrayList.withAnnotation(Selection.class), toUrl().
just use a try-with-resources idiom
just use a try-with-resources statement
just use a try-with-resources statement here.
Why not they set the max size of the max size?
this variable is not needed.
this variable is not needed
Why are these changes required?
This isAutoCompleteAllowed because it has 'enableAutoComplete' property. Please remove the call to getOrCreateConnectionProcessor()
Why are you passing connectionProcessor and connectionProcessor?
Could be static
Could be factory.emptyList()
Could be static (same for factory)
Can we move character '|' to a constant?
I think we can use Shall we call.entrySet() here?
I think we can move character.split( ) to a constant.
I think it's possible to do that more elegant by streaming one list and using iterator of another list in that stream.
I think it's better to do that more elegant by streaming one list and using iterator of another list in that stream.
I think it's possible to do that more elegant by streaming one list and using iterator of another list
Again, log the exception
Log the exception here.
I'd prefer to log this as a WARN
Could you also do assertThat(podTemplate.getYamls(), is(null))?
Suggest podTemplate.getYamls().size()
Suggest podTemplate.getYamls()
Can you please fix this so you can not use id in the message instead of getGroup()
Can you please fix this so you can not use id in the message instead of getGrouped()
Can you please fix this so you can not use id in the message instead of getGroup()?
don't you want to add a/b?
What is the purpose of this commit?
What is the purpose of this line?
Please put this tout on the same line as the LOG.error statement.
Please put this tout on the next line.
Please put this tense too.
double check that the group is still here
double check that the defaultBitstreamReadGroup is still here
double check that the defaultBitstream is still here
Use localization parameters
Add an assertion that the length of back spaces is correct
Add an assertion that the length of back format is 2 not zero
rename to cu
rename to importChange
rename to importChange?
did you want to remove this throws IOException as well?
did you want to remove this throws Exception as well?
did you want to do this for now?
Can you rename this to ePerson instead of ePerson?
Why this change?
Can you rename this to be more specific?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names.
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. Do we really want to stick to this?
Should we really use it by default?
Worth wrapping this in a ScheduledExecutorService?
Worth keeping it public?
Worth wrapping this in a try-with-resources?
Changing this to sth like LOGGER.error("Error filtering tresos message {}", fileName, e); would be a bit more readable.
Changing this to sth like LOGGER.error("Error filtering tresos message {}", fileName, e); would be a bit cleaner
Changing this to sth like LOGGER.error("Error filtering tresos message {}", fileName, e); would be a second
nit: drop the.
nit: no need to declare Exception here
nit: no need to declare throws Exception here
OK, I think these two lines could look like this: java ListenableFutureTask call = new ListenableFutureTask(); try {... } catch (Exception e) { logger.warn("Unable to load stats from table: {}", key, prevGuidepostInfo); } catch (Exception e) { logger.warn("Unable to load stats from table air.", e); } return null; }
OK, I think these two lines could be merged into one. java ListenableFutureTask call = new ListenableFutureTask(); try {... } catch (Exception e) { logger.warn("Unable to load stats from table: {}", key, prevGuidepostInfo); } catch (Exception e) { logger.warn("Unable to load stats from table air.", e); } return null; }
OK, I think these two lines could be merged into one
As with others, I would not assert on the return value of the operation
Here again I would not assert the result of the op, only that resilience strategy has been called.
Here again I would not assert the result of the op, only that resilience strategy has been invoked.
nit: a better test with the mutated flag is not enough
nit: a better test with the mutated function is not called, but I'm not sure if the difference is correct.
nit: a better test with the mutated function is not tested.
The same like in the other methods. Please remove them.
The same like in the other methods. Please use Bl layer from VOADMIN.
The same like in the other methods. Please remove.
super.execute()
super.canDoAction()
redundant check
v == null means array.size() == 0
v == null means array.size() is == 1
v == null means array.size() is == 0
Do you want to use the iterator? for (Entry<String, SessionInfo> entry : sessionMap.entrySet()) { numSessions += 1; }
This is not the correct way to use sessionMap.get(USER_PARAMETER_NAME) which is useful here.
Do you need to break line 91?
Needs to be removed now.
Needs to be removed
Needs to be removed here.
looks like is this lambda's logic to determine whether it is a more readable or not?
looks like is this lambda's logic to determine whether the filtering is enabled?
looks like is this lambda's logic to determine whether it is a more readable?
idemt is here used only for testing purposes, shall we also be able to use the file name here?
here you should be verifying the file name is of the expected file type.
New, we use File.createTempFile
If it doesn't exist then we would get a NPE here: int currentMax = iterators[0].getIndex(); while (currentMax == 0) { index = iterator[0].advance(); }
If it doesn't exist then we would get a NullPointerException with AscendingLongIterator.END;
If it doesn't exist then we would need to check currentMax == null
I think the code should be "Could not create the marker"
I would "Could not create the marker"
I would "Could not create the marker for your class"
@mykelalvis please, rename to server. ;)
@mykelalvis please, rename to child
Will this work with Java 10/11?
Here we should return list of taskDataDtos
Here you can return Collections.emptyList()
Here you can return Collections.emptySet()
This seems like a place where we want to allow a list of splits. I think that LISTER_TABLE_NAME is more appropriate.
This seems like a place where we want to allow a list of splits. I think that.setSchemaName(String.valueOf(schemaName)) is better
This is duplicated logic, so this should be extracted to a helper method.
same reserveFile for  size
same reserveFile for  size.
same question as before.
This is only valid for sorted by name, will break for other sort criterias
This is only valid for sorted by name, will break it
This is only valid for GameMap, unless speakerName is true, will this skip?
I would change this to: if (diff instanceof ReferenceChange) { return; } boolean isFromLeft = ((ReferenceChange) diff).getMatch(); if (diff instanceof ReferenceChange) {...
I would change this to: if (diff instanceof ReferenceChange) { return; } boolean isFromLeft = ((ReferenceChange)diff).getMatch(); return hasFromLeft && diff.getMatch();
I would change this to: if (diff instanceof ReferenceChange) { return false; }
this can be rewritten as: public static void addJoinField(JoinType property) { String parent = joinType.getContents(); builder.endObject(parent, children); }
this can be rewritten as: public static void addJoinField(JoinType property) { String parent = joinType.getContents(); builder.startObject(parent, children); }
this can be rewritten as: public static void addJoinField(JoinType property) { String parent = joinTypeRelation[1]; if (children.length > 1) { builder.startObject(parent, children); } } and use it here as well
We should be consistent with JUnit asserts
We should be consistent with the check: <LINK_0>
We should be consistent with the check above
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there are no lines
please don't do in the middle of method return. use else instead. also you can always write the else branch.
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method.
I think you should simply do a instanceof check here. The equals method is already checking if the bridgeHandler is null.
I think you should simply do a instanceof check here. The equals method is now doing the same thing as the bridgeHandler except.
I think we should not promote this to a variable. The UID is now not set in the loop below.
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
This seems like it should handle the exceptionsl ike the Exception block from above. Why make the distinction here?
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why not add a throws Exception?
I believe this if-else should be removed. DownloadBatchMap will create a new DownloadBatch if you set NO_OP
I believe this if-else should be removed. DownloadBatchMap will create a new DownloadBatch if you set NO_OP.
I'm not sure if newInstance() is guaranteed to be null here. This will create an empty collection in the same manner. I think this will create a new DownloadBatch object without a null check.
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as a cause.
TransportException is not just a wrapper for other exceptions, so where it is caught and wrapped in a new RuntimeException.
getOnlyElement again, no need for a loop.
getOnlyElement again, no need for it.
remove a _BROADCASTS_DATE
Please do not format the code. String defaultStreamProperties = getDefaultStreamProperties(); if (StringUtils.isNotEmpty(defaultStreamProperties)) { return Optional.empty(); } else { return Optional.of(defaultStreamProperty); }
Please do not format the code. String defaultStreamProperties = getDefaultStreamProperties(); if (StringUtils.isNotEmpty(defaultStreamProperties)) { return Optional.empty(); } else { return Optional.empty(); }
Please do not format the code. String defaultStreamProperties = getDefaultStreamProperties(); if (StringUtils.isNotEmpty(defaultStreamProperties)) { return Optional.empty(); } else { return Optional.of(defaultStreamProperties); }
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offsetMark == 0
If someone calls offsetMark == 0 then this will throw an exception. Should be inspected.
If someone calls offsetMark == 0 then this will throw an exception, he won't know what offset it is.
we still need this snapping logic if the property is not divisible by the step size
we still need this snapping logic if the value is not divisible by the step size
we still need this snapping logic if the constant is not divisible by the step size
same thing here. remove(taskId) is already marked as final so this code is redundant.
same thing here. remove(taskId) is already marked as final so this code doesn't need to be null
same thing here. remove(taskId) does anything.
The problem I see is that it's not possible to call the Companion method anywhere, but in fact I think it's not.
The problem I see is that it's not possible to call the Companion method anywhere, but in fact I think it's a problem.
You need to call Companion in the string
did you mean isInstructorOfResponsesAllowed?
did you mean isInstructor here?
Should you define out the Const.java.util.ListAllowedProperties in this class?
Iterators are not necessary here
Iterators are not necessary here.
What about Arrays.asList()?
Are we guaranteed that there will be a RuntimeException here?
Are we guaranteed that there will be a WKT type that could be null?
I think we can avoid parsing the ID for each entry, or just use the size. <LINK_0>
I think this is the new logic right? Also, it might be a bug if remoteHost == null.
It might be a good idea to supply an auth name here, to avoid having to supply it when creating the new one...
It might be a good idea to supply an auth name here, to avoid having to supply it when creating the new one.
You can just call oldBehaviour.apply here, is this intentional?
You can just call oldBehaviour.set(project) here.
You can just call oldBehaviour.apply here.
This is probably better than the logLogManager fallback, right?
This is probably better than the logLogManager.getLogger().
This is probably better than the logLogManager fallback. Check the IProgressMonitor is not a reliable check if the log works.
@ivandalbosco please extract this into a method
@YuryBY Not crazy, but this will cause confusion when the getLineHeight is greater than getLineCount, which is usually a line. So, something is fine.
@YuryBY Not crazy, but this will cause confusion when the getLineHeight() method returns 0. One should be fine.
is the same as below, maybe we can extract it into a method, maybe?
is the same as below, maybe we should extract it into a method, maybe?
is the same as below, right? Can we use the same code, maybe?
I think we should try to avoid reusing the same object here. The only thing that should be checked on optionsChanged is the same.
I think we should try to avoid reusing the same object here.
I think we should sequential restart the given state.
getBigtableScanValueProvider() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider.
getBigtableScanValueProvider() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider. Might be a better option to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider.
getBigtableScanValueProvider() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider. Might be a good idea to use a NestedValueProvider that transforms the opts.getBigtableScanValueProvider into a "true" or "false" for the ValueProvider.
Can we add a debug message here, like "Thread [c] should be removed.".
Can we add a debug message here, like "Thread xxx. thread could not be started".
Can we add a debug message here, like "Thread [c] should be removed from the string?
nit: else is redundant
suggestion } else if (publicId) {
formatting
content -> url
Typo
Typo.
The  here is not visible in the bridge anymore, since you didn't add a placeholder for it.
The NL is not shown in the placeholder for it.
The  here is notipaddress with the bridge.
I don't think this variable is needed.
I don't think this variable is necessary.
We don't create a new arraylist here.
Unnecessary empty line
Unnecessary catch block
Unnecessary catch block?
Typo
Typo in logging
Missing <LINK_0>
if you are going to add them, please add them to the one.
if you are going to add them, please add them to the diff below
if you are going to add them, please add them to the diff below and use them instead
blank line
getter?
blank line?
This should be a function, it gets called when the user is not in the app. If there is no user visible, the app will need to be updated.
This should be a function, it gets called when the user is not in the app. If there is no user visible, it should be the message.
This should be a boolean, it will default to a blank string.
Pattern.replace(Pattern, Pattern)
Pattern.replace(]*, character.toString())
Pattern.replace(]*, character.
"due to".
use %s
"due to"
Same here. No need for the if/else as above.
Same here, better if we return false and throw an exception to the user.
Same here, better if we return false and throw an exception.
do we need to have a LOG.info for this?
do we need to have a LOG.info for this case?
nit: do we need to have a LOG.info for this?
![MAJOR](<LINK_0> Remove this unused method parameter "request". [![rule](<LINK_1>](<LINK_2>
Remove this.
Remove this..
you're looking for an BaseCommand... No need to inherit from BaseCommand...
you're looking for an BaseCommand... No need to inherit from BaseCommand... it's correct.
you're setting timeout = 1 second here in the synchronized block. Why not have a synchronized block for the BaseCommand?
there is already a fix, this should be cursor.next(pageId, offset )
there is already a fix, this should be cursor.next(pageId, offset ) instead of offset
there is already a fix, this should be cursor.next(pageId, offset ) instead of big timeout
getPathsToExecuteBashScriptsToExecuteBashScripts(getLogDirPath(), path).toAbsolutePath());
getPathsToExecuteBashScriptsToExecuteBashScripts(path). May be you can add the path to the message?
getPathsToExecuteBashScriptsToExecuteBashScripts(getLogDirPath(), path)? dirName : null; is simpler.
Why did you remove this?
Remove this line
Remove this line from above to line 41
Minor: we don't need the "if" here.
Minor: we don't need this else.
final
The message could be extracted into a method, will be much better.
The message could be a little confusing, like a warn message.
The message could be the same here, will one format whole string (eg. when calling addAppIdentifiers() on its own).
equals for comparison
equals for the ==
'equals'
.isEmpty()?
I don't think we need a DAO to worry about whether it has index and not.
I don't think we should need a DAO method for this.
This is a spurious change. back it out.
This statement should be removed; use callback.
This callback call is a lot of code duplication. You can just inline this into the callback.
Is this needed given we already have a block with this value here?
Is this needed given we already have a block with this value?
IndexSnapshotBuilder#buildNextPosition is already called in the constructor
Please use {} for this if statement
Please use <LINK_0> for these deprecations
Please use {} for these if statements
We could optimize like this by calling BasicAuthCache authCache = new BasicScheme(); HttpContext(uri.getHost(), uri.getPort()); here.
We could optimize like this by calling BasicAuthCache authCache = new HttpContext(uri.getHost(), uri.getPort()); here.
We could optimize like this by calling BasicAuthCache authCache = new BasicScheme(); HttpContext(uri.getHost(), uri.getPort()); getHttpContext();();
Ah yeah it is a set of KeySet but I am wondering if we should use a set of KeySet instead.
Ah yeah it is a set of KeySet but I am wondering if we should use a set instead.
Ah yeah it is a set of KeySet but I am wondering if we should rather use the Set instead of a set here
Is this fixed to 20 seconds deliberately? Why not use reuse the default from the test method?
IllegalArgumentException is possible here. I see it not handled.
Is this fixed to 20 seconds deliberately? Why not use the default then?
I would avoid throwing RuntimeException here. I would make it info
I would avoid a pod lookup, if the label does not exist. I would suggest to use a different URL for the given label.
I would avoid a pod lookup, if the label does not exist. I would suggest to use a different URL for the remote label.
Unneeded parenthesis
Unneeded cast
Unneeded cast.
can we make this a constant? The other tests use the same username, so make them easier to read.
Can we make this a constant? The other tests use the same username, so make it easier to read.
can we make this a constant? The other tests use the same username, so make it easier to read.
One more times(1).
Nit: extra space after casting?
Nit: extra space?
You can use assertNull("Should have barfed") instead.
You can use assertThrows instead of RuntimeException
You can use assertThrows instead of ()
It's not the case that preTask is null, but it has a null pointer. I don't see how this can be null.
It's not the case that preTask is null, it should be a null check, not a _helixManager.
It's not the case that preTask is null, it should be a null value.
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
This retry-after-ms should be wrapped in a try-finally and close the socket.
This retry-after-ms should be wrapped in a try-finally so that it gets closed properly.
Can you use a more relevant variable name?
Can we use a more relevant variable name?
Can you use a more meaningful variable name?
please put the code in its own method.
please put the code in its own method in the if statement.
please move the code inside the if (objectSize!= null) { return reportPayload; } else { // Check response code }
Nitpick: this looks like a single return statement, so reduce indentation.
Nitpick: this looks like a single return statement, so reduce the elses.
Nitpick: this looks to me like it should be a simple return instead of {?
lets skip the updateAccountLocked
thanks for this.
lets remove this and use a lower case exception
I guess we should not call consoleEntry.getConsoleInUse(). We should then set it to null.
I guess we should not call consoleEntry.getConsoleInUse(). This should be a 'console'
I guess we could not just add this line here..
Shouldn't we be splitting this out into a separate method?
Shouldn't we be creating a new instance of LatencyCollectionResourceDTO for each call?
Shouldn't we be creating a new instance of LatencyCollectionResourceDTO in constructor?
Use slf4j formatting syntax instead of string concatenation.
Are there any unit tests for these?
Use slf4j formatting syntax instead of string concatenation
this is a new validate method. It will be reused by the validate method below.
this is a new validate method. It will throw illegal argument exception, with message in the description for the format.
this is a new validate method. It will throw illegal argument exception with a query error.
We should probably log what is the exception we're trying to get, so better use warn("Shutting down persistent lock manager.");
We should probably log what is the exception we're trying to get.
We should probably log what is the exception we're trying to get, not just the message.
Please add the "newTaskAttempt"" to the method.
Please add the "newTaskAttempt" check here.
let's pass the event handler to createEvent here. Instead of looping and pass the array.
ProcessBuilder.KEY.endsWith("heron-shell-pack-utils-shell") can be used instead of the full String comparison. The test is a bit hard to read in the code.
ProcessBuilder.KEY.endsWith("heron-shell-pack-utils-shell") can be used instead of the full String.join() method.
ProcessBuilder.KEY.endsWith("heron-shell-pack-utils-shell") can be used instead of the full String.join()
Minor - there is no need to log "debug".
- Shall we wrap the "debug" string in a log. - Use parameterized logging instead of string concatenation.
- Shall we wrap the "debug" string in a log. - Use parameterized messages instead of string concatenation.
I think we could avoid forEach in park (but directly don't check, so there's only one thread, right?
I think we could avoid forEach on the messageBody itself, and add a note to the park (but before this line)
I think we could avoid forEach on the messageBody itself, and add a note to the park (but before this line, right?)
I think there is a better way to do this. As for the other tests, the PageStripButton should be closed, it will return a 404 (as well as not a blocker). If there are multiple conflicts, it will throw an exception.
I think there is a better way to do this. As for the other tests, the PageStripButton should be closed, it will return a 404 (as well as not a blocker)
I think there is a better way to do this. As for the other tests, the PageStripButton should be closed, it will return a 404 (as well as not a 404) instead.
The original exception for the renaming is redundant.
The original exception for the renaming is better than "ex".
I think it is better to use java code.util.logging.Logger.getInvalidValueException("getInvalidValueException");
Looks like we want to keep the old method.
Looks like we want to keep these exceptions.
Looks like we want to replicate nulls everywhere. Should be in the same method.
could you please create a separate test for this?
can you create a test for this?
can you please create a separate test for this?
The moved above cGroupsMemory should be moved to a separate method.
Move this before creating the cGroupsMemory.
Move this before LGroupsHandler and after the next test case.
so the link is formed but not moved to the entity.
so the link does not exist? should it not exist?
so the link does not exist? should it not be hiding that entity.
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
I would have this test to pass but the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't have this test at all...)
Is this still needed if the value gets overwritten in the next line?
Is this still needed given the value gets overwritten in the next line?
Is this still needed if the value is null?
Would it make sense to move the history class member of this class that was created during init() and re-create()?
Would it make sense to move the history class member of this class to a member of this class?
Would it make sense to move the history class member of this class that was created during init() and re-initialize()()?
Boolean on a literal please
Boolean on a Rule
NumberFormatException
nit: I'd probably put all the the calls back onto the previous line
nit: I'd probably put all the other UUIDs in the test too.
nit: I'd probably put all the other UUIDs in the assertion
This code will only get called once at startup as far as I can see, can the game thread will no longer be found?
This code will only get called once at startup as far as I can see, can this code be changed?
This code will only get called once per our game, can it be changed?
nit: "Array element should not be array"
nit: if (arrayValue.isNull(arrayValue))
nit: line 59-62
This method is used only once, I think this is better: private static List<String> DiagramCategoryRegistry;
This method is used only once, I guess that it could be modified outside of this class.
The constant must be before the loop.
This log is a little strange here. Should it be a session or something similar?
This log is a little strange here. Should it be a full exception?
This log is useless here.
I'm going to trust this is doing the right thing (I understand this code is basically just copied and pasted from Apple's examples)
I'm going to trust this is doing the correct thing (I understand this code is basically just copied and pasted from Apple's examples)
I'm going to trust this is doing the right thing (I understand this code is basically just copied and pasted from Apple version examples)
We should use Integer.MAX_VALUE as the size to avoid magic numbers...
We should use Integer.MAX_VALUE as the size of the array.
We should use Integer.MAX_VALUE as the size of the array. Using int is more clear.
Suggestion: java return "select count(*) from TaskDataParameters.getStatuses().isEmpty() && queryPrefix.size() > 0;
Suggestion: java return "select count(*) from TaskDataParameters.getStatuses().isEmpty() &&....isEmpty();
can be replaced with: java return getQuery(t.hasTag(), pool)
It's impossible to throw an exception here if no auth token is configured. This is the only place where we handle any server, so there's no need to log it.
It's impossible to throw an exception here if no auth token is configured. This is the only place where we handle any server, so there's no need to throw it.
It's impossible to throw an exception here if no auth token is configured. This is the only place where we handle the host, we could, but I don't like the problem that any more.
Why not just use an iterator?
Why not just use an iterator? I don't think you need a ;)
Why not just use an iterator? I don't think you have a real reason to do this in a LinkedList...
suggestion ipOutputStream resourceMap = new FileOutputStream(filePath + resource.getResults());
suggestion ipOutputStream resourceMap = new FileOutputStream(filePath + resource.getResults().get(key));
suggestion ipOutputStream resourceMap = new FileOutputStream(filePath + resource.getipOutputStream());
Nit: Should be resCat.equals(resCat.getCode(), "...")?
Nit: Should be resCat.equals(resCat.getCode()) or something like that.
Nit: Should be resCat.equals(resCat.getCode()) or something.
I'd put it into the same commit as above: if (limit!= null) { return context.rewrite(Sort.class, rewrittenSource); } else { return node.rewrite(node); }
I'd put it into the same commit as above: if (limit!= null) { return context.rewrite(Sort.class, rewrittenSource); } else { return node.isPartial()?
the same as above: if (limit!= null) { return context.rewrite(node, rewrittenSource); } else { return node.isPartial(); }
@maria-farooq we should provide a description to the log message
@caria-farooq we should provide a description to the log message
why?
Single pass is needed here.
List<VDS> downHosts = new ArrayList<>();
List<VDS> upHosts = new ArrayList<>();
suggestion if (ns.isRegistered()) {
suggestion if ((host == null || ns.getInt("name")) {
suggestion if ((host == null) || ns.getInt("name"));
I would prefer the format to use id next to the entity type, like log.info("{} removed attribute {} from {}",...
I would prefer the format to use id next to the entity type, like log.info("{} removed attribute {} from entity {}",...
Any reason to log facility.getName()? Since you then mostly use otherEntity.getId().
There is a [File.deleteOnExit()](<LINK_0> in the finally block of the if (linkedFile.getFile().isGeneratedFile()) { return Collections.emptySet(); }
Strange formatting.. :-(
There is a [File.deleteOnExit()](<LINK_0> method instead.
If you ever make this public this _ will break the JavaBeans specification.
Can be replaced with: hosts.stream().map(VDS::getVdsDao).collect(Collectors.joining(","));?
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.joining(","));?
Unnecessary parentheses, the token's constructor doesn't do anything
Unnecessary parentheses, the error message will actually end up as checkstyle error.
Unnecessary parentheses.
Not sure about this, I am not sure about that. I can't think of a way to go. The configuration is the same as I mentioned in the other files.
Not sure about this, I am not sure about that. I can't think of a way to go. The configuration is the same as I mentioned in the PR.
Not sure about this, I am not sure about that. I can't think of a way to go. The configuration is the same about we are already in the PR.
Please use a more meaningful name. Like allowedOrigins or something
Please use a more meaningful variable name.
Please use a better variable name.
I think a map is needed here, since we do not need the map
I think the switch is no longer needed
I think a map is needed here, since we do not need the whole list
If we want to move this to KubernetesClient.java, we can probably expose it as a separate method.
If we want to move this to KubernetesClient.java, we could still expose it to KubernetesClient.java
I think that this should be closed
What do you think about using a static method on the class that could be called from many places?
What do you think about using a static variable for the seek and you are doing the seek twice?
What do you think about using a static variable for the seek and you are doing the seek twice? :D
Style nit: please always use {} with if statements: if (block.with(createChannelInstance.class).map(this::createChannelInstance).forEach(() -> { }
Style-nit: please always use {} with if statements: if (block.with(createChannelInstance.class).map(this::createChannelInstance).forEach(() -> { }
Style-nit: please always use {} with if statements: if (with always { }
getMessage() may be null
getMessage() may be null here.
typo: endpoint
This payload is no longer used in getTileMatrixSetName (which should really be in cache) - it should use params.put("id", id); (same for value)
This payload is no longer used in getTileMatrixSetName (which should really be in cache) - it should use params.getTileMatrixSetName() if you are already there. Also I don't think you can use the params as a parameter.
This payload is no longer used in getTileMatrixSetName (which should really be in cache) - it should use params.put("id", id); (same for namespace other resources)
I think get was more approriate here
I think get is more approriate here
I think get was more approriate here than it in the sense
In some cases, sleepThread calls should be sleepThreaded. Maybe. 10ms and sleeps?
In my opinion, these sleeps should be 2 seconds.
In some cases, sleepThread calls should be executed after the sleep thread has already happened.
Can you just: java try (File tree = new JsonParser()) {
Can you just: java try (File tree = new JsonParser()) {... }
Can you just new JsonParser()?
this could be shortened to java return new DirectDebitConnectorCreatePaymentRequest(directDebitConnectorCreatePaymentRequest, MediaType.APPLICATION_JSON_TYPE);
this could be shortened to java return new DirectDebitConnectorCreatePaymentRequest(directDebitConnectorCreatePaymentRequest).withMissingLink(directDebitConnectorCreatePaymentRequest).withDescription(directDebitConnectorCreatePaymentRequest.getPaymentProvider())).withDescription(directDebitConnectorCreatePaymentRequest.getPaymentProvider());
this could probably be shortened to.withReference(directDebitConnectorCreatePaymentRequest)
Why.toString()?
Why.toString() and not just send like this?
Why.toString() and not just sendTrace?
This method should return 0 if lhsVals is null.
This whole method could be replaced with return value!= null;
This whole method could be static.
This could be replaced with something like: java String dataString = Helper.quote(dataString); dataString.substring(0, dataString.length() - 1);
This null check is redundant.
This could be replaced with something like: java String dataString = Helper.createFehler(String.valueOf(dataString));
final is unnecessary here
final is unnecessary here.
final is unnecessary here and below
Could you please add clear message for case when assert failed?
Could you please add clear message for case when exception is thrown?
Could you please add clear message for case when debug failed?
That's just space
It would be nice if this was just space
It would be better if this was just space
We need to add a synchronized block to indicate we're in a thread safe manner.
We need to add a new method to PurgeListener.
We need to add a new method to PurgeListener. Then we can call this from here.
Won't stage stage always be called to stage?
Won't stage stage always be called twice?
Won't this break if you don't want to send stage?
You need to also store the lastStartTime: long lastStartTime = prevFullState == null? -1 : prevFullState.get(fullState);
You need to also update the end time here?
We need to also update the end time here, the end time should be before the last ss range start time.
Do you want to clear here too?
Do you want to clear index when it's!column name?
!
The naming of this method should be changed to reflect the new behaviour.
The description of the method ParameterContext parameter is not clear. Right now it looks like you're adding a similar mechanism to the new behaviour in the old method, which should be logged as well as bubbled up better.
The description of the method ParameterContext parameter is not clear. Right now it looks like you're adding a similar mechanism to the new behaviour in the old method, which should be logged as well as in ParameterContext.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below L486.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-)
java && reportingCurrency.getValue(FxRateKey marketData) {
Stream
Stream of double[] is cool cool
why do we need to set the BulkOptions for every batch?
why do we need to set the BulkOptions for every request?
why do we need a separate constructor?
just use context as synch obj
just use context as sync obj.
just use context as synch obj.
can we really don't use the generic check?
can we really don't use the generic check for null here?
can we use the common name for this?
nit: break up this line.
nit: break up this.
nit: extra space.
suggestion.inflate(rect -> listener.getMethod());
suggestion final OnClickListener frame = this.inflate(rect -> requireActivity);
suggestion final OnClickListener frame = this.inflate(rect -> {
Maybe encapsulate this in a method?
Maybe we need to avoid getContent here?
Maybe we need to avoid getContent() here?
I think you should use a finally block that throws an exception, to ensure that the thread is closed even when an exception occurs
I think you should use some logger here. In this case, just in case.
I think you should use a finally block that throws an exception, to ensure that the loader is closed.
Again, the relay on the configured value - is this intentional?
Again, is thislay!= null?
Again, the return value could be cached here.
I don't think that it's best to use Optional as the preconditions throughout the code - such as Optional.ofNullable(tradeInfoPropertyName).orElse(null);
I don't think that it's best to use Optional as the preconditions throughout the code - such as Optional.ofNullable(tradeInfoPropertyName).orElse(null); for easier debugging
I don't think that it's best to use Optional as the preconditions throughout the code - such as Optional.ofNullable(tradeInfoPropertyName).orElse(null); for easier debugging.
Spacing.
This won't work. ND4J or sth.
This won't work. Spacing.
IAtomContainer.getJavaCD()?
Here I would prefer to use a different method such as IAtomContainer.getJavaCD() instead of returning null
Here I would prefer to use a different method such as IAtomContainer.getJavaCD()
Why is the condition added?
Why is this condition added?
Why is this constructor using DB?
Cast to ScalarImplementation is not the wrong exception type.
Cast to ScalarImplementation is not the wrong exception.
Cast to ScalarImplementation is not necessary.
|| root.contains(x) is redundant
is this empty check not necessary?
is this empty check necessary?
LOG.warn("Terminating in Redis <LINK_0>", ex)
LOG.warn("Terminating in Redis <LINK_0>")?
info?
Need to exit the function here if the table was null.
Need to exit the function here if the table was successful,, which was null.
Need to exit the function here if the table was successful.
Would it make sense to have a separate method for putting the connection context?
Can you make this a private method?
Would it make sense to have a separate method for putting this in the synchronized block?
I think it's better to close the input stream in a finally block.
I think it's better to close the input stream here as well.
I think it's better to close the writer in a finally block. Otherwise, the write will fail.
Why not use a fixed map for this message?
Why a "different" name?
Why a comma?
Tests also need to be context-aware unfortunately, otherwise they end up testing against globally defined sites.
I think all of these need to be context-aware unfortunately, otherwise they end up testing against globally defined sites.
I think all of these need to be context-aware unfortunately, otherwise we end up testing against globally defined sites.
Could be isEmpty here since it's more explicit than an empty list.
Could be isEmpty here since it's more robust to treat an empty list.
Can the privacy model ever be enabled here?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
Same as above.
Can be replaced with lambda
Use lambda syntax
Use lambda approach
If it's not the case of open external web browser and opening a dialog on that host, it's a bug. The UI shows that open open source for a link is opened on org.eclipse.ui.browser.ui.util.ui.DialogUtil.createBrowserSupport(FormText.java:45) at org.eclipse.ui.browser.ui.util.ui.LaunchPanel.java:148) at org.eclipse.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormUtil.java:92) at org.eclipse.ever.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormText.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSharedUtil#createBrowserSupport(FormText(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.ui.util.ConsoleUtil.getConfiguredConfigured(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSWTUtil.getConfiguredTarget(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.ViewActions.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.g.ui.browser.ui.util.ui.LinkUtil.getConfiguredTarget(FormUtil.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.AbstractProjects.getBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:120) at org.eclipse.papyrus.infra.core.util.ui.datastore. theme.LinkPanel.java:395) at org.eclipse.j
If it's not the case of open external web browser and opening a dialog on that host, it's a bug. The UI shows that open open source for a link is opened on org.eclipse.ui.browser.ui.util.ui.DialogUtil.createBrowserSupport(FormText.java:45) at org.eclipse.ui.browser.ui.util.ui.LaunchPanel.java:148) at org.eclipse.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormUtil.java:92) at org.eclipse.ever.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormText.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSharedUtil#createBrowserSupport(FormText(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.ui.util.ConsoleUtil.getConfiguredConfigured(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSWTUtil.getConfiguredTarget(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.ViewActions.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.g.ui.browser.ui.util.ui.LinkUtil.getConfiguredTarget(FormUtil.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.AbstractProjects.getBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:120) at org.eclipse.papyrus.infra.core.util.ui.datastore. theme.LinkPanel.java:395) at org.eclipse.ever
If it's not the case of open external web browser and opening a dialog on that host, it's a bug. The UI shows that open open source for a link is opened on org.eclipse.ui.browser.ui.util.ui.DialogUtil.createBrowserSupport(FormText.java:45) at org.eclipse.ui.browser.ui.util.ui.LaunchPanel.java:148) at org.eclipse.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormUtil.java:92) at org.eclipse.ever.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.AbstractSharedUtil.showPanel(FormText.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSharedUtil#createBrowserSupport(FormText(FormText.java:45) at org.eclipse.cdt.dsf.ui.internal.ui.browser.ui.util.ConsoleUtil.getConfiguredConfigured(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.command.AbstractSWTUtil.getConfiguredTarget(Form.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.ViewActions.createBrowserSupport(FormText.java:45) at org.eclipse.cdt.dsf.g.ui.browser.ui.util.ui.LinkUtil.getConfiguredTarget(FormUtil.java:92) at org.eclipse.ui.internal.ui.browser.ui.ui.view.ui.view.ui.view.AbstractProjects.getBrowserSupport(FormText.java:1) at org.eclipse.ui.internal.ui.browser.ui.util.BrowserUtil.createBrowserSupport(FormText.java:120) at org.eclipse.papyrus.infra.core.util.ui.datastore.requestManager().getBrowserUtil(FormText.java:45) at
If the GeneratedClass.class.getName() were changed to an instance of the class, this should be accessed by the parent class.
If the GeneratedClass.class.getName() were changed to an instance of the class, this should be accessed by any super class.
If the GeneratedClass is already wrapped in a try/catch, this should be taken into account the listener.
Could just be LOGGER.error(jParser.nextTokenLevel).
Could just be LOGGER.error(jParser.nextTokenLevel(), e.getMessage());
Could just be LOGGER.error(jParser.getLocalizedMessage(), e) instead of logging?
nit: use context.getResources() instead of context.getResources()
nit: use context.getResources() instead.
Use context.getResources() instead.
please remove the duplication
please inline.
please remove
can you explain a bit more why this try/catch? can we throw a runtime exception and have it return null instead?
can you explain a bit more why this try/catch? can we throw a runtime exception and have it return null, so the method should be handled?
can you explain a bit more why this try/catch? can we throw a RestRException here?
I'd rather not catch this, but I think the proper message from the exception would be to give more information about what went wrong.
I'd rather not catch this, but I think the proper message would be: "Invalid auth config from EC2 instance role"
I'd rather not catch this, but I think the proper message would be: "Invalid auth config from EC2 instance " + credentials,
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded?
Will it even be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded?
Will it not be a good approach if we get object from function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded?
Can we move this line to a method?
Can we put this line in a method?
Can we put different implementations of those method? There is a method which is public
This code can be factored out into a private method.
This code is duplicated in deleteOnExit() above. I think we can refactor this to a private method that takes a FileUtil (which is used in all places) and also use it.
This code is duplicated in deleteOnExit() above, so that it can be well implemented.
Worth checking that the string is a valid JSON string, but that's not a valid JSON string.
Worth checking that the string is a valid JSON string, but that's not a valid JSON.
Worth checking that the string is a valid JSON string, because it could have a valid JSON string.
maybe lets use _seq_no, or _seq_no
maybe lets use a _seq_no, or _seq_no
maybe lets use the new name text?
Wouldn't it be good to have timeToLiveInSeconds.getcreationTime return the timeInMs for creationTime + one time? Then it is easier to read and understand.
Just to be really style-conscious, Preconditions.checkState about TimeUnit.SECONDS.toMillis(timeToLiveInSeconds)
Just to be really style-conscious, Preconditions.checkState about TimeUnit.SECONDS.toMillis(timeToLiveInSeconds) and to some variable name
I don't understand the cache manager, but you can use the default registration flag.
I don't see the cache manager at all. Is it necessary?
I don't understand the defaults for this. This is desirable... but you can override the default registration.
I am not sure the CASCADE should be using the [CASCADE](<LINK_0> as a configurable property.
I am not sure the CASCADE should be using the [CASCADE](<LINK_0> as a configurable value in the library. Maybe we can just use CASCADE?
I am not sure the CASCADE should be using the [CASCADE](<LINK_0> as a configurable value in the library. Maybe we can just use indexOf(':').
+1, and maybe move the context to a constant.
+1, and maybe move the context to the log file as well
+1, and maybe move the context to the log file as well.
As long as we switch to Java 8 you can do: if (jLoadProfile instanceof JLoadProfileRps) { WorkloadProfile = ((JLoadProfileRps) jLoadProfile.getLocalTransaction(Rps), clockConfiguration); }
As long as we switch to using Java 8 you can move to a long.
As long as we switch to Java 8 you can use: getGpsProfileId()
add final
add break
add break before if
this is not used anywhere else, should be in code base
should be in camel case all the time.
should be in camel case?
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
It might be interesting to allow CNull here, actually, to allow for more flexible code.
It might be interesting to actually check for CNull here, actually, to make sure it was actually used.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
final IPath pathString = Path.fromOSString(path); is unnecessary and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
final?
I think it's impossible for people to open your toasts if they think they're still needed to be shown quite a user and they need to be able to get the user directly from the save button.
I think it's impossible for people to open your toasts if they think they're still needed to be shown quite a user and they need to be able to get the user directly from the device. If it's gone then it's pretty easy to go through and understand the error.
I think it's impossible for people to open your toasts if they think they're still needed to be shown quite a user and they need to be able to get the user directly from the device.
I think that this works as if you extract a method to addBulkWriteError, which accepts TransactionUpdateException and you can call docUpdate.setBulkWriteError.
I think that this works as if you extract a method to addBulkWriteError, you can write this as: java docUpdateActually
I think that this works as if you extract a method to addBulkWriteError, you can write this as: java docUpdateActualError BulkWriteError
same as before, use var names instead of var
same as before, use var names instead of var names
You don't need to use var names, use 'FragmentManager'
This check should be done before, sSelel is a local variable.
This check should be done by sSelaction?
This needs to be in the if block below
No need for these two if statements. The error message is the same as the one in the file.
No need for these two if statements. The error message is the same as the one in the catch block.
No need for these two if statements. The error message is the same as the one in the else clause.
Why don't we just pass the name of the tree?
Why don't you just pass the name of the tree?
Why don't we just include the name of the exception as the message?
Nit: This should be null I think (to avoid the need to check any of the method signatures)
Nit: This should be null I think
Nit: This should be perform-request!= null
Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with.
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Bind these in the system module, aka Gerrit-Module. Its much more efficient and more efficient.
if (cellAtRow!= null) {
when would this be null?
I don't know if this is a good idea.
Use try-with-resource.
Use try with resources here.
Use try-with-resources.
this method is not required to avoid NullPointerException?
method.getMethod() is already clear. Please get back to method.getMethod()
this method should get renamed to method.
<LINK_0>
@dask Would like to know your thoughts on the indentation, like this: java String defaultID = " + sliding_layout
@Requian mentioned above
This can throw an exception. You must check if a serviceUrls is empty or not.
This can throw an exception. The caller will have to check for a null eurekaServiceUrl.
This can throw an exception. You must be able to use the eurekaServiceUrls.get(eurekaServiceUrl) method.
Please, use NodeUtils.valueOf(item)
Please, use NodeUtils.valueOf(item.getSelectionModel().toString())
Please, use NodeUtils.valueOf(item.getSelectionModel()).
Should we do an eic?
Should we do this in a separate thread? I think it would be nice to make sure all the segment files are covered.
Should we do this in a separate thread?
Could you please use the hamcrest matcher here? Or at least the hamcrest matcher would be more concise and easier to read?
Could you please use the hamcrest matcher here? Or at least the hamcrest matcher would be more concise and easier to understand the failure message.
Could you please use the hamcrest matcher here? Or at least the hamcrest matcher would be more concise.
it looks like you've copied the methods in the Class<? extends Thing> for this new task
it looks like you've copied the methods in the Class<? extends Thing> for this new test
it looks like you've copied the TriggerBuilder for this...
on the catch, let's add a servere logger
on the catch(), let's add a servere logger
on the catch, let's add a servere to the log
I think we shouldn't need a setter here.
I think we should prefer a setter here rather than setter.
I think we need a better naming here.
I think this should go like the one of the "matchFiles" flag. The these are used to do the same thing.
This should go after the loop
I think this should go like the one of the "matchFiles" flag. The these are used to do the same thing as the other one.
If I understand correctly, this will always return true (ie. because new ArrayList<> will do nothing)
If I understand correctly, this will always return true (ie. because new ArrayList<> will do nothing when tree item is found).
If I understand correctly, this will always return true (ie. because new ArrayList<> will do nothing when tree item is found)
I wasn't sure where this is coming from, but can be larger than the other is this change added.
I wasn't sure where this is coming from, but can be larger than the other is that we can do the same optimization
I wasn't sure about the place where this is done.
nit: simplifying it to java logger.warning("Ignoring received members from all suspected members!", sender.getMastership().equals(new MemberInfo(MemberImpl.N])) : "
nit: simplify else if (clusterService.isMastership()) { above?
This should be severe
Shouldn't we use mockitoSessionManager instead?
Shouldn't need to use mockito to verify the intent.
Shouldn't need to use the mock instead?
@bgeVam please replace the catch with the specific exception
A specific exception is not thrown, so you can just catch the specific exception
A specific exception is not thrown, so you can just assert the status of the object
maxKeywordsSize can be null
maxKeywordsSize can be used instead of the index
Precondition
Can you explain this change?
Now it seems to be right. I'd suggest <LINK_0>
Now it seems to be right to me to keep this action as part of <LINK_0>
Would be nice to use AssertJ for assertions.
Would be good to use AssertJ for assertions.
Would be nice to use AssertJ for the verification methods.
Perhaps also desirable to call track(Node, Context) directly. (For BindingStep, just inject a Node; for Workflow)
Perhaps also desirable to call start() at the end? (For BindingStep, just inject a Node; for Workflow)
Perhaps also desirable to call start() on the previous line?
Shouldn't this be a RuntimeException?
Should this comply with our formatter?
Needs logging as well.
It might be cleaner to add the check of the "old" literal at the end of the method to avoid the null check in the error message (before passing it to the user)
It might be cleaner to add the check of the "old" literal at the end of the method to avoid the null check in the error message (which is preferred by the way)
It might be cleaner to add the check of the "old" literal at the end of the method to avoid the null check in the error message.
Bad smell here. Why not use try-with-resources?
Bad smell here. Why not use {}?
This is not really a JsonReader. You can take a class of the class.
It might be better to use Arrays.asList instead of creating new Boolean object.
It would be better to use Boolean.valueOf(vmDevice.getSpecParams())
It would be better to use Boolean.valueOf(vmInterface.getSpecParams())
Sad times, but I don't think we can easily work around this.
Sad times, but I don't think you can easily work around this.
Ok, I don't think we can easily work around this.
Why does this need to be done in the constructor? If yes, the panel should handle it.
Why does this need to be done in the constructor? If yes, the panel should tailored to SPI.
Why does this need to be configurable?
shouldn't this be aliasId == null?
can't we just keep aliasId as a variable?
null is redundant.
Nit: this is duplicated at line 48, I would get rid of this line.
Nit: this is duplicated at line 48, I think get rid of this line.
Nit: this is duplicated at line 48, I would get rid of this line
nit: you can write map = pageBuilder.reset();
nit: you can write map = mapBlockBuilder.reset();
NullPointerException???
Is it possible to move this to a separate method?
Is it possible to move this inside the loop?
Is it possible to wait for the exact time for this?
Not sure whether theAmerica/Chicago is actually the correct Timezone? Maybe rename to something more appropriate, or at least make sure that it's not  foicago?
Not sure whether theAmerica/Chicago is actually the correct Timezone? Maybe rename to something more appropriate, or at least make it a follower?
Not sure whether theAmerica/Chicago is actually the correct Timezone? Maybe rename to something more appropriate, or at least make sure that it's not Timezone?
Can be simplified to if (log.isDebugEnabled())
Can't you just use persistence.info() here?
Can't you just use persistence.get() here?
@mbarbieri you can use TestUtils.createTempDir
@marchof I would suggest using a different @Rule for those methods.
wait.
You can merge both lines above as the body variable is not needed.
You can merge both lines above as the body variable is the same.
Nit: space between if and (.
Maybe we should use the following when we have: java Set<Long> tag = session.createQuery(new Guid(id), (SessionData).getDescription(); if (resource!= null) { entityManager.merge(session); }
Maybe we should add a method on ProviderData to SessionData.class
Maybe we should use the following when we have: java Set<Long> tag = session.createQuery(new HashSet<>());
These 'all' blocks can be combined with the one above
These 'if' body can be replaced with 'else'
These 'all' blocks can be combined with the one above.
Could you please write this method (and the one below) as (i - i == Const.POINTS_NOT_SUBMITTED || (i - i == 0)?
Could you please write this method (and the one below) as (i - i == Const.POINTS_NOT_SUBMITTED || Math.setValue(i - i)
Could you please write this method (and the one below) as (i - i == Const.POINTS_NOT_SUBMITTED || Math.setValue(i - i)?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownNodeUrl' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Refactor this method to not nest more than 3 if/for/while/switch/try statements. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "RM" local node "params. [![rule](<LINK_1>](<LINK_0>
typo _start_ -> _stop_
typo _start workspace_ -> _stop_
typo _start_ -> STOPPING
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceInformationGetNameMethod
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name.
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class YarnResourceTypesResourceInformationMethod.
@szczepiq Would you mind setting the value of sOnPreferenceChangeListener at this point?
@szczepiq Would you mind setting the value of sOnPreferenceChangeListener's?
@szczep
let's move it into the 'root' variable
let's move it into the 'root'
let's extract it into a private method, for instance, etc
well, the probability is very low, I know, but shouldn't be >=? in terms of readability I would prefer to have if (fetchTime - vmManager.getVmDataChangedTime > 0){... } else {.. } - but that's subjective I guess, so for your consideration
well, the probability is very low, I know, but shouldn't be >=? in terms of readability I would prefer to have if (fetchTime - vmManager.fetchTime - vmManager.getVmDataChangedTime()) {... } else { lock... } - but that's subjective I guess, so for your consideration
it would be safer to take the lock first and then check-and-update the time stamp
So you have default settingsfor userId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
If you have default settingsfor userId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
So why default value is null here?
The check item.getUrl()!= null is not needed.
The check item.getUrl()!= null is not necessary.
I prefer item.getUrl().indexOf('/') instead of calling getUrl().
I believe this code can be simplified to Java 8 stream =.filter(cursor -> stream == null || map.containsKey(key)).collect(Collectors.toList());
I believe this code can be simplified to Java 8 streams.
I believe this code can be simplified to Java 8 stream =.filter(cursor -> stream == null || map.containsKey(key)).collect(Collectors.toList())
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers? <LINK_0>
why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Why do we need AtomicInteger if you already have this method?
Why do we need AtomicInteger if you already have this variable?
Why do we need AtomicInteger if you already have this method on the class?
If you want to use a char with the data position here, you should be able to set the position directly. E.g. foo = section.getVerticals();
If you want to use a char with the data position here, you should be able to set the position directly.
If you want to use a char[] for the text, you should set the position directly when needed.
This should be an error condition. If it is null, we should at least log a warning.
This should be an error condition. If it is null, we should have a message like "ClusterModified {id} else"
This should be an error condition. If it is null, we should have a null check.
this method may return null, so no need to check for it.
this method may return null, so no need to check for getPkg()?
this method may return null, so it would be a bug.
I think we should rename receiverTree to receiverTree. Currently, we are not retrieving receiver from other methods.
This is the job of receiverTree. Currently, receiverTree is not thread-safe.
This is the job of receiverTree. Currently, receiverTree is not the case.
I'm not sure about this one. You could just use getTempEntity(entity, CounterEntity.class) here.
I'm not sure about this one. You could just use getTempEntity(entity, CounterEntity.class) directly.
Not sure, but we want to distinguish between the two classes: IPackageCoverage = new FileFilter(entity); if (modelLevel!= null) { return; } ModelBridgeInternal = (IClass) passed;
Do we need to check for duplicates here?
Do we need to check for empty list? I think this could be done with something else, so the error message could be added to the result.
Do we need to check for empty list? I think this could be done with something more than once.
Ah, this would be clearer if the mStillValidEntriesFromMenu was set to 'P', which is the case here.
Ah, this would be clearer if the mStillValidEntriesFromMenu was set to the end of the list. If you look at the end of this list, you're sure you should use a LinkedHashMap here.
A Vector is synchronized, which is not needed and allows duplicates.
if (mDebugMode)
if (mDebugMode == null)
if (
This should be removed
I think this should be removed
I think this should be removed and this was also added with Serializer.
The purpose of this test is to throw inside the onError block. I don't understand why you removed this.
Is this required? The purpose of this test is to throw inside the onError block.
Is this required? I don't see how this test is working with the old code.
Maybe have a single setter for parseType that takes a hasChildren and has an extension point?
Maybe keeping the try-catch inside the if block? We might want to simplify that.
Maybe have a single setter for parseType that takes a hasChildren and has an extension point.
Maybe we can replace this with: java Objects.requireNonNull(values, "values is null");
Maybe we can replace this with: java Objects.firstNonNull(values, "values is null");
Maybe add a check for values.isEmpty()?
both here and in the same method, I think it should have only one assertion statement.
both here and in the same method, I think it should be less readable and easier to read if you provide as parameters.
both here and in the same method, you could have to set true as the expected value so it will be more clear,
What would the previous code have returned?
What would the previous code contain?
What would the previous prefix contain?
I don't think System.out is necessary here.
I don't think System.out is necessary here, JUnit automatically formats it.
I don't think System.out is really necessary here.
I think this is a little bit too strong to understand, but why can't we just useWORKER_STOP?
I think this is a little bit too strong to understand, but why can't we use java this.request.TruncatedScriptHash(WORKER_STOP, STARTED), key)?
I think this is a little bit too strong to understand, but why can't we use java this.request.TruncatedScriptHash(WORKER_STOP, STARTED), key); Paths.get(src, null);
Why is this method public?
Why is a.keySet() here?
Why is a.keySet() and not a List?
May not work well if canvas changes are not preferred.
Tooltip tooltip: return container;
May not work well if canvas changes are preferred.
os.arch should probably be "unknown"
os.arch should probably return null.
might return null and probably fail on it.
I think this should be Type.valueOf(methodArg)
I think this should be <code>catch</code>.
Why not if (bean.getMethod() == null)?
Minor: you can use IOUtil.isTrueInAppears() (or assertThat(f3.get(0)).isExactly(1, 1, 2, 3, 3, 1).isTrue(); and that should be checked also.
Minor: you can use IOUtil.isTrueInAppears() (or assertThat(f3.get(0)).isExactly(1, 1, 1).isTrue(); and that should be good enough
Minor: you can use IOUtil.isTrueInAppears() (or assertThat(f3.get(0), () -> "f3.getParentFile().delete())", which is more appropriate.
code dup. would be better to move it to private saveInternal()
code dup. would be better to move it into private saveInternal()
code dup. would be better to move the logic for save()
This test is a bit too much... I would not use a Method as a Variable and treat the same method as a explicit type. I would avoid the casting.
This test is a bit too much... I would not use a Method as a Variable and treat the same as a explicit type. I would avoid the casting.
This test is a bit too much... I would not use a Method as a Variable and treat the same method as a explicit type. I would avoid the casting from MethodInvocationTree with a new MethodTree and deprecate it.
You can use Duration.SECONDS.remove(System.currentTimeMillis()) and omit the second call.
You can use Duration.SECONDS.remove(System.currentTimeMillis()) and omit the second part.
Looks like it is adding times. Was it worth to calculate dates using the same interval?
Hmm. do we log tags? Probably a good idea but C Git doesn't.
Hmm. do we log tags?
Hmm. do we test for tag?
Formatting?
isEmpty()?
isEmpty()?
Why are you doing this?
Why are you setting this to true here?
Why are you setting this to true?
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem) value : null;
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem)value : null;
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem item : null;
Shouldn't it be PRECISION instead?
Shouldn't it be PRECISION to NOT NULL?
Shouldn't it be the opposite?
This logic is a little confusing. What happens if there is an empty filename from the configuration file?
This logic is a little confusing. What happens if there is an empty filename from the name?
This logic seems a little weird to be in the same place as in buildText
no need to log here
a warning?
a warning is also good here
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Not relevant for this PR, but I'm curious: Why is the TrustAllX509TrustManager necessary?
Why is the TrustAllX509TrustManager necessary?
Redundant replicationSpec.
Redundant replicationSpec.setReplicationSpec().
Redundant replicationSpec.setDbSpec().
Should we log a warning or throw an exception in the else of this if? I don't think we want to just warn.
Should we log a warning or throw an exception in the else of this if? I don't think we want to just warn it.
Should we log a warning or throw an exception in the else of this if?
A amount amount is need to convert the totalPushStat to 0.
A amount amount is need to convert to Int. Double.
A amount amount is need to convert to double.
Should this be done in the else block?
TestRuleEntry is a bit more descriptive name
Should this be private?
@ALT, no need to add it.
@ALT, double[] is remain here.
@ALT + count;
I think! hashToInstances.isEmpty() can be used instead of the size.
I think! hashToInstances.isEmpty() can be used instead of the remove.
I think! hashToInstances.isEmpty() is simpler.
Java 8 has methods for required parameters.
Java 8 has methods for this logic.
Java 8 has methods for getting the header.
Excuse me, it will always be equals to true due to NPE. The prior implementation is checking for instanceof checks.
Excuse me, it will always be dismissStacked
Excuse me, the if
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs).
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL); Look for examples in Sirius code base (property section, wizard, dialogs)
why use domain id from parameters and not from storage object from method parameter?
please use getStorageDomainStaticDao()
please use domain id instead of redefining the domain name
Do we need any tests for the changes in this plugin info builder and others?
Do we need any tests for the changes in this plugin descriptor? Do we need any tests for the changes?
Do we need any tests for the changes in this plugin info builder and others? Do we need any tests for the changes?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
Forge, the legacy code you might want to change this to a method that uses the same feature as the K version of fluids? Seems like it belongs on a separate PR ;P
Forge, the legacy code you might want to change this to a method that uses the same feature as the K version.
I am not sure about this. I think that keeping the UNKNOWN in the main class should not be null. Let's discuss that.
I am not sure about this. I think that keeping the UNKNOWN in the main class should not be null. Let's explain this and what is the pool that is not ready?
I think parsers should not be null in this case. Let's use the same resource type here as well.
I don't like the idea of using an AbstractControlCreator here. Use the StatusControl class.
I don't think it's correct to use this.
I don't like the idea of using an AbstractControlCreator here. Use the StatusControl to create acontrols flag.
I would use an early return here instead of having two methods for the same if statement.
I would use an early return here instead of having two methods for the same statement.
I would use an early return here instead of an if for (DataSourceDataSource.getDataSources() > 1) {
The test can be simplified to assertEquals(TestRegexMountPoint regex, "user/hadoop/file/hadoop/file/src/test/java/org/apache/hadoop/file.xml").
The test can be simplified to assertEquals(TestRegexMountPoint regex, "user/hadoop/file/hadoop/file/src/test/java/org/apache/hadoop/file/cluster/ prefix.
The test for /file/ prefix could be removed, or merged into that.
please remove.
please remove these.
please remove these?
This is a little bit too long. In this case, can you please wrap this with a new Integer?
This should be new Integer(pushObjectList, new ArrayList<>()).
This is a little bit too long. In this case, I would prefer to have a constructor that takes the Integer object as the second argument.
debug/trace/remove?
log/trace/remove?
log/info
And this one
And this one?
And here?
This might be wrong, but the property name should be set to true
This might be wrong, but the set of tables is always 0.
This might be wrong, but the set of tables will be sorted by schema -> tableNames
throw something if sqlCompatible
Could use isNull()
Could use isNull() method
This cannot be removed. The scheduled task needs to be saved.
This cannot be changed. The scheduled task needs to be saved.
The scheduled task needs to be saved.
To be consistent with the other log statements, I would rename this to hostPort, and the one with the other.
Because of this it looks like we are using the same configuration as the old one, but we could rename this to be consistent with other parameters.
Because of this it looks like we are using the same configuration as the old one, but we could rename this to hostPort, then it will be obvious from this configuration.
This logging should be in the FileOutputStream and not in any case.
This logging should be in the FileOutputStream and not in any way.
This logging should be in the exception
I think this might lead to unused space on the right, when one of the columns is a single space and you don't redistribute the difference
I think this might lead to unused space on the right, when one of the columns is a space, the other doesn't redistribute the difference
I think this might lead to unused space on non-blocking
computeIfAbsent seems better, but still follows the regex form of the match.
computeIfAbsent would reduce one level of nesting
computeIfAbsent seems better, but still follows what happens if the match is null?
Why do we need this?
Why are you adding this?
Why are you adding this? This operation is already scheduled by the index at the end of this method.
The implementation will be modified.
The implementation will be simplified.
The implementation will be simplified to :P
this should be outside the loop? Otherwise it will only check for the first brick in the list
This should be outside the loop? Otherwise it will only check for the first brick in the list
this should be outside the for loop? Otherwise it will only check for the first brick in the list
This assert is no longer necessary.
This is no longer necessary, you can remove it.
This is no longer necessary. We can remove it.
I would rename it to preferencesDataSource
I would rename it to something like getActivity().
I would rename it to something like mapMode
Please add a // WARN here rather than the number of digits. And it's certainly counter-intuitive.
Please add a // WARN here rather than the contents of the message.
Please add a %s message and the assertDayPeriodFormat() call.
That's an interesting trick!
That's an interesting trick!.set(PathAddress o1.toString()) produces a NPE if no seed is found.
That's an interesting trick!.set(PathAddress o1.toString()) produces an exception if a required resource exists.
ConflictOverrides overrides =...
ConflictOverrides overrides authoritative classes as well
You should be able to pull the conflict overrides directly without needing to rebuild from the string
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
If you don't return here, this will run only after current repl dump execution? What can be better is to return here?
If you don't return here, this will run only after current repl dump execution? What can be better to return here?
This should probably be an error since it is fatal and that way it will be seen by apprunner
This should probably be an error since it is fatal and that way it is left here.
This should probably be an error since it is fatal and that way it will be seen by client.
Can we have example <LINK_0>
Can we have a standard variable name for this?
Can we have a standard executor for this as well?
Why do we need the no-op: the parentRelationships.addListener(this);
Why do we need the no-op: the type is a dynamic reference?
Why do we need the no-op: the type is a dynamic object?
I think a fan of the for loop inside of the while loop would probably be more efficient. Like for (String tableName : sql IS NOT NULL && sql IS NOT NULL) {... }
I think a fan of the for loop inside of the while loop would probably be more efficient. Like for (String tableName : sql.moveToFirst()) {... }
I think a fan of the for loop inside of the while loop would probably be more efficient. Like for (String tableName : sql IS NOT NULL || sql IS NOT NULL) {... }
this should be an instance of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
style nit: we don't use braces around single line blocks
this should be an instance of createMergeConflictInfor() and the mergeResult should be passed to createMergeConflictInfor()
This line can be combined with the one above.
This line can be moved above the try-catch block to avoid duplicate code.
This line can be moved inside the try-catch block to avoid duplicate code.
nit: you can use a method reference here. Something like shapeBounds.get()
nit: you could use a method reference here. Something like shapeBounds.get()
nit: you can use a method reference here. Something like shapeBounds.get() or something.
Not directly related to this PR. But at some point, we need to update it if it's not already registered.
Not directly related to this PR. But at some point, we need to update this to be a public API.
Not directly related to this PR. But at some point, we need to update it if it's not already been initialized.
AJ, An encounter also has a time limit of 2 days set to close. Try the 'dateList' value.
AJ, An encounter also has a time limit of 2 days set to close. Try to use [dateList.size()](<LINK_0> instead.
AJ, An encounter also has a time limit of 2 days set to close. Try to use [dateList.size()](<LINK_0> instead of 2 days.
Do we really need this loop? ComparisonConfiguration.getComparisonConfigurations().resolveBranchAlias(baseBranchName) already returns a Set and then the branch name will be same.
Do we really need this loop? ComparisonConfiguration.getComparisonConfigurations().resolveBranchAlias(baseBranchName) already returns a Set and then the condition below would succeed.
Do we really need this loop? ComparisonConfiguration.getComparisonConfigurations() already sets the ref to null.
put {} around if/else/while/for etc.
put {} around if/else/while/for/etc.
are we gonna put {} around if/else/while/for?
Why do you use a separate mLockShutdown? Can it not be a no-op?
Why do you need to do this after a return?
Why do you use a separate mLockShutdown?
Change getServerFactory() to use this?
Change getServerFactory() to use a deprecated deprecated getServerFactory().
Change getServerFactory() to use a deprecated deprecated method?
This method should be called CommunityService or jobService.getCommunityUuid()
why do you need to change the parameter?
This method should be called CommunityService or baseCommunityMap
It's better to use a switch statement here.
It's better to use a switch statement here too.
It's better to use a switch statement instead of if.
If we need to get rid of these dynamically, you could use org.apache.commons.lang.StringUtils.notNull.
If we need to get rid of these dynamically, you could use org.apache.commons.lang.StringUtils.isEmpty/solr.getIntegrationTest().
If we need to get rid of these dynamically, you could use org.apache.commons.lang.StringUtils.isEmpty/solr#getIntegrationTest().
Why not using the aggregate() method?
Why?
Why not using the super?
You could leave the empty list here. This would save the null check as well.
You could leave the empty list here. This would save a lot of empty lines.
You could leave the empty list after the if.
This line is too long. Did you apply the formatting rules?
I think this line is too long. Did you apply the formatting rules?
Method must not be public as this method is only used inside this class.
You should check if promotionBuilder is not null.
You should check return value before setting promotionBuilder
You should check return value before setting promotionBuilder.
Instead of using an ArrayList, we can use an iterator on the list.
Instead of continuing, we can use an empty list here and avoid the else clause.
Instead of continuing, we can use an empty list here and avoid the null check on the list.
Why is this check removed?
I think this check is unnecessary. The Objects.requireNonNull() will report an NPE if the config is null.
I think this check is unnecessary. The Objects.requireNonNull() will report an NPE if the list is null.
Is there a test to cover this method? Since the same test is using the same stream multiple times, would it make sense to have a function that does the check?
Is there a test to cover this method? Since the same test is using the same stream multiple times, would it make sense to have a function that does this?
Is there a test to cover this method? Since the same test is using the same stream multiple times, would it be possible to split into two?
Can you add a check to make sure the collection is not empty before doing the "throws" operation?
Can you add a check to make sure the collection is not empty before doing the "verify" operation? I am trying to wonder if it is useful when these methods are not called
Can you add a check to make sure the collection is not empty before doing the matching?
shouldn't this be: if (nestedRelationshipEntity == null ||!isNestedRelationshipEntity.equals(Direction.INCOMING)) {
shouldn't this be: if (nestedRelationshipEntity == null ||!isNestedRelationshipEntity.equals(Direction.INCOMING))) {
shouldn't this be: if (nestedRelationshipEntity == null ||!isNestedRelationshipEntity(filter, "m" ) {
rename tochildElement
rename to childDelta
childElement
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
StringBuffer is so 1900-ish. and adding the ", " is I believe cleaner if you add it conditionally
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you put it conditionally
You can use the VmManager.isCreated() method from the VmManager: suggestion if (Vm.isCreated()) {
You can use the VmManager.isCreated() method from here as well
You can use the VmManager.isCreated() method from the VmManager
Remove final as well?
Remove final as well as the next line?
Can you change this to an static method?
I'd add a check for mPoint being null here.
I'd add a check for "top" here and in the if statement below.
I'd add a check for "top" here and in the error itself.
Please use assertNotNull("line.separator")
please use assertNotNull("line.separator")
Please put this in a single statement
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_policy", Collections.singletonList(user)) &&!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_policy", Collections.singletonList(specificUser))) {.. }
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user))) {.. }
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_policy", Collections.singletonList(user)) &&!AuthzResolver.authorizedInternal();
Are we sure that we don't mask the exception here?
Are we sure we can't delete a transaction here?
Are we sure that we can't delete a batch here?
It would be better if we would show the user some message as toast as well!
It would be better if we would show the user some message as toast as well! Also, I would show the user some message as toast as well!
It would be better if you would show the user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessors(...))
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorsRegistry().getQuickAssistProcessors(...))
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Instead of hardcoding path, can you check if inMemoryScope is set on line 115?
Instead of hardcoding path, can you check if inMemoryScope is set on line 205?
Same here
Same here; lowercase
fix typo
I don't think you need to change this method signature.
I don't think you need to change this method signature. Very minor, but you can leave the original fix.
I don't think you need to change this class and implementation.
Can we have a default value for this?
Can we simplify the logic here by having a static method?
Can we simplify the logic here by having a default now?
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond( Quaterniond);
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond( new Quaterniond());
Could this happen?
static import graphvizPrinter
static import graph
PlanFragment::get
This is not the right name. Please use the jclouds predicates2.retry construct.
This is not the right predicates. Please use the jclouds predicates2.retry construct. If this is a common pattern, create the predicate and make it injectable so callers of it.
This is not the right name. I think getResponseBodyAsDto works?
ReElse is redundant here because the previous statement will always be executed.
ReElse is redundant here because the previous statement will always be true.
Is it necessary to check the Function1 above?
Can you explain what problem this is solving? The jira does not tel much about leases.
Can we explain what problem this is solving? The jira does not tel much about leases.
Can you explain why this is a problem if leases is a multiple-table leases?
Consider returning null instead of "null".
Consider returning null instead of "null"
Consider returning null instead of equals
I guess we could just pass the dialog to the PreviewPreferences constructor (instead of the whole method?). That way if the widget fails, the view will have to know how to fetch the icon.
I guess we could just pass the dialog to the PreviewPreferences constructor (instead of the whole method) as a static method, and then combine the code into the'show()' method.
I guess we could just pass the dialog to the PreviewPreferences constructor (instead of the whole method) as a new one, and reduce the code duplication?
Please don't use toString() asSODateTimeFormat.basicDateTime() can be used instead.
Please don't use String.format when using format
Please don't use toString() asSODateTimeFormat.basicDateTime() can be used here.
@idelcano The session is not found at all. Shouldn't we do it only for debugging?
@idelcano The session is not found at all. Shouldn't we do it only when we have a session?
@idelcano The session is not found at all. Shouldn't we do it only when the key is removed?
This check should not be made in this event.
This check should be done in the listener interface to ensure that it doesn't happen.
This check should not be made in this PR.
@mykelalvis please, rename to server. singo
Will this work with Java 10/11?
@mykelalvis please, rename to project
This implementation has to be in the interface.
This implementation has to be in the interface. It doesn't seem like it can be JDK 1.8.
This has to be an IllegalStateException.
I guess you don't need to set the same workspace as the one received in the workspace as the workspace is available to all workspaces...
I guess you don't need to set the same workspace as the one received in the workspace if the workspace is available?
I guess you don't need to set the same workspace as the one received in the workspace if the workspace is available and just overwrite it.
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling send.
The interceptors must not try to access the CompletionStage type, but it isn't safe to suspend the TM transaction before calling invokeAsync.
The interceptors must not try to access the CompletionStage type, but it isn't safe to suspend the TM transaction before invoking the interceptors.
Why not move this logic to NamedType?
Why not move this logic into NamedType?
Same question for longs
SA == SERVICE_ACCOUNT? avoid abbreviations
SA_CLIENT_EMAIL_TOKEN is not used in this test.
SA == SERVICE_ACCOUNT? avoid abbreviations.
Can be replaced with for (Entry<String, Object> entry : vars.entrySet()) {
Can we put back the for loop here?
Can be replaced with for (Entry<String, Object> vars : vars.entrySet()) {
Should we throw a TechnicalException instead of leaving it null?
Should we throw a TechnicalException instead?
Should we throw a TechnicalException instead of leaving the original exception in the signature?
Might make sense to add an overload of getMaxPriority() in this class.
Can we make this an enum?
Might make sense to add an overload of getMaxPriority() in order to avoid some duplicate code.
Hmmm this is redundant. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status of the API and that should be enough. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
Hmmm this is redundant. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status of the API and that should be enough. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status of the API and that should be enough.
Hmmm this is redundant. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status of the API and that should be enough.
Lets use VectorUtils.of(...) instead of Guava.
Lets use VectorUtils.of(...)
unused
Might want to change this to an ExpressionEnd, I think.
Might want to change this to an ExpressionEnd, no?
Might want to also check that the item is RECONNECTION_TIMEOUT.
This should be a check if it's not 0 or null.
This should be a part of ViewModel as well.
This should be a check if it's not 0.
Use entriesPositions.elements() instead of Arrays.asList(...)
Use entriesPositions.elements() with empty array instead of nulls.
Use mapValues
This cast is redundant with the method already available in the class
This cast is redundant with the method already.
This should be test in the listener
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the codePoint declaration without an initializer brought me up short.
I think this might be clearer as a while loop, or a for with an empty third part. Certainly the codePoint declaration without an initializer brought me up short.
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the isEmpty() directly but this method always returns absolute value.
this was the same as the previous one.
null check
same here.
In all cases of this pattern, we're throwing away the NotFoundException. It would be better if we could pass it as an argument to this method, in the case that articleKey was null isn't found.
In all cases of this pattern, we're throwing away the NotFoundException. It would be better if we could catch the "cause" exception from the deserialize case and throw a NotFoundException.
In all cases of this pattern, we're throwing away the NotFoundException. It would be better if we could pass it as an argument to this method, in the case that articleKey was not found.
I was thinking of adding this in the way that you mentioned that you hadn't considered at all, so you might want to have the full separation between the call to FormRecord, I can think of a way to do it here. For example, you could have the Dao approach to call FormRecord::update on instead of here and in ViewModelUpdateManager
I was thinking of adding this in the FormRecordWriter, can you please provide a way to approach this in a few places?
I was thinking of adding this in the way that you mentioned that you hadn't considered at all, so you might want to have the full separation between the call to FormRecord at the end
I can't get why is there a particular reason for this check?
I can't get why is there a particular reason to call this function?
I can't get why is there a particular reason to call this method?
I do not like this change because it is needed we have the complexity of create entries. Without trying to refactor properties lets try to move all the queries to DB instead.
I do not like this change because it is needed we have the complexity of create entries. Without trying to refactor properties lets try to move those properties into DB_id and method.
I do not like this change because it is needed we have the complexity of create entries. Without trying to refactor properties lets try to move those properties into DB.
You can use lambda here as well.
You can use Runnable as the type.
You can use Runnable as the name of source and target.
it should use integer parameter instead of true i think
it should use parameter instead of true i think
it should use true instead of false i think
This line has a typo in the name of the enclosing method.
This line has a typo in the name of the userHome property.
This line is too long.
You could avoid doing logger.error() here. This way, everything needs to be set to null.
You could avoid doing logger.error() here. This way, we can avoid the exception from logger.
You could avoid doing logger.error() with logger. logger when you used the exception?
This seems like it should be above a checkTableStatus, because the table is created in  table.
This seems like it should be above a testTableStatus method
This seems like it should be above a checkTableStatus, not a table
We cannot convert to boolean value, same reason
we cannot convert to boolean value, same reason
We cannot convert to boolean value, can we use here.
Just curious: why do you need this try-catch?
Just curious: why do you need this try-catch block?
Just curious: why do you need this change?
Can this be extracted as a constant?
@pecko @tsev This is a lot more readable if this ("if (lastFailure!= null) { return!Boolean.TRUE; } else if (lastFailure!= null) { return false; }
@pecko @tsev This is a lot more readable if this ("if (lastFailure!= null) { return!Boolean.TRUE; } else if (lastFailure!= null) { return true; }
nit: use arrayTexts and new String[] {node.asText() }.
nit: use arrayTexts and new String[] {node.asText() }
nit: more readable format?
I wouldn't use the word "SyntaxException" here.
I wouldn't use the word "key" here.
I wouldn't use the word "key" in this message.
Use equals.
We should use StringUtils.equals.
We should use either equals.
fieldValue should not be used here.
fieldValue?
fieldValue should not be declared in this class.
@rivera-zA- I think we should change this to: if (session == null) { return; }
We should not catch all exceptions, only Exception.
@rivera-zA- I think we should change this to: if (!refreshResolver.isLivePacket(session))
so we don't really need this catch block?
so we don't really need this catch statement?
why not use the variable op instead?
let's return null from this method?
let's return 204?
let's return null from this method, rather than handling null.
Great catch! Can we make this a bit more explicit?
Great catch! Could we make this a bit more explicit?
Great catch! Could we make this a bit more explicit? Thanks
Catching a try-with-resources block seems OK.
Missing try-with-resources.
Catching a try-with-resources block seems a bit redundant.
You can use Guava's Objects.equal to make this shorter.
You can use Guava's Strings.isNullOrEmpty() (this is a little shorter)
You can use Guava's Strings.isNullOrEmpty() (which also makes this more readable.
instead of an early return, you could just have the execute() method and have the parsefail() call fail
check for null before doing so?
(not null)
Does this need to be a local variable?
Does this need to be a local var new?
I think this should be local
Do we really want to call setRefreshingCourseDiscoveryEnabled() at this point?
Are we sure we want to leave this check in the default if the list is empty?
Do we really want to call setRefreshingCourseDiscoveryEnabled() at this time?
maybe it's better to use something like: "Can't load property \"..") + dialect.propertiesString().split("..")
maybe it's better to use something like: "Can't load property \"..") + dialect.properties_PROPERTIES() + "\"...";
maybe it's better to use something like: "Can't load property \"..") + dialect.properties_PROPERTIES;
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the file has this property.
I'd like to see what the format of the output is for JFlat. These MUR and TracingUtility.
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options
This is valid I was trying to unify
This is valid ICH for the old code was added to a new hash map of MojoCH.
This is valid ICH for the old code was added to a package
there is no need to use a string literal here
there is no need to call.toString() with path path
there is no Exception thrown here
Write if (value == null) { continue; } instead
Write if (value == null) { continue; } instead of big else.
Set (value == null) { continue; } instead of big else.
This is changing the behaviour of [consuming compressed schema](<LINK_0> which is counter-intuitive. It's not a good idea to throw a RuntimeException when the object has been ignored, but in the future it may be less tought.
This is changing the behaviour of [consuming compressed schema](<LINK_0> which is counter-intuitive. It's not a good idea to move this into a separate PR, but how about creating a separate PR for each call, checking whether the field length is 2 or more of a property?
This is changing the behaviour of [consuming compressed schema](<LINK_0> which is counter-intuitive. It's not a good idea to throw a RuntimeException when the object has been ignored, but in the future it may change.
initializeMod11ProxyAnnotation() doesn't need to be public, but it shouldn't be private.
initializeMod11ProxyAnnotation() doesn't need to be public, but it shouldn't be public.
Are you sure this doesn't need to be public?
why not use the logger for this?
why do you need to print the stack trace here?
why not use the logger for the failure message?
Are we sure that we want to zero the yaw on initialization?
Are we zero the yaw on initialization?
Are we sure that we want to zero the toString() method?
It would be good to figure out whether this is a race condition, since the way it could be getting most of the time.
It would be good to figure out whether this is a race condition, when two threads call this method simultaneously.
It would be good to figure out whether this is a race condition, since the way it could be running and set to null at the end.
can you move this line before the loop and put the LARGE_OPS block?
can you move this line before the loop and put the LARGE_OPS in a separate line?
can you put the LARGE_OPS prefix here?
doesn't the message need to be updated?
doesn't feel right be on the next line
NO_ID
You can use a variable for the column name
You can use a variable for the column names.
You can use a variable for the column name like that.
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
Ravi, if you just initialize this with true before the creation of the tasks then your fix will be perfect.
Ravi, if you just initialize this with false before the creation of the tasks then your fix won't be perfect.
return result of Checker.get() should be used instead of Checker.get().
return result of Checker.get() should be used instead of Checker.get().getName().
return result of Checker.get() should be used in all cases, don't need to introduce another variable.
Nice! If you have a file with two partitions and one with the same name, why do we need to save them?
Nice! If you have a file with two partitions and one with the same name it needs to be logged, why do we need to print it again? "Will use a file archive, but it does not exist in the fidel
Nice! If you have a file with two partitions and one with the same name it needs to be logged, why do we need to print them?
Does this have to be public?
Does not need to be public.
IResourceDelta.MODULE was supposed to be used in the change.
Shall we extract this to a constant, e.getMessage()?
Shall we extract this to a private method?
Shall we extract this to a private method, e.getMessage()?
looks like we don't need the resource URI here.
looks like we don't need the entity here?
looks like we don't need the resource URI here?
I wonder if this one is really needed, or?
I wonder if this one is really needed, right?
Can this be just one line?
Use already defined Constants
Wrap the exception
Use already defined constant
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address will be taken from the pool i think that releasing the mac addresses better be done at the end
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end.
Also need to verify that there is only 1 object in the iteration?
Can you replace this with a @NonNull? I think there's a typo
Can you find a better name for that? I mean, you can say "e", only the type of the object
This can be removed?
This can be removed? Kinesis not used?
This can be removed? Combine with the next line
I'm not sure this is right. On the other hand, the "merge job" implementation of UpdateJob seems to be missing. For example, if we end up with a *very* big job since this is the tad't-engine/core/b3c3f4e3a4e5bca4e5bc it would probably not work. But what is the rationale for this change?
I'm not sure this is right. On the other hand, the "merge job" implementation of UpdateJob seems to be missing. For example, if we end up with a *very* big job since this is the tad't-engine/core/bumps
I'm not sure this is right. On the other hand, the "merge job" implementation of UpdateJob seems to be missing. For example, if we end up with a *very* big job since this is the tad't-engine/core/b3c3f4e3a4e5bca4e5bc?
Name is misleading; it's a node name that's not found, not just a path.
Name is a horrible method name.
Name is a horrible name.
toString() not required, toString() will be always false.
RMModuleParameters
[]
Probably it's more efficient to iterate over authToken. It's also more efficient to iterate over the credentials.
Do we need to check the token type here? We don't check anything, since toString() will return true for credentials.
Do we need to check the token type here? We don't seem to be able to reach the token type unless credentials are null, otherwise we could get an exception which prints the token.
You need to pass the auth in the list as a parameter
You need to pass the auth option along when doing the resolving, not sure we should do it
You need to pass the auth option along
Nice fix!
Nice coverage, but well done!
Missing {}
Can you please make this block contribute the the dynamic workspace to the dynamic storage.
Can you make this protected?
Can you please also make this protected?
Should this throw RuntimeException? What exception are you trying to do with BaseTokenStoreException?
Should this throw a RuntimeException? What exception are you trying to do with the rest of the code?
Should this throw RuntimeException? What exception are you trying to do with the rest of the code?
This test looks wrong to me. It's not clear to me that this line is modifying the file name. I think it's better to add a function to the list of remaining messages.
This test looks wrong to me. It's not clear to me that this line is modifying the file name. I think it's better to add a function to the end of the list of remaining messages.
This test looks wrong to me. It's not clear to me that this line is modifying the file name. I think it's better to add a function to the end of the list of remaining messages to ease the process.
Why do we need this?
Why do we need the value here?
Why do we need the value?
I think this is good, but Prefs.isReadingListSyncEnabled is set to false when isReadingListSync == true. In the other cases, the list is completed by the time when isReadingListSyncEnabled is called. Since isSyncEnabled is false, the offset is no longer set to true before this line.
I think this is good, but Prefs.isReadingListSyncEnabled is set to false when isReadingListSync == true. In the other cases, the list is completed by the time when isReadingListSyncEnabled is called. Since isSyncEnabled is false, the offset is no longer set to true before this line. Prefs.isReadingListSyncEnabled() is executed.
I think this is good, but Prefs.isReadingListSyncEnabled is set to false when isReadingListSync == true. In the other cases, the list is completed by the time when isReadingListSyncEnabled is called. Since isSyncEnabled is false, the offset is no longer set to true before this line. Prefs.isReadingListSyncEnabled() is called.
Should read a cursor.close() call to see if read fails.
Should read a cursor.next and see if read fails.
Should read a cursor.close() block.
Use assertNotNull() instead.
Use fail() instead.
Use fail() instead of catching exceptions.
why are we checking RANGE header here?
if range is null, should probably throw a NotFoundException.
acquisition of all the RHS does the same thing and this lines are not necessary.
Should this be moved back to constant?
Should this be moved back into initializing?
Should be moved back to constant.
Is it really necessary to add an error message.
Is it really necessary to put ;) on its own line?
Is it really necessary to put ;) on same line?
authentication isn't being used?
authentication isn't registered?
Can you add a @Rule annotation for this?
I don't like that this is very much value. Do you know?
I don't like that this is very much scope of a difference, but is it important that time is blank now?
I don't like that this is very much scope of a difference, but is it important that time is blank?
use Guava's Iterables.getFirst() instead
use Guava's Lists.newArrayList() instead
use a stream instead
Is this line correct? Looks like a non-null check is necessary.
Does this not need to be a warn level?
Is this line correct? Looks like a non-null check on request.
Also, the logic of this class is repeated in a few places. Please extract it to a separate method.
Perhaps move this logic into the if block?
Also, the logic of this class is repeated in a few places. Please extract it to a constant.
is it OK not to put the segment location in LedgerSchema?
is it OK not to put the segment contents into the map?
this is not a good change..
Can this be replaced with if (zkClient.removeWatches(client)) {
Can this be replaced with if (zk.exists()) {
Yeah. That's what I meant.
What is the intent behind this change? Might be to use the following to split the list: private static List<T> ArrayNode createTags(String className) { if (marker.getMarker().contains(marker.getName())) { return ArrayNode_JSON; } else { return ArrayNode_JSON; } }
What is the intent behind this change? Might be less error-prone.
What if location is null? Might be an issue but I'm not sure it can be.
I would consider making the variable name more meaningful. Something like BlackboardAttribute param and return
I would recommend passing the BlackboardAttribute and return immediately after the if statement.
I would consider making the variable name more meaningful.
Maybe better to return int.
Maybe better to return int?
any reason for this change?
remove
investAmount and timestamp
investAmount
replace this with Logger.getLogger().debug( "Failed to login as anonymous user {}", e);
replace this with Logger.getLogger().debug( "Failed to login as anonymous user {}", e.getMessage());
replace this with Logger.getLogger().debug(e);
You can do f.orElseThrow(() -> new HaxeReference(expression, "HaxeClassReference")); and avoid the isPresent check if there is no HaxeReference.
You can do f.orElseThrow(() -> new HaxeReference(expression, "HaxeClassReference")); and avoid the isPresent check if there is no HaxeReference.get().
You can do f.orElseThrow(() -> new HaxeReference(expression))); instead.
Shouldn't it be 'TO_CHAR'?
Shouldn't it be sqlOutput.stream()?
Shouldn't it be sqlInput?
Again, these should not pass validateInputs()
invert equals()
invert equals
braces
final
final (space)
the steps 35, 36 and 38 are not neccesary
The steps 36, 37, 38 are not neccesary
The steps 36, 37, 38 are not necessary, please add this steps
I think this will overflow if the span is an empty string.
I think this isn't an issue, because the span will always be a string
I think this is an incorrect place.
which exception are you avoiding?
which exception are you avoiding? It is not clear why you are doing anything.
which exception are you avoiding?
IgniteEx assertFalse(state.state(), "INACTIVE ACTIVE", state);
IgniteEx assertFalse(state.state(), IgniteEx.active());
IgniteEx assertFalse(state.state(), assertFalse(state.state(), INACTIVE.ACTIVE);
this is now a problem...
call this function : "create"
call this function on line 88
instead of calling String.trim() multiple times here use map(), e.g. Files.lines(p).map(String::trim).forEach(...) You could also filter there too, e.g..map(...).filter(s ->!s.isEmpty()).forEach()
instead of calling String.format() multiple times here use map(), e.g. Files.lines(p).map(String::trim).forEach(...) You could also filter there too, e.g..map(...).filter(s ->!s.isEmpty()).forEach()
instead of calling String.trim() multiple times here use map(), e.g. Files.lines(p) You could also filter there too, e.g..map(...).filter(s ->!s.isEmpty()).forEach()
Is this really needed?
I think we should use the iterator over the list.
Is there a reason for not using the iterator?
nit: do you need AuthMethodPickerActivity.this or could it be just this?
nit: do we need AuthMethodPickerActivity.this or could it be just this?
nit: do you need AuthMethodPickerActivity.this or can it be just this?
Same here, should use the other.
Same here, should use the other way around: use the else here instead of the clause
Same here, should use the other way around: use.equals(pools)?
Are we guaranteed that there will be a isEmpty method in AttributeImpl?
Are we guaranteed that there will be a isEmpty() check here?
Are we guaranteed that there will be a null binding to the default value?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))).defendingUnit(givenUnit()).defendingUnit(givenUnitIsAir()).build();
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitIsAir()).build();
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitIsAir()).defendingUnit(givenUnitIsAir()).build();
is it possible for this line to be executed on an empty line?
is it possible for this e.g. onToggleItemOffline() to be called unconditionally?
is it possible for this e.g. onToggleItemOffline() to be called? I guess the effect is the same.
Can you make these variables final and they can be used for both methods?
Can these be declared final and used for both methods?
Can these be declared final fields?
suggestion } catch (InvalidInvalidException ex) {
suggestion } catch (InvalidInvalidException e) {
suggestion } catch (InvalidInvalidException e) {... }
This method can be private
This method can be made private
This can be private
Missing an extra space at the end of "knows".
Missing an extra space here?
Missing an extra space at the end.
Could be extracted in a helper method.
Could be extracted in a helper.
Could be extracted in a helper method?
It seems that we are not using the partition stats. We should remove this line.
It seems that we are not using the partition stats. We should remove this code.
Is this needed?
optional: can be merged
optional: can be replace with a Matchers.contains(actual)
optional: can be replace with a regular assertTrue or assertEquals.
why two space?
NPE?
why two constants?
should it be eobjectArrayValue0 and testInteger?
should it be eobjectArrayValue0 and date?
should it be eobjectArrayValue0 and testIntegerInteger?
Don't you think that set in a static field will be simpler?
Don't you mind moving this line to a "default_cpu_limit" constant?
Don't you mind to set the default value to a constant here?
Maybe a message could be helpful here.
Maybe a message here would be helpful.
Maybe a message could be helpful here. I don't think this is necessary.
We should use Thread.sleep() in tests instead of sleeping.
We could use Thread.sleep() in tests instead of sleeping.
We could use Thread.sleep(100) to make the test a little cleaner
Why not this. 5?
Why not <LINK_0>
Why not this.
can this be a separate function to avoid the break tag?
if (log.isTrace() && seekEvent())
if (log.isTrace() && seekEvent()) {
I think we should make this a constant, and put it in the getWidth()
I think we should make this a constant and put it in the getWidth()
I think we should make this a constant, and put it in a private static final variable
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out why it happens.
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it makes sense.
Yeah, I think it makes sense.
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActive What does "status" actually represent in this parameter? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate?
This would be false if newlyDisallowed && prevDisallowed && prevDisallowed &&!tetheringActive What does "status" actually represent in this parameter? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate?
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActive What does "status" actually represent in this parameter? If it represents whether 'code' is disallowed, maybe just newlyDisallowed would be appropriate?
use Map::computeIfAbsent instead
use String.format instead
use Map.computeIfAbsent
if PLANPOSTURL is set, it will be more clear to users.
same here, to reduce the amount of code duplication.
if PLANPOSTURL is set, it will be okay to drop the first set.
do we need this?
do we really need this?
do we need both this and the other print?
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, chargeEventEntity.getId(), charge.getExternalId());
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), charge.getExternalId());
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), externalId={}] [chargeEventId={}]", fromChargeState, chargeEventEntity.getId(), charge.getExternalId()); }
suggestion LOG.debug("The version did not change '{}'.", rawSize);
suggestion LOG.debug("The version did not change '{}'.", Bytes);
suggestion LOG.debug("The version did not change '{}'.", rawBytes);
Why not change this to lazyCompactBlock?
Why not change this to be lazyCompactBlock?
Wrong variable name.
add this to the previous line
swap the two lines
add this to the previous line.
We should write a test for dropping connections.
We should test the condition for the specifics.
We should test the condition for the specifics right?
If the error happen that early, can you map the error in early phase before mapping page result?
If the error happen that early, can you map the error in early phase before mapping page result, so toText( error).
If the error happen that early, can you map the error before mapping page result?
Add the parameter to the log message
I am not a lover of the parameter... Let's add the parameter to the log.
Add the parameter to the log
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
suggestion boolean notInGraphAtAll = candidatesForDeletion.size() == 0;
Why not ==?
if you turn.toUpperCase() and throw IllegalStateException, no risk to let user know about this
if you turn.toUpperCase() the [here](<LINK_0> I think we should do it here not take into account
if you turn.toUpperCase() the [here](<LINK_0> I think we should do it this way
you don't need to wrap with a custom exception since it's the same message.
you don't need to do this.
you don't need to do this. You can use reflection.
Extract method to descriptive variable name
Can we please cache method names?
Can we please cache method names more readable?
This would be more readable if you move the code after the if (count == 0) {
This would be more readable if you move the code from the function below so that the flow is clear.
This line can be more readable as well.
I don't think this is going to be a problem, but it might be better to provide a getter below.
I don't think this is going to be a problem, but it may be better to provide a getter below.
I don't think this is going to be a problem, but it may be better to actually set the variable symbol size.
Move this if block after all if blocks.
use SafeEncoder.encode(String, String, getParam(String.class));
use SafeEncoder.encode(String, String, getParam(String.valueOf(parameter));
I think this resourceMap.getResource(URI.CONTENT_SCHEME) is a bit simpler.
I think this resourceMap.getResource(URI.CONTENT_SCHEME) is needed, since it is also used in the resourceMap.
I think this resourceMap.getResource(URI.CONTENT_SCHEME) is a bit simpler, but a resource map may be simpler.
Please don't remove this mechanism for changing the color.
Please remove this TODO: <LINK_0>
Please don't remove this class
space?
space after if
space
map initialization is redundant here, since igniteParameters.getPassword() is private.
map initialization can be replaced with igniteParameters.getSystemProperty("company")
May be better to use StringUtils.isNotBlank()
formatting?
formatting please
formatting looks off
Slightly confused by the message here. If "hToken" is not equal to HostPool. So we should at least log a warning here.
Slightly confused by the message here. If 'hashtag' is not valid for HostToken then we have the same host and the one that was on HostToken. In that case, we should add the hostPool == null case before.
Slightly confused by the message here. If 'hashtag' is not valid for HostToken then we have the same host and the one that was on HostToken. In that case, we should add the hostPool == null check here.
Why do we use iterators? I know the base class does, but why in the first place?
why do we use iterators? I know the base class does, but why in the first place?
Do we really need to use iterators? I know the base class does, but why in the first place?
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn).
Only need to create one Admin for the first two dataTableFullName. This change only moves the number of tables that have the same problem.
I would only check size == 1 here as well.
I would only check size == 1 here.
We could only check size == 1 here.
suggestion if (this.shadowero) {
Remove this if statement.
Why is this more efficient?
nit: (here and elsewhere)
nit: (here and below)
nit: (here ) We can use ImmutableMap.copyOf for this
I think that this should be a try-with-resources as well
I think it's better to use try-with-resources as you did in the other files.
I think it's better to use try-with-resources as well
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check Write, which is a high-level permission containing many low-level ones.
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check Write, which is the ones you want in AbstractSession.
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check Write.getName() on the array and use resolvedPermissions.contains(resolvedPermissions).contains(WRITE).
I feel like we can inline the entrySet.stream() into a single statement.
I feel like we can inline the entrySet.stream() into a single call to avoid the redundant isPresent check.
I feel like we can inline the entrySet.stream here
I am wondering if it might be better to call super.initialize explicitly instead
can we use super.initializeFormatName() instead?
can we use!= null instead?
You can use the following: assertNotEquals(file1, path2, true);
You can use IOUtils.readFully(file1, path2, true) here to remove the line 90.
You can use IOUtils.readFully(file1, path2, true) here to remove the line above.
setSnomedSimpleMapRefSet() should be added as a dependency.
AbstractSnomedSimpleMapRefSet has already been set on the reference set.
Not required.
why do we need two builtinMap methods?
Where do we have builtinMap methods for these?
Where do we compare the two builtinMap instances?
Please use the count defined in assertj: assertThat(onSuccess).hasSize(2);
Please use the count of the metric here too.
Please use the count defined in assertj: assertThat(onSuccess, is(true))
I would include this as a constant value here.
I would include this in the util too.
I would include that since it's not a public API content, we should also include that.
Use logger?
Try to use logger?
Use logger.
4 spaces
4 spaces around this
4 spaces around!
Is this really a "magic number" 3?
Is this change a language error?
Is this really a "magic number" 3 lines?
"Gctop" is too long. Perhaps want to name it like "Gctop".
"Gctop" is too general. "We want to know how to fix this kind of error". Perhaps the error message like "Cannot open repository with format {}"?
"Gctop" is too general. "We want to know how to fix this kind of error". Perhaps the error message like "Cannot open repository with format: " + e.getMessage()
no need to add "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
no need to add a constant for the class name (also for the other logging below)
no need to add it here, the above code is already done in the class (as there is no other place in this class)
[ERROR] /Users/g/jenkins-slave/workspace/Base-mailet Test/src/main/java/org/mail/jenkins/plugins/jenkins-mail/jenkins-plugins/localhost/mail/jenkins-client/StiageTimeout.java:[471,41] error: [ERROR] /home/dcaro/jenkins-slave/workspace/Base-java:[471,41] error: [ERROR] /home/d9494/src/main/java/org/mail/jenkins/plugins/jenkins-slave/workspace/Base-Notes:Tests--mail/jenkins-plugins-be-app-mail
[ERROR] /Users/g/jenkins-slave/workspace/Base-mailet Test/src/main/java/org/mail/jenkins/plugins/jenkins-mail/jenkins-plugins/localhost/mail/jenkins-client/StiageTimeout.java:[471,41] error: [ERROR] /home/dcaro/jenkins-slave/workspace/Base-Notes:36-71-7410
Log level?
If the error is _empty_ to the refresh, then it means that it's a bug, right? Just log it as a warning?
If the first attempt fails, this will log the error. Instead of returning early, we should likely log it after the fallback.
If the error is _empty_ to the refresh, then it means that it's a bug, right? Just log it as a warning.
You're missing some brackets here.
You're missing some stuff here. EntityPlayer#builder().result(DataTransactionBuilder.class).build()
You're missing some stuff here. EntityPlayer#builder().result(DataTransactionBuilder.class)?
you can simply use Predicates.notNull()
there is already a Predicates.notNull() for the segment, I think it doesn't need to be.
you can simply use Predicates.notNull() here
does this mean that if you want to be able to add a selector that does this work as expected?
does this mean that if you want to be able to add a selector that does this work for you?
does this mean that if you want to be able to add a selector that does this work?
Why would you want to pick a LinkedList here instead of an ArrayList?
Why LinkedList? You can just use Map.computeIfAbsent.
Why LinkedList? You can just use Map.computeIfAbsent and avoid the extra List allocation
This seems to be a dangerous method. It should be called once at the top of the method.
This seems to be a dangerous method. It should be called once at the top of the test.
This should be a info message.
We could avoid cloning here? (The message is not modified by the view?)
We could avoid cloning here? (The key is not modified by the view?)
We could avoid cloning here? (The message is not modified by the view)
Could we replace the 2 * TupleBatchBuffer.nextReady() with IntStream.range(0, j.getConcatSize())?
Could we use TupleBatchBuffer.NO_ALIGNMENT_REFERENCE_NAME to make it clear what the special precondition is?
Could we use TupleBatchBuffer.NO_GEN5 instead?
Consider using slf4j parametrization instead of string concatenation.
Consider using slf4j parametrization instead of e.printStackTrace()
The reason why the generic exception is here is so that we don't have to catch Exception.
The last position is the same as lastPosition.
The last argument should be last.getAttributes().containsKey(attribute)
The last position is the attribute id.
is this necessary if the next calls fail?
is this correct?
is this used?
Could just move portName as a parameter to the constructor. That way we don't have to create a new port.
Could just move portName as a parameter to the constructor. That way we don't have to repeat in this class.
Could just move portName as a parameter to the constructor. That way we don't have to create a new port chain.
Why should return directly.
should return after this.
... but I would put this right after ILaunchConfiguration
I'd rename the variable to rowDetailField
I'd rename the variable to columnDetailField
I'd rename the variable to columnDetailField or something.
For performance, I think we should assert that both values are greater than zero.
Query size is not supported for all values.
For performance, I think we should assert that both values are not supported for the same things.
I'd rather see a dedicated class for this - DeployRoles.ADMINISTER
I'm not a fan of this method, since project may be mutable and thus trying to force a refresh. Change it to use the passed in getDefaultCredential() and you create a new method that is then used by other methods
I'm not a fan of this method, since project may be mutable and thus trying to force a refresh. Change it to use the passed in getDefaultCredential() and you create a new method that is then used by other classes
nit: space around createSecrets
nit: space around l
nit: space after try
I think this is incorrect - we shouldn't be placing files for variants of the blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can this be improved?
is this finally block necessary?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
Update log messages to refer to timer instead of commit, here and below.
Update log messages to refer to timer instead of commit, this method should be renamed.
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in?
The other examples all use ASCII table output - is there a reason for switching to CSV?
The other examples all use ASCII table output.
Why are we shutting down the jedis connection?
Why do we need to wait 100ms?
Why do we need to wait for the cache to get the version?
I don't understand why you didn't use the variable name directly.
I don't like the name of the variable... I think it's a bit confusing to read.
I don't understand why you didn't use the context.rootTree variable...
Combine these two lines with an else onto the same line as the other one.
Combine these two lines with an else onto the same line as the other one?
Combine the two lines with a single line?
With the current code, you are sure the if/else branch has not been deleted.
With the current code, you are calling getTag(), so don't need the else clause.
With the current code, you are calling getTag(), so don't need the toString()
Why not just pass the new MessageQueue directly?
I'm not entirely sure this is the cause.
Is this necessary?
This annotation is not required. I'd prefer to keep it as it was.
This annotation is not required. I'd prefer to remove this.
This annotation is not required. I'd prefer to keep it as it was before.
this doesnt look correct. if we use the config we need to query the task name for all tasks it should be "/tasks"
this doesnt look correct. if we use the config we need to query the task name for all tasks the week, right?
if you use else if?
Please revert the changes in the commit message here.
Please revert the changes in this file.
Please also update the name of the method above.
Throw an Exception on udp. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Throw an Exception on udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever be null.
wrap ledger ID in a finally clause?
wrap this line
wrap?
please change it to assertEquals(expected, actual)? So that we always change the test data.
please change it to assertThat(v).isNotEmpty();. It is more readable
please rename to gt
I think you could still get rid of the iterator() and just do a remove() here, and the remove() method could be written as return getAuthentication().getAttributes().putAll(attrName);
I think you could still get rid of the iterator() and just do a remove() and the remove() call. It would be enough to only do the lookup and the values() method.
I think you could still get rid of the authenticationAttribues variable and just return the values.
I'd do it only once, just in case it's not empty.
I'd do it only if the profile exists, just if it is empty.
I'd do it only if the profile profile is active.
Do we need a retry here?
Do we need to check if netty usedMemoryBytes is * bytes?
Should we check if netty used to pass the bytes to this method?
Please avoid using e.printStackTrace().
Please avoid using Log for exceptions.
Log as t.
if (!Objects.nonNull(name))
Does this need to be public?
if (!Objects.equals(dbObject))
- spell out partitionName for partition %s
- spell out partitionName
- spell out partitionName -> partitionName
Don't you need to rename it to testName?
Don't you need to rename it to createSystemTags?
Don't you need to rename it to testElementsUpdateMetadata?
Did you want to have a Preconditions.checkNotNull here?
Did you want to have a look at the code, like this: this.element = parts[2].toArray();
You need to have a Preconditions.checkArgument() call here.
The indexNullAsValue can be null if the indexNullAsValue is not a field.
The indexNullAsValue can be null if the indexNullAsValue is not a valid field.
I believe this should be StoredField instead.
why create a new array for it?
why create a variable for it?
why create a new array here instead of creating a list?
Redundant brackets { } for (int i = 0; i < s; i++) { l.add(sb.toString()); l.add(sb.toString()); }
Style-nit: We avoid curly braces around single line blocks
Style-nit: We avoid { } around if body
suggestion Throwable exception = new RuntimeException("fake exception 1").addSuppressed(exception));
suggestion Throwable exception = new RuntimeException("fake exception 1").addSuppressed(exception);
suggestion Throwable exception = new RuntimeException("fake exception 1").addSuppressed(exception1);
Can this be simplified to java return "MCBlockState withProperty(blockState, propValue, propValue);
Can this be simplified to java return "MCBlockState withProperty(blockState, propValue);
Can this be simplified to java return "MCBlockState withProperty(blockState, propValue)" {
Let's make all of these finals.
Let's move this end of the FBO declaration and just add an empty line.
Let's move this end of the FBO declaration to just before the FBO is passed.
Can you use == rather than DISALLOW_CONFIG_TETHERING here?
Can you also log a warning and then return if it's null or empty?
Can you also log a message or similar?
Why the declaration and not int?
Why not just return the int[]?
Why the declaration is here?
getLong?
Null-check
getLong is deprecated?
Does toString() need to be called if statement is null?
Does toString() need to be called on MyriaJsonSerialization?
Does statement.toString() make sense?
minor: you could move result_size_SIE_IN_BYTES out of the function.
minor: no need for result variable
line
Missing nullcheck on AbstractPlanBuilder
Missing nullcheck on AbstractPlanBuilder.build
Missing nullcheck on AbstractPlanBuilder.build?
Prefer using the compiled pattern as a regex instead of manually replaceAll(). I believe it's done automatically on Linux, but I'm guessing this will replace "https", "foobar" even if you think it's simpler.
Prefer using the compiled pattern as a regex instead of manually replaceAll(). I believe it's done automatically on Linux, but I'm guessing this will replace "https", for example.
Prefer using the compiled pattern as a regex instead of manually replaceAll(). I believe it's done automatically for the compiled pattern.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
1. you compare with the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
This device seems unused. Can it be removed?
Why do you need to null check here?
Instead of calling toLowerCase(), we should use null check for username and password here.
Instead of calling toLowerCase(), we should use null check here.
Extract private void testConvertBedToTargetFile(String input, String element, boolean expected) throws IOException { gtTargets.get(i), TargetFile.class); }
Extract private void testConvertBedToTargetFile(String input, String[] args) to class level code?
Extract private void testConvertBedToTargetFile(String url, String name, gtTargets)
suggestion throw new InvalidCastException("partNumber and partNumber", e);
suggestion execute( Method.class, getRegion(partNumber, JsonNode.class));
suggestion execute( Method.class, getRegion(partNumber, JsonNode.class),
Calls super but that method is invoked in the base class
Replace using Class.forName("minecraft").toLowerCase()
Calls super but that method is using a method that is always true
I think this is the only owner that will need to be sent.
I think this is optional.
I think this is an optional.
I think this should be logged at debug level.
I think this should be logged at debug level. It is redundant to the caller of this method, but _partitionChangeCallback is not necessary.
I think this should be logged at debug level. It is redundant to the caller of this method.
is this required?
java //NON-NLS-1
java //... }
assertThat( query ).assertThat(...)?
assertThat( query )
assertThat( query )?
try-with-resources?
try-with-resource might be better here?
Minor: try-with-resources
This could be: if (input.size() > 0) {...
This could be: if (input.size() > 0) {... }
Perhaps we could use the AntiSamy validation error.
Do we need to check for duplicates inside ClientTxAwareRequestProcessor?
Should we filter for ClientTxAwareRequest inside a try-catch block?
Do we really need a lock when creating a new ClientTxAwareRequest on every call?
log.error("Failed to prepare image {} on the image {} on the image {}: {}", getParameters().getStoragePoolId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId
log.error("Failed to prepare image {} on the SPM", getParameters().getStoragePoolId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImage
log.error("Failed to prepare image {} on the SPM", getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId(), getParameters().getImageGroupId
Is this correct? what happens if no token is provided?
Is this correct? what happens if no token is provided? is this a valid value?
Is this correct? what happens if an exception is thrown, but the value is null?
Eeek, eatin away exceptions?
EINK would be clearer and more concise
EIN, eatin away exceptions?
You could simplify this a little by using Optional<GlusterStatus> from GlusterStatus.
You could directly use GlusterStatus.UNKNOWN.
You could directly use GlusterStatus.Exception
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists. As long as the compiler can detect perfect lists.
use Arrays.asList(...) for short lists. Same for other places.
Why not just.next(new MkAnswer(container)
Why not just'stars'?
Why do we need this?
suggestion LOG.warn("The amount of the {} should be configured with a {}.", amount);
suggestion LOG.warn("The amount of the {} should be configured with a {}.", amount, e);
suggestion LOG.warn("The amount of the {} should be configured with a {}.", getExternalResourceAmountMap);
Add this logic into the certificatemanagerserviceImpl class.
Add this logic in the certificatemanagerserviceImpl class.
Can you move this logic into the certificatemanagerserviceImpl class?
please log in error
log in error
probably better to log here
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
The logic in lines 37-64 is common between C and C++ and should be moved to VariableInitializerLine.
The logic in lines 37-64 is common between C and C++ and should be moved to VariableInitializerImpl.
How about the following? if (sha256().equals(v)) { hasher.putString(); } else { hasher.putString(); hasher.putString(v, StandardCharsets.UTF_8); hasher.putString(); }
How about the following? if (sha256().equals(v)) { hasher.putString(v, StandardCharsets.UTF_8); hasher.putString()); hasher.putString(values); }
How about the following? if (sha256().equals(v)) { hasher.putString(); } else { hasher.putString(); hasher.putString(v, StandardCharsets.UTF_8); }
Could use org.junit.Assert.fail(String, Throwable) here. It will get rid of the stacktrace
Could use org.jboss.as.controller.operations.common.utils.Constants#LParams instead.
Could use org.junit.Assert.fail(String, Throwable) here
@hkalina The host parameter should always be 'http', so this method doesn't have to be static.
@hkalina The host parameter should always be 'http', so this method should always return true.
@hkalina The host parameter should always be 'http', so this method should always return 0 instead.
Missing final
This seems like it should use a Ds3AnnotationElements for the entries of the list.
This seems like it should use a Ds3AnnotationImpl.
Hmmmm... I just noticed this one Keyword call, and no need to addKeyword() here, because it's pretty much the same way you have below.
Hmmmm... I just noticed this one Keyword call, and no need to addKeyword() here, because it's pretty much the same call that hasKeyword()
Hmmmm... I just noticed this one Keyword call, and no need to addKeyword() here, because it's pretty much the same way you have below. What do you think?
Set this only if session details not null??
Set this only if sessionDetails == null??
Set this only if session details not null?
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Context>, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Context> and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Line, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
Probably want to call TestTransactionToTransaction() here so that the transaction is not available.
Probably want to call TestTransactionToTransaction() here so that the transaction is not committed.
Probably want to call TestTransactionToTransaction() here so that the transaction is not built.
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Suggest adding an assert that the only task name in the list corresponds to the expected number.
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName().
Shall we use this syntax for both getters? suggestion..(this.fieldLocation, fieldName, fieldDesc) && Objects.requireNonNull(fieldLocation, "desc is null");
Shall we use this syntax for both getters? suggestion..(this.fieldLocation, fieldName, fieldDesc) && Objects.requireNonNull(fieldLocation, "desc");
Shall we use this syntax for both getters? suggestion this.desc = checkNotNull(desc, "desc");
This can be replaced with if (logger.isDebugEnabled()) {... } else { logger.debug("Valid signature found in SAML object:"+certificate.toString()); }
This can be replaced with if (logger.isDebugEnabled()) { logger.debug("Valid signature found in SAML object:"+certificate.toString()); } else { Log.debug("Valid signature found in SAML object:"+certificate.toString()); }
This can be replaced with if (logger.isDebugEnabled()) { logger.debug("Valid signature found in SAML object:"+certificate.toString()); } else { throw new RuntimeException("The signature found in SAMLObject "); }
Is it possible to define the variable with a null value? if (instanceParameters[3] == null) { throw new IllegalArgumentException("Credentials must be specified"); } Even if you do this check in line 76, you will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
Is it possible to define the variable with a null value? if ((byte[]) policyParameters[3] == null) { throw new IllegalArgumentException("Credentials must be specified"); } Even if you do this check in line 76, you will return a NullPointerException if (instanceParameters[3] == null)...
Is it possible to define the variable with a null value? if (instanceParameters[3] == null) { throw new IllegalArgumentException("Credentials must be specified"); }
suggestion.stats().loadExceptionCount("loadExceptionRate",
suggestion.stats().loadExceptionCount("loadExceptionRate", name)
suggestion.stats().loadExceptionCount("loadExceptionRate", name, "loadExceptionRate")
You can remove the "!" and just swap the two clauses. You can keep the "!" and just swap the two clauses.
You can remove the "!" and just swap the two clauses. You can keep the "!" and just return quickly with a throw
You can remove the "!" and just swap the two clauses.
typo
why not initialize it in constructor?
why not use it a primitive int?
You should probably use logger.
You should probably use logging here.
You should probably use logging here instead.
minor: you could move result_computedStatistics.getOrDefault(computedStatistics.get(NUMBER_OF_TRUE), (computedStatistics.get(NUMBER_OF_TRUE)
minor: you could move result_computedStatistics.getOrDefault(computedStatistics.get(NUMBER_OF_TRUE), right?
minor: you could move result_size_SIE_IN_BYTES out of the function.
create a log message for this
create a log message for this log.
give a log message for the snapshot id or just the mismatch.
This should be a constant for the toLowerCase (see [anno.fieldValues.names](<LINK_0>
This should be split into two lines.
This should be split into two separate cases.
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}."
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Deleting consumer for {}. (and so on)
This log ends with a period, the corresponding does not.
What do you think about the return value of _ready to _Salesforce_string instead of _ready_.
What do you think about the return value of _ready to _Salesforce_string instead of _ready_?
What do you think about the return value of _ready to _zookeeper instead?
should be a method reference
should go to stream
should be a orElse
Same nesting questions
Same questions as above
Same questions
Not sure about this fix. To me this previous indentation was correct
Not sure about this fix. To me this previous indentation was correct (should be 2 spaces).
Not a fan of this fix. To me this previous indentation was correct
I think you can use log.logEntry1 here instead of log.logList1
I think you can use log.logEntry1 here instead of log.logList.
I think you can use log.logEntry1 here, right?
Maybe we should use a switch statement here?
Maybe we can do something similar to the one above?
Maybe we can do something similar to the String constant above?
Are you sure this can happen? If so, it's a good idea to include this in the url.
Are you sure this can happen? If so, it's a good idea to include this into the url.
Are you sure this is the url that can be equals?
I think we should have setType(ProjectConfigDto) method
I think we should have setType(ProjectConfigDto.class) method
I think we should have setType(ProjectConfigDto dataObject) method
Is it possible to create a setter for planner as well?
Is it possible to create a setter for planner as the parameter?
If we create a setter for planners, we can create a setter for time argument.
I guess you also want to close the stream after you close it as you did before, that should be closed no matter what happens with the finally clause.
I guess you also want to close the stream after you close it as you did before, that should be closed no matter what happens with the finally clause
I guess you also want to close the stream after you close it as you did before, that should be closed.
It is a little dangerous to use PoolFilterBuilder on a new pool, since it is shared between the 2 pools and the pool. Maybe it is better to cache the pools in a field?
It is a little dangerous to use PoolFilterBuilder on a new pool, since it is shared between the 2 pools and the pool. Maybe it is better to cache the pools in a new pool?
It is a little dangerous to use PoolFilterBuilder on a new pool, since it is shared between the 2 pools and the pool. Maybe it is better to use a single command/listener?
This test should also check the saved interval is not zero.
This test should actually check the saved interval is not zero.
This test should also check the saved interval is not null before calling getStart.
Name it to externalize the string
Missing braces.
Missing braces
Do we need to do anything with error handling here?
Do we have to use the new error handling here?
Do we need to do anything with error handling for RuntimeException?
Even though you might want to allow user to specify displayName to be null, I think it should be null (i.e., if displayName.contains(displayName)).
Even though you might want to allow user to specify displayName to be null, I think it's reasonable to allow a default value (with a default value).
Even though you might want to allow user to specify displayName to be null, I think it should be null (i.e. Id)
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. You don't need a separate switch inside the method.
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other places
Here you should check the result metadata first and only if it is not INT
shouldn't this be an error?
shouldn't it be the other way around?
shouldn't it be the same as the query?
Shouldn't this line be inside the for loop? If the is the case insensitive you have to define brackets around if and else.
Shouldn't this line be inside the for loop?
Shouldn't this line be inside the for loop? If we are normalizing and we want to minimize changes for the caller.
This is where the if statement should be for checking the property for allowing for corrected times.
This is where the if statement should be for checking the property for allowing for corrected times. The property is then set, the endValidTime is 0 or false to indicate a clock.
This is where the if statement should be for checking the property for allowing for corrected times. The property is then set, the endValidTime is 0 or false to be a valid value.
BTW you're missing braces in the previous lines.
why don't you throw the exception?
why don't you throw an exception on each task?
encodings?
it's easier to read if you use assertEquals here
it's easier to read if you use assertEquals
This crashes on my device (4.4). It doesn't seem to like SearchView cannot be null. Allowing to do this job.
This crashes on my device (4.4). It doesn't seem to like SearchView cannot be null. I'd suggest putting it in here and on a separate line.
This is unnecessary.
nit: Should use _td_name + _column_
nit: Should use _td_name + _sourceMaxSuffix rather than +
nit: else with the last line.
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel() will not call cancelling() and the refresh won't happen.
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel will not call cancelling anyway, and the job won't start.
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel will not call cancelling even if the job is in the middle of the job.
Lets move this to a different method so that whoever uses this class will always run the thread groups and the test will fail.
Lets move this to a different method so that whoever uses this class will run the thread groups and the test will fail.
Could move this to a different method like createGroups
If you make this new method into this one you could use findById and Collectors.joining directly.
If you make this new method into this one you could use entityType.createId() to create an id.
If you make this new method into this one you could use entityType.createId() to create an id and use it.
If we access the analytics info here, we don't need to track the wpcom user.
If we access the analytics info here, we won't need to track the wpcom user.
If we access the analytics info here, we don't need to track the wpcom sites even if the site is not enabled.
weight += should be available as a static variable, please.
weight += should be available as a static variable, see how getIntervalInterval() does it.
weight += should be available as a static variable, see how getIntervalInterval() does that.
I'm a little confused about this test.. why are we using a different SamLocusIterator?
I'm a little confused about this test.. why are we using a Vector and not a ArrayList?
and this test is identical to the one above except for 1 line.
Let's use generics here and elsewhere in the log message.
Let's use generics here and below...
Let's use KeyExtent to handle the null case
Why is this needed? I think it should be in the other place, right?
Why is this needed? I think the entry and k1 must be in the same order each time the entry is called.
Why do you need to use the entry class?
can we use a StringBuilder here and below instead of a new StringBuilder?
can we use a regular for loop and call previous method each time you call this method?
can we use a regular for loop and call previous method each time equals method is called
why send empty domain?
please remove the explicit set of parameters
Why send null domain?
I think the when would be easier to read if the logic is written as a HashSet suggestion log.trace("Failed to add more data, volume, Request request {}", lor, Request request);
I think the when would be easier to read if the logic is written as a HashSet suggestion log.trace("Failed to add more data, ", lor, future);
I think the when would be clearer to use a HashSet
Why is this change necessary? I don't think we want this to be related to the feature.
Why is this change related to 1.x? I don't think we want this to be related to the feature.
Why is this change related to 1.x? I don't think we want this to be related to 2.x.
Line exceeds limit.
Line exceeds limit, perhaps?
segmentState is always greater than 0?
I think we should set the time to localize() in this class, i.e. only when the trace is active.
I think we should set the time to localize. This is one-time fix.
I think we should set the time to localize() in this class.
Did you use our code formatter? <LINK_0>
I think this should be using the locale of the google search service not available.
I think this should use google.Whitespace.
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Is it possible to have a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on different threads.
Again, here we are using java 8 streams to make sure that potential steam is configured.
Again, here we need to get rid of the for loop as above.
Again, here we are using java 8 streams to make sure that potential simplification is applied
move this below below try block, and put in a continue?
move this below below try block, and put in a continue statement above instead.
move this below below try block, and put in a few try block?
please extract to a separate method
please add new constructor
please extract to a variable
Filter into a DatadogItemListener#onDatadogItemListener#onEntity method
Filter into a DatadogItemListener#onEntity method
Filter into a DatadogItemListener#on
I usually Preconditions.checkNotNull(message.get(message.get())
I usually Preconditions.checkNotNull(message.get())
... and use Objects.firstNonNull()
We should also handle the exception?
We should use the handleResult.getId() at the end of this method?
We should use the handleResult.equals(result) method before throwing the exception
Have you decided against a possible NPE here? If I set propertyString = "value" and propertyString = simulationDescriptorGridModel.getSimulation().getFactMappingByIndex(selectedColumn);
Have you decided against a possible NPE here? If I set propertyString = "value" and propertyString = simulationDescriptorGridModel.getSimulation().getFactMappingByIndex(selectedColumn, propertyString);
Have you decided to use Objects.requireNotNull?
I don't think it's necessary to set the statusFuture to null here. It will throw a NPE in the future, and then you won't need the null check below.
I don't think it's necessary to set the statusFuture to null here. It will throw a NPE in the future, and then you won't have to worry about it.
I don't think it's interesting to see this. The metric is specific to statusFuture, so why are we doing it here?
I think we should make all the tests consistent and make it more clear that each other doesn't accept the same type.
I think we should make all the tests consistent and make it more clear that each other is the GraphBuilder, thoual changes?
I think we should make all the tests consistent and make it more clear that each other is the GraphBuilder, thoual casts etc.
part of the PR?
part of this PR
part of this PR?
Can we log the exception?
Log to lowercase?
Log to lowercase the message.
"belonging" -> "which belong"
"belonged" -> "which belong"
"belonging", "which belong"
IMO, it's better to use the.success() of a boxed type.
IMO, it's better to use the.success() of the QueryException for this case.
IMO getOne("pagination-id") is mutable
also assert the cause attributes
also add an assertion to verify the cause attributes
also add 'Schema'
We could use: TimeUnit.MILLISECONDS.toMicros((K, V) valueSerializer.serialize(topic, serializedValue));
We could use Function.identity() here.
We could use: long timestamp = time.timestamp();
moduleRenderingInstance.get()
moduleRendering.get()
moduleRenderingFactory?
why causeOfDeath is empty?
by registration, since in this
by spec this
It feels weird to have this check in the HTTP_HEADER_NAME constructor. Any way we should make sure that the configuration setting is enabled when it is enabled or not.
It feels weird to have this check in the HTTP_HEADER_NAME constructor. Any way we should make sure that the configuration setting is enabled when it is enabled?
Nit: Space before {
There is no need for this variable here.
There is no need to assign this to a variable
One more empty line
I think this whole if block could be moved up a level by setting the field to null, and we won't have a query parameter anymore.
I think this whole if block could be moved up a level by setting the field to null, and we won't have a query that was updated by this method.
I think this whole if block could be moved up a level by setting the field to null, and we won't have a query that was updated by user.
since it is not a regular expression you should add to the property.
since the second is important then the drop is not necessary anymore.
since it is not a regular expression you should add to the else clause
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
This is not needed. In super.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8.8" address. Can you also include the 8.8.8.8.8.8.8.8.8.8.8.8.8.8" address?
This is not needed. In super.tearDown(), all of the replaced stuffs are restored automatically.
what if the acl is not found? we should skip metadata update in this case and return false?
what if the acl was not found? we should skip metadata update in this case and return false?
what if no acl is found? we should skip metadata update in this case and return false?
Please consider making this more explicit (the check for lines YOU_ARE_OP)
Please consider making this more explicit (the check for lines YOU_ARE_OP_ARE_OP) to be consistent with the rest of the commands.
Please consider making this more explicit (the check for lines YOU_ARE_OP_ARE_OP)
Wouldn't this have two minutes?
Wouldn't this have two minutes? I think the day activity should take into account this week.
Wouldn't this have two minutes? Long term, dayActivity -> weekActivity.toLocalDate() similar to figure out whether an day is given or not.
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
DANGER WILL ROBINSON, DANGER! Is the password really passed as an URL parameter? Any proxy on the way could record your password. Please check whether the URL is a URL or URL?
No need to assign
It would be good to make this a constant.
It would be good to make this a static constant.
It would be good to do this in the check chain.
rename contributorId
rename to extensionPoint
rename to extensionPointId
You can use a regex for the method to do this: <LINK_0>
You can use a Matcher here and re-use it. It seems like this will be easier to read.
You can use a Matcher here and re-use it. It seems like this should be false by default.
Thanks for digging into this. Just one thing: I think this can be simplified as follows: java final CallbackGroup cb = new CallbackGroup();
Thanks for digging into this. Just one thing: now I think this can be simplified as follows: java final CallbackGroup cb = new CallbackGroup();
Thanks for digging in to the cause.
This looks a bit strange to me
This string should be refactored to 'String', '.
This string should be refactored to 'String'.
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two places.
Consider adding an additional layer of abstraction for this block
should be: model.isSetSsh() || model.getSsh().getPort()
should be: model.setSsh(model.getSsh().getHost(), model.getSsh().get())
should be: model.setSsh(model.getSsh().getHost(), model.getSsh().getPort());
Isn't it better to use a constant for all the cases now?
please move this to the sHUB_target class.
please move this to the sHUB_target class, so the same in is the same.
Unable to build custom properties.
getBuildTimestamp() can be null
getBuildTimestamp
@jffdutyb I think we should handle this case as a fallthrough of the code
@jffdutyb I think we should handle this case as a fallthrough of the code :)
I think we should put this check in the karaf module instead of hard coding it. Or even better, have it be a separate one?
Needs to be removed.
Leftover debug statement?
Missing linter
use a constant
use a log
use a constant instead of the hardcoded name
System.out.println("...... and path id (optional).......
System.out.println("......... and path id (optional).......
System.out.println("...... and path id (optional)..........
Is this attempting to connect to any existing cached configuration?
Is this logging necessary?
Isn't this the same as the new configuration?
I think it's more efficient to use a boolean for the candidate to just use a switch statement here.
I think it's more efficient to use a boolean for the candidate to just use a switch statement to reduce nesting.
I think it's more efficient to use a boolean for the candidate to just a switch statement.
it would fit easily one line
it would fit easily one level
it would fit easily one statement
Perhaps we should add a new logging statement to distinguish between these two cases: - a new proxy is created - the proxy is activated after passivation
Perhaps we should add a new logging statement to distinguish between these two cases: - a new proxy is created - the proxy is created - the proxy is activated after passivation
Perhaps we should add a new logging statement to distinguish from these two cases: - a new proxy is created - the proxy is activated after passivation
How do you feel about your implementation of this method? It seems that you just throw an exception, right?
How do you feel about your implementation of this method?
How do you feel about you to use this as an argument?
I would move this inside the if (send || timeoutException == null) { throw new TimeoutException("Test failure message was %s ms", elapsed, ms); } and remove this block.
I would move this inside the if (send || timeoutException == null) { throw new TimeoutException("Test failure message was %s ms", elapsed); } and the other one should be the same.
I would move this inside the if (send || timeoutException == null) block.
This should be wrapped in a new method.
This should be in a new method.
This should be wrapped in a try-catch block.
We should probably log this somewhere in this method.
why we need this special case?
Should we throw a RuntimeException if this occurs?
Unneeded empty line here.
Any reason to use DiscussionUtils.isNullOrEmpty() here?
Any reason to use DiscussionThread.of() here?
I think this is unused.
I think this is a non-zero edge to be used.
I think this is also possible the NO_ID constant.
rename to 'Installed' or 'fatal'.
rename to 'Installed' or 'fatal'
rename to 'Installed' or 'fatal',
I think this field were in seconds, shouldn't it be here?
I think this field were in seconds, shouldn't it be static from updaterDevice?
I think this field were in seconds, shouldn't it be marked here as well?
please use this instead: this.advanced = (CommonUtils.TMENDRSCAN)?
please use this instead: this.advanced = (CommonUtils.this) or even in that case.
please use this instead.
Objects.requireNonNull(file, "File already exists");
I know this is a code, but I guess it's not a good idea to throw an error here.
I know this is a code, but I guess it's not a good idea to throw an exception here.
This can simplify this method to: while (true) { viewToHighlight.getHighlight().add(mHighlightHighlightHighlight()); viewToHighlight.setHighlightOnHighlight(); } What do you think?
This can simplify this method to: while (true) { viewToHighlight.getOverlay().add(mHighlightHighlight()); viewToHighlight.getHighlight(); }
For clarity it'd be nicer to have this method return boolean and store the view in a field
can we use lambda expression in the common way (e.g. getRegistryAccounts())
can we use lambda function here?
can we use lambda expression in registryAccountObservable.e.g. addEditor(String containerName)?
I think this could be replaced by a org.apache.commons.lang3.CharacterUtils.toString('\n');
I think this could be replaced by a org.apache.commons.lang3.StringUtils.isEmpty(record) here.
I think this could be replaced by a org.apache.commons.lang3.CharacterUtils.append('\n');
It seems like this filters were added to the right package. It's only used for this test.
It seems like this filters were added to the right package. There would be a unit test for this to test this.
It seems like this filters were added to the right package. There would be a few issues with this change.
I think this can be simplified to: java switch (metadata.getOperatorType().isPresent()) { case metadata.getOperatorType().isPresent(): return metadata.getOperatorType().isPresent(); }
else { return new FunctionMetadata( metadata.getOperatorType(), metadata.getFunctionKind(), metadata.getReturnType(), metadata.isCalledOnNullInput()); }
else { return new FunctionMetadata( metadata.getOperatorType(), metadata.getReturnType(), metadata.isCalledOnNullInput()); }
Not sure about this. It's the right way to hash a hasher. We don't really have to create a new hash map with the same hasher's hasher. The hasher is mutable in the hash code, and we're creating a new hash map for each hash table. So better use something like hash.equals(hasher.get()) or something.
Not sure about this. It's the right way to hash a hasher. We don't really have to create a new hash map with the same hasher's hasher. The hasher is mutable in the hash code, and we're creating a new hash object for each hasher.
Not sure about this. It's the right way to hash a hasher. We don't really need hasher and hasher here.
nit: assertThat(responsesize).hasSize(1);
nit: assertThat(responsesize).contains(1);
nit: assertThat(responsesize).hasSize(1)
Doesn't the setup method need to be synchronized?
On the setup, the communityId should be set to null. I suggest we can use the non null value here.
Doesn't the setup method need to be synchronised?
You don't need it in every Exception since you have a finally clause that will get executed at the end.
You don't need it in every Exception since you have a finally block that will get executed at the end.
You don't need it in each Exception since you have a finally clause that will get executed at the end.
Can you factor out ps.get(db, patchSet) into a variable? I think it would be better than to have it in 3 places now.
Can't you get the name of the author like this: ps.stream().map(db, p -> patchSet.get(db, patchSet)).collect(Collectors.toList());?
Can't you get the name of the author like this: ps.stream().map(db, p -> patchSet.get(db, patchSet)).collect(Collectors.toList());
This should be spacing(?)
This should be spacing.
This should be space. The space character is between the {.
I think you can use assertFalse here instead of size comparison
I think you can use assertEquals(List.of(new ArrayList<>()) here.
I think you can use assertFalse here instead of assertEquals
Should we use isNotBlank() for this parameter?
Should we use isBlank() as well?
Should we be using isBlank?
Is this really needed?
Is this really needed? There isn't any exception thrown in createGroup.
Is this really needed? There isn't any exception thrown from createGroupUnion method.
Will this cause a new config value? If not, it doesn't look like it'll be useful.
Revert this change?
Will it be needed to move this line?
There is a singleton for OK Status: Status.OK_STATUS
There is a singleton for OK Status.OK_STATUS
There is a singleton for OK Status: OK
If mReader is null, this should probably be private to ensure the writer is closed too.
If mReader is null, don't we need to check for the CSV format? Why not use the schema name directly?
If mReader is null, this should probably be private to ensure the writer is always initialized.
Couldn't it be List<String>?
Couldn't it be List<String>
Couldn't it be List<String>.
Use Timber.v
Use Timber class to throw exceptions
Use Timber, not 'o'.
The last question about maintaining type information would be to avoid maintaining type information.
The last question about maintaining type information doesn't seem to be useful.
The last question about maintaining type information would be to avoid maintaining object large.
There is a method, org.eclipse.emf.ui.search.util.UserHelper.close
Do you really need to read _x_ of a field here?
We could extract a method for this case.
I don't like this design. It is just going to work as-is, but it is just a code smell. I think we can just call this method directly.
I don't like this design. It is just going to be a lot of trouble to let users know that this is going to work with. I think we can just let it throw an exception here.
I don't like this design. It is just going to be a lot of trouble to let users know that this is going to work with. I think we can just let it throw an exception here?
nit: ByteString startQualifier = ByteString.toLower();
nit: ByteString startQualifier = ByteString.toInt(startQualifier);
nit: ByteString startQualifier = ByteString.toIntExact(filter);
I think it's useful to remove the /.getChannel()/getJavaFile()/
I think it's useful to remove the /.getChannel()/getJavaFile(), and just use "rw.limit". This will remove the need for the clear.
I think it's useful to remove the /.getChannel()/getJavaFile(), and just remove the need for the new index.
Just a heads up: We can do the following: if (TextUtils.isEmpty(widget)) { updateIfNotShowing(true); } else { updateHasOnSavePostAsync(this, event); }
Just a heads up: We can do the following: if (TextUtils.isEmpty(widget)) { updateIfNotHandled(true, false); } else { updateHasOnSavePostAsync(this, event); }
Just a heads up: We can do the following: updateAddingMediaToEditor(false) -> { if (TextUtils.isEmpty(mViewModel.getOnSave()) { updateIfNotShowing(true); } else { showIfNotHandled(false, 0); } }
reuse DfsBlockCacheConfig.setBlockSize()
missing braces, change this only for newCountersSource(...)
nit: missing braces, since a while we're here
Shall we use getBytes() here?
This is redundant.
Spacing.
Can't the following two lines be extracted to a method and reused?
Can't the following two be assertFalse?
Can you extract to a different method and call it in a few places?
remove System.out.println
remove System.out.println statements.
remove system.out.println
This identation is odd, but you can use {} to wrap statements.
This code is strange, use {} to wrap the 'else' statement
This code is strange, but you can use {} to wrap it
This can be static variable, so I don't think it's worth changing it.
This can be static variable, so I don't think it's worth declaring it as a variable.
This can be reduced to debug
no need for this local variable.
no need of this local variable.
no need of this local variable (symbol is already a field).
This is wrong. Extra line can be removed.
This is wrong, Extra line needed.
This is wrong,'message' can be changed to 'this'. 'Change-Id'.
do we need a try/catch here?
do we need a new exception here? If we are not using a BackOff with the BackOff constructor, we can safely remove this line and straight away.
do we need a new exception here? If we are not using a BackOff with the BackOff constructor, we can safely remove this statement and the while condition
Can be written as a single line: final List<String> acsModeledSegment = new ArrayList<>();
Can be written as a single predicate on the list.
Can be written as a single line: final List<String> acsModeledSegment = new ArrayList<>(outFile.toNics().size());
Is it possible to assert that instanceDesc is not null?
Can't we keep this test the same as it used above?
Can't we keep this constructor that takes the instanceDesc and getOnlyElement()?
I think you can replace this with something like: java combined.addAll(Math.max(a, extra))
nit: missing space around 'for'
nit: missing space around =
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_2>
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_1>
style nit: no braces here
redundant null check
redundant check
line ------- and equalTo
line ------- and 240
line -------.
I'm not a big fan of calling setUp() and try-finally blocks, in the end we should have a state that occurs in the database, before each user calls this method. Could be abstracted out to a method in database, here.
I'm not a big fan of calling setUp() and try-finally blocks, in the end we should have a state that occurs in the database, before each user calls this method. Could be abstracted out to a method with this name.
I'm not a big fan of calling setUp() and try-finally blocks, in the end we should have to do the job.
Spacing is off.
Why are we checking if the instance is opaqueUser above?
Why are we calling this twice?
Instead of creating a couple of extra Timestamp objects, move this outside the loop
Instead of creating a couple of extra Timestamp objects, move this outside the if statement and just return true.
Instead of creating a new Timestamp object, move this outside the loop
I think you meant to use MorePredicates.transform(...) here
I think you meant to use MoreObjects.transform here.
I think you meant to use MorePredicates.transform here
Minor detail but this could be handled within the if-else statement.
Minor detail but this could be changed a bit the same as in superClass (page) below.
Minor detail but this could be changed a bit the same as in superClass (page) tree.symbol().get(id) below.
This could be public.
This could be static.
This might need to be public.
What is the reason for this change?
Are you sure you could change this to return an error?
Are you sure you could change this to return an error or warning?
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
Nit: wouldn't it make sense to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits there.
This is not a good place for the change.
This is not a good idea.
This is not correct.
lang.Character is not used
lang. name could be misleading
lang.isEmpty()
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
nit: The mocked environment creates 3 nodes (by default) that you can use so we don't have to create them. You can get them with env.getCluster().nodeById(..).
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..)).
If you're at it you can remove the extraneous space at the end of line
If you're at it you can remove the isNotLocal property, the code will never get here.
If you're at it you can remove the isNotLocal property, the code is not needed (the check above can be removed).
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Isn't this the number of mappers? Can the reducer get it instead and compare with that?
Isn't this the number of mappers? How do you know if it is a lot?
Minor: can you use simple.map(e -> e.getKey().stream() / numberOfTasks;) instead of.map(e -> e.getKey()).orElse(null)?
Minor: can you use simple.map(e -> e.getKey().getSamzaContainerContext().taskNames()) instead of duplicating the code?
Minor: we can use member variables for clarity here.
Would be nice to print the duration too, so we can find a way to run environmentd lines every time.
Would be nice to print the duration too, so we can still get the amount of time on the dump.
Would be nice to print the duration too, so we can find a way to run environmentd lines if the scheduler was executed.
Check for null
Missing null check on library
Missing white space after if
Null check required?
Maybe throw RuntimeException?
Maybe throw RuntimeException instead?
Should this be defined as a class field? Also, should it be defined as a class field?
Should this be defined in a @Before or method?
Should this be defined in a @Before or test in other class?
isEmpty
Delete the second point
isEmpty()
You may want to log the folder.exists() here.
The folder.exists() check is redundant.
You may want to log the folder.exists() check here.
Hi [1] [1] <LINK_0> [1] <LINK_1>
Hi [1] [1] <LINK_0> [1] <LINK_1> [1] <LINK_2> > The following code needs to be duplicated in [1] <LINK_0>
Hi Nick, Thanks for the patch! However, I'm not convinced that is a good solution for the regex :D
You can chain this nicer
This too
StringBuilder
Should this use a try { } finally? Otherwise other Throwables leak.
Should this use a try finally? Otherwise other Throwables leak.
Should this use a try catch block? Otherwise other Throwables leak.
why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicId + ":v" for schema registry to work with
Why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicId + ":v" for schema registry to work with
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
Perhaps we want to asserts with.equals("2000")?
Perhaps we want to assert only that query is expected to be non-null?
Perhaps we want to assert only that query is frozen?
Shall we use the constant - APILifeCycleState.PROTOTYPED here?
does it mean that CM returns an APILifeCycleState?
Shall we use the constant - APILifeCycleState.PROTOTYPED.equals(...)
According to this version, I would prefer to use the [try-with-resources](<LINK_0> syntax here.
According to this version, I would prefer to use the [try-with-resources](<LINK_0> syntax.
looks like you can use response.get(0) instead of creating a new byte array.
setBot
setBot should make final
set True -> setAtSkipResult
you could do this in a more neat way by replacing the whole if with brackets: if (f!= null) { //NON-NLS-1 }
elements.isEmpty()
you can declare this variable inside the if, so you don't have to pass it twice
A method should return true if the actionMode is null
A method that should return true if the actionMode is null
A method should return boolean
Should status.pollCountInWindow() be a variable?
Should status.pollCountInWindowCount be a variable?
Should we set status.getWaitTimeInWindow().compareTo(status) to 0) here instead?
This seems like a simple merge. Is there any reason we cannot cache the span?
This seems like a simple merge. Is there any reason we only need the spanRef provided to the span?
This seems like a simple merge. Is there any reason we only need the spanRef provided to this?
Do we need this String.split() here?
Do we need to log this exception since it seems to be a client error?
Do we need this log statement anymore?
If you are in Java 8, it is nicer to use.then.
If you are in Java 8, it is nicer to use.then() on the next line.
If you are in Java 8, it is nicer to use.then().
Cosmetic: You should create a variable for the default name and use the constant in the loop.
extract this into a variable
final
This could be refactored to something like :withHeader(now().minusDays(1)); URL.withHeader(Constants.ACCEPT_JSON)
This test doesn't make sense if the real value is accepted. Can you rename it to something more specific?
This could be refactored in a test
I am wondering if we should keep exchange here.
I am wondering if we should keep this method unchanged.
I am wondering if we should keep this method as 'write'?
Similarly here; you can use the Const.ParamsNames.ENTITY_TYPE + "email" + emailType.
Similarly here; you can use the Const.ParamsNames.ENTITY_TYPE.equals(emailType) instead.
Similarly here; you can use the Const.ParamsNames.ENTITY_TYPE)?
please rename to performOpenColorPickerView
please rename to performOpenColorPickerView please
please extract to a constant
please have a check for the standard library functions of the map
does it mean we're using ContentMappedByType for this map? Will this send well?
please have a check for the standard variable name
Could this check be combined with the one above?
Could this line be simplified to final String key = contextClassLoader.getResource(classpathResource.length() - 1);
Could this check be simplified to final String key = contextClassLoader.getResource(classpathResource.length() - 1);
I think this should be publishEvent
I think this should be WARN instead of ERROR.
The change looks good.
Does it make sense to check clusterParticipant!= null?
why do we need this check? Is it really needed?
Does it make sense to check clusterParticipant!= null? Do we need it?
I don't think this code is needed, since in.line() is the same as in HttpConnection
I don't think this code is needed, since in.line() is the same as in HttpSupport.java.
I don't think this code is needed, since in.line() is the overridden method
Can you make this a constant?
Can you make this an internal constant.
Can you make this a constant.
I don't think you need to use UNKNOWN as the default can be null here.
nit: you can use StringUtils.isNotEmpty
I don't think you need to use UNKNOWN as the default address to the user's key.
I don't think we need to change this class. How about just KVSerde.from(sourceName)?
I don't think we need to change this class. How about just KVSerde?
How about "KVSerde" for sourceName?
I'd say just add the flag into the add() call.
I'd say just add..else to the if.
I'd say just add the flag into the add() method.
Why do you not use DRepresentationDecorator here?
Why do you not use disposeStatus() in the synchronized block?
Why do you not use disposeStatus() in the refresh?
You can also remove the try-catch and just write a test that verifies the email is valid.
You can also remove the study-level account.
You can also remove the try-catch and simply adding a string here?
The call to closeInputStream is redundant here.
The call to closeInputStream is redundant. This code doesn't seem necessary.
call to closeInputStream is redundant with the if statement below
libraries should be reported in version param.
I think warn is more appropriate here.
maybe use warn?
The repository name here is a bit confusing. I'm not sure why its needed here.
The repository name here is a bit confusing. I'm not sure what the job is here.
The repository name should be a constant.
you can use Schema's isNullable and getNonNullable methods to help out here.
you can use Schema's isConfiguration.Type.STRING
you can use Schema's isClass and getStages()
I'm not sure this can be simplified. Why put the handler inside the if?
I'm not sure this can be simplified. Why put the handler in a method?
I'd rather put the handler inside a method like this:'return handler!= null'?
Instead of assertNotNull(...), you should use AddressUtil.getAddressHolder instead.
Instead of assertNotNull(address, Address.class.getPort(), address.getHost(), address.getPort(), address.getPort());
Instead of assertNotNull(...), you should use AddressUtil.getAddressHolder() to get the address.
if it existed in containers, is it not sufficient?
If it existed in containers, is it not sufficient?
if it existed in containers, is it not sufficient? So we can skip it?
NaN if outputRowCount is 0
NaN?
NaN
do we have to sleep for 5 seconds here?
do we need to have this print to stdout?
do we need to have this print to console?
Use parameterized logging instead of string concatenation.
Use parameterized logging LOG.warn("Deleting entry log size: {}", entryLogId, e);
Use parameterized logging LOG.warn("Deleting entry log size: {}", entryLogId, meta);
This condition is too long, so you should use a variable jcrPath instead of the jcrPath
This condition is too long, please use a separate block
This condition is too long, so you should use a variable jcrPath instead
Minor: you can use try-with-resources
why catch two exceptions and exception?
Minor: you can use try/catch
Wouldn't it be easier to assert a data type here that is int & a bug in the CF?
Wouldn't it be easier to assert a data type here that we don't assert anything?
Wouldn't it be easier to assert a data type here that is int & a bug in the CF.
When e.getMessage() is null, is there a chance the message can be null?
When e.getMessage() is null, is there a chance the message could be null?
When e.getMessage() is null, you will get an NPE.
I'm not sure what we want to do. Why don't we do a null check here?
I'm a bit worried about this test for null. What if the value isn't null?
I'm a bit worried about this test for null. What if the value isn't null? We can't handle nulls here.
why couldn't we return results before the analysis is completed?
again, I don't think this is the right place to return.
again, I don't think we need the return?
This seems to be the same as
This looks a bit strange?
This probably would be better using the same message mechanism
Please test for null, it doesn't need to be fixed
Please test for null, it doesn't need to be fixed or empty
Please keep the original code.
Instead of having hardcoded text here, should we use show AdvancedActivity instead?
Instead of having hardcoded text here, should we use getText instead?
Please add a space before the if.
Why do we need it here? ModeUtils.prettyPrint(whoColor).
Why do we need to store it in the ModeUtils?
Why do we need the "public" modifier? Ops is in the wrong place.
final?
final and reverts the change below too
final and inline below
This doesn't make sense as an else if.
This doesn't seem right. Can you make this a warn level?
This doesn't seem right. Can you make this a println() method?
Lets break this up into a method in parkedOffset, basically where it was interrupted (which is really a case I see.)
Lets break this up into a method in parkedOffset, basically where it was false when we checked (i.e., waitedOffset, then.)
Lets break this up into a method with descriptive names.
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
Shouldn't the exception bubble up if the expression is not found? Fail fast fail hard!
Shouldn't this exception bubble up in these cases? Fail fast fail hard!
getLocation can return null and we should be sure it is of length 0.
In Druid, we use "/" and / for path separator
getLocation can return null and we should handle it.
If we want to be sure that directory does not exist, should we delete this directory?
If we want to be sure that directory does not exist, should we delete it?
If this assertion fails below, can we make sure the action is executed after the deleteRecursive?
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == true
The new code is unnecessary if isSequenceElement == false
Hm, correct me if I'm wrong. The rationale is that if the enum is not set, than the code needs to be flipped. I don't see why it is necessary.
Hm, correct me if I'm wrong. The rationale is that if the enum is null, the code needs to be updated.
Hm, correct me if I'm wrong. The rationale is that if the enum is not set, than the code needs to be flipped. I don't see why it needs to be flipped.
This should be logged here instead of e.printStackTrace();
This should be logged here instead of e.printStackTrace()
This should be logged or removed
This log seems to be in an else block and there's a typo.
This log seems to be in an else block.
This kind of logging seems off
Why not change the type to 'hosts', instead of this.
Why not change the type to 'hosts', instead of the above line?
Please change the wording
Any reason why 'file.getName()' was changed to just 'name'?
Any reason to reduce duplication?
More descriptive names
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the callbackId being null).
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the callback method.
style nit: no braces around single line block
style nit: no braces around single line blocks
style nit: missing braces around single line blocks
This looks wrong - we are creating a new instance of BraveResourceIdentifier on both sides of this class, so not really sure why we need to cache the resource at all. Could this be a no-op?
This looks wrong - we are creating a new instance of BraveResourceIdentifier on both sides of this class, so not really sure why we need to cache it?
This looks wrong - we are creating a new instance of BMT here. Could you not reuse the same instance?
If blobName is not used, then getMessage() will return an exception. Should we use the same message here?
If blobName or blobName is not used, then getMessage() will return an exception. Should we use the same message here?
If blobName or blobName is not used, then getMessage() will return an empty string. Could you add getName() to the logger?
Is this part of the issue?
Is this part of the issue? Can we have a more descriptive name?
Is this part of the issue? Can we have a more descriptive variable name?
We don't print to System.out here, use a logger instead.
We don't print to System.out here - use a logger instead.
We don't print to System.out here - use LOG.
Did you check for this case? I don't think we can support this feature.
Did you check for this case? I don't think we need to retry in this case.
Did you check for this case? I don't think we can support file length on the buffer length.
this should be done only if the user is created with permissions, right?
this should be done only if the user is created with permission, right?
this is called from two places. right?
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm fine with the null value as default and would prefer an instance of a default class.
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment).
Perhaps we want to provide the actual response status code in the constructor so we don't have to do it here.
Perhaps we want to provide the actual response status code in the constructor so we don't have to do it twice?
Perhaps we want to provide the actual response status code in the constructor so we can log it for now.
If m_esAdvertisedGerAdvertisedGerAdvertisedGerAdvertisedGiverDone() is true, then m_es1 will always be true.
If m_esAdvertisedGerAdvertisedGerAdvertisedGiverDone() is true, then m_es1 will always be true.
If m_esAdvertisedGerAdvertisedGerAdvertisedGerAdvertisedGiverDone() is true, then m_es1 will always be false.
Would be nice to make this the same as startFailedOnStoreCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessSequence and move it to the constructor as well.
Would be nice to make this the same as startFailedOnStoreCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessSequence and move it to the constructor?
Would be nice to make this the same as startFailedOnStoreCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessCopyProcessSequence and move it to the constructor?
Same here, defaulting to zero.
Same line.
Same as above.
I'm not sure this message is accurate. In the end it's finWorkload.getNumBlocks() > 0), but it's only updated on success. It's better to use %s instead of concatenation.
I'm not sure this message is accurate. In the end it's finWorkload.getNumBlocks() > 0), but it's only updated on success. It's better to use %s.
I'm not sure this message is accurate. In the end it's finWorkload.
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if 'general' config
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its DC is set.
u can use Util.isTemplate
u can use Util.isSet
u can use 'isTemplate'
This (the whole method) could keep the same indentation char.
This (the whole method) could keep a couple of indentation issues.
Generally we only add final when really needed.
please move with Parameter
please move to Parameter
please move with ParameterFormatter
this validation is not required, no?
this logic is not correct, please remove
this logic is not correct, please remove.
I think it is a bad idea to catch an exception here. What is the reason for it?
I think we should avoid catching an exception here. If bridgeHandler == null it should probably be an instance of bridgeHandler (like other trace handler implementation)
I think it is a bad idea to catch an exception here. What is the reason for catching an exception?
We do the same ternary operator above - how about breaking this out into a seperate function.
We do the same ternary operator above - how about breaking this out into an seperate function.
We do the same ternary operator above - how about breaking this out into a seperate method.
isConnected() would be appropriate here.
isConnected() called set().
isConnected() would be appropriate here, as well.
This class has a bug with the merge conflicts. Let's put it back in a separate commit.
This string should be added to the new line
This string should be added to the merge file.
We can use return type here as well, otherwise we will block extra code for InputFormat.
We can use return type here as well.
We can use return type here as well, otherwise we will block extra code for getInputFormat().
I would use AsyncServiceTest.assertInCodedReasonNonCodedReasonNonCoded here too
I would use AsyncServiceTest.assertInCodedReasonNonCodedReasonNonCoded here
I would use AsyncServiceTest.assertInCodedReasonNonCodedReasonNonCodedReason(...) instead
Not necessary with the group name, since the layout no longer has anymore the columns.
The default should be always true. The color settings show up to the user.
Not necessary with the group name, since the layout no longer has anymore.
Could we please move this into a finally block?
Could we have an API that does this? I think this method does not get called until the server is connected.
What does this method do? I think we have to update a File as well.
Can you make this a constant?
Can you make this a constant for the left and lower case? like ff.literal(1) (dimension, ff.literal(0));
Can you make this a constant for the left case?
Given we are doing multiple things at once I would prefer: final Programmer@4induction = new Programmer{4induction}); final Programmer{nick='faxternity'}"
Given we are doing multiple things at once I would prefer: final Programmer@4induction = new Programmer{4induction}); final Programmer@4induction =...
Given we are doing multiple things at once I would prefer: final Programmer@4induction = new Programmer(4induction, "))); final Programmer@4induction =...
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously so we can try to simplify it)
I am just wondering whether this snippet should not be surrounded by try-with-resources
Why does this return a boolean?
Why 5?
Why would you return a boolean?
Your question is badly phrased. 1. You do a WARNING, but you'll probably want to at least log the exception. 2. If the file fails and you won't know what happened, it needs to be fixed. E.g. 2. Swift. I'm not sure that's a problem (e.g. WARNING, not SEVERE)
Your question is badly phrased. 1. You do a WARNING, but you'll probably want to at least log the exception. 2. If the file fails and you won't know what happened, it needs to be fixed. E.g. 2. Swift. I'm not sure that's a problem (e.g. slackFileRequest): 2. You know that if I provide a warning logging, then you'll need a warning here and in the code below. I don't think it's a good idea to log it in a warning. E.g. "Error closing HttpClient for current execution" instead. You can use WARNING level for things like this.
You don't really need this warning here, as it's only a warning
could you extract body of this into a helper method?
maybe extract url for this.
could you extract constant?
IIUC this code was also inherited but it might be clearer to move this block to a helper class.
IIUC this code was also inherited but it might be clearer to move this block to a helper, e.g...
IIUC this code was also inherited but it might be clearer to move this block to a helper, e.g... (to avoid duplication of this block)
Nitpick: remove this
Nitpick: prefer empty map.
We need to test the state in every test case.
Maybe we should move this to warn level?
Maybe we should move this to enrichmentDispatcher instead?
Maybe we should make it warn here.
Would it be possible to assert the result of the component as well?
Would it be possible to assert the result of the component is null?
component is a mandatory variable.
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Replace this use of the enclosing if statement. [![rule](<LINK_2>](<LINK_0>
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Replace this use of the enclosing if condition. [![rule](<LINK_2>](<LINK_0>
I wonder if using a self-sorting list here would not be the better solution.
I thought this was only ever called when mMenuId is null?
I thought this was only ever called when mMenuId == NONE?
I thought this was supposed to be changed to mMenuId == NONE
kryoAndEdges may be null
kryoAndEdges may be not available on constructor.
kryoAndEdges may be not available on file level
initialize this variable at declaration.
initialize this variable in declaration and assignment it.
initialize this variable in declaration and assignment
suggestion float xmin = ((xmax >= x) && ymin <= x && ymin < x && ymax < x && ymax < x && ymin < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax <
suggestion float xmin = ((xmax >= x) && ymin <= x && ymin < x && ymax < x && ymin < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax <
suggestion float xmin = ((xmax >= x) && ymin <= x && ymin < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax < x && ymax <
TerminalPlayer#getHandle returns an empty list, which is interpreted as a view in a background thread
TerminalPlayer#getHandle returns an empty list, which is interpreted as a view in the background thread
TerminalPlayer#getHandle returns an empty list, which is interpreted as a view in the session
Wondering if we should throw a TechnicalException here. Something like the below would be better.
Wondering if we should catch a more specific exception here?
Wondering if we should catch a more specific exception here. For example, if it may be null (didn't provided), authorized user with a clear message.
why are you destroying the user? I think it would be better to assert that the user has actually been removed from the DB
why are you removing the final list?
why are you destroying the user?
Do we need a switch here?
Do we want to have a translation from here?
Do we want to have a switch here?
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we can make a followup change. :)
1. Should this be continue? If not, if the 2nd parent is not uninteresting but the 3rd parent is, the 3rd parent won't get added. 2. Put braces around single-line "if" statements [1]. [1] <LINK_0>
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
ugh again..
System.out/err?
System.get()
Just want to make sure: do you really want to create a string with byte[] instead of byte[]?
Just want to make sure: do you really want to create a string with byte[] instead of double[]?
Just want to make sure: do you really want to create a string with byte[] instead of String?
There is only one usage of the query: select "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_uuid=u.id and gu.group_uuid=?)"
There is only one usage of the query: "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_uuid=u.id and gu.group_uuid=u.id=?)
There is only one usage of the query: select gu.organization_uuid and gu.group_uuid.name=? AND NOT EXISTS
Isn't this missing a check for delegate.getPreparing()?
Isn't this missing an assert...?
Isn't this missing a check for delegate.getOrElseGet()?
I would suggest to correct the code flow of line 160.
I would suggest to correct the code block in line 175 and 176.
I would suggest to correct the code flow.
why is the lower bound 0? Should it not be at least 1?
why are the lower bound 0? Should it not be at least 1?
why is this required? Should it not be at least 1?
Let's explicitly check whether numBlockOwnershipByEvalIdForServer is empty. Same for storeServerMetrics().
Let's explicitly check whether numBlockOwnershipByEvalIdForServer == numDataBlocksOnServer. Same for storeServerMetrics().
Let's explicitly check whether numBlockOwnershipByEvalIdForServer == numDataBlocks.get(serverId) is null.
Do we need to cast it to AppSearchProxy?
Do we need to cast it to AppSearchBanner?
This cast does not seem necessary.
This should probably be instanceof Handler instead.
This error message is incomplete. I think we should make a constant for this.
This error message is incomplete. I think we should make a constant for this. Context == null?
There seems to be a leak between these error messages. Might be better to log it.
Any particular reason for logging the error message instead of it?
There seems to be a leak between these error messages.
I'd like to move this into utils package/util.
I'd like to move this into utils class so it may be easier to read.
I'd like to move this into utils class so it may be easier to read/understand
Please use ServerWizard.finish(wizardDialog.finish()); instead of testing whether it is failing.
Please use ServerWizard.finish(wizardDialog.finish()); instead of test for assertion
Please use message to the fail method.
This log message has to be removed before sending any instances
This log message has many parameters and it isn't supported. Please remove it.
This log message is too specific to the place it should be removed. This will give you very little information as you can now iterate over all of them.
why clone()? just not use getVm().getstatus
why clone()?
why clone()? just not use getStoragePoolId()
It would be nice to test that connectionFactory createConnectionFactory can never return null in the test, instead of catching it there.
It would be nice to put fail(amqpConnectionManager.class) in the test, instead of try/catch block.
It would be nice to test that connectionFactory createConnectionFactory can never return null.
I am not sure if there is a need to add orderingMap.put(...) with DEFAULT_ORDERING here since it is the default value.
I am not sure if there is a need to add orderingMap.put(...) with DEFAULT_ORDERING_WEB_BOOKMARK" where it is used
I am not sure how to put all the ordering objects here, maybe I believe.
extra space
I think that we should not catch Exception here as it is a subclass of RuntimeException
I think it is not enough to create a new registry.
This refresh call should be done inside the refresh() method.
This refresh call should be done inside the refresh() method. It is a little confusing. Why not do it inside the refresh() call?
This refresh call should be done inside the refresh() method. It is a little confusing. Why do we need to refresh the project here?
You can extract this into a separate method.
You can extract this into a separate JSON file.
You can put them into a separate line.
![MINOR](<LINK_1> 'Severity: MINOR') Split this 183 characters long line (which is greater than 150 authorized). [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "setCredentialAccountTypes.getCredentialRequestCodes.INTERVAL_START_FLOW". [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "setCredentialAccountTypes.getCredentialRequest().isExpate". [![rule](<LINK_1>](<LINK_0>
Please use the JUnit's logger instead of System.out.
Please use either Class<? extends Application> or String.format() :(
Please use either Class<? extends Application> or String. This is not a huge amount of time.
Is this semantically correct? Why do we need to get a CaptureResponse, and a FutureResource to return it?
Is this semantically correct? Why do we need to get a CaptureResponse, and a ListenableFuture<Void> when it's null?
Is this semantically correct? Why do we need to use AsyncFunction.identity()?
I would do that in this case. After doing this, we will set globalEnvVars to empty list.
I would do that in this case. After doing this, we would not have empty array list in the hash map.
I would do that in this case. After doing this code, we have empty array list in the constructor.
![MAJOR](<LINK_2> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Specify a "Optional" parameter instead. [![rule](<LINK_1>](<LINK_0>
Code style
Code style in these 4 methods is longer three lines
Code style in these 4 lines looks good.
Use checkNotNull(outputHandler, "outputHandler"); so that the outputHandler can be null.
Use checkNotNull(outputHandler, "outputHandler"); so that the caller can handle nulls properly
move outputHandler =...) outside the try block
Could you add a overload to pass a BinaryHeapOutputStream or String[]?
Could you make a utility method for this? More readable
Could you make a utility method for this? More readable and a simple conditionals.
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
Isn't it possible to use try-with-resources?
It'd be nice to use some custom class for this, e.g., tmp.set(attachmentLength);
Shouldn't this be: return PrioritizedFilterChainResolver.init(accountFilterFactory);
Shouldn't this be something like: java /** * @Override public void PrioritizedFilterChainResolver() { return PrioritizedFilterChainResolver.init(accountFilterFactory ); } private PrioritizedFilterChainResolver getFilterChainConfiguration(final PrioritizedFilterChainResolver factory) { return PrioritizedFilterChainResolver.init( ); }
Shouldn't this be something like: java /** * @Override public void PrioritizedFilterChainResolver() { return PrioritizedFilterChainResolver.init(accountFilterFactory ); } private PrioritizedFilterChainResolver lookupFactory() { if (listenerFilterFactory.init(servletContext, 2)) { return; } }
The declarator and the 'else' branch are redundant. The only valid cases can happen in this if-else statement, but there is no way to avoid it.
The declarator and the 'else' branch are redundant. The only difference is the 'if ('else if' clause) and the return' is fine.
The declarator and the 'else' branch are redundant. The only difference is the 'if ('else if' clause) and the return' is the first statement.
I think this exception should be the same as it was before, right?
I think this would be easier to read if it was a plain old data.
I think this would be easier to read if it was a plain old copy of the data.
Why aren't you using 'createNic(..);
Why aren't you using 'createNic(.)'?
Why aren't you using 'createNic(.)'?
I think you need to do this, given that the entry is not exist in the config file.
I think you need to do this, given that the entry is not exist in the stream.
I think you need to do this, given that the entry is not exist in the configuration.
same what have been done here with it below?
same what have been done here with the synchronized on line 160
same.. it's just a special case for it
Small typo in setup, as in ImportVmCommand
can't we have a local variable here?
Small typo in setup, as in ImportVmCommand.
try-with-resources?
Already made a utility of mkdirs() which is public.
try-with-resources might be needed here
Again, this method doesn't need to be public?
Again, this method doesn't need to be public.
Again, this method doesn't have to be public?
I think this can be truststorePasswordAlias instead of the string?
I think this can use truststorePasswordAlias instead of the string?
I think this can return truststorePasswordAlias instead of the string?
We can't catch Exception so no need for the catch block
We can't catch Exception so no need for the specific failure would be thrown
We can't catch Exception so no need for the specific failure would be logged.
Where is the order of parameters changed?
Where is the name of the buildResult coming from?
Where is the order of bindings coming from?
Why adding unneeded braces?
Why adding this check?
Why adding braces?
suggestion if (this.equals(event.getPropertyName())) {
suggestion if (this.equals(event.getPropertyName()) {
suggestion if (this.getPropertyName!= null) {
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
The selectSQL method is called for normal data extraction, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
The selectSQL method is called for normal data extraction, there is already a separate function to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
Is it really necessary to catch all exceptions in this case? What happens if the file didn't exist? I could think that's the exception that you want to catch and that you can catch it in the finally block.
Is it really necessary to catch all exceptions in this case? What happens if the file didn't exist? I could think that's the exception that you want to catch and that you can catch them in the end of the method.
Is it really necessary to catch all exceptions in this case? What happens if the file didn't exist? I could think that's the exception that you want to catch and that you can handle them in any case.
You can't use externalFolder in the folder.setPropertyValue() since you don't need the second call to setEnabled().
The folder.setPropertyValue() should be second called from a different folder. It doesn't seem to be necessary since you only use it.
The folder.setPropertyValue() should be second called from a different folder.
Are there any race condition here? If it's not the leader election phase throws an exception, than a RuntimeException which would be thrown by the client. We need to handle this as well
May I suggest removing the synchronized block since there is an extra "if" condition.
Unless there is some reason to limit this?
don't we want to get rid of the null check?
don't we want to get rid of the null check (also with the visitor pattern)
don't we want to get rid of the null check (also with the visitor variable)?
If we can avoid this log.join(",", cleanupPolicyStr, topicTopicConfig.CLEANUP_POLICY_CONFIG), then why do we need to change this?
If we can avoid this log.join(",", cleanupPolicyStr, topicTopic, TopicConfig.CLEANUP_POLICY_CONFIG), then why do we need to change this?
If we can avoid this log.join(",", cleanupPolicyStr, topic.size());
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a flag and then reset the interrupt flag after we are outside of the while loop.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of it.
Is it possible to avoid this initial kickoff by setting the listener before we add the action to the PageListener?
Is it possible to avoid this initial kickoff by setting the listener before we add the action to the PageFragment?
Is it possible to avoid this method?
Why not using the windowData for the window?
Why not using the window data iterator and use it?
Why not using try catch instead of Throwable?
Can we use injection instead of creating a new CorsConfiguration?
Can we use injection and corsConfigurationByOrganization here?
Can we use injection here?
remove the isDebugEnabled()
remove the ()
remove the isDebugEnabled().
It would be good to create one instance of MemoryUnitImpl and one in this test, because it's creating another one and not needing to pass in the same message.
It would be good to create one instance of MemoryUnitImpl and one in this test, because it's repeated too many times.
It would be good to create one instance of MemoryUnitImpl and static resource pool on a static method (which calls all the methods on line 78).
Don't we want to get here a number of scheduled messages?
Don't we want to get here a number of seconds, can't we just use awaitility?
Don't we want to get here a potentially interrupted exception?
![MAJOR](<LINK_0> Make this line start at column 7. [![rule](<LINK_2>](<LINK_1>
this is not needed
is this needed?
nit: add braces for each if statement
nit: add braces for each if statements
nit: add braces for each if statement.
The diff is not related to the auto merge. If this is the default value of the diff, we will need to set this on mergeDependencies method.
The diff is not related to the auto merge. If this is the default of the diff you will need.
This message should be "diff.getRequiredBy0.2" or "master"
Also, this could be a static method that returns a HashMap. It would make this easier to read.
Also, this could be a static method that returns a HashMap. It will be called every time this method is called, and every new HashSet is created.
Also, this could be a static method that returns a boolean.
nit: maybe rename this to something like CorruptionHealth
nit: maybe rename this to something like CorruptionHealthReport
nit: maybe rename this to entry
A few questions: - Could we remove the try-with-resources? - } catch (InterruptedException e) {... }
A few questions: - Could we remove the try-with-resources? - The BufferedReader should be closed in the "finally" block, so that the close() call is skipped. - If there is nothing to do, it might be too broad in the finally block.
A few questions: - Could we remove the try-with-resources? - The BufferedReader should be closed in the "finally" block, so that the close() call is skipped. - If there is nothing to do, it might be too broad in the finally clause.
I think this looks like the original code. Why do we need to send offsets map to the original state? It seems that this method is only used for inner access to the underlying map, which can be modified in the issue.
I think this looks like the original code. Why do we need to send offsets map to the original state? It seems that this method is only used for the underlying partition.
I think this looks like the original code. Why do we need to send offsets map to the original state? It seems that this method is only used for inner access to a specific file.
This Exception can be removed. As this is common practice in all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception) is no longer needed. Do we want to keep such case?
This Exception can be removed. As this is common practice in all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
if we move this outside the loop, we don't need to do all the null checks. for the case where the acl is not found.
Nit: Don't need the "." at the end of the test.
Nit: Don't need the "." at the end of this line.
Nit: Don't need the empty line.
Add a line break
Add a line break before.
Add a line break between.
We can use Paths.get(System.getProperty("basedir"), "v1"); instead of toString() - it is always null since it is always passed by surefire retrieved from the pom {basedir} (although it is deprecated)
We can use Paths.get(System.getProperty("basedir"), "v1") here, since it is always passed by surefire retrieved from the pom {basedir} (although it is deprecated)
We are never changing info.getBuildFlavor() to INFO
Same here, we can use the expectedPreparedStatement variable.
Same here, we can define a constant.
Same here.
suggestion log.warn("SHA-256 is supported for this file cannot be found for this file");
suggestion log.warn("SHA-256 is not supported for this file: %s", file);
suggestion log.warn("SHA-256 is supported for this file: %s", file);
How can this happen?
Do we want to also support this?
Do we need to check for inodePath?
This doesn't look like an ERROR_TOO_MANY_REQUESTS_PREFIX
This doesn't look like an ERROR_TOO_MANY_REQUESTS; can we put this in a util method?
Unnecessary line after printStackTrace.
Style-nit: We don't use braces around single statements.
Style-nit: We don't use braces around single line blocks
Style-nit: We prefer to use braces around single statements.
Why do you use "testReference" here? It is highly discouraged, wait for an element instead
Why do you use "testReference" here? It is highly discouraged, but it would be more readable in language
Why do you use "testReference" here? It is highly discouraged, but it would be more readable in language.
short -> short
short -> red loop
short -> redud.
two questions regarding this logic. 1. Why isn't this synchronized(boolean) { while(paused) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code } Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?
two questions regarding this logic. 1. Why isn't this synchronized(boolean) { while(true) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code } Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?
two questions regarding this logic. 1. Why isn't this synchronized(boolean) { while(paused) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code } Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it? Another option would be to have the same problem (in a method called from a thread).
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations).hasSize(1);
assertThat(violations).hasSize(1);
assertThat(violations.isEmpty()).hasSize(1);?
It would be better to call setEnabled(reviews).clear() here.
It would be better to use getSelection() and hasNext() here.
It would be better to use getSelection() and hasNext() instead of getActivePageInstance().
Aren't you supposed to be checking all the fields (channel!= null)?
Aren't you supposed to be checking cookie!= null?
Aren't you sure that this change is safe? I'd expect it to be a null check
shouldn't be private
shouldn't it be private?
static import
Consider changing type to SubMonitor
Consider changing to SubMonitor.convert(...)
Consider changing this to SubMonitor.convert(...)
Would it be useful to have a "new ResourceLocation("forge").
How about creating a new ResourceLocation?
How about instantiating ResourceLocation?
This part is not done here, right?
This is not done here, right?
This part is not done here, the mapper should already have a "passed" method.
nit: should this be pipelineDataSize?
shouldn't this be asserting current thread's system property?
nit: should this be pipelineDataSize?
Is there any specific reason to use streams? If not, then you could use Arrays.asList(responseWaiter, partitionCount)
Is there any specific reason to use streams? If not, then you could use Arrays.asList(responseWaiter, t)
Is there any specific reason to use streams? If not, then you could use Arrays.asList(responseWaiter, key)
please change to mapboxMap = findViewById
change to mapboxMap = findViewById
change to insertMap(this, null);
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutItem Optional<AboutItem> aboutItem after that the code should be less complex
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutItem after that the code should be less complex
Needs a space before the comma.
Needs to be addressed here, as indeed the file needs to be updated in the previous version.
Needs to be addressed here, as indeed the file needs to be updated in the beginning,.
Could be: return result.register(registryObject, viewModel);
Could be: return result.register(registryObject, view);
Could be: return result.register(registryObject, viewModel)
We should probably use the constants for these two messages.
Why do we need to use the constants for the correlation id?
We should probably use the constants for the correlation id in the message
This should be moved to a method under class.
This should probably just go into a default value.
This should probably just go into a default value for chatter and not do anything.
Shouldn't this be in FirehoseFactory as well?
Shouldn't this be in configurehose instead of tracingSource?
Shouldn't this be in Firehose instead of firehoseFactory?
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Arrays.asList(range2));
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Arrays.asList(range1));
I think this lines are not required, but never mind.
You could move this to the constructor because you pass the list of listeners in the constructor.
You could move this to the constructor because you pass the list in to the StatisticType constructor.
You could move this to the constructor because you pass the list of listeners in several methods (final Collection<StatisticType> statisticName)
I guess "(s)" is a reason why the srg names are split into two strings..
I guess "(s)" is a reason why the srg names are split into two strings.
can you convert this to a streamline. There is some reason why the convert is not match?
Not sure if this is crucial, but it should be deferring the cache size at the very end of the constructor.
Not sure if this is crucial, but it should be deferring the default capacity for the cache size.
Not sure if this is crucial, but it should be deferring the default capacity for the cache size (which is configurable).
This can't be null right? If ITextEditor is not null then we should check it.
This can't be null right? If ITextEditor can be null then we should check it.
This can be moved below the check right?
is there a problem with this? It feels like it has to be in a loop. Why are you setting isEmail to false?
is there a problem with this? it feels like it has to be in a loop. Why are you setting isEmail to false?
is there a problem with this? It feels like it should be in a loop
Please include clientTelemetryEnabled in toString() API
We should include clientTelemetryEnabled in toString() API
We should also rename the string wordings -> maxRequestsPerConnection
formatting
Is there a named constant for the b
Is there a reason for this?
Unnecessary final
Unnecessary final.
Unnecessary null check
Is this change required? if a user wants to use this with the sslConfig.requireFullSslConfig I'd think
Don't need this if statement (sslConfig.requireObjectIsSsl())
Don't need this if statement (sslConfig.requireNotNull).
We should extract this to a constant, no?
rename to sourceBlock
rename to edges
Should this be CF_METRICS_METADATA_NAME?
Shouldn't this be CF_METRICS_METADATA_NAME?
Should it be CF_METRICS_METADATA_NAME?
Can we move this logic to a static method?
Can we move this logic to a separate class?
Do we need this?
I think the "/" in this case is redundant.
I think the "/" in this case should be 'else if'
I think the "/" in this case should be 'else if'.
consider making a parameter to indicate whether we're making a classification or not using it.
consider making a parameter to indicate whether we're not making a classification or not using it.
consider making this an error.
Let's use com.facebook.presto.server.DefaultException#wrap(java.lang.Exception, java.lang.Exception)
Let's use com.facebook.presto.server.BaseAdmin#create(java.lang.Exception, String, boolean) to avoid possible NPE.
Let's use com.facebook.presto.server.BaseAdmin#create(java.lang.Exception, IOException) and let the other constructor do the work
remove this line
delete this line.
delete this line
I would give a better name than null.
I would surround with brackets even if (!=null) {
I would give a better name than what is not found.
Anyone would think you're a Go programmer with those variable names ;)
Anyone would think you're a Go programmer on those variable names ;)
Anyone would think you're a Go programmer with those variable names :P
Can be moved to the end of the method
Yes, that is what you want.
Yes, that is right.
"Cannot create a thing of type '{}'."
"Cannot create a thing of type '{}': {}."
"Cannot create a thing of type '{}'. The thing of type {} is that."
nit: probably we don't need to specify this if we have a constant called retryCount < this.maxRetryIntervalSeconds
nit: we don't need to specify this if we have a constant.
nit: I think we don't need to specify this if we have a constant called retryCount < this.
> This should just be a Versionable, not a Versionable. The Versionable is going to convert to SirtingPaxosStateLog. But I think this should just be a simplification from SeosStateLog, so it's easier to just use TimeUnit.min(parameters.getLeastLogEntry()).
> This should just be a Versionable, not a Versionable. The Versionable is going to convert to SirtingPaxosStateLog. But I think this should just be a simplification from SeosStateLog.
> This should just be a Versionable, not a Versionable. The Versionable is going to convert to SirtingPaxosStateLog. But I think this should just be a RuntimeException.
I'm not sure if this is a good place to set - when spark version is true, the other means that the Spark job is running, and not " running" is on a Servlet container (or some other component that is running, in case of Spark job is running, and not " running". In that case, the Spark job is running and not " running". Now that it is up to date since the Spark job is running, and not "presto-main" the same Spark version is the same.
I'm not sure if this is a good place to set - when spark version is true, the other means that the Spark job is running, and not " running" is on a Servlet container (or some other component that is running, in case of Spark job is running, and not " running". In that case, the Spark job is running and not " running". Now that it is up to date since the Spark job is running, and not "presto-main" the same Spark job is in the same time.
I'm not sure if this is a good place to set - when spark version is true, the other means that the Spark job is running, and not " running" is on a Servlet container (or some other component that is running, in case of Spark job is running, and not " running". In that case, the Spark job is running and not " running". Now that it is up to date since the Spark job is running, and not "presto-main" the same Spark version is the same as the "unix".
I suggest one level to log at the same level.
why bother keeping it twice?
why is java.net.URI en an IOException?
With the original code, you can't remove the catch clause.
With the original code, you can't remove the catch clause from the first line of the catch.
With the original code, you can't remove the catch clause from the catch block below, which is where you are using it.
can this be moved to the provider itself? Otherwise the 'fromProvider' is not called from multiple threads.
if (provider == null) { return Collections.emptySet(); } //the list is not mutable
can this be moved to the provider itself? Otherwise the 'if' is not called from the provider, it will be null and won't generate an NPE.
extract as constant for sj.fieldValues.length
Also check if sj.fieldValues.length is also missing
extract as constant
Should we have an else block that throws the error? Or at least have a break; after the if?
Should we have an else block that throws the error? Or at least have a break break after the if?
Should we have an else block that throws the expected exception?
I think it would be better to use the same approach as for the other: <LINK_0>
I don't think this is a good idea. The former check would have been more readable to use the equalsEquals method instead.
I don't think this is a good idea. The former check would have been more readable to use the equalsEquals method.
specific exception type here: epdqGatewayResponse.from(response).orElseThrow(() -> new WebApplicationException())
specific exception type here: epdqGatewayResponse.from(response).orElseThrow(() -> new WebApplicationException());
specific exception type here: epdqGatewayResponse.from(response).isPresent()
I'd just do more checks on tuples and see if they are ordered or not, in fact, you can just test that if an frame is being found.
I'd just do more checks on tuples and see if they are ordered even if the frame is not met.
I'd just do more checks on tuples and see if they are ordered even if the frame is not equal, e.g. on tupleFromFrame and the IF block are just checking the equality operation.
Could you refactor this into a method please?
Could you create a private static final int constant for the size of the class?
Could you create a private static final int constant for the size of the iterator?
why do we need to wait for 5 seconds here?
why do we need to wait max 2 seconds here?
why do we need to timeout here?
Can we change the default quota only in one place?
Move this logic to the 'if' statement
Move this logic to the DCs constructor
getString() is not needed. Please inline all the code :)
getString() is not needed. Please inline all the string literals
getString() is not needed. Please inline all the code
Yes this is the first thing i tried. But when I tried to empty the previous mails I couldn't get it to clear.
Yes this is the first thing i tried.... if you want it to be.
Yes this is the first thing i tried.... if you want it to be too important.
I think it would be better to not parse the value of the invalid value, like this: if (value == null) { return; } This is more consistent with the below.
I think it would be better to not parse the value directly in the constructor, rather than doing a cast on every call.
I think it would be better to not parse the value directly in the constructor, rather than doing instanceof check on the value.
The best way to do this. This constructor returns private field names, but it's not referenced from anywhere.
The best way to fix this. Not sure if it's possible to make a local variable.
The best way to do this. This constructor returns private field names, but it's not in the bean itself.
I think I'd prefer to have a test that deletes the value of both JsonNode and expect it to be null.
I think I'd prefer to have a test that deletes the value of both IP and userId.
I think I'd prefer to have a test that deletes the value of both JsonNode and expect it to be equal.
Need to remove this log.
Need {} around all strings.
Need something here.
Have you checked that the test fails if the this assertion fails?
Have you checked that this test fails if the this assertion fails?
Have you checked that this will break the test?
May be you can leave this as debug
May be you can leave this as info
May be you can leave this in info level
nit: it is a little confusing that we use HttpUtils.DATASTREAM_STATE to return a path
nit: it is a little confusing that we use HttpUtils.DATASTREAM_STATE to get a path without prefix. Could you please use it here?
nit: it is a little confusing that we use HttpUtils.DATASTREAM_STATE to get a path here. Could you please use it in other places?
You should test the response.getBody() method. This may simplify the test, see the difference between the other test cases.
You should test the response.getBody() method. This may simplify the test, see the difference between the other tests.
This should be a JUnit test class.
Might be clearer if you actually check that sampleRowKeys.size() and bundles.size() are 1. Also a check on the estimatedSizeBytes will make things clearer.
Might be clearer to assert that sampleRowKeys.size() and bundles.size() are 1. Also a check on the estimatedSizeBytes will make things clearer.
Might be clearer to assert that sampleRowKeys.size() == bundles.size()
This also needs to be done once 'if' is loaded.
This is not really the right issue you are trying to fix here. This issue is a patch.
This is not really the right issue because the problem is also _broken.
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
so it records stopped time only if the workspace is stopped? Shouldn't it be all user's workspaces?
so it records stopped time only if the workspace is stopped? Shouldn't it be all the workspaces?
getNonProxyHosts() already has a risk of NPE, this is not necessarily the same thing. I think it will work
getNonProxyHosts() already has a risk of NPE, this is not necessarily the same thing. I think it will return null if the key is equals to the proxy.
getNonProxyHosts() already has a risk of NPE, doesn't it? There is a lot of code in PermissionSelector.java - I think it is no longer possible to use the interface
IMO better to introduce a method "NodeUrl" that will be used here.
IMO better to introduce a method "NodeUrl" that could be used in the session and TerminalNode it's easier to read.
IMO better to introduce a method "NodeUrl" that could be used in the session and TerminalNode it's easier to follow.
We should also attempt logging/debug here.
We should also attempt to impose the restriction for sensitivity.
We should also attempt logging/trace here.
optional: File::getName
optional nit: File::getName
optional suggestion: File::getName
Why are these 2 lines necessary?
Why are these 2 lines?
Do we need an explicit StringBuilder here?
is this necessary?
is this null any more?
is this null an artifact?
Should we log the warning to stdout? We don't want to generate the message if we are going to have a message.
Should we log the warning to stdout? We don't want to print the stack trace each time we call the method with a message.
Should we log the warning to stdout? We don't want to print the stack trace each time we print the same message.
also should be in one line
also assert the contentlet is null
formatting
It feels like this task should be updated to call the constructor, and not when it is assigned to a local variable.
It feels like this loop should be replaced by a call to forEach, since you only need the watchService call here.
It feels like this loop should be replaced by a call to forEach, since the watchService field is now always called once.
The gui does not need to be Null as well.
The hand for a player is no longer downloaded.
The gui does not need to be set to null.
Why not use StandardCharsets.UTF_8?
Why not just use StandardCharsets.UTF_8?
Why not use StandardCharsets.UTF_8 instead of "/"?
This should be externalized. Also, I don't know what is it used to do with this change.
This should be set back to false. Also, it is also possible to set the editor to null if it is already locked.
This should be set back to false. Also, it is also possible to set the editor to null if it was not found.
File.mkdirs doesn't throw an exception. Use a try-with-resources block.
File.mkdirs doesn't throw an exception if input is not a directory. Use a try-with-resources block.
File.mkdirs doesn't throw an exception if input is not a file.
You can use the lambda expression: java if (Advanced.getoomManager().registerContextMenu(context)) { return AdvancedUtils.getoomManager(); }
You can use the lambda expression: java.map(Advanced::getoomManager)
You can use the lambda expression: java if (Advanced.getoomManager().registerContextMenu(context)) { return Advanced.getoomManager(); }
If we have the skipUser check, we can assume that enqueuedAccountDao.admin() is called. (Here and in the next 3 methods.)
If we have the skipUser() call, we can assume that enqueuedAccount(). Similarly for the rest of the logic.
If we have the skipUser() call, we can assume that enqueuedAccount(). Similarly for the rest of the logic. (Here and in next test case.)
s/oldDisk/getDiskShareable/
1. I'd suggest to unconditionally add a check for 'oldDisk' 2. If not, we'll be able to remove it and from that case.
1. I'd suggest to unconditionally add a check for 'oldDisk' 2. If not, we'll be able to remove that block
We can use Assert.isNotNull() here.
We could use Assert.isNotNull() here.
We could use AssertJ's assertions in one line
Can you please explain this line and the next one: buffer.setSize(new Font());
Can you please explain this line and the next line?
Can you please explain the need of this line and the next line?
unrelated change
why these changes are not necessary?
why these changes are not needed?
This is never called.
This is now useless.
This is probably a good idea.
Why is this done in the master branch? That's a separate issue.
Why is this done in the master branch? I see it in the master branch.
Why is this done in the master branch? I see it's not only moved there.
Should this case be handled by the previous extract method?
Should this case be covered by the previous extract method.
Should this case be updated to use FilterFilters#RESOURCE_name?
Can you make this "BlobId" so that this is only used for the rest?
Can you make this "BlobId" so that this is only available for blobs?
Can you make this "BlobId" a constant?
Please move this line before the for loop.
Please move this line before the if.
getLimit will return null
I think this should use.lang.Class.getClassLoader()
I think this should also be named lang.Class.
I think this should use.equals over ==
This should be a try-with-resources block in case the getHtml is null.
This should be a try-with-resources block in case the resource is closed.
This should be a try-with-resources block.
Lots of unnecessary parentheses here.
add an error message to the log.error
add an error message to the log.error statement.
I don't think these two lines are necessary.
I don't think the throws clause is necessary.
I don't think this test is necessary.
This and other places can be simplified to: java if (table.hasEmbeddedStrategy(schema)) { properties.put(schema, properties); } else { return new DatasetDescriptor(schema.getEmbeddedStrategy()); }
This and other places can be simplified to return an empty map.
This else block could be removed.
Can't you just catch JamesCliException here?
Can't you catch the Throwable and move out of the catch block?
Can't you catch the Throwable and move out of the catch block?
This only runs on GgtkVersion. How about trying to set this to not run on gtkVersion instead? would this work on cocoa/win32?
This only runs on Ggtk version. How about trying to set this to not run on gtkVersion instead? would this work on cocoa/win32?
This only runs on Ggtk version. How about trying to set this to not run on gtk version.
I think this should be: getAndSet(true).map(serviceTarget::getServiceRegistry)
I think this should be: getAndSet(true).map(PortController::getServiceRegistry)
I'm not sure this should be a part of the defined service.
this logic should be inside the if (inputField!= null) block
this logic should go into the Schema class, not the inputField class
this logic should go into the Schema class, not the data type
Use System.gc() instead of System.gc()
Use loops, both here and in perf tests.
Use loops, both here and in perf tests, the data being extracted to a local variable in BeforeClass and Statistics.
I fail with "return Guid.Empty;"
I'm not sure why we need this method 'else' - it is a matter of style, but I prefer to have it in one line
I'm not sure why we need this method here, as it seems to be called only once per run call.
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
If it got deprecated in Gtk3.10, then it should still work between Gtk3.10. You may wanna put this around a version check instead perhaps?
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10.
Is this change necessary?
Is the case that it's not a valid ValueType? If so, I'd rather throw an exception.
Is the case that it's not a valid ValueType?
It seems a bit strange to use!version.equals(version.getAttribute())
It seems a bit strange to use comparator for the version transformations, something like Map<String, String> builder = (version equals(versionAttributeChecker.DISABLE_CACHE_VERSION)).equals(builder.pathElement.get(VERSION_CODES.DISABLE_DEFAULT_EJB_USER)
It seems a bit strange to use comparator for the version transformations, something like Map<String, String> builder = (versionAttributeChecker.UNDEFINED, EJB3Subsystem.get(Supervisor.DISABLE_SORT_EXTERNAL_STORAGEB_DISABLED)))
better: java new Gson(notifications.get("enabled"), notificationListType.disabled), notificationListType);
better: java new Gson(notifications.get("enabled"), notificationListType.disabled)
not sure about the need for this ;)
I am not sure about that. IMO we should set workspace name to null here.
I am not sure about that change. Disregarding workspace.getConfig().get(workspace.getConfig().getEnvironments().isEmpty()) is better.
isNullOrEmpty
can you use the TreeMap here?
can you use the TreeMap constructor to keep a List?
can you use the TreeMap constructor to avoid a List?
the definition can move to the try block
the definition can move to the else block
is this necessary else block
Is it possible to move this block to the end of the run method? It might be a bit easier to read.
Why is this needed? I think it's fine to just catch IllegalAccessException so that the specific exception is clear.
Why is this needed? I think it's fine to just catch IllegalAccessException so that the specific exception is clear here.
what happens if the account did not exist? I think the log should be assertExpectedRouterErrorCode.
what happens if the account did not exist? I think the log should be assertExpectedRouterErrorCode().
what is the reason you are using assertNull here instead of instanceOf?
Can we use a try-with-resource pattern here? I don't think we need to get rid of these.
Can we use a try-with-resource pattern here? I don't think we need the CountDownLatch here.
Can we use assertEquals here? I don't think we need a reference to the client.
Remove, please, this line.
We can change this to List<Message<?>>? (just thinking in terms of consistency with the RabbitMQ version)
Remove, please, this should be a brpop with a short delay. That's the reason to check for  RabbitMQ version over groupId.
Can you keep this text a bit more meaningful?
Can you keep this one way or the other so that it's okay to just keep the one instance up to the other?
Can you keep this one way or the other so that it's clearer to just keep the one After else on a Final class.
Please use AsyncCountDownLatch here. Both handlers slave and reconnect.
Please use lambda syntax
Please use 'public'.
This should occur before the call to isValidType.
This should occur before any call to isValidType.
This should occur before the check below.
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
hmmmm.... how is it done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you.
can you please use a standard for loop
can you use a regular for loop here and remove -> a lambda?
can you please use a positive condition for this and add an early exit
Spacing
Spacing java 8 spaces.
Spacing java 8
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and could be removed. The same goes for the other fields.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and they are redundant, and should be removed. The same goes for the other fields.
Did I miss where you close it?
Did I miss where you close your&lt;ivanzes?
Did I miss where you close it?...
What if.filter(dice) is null?
Why there are only 8 processors, when you need to use Stream
What if there are multiple digits?
Should be debug
Should be debug.
Should be a constant
Where is the error level added?
Where is the error level shown?
Where is the error?
checking if the group count is equal to limit, i.e., you don't have to do 1. If the user specified has been removed, it would make sense to have a lower default value, like 100. Also, I would just say that service.getHostedEntryCountLimit() == 0
checking if the group count is equal to limit, i.e., you don't have to do 1. If the user specified has been removed, it would make sense to have a lower default value, like 100. Also, I would just say that service.getHostedEntryCountLimit() < 1.
checking if the group count is equal to limit, i.e., you don't have to do 1. If the user specified has been removed, it would make sense to have a lower default value, like 100. Also, I would just say that service.getHostedEntryCountLimit() == 0.
just use log.error("Retrying", e);
just use log.error("Retrying rate limit exceeded.");
Just use logger.error("Retrying rate limiter.log");
Also we need to close the connection here as well.
Also we need to close the server here as well.
Also we need to close the server even if we do not want it.
can you fix the typo on the next line?
can you fix the typo on mppProviders
can you fix it
Can we put the if (totalRequests == 1) { continue; here?
Can we put the if (totalRequests == 1) { below?
Can we put this to the else branch?
Sidem: I know it's not a measurable to me but for me it is not a good idea to throw an exception here like in SchemaBatchBuffer fillInputTbb
Sidem: I know it's not a measurable to me but for me it is not a good idea to throw an exception here like in SchemaBatchBuffer fillInputTbb method.
octal numbers
I feel like this test and the above test have switched titles.
This test and the above test have switched titles.
I feel like this test and the above test are duplicating?
might be worth putting this into a helper method often: java Util. put(keyBuf, (long) ((long) keyBuf.get(keyBuf))
might be worth putting this into a helper method often: java Util. put(keyBuf, (Collection<K>)? put(keyBuf) : ByteBuffer.allocate(keyBuf.flip());
might be worth putting this into a helper method often: java Util. put(keyBuf, (Collection<K>)? put(keyBuf) : ByteBuffer.allocate(keyBuf.toByteArray())
this should be an error instead.
Static import?
This should be an error instead.
can you put the specific exception e.getMessage() into a separate catch block and log the error.
can you put the specific exception e.getMessage() into a separate catch block and log as an error.
can you just put the specific exception handlers up on the new catch block?
why not make "update" a constant too?
why not make "update", "update" a constant too?
why not make "update instead of "update" a constant?
we can set variable directly here.
we can set map directly here.
we can set map as JSON. The call to sendCommand will make sure it was called after command.
Should this be CompoundRuntimeException?
Should this be CompoundException instead of CompoundRuntimeException?
Should this be "Error stopping"?
Also, consider this (up to you): java return input.append(text.charAt(i)).append('\n');
Also, consider this (up to you): java return input.append(text).append('\n');
Also, consider this (up to you): java return input.append(text).append(name).append(text);
Please benchmark this. The code was written this way for a reason.
Please benchmark this. The code was written this way for a reason. In general I prefer for a reason.
Please benchmark this. The code was written this way for a reason of this.
Slightly confused by this method
Slightly confused by this method. What about something like: private static final String Dotfile(final String line) { final String value = Files.readAllLines(key); return secretsFile; } and use it below.
Slightly confused by this method: private static final String Dotfile(final String line) { String value = Files.readAllLines(key); return secretsFile; } and use it below.
why is this tested?
why not resource.getResource()?
why not resource.getResource()
Use NetworkUtils:isInternetConnectionEstablished
flip the conditions, null check should be done before
Use NetworkedState.isInternetConnectionEstablished
wait.forElementPresent(NAV_ICON) is pretty bad, before the loop and will fix it.
wait.forElementPresent(...)
wait.forElementPresent(model)
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "Optional#isPresent()". [![rule](<LINK_1>](<LINK_2>
checkState
why swap?
why swap here?
how about swap?
Formatting is off here.
Formatting is off.
Formatting before the return.
This is a very minor nitpick, but is there a reason for not using printStackTrace()?
This is a very minor nitpick, but is there a reason for not using printStackTrace() here?
This is a very minor nitpick, but is there a reason for not using printStackTrace()?
Not sure if I'm confused. Even if we wait for the 1st parameter to retry the command, it might be better to wait until we find a different response.
Not sure if I'm confused. Even if we wait for the 1st parameter to retry the command, it might be better to wait until we get a client errors, and then retry immediately.
Not sure if I'm confused. Even if we wait for the 1st parameter to retry the command, it might be better to wait until we get a client errors, and then retry once we find a client.
We could avoid nesting by skipping some of the following lines if block : java if (qName.equals(key)) {... }
We could avoid nesting by skipping some of the following lines if block : java if (qName.equals(last)) {... }
we could avoid nesting by skipping some of the following if block here if we print a warning at all.
toString()?
toString()
use StringBuilder
it would be better to use StringUtils.isNotBlank(rc)
please use StringUtils.isNotBlank(rc)
please use StringUtils.isNotBlank()
Should we log the exception here?
Should we use a logger here?
Log the exception here?
Won't this need to be synchronized?
Won't this need to be synchronized as well?
Let's make this method synchronized
Can we use [apache.csvFileParser](<LINK_0> here?
Instead of parsing thecsvFile, could we use a static variable to save all the files and verify that it is a directory?
Instead of parsing thecsvFile, could we use a static variable to save all the files and verify that it is a code smell?
Could not use Arrays.asList(new ArrayList<>() here as well
Could use new ArrayList<>() here and below.
Could not use Arrays.asList(new ArrayList<>() here as well.
You could use the ninePatchHeight instead of the width.
You could use simple concatenation like this: final double drawLineSegment(x, y, false, "tr");
You could use the ninePatchHeight directly instead of the width.
Not a big fan of creating a separate StreamProcessor in the test suite. Can we deduplicate the code?
Not a big fan of this. The test uses a lot of the same metrics.
Not a big fan of creating a separate StreamProcessor in the test suite. Can we deduplicate this?
Does the schema name need to be null here?
Use Util.validateSchema(tableName, schema.tableName)?
Use Util.validateSchema(tableName, schemaName)
Use IWorkbenchCommandConstants.EDIT_CONTENT_LENGTH constant.
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST in the URL
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> schema, Expression Expression pattern, Optional<Expression> schema) { Expression Expression pattern = Index.parsePredicate(metadata.getCatalogName(), schema.getSchemaName(), TABLE_TABLES).getLikePattern();... }
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> schema, Expression Expression pattern, Optional<Expression> schema) { Expression Expression pattern = Index.parsePredicate(metadata.getCatalogName(), schema.getSchemaName(), TABLE_TABLES); schema.getLikePattern(originalName); }
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> schema, Expression Expression pattern, Optional<Expression> schema) { Expression Expression pattern = Index.parsePredicate(metadata.getCatalogName(), schema.getSchemaName(), TABLE_TABLES); schema.getLikePattern(tree.getCatalogName()); }
Remove this NULL if it's not necessary
if a new code is missing here?
Remove this NULL if possible
Beware that this code is invoking logger.getLogger() on loggerContext. It's not exactly the same as this, but a logger.getLogger(logLevel)..... should be logger.debug instead.
Beware that this code is invoking logger.getLogger() on loggerContext. It's not exactly the same as this, but a logger.getLogger(logLevel)..... should be logger.debug instead of this?
Beware that this code is invoking logger.getLogger() on loggerContext. It's not exactly the same as this, but a logger.getLogger(logLevel)..... should be logger.debug instead of logger.debug
Update to use in the vdsbroker
Ipv4Addresses#equals(null)?
In most places you've changed using of getter.
We should have the cause in the exception. Otherwise, it is a hard to identify the cause of the issue.
We should have the cause in the exception. Otherwise we would try to delete everything after the zk operation.
We should have the cause in the exception. Otherwise, it is a hard to identify the cause of the failure.
Shouldn't we use the try with resources here.
Shouldn't we use the try with resources here?
Shouldn't we use try with resources here?
this is another behavioral change, it should be discussed in #6610
this is another behavior change, it should be discussed in #6610
this is another behavioral change, it should be discussed in a service
do we even need to say getResults here?
Why are we checking the exception here?
do we even need to checkArgument it is debug?
Please use network.isChangable(false);.
Please use network.isChangable(new Guid().toString())
Please use network.isChangable()
It would be nice to verify that the question button is applied correctly after 'bottom', not '(0)'?
It would be nice to verify that the question button is applied correctly instead of simply using 'owner'.
It would be nice to verify that the question button is applied correctly instead of simply using'match'.
Why is this synchronized call needed?
Do we need to log leak here? Let's make it consistent.
Do we need to log leaked resources?
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE); }
here we need to use instead this pattern: java java.channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE);
here we need to use instead this pattern: java java.channel.channel().hasAttr(LOCAL_ADDRESS_OVERRIDE); This also applies below.
You may want to make it a static variable and call it in the constructor rather than on every call.
You may want to make it a static variable and call it in the constructor like you did in Backward shiftGenerator.
You may want to name this a bit more readable.
I wonder if maybe pass this to Java 8 to DefaultPassConfig, do we need to apply the same logic to several places?
I wonder if maybe it would be nicer to use extracting this to a method and inline the logic into the 'if' clause.
I wonder if maybe pass this to Java 8 to DefaultPassConfig, do we need to be able to apply the same logic to multiple places?
Could you fix this while you are at it?
Could you fix this to make the regex an "else" bracket a few lines below?
Could you fix this to make the regex an "else" a bit more explicit?
I guess this should be extracted into a method to avoid code duplication.
I guess this should be extracted in a separate method to avoid code duplication.
I guess this should be extracted into a method to avoid duplicating the same thing.
As above, I think we should simplify the instanceof check.
As above, I'd move the instanceof check into the build function
As above, I'd move the instanceof check into the build method
please make it static
please make other if/else
please make other if blocks
one more thing: if windowInfoList!= null, and windowInfoList are empty, then we don't need to change the first one
one more thing: if windowInfoList!= null, then we don't need to change this anymore.
one more thing: why change this?
Need to change'return' to 'else'.
Need to change'return' to 'else'?
Need to change 'is not async'?
I'm a bit confused, what do you think about changing sleepVal to a variable and use it in the while loop?
I'm a bit confused, what do you think about changing sleep time?
I'm a bit confused, what do you think of changing sleep time?
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please add them also here. Otherwise if you are sure none of the fields will ever be null in a column?
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please update them also in VmGuestContainerListModelTable.
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please update them also here.
As discussed offline, we probably need 2 things here: - 1. Can we change the variable for clarity, avoiding the variable names of variable for clarity? 2. Why not change the variable for clarity, e.g. RiakClient.readFrom()?
As discussed offline, we probably need 2 things here: - 1. Can we change the variable for clarity, avoiding the temporary variable for clarity? 2. Why not change the variable for clarity, e.g. RiakClient.readFrom()?
As discussed offline, we probably need 2 things here: - 1. Can we change the variable for clarity, avoiding the temporary variable for clarity? 2. Why not change the variable for clarity, this isn't needed anymore?
instead of path separator create new path to make it generic
instead of path separator create new path for each test, why not use the path variable and use it in testAfterOutputs()?
instead of path separator create new path for each test, why not use the path variable and use it in testShouldDumpLocation test method?
try using stream api for filtering
try using stream api for filtering and filtering
try using stream api
The previous code was more readable since if the stopSample count is 0 then we don't need this check.
The previous code was more readable since if the stopSample count is 0 then we don't need this since it will be set to true.
The previous code was more readable since if the stopSampleCount == 0 then the new MaxTransactions.all() will be called for each node (as well as a local variable). It's the "if" statement.
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
if (keyAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
if (keyAlgorithm == null) { key = ECDSAPassword.INVALID_ALGORITHM(); }
We're no longer using the stored values in the local variable. Let's call removeAll instead of getAll.
We're no longer using the stored procedure. Let's call removeAll instead of getAll.
We're no longer using the stored source in the local variable. Let's call removeAll instead of getAll.
If I'm reading this right (and I may be missing something!), it seems like we're never actually _cancelling_ these futures, right? We're just waiting for them to finish on their own?
If I'm reading this right (and I may be missing something!), it seems like we're never actually _cancelling_ these futures, right? We're just waiting for them to finish on their own.
If I'm reading this right (and I may be missing something!), it seems like we're never actually _cancelling_ these futures, right? We're just waiting for them to happen on their own?
You can combine the two ifs into one.
You can combine the two checks into one.
It doesn't make sense to catch the Exception here.
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "message" 3 times. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Define a constant instead of duplicating this literal "message": 3 times. [![rule](<LINK_0>](<LINK_2>
!json.isEmpty()?
should this happen before the loop?
should this happen inside the else?
should this happen before isVisited?
Basically the same issue as mentioned above, I believe.
Basically the same issue as mentioned above, I think.
- [x] The error message should be "not found".
Can you add a check for threadCpuTime, like you did above?
Can you add a check for threadCpuTime, to avoid this?
Can you explain how users are easily guarded by the possibility to avoid NPE?
style nit, put the { up with the if clause
style nit, put the { up with the if, right after the if,.
style nit, put the { up with the if, right after the if clause
Can you use a multi-line try-with-resources?
Can you use the BufferedReader constructor to save the lookup?
Can this be made final?
Huh? I'm surprised that the lock isn't needed, I don't think this is needed.
Huh? I'm surprised that the lock isn't needed, I don't think there's any reason for this.
Huh? I'm surprised that the test expects the lock based on the lifecycle lifecycle...
I think this whole block could be moved up. It's hard to read with CV a bit.
I think this whole block could be moved away from line 63 to 76. Having different grammar in it is to split up the string's length.
I think this whole block could be moved away from line 63 to 76.
Other arguments are registered in Java 7, so this line is redundant.
Other arguments are registered in Java 7, so this is not necessary.
Other setters are not named as parameters
I'm not sure this is correct. I think we should make the scenario more clear.
I don't think this is correct. I think we should make the scenario more clear.
I'm not sure this is correct. I think we should make the scenario more clear by design.
instead of checking for null, we can get the next line (just for the next line): AndroidFxAccount account = ((String) args).email(); if (def == null) { throw new IllegalArgumentException( "The image is not found in pickle file"); }...
instead of checking for null, we can get the next line (just for the next line): AndroidFxAccount account = ((String) args).email(); if (def == null) { throw new IllegalArgumentException( "The image is not found in pickle file"); }
instead of checking for null, we can get the next line (just for the next line).
Could you keep this method on the same line? It doesn't seem to provide any value.
Could you keep this method on the same line? It doesn't seem to provide any purpose to the same file type.
Could you keep this method on the same line? It doesn't seem to provide any purpose to the endorse of the method.
this can be done outside the while loop
this can be done outside the while loop.
this can be done outside of the while loop.
Nit, I don't think this error message is appropriate. I think it may be good to include the path or path in the message.
Nit, I don't think this error message is appropriate. I think it may be good to make it more clear about what exception means.
Nit, I don't think this error message is appropriate. I think it may be good to make it easier to debug.
Good candidate for a method like roflConf().
Good candidate for a method like getIngestionSchema() instead.
This can be combined for all tests
"String url = null;"
"no longer work" -> "due to image"
"no longer work" -> "not found"
rename to 'equals'
not needed, right?
equalsIgnoreCase() is redundant and can be replaced with equals()
nit: sb.getRawPath() could be used here too
nit: sb.getRawPath() could be used here.
nit: sb.getRawPath() could be replaced by a StringPool.getRawPath()
It looks like this check can be removed.
It looks like this check is also checking that the attribute has a NodePath parameter.
It looks like this check is also checking that the attribute has a space already.
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceStatusReturnValue and not FenceStatusReturnValue?
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return a String?
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode is also renamed?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if the client were offline.
damn. Common.getProjectCache().get(change.getDest().getParentKey())) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
Merge this line with the one above
Merge this line with the one above?
Use a static import
bad part of this condition, this if-else block can be removed
bad part of this condition, i think.
please reformat this condition
Can you check your identation settings?
Can you check your identation settings from your PR?
Can you check your FQN?
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future.
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if the new assignment is applied here.
check if needed?
the check is still not needed
the check is still not needed.
Remove check for SSL context.
Remove check if the order is correct.
Remove check for (previous version of the activation)
Is there a way to explicitly print stack trace?
remove printStackTrace() and simply log the error
remove printStackTrace()
Should be moved inside the try block.
Should be inside the try block.
Should be done in BaseResultFactory.
Now that we're checking adapter.getPlacementId() can go null and this should be a fix. This is needed as well.
Now that adapter.getPlacementId() can return null, why do we need to check for getPlacementId()!= null?
Now that we're checking adapter.getPlacementId() can go null. This is the replacement for checking.
move the pongPatterns and pongPatterns to a static method?
move the pongPatterns and pongPatterns to the right version.
switch please.
if (representation == null) { return; }?
if you change this to (representation == null), you should break the test.
if you change this to (representation == null), you should return an error.
Log.debug?
Consider usage of machines!= # of pods.
Consider usage of machines names in log message
can we keep the old error message please? I know it's not part of the exception, but would it make sense to define more info in this error message?
can we keep the old error message please? I know it's not part of the exception, but would it make sense to have the field record.getSchema().
can we keep the old error message please? I know it's not part of the exception, but would it make sense to have the field record.getSchema().get(key) in the message?
Isn't there some simple little library for generating JSON output? This seems like overkill.
Isn't there some simple little library for generating JSON output?
please extract to package-private.
Please rename operatorType to operatorType
Please rename operatorType to functionType
operatorHandle?
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL) as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL) as this would be symmetric with the Timestamp -> BigDecimal conversion we support. I think a DateUtil that goes from BigDecimal -> Timestamp makes sense.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)?
@vilchik-elena If there is nothing to do if (json instanceof File) { return null; } else if (json instanceof Reader) { return json; } else { return json; } and the exception handler
@vilchik-elena If there is an else that does not throw an exception on the next line.
@vilchik-elena If there is an else that does not throw an exception? So we have to handle something else.
Single line per [principal.getName()](<LINK_0>
Single line for readability.
Single line if and else blocks
This will throw a NullPointerException if failures.size() == 0
This should be simplified to wrap with Objects.requireNonNull.
This will throw a NullPointerException if failures.size() == 0.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java.join(testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(Collectors.joining(",")));
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java.collect(Collectors.joining(",")));
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java.put(TESTER_NAMES, testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(toList());
I don't think we need this variable. The workbench is already used in the other places in this class.
I don't think this would be a good idea. The title should be the responsibility of the page, not the model.
I don't think this would be a good idea. The title should be the responsibility of the page, not the UI.
Nit: can you make this a constant and give it a meaningful name
same here, can you make a smaller error message and also check that the returned value is not empty
same here, can you make a smaller error message and also check that the returned value is not empty?
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs,...)?
why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs,...)?
Why do we use frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs,...)?
I'm not sure if the change to!launched.isCanceled() is the same as fLaunchConfig.launch()?
I'm not sure if the change to!launched.isCanceled() is the same as the!launched.isCanceled()
I'm not sure if the change to!launched.isCanceled() is the same as fLaunchConfig.launch()
put these code in else block?
put these code in a separate method.
remove this line
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Is the sleep necessary? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive()).blockUntil(), getError(...)
Minor: this is duplicate of above check and can be removed.
Formatting?
Minor: this is duplicate so this could be removed.
This could be more concise as as!Strings.isNullOrEmpty(valueToCheck)
This could be more concise as as!Strings.isNullOrEmpty(valueToCheck))
This could be more concise as String value = "true".equalsIgnoreCase("false");
There are some project types that are not Abstract Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractTriggeringManager to check for that. Can we decide to change this to fire a event and have getTriggers?
There are some project types that are not Abstract Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstracterritView, but I'm not sure that those are relevant here. Could you please change these to a PR or remove them?
There are some project types that are not Abstract Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstracterritView, but I'm not sure that those are relevant here. Could you please change these to a PR or remove the getTriggers() method too?
we need to handle that somehow, I think the UpdateVmCommand should be marked with @Nullable
we need to handle that somehow, I think the UpdateVmCommand should be populated with default values
is it relevant only for vmDynamicData?
This if-statement can be combined with the one above.
Is this change really needed?
This if/else can be combined with the else
initializeDisksAndReplicasOnNode is not being used for this patch.
initializeDisksAndReplicasOnNode is not needed anymore
initializeDisksAndReplicasOnNode is not needed anymore?
removeImage and removeImage too
removeImage and removeImage parameters in the same line
removeImage and removeImage
no need for this.
no need for OsRepositoryImpl
please move this to the top.
This message doesn't seem clear to me. Something like: "Cannot partition on schema:private fp = null && fieldSchema.getType() == Schema.Type.RECORD;"
This message doesn't seem clear.
This message doesn't seem clear to me.
Nit: I think you need to check that lbService is not null before accessing it
Nit: I think you need to check that this service is not null: <LINK_0>
Nit: I think you need to check that lbService is not null before accessing it.
Do we need to check parameter.value, or can we just use parameter.value?
Do we need to check parameter.value, or can it be null?
Do we need to check parameter.value, or can we just use parameter.value here?
This block should probably be parameterized, [fails](<LINK_0> and this block should always be executed.
This block should probably be configurable and has a flag taking a long time.
This block should probably be debug level.
Extract the fix to a method for better readability
Extract the creds into a local variable to avoid calling it twice
Extract the creds into a local variable to avoid calling this twice
suggestion if (isLocalPlayer()) {
suggestion if (isLocalPlayer) {
suggestion int count = super.getMessagingService();
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>()).add( category);
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>()).add(category);
rename 'childsystem'?
rename 'childElement'?
Should this be in a different way?
Same here, we should pass in the exception to this method so that the caller doesn't have to pass in a list.
Same here, we should pass in the exception to this method so that the caller doesn't need to pass in a list.
Same here, why not pass in the uninitialized list?
declare a constant?
"Host" could be a constant.
"Host"
using string concatenation may help with debugging info.
using string concatenation may help revert your change
use StringUtils.SPACE
Unrelated change
Consider pass a subMon.newChild(10)
Unrelated changes
this change is good, but I don't think it's a good idea to make it visible for users to know they have the bot user.
this change is good, but I don't think it's a good idea to make it visible for testing. slackUserId = slackUserIdResolver
this change is good, but I don't think it's a good idea to make it visible for testing. slackUserId =... or something.
Tangay! We should catch this exception only if the user presses ctrl-c/etc player aren't running.
Tangay! We should catch this exception only if the user presses ctrl-c/etc/ can't be somehow apparent.
Tangay! We should catch this exception only if the user presses ctrl-c/etc/ can't be somehow loaded.
I don't think this is correct. git git blame is also about git git - I don't like it, because it means git git blame / git shows the git tree update. The git shows the editing tree tree and doesn't support editing the git tree. So the git tree tree should be in the same commit, maybe it is better to move this above the if/else block?
I don't think this is correct. git git blame is also about git git - I don't like it, because it means git git blame / git shows the git tree update. The git shows the editing tree tree and doesn't support editing the segment. So the fix should be "not implemented".
I don't think this is correct. git git blame is also about git git - I don't like it, because it means git git blame / git shows the git tree update. The git shows the editing tree tree and doesn't support git.
This test will fail if the default value is true, but does still return false. Here we need to validate it false, otherwise it will still pass right?
This test will fail if the default value is true, but does still return false. Here we need to validate it false, otherwise it will still pass it back to the server.
This test will fail if the default value is true, but does still return false. Here we need to validate it false, otherwise it will still pass it back to the default value.
I would prefer to use same code as in method getProjectRelease final Set<Release> releaseIds = projectService.getReleaseIdToUsage().keySet(); for (Release releaseId : releaseIds) {...
I would prefer to use same code as in method getProjectRelease final Set<Release> releaseIds = projectService.getReleaseIdToUsage().keySet(); for (Release releaseIds : releaseIds) {...
I would prefer to use same code as in method getProjectRelease final Set<Release> releaseIds = projectService.getReleaseIdToUsage(); for (Release releaseIds : releaseIds) {...
instead of doing this, could we use globalConfiguration.isClustered()? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
instead of batchWriters, could we use globalConfiguration.isClustered()? when reading the line, it seems like we are avoiding a null pointer exception (like expiration) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
instead of batchWriters.forEach(), could we use globalWriters.forEach()?
I don't think you need to set the build to true here.
could use BigDecimal.valueOf()
could use BigDecimal.valueOf() or respectively.
This should be a warn
This should be a constant variable.
This should be a warn instead.
You don't want to move them all to hamcrest?
You don't want to move them all into hamcrest?
You don't even want to move them all to hamcrest?
This is inconsistent to use TxFormatter.getInstance().scheduleState(slaveState);
This is inconsistent to have some UTs for this. You could move it up to a separate PR that checks it.
This is inconsistent to have some UTs for this.
I guess this will be GWT compatible?
I guess this will return null?
I guess this will be GWT's Java?
please rename to "decimalPlaces"
Please rename to "decimalPlaces"
Remember to change to "authenticate"
rename to resolvedBundleField
rename to resolvedBundle[]
rename to resolvedBitSet
You can inline this variable. It is not really needed for more readability
You can inline all of these local variables into a method to reduce code duplication.
You can inline this variable.
"/" from java.lang.String is more readable than StringUtils.startsWith
Missing space between if and (
"/" from java.lang.String is more readable than String.format
This fails for Gerrit server to never be connected.
This fails for Gerrit server to abort.
This can be inlined
Can we remove the.addHandler(). ;)
Can we make the init() method private?
Can we remove the.addHandler( rillSessionImpl creates a Configuration?
Let's keep the same behaviour for this.
Let's just keep this.received
Let's keep the same thing for this.
Same here, you can flip the order of the lines.
Same here, you can flip the order of the key and value in the map.
Same here, you can flip the order of the key and value
Should we use a default scaling flag here?
Should these two lines be moved to the if statement above?
Should these two lines be moved to the beginning of the method?
Can we use String.format() to make it more readable?
Can we use String.format() to make this more readable?
Can we use String.format here?
I'm not sure we should handle this in the modification of the parameter. The way to introduce wait is to add scroll when the value is set, but this is always the current time. It might be better to move this into a new method.
I'm not sure we should handle this in the modification of the parameter. The way to introduce wait is to add scroll when the value is set, but this is always the current time. It might be better to move this into a separate method.
else should be on the previous line.
We should move this out of the done loading listener, I don't think we should just leave it out for now.
I don't think we should leave this out for now. I think we can just move it out of the scope of this PR.
I don't think we should leave this out for now.
Do we really need to set the link status?
Do we really need to set the hidden status of the project?
Do we really want to use.append() for the title?
Could you please explain why this assertion is necessary? Couldn't the assertion be done just once.
Could you please explain why this assertion is necessary? Couldn't the flag be set to false automatically?
Could you please explain why this assertion is necessary? Couldn't the flag be set to false just mean we have only one item.
Could we refactor this log message in a unit test?
Should the log message be updated?
Should we log a warning?
space after,
space before the }
tab
You should probably parse the value only once, and store it in local field.
You should probably parse the value only once, and store it in local variable.
You should probably parse the value using StringUtils.isNotBlank()
na!= null? false : true;
na!= null is redundant.
na!= null is always false.
should this be error level?
should this be error message rather than info?
should this be error message rather than info message?
Stereotypeifier instanceof EObject is not part of your commit
StereotypeUtils.isElement
use static
Shall we throw an exception instead of returning null?
Shall we throw an exception in the catch instead of returning null?
We try to handle this. In the other words: throw an exception if it is null.
The while loop can be replaced with for (int i = 0; i < size; i++) {
The while loop can use for-loop here.
The while loop here is redundant.
what if subTree is null?
what if parentTree.root().isPresent()?
what if parentTree is null?
Minor typo: why are we calling jsonEdgesArray here?
Minor typo: why are we calling jsonEdges.put here?
Minor thing, why are we retrieving the value and not the jsonmodel?
can we change this to a warn log message indicating that the segment was skipped?
can we change this to a warn log message indicating that the segment was deleted for a segment?
can we change this to a warn log message indicating we were skipped for segment starting with data source {}?
static import
I am not sure if inlined version is better
Remove the static import
cache?
cache as we use the tenant
cache as we use the wrapper API
why not use map(r -> r.getCanonicalPath())?
why not use a map?
why not use a method reference?
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
Is there a reason for the old method, <code>updateFeedbackQuestion</code>?
Is it possible to add newline before the comma?
It would be nice to have a more descriptive name, like toggleItem() or something.
If we're already using MenuManager... just to show the dialog it like this: TextUtils.isEmpty(showView)
If we're already using MenuManager... just to show the progress bar?
Please call mkdirs here. And it is strange that getWorkspace returns null.
Please call mkdirs() here.
Please call mkdirs here.
If you want to be sure that this method is not a SectionMatcher rather than a regular root, then it might not be visible to the user, but it might be better to not use it as a dynamic one.
If you want to be sure that this method is not a SectionMatcher rather than a regular root, then it might not be visible to the user, but it may be better to not use it as a dynamic.
If you want to be sure that this method is not a SectionMatcher rather than a regular root, then it might not be visible to the user, but it's not necessarily a Set. So it should be the same.
The contents of the file are same, right? If you need to make sure that we don't delete the file, you can remove the "file" from the list of files.
The contents of the file are same, right? If you need to make sure that we don't drop the file, we can remove the "file[01.165, "file2".
The contents of the file are same, right? If you need to make sure that we don't drop the file, you can remove the "file[01.165, "file2".
I don't think that this will work for all cases. You need to just start the project and then dispose the outlinePage.removeMavenProjectChangedListener() method.
I don't think that this will work for all cases. You need to just start the project and then dispose the outlinePage again if the project is not already disposed.
I don't think that this will work for all cases. You need to just start the editor with the selected outline.
can't we use the new enforce function calls here?
can't we reuse the existing HBase function?
can't we use the new enforce function calls?
I think we should close the StringReader after unmarshaling.
I think we should close the StringReader after unmarshaling. And if there is no other way we can do that
we should close the StringReader after unmarshaling.
What about throwing IllegalArgumentException instead of returning null?
Can you please extract this block to a separate method, for the sake of readability.
Can you please extract this into a local variable
This doesn't look right. Why are you making an array of cubes (cube..) and can be null?
This doesn't look right. Why are you making an array of cubes? It can be null!
This doesn't look right. Why are you making an array of cubes here?
I am not sure we need to create a couple of local variables here... should we use the rateLimiterConfigurationProperties.as(entry -> rateLimiter.getCache()!= null, entry.getValue())?
I am not sure we need to create a couple of local variables here... should we use the rateLimiterConfigurationProperties.keySet() in the constructor?
I am not sure we need to create a couple of local variables here... should we use the rateLimiterRegistry?
use static import for AssertJ
use static import for hamcrest
use static import import
Please benchmark this. The code was written this way for a reason.
Please benchmark this. The code was written this way for a reason. The code was written this way for a reason.
Please benchmark this. The code was written this code was written this way for a reason.
Change the lambda arg's name to __ when not used
Doesn't the lambda arg's name need to be used here?
Doesn't the lambda arg's name need to be used here's?
This can be simplified into: if (getFeedbackSessionResultsForInstructorInstructorInstructorInSection(feedbackSession, courseId, instructor.email)) {
This can be combined with the previous one.
This can be simplified into: java if (getFeedbackSessionResultsForInstructorInstructorInSection(feedbackSession, instructor.email)) {
well, of course I can read the code and understand, but - still, maybe enum is better.
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
i didn't see change in the config.sql to make this value per-version, so it's not ok to call this from the config file.
I don't think it's worth using.equals() here. The underlying issue is that the event is only about one thread.
I don't think it's worth using.equals() here. The result is true on the application.
I don't think it's worth using.equals() here. The underlying issue is that the event is only about one element (as it's probably going to be ordered anyway). So a user could just enter a hint?
Can we add the cause here as well?
There is no need to catch this, just let the exception bubble up and fail the test.
There is no need to catch this, just let the exception bubble up and be thrown.
It might be better to create a new StringBuilder object, rather than adding a new string builder.
It might be better to create a new StringBuilder object, rather than adding each element to an array.
It might be better to create a new StringBuilder object, rather than constructing a new string each time.
Why would the conversion be done outside the if-block?
Why would the conversion be done outside the if block?
Why would the conversion be done outside the if-condition?
This block is not covered by the existing check, but changelogMetadata!= null check is enough.
This block is not covered by the existing check, but changelogMetadata!= null check is already done here.
This block is not covered by the check above in the hasInitializedChangelogs.
We should add a check for the channelInterceptorBean to the registry instead of the name.
We should add a check for the channelInterceptorBean to ensure we have the same bean in the registry. Otherwise these changes are required.
We should add a check for the channelInterceptorBean to ensure we have the same bean in multiple places.
[minor] Should we not have that one.
[minor] Should we not change this, as it is a GitHubPushTrigger instance?
[minor] Should we not change that?
Could you please explain the need for this variable?
Could you please explain the need for a variable?
Could you please explain why this is needed? we have many useless copies with this structure
Is this the same as the one above?
Is this the same as the previous catch statement?
Is the exception caught somewhere else?
setStatusInfo() does not necessarily return a node, so you should not set it here.
setStatusInfo (see other places)
setStatusInfo (see line 69)
This one should probably be changed to '...' too.
This one should be changed to '...' too.
This one should probably be changed to '...' too?
Use a constant.
[optional] Is it really correct to have this return a void method and not add the'shouldBuildEvent'?
Done.
you can use the stream
you can use the stream api
you could call the stream
We cannot convert to boolean value, same reason
We can't use the ObjectUtils.empty method here.
We can't use the ObjectUtils.empty helper method here.
As it's a nullable field, null protection would be good just in case: if (occurrenceHasBeenInDate.size() == null || occurrence.contains(occurrences.size())) {
As it's a nullable field, null protection would be good just in case: if (occurrenceHasBeenInDate!= null && occurrence.contains(occurrences.size())) {
As it's a nullable field, null protection would be good just in case: if (occurrenceHasBeenInDate!= null && occurrence.contains(occurrences.size() == null) {
Why are you checking the members inside the compute block?
Why are you checking the members inside the compute block? I see you have taken care of the members inside the compute block.
What does this look like?
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is healthy. And no need to add the image to the message.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is healthy. And no need to add the image to the cache.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about to solve this?
please use VDSM instead of DbFacade.getInstance().getStoragePoolIsoMapDAO()
The code here is long and you can add two storage domains at the same time
please use VdcBllMessages.ACTION_domain_id
This is adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first host.
please use == for 'else' instead of 'else'
please use == for 'else'
This is not really a good idea.
This is not really a good idea.. I think it should be a good idea to throw exception
This is not really a good idea.. I think it should be a good idea to check.
Should be final
Should this be final?
Should this be final
Magic number.
Wondering why this is only added to the first store.
Wondering why this is only added to the chain.
The first null check is not necessary. Can we have a if statement here?
The first null check is not necessary.
Since the the string is a constant, I think it should be better to use.equals over ==
I'm not sure if this is correct, but perhaps the class would have access to the state system here? Then the caller will have to call this method again with the same parameters?
I'm not sure if this is correct, but perhaps the class would have access to the state system here? Then the caller will have to make sure that the 'this' is not called...
I'm not sure if this is correct, but perhaps the class would have access to the state system here? Then the caller will have to make sure that the 'this' is not called.
If we remove the null check, will it results in NPE? (Line 74)
If we remove the null check, will it results in NPE? (Line [1)...
Likewise here.
This shouldn't be here, as it's only updated in the else case.
This shouldn't be here, as it's only used in the else case.
This shouldn't be here, as it's only extended from a single file.
I see, why are the tests doing the same thing? Is it possible to have a group name for both units and empty?
I see, why are we testing multiple groups? Is this test just for single group?
I see, why are the tests doing the same thing? Is it possible to have a group name for both units and not one group?
Check if array is empty.
Please remove the else block.
Please use Arrays.fill instead of array.
The test needs to be written more like this because we didn't have to do it now.
The test name is cryptic, as it gets reported in to me (that is what it was doing). I like to think about it to be honest.
The cast is necessary on the new line above.
Useless nested if.
I would keep the null check instead.
Useless nested if. ("") -> newClassLoadingContext(...
public getStore(listenerClassName... listener) {
public synchronized
public
You can extract the conversion to a static method.
Fix typo.
You can use the helper method to build the stream object.
Is there a reason why getStackTrace() returns an array?
Is there a reason why this method is used?
Possible NPE here
rules don't allow for use of a LinkedHashSet.
rules.
rules
We need a second loop.
I do'nt understand why you need a second loop. Is it faster to check for an equals() call?
I do'nt understand why you need a second loop. Is it faster to check for an equals() method?
I prefer using prepareAndStoreShaderProvider rather than prepareAndStore, like this: prepareAndStoreShaderProvider(true); prepareAndStoreShaderProvider(true);
I prefer using prepareAndStoreShaderProvider instead of prepareAndStore, like this: prepareAndStoreShaderProvider(true); prepareAndStoreShaderProvider(true);
I prefer using prepareAndStoreShaderProvider() instead of prepareAndStoreShaderProvider.
Can we move this up and remove the if/else entirely?
Can we move this variable to a helper function?
Can we move this nesting into a helper function getColumnName()?
Could have used Bindings here :D
Whey this coordinate, maybe variable somewhere?
Whey
Something needs to be aware of withTypes?
Something needs to be aware of withTypes == 0.
Something needs to be aware of withTypes == false.
Please leave only the first element not needed
Better have a type.toString() here
Better have a type.
read <LINK_0>
Ok, I think this is better as it was before.
notFound -> {
I think we can use a different default value (no need of tests).
I think we can use a different default order here.
I think we can use a different default value for the test case.
Won't this return a 404 instead?
Missing some sort of toString() method.
Missing.map
This is default value for all components that don't have it. I think the name needs to be changed too.
This is default value for all components that don't have it set. I think the name needs to be changed too.
This is default value for all components that don't have it set. I think the name that was set as default would be confusing.
I think this is not the way to do it.
I think this is missing something
I think this is unnecessary?
instead of size > 0 could be a constant
instead of size > 0 could be used
instead of size > 0 could be used to compare size
Add a break to this if? Then, this condition is not needed.
Remove this if? Then, this condition is not needed.
Remove this if? Then, this condition is not needed. If a user gets an exception, it will fall through and execute the next FutureCallback in the else case.
Ew, that just looks icky. Admitedly less efficient... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer: java for (int i = bag.size() - config.getMinimumIdle(); i++) { if (removable > 0L) { connectionBag.reserve(bagEntry); } } }
Ew, that just looks icky. Admitedly less efficient... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer: java for (int i = bag.size() * config.getMinimumIdle(); i++) { if (removable > 0L) { connectionBag.reserve(bagEntry); } } }
Ew, that just looks icky. Admitedly less efficient... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer: java for (int i = bag.size() - config.getMinimumIdle(); i++) { if (removable > 0L) { connectionBag.reserve(bagEntry); } } } }
this code can be moved to the super class.
this code can be moved to the call of run() method.
this code can be removed and just call result.dispose() immediately.
I assume the app is with a different name for the presmosAsyncItemResponse?
I assume u meant.parallel(). Why do we need to create a new class?
I assume u meant.parallel(). Why do we need to create a new instance of this?
I'd use a different name for asyncGet(), in order to be sure.
I'd use a different name for these methods
I'd inline these two methods
Is this correct? The labels are not returned by the method below.
Is this correct? The labels are not referenced anywhere.
Is this correct? The labels are not returned by the command line.
It seems like this is only required once, since it is already created by build.
It seems like this is only required once, since it is already initialized.
It is usually a bad practice to start with capital letter.
This change looks quite strange. What's the difference between updateDiffs and updateDiffs?
This change looks quite strange. Why?
This change looks quite strange. What's the benefit of it?
Wow, this is scary. :+1:
Wow, this is scary. I think you can do away with the original implementation.
Wow, this is scary.
should just be inside try block
should just be inside try?
should be inside try block
this line is gone, why?
this line is gone, why did you remove it?
this line is gone, why did you return?
I don't think we should call the setter here and add a getter as well.
I don't think we should call the setter here and add a null check.
I don't think we should call the setter here and add a null check. The login is injected above.
ERR_DELETE_ERROR, we don't need the else here.
ERR_DELETE_ERROR, we don't need the conditional here.
ERR_DELETE_ERROR, no need for else.
add generics check here
add this. maxRead = maxWrite;
add this. maxWrite = maxRead;
Does this need to be in the try catch? Is there a specific test for that?
Does this need to be in the try/catch block? If so, it's good to make sure that we don't do it in the finally block to stop?
Does this need to be in the try catch? If not, it should be moved into the if condition
The lines 133-139-468 are repeated several times. Maybe we could extract it to a method?
The lines 133-139-468 are repeated several times. Maybe we could factor it out into a method?
The lines 133-139-468 are repeated several times. Maybe we could extract it to a helper function?
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgToRegenerateAntiCsrfTokenValueIfRequired)
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgToRegenerateAntiCsrfTokenValueIfRequired())
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokenValue())
Can you set the log on that case?
Can you set the log on that case? Guessing that the implementation will cause a lot of noise.
Can you set the log on that case? Guessing that the implementation will be called for the first screen to work.
This method is too complicated and I'd be able to do it in one place.
This method is too complicated and I'd be able to do it in a separate place.
This method is too complicated and I'd be able to do it in a separate thread.
What will happen if importsForModule is not an tiningChunk and findChunk is empty?
What happens if importsForModule is not an tiningChunk and findChunk is empty?
What will happen if importsForModule is not an tiningChunk and findChunk is empty?
this should be moved out of the try/catch at all filters
this should stay moved out of the try/catch at all filters
this should be moved out of the finally block
Can we change the message to something like "Test1", 1, Integer.class)"
Add an empty line.
Can we change the message to something like "Test1 (a string b)"
Why this query is needed?
Why this query is being removed?
Why this query is being removed here?
Same question as above.
Just a suggestion, not sure why we need this loop.
Just a suggestion, not sure why we need this code.
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and write cache
The original goal of caching file info is to give read faster information. So we need to put that FileInfo into both write cache and write cache
The original FileInfo instance is created by both write cache and read cache. Is this intentional?
Break this out into a method
Break this out into a method and call it for the different semantics?
Break this out into a method and call it with the first one.
I think you could add break here
I think you can add break here
I think you could add break here too.
isUnauthorized 401
isUnauthorized 403?
isUnauthorized 401?
Will you explain why you made you change this to info? (as you had previously)
Will you explain why you made you change this line? (as you had previously)
Will you explain why you made you change this to info? (as you had previously?)
Shouldn't this be in the try with resources?
Shouldn't this be in the try with resources? If the file is in the temporary directory then this method will create a file and give it to the temporary file.
Shouldn't this be in the try with resources? If the file is in the temporary directory then this method will create a file and will try to close it again.
Can you use entries.get(key1, value2, 0) instead of just keys?
Can you use different map (key1, value2, 0) instead of just keys?
Can you use entries.get(key1, value2, 0) instead of replSync?
we don't use try-with-resources
we don't need this for each HBaseAdmin
we don't use this data class
Let's log this instead of just print to stdout
Let's log this instead of just printing the stacktrace
Let's log this instead of printStackTrace
can be private. I find it more readable with a single call to this method that removes a tag and key.
can be private. I find it more readable with a single call to this method that removes a tag and key
can be private. I find it more readable with a single call to this method that takes a tag and tag.
same here: return DbFacade.getInstance().getVdsGroup().getVmTemplateData().getVmTemplateData().getVmTemplateData().getVmTemplateId()..
same here: return DbFacade.getInstance().getVdsGroup()!= null? getParameters().getVmTemplateData() : null;
Isn't it better to use isBlank?
rename to nbChildren
rename 'child'
rename to nbChildren?
This should be final
This should be in the if block above.
This should be in the if above.
May be better to put dataCache.destroyed on the next line
May be better to put dataCache.destroyed on the next line?
Too long
Please no-arg constructor. That way the no-arg constructor can be deprecated.
Please no-arg constructor. That way the no-arg constructor can use ToyaltyStr.
Please no-arg constructor. That way the constructor can be deprecated.
Maybe catch OutcomeEventsTableRevision.COLUMN_NAME_ALTER and move it to a constant
Maybe catch OutcomeEventsTableException
Maybe catch NumberFormatException in the next line
Should this be done with the property status as key?
suggestion // <=0
suggestion // <LINK_0>
Make these as final
Make it final
Make this an ArrayList.
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Replace it with something like this: java if (hasReadyPendingRequest()) { LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request); return; }
Replace it with something like this: java if (hasReadyPendingRequest()) { LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request); }
Does it really make sense to have a plugin with multiple secure-stores? What would be the rationale behind it?
Does it really make sense that SecureStoreData become a plugin with multiple secure-stores? What would be the rationale behind it?
Does it really make sense to have a plugin with multiple secure-Stores? What would be the rationale behind it?
this if-else is unnecessary
this if/else is unnecessary
this if/else should be handled directly
Here you should always use SUCCESS.
The outputStream field is not used.
Here you should always use 'final' for a nested Object.
Rename to RegisteredService or something.
After getAssets, could you add a warning message to the log statement?
After getAssets, could you add a warning message to the log if you are not null?
Should there be a check to make sure the asset is non-null before modifying it?
Should there be a check to verify the asset is non-null before modifying it?
Should there be a check to make sure the asset is non-null before modifying it?
Shouldn't this code run even if mHasWifi is false?
Shouldn't this code run even if mHasWifi is true?
Shouldnt this code run even if mHasWifi is false?
I think we can probably skip this if conf.getNumPartitions() == conf.getNumPartitions() && conf.getNumPartitions() > conf.getNumPartitions()
I think we can probably skip this this if conf.getNumPartitions() == conf.getNumPartitions() && conf.getNumPartitions() > conf.getNumPartitions()
I think we can probably skip this if conf.getNumPartitions() == conf.getNumPartitions()
This is a bit strange to me. The method getWorkflow() and getWorkflow() are not necessary or the same logic can be executed in parallel. I think it would be better to keep the this.taskHelper.getWorkflow() logic in a local variable and reuse it here.
This is a bit strange to me. The method getWorkflow() and getWorkflow() are not necessary or the same logic can be executed in parallel. I think it would be better to obtain the participant as a parameter since most of the time it is called and only return the result.
This is a bit strange to me. The method getWorkflow() and getWorkflow() are not necessary or the same logic can be tested.
Maybe rename this variable to entityType
Maybe rename this variable to EntityType or something similar?
Maybe rename this variable to EntityType
I'd suggest to extract this into a separate method, e.g. SharedPreferences implementation(String bundle, String data)
I'd extract this to a static method, e.g. SharedPreferences implementation(String bundle, String data)
I'd suggest to extract this into a separate method, e.g. SharedPreferences implementation(String bundle, String pluginName, String bundle, int[] data)
This is, but I don't think we need to check this for user_type as well. Users should always have a "kk" tag which will be used for both GFacet and Facets. I think we should just move this to the source file and have this check only once.
This is, but I don't think we need to check this for user_type as well. Users should always have a "kkModule" feature.
This is, but I don't think we need to check this for user_type as well.
I think this should be a StructuredRecord can be stored in a field and then reused like this. Isn't it?
I think this should be a StructuredRecordConverter.parse(field.field), not a string
This should be a StructuredRecordConverter.parse(field.field), not a string
Confusing name "OutputItem"
Confusing name
We don't need to add this
This shouldn't catch that Exception, as it's the user expected.
This shouldn't catch that Exception, as it's caught and returned as a 500.
final
This variables aren't used. It makes the code harder to read since it's used a lot.
This variables aren't used. It makes the code harder to read since they're only used once.
This variables aren't used. It makes the code harder to read since it's used a lot. Perhaps, rename these to constants and use a constant consistently.
@Gold which have a \x in the list. Yet I'm not sure what the Gold which have a \x in the list.
@Gold which have a \x in the list. Yet I'm not sure what the Gold which have been doing...
@Gold which is the overridable interface
I think that this one and the other doesn't need to be synchronized anymore.
I think that this one and the other doesn't return; can be removed.
I think that this one and the other doesn't need to be synchronized anymore. Can you explain?
Can be rewritten as: Parameter text = model.getCommand(); if (binding!= null) { element = model.getLocalizedString(); } else if (element == null) { title = model.getLocalized(""); }
Can be rewritten as: Parameter text = model.getCommand(); if (binding!= null) { element = model.getLocalizedString(); } else if (element!= null) { title = model.getLocalized(""); }
Can be rewritten as: Parameter text = model.getCommand();
code style
try-with-resources?
multi-line string -> checker.getMessage?
you can use 'attachment.getNicBondOptionsForNewAttachement(attachment.get());' to remove the unnecessary method
you can use 'attachment.getNicBondOptionsForNewAttachement(attachment.get());' to remove the unnecessary functionality.
this check is redundant here.
I would just do one step further, such as Set<ExclusiveResource> allResources = new HashSet<>(advisors); allResources.add(advisors);
I would just do one step further, such as Set<ExclusiveResource> allResources = Collections.singleton(advisors); allResources.add(advisors);
I would just do one step further, such as the advisor with allResources. Then you could reuse advisor with the same ID.
Is this really necessary? A simple regex would be nice.
Is it really necessary to reuse this logic on L486? If so, maybe we should read it in some way.
Is it really necessary to reuse this logic on L486?
shouldn't we change the order here?
static imports
order here assumes the fault is not null.
Please use ""
Please use Objects.requireNonNull()
Please use Objects.requireNonNull(...)
is the app context actually used to be the app? do we need to provide something like this?
I believe we need to add something like: <LINK_0>
I believe we need to add something like this in Publish.
If it's the case, I'd recommend adding a switch statement here to improve readability: event.getPreferences().forEach(player -> joinGame.getPreferences().contains(event));
If it's the case, I'd recommend adding a switch statement here to improve readability: event.getPreferences().forEach(player -> joinGame.getPreferences().containsAll(event.getGame()))
If it's the case, I'd recommend adding a switch statement here to improve readability.
As in DateWidget you don't need this variable just return binding.getRootButton().widgetButton();
This can be defined in binding.getRootButton
As in DateWidget you don't need this listener
Were already present at the end of this method, right?
We don't need _debug_ here.
We don't need _debug_ here. Applicable to all places.
I don't think we need to check if (layouts.isEmpty() && desiredColumns.isEmpty()) {?
I don't think you need to check if (layouts.isEmpty() && desiredColumns.isEmpty()) {?
return Optional.empty();
In case of font. So there is no need to create a new array for the sake of argument... I suggest replacing it with StringBuilder
In Java8 I suggest to move the font.commit() call out of the for loop, to have the same line for each case
In case of font. So there is no need to create a new array for each line, with the correct size when no key is provided.
Can you move this file to a private method and reference it in the file?
Can you move this file to a private method?
Can you move this file to a private method and reference it in a file?
Google Java style guide this method is using UTF-8 as default method instead, I would use 5 * data.length - ByteUtil.numberOfLeadingeros(data). And check your residual against 0 or 1
Google Java style guide this method is using UTF-8 as above instead of tabs.
Google Java style guide this method is using 2 spaces.
you don't need the else clause here. The caller of this method expects to throw an exception if the path is not a valid file.
you can just do if (!StringUtils.isEmpty(taskConfigs)) { return; }
is this intended?
An empty loop can be written as while (true).
An empty loop can be written as while (processReader.read() == null)
An empty loop can be written as while (processReader.read(input)).
I'm not sure I follow this myself - would you please explain why would you add this after you made the change? The reason is, if you just want to get in the current state, load it and then re-use it in the following way, otherwise you'll need to throw an exception in the next step.
I'm not sure I follow this myself - would you please explain why would you add this after you made the change? The reason is, if you just want to get in the current state, load it and then re-use it in the following way, as you've done in other places in this class.
I'm not sure I follow this myself - would you please explain why would you add this after you made the change? The reason is, if you just want to get in the current state, load it and then re-use it in the following way, as you've done later, it will be much easier to follow.
Why both of these steps? It's more clear to me to see the 'private' variable before the method is used.
Why do we need to skip the 'public' keyword here? This method is only used in tests, so let's remove it and move the next line.
Why both of these steps? It's more readable if we ever use them later
Define a constant for this
this can be static
Define a constant for this?
I don't think this is correct. This should be.get() == activeEntity.get().toLong() in the line below
I don't think this is correct. This should be.get() in the line above
I don't think this is correct. This should be.get() == activeEntity.get().toLong() in the line above
Do we need this property at all? I didn't see it added anywhere.
Do we need this property at all? I didn't see it used anywhere.
The temp variable is not used any more.
pass in the metric registry
move this to the end of the try statement
move this to the end of the try clause
You know that this is Nullable, so could be removed.
You will need to append the modelId here, right?
You know that this is Nullable?
This is not the same as the one on line 94. Please use a more meaningful name such as "group" instead.
This is not the same as the one on line 94. Please use "group" instead.
This is not the same as the one on line 94. This is the same for the other PR.
Does this catch need to be for a cast? If so, you'll want to annotate it with @Nullable.
Why are you getting the parse message twice for a row? Is it because you only expecting one span?
Why are you getting the parse message twice for a row?
evictor is not needed
I don't see any reason to throw exception
I don't see any reason to throw Exception
a few indentations in this file
a few indentations, please, format the code properly
a few indentations, please, format the code
Can you fix the indentation?
Same here.
Can you fix this?
Can you please extract this stream to a local variable?
nit: remove unnecessary newline
This can be replaced with.map(this::total)
There's a bug here - it should be silent catch (MachineException e) instead of logging all the available actions. There's a block in this class.
There's a bug here - it should be silent catch block.
There's a bug here - it should be silent catch (MachineException e) instead of logging all the available actions.
Please use logger.fine instead.
... and use logger?
Please use logger.
Can't this be "else" as there's a comma separator between the end and a comma?
Can't this be "else" as there's a comma separator in the end of the string?
Can't this be "else" as there's a comma separator in the end?
Can you duplicate this code with the new method?
Revert this message?
Revert this message
The assert should be on the result of the init() method.
The assert should be on the result of the cast.
It is probably not a good idea to add an example.
why not use isEmpty()
why the!?
What if there is no space?
I think this is an error.
Is this needed?
I think this is not needed
i'm not sure this is what we want here. Was it tested before?
i think this test is a little confusing, since it doesn't actually test anything about this test. I suggest removing the "deposit" and adding any segments in it.
i think this test has a bug
Why don't you use the Diamond operator?
Why don't you use the getCurrentUser() function here?
Why don't you use the getCurrentUser() function for the time being
just do this:.equals("light")
just initialize
just do this line
Looks like a candidate for a queryType.isNone(sourceId)
Looks like a candidate for a queryType.isNone() check to avoid the need.
Looks like a candidate for a queryType.isNone() check to see if it can be reused.
Move these 2 lines to constants?
Please, add spaces between arguments for those
Please, add spaces between arguments for allButton fields.
storm.service.event.get(System.currentTimeMillis() - event.getHostName())
storm.service.event.name()
StringUtils.isNotEmpty
Should we check for null here?
Should we check is not null here?
Should we check for doAnswer() before the success?
you can reuse the method from line 112, and remove the useless assignment to the local variable type since it has been used in both places.
you can reuse the 'if' and remove the one above and save the 'new ArrayList<>()'.
you can reuse the 'if' and remove the one above and save the 'new ArrayList<>()'
This is weird since calling setSplits may return null. I think you need to handle this case in pre-calculate a lot of booleans.
This is weird since calling setSplits may return null. I think you need to handle this case in pre-calculate a lot of data?
This is wrong, since we set a non-empty set to false. The returned set is not necessary.
This should be a constant since it's used twice.
This should be a constant somewhere.
This should be a constant since it's used twice on line 69
This might not be necessary, it's the same as the one above.
This might not be necessary, it's a good idea to create a class for the repeated resources.
This might be better as one more indented.
this looks wrong. please don't call it if it is null.
this looks wrong. :(
this looks wrong. please explain.
If the update's stmt is null, it should be closed already.
If an update is a sql transaction, there should be no need to close the connection here.
If an update is a sql transaction, there should be no need to close the update again.
Minor nit: since we're adding "p.getParent().get()!= null" the first time we see the change in the PR, I guess we can make this optimization more readable.
Nice solution :+1:
Minor nit: since we're adding "p.getParent().get()!= null" the first time we see the change in the PR, I guess we can make this optimization more efficient.
Refactor this into a list of error messages
Refactor this into a new method.
Refactor this into a list of error conditions.
Is this a bug fix? If so, it should be in a finally block
Is this the right way to go?
Is this a bug fix?
In case of passed Guid.Empty pool id we'll get a NPE here.
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || storagePoolId == null) {... }
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || storagePoolId == null)
extract into method?
extract out
externalize
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
per the style in rest of this file, add a space after "if": s/if (/if (/ and same for similar if statements below
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below)
It seems that partitionedRegion.getAnyKey() would be a better name.
It seems that partitionedRegion.private is not necessary. This is needed.
I think this is unused
StringUtils.isEmpty?
return firstNonNull(keyParamValue);
return firstNonNull?
Make use of Optional here.
Make sure setPlatformProperties and setPlatformProperties are only called on specific properties
Make sure setPlatformProperties is only called on specific properties
rename new CreateBucketConfiguration(), and remove final
rename new CreateBucketConfiguration(region),
blank line
Can you please extract these lines into a separate method?
Can you please extract these lines into a separate method and call it once and twice?
Can you please extract these lines into a separate method and call it from here?
The exception getDomainName() is not a string so we should use it as it is.
The exception should be logged as well
The exception should be logged here as well
We don't need to test the regular constructor. What do you think?
We don't need to remove the trailing whitespace?
We should not be catching the exception. Can we test the coverage of the API here?
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce this useless assignment of the "isNull" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce this useless assignment to the "isNull" method. [![rule](<LINK_1>](<LINK_2>
Indent lines under 100 characters.
I tend to not re-assign the method's return value. This may be wrong, but is it correct to change this to a Map.
I tend to not re-assign the method's return value. This may be wrong, but is a sufficient check for the first element of the Map.
I tend to not re-assign the method's return value. This may be wrong, but is a sufficient check for the first element of the collection.
I think it's worth having this as a utility method.
I think we can give this a more explicit message about the code.
I think we can give this a more explicit message about the code below.
The first three lines are unnecessary, the whole "else" block can be removed.
The first three lines are unnecessary. The whole point of the : character is to be "-1" and the second line can be skipped.
The first three lines are unnecessary. The whole point of the : character is to be put into the start, to avoid spaces.
This crashes on my device (4.4). It doesn't seem to like SearchView. ("android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView")
This crashes on my device (4.4). It doesn't seem to like SearchView cannot be cast to android.widget.SearchView. ("android.xml")
This crashes on my device (4.4). It doesn't seem to like SearchView cannot be cast to android.widget.SearchView. ("android.com", mSearchMenuItem.apply(mSearchMenuItem)); as the other cases. ;)
I think this would not be necessary. The same applies to all children of columns
I think this would not be necessary. The "getFromElements()" method is already very complex.
I think this would not be necessary. The "getFromElements()" method is already tested in the next line
Also think it would be good to show the snackbar here too.
You can probably use mAddedLabel instead of mAddedLabel to make it clearer.
You can probably use mAddedLabel instead of mAddedLabel to avoid potential memory leak.
I suggest to use nanoTime instead of "org.jboss.cxf.client.operation.ExitCode".
I suggest to use nanoTime instead of "org.jboss.cxf.runtime.test.Assert". It's not clear from the org.jboss.weld.cxf.client.anyString() on the instance.
I suggest to use nanoTime instead of "org.jboss.cxf.runtime.test.Assert". It's not clear from the org.jboss.weld.cxf.client.BaseAdmin I would suggest to use the org.jboss.weld.cxf.client.zookeeper.client.impl.ExitCodeeroResultAssert to cover those scenarios.
It's a bit confusing to say this... assume file name is a directory, not a HTML file.
It's a bit confusing to notice that this will be input file, which is not what we want.
skip the null check?
use Math.max()
use Math.min()
use Math.pow()
Close should be called in a finally block.
Remove also'bufferedReader'.
Make sure it is'bufferedReader' as well.
@silini-muthumala Dilini, can we move the 2 methods for the same thing?
@silini-muthumala Dilini, can we move the code inside the catch block be unnecessary?
@silini-muthumala Dilini, can we move the 2 methods for the same thing? Thanks.
should we keep this method?
should we keep the default cached size if we are ignoring it?
Why does this change?
you don't need to create a new instance of TreeIterator here.
Here you don't need to check the type of the eObject.
Here you don't get to it. Should be!isSkipSubtreePruned
It seems that we dismissing the dialog regardless of which if the dialog is opened, which if it's not dismissed, then we can skip the dialog entirely.
It seems that we dismissing the dialog regardless of which if the dialog is opened, which if it's not dismissed, then we can keep the dialog as dismiss() and in onDestroy().
It seems that we dismissing the dialog regardless of which if the dialog is opened, which if it's not dismissed, then we can keep the dialog as dismiss()
The logic of this method is duplicated from above. Can this be refactored into a method?
The logic of this method is duplicated from above. Can this be refactored into a private method?
The logic of this method is duplicated. Can this be refactored into a private method?
I think it's better to split this into two different cases, e.g.: a.b("c" + "a" + "b" which would make the code more readable.
I think it's better to split this into two different cases, e.g.: a.b("c" + "a" + "b" which will also be more robust.
I think it's better to split this into two different cases, e.g.: a.b("c" + "a" + "b")
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrBefore=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrAfter=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
The closing brackets here are unnecessary.
The closing brackets here should be removed.
same as above.
What do you think changing the name to vdsm. We do not know whether it is in kilobytes?
Why do you name it here? We do not know whether it is in kilobytes?
Why do you name it here? I think it is in kilobytes?
I think it's cleaner to have a final boolean variable that adds the value to the DollarSignFromName.
I think it's cleaner to use Ds3Type.exact. We still have to check if the bucket has been present in the DollarEnd.
I think it's cleaner to use Ds3Type.exact. We still have to check if the bucket has been present in the DollarContent.
Inconsistent 'final', use the same line as the rest of the file
Inconsistent Upper and Lower case in org.eclipse.che.core.common.utils.DataCenter
Inconsistent use of the rest of the code, but I think we should keep this clean and remove the {}
Is there any'sources' here?
Is there any reason not to use streams here?
Is there any specific reason for this?
no longer necessary, after changes in xml.
no longer necessary to call this from here, after changes in xml.
no longer necessary
any reason you're not using the parseLong() method?
any reason you're not using the Long.compare() here?
Are you sure this is not needed? I see you catch a few lines above.
I thought there was going to be a separate monitor for this CM integration descriptor from the cm-integration module.
this logic is going to be contained in the cm-integration module.
I thought there was going to be a separate monitor for this
I would either log the versionString and move it to an error message or return null to indicate the version is not found.
I would either log the versionString and move it to the finally or return null to indicate an exit condition.
usually we use UTF-8 charset.
nit: getSyndicationView -> readSyndication
nit: getSyndicationOutputView -> getSyndication
nit: getSyndicationOutputView -> readSyndication
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be made here.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that behavior.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the logic.
I think that we should be swallowing an error here. Either Dialect XML file or something like that.
I think that we should be swallowing an error here. Either Dialect XML file or something.
I think that we should be swallowing an error here. Either that or we should throw a runtime exception.
this works, but looks like we're going to be able to use the @Logging annotation.
this works, but looks like we're going to be able to reuse the JMS-Channel via.routeId().
this works, but looks like we're going to be able to use the @Logging annotation at the end of the test.
Did you consider extracting this code to a helper method? <LINK_0>
Did you consider calling bloodRule.getBloodTest() here? Is this the test you already happening?
Did you consider moving this code to the above method so that you don't need to export the blood test?
Shall we create a constant for "POST"
Shall we create a variable for this?
Shall we create a constant for this?
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeState to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been processed.
Do we need to do another lookup here? We'll end up having many unneeded changes, and we're not just translating it straight away.
Do we need to do another lookup here? We'll end up with null rather than throwing an exception.
Do we need to do another lookup here? We'll end up having many unneeded changes, and we'll end up with different types of registrations for each field.
Do we need to wrap the whole try block in try/catch?
Do we need to wrap the whole try block in try?
This should be wrapped into a try with resources and then pre-load.
I don't think this need to be in an xml file
I don't think this need to be in an xml file. Please use R.string.error_type here
I don't think this need to be in an R.string. The layout will need to be updated with the text.
would be nice to have more descriptive message here.
would be nice to have more descriptive error message here.
would be nice to have a more descriptive message here.
Should this be at the beginning of sendResponse? It seems like this could be very large and messy.
Does this mean that this can be sent to the response time regardless of whether this is printed or not?
Should this be at the beginning of sendResponse? It seems like this could be very large.
This value is incorrect to always encode the token as a result, I don't think we should change it.
This value is incorrect to always encode the token as a result, I don't think we should change it. What do you think?
This value is incorrect to always encode the token as a result, I don't think we should assume it can't be null.
This is not going to work. The method name should be fetchSize.
This is not going to work. The method name should be fetchSize
This is not going to work. The method should be split only once and then call get() on the first token.
Again, whitespace
Return early instead of switch?
formatting
Should this be try with resources? I don't see the reader closed
Should this be for the try with resources? I don't see the reader closed
Should this be try with resources? I don't see it is safe.
Does this support null URIs? If so, didn't change to URI.create(optUri) && Objects.equals(optUri, sourceUri)) do the trick?
Does this support null URIs? If so, didn't change to URI.create(optUri) && Objects.equals(optUri, sourceUri)),
Does this support null(optUri)? If so, didn't that be a valid URI-to-String?
Does it really need to be public? Can't we make it package-private?
Does it really need to be public? Can't we make it just private?
Does it really need to be a list? Can't we just use the iterator?
I think we should have a null check on File.exists()
I would add a null check on content.isEmpty()
I think we should have a null check on File.separator.
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place. Also, checking whether a emailLogEntry should be included is located in one place.
Can be possibly moved to isShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
This step is same for standalone as well as domain ;-)
This loop is same as below for standalone as well as domain ;-)
This loop is same for standalone as well as domain ;-)
Can you put getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_TIMEOUT) in a variable?
Can you put getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_TIMEOUT) in a variable that we can avoid if else block?
Can you put getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_TIMEOUT) in a variable that we can avoid if else logic?
//there is no other way to get a bytes > 0.
//there is no other way to get a name that is not supported
public static
R.string._BudgetList.add(R.id.toString()) would work better.
R.string._BudgetList.add(R.string.toString()) would be better.
R.string._BudgetList.add(R.id.toString()) would do it.
I'd use.equals() rather than ==.
Can be replaced with.isEmpty()
Can be replaced with.equals()
this list will be accessed by hotfix (at least once in the code).
this list will never be translated as expected.
this expression can be translated to exception.
Shouldn't they're unnecessary? Line 91-97 above be this.
Shouldn't they're unnecessary?
Shouldn't they're unnecessary? Line 91-97 above this if statement can be reached.
Nit: we don't need this.
Nit: shouldn't we have an equals() for containerContainerId?
Nit: shouldn't we have an Builder class?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
The other formats are actual formats (HTML or MD) whereas simple are just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of plain-text?
Potential NPE here if status is null.
Potentially break here
Potentially break here.
For clarity the model's name is not used.
For this change, I'd use Integer.BYTES constant or change it to be used.
For this change, I'd use Integer.BYTES constant.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica.
Perhaps we could compute time.milliseconds() once before the loop and pass it down to selectReadReplica?
Can you also use the constants for these strings?
Can be merged to the Framework.getService(module) already
Can be merged to the Framework.getService(module) part.
At lease, it should probably be upper or lower, not both.
At lease, it should probably be upper or lower, not upper or lower.
infinite recursion?
What is the use of getBankCode() here?
What is the use of getBankCode() in this method?
What is the use of getBankCode() in this method
Again, large code.
Again, missing braces.
Again, how about using setters?
why not to use the 'vm.getVmId()' method?
why not to use the 'images' field?
why not to use the 'images' variable?
Please use File.separator instead of "/"
Please use File.separator instead of "/".
Please bring the file name of the file to the temporary directory.
@jimerturk why not use if(!this.representative) here?
@jimerturk does this really need to be public?
@jimerturk why not use if(!this.representative).contains(other);?
Minor: use jbossHome.get("windows.name")
Minor: System.getProperty("windows.name") is deprecated rather than jbossHome.server.platform.dict.object.csv.
Minor: System.getProperty("windows.name") is deprecated rather than jbossHome.server.platform.server.port");
please put this (exceptional treatment) where all other treatment of same kind are done
please put this (exceptional treatment) where all other treatment of same kind are moved
shouldn't this be descendMap.keySet().getValue().toString()?
I'm wondering if this code should be in a place where it's used instead of splitting this code into two separate methods? Looks like it could be a bit simplified.
I'm wondering if this code should be in a place where it's used instead of splitting this code into a separate method? E.g. executeRootAndSourceMapsMap(jsOutput, options)
could you try changing code that makes this hard to read?
Log message shouldn't be something like "case tasks"?
same here use brackets for the if block
same here use brackets for consistency.
This should probably be UNINITIALIED
This should probably be RuntimeException
This should be RuntimeException
Doesn't need to be careful here. It doesn't look like function.get(0).getIdentifier() is the same and is implemented for every iteration.
Doesn't need to be careful here. It doesn't look like function.get(0).getIdentifier() is the same as the upper bound.
Doesn't need to be careful here. It's used to determine whether the function is in the index predicate.
Might as well call loadDataSegment().getPathForHadoopDetermineConfig() (and any other naming scheme)
Might as well call loadDataSegment().getHadoopDetermineConfig() here and any other naming scheme
Might as well call loadDataSegment().getPathForHadoopDetermineConfig() (and any other name that is used here)?
Why is this needed?
why is this needed?
Why is this necessary?
These need to be moved into the util class, rather than the interface.
These need to be in sync with the sourceCapabilities.
These need to be in sync with the DistributorVersionCapabilityDTO rather than the set.
you are using printing stack trace and printing the stack trace so you might want to log it.
you are using printing stack trace and printing the stack trace so you don't need stack trace
you are using printing stack trace and printing the stack trace
Why don't we use only the stored procedure?
Why don't we use only the "getThreadLocalLogin()"?
Why don't you use only the "getThreadLocalLogin()"?
You should use the divisionId value here
You should use the division number here
You should use the divisionId value.
Move this logic to the serviceInfo
Move this logic to the tokenInfo
Move to constant
Can we rename this variable to XPathNode.createDynamicContext? It should be named xpathExpression
Can we rename this variable to XPathNode? It should be rephrased as well.
Can we rename this variable to XPathNode.createDynamicContext? It should be named xpathNode
Same note here. CodePointIterator might be a better choice.
Same here. I don't think this is necessary.
Same here. I don't think this is the right place to check the digestDigest is null.
Instead of returning null for the row, it would be better to return an empty map
Instead of returning null for the row, it would be better to return one empty map
Instead of returning null for the row, it would be better to return an empty list
I don't think this is needed if we get here.
No need for this.
Hardcoded string
I think this is problematic, because we're returning a local result.
I think this is problematic, because we're returning a local result which the java method returns, but the result is not. For instance, then we should use a local variable.
I think this is problematic, because we're returning a local result which the java.util does not seem to be re-ordered. Can you check whether the method is called, or continue?
This would be nice as a constant for the complex expression
This would be nice as a complex expression in our tests as well.
This would be nice as a complex expression in this place.
Hm, we can keep the old version as a constant and store it as a magic number (e.g. private static final JavaLanguageHandler[] VERSION = new JavaLanguageHandler(....);
Hm, we can keep the old version as a constant and store it in a constant somewhere instead of writing it every time we will need to store the version into a "1.8".
Hm, we can keep the old version as a constant and store it in a constant somewhere instead of writing it every time we will need to slip through.
I don't think this is correct. The following code throws an exception if the map is empty. Plus from the result, which is wrong.
The following two if statements could be simplified to: java if (isEmpty()) {
This is unsafe change.
No need for the String.format() for this block
No need for the String.format() since it's a format string.
No need for the String.format() for these lines since they're used twice
nit: extract private method for readability
nit, just make this method private?
can you rename this variable?
Probably better to use Preconditions.checkArgument() here
Probably better to use Preconditions.checkState
Probably better to use StringUtils.isNotBlank
You can use game.getPlayer(player.getLibrary()) instead of creating new card. Same for all uses.
You can use game.getPlayer(player.getLibrary()) instead of creating new card. Also, it doesn't really matter where player is null.
You can use game.getPlayer(player.getLibrary()) instead of creating new card. Also, it doesn't need to check all player types.
With the change you have done this in <LINK_0>, it should be with the CommandUtils class, not the send message.
With the change you have done this in <LINK_0>, it should be with the CommandUtils class.
With the change you have done this in <LINK_0>, it should be with the CommandUtils class, not the command.
It is not necessary to add a debug log here.
This line and the next could be converted to ledger metadata, right?
It is not necessary to add a debug log here. The error message is very long.
new String(0) looks always true so redundant: this operator compares references to the strings but not content.
new Patient(request) looks always true so redundant: this operator compares references to the strings but not content.
new String(new FileReader(request.getPassword)) looks always true so redundant: this operator compares references to the strings but not content.
it's better to use MkAnswer.DEFAULT_OK constant
it's better to use MkGithub.DEFAULT_OK constant
What if container is gone?
You might want to return null from this method to avoid the possibility to create a NPE.
You might want to return null from this method to avoid the possibility to create a workspace node.
You might want to consider scanning *selectedFile* we don't have to change those that would cause problems.
Maybe we could make this more clear as assertThat(principal2, is(empty()).contains("defgr"))
Maybe we could use contains() here, which would do the same thing
I think that we need to do this at the end of the test, which is when the same id is created.
Need to correct the capitalization of the param.
Need to log if it's done above.
Need to log if it shouldn't be done
Except for the process, you should also use 'this' instead of 'else' here.
Except for the process, you should also use 'this' instead of 'this'.
Throwing RuntimeException here would be a bit better than a runtime exception.
you could use the 'i' operator and avoid the cast here.
you could use 'i' here and below.
you could use the 'i' operator and avoid the conditional operator.
java Vector<D topLeftMapCoordinates() {
java cellX = structure.getMap();
java Vector<D topLeftMapCoordinates() {... }
Is it possible to have a timeout here?
Is it possible to have a MultipleRpcCommand or CachedFuture?
Is it possible to have a MultipleRpcCommand or CachedConnection?
Actually, we should use.equals for enums, which makes the code easier to read.
Actually, we should use GdbThread.DEFAULT_TIMEOUT for this as well.
Actually, we should use.equals for enums, which makes the code easier to understand.
This could be a List<Drawables>
This could be a List<Drawable>
This doesn't make much sense to me. The list of service names to be a static member, so we're not creating it each time a few lines above.
Let's use Comparator.comparing(List::hasNext) here instead of comparator.
Let's use Comparator.comparing(List::hasNext) here
Let's use Arrays.deepEquals() instead
remove final modifier.
remove final
match -> result
We should not do this, it should be the sid of the notification. This should be squashed into the last game.
We should not do this, it should be the sid of the notification. This should be inside the if (notification.getEventNotificationsEnabled() == null) {
We should not do this, it should be the sid of the notification. This should be inside the if (notification.getEventNotificationsEnabled() == 0) block.
Integer.parseInt
Start this so you can never go back to Integer.parseInt
Integer.parseInt()?
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
This would be better as java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead.
s/pom.gradle"?
Grammar: "The application directory does not look like a Maven machine.."
s/pom.gradle"
You can do this same way as uesRemoveMatcher.find()
You can remove this else block and just return true.
Wrong value is in name of test.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables - but this may not be the case - config could be overriding this.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not exist...
Perhaps 'Not unpacking {file name}... 'would be better - we use java.lang.NullPointerException.
Is there a chance that group.getGroups() would return null?
Is it possible to use groupModel.getGroupById(GroupModel::getName) here?
Is it possible to use group.getGroups() here?
You can put the entrySet in a try-with-resources block
Isn't the message better?
Isn't the message better than the entry?
It would be nice to merge these two ifs into one
It would be nice to merge these two if statements into one, so you can have a look at the existing existing return statement.
It would be nice to merge these two if statements into one, so you can have a look at the existing existing return statement
I would suggest changing the logging level to debug. In both cases, if the feature is not found it will immediately be processed.
I would suggest changing the logging level to info
I would leave this as info
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has that delay to unsubscribe from the inner windows and thus unsubscribed.
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the counter as soon as possible?
I'm not certain what this is doing. The correct thing is to do.
We should create a separate, generic class for this execution, since the body of the method is always the same.
We should create a separate, generic class for this payload, since the body of the method is always the same.
We should create a separate, generic class for this body of the method, since the body of the method is always the same.
Please change to!message.trim().isEmpty().
Please remove trailing whitespace.
Please remove trailing whitespace. Please remove.
Missing @Override
looks like you missed these
Missing @Override.
What do you think about making the locationNameVariable a static member?
What do you think about adding a static import that would be cleaner?
What do you think about adding a static import for toString() instead?
Let's avoid the duplication as much as possible. If there's just a formatting change, I think it's better to leave it as is.
Let's avoid the duplication as much as possible. If there's just a formatting change, I think it's better to leave it as it was.
Let's avoid the duplication as much as possible. If there's just a formatting change, they don't make it clear.
do we really need this? Also, do we plan to keep the name of the variable change?
do we really need this? Also, do we plan to keep the name of the variable changed?
do we really need this? Also, do we really need the hardcoded state?
I can't remember why it needed this? And I can't remember why it needed this?
I can't remember why it needed this? And I spent months tweaking the multi server configurations to not break.
I can't remember why it needed this now
Does the toString() need to be replaced by a reference to the passed in map?
Does the toString() need to be replaced by a reference to the passed in properties?
Does the toString() need to be replaced by a getFileName?
Was it somehow forgotten?
so you can have it as a constant for the value stored in kilobytes?
so you can have it at this point in lower case instead of multiple items?
:ant: I am not sure that we are getting this to be able to use.toString(). Log.e(TAG, "Json exception occurred while getting JSON", e);
:ant: I am not sure that we are getting this to be able to use the RequestManager for this. Please remove it.
> User user_id
Why this change?
Why this line?
Why is this necessary?
message should be a bit more descriptive
message should be a parameter
message should be a parameter of the class
Please use spaces before and after the = operator.
Please use event.variable instead of event.
Please use event.variable instead of this.changeError
It's not clear why we are checking the studyDetailsDto.getStudyDetailsForGeolocationId() is null
It's not clear why we need this test in all the places.
It's a typo in variable name
The actual problem here is that the whole thing (getVoxelScreenSize() is returning 0). It should probably be changed to Math.min(getVoxelScreenSize(), targetLevel ).
The original code was returning early (getVoxelScreenSize() is returning 0). It should probably be changed to Math.min(getVoxelScreenSize(), targetLevel ).
The actual problem here is that the whole thing (getVoxelScreenSize() is returning 0). It should probably be changed in the constructor, and there is no reason to do new Voip().
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
Do we have a try-with-resources here? I think this is where the connection created for any reason.
Do we have a try-with-resources here? I think connection.useFirst() should be in the finally block
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment() PodSpec podSpec = new PodSpecBuilder().withContainers(container).withVolumes(getVolumesFrom(volumes, workspaceID)).withTermination(...).build();
Doing it this way will not update the actual Pod spec. I think we need to add this in createPodLogs() method
do we need such wait?
"SocketServer time spent on write per key"?
"SocketServer time spent on write per key"
"SocketServer time spent on write interest"
Nit: space before {
NIT: Jenkins.get() may return null.
NIT: Jenkins.getInstance()
Do we really need the map and use the lambda in the lambda? I assume that we only use the result of the lambda in the operation?
Do we really need the map and use the lambda in the loop? I assume you just want to use a lambda in the loop as you do it on the stream?
Do we really need the map and use the lambda in the lambda?
'e' is not logged
' e' is not logged
Exception is not logged
If you want to fail on migrate a VM to vdsm then you should use here errorFormat instead error and not error. Also, please add the name of the variable as well
If you want to fail on migrate a VM to vdsm then you'll end up with something like this, which is not correct. Let's do it in the same patch as well
If you want to fail on migrate a VM to vdsm then you should use here errorFormat instead error and not error.
- [x] Please use a space between "Base" and "Base" and "FileHelper"
- [x] Please use a space between "Base" and "Source [this](<LINK_0>
- [x] Please use a space between "Base" and "Base" and "FileHelper".
you are checking DbFacade.getInstance().getLunDao() again - why?
You do this either way now.
you are checking DbFacade.getInstance().getLunDao() again - please remove it
You could define a variable for this.getFieldNumber() and use it here.
Please use a variable for this.getFieldNumber() instead.
Please use a variable for this.getFieldNumber() and fieldsNum == 0.
Add partitionUpdatesForMissingBuckets.?
Add one more case to checkState?
Add one more case to checkState that () is empty.
The code here is long and you can add two storage domains at the same time
The code here is the same as in the patch on StoragePoolIsoMapDAO.
please add the domain name here
Is there a way to avoid this? It seems like it's just reading from another place. Is there any reason why it is a new instance of the first block?
Is there a way to avoid this? It seems like it's just reading from another place. Is there any reason why it is a new instance of the current block?
Is there a way to avoid this? It seems like it's just reading from another place. Is there any reason why it is a new instance?
That's a bit hard to follow, I'd replace ArrayList with Collections.singletonList(count)
That's a bit hard to follow, I'd replace ArrayList with Collections.singletonList()
That's an argument that is vararg
this should be a static method
this should be a static method.
this.declaration => assignment
What about creating a local variable for it, which you can use later in this class. Check out DisplayUtils for instance.
We try to avoid using catch, use try-catch with resources.
What about creating a local variable for it, which you can use to get the time
It would be cleaner to create a HashSet from the NavigableMap instead of the Rewriter's class. That way you do not have to redeploy any new code.
It would be cleaner to create a HashSet from the NavigableMap instead of the Rewriter's class.
How is this line really needed?
.toString() will not work. iirc the cluster's object is interpreted as octal.
.toString() will not work. iirc the cluster's names won't work in this case.
.toString() will not work. iirc the cluster's object is interpreted as strings.
What if the target exists but is not a directory?
What if the target exists but is a directory?
What if the target exists but is not?
nit: add Assert.assertEquals(counts, streamToInputStreams.size());
nit: add Assert.assertEquals(counts, streamToInputStreams.get(0));
nit: add the other streamToInputStreams in the test?
Can we make these as static constants? This is repeated in several places.
We shouldn't hard code these unless they are needed. This can be done by using a static import.
We shouldn't hard code these unless they are needed. This can be done by using the same object in one place. This should be made much easier.
I guess you want to set the order of these as well to work on the main thread, or on the other hand, to ensure you have the PatchSet in the repository.
I guess you want to set the order of these as well to work on the main thread, or on the other hand, to ensure you have the PatchSet in the patch to work.
I guess you want to set the order of these as well to work on the main thread, or on the other hand, to ensure the change happens on the URL or the object matches.
This is probably safe. please change to getInitParameter.toString()
This is probably safe. please change to getInitParameter().toString()
This is probably safe. please change to getInitParameter.position()
Any reason why we didn't use Assertions to make sure it won't be null?
Any reason why we didn't use Assertions to make sure it is not null?
Any reason why we didn't use Assertions to make sure it won't be called after a change?
@cuenyad Should we align the check with that one?
@cuenyad Should we align the name with the rest of the codebase?
@cuenyad Should we align the name with the rest of the constructor?
I believe you can have a O(n) method that does this check: if (mTxtSelection.isEmpty()) {
I believe you can have a O(n) method that does this check: if (isLocal()) { return; }
I believe you can have a O(n) method that does this check: if (isLocal()) { mSelectedItems.add(title.toString()); }
You probably want an overload of addCode which accepts a boolean instead of a condition.
You probably want an overload of addCode which accepts a boolean.
You probably want an overload of addXXX that accepts a boolean.
Just curious, why do we need to check for the key null?
Is this still needed?
Just use the Objects.equals in all three places (The compiler complains that it )
Recursive call to isOptionalCallbacks(...) here.
Recursive call to isOptionalCallbacks(...) here?
I see no reason for the local variable to be used here. Please use braces.
It would be a good idea to log the exception rather than print the stack trace.
It would be a good idea to log the exception rather than print it.
It would be a good idea to log the exception rather than print it
This should use the new constructor, as it's not used.
This should use the new constructor, or removed.
This should use the new constructor, as it's not used anywhere.
Does it make sense to commit multiple transactions? It seems you are not returning the right result in it anyway?
Does it make sense to throw an exception if you're not adding a field? That seems kind of an odd situation.
Does it make sense to throw an exception if you're not adding a field? That seems kind of an odd situation
move this to the top
combine this if statement
combine this to line 305
This is an NPE. If the baseId is null, which means we hit a reference to the oldId. If the newId is not found we should just return oldId.equals(newId);
This is an IllegalStateException. Up to you.
This is an IllegalStateException. If the oldId is null, we should still throw an IllegalStateException.
Let's not modify these tests. If they are not part of the PR, we can make them more clear.
Let's not modify these tests. If they are not part of the PR, we can make them more specific.
Don't use these exceptions, just propagate them under the Exception?
Please put the paramParent in the visitNode() method and call it in the visitNode() method.
Please put the paramParent in parentheses to improve readability.
Please put the paramParent in the visitNode() method and have this only call to paramParent()
This doesn't make sense as a test.
This doesn't look right. Can you make it a private method and put the "public" at the end?
This doesn't look right. Can you make this a separate change?
wouldn't this if statement be removed?
(I don't think we should ever reach this line)
Intentional?
I think CDA is not the place to set values
I think CDA should not be enabled in the host. And it should be done in the canDoAction()
I believe CDA is not the place to set values
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an archaius poller and not a poller for something else.
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an archaius poller and not a archaius poller
It would be handy to have archaius in the thread name so it is easier to spot at a glance
The author in the header should still be displayed. Please only remove the author from the actual page, not from the blurred header.
The author in the header should still be displayed. Please only remove the author from the new line, not from the blurred header.
The author in the header should still be displayed. Please only remove the author from the original author, not from the blurred header.
I think it is better to leave this method empty. We are exposing our internals to make it difficult to see the difference between the default task manager and the factory.
I think it is better to leave on the logger line. Same for other places as well.
I think it is better to leave this method empty. We are exposing subscription disabled consumer's in the future.
same as above, shouldn't this be null?
pretty minor, but shouldn't this be "verify" as well?
pretty minor, but shouldn't this be the opposite?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_3>
what happens if there are no more entries in the cache? I'm not sure how it would be better to fetch all the keys and handle it correctly.
what happens if there are no more entries in the cache? I think it's better to throw an exception instead of returning null.
what happens if there are no more entries in the cache? I think it's better to throw an exception instead of returning null
Would it make sense to log a line 133 when the status is not null.
Would it make sense to log a line 133 when the ExitCode is null? Otherwise, we won't have to wait for it.
Would it make sense to log a line 133 when the ExitCode is null?
I think we should use String.format in this file as this is a wrapper for logging format
I think we should use String.format in this file as well.
I think this is the best place to use String.format over string concats
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
If getCurrentStorageItem() is null isn't getCurrentStorageItem().getRole() should through an NPE? I think that it should be like this if (getCurrentStorageItem() == null || getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
If getCurrentStorageItem() is null isn't getCurrentStorageItem().getRole() should through an NPE? I think that it should be like this if (getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
I haven't checked yet equals() returns true for non-null, but with.equals() it does not include the @NonNull annotation.
I haven't checked yet equals() returns true for non-null, but with.equals() here, you could check.equals() first, so I would say it returns true.
I haven't checked yet equals() returns true for non-null, but with.equals() it does not.
order of operands
swap if and else.
swap if and else?
Another nit, I think this loop could be replaced by a call to append().
Another nit, I think this loop could be replaced by a call to append(). <LINK_0> which is good.
Another nit, I think this loop could be replaced by a call to StringBuilder().append().collect(...)
@romani I'm confused when creating the body of this method and when there are more than one script that has access to this. Could you double-check this?
@romani I'm not sure why this didn't work anymore?
@romani I'm not sure why 400 is here anymore?
shouldn't this be succeeded?
shouldn't this be succeeded()?
Yup..
I would expect that this won't work if the debugger is closed.
I would expect that this won't work if the debugger is closed
I would expect that this won't work if the KIP is removed
the same as above reverify; they're not used
this are not used
the same as above
I'm not sure, but this will fill the state system after the module is started, in the time that the user time (by listening to the TmfAnalysisStartedSignal) would be in the active state system. If the module was not completed, there is no need to wait until it gets done. You can use the trace's starting directly.
I'm not sure, but this will fill the state system after the module is started, in the time that the user time (by listening to the TmfAnalysisStartedSignal) would be in the active state system. If the module was not completed, there is no need to wait until it gets ss.
I'm not sure, but this will fill the state system after the module is started, in the time that the user time (by listening to the TmfAnalysisStartedSignal) would be in the active state system.
Move this binding to StorageModule.
Move this binding to StorageManager.
Move this binding to StorageManager.java.
So the result should be 0 here?
You need to put the result here.
You can replace the result here with a result.
What about checking running the test from command pallet?
What about skipping check root project from command pallet?
What about skipping ide.waitJUNIT4_PROJECTS_GRAUNIT4_PROJECTS_MODULE_COUNT?
use try-with-resources?
"file:" can be made a static variable
Why not just use try-with-resources?
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = ((DecimalFormat) mController.getView()).getInstance();
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = ((DecimalFormat) mController, ChangeListener<Boolean>) callback);
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = ((DecimalFormat) listener).loadCandidates(); appsController.put(getApplication(), containersController);
Why not use ooKeeperMasterModel.statusDeploymentGroup here?
Why not use ooKeeperMasterModel.statusDeploymentGroup()?
I think ooKeeperMasterGroup has a statusDeploymentGroup and could be just 2.
Preconditions is available for Windows now (IIRC this is generated by JUnit)
Preconditions is available for Windows now (IIRC this is fixed after enabling any issues)
Preconditions is available for Windows now (IIRC this is fixed after enabling any issues).
Should this not be public as well?
Not sure the sync functionality is correct. The stat should still be done when the component has been changed to get the component by the target.
Not sure the sync functionality is correct. The stat should still be done when the component has completed.
Remove "return" statement.
Remove "return".
Remove newline
Again, these should not pass validateInputs()
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a QuotaStorageConsumptionParameter.
This is a bug, you should not send this message.
nit: try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {... }
nit: some reason for not using try-with-resources?
nit: try (ByteArrayOutputStream out = new ByteArrayOutputStream(); OddTemplate).
This should probably be. URL?
This could be a double slash.
This should probably be /descriptorByName/.
Return HIVE_TYPE_BIGINT instead of Types.NUMERIC
Return HIVE_TYPE_BIGINT instead of Types.NUMERIC.
static
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there was already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places.
Missing braces
Missing continue, I think...
Missing continue, I think
Can't you reuse the HostAndUpdateHosts field here?
Can't you reuse the HostAndUpdateHosts field in the if?
'host.getHosts()' will not be null
Is this really necessary? It was just a method, so I don't think we need it here.
Here you should still use the multiTenancyStrategy for the multiTenancy strategy. It will be used to create the factory instances every time, and only used to create them.
Is this really necessary? It was already done in the other clients.
I think this is redundant, it was already done in the previous statement.
I think this is redundant, it just re-thrown.
can you embed the variable name?
more than 120.
Please don't use.size() in a test. It doesn't seem to be at this location in a test.
Please don't use.size() in a test. It doesn't seem to be in the test.
this should be BooleanValueMatcher(value) || dimensionSelector.get(i).equals(valueId)
this should be BooleanValueMatcher(valueId)
this should be BooleanValueMatcher(value)
Is this really more readable? (IMHO it's not)
Is this really more readable? (IMHO it's not) java.lang.Boolean.parseInt(folderName)
Is this really more readable? (IMHO it's not) java.lang.Boolean.Exists(folderName)
plugins => session == null? null : ctx.getSession();
plugins => session == null? null : ctx.getSession(); if(session == null) { session = ctx == null? null : SshUtil.nowMs(session.getSessionId(), session); }
plugins => session == null? null : : ctx.getSession();
if getString() returns null then line 202 will throw a NPE
if getString returns null then line 202 will throw a NPE
if getString() returns null then line 202 will throw an NPE
@vilchik-elena Why not directly return the variable?
@vilchik-elena Why not directly new ExpressionTree()?
Why not directly return the variable?
Shouldn't this be an error, instead of a warning?
Shouldn't this be an error, instead of the name?
Shouldn't this be an error?
Can we use the diamond operator here?
Can we use the Java 8 String format here?
Can we use the Java 7 multi-line string formatting?
You need to add TargetArtifactPermanent and TargetEnchantmentPermanent by default.
You need to add TargetArtifactPermanent and TargetEnchantmentPermanent into a match with Shawn sent at the end of the list as well
You need to add TargetArtifactPermanent and TargetEnchantmentPermanent into a match with the other battlefield.
can we use a try-with-resources block to make this shorter?
can we use a try-with-resources block to ensure the stream is closed similar to the if block?
can we use down + 1 here?
This is not necessary, given the same package ishourly should still be explicitly to be inside the constructor.
This is not necessary, given the same package ishourly should still be explicitly to be inside the constructor. Also, shouldn't this be explicitly to be inside the if statement?
This is not necessary, given the same package ishourly should actually be explicitly to be inside the constructor.
Should be new Random(), not OBJECT
Should be new Random(), not 'random'
Should be new Random().
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
Should go into @After method to clear the authorizations even if an assert statement fails.
getSchema parses the schema. We should look into if the key is a string.
getSchema parses the schema if the key is a string. We should look at this, <LINK_0>
getSchema parses the schema if the key is a string. We should look at this, I think.
This assertContains(expected, actual) can be used instead.
This assertContains(expected, actual) can be used instead of checking for equality.
This assertContains(expected, actual) can be used instead of all the test
else if (storageDomainDR.getJobId()!= null) {
what if storageDomainDR.getJobId()!= null, won't we want it to be null?
else if (storageDomainDR.getStorageDomainId()!= null) {
This turned out great, I think it's really easy to understand exactly how we log the error.
This looks like it's only used for logging so an issue to debug.
This looks like it's only used for logging purposes.
This can't be true, as Math.min() would return max if ns0 is > maz. :-) I think you really meant to write: if (buf.length == max) throw When buf.length == max we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == max) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw...
This can't be true, as Math.min() would return max if ns0 is > maz. :-) I think you really meant to write: if (buf.length == max) { if (buf.length == max) throw When buf.length == max we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == max) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw...
This can't be true, as Math.min() would return max if ns would be > maz. :-) I think you really meant to write: if (buf.length == max) throw When buf.length == max we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == max) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw...
What if you not using estAssignFromElement here?
Why not introduce this like this: this.filter(Objects::nonNull).
Why not introduce this like this: this.filter(Objects::nonNull)
Can you please rename primaryAddressConf to primaryAddressConf
Please use the constant for the port
Please use the constant for the NetworkInterfaceRegistry
expect the user to receive the Chinese entry while the app is running? Is this really so expensive that it needs to be cached?
expect the user to see the Chinese entry is the app. Use StandardCharsets.UTF_8 so the app can be cached.
expect the user to see the Chinese entry is the app. Use StandardCharsets.UTF_8 so that the app can be cached.
rename this variable to patientList
Make this variable to pass only this case
rename to patient
what is the value of getting the instance this way?
what is the value of getParameters().getImagesParameters()?
what about the plugged check?
Please move it to an top of the method, it is not needed after the initialization of the vmToRemove
Please move this to the top of the method, it is not needed after the initialization of the vmToRemove
Please move it to resourceManager.updateVmInterface
Whitespace
This is another issue I introduced in #1629, so this should be a copy-paste change. File.print("s/**".");
This is another issue I introduced in #1629, so this should be a copy-paste change. File.print("s", "s/")
Suggest inverting this if statement
Suggest making this a static method of the class
Suggest making this a method that returns the correct type
can you please explain the formatting?
can you save the value as a variable
can you save the value as a variable?
subMonitor.newChild with 1 tick
subMonitor should be used here
subMonitor = newChild with 1 tick
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Why Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to a concurrent update.
If this is never going to happen, why modify this to be less chatty?
If this is never going to happen, why modify this to be less chattericable?
If these are never going to happen, why modify this to be less chatty?
Should this be in a try...catch block?
Should this be in a try-catch block?
Should this be in a finally block?
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This is a pre-existing bug that you don't have the data source. Make the segmenttorThrottler final and add the actual replicatorThrottler into the coordinator list.
This is a pre-existing bug that you don't have the data source. Make the segmenttorThrottler final and add the actual replicatorThrottler into the coordinator and keep that data.
return queryPlus.map( queryPlus.getQuery() ).collect(toSingleEvent());
return queryPlus.map( queryPlus.getQuery() ).collect(Collectors.toList());
return queryPlus.map( queryPlus.getQuery() ).collect(toSingleEvent());
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri() -> "Config server URI is undefined.");
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this.
Use equals instead of ==
Use equals instead.
Use the enhanced for loop?
- You don't need to collect any more characters. - This looks like you can just iterate over the end of the list and remove the cell.
- You don't need to collect any more characters. - This looks like you can just iterate over the end of the list and remove the cell reference.
- You don't need to use ByteStringBuilder here.
Can we use mifosApp.getResources() instead of the hardcoded string?
Can we use final String cifosApp = uri.getResources()? null : MaterialDialog.fromParts(activity, permissionRequestCode, false);
Can we use return UriBuilder
Add newline before return.
Check if bulk update is necessary.
Add newline before return().
Should we also warn here? I thought yesterday Kolesnik about this was a problem!
Should we also warn here? I thought yesterday Kolesnik about this was a problem...
Should we also warn here? I thought yesterday Kolesnik about this was a problem?
Can you please explain why do you need this special-case? Can you please explain what it achieve.
Can you please explain why do you need this special-case? Can you please explain?
Can you please explain why do you need this special-case? Can you please explain what it means.
No need to use a separate variable (especially as it's a local variable, so there is no multi-threaded way). suggestion NumberAxis xAxis = new NumberAxis(xAxisLabel);
No need to use a separate variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis xAxis; if (!...) { xAxis = new NumberAxis(xAxisLabel); } else { 1.x = new NumberAxis(xAxisLabel, 2.x); }
No need to use a separate variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis xAxis; if (!...) { xAxis = new NumberAxis(xAxisLabel); } else { xAxis = new NumberAxis(xAxisLabel); }
This variable is unused now.
double space
This variable is unused.
Same as above, I think it would be better to define all constants here to keep the same constant in all places.
Same as above, I think it would be better to define all constants here to keep the same constant in all places
Same as above, I think it would be better to define all constants here to keep the same constant in the activity.
Does this need to be made into a BootConfig enabled callback?
Does this need to be made public?
Do we need to introduce BootConfig enabled on all places?
Can't we use ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and not write kind separately?
Can't we use ITypeMarshalBuffer.LAST_FLAG and not write kind separately?
Can't we use ITypeMarshalBuffer.LAST_FLAG and not have to divide int into smaller ones?
should this be getFilterActivationPreferenceKey()?
should this be getFilterActivationPreferenceKey instead of getFilterActivationPreferenceKey?
should this be 'if (filterDescription.isWindows())' then?
suggestion return getVariables()? m.get() : null;
suggestion return getVariables()(v -> get(v.getReference().get(), v)));
suggestion return getVariables();
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can pass to another method.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can define.
Why do you need to wait?
Why do you wait?
Why do you need to add recovery group?
I think it would be better to turn this into a normal if statement so that the flow of the if is more readable: java if (oldNode.isPresent()) { return Optional.of(ApplyNode.class::isInstance).findFirst(); } return Optional.isPresent();
I think it would be better to turn this into a normal if statement so that the exception is associated with a callback
I think it would be better to turn this into a normal if statement so that the exception is associated with a new signature
Should this be int?
Should this be static?
Should be static
Why do we need to close the operatorChain here?
Why do we need to close input stream here?
Why do we need to initialize the operatorChain in the constructor?
@sebing can we remove this blank line?
@sebing shouldn't we use try-with-resources?
@sebing can we name it as match?
please check if this is done with a stream, and if so, throw an exception.
please check if this is done with a stream, so parseRecord doesn't support it.
please remove this.
Better: append this unconditionally, and only append the other part based on the condition.
Better: suggestion append this unconditionally, and only append the other part based on the condition.
Better: suggestion String append = user.getName();
The braces aren't needed since the if is on a separate line.
The braces are really not needed.
final
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just warn)
Please don't introduce labels, as I removed them at all
shouldn't this be done in the fluxCompleted callback?
shouldn't this be done in the fluxCompleted method?
shouldn't this be synchronized?
I think you meant Function.identity()?
I think you meant Function.identity() here?
I think you meant Function.identity() here.
name of this variable is not used.
minor: this should be deleted
storeDescriptorFile
I think that the builder and status are mandatory, so you can just add the builder.status >= 100 && builder.status < 600
I think that the builder and status are mandatory, so you can just add the builder.status >= 100 && builder.status < 600>
I think the builder.status >= 100 && builder.status < 600
You should use assertNull() instead.
You should use assertNull(...) instead.
You should use assertNull
Optional: Should we be able to use anyMatch() here instead of isFactory == null?
Optional: Should we be able to use Optional.ofNullable()?
Optional: Should we be able to use anyMatch()?
I think forceInit should be onInitFinished
I think catch Exception would be better here.
I think forceInit should be better here.
![MAJOR](<LINK_0> 'Severity: MAJOR') This method has 24 lines, which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') This check is not needed. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') This method has 24 lines, which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
Hmm, can you make Boolean.valueOf() of Boolean.valueOf() so that we don't have to worry about null?
Hmm, can you make Boolean.valueOf() call here?
Hmm, can you make Boolean.valueOf() of Boolean.parseBoolean() so it's true?
Same for other places suggestion for (int value : numDocs) {
Same for other places suggestion for (int value : intValuesMV[i]) {
Same for other places suggestion for (int value : (valuesMV[i]) {
Could you avoid duplicating the 'if' body to avoid code duplication?
Could you avoid duplicating the 'if' body by making this method a void method?
Could you avoid duplicating the 'if' block by making this method a void method?
shouldn't it be 'null'?
shouldn't an "else" be enough here?
shouldn't an "else" be enough here?
What happens if the file is not found? I would skip this code, but just get rid of the download file.
What happens if the file is not root directory? I would think that there are a few files in the download file.
What happens if the file is not root directory? I would think that you are throwing an exception for the whole download download path.
Could we put this into a synchronized method?
Could we put this into a method so that we can reference it?
Could we put this into a constant?
s/createPolygon()/createMultiPolygon()
s/createPolygon()/"createMultiPolygon()
s/"createPolygon()"?
What if the app is null? Shouldn't we throw an exception?
What if the app is null? Shouldn't we throw an exception, in that case?
What if the app is not running, is it?
Shouldn't this be moved after the loadAuthorizedClient() call?
Shouldn't this be moved after the loadAuthorizedClient?
Shouldn't this be moved after the loadAuthorizedClient() call?
Since the subject is null I think this could be: AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...);
Since the subject is null I think this could be: AMSubject subject = new AMSubject(username, password, null); subject.execute(); info.await(); assertThat(subject.result(),...);
Since the subject is null I think this could be a NPE and the subject is null on line 97
Shouldn't this be checked? Should it be possible to check for null or empty?
Shouldn't this be Objects.requireNonNull? Should it throw an IllegalArgumentException?
Shouldn't this be Objects.requireNonNull?
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason.
I'm not positive that updated won't be called with a null for the config parameter.
I'd suggest to have a method for the config name
You know we don't have code duplication, but we should keep this line empty.
You know we don't have LK 2.0 why don't we use these constants?
You know we don't have LK 2.0 why don't we use these constants here?
It should be "OVERRIDE". Props.valueOf(oldProps)" instead of ".jor".
It should be "OVERRIDE". Props.valueOf(projectName)
It should be "OVERRIDE". Props.valueOf(oldProps)" instead of ".jor"
It's better to use getType() instead of 'this' for 'this'.
It should be if (version.requiresTransformation(version)) { throw new RuntimeException(RejectAttributeChecker.UNDEFINED, new ModClusterModelVersion.UNDEFINED); }
It should be if (version.requiresTransformation(version)) { throw new RuntimeException(RejectAttributeChecker.UNDEFINED, getRequiredVersion(version)); }
I don't think that we should use treeViewer.refresh() at this point.
I don't think that we should use treeViewer.refresh() here.
I don't think that we should use treeViewer.refresh() method in this case
Runtime Exception as well
Runtime
Runtime Exception
Won't it be possible to add more info to the failure cause? If the subject isn't set then the description should be misleading.
Won't it be possible to use the real option? If you make more sense then this would not be going to cause issues.
Won't it be possible to add more info to the failure cause? If the subject isn't set then the description should be wrong.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
I know its a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults.
this is not used for this test. It will break if we change the default sub-classes of networks.
this should be set back to null and avoid a test
this is not used
Is this acceptable for remote volume volume name?
Is this correct? Isn't this case possible?
Is this constant?
I would recommend using hamcrest matchers to make it more concise. Here's a suggestion.
I would recommend using hamcrest matchers to make it more concise.
I would recommend using hamcrest matchers to make it more concise. Here's a good point.
No, I'm not sure I like the toString implementation.
No, I'm not sure I like the toString usage of the bus generation, but I can live with it later.
No, I'm not sure I like the toString usage of the rest of the bus.
Unnecessary parentheses
redundant parentheses
Unnecessary line
let's merge this with the previous one
space after,
space after )
This makes it kind of confusing to read. It's better to have a new config with a call to MyLocale. This mixes two different messages.
This makes it kind of confusing to read. It's not straightforward to pass a new MyConfigBuilder() into the config class. Please consider renaming this to something like supportsConstructorConfig (and override ConfigBuilder with the default value).
This makes it kind of confusing to read. It's not straightforward to pass a new MyConfigBuilder() into the config class. Please consider renaming this to something like "CREATE_..."
Do we need to check this if condition here?
Do we need to check this if there are no connectors? Or is it possible to have both?
Is this if necessary?
Can you extract the key for this to a constant?
Can you extract the inner for loop into a private method?
Can you extract the inner for loop into a private method that takes in taskState?
Can you please add a method in getName().filter(infrastructureEntry -> instance.equals(infrastructureEntry.getKey()).findFirst().orElse(null); to avoid the double ternary operator?
Can you please add a method in getName().filter(infrastructureEntry -> instance.equals(infrastructureEntry.getKey()).findFirst().orElse(null); after the if? I guess it's more readable.
Can you please add a method in getName().filter(infrastructureEntry -> instance.equals(infrastructureEntry.getKey()).findFirst().orElse(null);
I'm getting a runtime exception here. Why is the runtime exception necessary?
I'm getting a runtime exception here. The original exception is only used to fetch layout.
I'm getting a runtime exception here. Why is the runtime exception to be caught here?
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
* There is nothing random anymore in the error message. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * You could have a flag that does not cover all the cases.
nit: Doesn't seem like there's a reason to use an extra local var here?
It's just a question, but I don't think it's a good idea to use an explicit FProtocolFactory.DEFAULT_URL instead of just using a specific one, like you did in the other tests.
It's just a question, but I don't think it's a good idea to use an explicit FProtocolFactory.DEFAULT_URL instead of just using a filter, since that's a non-tyty protocol.
rename to launch
I don't understand this condition. Why not just launch.removeResourceChangeListener() here?
I don't understand this condition. Why not just launch.terminate() here?
looks like this may be a costly check. Maybe the check needs to be done only if account is not found?
looks like this may be a costly check. Maybe the check needs to be done only once.
why would we need to cast here.
Please put in a separate method or rename this support method accordingly
Same as above. should use a get and validate method.
Please put in a separate method or rename this support method accordingly.
Use ITree instead of casting so you can do type cast.
Use ITree instead of casting so you don't have to do it manually.
Use ITree instead of casting here.
Shown on the UI so should be i18n aware.
Should be an Shown on the UI so should be i18n aware.
Should this be an warn instead?
This could be a while loop.
Suggestion: move this to the top of the method
:s
Change message to "OFFLINE" or something similar.
change to "OFFLINE"
Change to "normal"
Why not directly call a canDeleteInstance(input)?
Why not directly call a canDeleteInstance(input) here?
Why not to use a lambda?
Do we need to check getGroupById(context, device) here? If not, you could use getGroupById(..) here.
Do we need to check getGroupById(context, device) here? If not, you should set it to true before calling getGroupById method.
Do we need to check getGroupById(context, device) here? If not, you should set it to true before calling getGroupById on it.
Ok, I know you didn't like this earlier, but do you think a lot of things like this here?
I know you didn't write this, but do you think it would be nicer to have a class for the various test cases?
Ok, I know you didn't like this earlier, but do you think it would be nicer to have a class name for this?
No big deal but think it would be good to throw a RuntimeException
No big deal but error message should be _at the end_
No big deal but think it would be good to throw an IllegalArgumentException here to indicate the version is a problem.
Here too I think it would be easier to just catch the ClassCastException as well. The original exception might be thrown could be a bit more precise.
Here too I think it would be easier to just catch the ClassCastException as well. The original should be a ClassCastException (since it's the same).
Here too I think it would be easier to just catch the ClassCastException as well.
we should check mMediaUpoadHandler!= null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
we should check mMediaUpoadHandler!= null before accessing its methods here, as I believe they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
we should check mMediaUpoadHandler == null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
'else if' is redundant here.
'else if' is redundant here. Perhaps add an overload.
'else if' is redundant here. Perhaps add "'throws'
Looks like this should be withing if (result && this.fullStatsEnabled) as well.
Looks like this now should be withing if (result && this).
Looks like this now should move to AbstractChannelMetricsContext.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
We don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, and we can build maps and pass those to Jackson (ObjectMapper) directly.
protected (IFeatureAndProductInput) { if (fFeatureIndex!= null) { return; } return!isIncludeProducts(featureId).isEmpty();
protected (IFeatureAndProductInput) { if (fFeatureIndex == null) { return; } return!isIncludeProducts(featureId).isEmpty();
this (and below) should be enough to compare the featureId here.
IIRC anonymous users will crash here because they have no user account to get the prefs from.
IIRC anonymous users will crash here because they have no user account to get this prefs from.
IIRC anonymous users will crash here because they have no user account to create the prefs from.
nit: Consider extracting this into a static final variable.
nit: add final for the variables.
nit: add final (or a variable)
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell.
I'm wondering whether this should be case-insensitive, but maybe as well?
Do you think it makes sense to create a new RuntimeException, this code is outside of the hot path?
Do you think it makes sense to create a new RuntimeException, this code is too low?
Do you think it makes sense to create a new RuntimeException, this code is outside of the loop?
this variable should be declared final.
Please remove this line
Please remove this
It's better to use TestUtils.waitFor(...) here
In general, we should use try-with-resources style
It's better to use TestUtils.waitFor(...) here.
we should use the context variable here.
we should use the String, not a String.
we should use the String, not a String
flow => flowPath
flowName is not necessary as an additional method argument since it is used in this class.
flow => flowFile
Regarding TODO, It's a good idea to dispose the publisher. You can use requestManager to dispose the publisher. If you want to: finally { if(!adView.getParent()!= null) { Log.d(TAG, "Vungle extras.removeView(TAG, "Vungle extras"); } if (!adView.getParent()!= null) { Log.d(TAG, "Vungle extras"); }
Regarding TODO, It's a good idea to dispose the publisher. You can use requestManager to dispose the publisher. If you want to: finally { if(!adView.getParent()!= null) { Log.d(TAG, "Vungle extras.removeView(TAG, "Vungle extras"); } if (!adView.isVisible()) { Log.d(TAG, "Vungle extras"); }
Regarding TODO, I think you should only call removeView on the result.
I don't understand this, given you're checking if DatastreamMetadata.getMetadata().containsKey(DatastreamMetadataConstants.S_409_MS) continue; if (streamMetadataConstants.IS_CONFLICT_MS) {
I don't understand this, given you're checking if DatastreamMetadata.getMetadata().containsKey(DatastreamMetadataConstants.S_409_MS) == null
I don't understand this, why we need to log it twice?
I believe this should be.booleanValue() not!= null
I believe this should be.booleanValue() not.
I believe this should be.booleanValue() not == true
You can use assertEquals(endpointName, releaseStage);
You can use assertEquals(endpointId, resource, false);
You can use assertEquals here
nit: can we use assertInException here? assertTrue(a, b)
nit: can we use assertInException here? assertTrue(a,b)
nit: can we use 12345?
"Start trainning sub process"
.toString() seems to be missing
"Start trainning sub process"?
I'm not a fan of this while loop. The proper way is to construct a new sql connection and then try to close it at the end: while (true) {.. } catch (SQLException e) {... }
I'm not a fan of synchronized blocks. The while condition can be avoided with the next two synchronized blocks.
I'm not a fan of this while loop. The proper way is to construct a new sql connection, then you can use the while condition in the loop as below.
replace this with: if (this.numBits() == BulkOutput.GET) { xmlOutputBuilder.append(XmlOutput.GET); }
replace this with: if (this.numBits() == BulkOutput.GET) { xmlOutputBuilder.append(XmlOutputBuilder.GET ); }
replace this with: if (this.numBits() == BulkOutput.GET) { xmlOutputBuilder.append(XmlOutputBuilder.class, StandardCharsets.UTF_8); }
Was it somehow forgotten?
so you can have it in a constant for this case (at least in other files)
I think it would be cleaner to have an enum instead of using magic values for the value
Does this block need to be logged out?
Does this block need to be logged in a finally block?
Does this block need to be logged in the finally block?
This ducks up a bit. It could be called requestManager and service/requestManager, securityManager calls, and it could be called in the service.
This ducks up a bit. It could be called requestManager and service/requestManager, securityManager calls, and it should be called in the service.
This ducks up a bit. It could be called requestManager and service/requestManager, securityManager calls, and it should be called in DefaultHelperService.
Use { } even for one line if/else bodies.
Use { } even for one line if/elses.
Please add a space after if.
How about extracting the first random page.getHost().bySlugOf(res.head()) to a variable?
How about extracting this first method.stream() to a variable?
Could you make this second page.executeBlocking be used more than once?
It is possible to define a new ArrayList and reuse it here.
It is not a good idea to move the type to Collection as a Set, right?
It is not a good idea to move the type and implementation into the enum.
Do we need this? The config in configurePipeline() and this.configuration.isTcpMatcher() may be a good idea.
Do we need this? The config option would be a property of the UdpDataSerializer interface, so you can use the same TcpMatcher<UdpDataSerializer> as well.
Do we need this? The config option would be a property of the UdpDataSerializer interface, so you can use the same TcpMatcher<UdpDataSerializer>.
Typo?
Could be a singleton.
Typo
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.IMPLICITLY)
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.IMPLICITLY).
Can you add if (getNode().getComponentType()!= null) to make code more readable?
Can't you replace this logic by in the else condition?
Can't you add else if (getNode().getComponentField()) { return; }
Correct me if I am wrong. ;)
removeBreakpoints instead of createWarning
remove is a bit unnecessary.
I see other places using Thread.sleep() to get a single handler. Is that possible?
I see other places using Thread.sleep() to get a single handler. Is that possible here?
I see other places using Thread.sleep() to get a single ResponseHandler. Is that the right approach?
nit: I think it'd be a result of this, but the tableDataManager would never be null, so we don't need to keep it. The RealtimeTableDataManager also has a getDBQuery() method, and we can add it here.
nit: I think it'd be a result of this, but the tableDataManager would never be null, so we don't need to keep it. The Cache manager already checks for existence of instance, which will lead to a race condition with tableDataManager to be initialized.
nit: I think it'd be a result of this, but the tableDataManager would never be null, so we don't need to keep it. The Cache manager already checks for existence of the table type.
can we also return true?
can we also include client.get()?
can we also log the error as well?
We don't need the snapshotVersion here. The snapshotVersion is marked as optional.
We don't need the empty check here.
We can just use the snapshotVersion here. The snapshotVersion is not guaranteed to be 1.
This should be an IllegalArgumentException
instanceof GeometryType
s/ST_object/g
Does it make sense to have a Set<String> tag = Collections.singleton(tag); if(tags == null){ Set<String> tags = new HashSet<>(); tags.add(tag); }
Does it make sense to have a Set<String> tag = Collections.singleton(tag); if(tags == null){ Set<String> tags = new HashSet<>(); tags.add(tag); }?
Does it make sense to have a Set<String> here? I can't see any reason to use Set (which this can be changed later)
You can use [StandardCharsets.UTF_8.UTF_8](<LINK_0>
You can use [StandardCharsets.UTF_8](<LINK_0>
You can use [StandardCharsets.UTF_8](<LINK_0> here.
What do you think about other changing to FOO, FOO, FOO, FOO, FOO, FOO)?
What do you think about changing this so it will be more appropriate i guess?
What do you think about other changing to FOO, FOO, FOO)?
Nice test!
Nice.
occurrenceDate.get().getId()?
In the case of medias previously set the defaultLang value, this can be null. Suggest replacing the "defaultLang" string with a non-null value.
In the case of medias being null, I think you should create a function that returns the correct value for the dialog and reference that can be called.
In the case of medias previously set the defaultLang value, this can be null. Suggest replacing the "defaultLang" string with a non-default value.
nit: can we call it Context.stageBlockWithResponse(this)?
nit: can we call it Context.stageBlockWithResponse(this)
Can we just go with the Context.stageBlockWithResponse(e) method?
this is needed. Won't it be a valid fix for this in Ecore's go well with the previous version?
this is needed. Won't it be a valid fix for this in Ecore's go well with the previous commit?
this is needed. Won't it be better to do it as it was before.
Couldn't we throw the exception if we know that there is no aggregate state?
Couldn't we just throw the exception here instead of returning null?
Couldn't we just throw the exception here instead of returning null? Personally I prefer the use of Optional in the first place (in the first place).
getDrawable() can return null. It will be better to check against null.
getDrawable() can return null. It will be better to check whether it returns null and parse accordingly.
getDrawable() can return null. It will be better to check == GONE.
log the sleep duration maybe? and maybe remove the exception?
log the sleep duration maybe? and maybe remove this exception?
log the sleep duration maybe? and maybe remove the exception? or rename the sleep duration maybe?
Any reason for this change?
If you use a field, like this:.originCounter++;
Why Unnecessary this?
Naming: I don't understand the context of the variables? I mean, the return type of the method should be named "fake_user". Three more than "a".
Naming: I don't understand the context of the variables? I mean that the id of the variables should be of the same type of the service for the variables?
This should be a log.
[\/\ ] please, I think we should be more efficient here, please check for it.
[\/\ ]
[\/\ ] please, I think it is more readable, please use brackets, I think
Extract these two lines into a method to reduce duplication.
Extract these two lines into a method and call it in the tick code
Extract these two lines into a method to make it more readable.
It feels like this is almost the same as the first two lines... could return null and put the non-null on its own line
It feels like this is almost the same as the first two lines... could you break everything here?
It feels like this is almost the same as the first two lines... could return null and put the non-null on its own line.
Shouldn't this be: quarks = request!= null? fullState.getQuark() : quarks.get(fullState);?
Shouldn't this be: quarks = request!= null? fullState.getQuark() : quarks; and fLastRequest = request.getQuarks();?
Shouldn't this be: quarks = request!= null? fullState.getQuark() : quarks; and fLastRequest = request.getQuark();?
Potential NPE: You should use %s here; it's still possible that consumer.seekToEnd() is called before the getEarliestOffset() method.
Use warn()?
Potential NPE: You should use %s instead of %s here
Same question
Same question as above
Same question as before
Which asserts are there for clusterListener1?
Which asserts are there for cluster listener?
Which asserts are there for no cluster listener?
I don't think this should be configString.length() 0 (the default value is null).
I don't think this should be configString.length() 0
I don't think this should be configString.length() == 0
Why is this hardcoded to 4 threads? Should there be an option to control this?
Why is this hardcoded to 2 threads? Should there be an option to control this?
Why is this hardcoded to 4 threads? Should there be an option to mock?
I'm not sure if ({dataGenerator.get{t1 = {dataGenerator.get{t1 + 2\n) is needed.
I'm not sure if ({dataGenerator.get{t1 = {dataGenerator.create table ) should be used instead.
I'm a bit confused by this. What's the purpose of the test? Could this be unit tested?
n.equals(na.get())
n.equals()
n.stream()?
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to each element in the resultObject.
Think @sandeepSamudrala mentioned in another pull request. Should add location to the resultObject.
This can be small D double
This can be small DDoubleHistogram::add
This can be small DDoubleHistogram::close
Can you explain why the error handler is null here?
Can you explain why the error handler is null?
Can you explain why the error handler is null here.
checkNotNull
checkNotNull?
externalize
s/Started/Starting
, it's not your fault but we should log the whole exception as a user.
, it's not fatal.
Umm, why are we translating the exception?
Unecessary.
Uh, this is just something I missed above.
Why do we want to return here? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fListenersByPartId.get(listenerPartId)
why do we want to return here? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fListenersByPartId.get(listenerPartId)
Why do we return here? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fListenersByPartId.get(listenerPartId)
Is there a reason why you do not assert the stateManager.flush()?
Is the intention to reset state here?
Isn't this requier enough?
Shall we use the constant NAME_USER_KEY instead of the name here?
Shall we rename the constant NAME to HEADER_USER or HEAD?
Shall we rename the constant NAME to HEADER_USER or HEAD_Cgtm
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should call _raw_SILLION_LILLION_L with ONE_BILLION_L * fClockAntiScale_NILLION_LILLION_L * fClockAntiScale_Seconds;
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, it must be a non-null.
I think!( operation instanceof CatalogFunction || operation instanceof CatalogFunction) || operation instanceof RemoveCatalogFunctionOperation
I think!( operation instanceof CatalogFunction) || operation instanceof RemoveCatalogFunctionOperation
I think!( operation instanceof CatalogFunction || operation instanceof CatalogFunction) || operation instanceof RemoveCatalogOperation
I don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
I don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an internal method where each subclass does their own thing.
I like the idea of doing the same thing as testPruneMode where each subclass does their own thing and this test makes it more readable
Would it be a good idea to make this check cleaner?
Wouldn't this make more sense to create a Map (name to value) instead of two commands?
Wouldn't this make more sense to create a Map (name to value) instead of having a list?
we don't need to set it here
we don't need to set /4 for this
we don't need to set /4 for windowUnit
Better use!StringUtils.isEmpty()
Better use StringUtils.isNotEmpty()
Better use!StringUtils.isEmpty()!
I don't think we need this check in the constructor
this.layoutAlgorithm is not null in the layout and it is initialized in the constructor
this.layoutAlgorithm is never null in the constructor
Should this be "Could not find any Subject Id" or check for extensionIdFromSubject?
Should this be "Could not find any Subject Id" and the check really be done?
Should this be "Could not find any Subject Id"?
lets log this as well
lets keep this as a rename() so it's clear
lets log this as well.
This method looks a little weird to me. No need to throw an exception and notify the user.
This method looks a little weird to me. No need to throw an exception and notify the user, right?
This method looks a little weird to me. You could just use a normal file name here.
assertFalse(...);
assertFalse(...); is not needed
java assertFalse(...);
Is it correct to compare with GTK4 instead of GTK4?
Is it correct to compare with GTK4?
Is it correct to compare with!GTK4 && GTK4?
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
Check what happens with an empty file: Looks like on replay, both openFile and closeFile() calls are skipped since there are no recovery entries for that file.
Check what happens with an empty file (that is, too)?
I would rather copy the requested contents into a local variable.
I would rather copy the requested value from the current pull, i.e. we can cache it in a constant.
I would rather copy the Producer to a local variable.
I think it would be more clear to remove the SWT.MouseUp here. They aren't normally sent when you click on the mouse when clicking on the mouse.
I think it would be more clear to remove the SWT.MouseUp here. They aren't normally sent when you click on the mouse.
I think it would be more clear to remove the SWT.MouseUp here. They aren't normally sent when you click on them.
![MINOR](<LINK_1> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_0> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_1>](<LINK_2>
close streams
there's a bad place to put it in try-with-resources. i.e. setup resource in finally block
also assert that streams are empty
I know this is not change, but as we are doing this it, it may be better to make the inMemoryQueueSize final and have inMemoryQueueSize return true at the end.
I know this is not change, but as we are doing this it, it may be better to provide a static variable for this message.
I think we can return -1 directly here.
Could you elaborate why this logic is necessary? It seems like it could be simplified to: java if (taskMaster.get(interval).equals(interval) && toBuildInterval.equals(interval)) { return; } DataSegment segment = entry.getUsedSegmentsForInterval(interval);
Could you elaborate why this logic is necessary? It seems like it could be simplified to: java if (taskMaster.get(interval).equals(interval) && toBuildInterval.equals(interval)) { return; } DataSegment segment = entry.getUsedSegmentsForInterval(interval); And also you can still reuse the methods below.
Could you elaborate why this logic is necessary? It seems like it could be simplified to: java if (taskMaster.get(interval).equals(interval) && toBuildInterval.equals(interval)) { return; } DataSegment segment = entry.getUsedSegmentsForInterval(interval); And also you can leave this method unchanged.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
If we already have a value, we don't need to determine it anymore and can just return the previously computed value even for read-only directories.
please rename fieldsRead<?>> fieldsRead<?>> fieldsRead = new TypeFilter<>(v)
please rename to fieldsRead<?>>
please rename fieldsRead<?>> fieldsRead<?>> fieldsRead =...
Suggest you move the zip == null to a separate method so that you don't need the null check
Suggest you move the zip == null to a separate method so that you don't need the null check.
Whitespace before/after the operators
You forgot parent class name and it also must be aliased name
You forgot class name and it also must be aliased name
We forgot parent class name and it also must be aliased name
why won't this throw an exception?
why won't this be package protected?
why won't this throw an exception if the metric is updated
This seems to be missing a space after the HandlerHandler.addHandler( messageListener);
This seems to be unused.
This seems to be missing a space after the )
logger?
remove?
remove param
Catching exception is not necessary.
Missing white space between the {
Missing white space
Why are you using a Queue here? And then by extension a LinkedList?
Why are we using a Queue here? And then by extension a LinkedList?
Why using a Queue here? And then by extension a LinkedList?
Why have you removed the variable?
Why have the first version checked in the method?
Why have the first version checked in the call?
should this be in the try catch block above?. What happens if the expiry task was removed and the stop command fails?
should this be in the try catch block above?
should this be in the try catch block above? Also, what happens if we merge a 2nd sequence?
Does this need to be wrapped in a test?
Does this need to be wrapped in a mapper?
Could this be removed?
Style-nit: Space after if.
Style-nit: missing space after if.
Style-nit: Should this be a synchronized method?
remove the entire stream() line
Remove the entire stream invocation.
remove the entire stream() lines
In what's the purpose of this line?
In what situations are we throwing an exception here?
In what situations are we throwing a runtime exception here?
Please rename these config variables.
Please rename these config variables to just type
Please rename these config files to invalidId
This block only compares AttributeAccessItemDto objects to themselves. It should compare them to the corresponding indexes of the methodAccessItemDtoList.
This block only compares AttributeAccessItemDto objects to themselves. It should compare them to the corresponding indexes of the method.
This block only compares AttributeAccessItemDto objects to themselves. You can compare them to the corresponding indexes of the methodAccessItemDtoList.
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderScreen.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrder/Lint/
rename to pupTime
same issue as original exceptions
same issue
nit: remove empty line
nit: rename to location
nit: rename to "OnlyElement" to something more meaningful
Shouldn't we be moving the elevator while we're moving the clamp?
Should be elevator.save() rather than..
Should be elevator.
Nit: maybe we should just say a return type here (instead of returning a null)
Nit: maybe we could just say a return type here (instead of returning concrete type)?
Nit: maybe we could just say a return type here?
If the user starts an empty notification, shouldn't we use the [pattern](<LINK_0> instead?
If the user starts an empty notification, shouldn't we be using a normal path?
I believe this shouldn't be here?
avoid increasing visibility?!
avoid newline
avoid superfluous variable
we can continue here? java if (testData.students()!= numStudents.size() > numStudents.size()) {
we can continue here? java if (testData.students()!= numStudents.size() > numStudents);
else if?
I have Srtreamline hard coded in my PR too. I thought it would not be used elsewhere. But can you add it as a constant? And I will change my code to use that constant.
I have Srtreamline hard coded in my PR too. I thought it would not be used elsewhere. But can you add it as a constant? And I will change my code to use it also.
I have Srtreamline hard coded in my PR too. I thought it would not be used elsewhere (with it as a constant). I will change my code to use that constant.
should only do if (hsuke.length > 0) throw exception?
should only do if (hsuke.length > 0) return; here?
should only do if (hsuke.length > 0) return false; here
Minor: Please add whitespace before the final argument.
Minor: Please add whitespace before the {.
Minor: Please add whitespace before the if.
DISTRIBUTED_STRIPE could be extracted to constants.
DISTRIBUTED_STRIPE should be set to final
pass object.getVolumeType().getForce().getEntity()
Did you mean to remove this, or if it will work in this case? suggestion
Did you mean to remove this, or use two rlContainer.set(String)
Did you mean to remove this, or use two rlContainer.setScenePath(String) method?
Don't we have a +1 here?
Don't we have to create a new connection object here?
Don't we have to create a new connection - we should probably use [web.myField](<LINK_0> here - it should be removed.
4.2
Should the 4.2 version be checked outside the loop?
Same here, 4.2
You could do pdfHeaderFormat with null
You could call pdfHeaderFormat with null
You could do pdfHeaderFormat with null.
Please refactor to different methods
You should be able to refactor the DB part, what do you think?
Please extract to a method
These should still be removed.
ah log.
ah log.out
This is an anti-pattern that is used quite frequently. We don't want to try to update the database at all, so if it doesn't make sense to have it.
This is an anti-pattern that is used quite frequently. We don't want to try to update the database at all, so if it doesn't make sense to have it at all.
This is an anti-pattern that is used quite frequently. We don't want to try to update the database at all, so if it doesn't make sense to have it at the end just return false.
Listner is misspelled.
Missing { and }.
datums and parameter names are not used.
extra space
extra newline
unnecessary
This property name seems a little misleading because it is not used.
This property name seems a little misleading since it is used in the test.
This property name seems a little misleading because it is used in the test.
Instead of having two method createSimpleLabels(List<String> matchedLabels, Optional<String> matchedLabels, Optional<String> matchedLabels) { return createLabels(label -> {StringUtil.isEmpty(label); }));
Instead of having two method can be inlined as thePAD, when you can compute the label right away.
loadLabels -> loadLabels
also need to handle case where insertionArt == null
also need to handle case where insertions return null
also need to handle case where insertions are null
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getName(), parameters)).append(" ").append(column.getType());
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getType(), parameters)).append(" ").append(column.getType());
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getDefaultValue().get(), parameters)).append(" ").append(column.getType());
Shouldn't it be negotiate?
Shouldn't responseBuilder be negotiate?
URLBuilder
should we add a log message here so that we can see the admin admin has been started?
should we add a log message here so that we can see the admin admin has been started and not stopped?
should we add a log message here so that we can get the admin admin has been started?
Doesn't seem to be a need for a segmentConsistentHash?
Doesn't seem to be a need with a segmentConsistentHash?
Doesn't seem to be a need for a separate list.
Is there a use case where we can use the assert?
Is there a use case where we can use the assert.
Is there any reason we can't use the assert.
Looks like it might leave two commas in place in the case: (HaxeDebugUtil.getExposedMembers(type, HaxeDebugUtil.class))
Looks like it might leave two commas in place in the case: (HaxeDebugUtil.getExposedMembers(type, HaxeClassModel.class))
Looks like it might leave two commas in place in the case: (HaxeDebugUtil.getExposedMembers(type, HaxeDebugUtil.class)) I'd prefer to leave these as-is (i.e. in the case of resolving to HaxeModel.)
can be simplified to just verifyCanAddDisks(any(List.class))
can be simplified to just mock the storageDomainValidator.
can be simplified to verifyCanAddDisks(any(List.class))
If you use constructor: Multimap<String, Serializable> map = new HashMapMultimap.Builder();
send as "instanceof" instead of using "this".
space before "?
Wrap in a new method called "canMigrate" or something.
Wrap in a new line.
double slashes
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Its the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
could you also verify that parentTxTest.equals(parentTxUri) is true?
could you also verify that parentTxTest.equals(parentTxUri) is equal
could you also verify that parentTx.getTxUri() is equal
Can you just declare this on line 132 to avoid needing to have the null check?
Can you just declare this as throws Throwables.propagate?
Can be static.
can we make this more explicit and log the exception.
can we make this more explicit and log the exception message for the checksum?
can we make this more explicit and log the actual content instead of checksum.
Should this be a constant?
Should this be configurable?
Should this be moved to the constructor?
Consider using "minutes" in order to match most of the time.
Consider using TimeUnit.SECONDS.toMillis(days) here and in some other places.
Consider using TimeUnit.SECONDS.toMillis(days) here and in similar cases.
You could use translations.forEach(feature::add);
You could use this code to create a new Translation
You could use Arrays.asList(getTranslation(local));
can replace the loop with return (healthyWritablePartitions.keySet().stream().map(Replica::getWritablePartitions).filter(state -> new healthyWritablePartitions.isEmpty()).collect(Collectors.toList());
can replace the loop with return (healthyWritablePartitions.keySet()..) healthyWritablePartitions;
can replace the loop with return (healthyWritablePartitions.keySet()..)
Please remove these empty lines.
Please remove this. It's the only place you need this queryConditions.
Please remove these final.
sounds nice! so users are not overwhelmed with hints. Shall we also add a new line just for consistency?
sounds nice! so users are not overwhelmed with hints. Shall we also add a change log line as well?
sounds nice to me
We should use a StringBuilder here instead of a String.
use DTSDBWriter here as well
We should use a StringBuilder here instead of Lists.newArrayList
I don't see the difference between testWriteAdvHandle and testWriteAdvHandle. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithUnsemble. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithPassword. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
Suggest checking for workflowAction.getSchemeId() instead?
[optional] Why doesn't it be easier to use == for enums?
Suggest checking for workflowAction.getSchemeId() instead of equals.
Very small nit: I would add a new line to make the code more readable.
Very small nit: I think we can move this line to the caller of the method.
More new line.
What happens if exceptionInfo is null? Shouldn't this throw a RuntimeException?
What if exceptionInfo is null? Shouldn't this throw a RuntimeException?
> "Token is successfully returned from ADALError" the exception should be the first.
Replace these two switch statements with switch.
Replace these two switch statements with switch (args.length)
static
nit: put this in a constant
Add a message
nit: put this in a field
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0:500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Use Collections.emptyList()
Use Collections.emptyMap
Use Collections.emptyList
@cvrebert can we move this up?
@cvrebert can we rename this variable?
@cvrebert can we move this variable to variables?
we need to sleep(1000) here, to test the EntryMemtable is already doing that.
we need to sleep(1000) here. can we make this test sequence more deterministic rather than depending on capacity
we need to sleep(1000) here. can we make this test sequence more deterministic rather than depending on capacity?
Can be checked on Collection.equals()
Can be checked on Collection.equals and hashcode methods.
rename to hashcode
Please use constant for this.
Please use acp.getOrCreateACL().contains() here as well.
Please use acp here.
> is redundant.
> is redundant..
Extract method
Is this being the only way you do this? If not, then you should probably remove.
Is this being the only way you do this? If not, then you should probably remove it from the constructor, right?
Is this being the only way you do this? If not, then you should probably remove it from the method signature since it's only a concern about the hadoop index.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing. Is it possible to skip the parametrization?
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing. Is it possible to skip the --param flag altogether?
This isn't clear to me. Suppose the text was changed to be a text: "tabs".
Maybe we should rename this to "disablable"?
This isn't clear to me. Suppose the text was changed to be a text and not just put it there.
I don't like that you are using.get() here because.get() may return null if the file doesn't exist. I suggest to do a check before the return in the end.
I don't like that you are using.get() here because.get() may return null if the file doesn't exist. I suggest to do a check before the ".get()" on line 61.
I don't like that you are using.get() here because.get() may return null if the file doesn't exist. I suggest to remove it.
Why this change?
Why change this?
Why the change to the private method?
code formatter missing curly brackets around if
code formatter missing curly brackets
code formatter missing?)
Remove these redundant logging changes.
According to <LINK_0>, it's better to remove these blank lines.
Remove these two lines.
I think it is better to return an empty collection instead of null.
Shall we throw GeoLocationBasedServiceException wrapping RegistryException?
I think it is better to return an empty list instead of null.
Check if this test of relation is also in BlImpl part. If not, move it there.
Use new ExternallytronException("admin", " + operand); instead of else.
Check if this project exists.
I would add a method in marshalledEntry class that uses this interface.
I would add a method in marshalledEntry class that uses Instant.now(). Also we can have a non-static method with a specialized interface for this now.
I would add a method in marshalledEntry class that uses Instant.now(). Also we can have a non-static method with a specialized interface for this class.
I would prefer more explicit message (it could add the osgiVersion to the message)
I would prefer more explicit message (it could add the osgiVersion to the message) to the exception
I would prefer us to use osgiVersion.getUserAgent to avoid duplication with the message.
I think it is better to re-throw the exception here. I have a Overall, but I just noticed that the Wrong key should be handled. Did you test the Plain string in the changeset?
I think it is better to re-throw the exception here? I had a SYSE0001 should be a good way to catch exception here because we know that the exception is thrown and then invoke it.
I think it is better to re-throw the exception here. I have a Overall, but I just noticed that the Wrong key should be handled. Did you test the Plain string in the invalid key?
You should not modify the cache xml. Instead, why not just do invokeMethod(ctx.getConfig().get(obj).getCache() here?
You should not modify the cache xml. Instead, why not just do.filter(p -> p.getConfig().get(obj))?
You should not modify the cache xml. Instead, why not just do invokeMethod(ctx.getConfig().get(obj))) and then check the cache?
shouldn't we remove the pvk.getArg("?") check?
shouldn't we remove the pvk.getArg() here?
rename to pvk
Why are we throwing this exception instead of Exception?
Why are we throwing this exception instead of Exception? Wouldn't it make sense to wrap it in a RuntimeException instead?
Why are we throwing this exception instead of SamzaException?
I'd expect the default to be of the enum. Also, does it make sense to always use a constant?
I'd expect the default to be of the enum. Also, does it make sense to always use the correct API?
I'd expect the default to be of the enum.
Shouldn't we re-throw the exception here?
@vmaletta I think we should log the error here.
@vmaletta I think we should log the error
Can be changed to isShareable()
Can you put the new isShareable() here as well?
you can remove the first &&
Can you use already-defined constants for the following three strings?
Can we use already-defined constants for the following three strings?
Can be replaced with already-defined constants.
Same here. There is no need for the.toString() method.
Is this really necessary? There is a race condition in looping like the next iteration.
Is this really necessary? There is a race condition in looping like the previous wait.
If you use this same block as the other method, maybe you can extract it
If you use this function, its good to read it
If you use this function, it makes sense to keep it similar to the other methods.
relevant non-logging code change here
relevant non-logging code change here ;)
The non-logging code change here
I would prefer to use BlImpl.getPerunPrincipal().getRoles() and getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().get
I would prefer to use BlImpl.getPerunPrincipal().getRoles() and getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().get
I would prefer to use BlImpl.getPerunPrincipal().getRoles() and getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles().getPerunPrincipal().getRoles
Same here, we shouldn't be copying fields from the database.
Same here, we shouldn't be copying fields from the existing.
If we're changing this to an index from field to fields we shouldn't be copying the existing values from the index.
The if/else branch look redundant.
The if/else branch is redundant.
The if can be simplified into one ifs.
Not sure on this one - isn't the capacity important?
Not sure on this one - isn't the capacity that would easily be 0?
Not sure on this one - isn't the purpose of the 'cause'?
supplyAsync
supplyAsync would already handle this exception correctly, right?
Missing final
variable is not needed.
variable is redundant.
Add a break here.
Since this block is repeated in above, shall we move it to a separate private method?
Since this block is repeated in above, shall we move it to a separate private function?
Since this block is repeated in above, shall we reuse it?
What about assertEquals(SolverInstance.SolverStatus.DEFAULT_TIMEOUT, solverInstance.getSolverStatus()); here?
What about assertEquals(SolverInstance.SolverStatus.DEFAULT_CLIENT_ID, solverInstance.getStatus());?
What about assertEquals(SolverInstance.SolverStatus.DEFAULT_CLIENT_ID, solverInstance.getSolverStatus());?
final DecimalFormat format = new DecimalFormat("0.3.0");
Leftover debug statement?
final
This check should be moved down to the method below to check whether the parser version matches the pattern.
This check should be moved to the beginning of the method.
This check should be moved down to the method below to check whether a file is present before bam.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term seems take, so lets use that)
.take(limit) does the same as the one above.
Add default statement here to simplify this
Add a message to 'factory.getLocalizedMessage'
default should be a constant
I'd suggest extracting the label name into a local variable and use it in both places instead of having them.
I'd suggest extracting the label name into a local variable and use it in both places instead of 'text'.
I'd remove the tab and make it final.
The exception should be caught by the property.
Might be better to catch azkabanValidators.LOG.error("Exception while parsing file {}", flowLoader);
The exception should be caught somewhere to the try/catch.
Probably want to extract a static string for each thread access.
No need to extract this component out.
No need to extract this component since it's static and detected within a constructor
this whole if statement can be replaced with.collect(Collectors.toList())
this whole if statement can be replaced with.trim().split(" *", *")
this whole if statement can be replaced with.trim().split(" *", 2)
ditto :)
ditto: just use this utility method
static import
you don't need to define this.
you don't need to define this explicitly
you didn't define this.
You can simplify this a bit by using Optional<GlusterStatus> from GlusterStatus.
You can simplify this a bit by using List<GlusterStatus>.
Failed to check Gluster running status of this host?
This may be OK in this circumstance, but there's a restriction on what can be passed to the method. Is there any chance this restriction will be violated in this code as a surprise?
This may be OK in this circumstance, but there's a restriction on what can be passed to this method. Is there any chance this restriction will be violated in this code as a surprise?
may be we should put this into a helper method in ParameterizedType.
Is there a reason we dont require this to be a PlainBuffer constructor?
Is there a reason we dont require this to be a PlainBuffer object?
Is there a reason we dont require this to be an empty string?
I think here we should make this private, no?
I think here we should make this private - error should be read from response, no?
I think here we should make this private - error should be read from response, i.e. read content(contentTypes).
I am unsure about the FileOutputStream here, as we use it in finally block
I am wondering if we should instead close the FileOutputStream and close it in finally block.
I am wondering if we should instead close the FileOutputStream and close it in finally block?
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
The AllCleanRule should do the work of lines 158..159, so that you can skip this code.
The AllCleanRule should do the work of lines 158.
Isn't the user's state being set?
Isn't the user's state being null?
Isn't this if branch visible?
Minor thing: "referer!= null"
Minor thing: "referer!= null && referer.isEmpty()"
Minor thing: "referer!= null &&"
is this needed?
can increment util?
can this use increment.
use new names?
use new names? Please do so.
use new char names?
Do we want to turn this on by default?
Do we need to make this non-null?
Do we want to turn this on by default in elide-standalone?
Why did you add the path param to the log? And if you want to print the stack trace, you can't log it if there is no issue.
Why did you add the path param to the log? And if you want to print the stack trace, you can also log it if there is no issue to print it.
It would be better to add the path /rest/"+CACHE_MANAGER_ID
if (log.client.reloadIfRequired(parameter)) { connectionName = connectionName; }
if (parameter.client.reloadIfRequired(parameter)) { connectionName = connectionName; }
if (log.client.reloadIfRequired(parameter)) { connectionName = true; }
please throw exception
please return long type
please return longModel
Could this be just return new Thread(scheduler, RxJavaPlugins.createComputation(), new Thread("Test")?
Could this be just return new Thread(scheduler, RxJavaPlugins.createComputation(), new ThreadFactory(prefs))
Could this be just return new Thread(scheduler(), RxJavaPlugins.createComputation(), new ThreadFactory(prefs))
Curious why we should have 2 separate threads for this one, and also one of them?
Curious why we should have 2 separate threads for this one, both as well and having all separate one.
Curious why we should have 2 separate threads for that.
you also need to set the kickedOff to false even if the request fails.
you just put in the else block below, you don't have to set it to true.
you just put in the else block below, you don't have to set it to false.
final?
you can use entropy.getSumC() instead of Math.max().
final
I think this should be else if (rec.getReadUnmappedFlag() ||!rec.getReadUnmappedFlag()) {
multiple return statements can be merged into one
I think this can be static?
We could add the.baseTypeToContentTypeStrategyResolver field here
We could add the.baseTypeToContentTypeStrategyResolver constructor here
We could set the ContentType.BASE_TYPE_KEY too
nit: just simplify to throws Exception
nit: simplify to throws Exception
nit: just simplify to throws ServerException
why are we ignoring user?
why are we not use these params?
why are we ignoring the case?
This should be CFMap.get(bytes)
Shouldn't we clear definedPropss on the SYNCED_DATA_QUERY property?
This should be CFMap.get(key, SYNCED_DATA_AND_INDEX_QUERY, "v")
There is a few other places in this file that use arrays, while they are. It might be nice to have them just test for two records.
There is a few other places in this file that use arrays, while they are being used above.
Looks like this can be final
Why this get deleted? Your code depends on this function? Your code depends on this function?
Why this get deleted? Your code depends on this function?
Why this get deleted? Your code depends on this function? Your code depends on this function? Your code depends on this function?
ping
ping: This doesn't seem to be complete.
ping!
Why not do this?
Why not do this in the constructor for-loop?
Why not do _maxAllowedCapacity?
else throw exception?
else throw an exception?
remove
There are other places in this file that use kWorker.getTask().getHost(), which access K would be nice.
There are other places in this file that use kWorker.getTask().getHost(), which access K would result in a lot of duplicated code. Perhaps make it a private helper method?
There are other places in this file that use kWorker.getTask().getHost(), which access K would result in a lot of duplicated code. It seems like it might be worth having it in a helper method.
Looks like the overflow isn't possible for the overflow to finish (xl  yl  zl)) or  yl.
Looks like the overflow isn't possible for the overflow to finish (xl  yl  zl)) or  yl (xl  zl))?
overflowing (xl  yl  zl) => overflow?
This should be args.length - 1 || args.length == args.length
This should be simplified to: if (args.length - 1)
This should be args.length - 1 || args.length == 2
It's not your fault, but 'could be 'queueType' is null.
It's not your fault, but 'could be 'queueType', instead of '?
Again, don't use the same message for the exception thrown from updatePolicy.
I think this is a good example of how it should be. But GENERIC_MAPPING_QUALITY
I think this is a good example of what the new rool is - we should just throw Exception instead of returning null.
I think this is a good example of what the new rool is - we should just rebase this new PRIVILEGE_NO_TIMESTAMP.
Is it possible to use StringUtils.isBlank() here?
Is this check necessary?
Is this conditional necessary?
Debug code :P
Debug code?
Debug code :(
You can use the IDE's java.util.ResultSet<ResultSet> future = rs.getExecutionInfo().fetchMoreResults() == null;
You can use the IDE's java.util.ResultSet<ResultSet> future = rs.getExecutionInfo().getPagingState() == null;
You can use the IDE's java.util.ResultSet<ResultSet> future = rs.getExecutionInfo().getPagingState();
after calling setAttachments, there is no need to set the local variable to null.
after calling setAttachments, there is no need to set the local variable to null,
after calling setAttachments, there is no need to set it to null.
should the condition be "dedicatedRow" here?
I think you can do this with the 'else' case as first step is to keep the code shorter and more readable.
should the first condition bededicatedRow?
Need to update the timer metric even when the _zkclient is closed.
Need to update the timer metric even when the _zkclient is deleted.
Need to check if the _zkclient is closed.
Should this be a new Exception class?
Should this be a static final _can_ be a constant?
Should this be a static final constant?
If this vector is constant, it would be a good idea to create only one instance of this vector on class instantiation.
If this vector is constant, it would be a good idea to create only one instance of UserUtils with class instantiation.
Replace with UserUtils.validateUsername(String)
These two checks are redundant, only the "poison pill" can have a start time of -1 (right?). You can keep only one of them.
If it's not the case, throw an exception.
These two checks are redundant, only the "poison pill" can be by itself in a chunk, and only it can have a start time of -1...
@pefernan A test case for the (HttpServletRequest) chart: <LINK_0>
@pefernan I believe here you are comparing the strings
remove
if we fail here we have a stale version in hand. we should roleback
SDR or Stanford Digital Repository?
I would suggest here putIfAbsent
@DIRECT_REPLY_FLAGS_TO_SET
this is invalid with the fix
Please revert this change
I think this can be reduced to: while (inStream == null) { return null; }
I think this can be simplified by: while (inStream == null) { return null; }
I'd suggest return buffer.toByteArray() == null;
Yes, we shouldn't send the channel to the Request.
Yes, we shouldn't call this (and other similar places)
Yes, we shouldn't call this (Channel channel )
This method may return an ArrayList instead of a List.
This method may return a List instead of an ArrayList.
This method may return an ArrayList instead of an ArrayList.
This URLDecoder.decode() will throw ResourceNotFoundException, which will simplify the handling of the exception.
This URLDecoder.decode() will throw ResourceNotFoundException.
This fails here with 'err' warning.
Assertj has a fluent API. You have to use AssertJ
Please use AssertJ
Please use Assertj
Would this ever be a problem if the type name is unused?
Would this ever be a problem if the type parser is using the generic type loader?
Would this ever be a problem if the type name is different from the Type in the adapter?
Inline method
Inline variable
Inline variable.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
I think we should somehow catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
I think we shouldn't just catch and silently ignore)? Would be nice if we could somehow alert that there is a malformed URL.
Can't you use containsKey()?
Can you use newArrayList() here?
Can't we use newArrayList()?
nit: you can just use assertEquals
nit: I would use just address here
nit: you can just use the declared msg
Ye, but it causes a PMD warning.. :P I will fix it. ;) <review, layout
Ye, but it causes a PMD warning.. ;) <review, layout
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review
Could you please wrap this block with a try/catch to write the label before the write?
Could you please wrap this block with a try/finally?
Could you please wrap this block with a try { writeFixedLength & 156?
Should we include the full exception in the message?
Should we include the "not" tag in the message?
Should we include the "not" in the message?
Typo, should be allowed to overwrite
Typo in the name of the method.
Typo, should be allowed to point out that something
Is there a reason why you are catching Exception instead of a Thread?
Is there a reason why you are catching Exception instead of a CoreException?
Is there a reason not to use stderr here?
getCause() instanceof SocketTimeoutException and has something more generic to handle them. I think we should consider something more generic and let the user know about it.
getCause() instanceof SocketTimeoutException and has something more generic to handle them. I think we should consider something more generic (e.getCause() instanceof uulException)
getCause() instanceof SocketTimeoutException and has something like that. I think we should consider using Throwable e here.
Shouldn't this be: if (HttpURLConnection.HTTP.403!= 500) {?
Shouldn't this be: if (HttpURLConnection.HTTP.403!= null) {?
Shouldn't this be: if (HttpURLConnection.HTTP.URL_IDENTITY.equals(key)) {?
dilutions should be non-null and non-empty
dilutions should be non-empty and non-default
dilutions should be non-null
What is wrong with file.getAbsolutePath()?
What is wrong with file.getAbsolutePath()?
What is the reason for this change?
minor nit: initialize commonStats to zero.
minor nit: initialize commonStats to zero it's own variable.
minor: I am not sure if we should be setting commonStats to null here.
Check args?
Check if a lambda is null.
Check if a lambda is null?
Why not use a [Formatter](<LINK_0>, instead of the string concatenation?
Why not use a [Formatter](<LINK_0>, instead of creating a String array?
You can use a try-with-resources statement here
Should the warn be logged?
This should be after the println
This should be after the println.
Could this be moved to line 85-286
Could this be moved to line 85?
Could this be moved to line 85-286?
So is this really necessary? Shouldn't this be reading from sharedPreferences.edit()?
So is this really necessary? Shouldn't this be reading from the old file not the save?
So is this really necessary? Shouldn't this be reading from the old file not the same?
I would drop the ", ex"
I would drop the Exception
I would drop the text since it is effectively a string
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further information would be useful.
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further information would be better.
you can use a second parameter here: assertThat(topologyService.isActivated()));
you should also verify that the node is activated, but not the last node.
you should also verify that the node is activated, but not the first one: withCluster("localhost:50")
I suggest to make this a class variable, and use it in the new test cases. For example, this could be changed to: private IThreadLevel stackFrameVariables(final IThread threadName, final IStackFrame stackFrame) { this.outFrames = stackFrameVariables.iterator(); }
I suggest to change this to: if (stackFrameVariables!= null) { return Collections.unmodifiableList(filterSize + stackFrameVariables); }
I suggest to make this a class variable, and use it in the new test cases. For example, this could be changed to: private IThreadLevel stackFrameVariables(final IThread threadName, final IStackFrame stackFrame) { this.outFrames = stackFrameSecurity.iterator(); }
.toString() is not what we want here. Probably an error message should include the Search query.
.toString() doesn't throw an exception if it doesn't have a limit. So we should probably rename it to something like INSTRUCTOR_SEARCH_QUERY.
Log the exception?
Should this be against OADMIN.
Should this be against OADMIN?
Not sure, but maybe it's better to rename these methods to "Base"?
is it necessary to have applyStatefulFunction.processLeftData() here?
is it possible to have applyStatefulFunction.processLeftData(object) here?
is it possible to find one state from Operator?
I think you can remove this exception.
I think you can remove this.
I think you can remove this line.
Is this the same as the default?
Is this the same as the new findFirst()?
Is this the same as the change above?
How about adding a helper method: java private Object[] argsNull; public Object[] args(Object proxy, Object args) { if ( args.length > 0) { setCalled = method; return args; } else { throw new setNull(method.getName()); } }
What about adding a helper method: java private Object[] argsNull; public Object[] args(Object proxy, Object args) { if ( args.length > 0) { setCalled = method; return args; } else { throw new setNull(method.getName()); } }
What about adding a helper method: java private Object[] argsNull; public Object[] args(Object proxy, Object args) { if ( args.length == 0) { return null; } else { return args.length; } }
Could we change state.add(assignment.getAssignments()) to.add(assignment);?
Could we change state.add(assignment.getAssignments()) to.add(assignment)?
Could we change state.add(assignment.getAssignments()) to retainAll and no need to add the extra set?
it would be good to break out of the loop by changing the foreach loop below to for(...)
it would be good to break out of the for loop, when you still return the entry, and when the mod doesn't exist, use a LinkedHashSet instead of a HashSet
it would be good to break out of the for loop, when you still return the entry, and when the mod doesn't exist, use a LinkedHashSet to preserve existing behavior.
We could change the level of the switch to be the same in the PR. WDYT?
We could change the level of the switch to be the same in the PR.
Since the fragment's used only once, and do the switch to the new intent.
Should this this call to AsyncQueryParameters.validate(..)?
Should this call replaceSubRelation directly?
Should this call replaceSubRelation here?
boolean includeTextDetails = true; and send that value in the call below.
boolean includeTextDetails = true; and send that value in the call below
boolean includeTextDetails = false; and send that value in the call below.
Use Java 8's isNullOrEmpty() method.
Use Java 8's isNullOrEmpty
Use Java 8's isNullOrEmpty() e.g.
Can we use HIVE_METASTORE_CONFIGS_CONFIGS_CONFIGS_CONFIG here?
Why is this required?
Can we use HIVE_METASTORE_CONFIGS_CONFIG constant here?
I think we need to change timeout value in this case. Since #build is async, it would be good to have a small performance impact.
I think it would be nicer to extract this code to a method to avoid duplication.
I think we need to change timeout value in this case.
Isn't there a better way to do get the user from the getClusters method instead of checking for null?
Any idea why you can't do this (and others) rather than creating a new method in AccountService?
Any idea why you can't do this (and others) and get the user from the AccountService?
Can we use Objects.equals() here as well?
Can we remove the extra parenthesis as they are redundant?
Can we remove the extra parenthesis?
Missing {}
Missing generics
Missing space after (
Inline the variable - use something like json.get("assets")
Minor correction: Could you please use assertEquals for this?
RECALCULATED_TABLE_FACY_TWO
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into their own.
We shouldn't need separate methods for create/update like this. Do that.
Could you please log the transaction ID here, instead of the entire transaction?
Could you please add the transaction ID here, instead of the entire transaction?
Could you please add the transaction id here, instead of the entire transaction?
Is this the main purpose of the test?
Is this the main purpose?
Remove this?
I don't think we need the assertTrue()
I don't think we need the 0 check here. I'd prefer to use a Set.
I don't think we need the 0 check there. I'd be more comfortable using the 0 magic number here.
could make this check easier to read.
isNaN(int)
could make this check be first
Same here with not needing the local variable.
Same here with not needing the local variables.
Same here about not needing the local variable.
Should this be made in its own else block?
Should this be public?
Should this be else if?
Would you mind removing the parenthesis for the || (a && b) {?
Would you mind removing the parenthesis for the || operator? I know this is not part of the existing code, but I think we can eliminate some checks.
Would you mind adding some parenthesis here to avoid a double lambda?
I have the feeling this should be IllegalStateException instead of RuntimeException.
I have the feeling that we should have a single try-catch block around the same.
I have the feeling that we should have a return value in the catch block.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Same again with the log level, can you set this to w? Also could you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Same again with the change.
Nitpick: might be better to use constants for these.
there's a constants for these.
there's a constants for this.
This seems unnecessary. What advantage is there here versus before? Both guarantee the order is respected.
This seems unnecessary. What advantage was there here versus before? Both guarantee the order is respected.
This seems unnecessary. What advantage is there here versus before? Both guarantee the order has changed.
can use the trace only for logging consumer.
can use the trace only in this method
can use logging
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
Move this line down. We don't need to instantiate a IContainer if it's not an IContainer.
Move this line down.
I don't think we need to set the max size of PARTITION_DROP_ED.
I don't think we need to set the PARTITION_DROP_ED state here.
We can use the constants from ReplicaInfo.java
This is just debug line. I think we need to wrap in an exception.
This is just debug line. I think we need to wrap in an error condition.
This is just debug line. I think we need to wrap the exception in an IOException.
is it better to not show " isSubstringFoundOrdered" in this case?
is it possible to not return "null" (and isSubstringFoundOrderedInString).
is it better to not show " isSubstringFoundOrdered" in case of typos?
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these could be package-local. Also please annotate @VisibleForTesting
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-private and not be accessible to JSON
I would rename these to something like storageTypeStatsList or something along those lines since they're just testing the type template
I would rename these three test cases to better reflect what we are testing.
I would rename these three test cases to a better reflect what we are testing.
I think it would be better to do it in the synchronized block, in case of null pointer exception, we might get NPE
I think it would be better to do it in the synchronized block, in case of null pointer exception, we might get it in the future.
I think it would be better to do it in the synchronized block, in case of null pointer exception, we might get NPE in the calling code.
Same as above, try to simplify this by adding a little local variable.
Same as above, try to simplify this by adding a little method.
Same as above, try to simplify this by adding a method to simplification.
This can be handled by waitForRunningTaskToComplete accepting a callback function
This can be handled by waitForRunningTaskToComplete accepting a callback function that can contain the following code.
This can be handled by waitForRunningTask.
Change to branch.isRebaselined().
Change to branch.isRebaselined()
Change to a single check in the if-statement.
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other tests, because it makes the intention of the test unclear.
Please don't extract that into other methods, it makes the test unclear to me.
Please don't extract that into other methods, it makes the test unclear why it fails.
[minor] This can be simplified - if (timePartitioning!= null) {
[optional] This can be simplified - if (timePartitioning!= null) {
[minor] This would be better as a style - not required for testing
I don't understand why we are setting this for a reason.. why aren't we keeping the year from the app?
I don't understand why we didn't use the submitAppId. Was this a fix?
I don't see why we need a controller for this..
Isn't it better to call getLogger()?
Isn't it better to be System.getProperty?
Isn't it better to throw a NicException?
What is the point of storing the local variable? It seems like this could be used only once.
What is the point of storing the local variable? It seems like this could be useful.
What is the purpose of this?
We should use awaitility for the test instead of sleeping.
We should use awaitility for the test instead of wait.
You might want to add a fail() after the cleanup call.
I would suggest to use a constant string, this is the default value
I would suggest to use a constant string, this is the default value of 5
This string should be localized
only the try-catch
just returning returning tokenFuture instead
extract method
The field name is the base class, so this should be externalized.
The field name is the base class, so this should be externalized
The field name is the base class, so it should be externalized.
Do we really need to create this feature in the model? Seems to me that the model should be responsible for knowing what is visible and what is the user.
Do we really need to create this feature in the model? Seems to me that model.getErrata() is deprecated and the logic should be removed.
Do we really need to update the model from the model? Seems to me that the model should be responsible for knowing what is visible?
this function can be set to ensure that the qualifyingSet was used for the previous iteration. It was introduced in the original code, but I'm not sure why this assertion is needed.
this function can be declared in the qualifyingSet private utility method to remove the necessary code from the previous test.
this function can be set to ensure that the qualifyingSet was used for the previous iteration. It was introduced in the original code, but I'm not sure why this assertion is necessary.
space between if and (
space between if and ( )
type Intent and return in this places
check for null before deleting. Please use a possible NPE
check for null before deleting. Please use a possible NPE here
check for null before deleting. Please use a fix for this
Just stuff all this logic in "get" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getMarketingUpdate);
Just stuff all this logic in "getMarketingUpdate" so you have no idea what this does.
Just stuff all this logic in "getMarketingUpdate" so you have no idea what these two cases return Optional.ofNullable(getMarketingUpdate);
This seems to be a bit brittle. I think the following might be more readable: if (controlResult.getState()!= null) { return checkForDeterministicAndRerunTestQueries(); }
This seems to be a bit brittle. I think the following might be more readable: if (controlResult.getState()!= null) { return checkForDeterministicAndRerunTestQueries(); } else { return false; }
This seems to be a bit brittle.
Here and below: Please, remove curly brackets for one-line statement after if
Here and below: Please, remove curly brackets for one-line statement by using if: <LINK_0>
Here and below: Please, remove curly brackets for one-line statement by using curly braces { for one-line blocks!
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why this exception is logged?
Second parameter of Status is the pluginId. Why this exception is used?
Why can't we use PAResourceManager.RM_TOPOLOGY_ENABLED instead of the host?
Why do we need this condition?
Why can't we use PAResourceManager.RM_TOPOLOGY_ENABLED instead of the node?
Do we want to change the order in the ctor?
let's change the order in the ctor - its clearer when the source changes.
let's change the order in the ctor - its clearer when the source changes
Use Map<String, String>
Use Map<opponentGuess you can use the first opp's filter instead of card.getHand().
Use Map<String, char>
Nit: Just use Collections.singletonList() instead.
Just use Collections.singletonList() instead.
Nit: Just use Collections.singletonList()
shouldn't we add an assertion here that the activeOrder is not null?
Shouldn't we add an assertion here that the activeOrder is not null?
shouldn't we add an assertion here that the activeOrder is not null
May we detail the logger message a lit like > error in getting flow trigger <PojrectName_FlowName> in Quartz,
May we detail the logger message a lit like > error in reading flow trigger <PojrectName_FlowName> in Quartz,
May we detail the logger message a lit like > error in having flow trigger <PojrectName_FlowName> in Quartz,
Suspicious that the reference is the only place where the reference is I used to get it and I find the name of the method confusing.
Suspicious that the reference is the only place where the reference is in the tree.
Suspicious call to getSemanticModel() here.
Is no use case bound the only case may cause camera inactive?
Is no use case bound the only case can this be used?
Is no use case bound the only case.
nit: can we Ints.saturatedCast(numBytesWritten )?
nit: Could always use Ints.saturatedCast(numBytesWritten )
can we Ints.saturatedCast(numWritten )?
you could do this without relying on this condition.equals(sspToSingleTaskGrouper.get())
Why do you need this? Can't we just use Boolean.equals(sspToSingleTaskGrouper)?
Why do you need this? Can't we just use Objects.equals()?
Any reason to make these public?
Any reason to make these static imports?
Any reason to make these static imports here?
:bug: code style
:ant: use assertNull
:ant: use assertThrows
I think the app should be getPubmedIdsBySection instead of PatientID
I think this should be a call to getPubmedIdsBySection instead of PatientID
I think this should be a call to getPubmedIdsBySection instead of a boolean.
would this still full fill the smooth transition path without checking NullHandlingHelper.isNullOrDefault
would this still full fill the smooth transition path without checking NullHandlingHelper and lowercasing?
why is this change needed?
Maybe I'm missing something here. In the sirius, the models should not be explicitly set to the default.
Maybe I'm missing something here. In the sirius, the models should not be directly initialised.
Maybe I'm missing something here. In the sirius you know it is a local variable name.
This should be moved inside the try.
This should be moved outside the try.
Catching a general Exception type on failure seems unnecessary.
Consider logging the update stack trace and the problem could be more useful
Consider logging the update stack trace and the problem could be more useful.
Consider logging the update number of agents that are over the top of the file
ConfigSource member is usually populated with @Nullable.
I think this should be ExceptionHandler.TOPIC_CONFIG, as you're handling it twice.
I think this should be ExceptionHandler.getActiveConfigSource().
check for null?
return v?
return super.isInstance(feature);
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base is left empty.
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base is not empty, but jetty.base is?
Do we need to check if it's a url (name or something similar)?
Do we need to verify that there's a valid endpoint string for that reference?
Do we need to check if it's a url (name: "foo") to be safe?
This should be 'this.clear()' not in the method.
This should be 'this' not 'this'.
This should be 'this.remove' at the end of the method.
Shouldn't we also clear the RepositoryCloneWizard.setUp();?
Shouldn't we also register the addActionAction here?
Shouldn't we also clear the RepositoryCloneWizard.setUp()?
use ConcurrentUtils.withLock()
using AtomicInteger makes the need for this lock unnecessary.
using ConcurrentUtils.withLock()
this is not required, there is no need to have _metrics.xml
this is not required
this is not going to be a Set.
You could use a foreach loop of the entries to save the repetition a little bit.
You could use a foreach loop of the entries to obtain the desired data
You could use a foreach loop of the entries to obtain the desired data.
It seems like a good candidate for an explicit method getAuthorizationGrantType(ClientRegistration.CLIENT_CREDENTIALS) instead of this.
It seems like a good candidate for an explicit method getAuthorizationGrantType() to reduce the amount of nested calls.
It seems like a good candidate for an explicit method getAuthorizationGrantType(ClientRegistration.CLIENT_CREDENTIALS)
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Exception has this method to throw at most one checked exception. [![rule](<LINK_1>](<LINK_2>
This potentially long-running code seem to be doing more than once. The change in the previous version of the code is fine, but it's not really easy to read.
This potentially long-running code seem to be doing more than once. The change in the previous version of the code is fine, but it's not really making sense to me.
This potentially long-running code seem to be doing more than once. The change in the previous version of the code is fine.
What's with the old code?
What about the rest of the code?
What about the rest of the code here?
future.getPullServerPort() is deprecated now, so we don't need to cast it on every connection.
future.getPullServerPort() is deprecated now, so we don't need to set the future again.
future.getPullServerPort()?
What does "exit" mean here?
What does " indicates that this is a test for?
What about a single entry for this?
I think it would be nice to decrease the info level to trace, otherwise this is going to happen.
I think it would be nice to decrease the info level to trace after this is associated with details.
Can use lambda syntax.
shouldn't we also add a name for the throwable in here?
shouldn't we also add a name for the throwable here?
not sure whether this should be done in a finally block.
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } } This make very clear when a is set to null;
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; }
This is more efficiently stored as: java if (isDelegateScoped &&!isNormalScope(ij.isNormalScope)) {
This is more efficiently stored as: java if (isDelegateScoped &&!isNormalScope(ij.isNormalScope)) {... }
This is more efficiently stored as: java if (isDelegateScoped && normalScoped) &&!...
You could keep this declaration as the last statement, and remove the switch/case.
You could keep declaration as final
thread safety?
some null checks are redundant since we don't need the container here
some null checks are redundant since we don't need the container is unique
some null checks are redundant since we don't need the container since our checks are already present
The same is in this method below.
The same error message is in multiple places.
The same is in this method.
See above about "run_untagged"
See above about "throw new GitLabApiForm formData = Status.CREATED"
See above about "throw new GitLabApiForm formDataDetail registerRunnerDetail();"
I think we can have a static constant for the number of keys, like 100 and 1.
I think we can have a static constant for the number of keys, and values here name.
A comma?
For null values, we just do not supply those properties in the autoGenerationOption
How sure are you that these values were not already null before the rest call?
When will these last two lines ever get executed?
Also include the values here?
Also include the e in the exception here?
Also include the e in the exception?
isError()
Log all the error messages.
log all the error messages.
It would have been quite neater to have a method that does the check and set the status inside. Otherwise, the method will have to return false.
It would have been quite neater to have a method that does the check and set the status inside. Otherwise, the method will have to return true if it is not called.
It would have been quite neater to have a method that does the check and set the status inside. Otherwise, the method will have to return true.
Please fix the formatting.
Please fix the typo.
I would prefer to have the format arguments in here.
Arguments should be switched.
Shall we change this to a metricId?
config is never used.
I believe this should be logged at debug level and not info.
I believe this should be logged at debug level
I hope you don't mind, but when you do this please I would just log it as a debug message
Instead of this, why not just get rid of the negation?
Instead of this, can we have a test that the entity is still returned?
Instead of this, can we have a test that the entity is an entity and then iterate over it instead of looping over the collection.
I think we should verify that this method is actually called when the queue is CLOSED (ie throw exception)
I think we should verify that this method is actually called when the queue is CLOSED.
Move this to debug level?
We should probably add it here, since set is called first, then getConsumedEvents is called, not dispatches.
We should probably add it here, since set is called first, then getConsumedEvents is called, not inside set.
We should probably add it here, since set is called first, then set to the set.
suggestion p.run().setText("sc.run", "o", p.getId().get());
suggestion p.run().setText(";", p.getId().get());
suggestion p.run().setText("sc.run", "o", p.getId().contains(";")
We probably want a condition check here, i.e., should we only check if currentBatch is non-null here?
We probably want a condition check here, i.e., should we only check if currentBatch is null here?
We probably want a condition check here, i.e., should we only check if currentBatch is null here, and if it does it, we can't do a check first here?
suggestion assertThat(filter.beforeRequestMessage).startsWith(AbstractRequestLoggingFilter.DEFAULT_MESSAGE_PREFIX);
suggestion assertThat(filter.beforeRequestMessage).startsWith(AbstractRequestLoggingFilter.DEFAULT_AFTER_MESSAGE);
suggestion assertThat(filter.beforeRequestMessage).startsWith(AbstractRequestLoggingFilter.DEFAULT_MESSAGE);
Currently you are using MemberNotExistsException, if member is not TRUE -
Currently you are using MemberNotExistsException, if member is not TRUE characters. It should be allowed to be part of Bl layers.
Currently you are using MemberNotExistsException, if member is not TRUE characters. It should be allowed to be part of such method. Please remove it.
I think this should be an int. And it shouldn't be assigned to a double.
I think this should be an int. And can't use an Integer.
I think this should be arrays. And, to be consistent with how we compare the array.
I think this is the same as is done for FileSinkCommittableCommittableCommittableCommittableCommit.
I think this is the same as is done for FileSinkCommittableCommittableCommittableCommit.
I think this is the same as is done for FileSinkCommittableCommittableCommit.
final
Cosmetic: Curly braces on new line.
Cosmetic: Braces on new line, please. :)
"/"?
String.format?
String.format
Why 8192 is better extracted as a constant?
Would it make sense to move this setting into 8192 as well?
Would it make sense to move this setting into 8192?
Append assignnment to declaration
Append assignnvyDir. It is not a method
Append assignnvyDir if no change
Just use getOrDefault? int physicalSlotId = slotMapping.get(mSlotId); if (physicalSlotId!= null) { // for loop }
Just use getOrDefault? int physicalSlotId = slotMapping.get(mSlotId); if (physicalSlotId!= -1) { // for loop }
Just use getOrDefault? int physicalSlotId = slotMapping.get(mSlotId);
This is fine, but what does the rest of the code do?
This is fine, but what does the code mean? You should probably check for empty strings too.
This is fine, but what does the code mean? You should be able to initialize the variable with empty.
can we chain this with a class variable
can we chain this with a class name?
can we chain this with a class member?
Isn't it a bit hardcore for a mere selection of a random user? I'm not sure we should be swallowing this...
Isn't it a bit hardcore for a mere selection of a random host for the pool and keep the close of the db thing? I'm not sure we should be swallowing this silently
Isn't it a bit hardcore for a mere selection of a random host for the pool and keep the close of the db thing? I'm not sure we should be swallowing this. In the worst case, we should just set the session to null and throw a runtime exception if we don't update the db,
category
category should not be declared
category?
shouldn't need the throws declaration?
shouldn't need the throws IllegalArgumentException as the cause() method throws
shouldnt need the throws declaration?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I don't think these check can be required - the NullPointerException will be thrown down the chain anyway?
I don't think these check are required - the NullPointerException will be thrown down the chain anyway?
@jam01 Can you add another one here?
Cosmetic: Could you please add another variable to all the code?
Cosmetic: Could you please use jclouds variables instead of manually building it?
I wonder if this should be in the callback bus. If we use a dialog that starts the event, the view can't be canceled. Also, we are waiting for the event to be visible, so the user can click on it.
I wonder if this should be in the callback bus. If we use a dialog that starts the event, the view can't be canceled. Also, we are waiting for the event to be visible, so the user can't know what to do with it.
I wonder if this should be in the callback bus. If we use a dialog that gets visible, the view can't be deleted. Also, in the event that is visible, we don't really know what to do with this widget.
please remove the package prefix
you can remove this
you can remove the package prefix
null!= manager
getMatrixTableWidget?
null!=...
I'm just wondering if we should also do this in this method.
is this the same as for restart?
I think we can just do this in one line.
The Mockito.any(Mockito.any(Mockito.any(ClassName.class)); is better.
Is there any reason for that?
Is there a reason for that?
Can this be converted to a simple loop?
Can this be false?
Can this be removed?
else if (value == null) { throw... }
else if (value.getMin()!= null) {
This is redundant
NIT: use equals instead of!=
Nit: use () -> equals
Nit: use () -> equals()
Let's add segment = FileUtils.move(new File(dataSegmentFile)) at the end of the method, and call it there instead.
Don't use FileAlreadyExists implementation.
Fix indentation
Do we need this stack trace to be printed or should it just fail?
Do we need this? It looks like moving this test to it was missed.
Do we need this stack trace to be printed or should it just fail? We can't use assertTrue for it.
Please don't remove this. Just add a log.error statement itself.
Please don't swallow exception. Just let it be null.
Please don't remove this. Just add a log.error to there.
you could use model.getCifs()
you could use volume.isUser()
you could use model.isASD()
final?
> What if we use only the expected and actual here? Please apply the same order.
final and =
this, too?
this, too, put in try/catch
this, too, put in try-catch
We don't need to throw RuntimeException.
We don't need to catch RuntimeException.
We don't have to throw RuntimeException.
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the Follow-up rule
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the Follow-up logic in this file
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the test
Can you find a way to get oc without saniting?
Can you find a way to get rid of 'true' and use { }
Same as param
suggestion if (path.equals("")) {
suggestion } else if (path.equals("")) {
these two ifs can be combined with &&
nit: vt should just be an empty string.
nit: vt should just be an empty String.
Maybe refactor the entire test into a method.
I think the following is more correct: assertEquals(actual, expected, expected);
I think the following is correct: assertEquals(actual, expected, expected);
I think the following is more correct: assertEquals(actual, expected, expected, actual);
should it be at the beginning of the method, not the template string?
should it be: conversionTemplate = template.getOriginalKey();
should it be: conversionTemplate == null? template : convertTemplate to string
Seems like this could be simplified to something like event.getWorkflowConfigMap().
Seems like this could be simplified to something like event.getWorkflowConfigMap().add(event.getWorkflowConfigMap());
is this loop really necessary?
rename filterRoles to filterRoles
rename filterRoles to filterEnumerator
extract as a util method
There are a lot of different methods in this class, consider extracting this to a method.
There are a lot of different methods in this class, consider extracting this to a separate method.
There is a better way to make this: TextUtils.isEmpty(getResources().getColor(R.color.uri)) instead of defining this new code.
moodManager(1|2) should be final fields of the class.
moodManager(1|2) should be final fields of this class.
moodManager(1|2) should be final fields of the sender.
Should this not be flaky in this context? The test will fail if there are no processes, right?
Should this not be flaky in this context? The test will fail anyway, but I don't think that if the processDestroyer is not called (it's not interrupted).
Should this not be flaky in this context?
Hm, interesting way to check for a switch is here (yme): throw new IllegalStateException("Unable to determine tables: " + suspect + "mat", expression)
Hm, interesting way to check for a switch is here (yme): throw new IllegalStateException("Unable to determine tables: " + suspect + "mat", value)
Hm, interesting way to check for a switch is here (yme): throw new IllegalStateException("Unable to determine tables: " + suspect + "mat", value,...)
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
Remove this catch, so you don't do it if the exception is thrown. Really minor thing.
set a flag here saying : atleastoneunsetevent
Don't need List<String>
logic here could be replaced by KPaths.
logic here could be replaced by KPaths::add
Could we assert the case of the key and value?
Could we assert the case of the result?
nit: should probably assert the case of the exception
Can we short circuit here as well and return early instead of having to compute offsets?
Can we short circuit here as well and return early instead of having to compute the offsets?
Can we short circuit here as well?
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
any specific reason we have a separate function for this? I would suggest creating a generic function that takes the column number as a parameter, then both these functions can call that one with the appropriate column number
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate title.
no need for this change now
no need for that change now
no need for the extra check in line 119
Please add {}.
Please add braces.
Please add brackets around ||
mBanner = null (see line 82)
mBanner = null not null
mBanner = null
please replace lambda with method reference
please use Matchers.is
please use proper name than IncludedStructuralElement
@jijisv Could you please use a more specific method, like.addTaskAndWakeup( State.RESCHEDULE, State.RESCHEDULE) It will remove the taskAndWakeup() as well as the new static field.
@jijisv Could you please use a more specific method, like.addTaskAndWakeup( State.RESCHEDULE, State.RESCHEDULE) It will remove the taskAndWakeup() as well as the new private method.
@jijisv Could you please use a more specific method, like.addTaskAndWakeup( State.RESCHEDULE, State.RESCHEDULE) It will remove the taskAndWakeup() as well as the new static field?
You don't need to check that the messageIdleExceptionEvent is the same as the async one.
You don't need to call taskScheduler() in the test. I understand that it fails, but that's the first one.
You don't need to check that the messageIdleExceptionEvent is the same as the new one.
s/left/right/g
s/left/right/
nit: extra space after if
And here you can use Function.identity() since it will also be safe.
And here you can use Function.identity() to collect lists.
And here you can use Function.identity() since it will be more efficient.
Does it have to be the same reference or an isomorphic type?
Does it have to be the same reference or an isomorphic body?
Does it have to be the same reference or an isomorphic array?
Please handle it the null case.
Please remove this line.
Please handle it the null case. :-)
I'm not sure we should print the stack trace in this message.
Please make this: logger.info("Found server!"
Please make this more descriptive.
I don't think we need this map. Why not just pass in the BoundedRestoreSnapshot() call?
I don't think we need this anymore.
can we put this into a method?
Can we please mock the Future?
Can we please mock the Future? please mock the Future.
Can you please mock the Future?
We should remove the new line after the if.
Should we really need to create the BeanContributor here?
We should remove the new line before creating the class.
We are no longer supporting generic items from the data editor, so its a good thing if we are really using them.
We are no longer calling programs. I think its great to use only one thing during a call!
We are no longer calling programs. I think its a good idea to use its class loader.
Might want to ignore the exception? Was that intentional?
Might want to ignore the delay between the buffer and the send a response.
Might want to ignore the delay between the buffer and the send a Response value.
Nitpicking: Using entrySet might be clearer.
Nitpicking: Using containsKey might be clearer.
Nitpicking: Using entrySet might be easier to read
This can be moved outside the while loop.
This is not a good idea. If you move the iteration to the while loop, the while loop will not do anything.
This is not a good idea. If you move the iteration to the while loop, the while loop might not be executed.
Since we are using a constant for this, I think we should have the same check as "async".
Since we are using a constant for this, I think we should be consistent here.
Since we are using a constant for this, I think we should have the same check as http
Setting the style isn't needed for this component as this is the default already.
Setting the style isn't required for this component as this is the default already.
Setting the style isn't required here.
shouldn't this be a period?
shouldn't this be a session?
why is this needed?
You should also lazily initialize the exclusion list when exclusion is not provided, as it will slightly improve performance when calling the rule on multiple files during analysis.
You should also lazily initialize the exclusion list when exclusion is not provided, as it will slightly improve performance when calling the function on multiple files during analysis.
You should also lazily initialize the exclusion list when exclusion is not null.
Use of this.getClass().getCanonicalName() instead.
Use of this.getClass().getName
For consistency with the rest of the code, I think this should be a call to getClass().getCanonicalName() instead
Hey, please move this whole block outside the if/else, so we don't need to build it every time.
Hey, please move this whole block outside the if/else, so we don't need to do it every time.
Hey, please move this whole block outside the if/else, so we don't need to do it every time we need it.
In the previous version, the variable "LimitsSnapshot" is not used.
This line does not match with the session
In this change, the variable name does not match with the session
I would prefer to have a local variable for remoteGetConsistentHash(), like isRemotely(ctx, command). thenCompose(hasFlag(ctx, command))
I would prefer to have a local variable for remoteGetConsistentHash(), like isRemotely(ctx, command). thenCompose(hasFlag(ctx, command, false))
I would prefer to have a local variable for remoteGetConsistentHash(), like isRemotely(ctx, command). thenCompose(hasFlag(ctx, command).
ObjectMapper can be reused here too
What about replacing returned value (which is not a good idea).
What about replacing returned value (which is not a good idea)?
args.putArg(flagSplit[0], flagSplit[0]));
args.get(flagSplit[0], flagSplit[0]));
args.putArg(flagSplit[0], flagSplit[1]);
This should be handled right before this PR and have the user_type be in the resource itself instead of here.
this should be updated to 'this' because the user is not in the life mode
this should be updated to 'this' because the user is not in the life mode of this component
Can you make these 5 seconds a constant like the other timeouts?
can you make these 5 seconds a constant like the other timeouts?
I'm a little worried about this change. Can you make these 5 seconds a timeout for the test.
null check?
null check? (new byte[] {... }
null check
suggestion vertx.onSuccess(testThread);
suggestion vertx.onSuccess(testThread.get());
suggestion vertx.onSuccess(testThread.get())
Is this the main issue that these streams are running on the cluster?
Is this the main issue that these streams are running on the right thread?
Is this correct, or does it not redeploy everything?
s/updatePartialsFromOldMacPoolToNewOne/updatePartial()/
s/updatePartialsFromOldMacPoolToNewOne/updatePartialByScope
s/DbFacade.executeInScope/updatePartial()/
Let's put this in a constant.
Let's remove this string from the toString() call.
Let's remove this string from the getName() call.
0 is the default value for an int field. We do not make assignments to default values in constructors.
0 is the default character for an int field. We do not make assignments to default values in constructors.
0 is the default for an int field. We do not make assignments to default values in constructors.
Better to use a static import of Assert.fail() instead of a new line.
Move this to a @Before method and use it here.
Better to use a static import of Assert.assertEquals please.
I think this is the wrong place for this patch. It seems like this method should be private.
I think this is the wrong place for this patch. It seems like this method should be static.
I think this is the wrong place for this patch. It seems like this method should be static
don't we need to re-throw the exception?
don't we always want to check if the platform object is null?
unnecessary space
Maybe we could use a Redis pipe here as well.
Maybe we could use a Redis pipe here as well?
Maybe we could use a TreeMap here.
should use instanceof instead of isEmpty
Should use instanceof instead of isEmpty
should use instanceof instead
I think this should be name.get(CrudConstants.ERR_DELETE_METADATA_APP, name)
I'd think this should be name.get(CrudConstants.ERR_DELETE_METADATA_APP, name)
I'd think this should be name.get(CrudConstants.ERR_DELETE_METADATA_APP, name));
I think that there is no reason to create an empty PasswordGuess you have specified the method. This will allow them to be returned if the file is not present.
I think that there is no reason to create an empty PasswordGuessingActivity instance. This method is only used in the app, so there is no need to expose a System.out. :wink:
I think that there is no reason to create an empty PasswordGuess you have specified the method. This will allow them to be returned if the cursor is not present.
We should use the isEmpty method instead of checking null.
We should use the isEmpty method rather than checking null.
We should check null.
I think it's better to move this to the finally block
I believe this should be in the finally block, right?
remove the variable
Oof it's a huge bug but you can remove the throws clause. And maybe you could put the annotation in the CredentialNotFoundException. That way you will have to maintain the order in the end.
Oof it's a huge bug but you can remove the throws clause. And maybe you could make the exception message more concise.
Oof it's a huge bug but you can remove the throws clause. And maybe you could put the annotation in the CredentialNotFoundException. That way you will not need to put it there.
Is this line removed by mistake?
Is this line a duplicate?
Is this line removed for the 41?
domainList is no longer used, can we just use domainList here?
domainList is no longer used, can we just use domainList?
Wow...where we have already fixed this?
This variable should be changed.
Should have a space after the chromosomes here to make it clear what it is doing.
Should have a space after the chromosomes here to make it clear what it is.
<LINK_0>
[minor] You could put this in a single line, so that you don't have to duplicate the first line.
[minor] You can put this in a single line, so that you don't have to duplicate the first line.
What makes this status DOWNLOAD_ERROR?
What makes this variable name different?
What makes this status 'visible'?
Is this needed? You already have a RevCommit that does ObjectId if you want to match.
Is this needed? You already have a RevCommit that does ObjectId RevCommit =...
Is this needed? You already have a RevCommit that does ObjectId, no?
Add a IllegalArgumentException to IllegalArgumentException.
Why just throw RuntimeException?
Why do we need to throw an exception?
how does this differ from the previous code?
how does this differ from the previous one?
why this call is not done in RestRequest.
You can use Collections.builder()
You can use Collections.builder() here.
You can use builder.builder() here.
please set a modifier - protected seem suitable
Please set a modifier - protected seem suitable
shouldn't you set this as _vds.getMessage()?
I don't think "MOBS" is more readable
I'd put "MOBS:" and "xML" into a constant
I'd put "MOBS: " + x,..." into separate messages
cleanup this temp dir afterwards
close this temp dir afterwards
cleanup this test
rename to fileName
rename to propertyName
rename to propertyName and name
Couple of things here: (a) we can use Preconditions.checkArgument here? What about throwing IllegalStateException?
I think we should use Preconditions.checkArgument here.
I think we should use Preconditions.checkArgument here?
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place. And you should deal with the failure mode that shouldn't have been there in the first place.
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in this case.
No need for null check here.
No need for null checks here.
Just pass in the error message for the exception
This try/catch block could be removed.
This is a bit confusing. I guess we could use direct call to migrate.
This should be package local
nit: extra space after if
nit: since it is obvious that the buffer is always 0, then you can drop the else block
nit: since it is obvious that the buffer is always 0, then you can drop the lastRead flag.
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
This should probably get called after the above resolve() call.
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass.
why final variable? :-)
why final variable? :-) Same below
why final variables? :-)
unnecessary new line
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since test will fail on Windows.
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since testName will throw the exception.
Can we make this check visible to the run method, shouldn't it already be handled there?
Can we make this check visible to the run method, shouldn't it still be handled there?
Can we make this check visible to the fast delete?
We should not cancel local partition we should set the priority here.
We should not cancel local partition here, both the Partition and the Partition both are not going to be closed.
We should not cancel local partition here, both the Partition and the Partition both are not going to be more readable.
Would it be better if we could store the result of 'found'?
Just wondering, we could update the method name here.
Would it be better if we could store this in the field declaration for clarity?
Remove this intermediate variable.
Should we make this intermediate commit point *configurable*?
This is an email only
try/catch
Try/catch
remove try/catch
s/hasLastRow/isLastRowDescription/
s/hasLastRow/hasColumnDescription/
s/hasLastRow/isLastRow/
You can use SubMonitor#convert() here.
You can use the two-argument constructor
You can use the two-argument constructor here.
I think that this is not needed, @korthout
I think that this is not necessary, @korthout
I think that this is the default location of the file, not the test.
Consider switching to.filterField!= null &&!aggregates.isEmpty()?
can this be the default function name?
can this be the one above?
This should also have some way to read this from the UI. The is here because the features is not empty, the code will return null, so we may need some way to check it.
This should also have some way to read this from the UI. The is here because the features is not empty, the code will throw an exception, and that is not executed. This is the root cause.
This should also have some way to read this from the UI. The is here because the operation is not specified in the UI.
suggestion logger.warn("Could not add {} with the same uid. " + element.getClass().getName(), uid);
suggestion logger.warn("Could not add {} with the same uid. " + ex.getClass().getName(), uid);
suggestion logger.warn("Could not add {} with the same uid. " + element.getClass().getName());
@cvrebert let's inline this variable.
@cvrebert let's avoid composite names: let's rename this variable to basebranch
@cvrebert let's inline this variable?
nit: Flux.just
nit: spaces between + also
nit: spaces between +
This looks like a very strange change. Can you please extract this into a method (e.g. getExtensionPattern())?
This looks like a trace and should be removed.
This looks like a very strange change. Can you please extract this into a method?
Is this potentially slow? Can't we pass rowSize into the reaper?
Is this potentially slow? Can't we pass rowSize as a parameter?
Is this currentRow the instance of Partition which was just created?
Some left overs..? :)
Some left overs within some source? :)
Some left overs.? :)
This is a good idea to have the try-catch at the end of the test, i.e. method signature. It's not used anywhere else.
This is a good idea to have the try-catch at the end so we can remove this else.
This is a good idea to have the try-catch at the end so we can remove this exception completely.
We could use else if here.
We could use [containsHeader(type)](<LINK_0> instead.
We could use [containsHeader(name)](<LINK_0> instead.
deadlocked_monitor would be more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between these two metrics.
deadlocked_monitor would be more typical. I'd suggest expanding the help a little too so users will get idea of the difference between these two metrics.
toString is not going to be very helpful. I'd suggest expanding the help a little bit too so users will get idea of the difference between these two metrics.
Should be cachedBlock.
Should be cached in a local variable.
Should be cached in a field.
Don't like this, check isContent before trying to read all the header, and if the check is done.
Don't like this, check isContent before trying to read all the header, and if the check is to ignore the old value, then remove it.
Don't like this, check isContent before trying to read the header, and if the check is to ignore the old value, then use it.
Should be "ogc".
Should be "ogc" I'm guessing that would come into play here.
Should be "ogc" here.
This should be getClass().getSimpleName() instead of getClass().getSimpleName()
This should be getClass().getSimpleName() not getClass().getSimpleName()
This should be getClass().getSimpleName()
More a question about returning type to the log message here.
More a question about returning type to the log statement here.
Consider using {} for if statements.
I think settingsObject can't be null here since asList returns a non-null value.
I think settingsObject can't be null here since sWoa has gone.
I think settingsObject can't be null here
This is a refresh issue. The icon is not set when the reference is a particular element and the reference is not a DWRF one.
This is a refresh issue. The icon is not set when the reference is a particular element and the element is not a DWRF one.
This is a refresh issue. The icon is not set by the view of the edit type and the call to refresh on it.
This line is repeated in AgentService.startAddress. Is it intended?
This line is repeated in AgentService.startAddress. Is it intentional?
This line is duplicated
SegmentLoadingException is specifically checked for in a few places that treat it differently from a generic runtime exception. Please keep it.
SegmentLoadingException is specifically checked for in a few places that treat it differently from a generic runtime exception. It might be better to keep it.
formatting
That's a small thing, but the variable should be called HandlerContext.getAttribute(HandlerContext.class) (which is the same as the method above).
That's a small thing, but the variable should be called HandlerContext.getAttribute(HandlerContext.class) (which can be reused by other methods).
That's a small thing, but the variable should be called HandlerContext.getAttribute(HandlerContext.class) (which is the same as the method above)
ditto constructor
ditto code
add a line break
Magic constant? Should be close in a finally block
Magic constant? Should be close directly
Magic constant? Should also be close the reader?
could you use a entrySet() here instead? Also, if we go with a [get()](<LINK_0>, we still need to append the key in the map.
could you use a entrySet() here instead? Also, if we go with a [get()](<LINK_0>, we still need to toString() it.
could you use a entrySet() here instead? Also, if we go with a [get()](<LINK_0>, we still need to toString() it, that may be fine.
Would be better to use the org.ovirt.engine.core.common.businessentities.Disk.class.name() == null, Snapshot.class.getDescription() if null is passed via the backend enum, and if null, then the backend should return an enum, otherwise the backend enum will never be returned.
Would be better to use the org.ovirt.engine.core.common.businessentities.Disk.class.name() == null, Snapshot.class.getDescription().getId())
Would be better to use the org.ovirt.engine.core.common.businessentities.Entity.class.name() instead.
The return code?
The return code could be avoided with: java return getRetry(rc);
The return here may not be necessary.
I don't know why we need this method to return null, and we should avoid the null check below. If this is what is meant for.
I don't know why we need this method to return null, and we should avoid the NPE below in line 97
I don't know why we need this method to return null, and we should avoid the NPE below in line 97.
Can we remove all these stream calls?
Can we remove distinct() here?
Can we pull all the stream creation into a field?
again IBM-specific i would go with "IBM specific"
again IBM-specific i would go with "IBM specific"?
again IBM-specific i would go with "IBM Map"
I guess this else block could be removed?
I guess this should be a switch-case?
I guess this else block could be removed.
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond( Quaterniond);
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond(T>() { Quaterniond.fromAxesClassName(start, distance, distance, filter); };
Could be simplified to: suggestion Quaterniond rotation = new Quaterniond(T>() { Quaterniond.fromAxesClassName(start, distance, distance, distance, filter); };
You called setMustExist(true) twice here. At least one of those is unnecessary.
You called setMustExist(true); twice here. At least one of those is unnecessary.
You called setMustExist(true) twice here. At least one of those is unnecessary. :-)
This line should be in the same line as the previous one
This line should be moved before the if
@manstis I don't know what is the point of the new way to get the lastPlotWidth and end of the loop
The role strings are returned by CuFPConstants. Are there some special reason we don't want to support that?
The role strings are returned by CuFPConstants. Are there some special reason we don't want to support this?
The if statement here is not necessary, right?
We can use days.equals(months )
We should check this to see the system in the "only" format.
We should check this to see the user in the bug report.
<LINK_0>
Should be threshold = Math.min(m1, usage2)
Should be threshold = Math.min(max1, usage2)
What if we change this behaviour? Is it intended?
What if we modify the.cancel to true? Is that intended?
What if we change the.cancel to true? Is that intended?
getDrawable is deprecated and may be called by the ContextCompat.getDrawable(context, R.drawable.***)
getDrawable is deprecated and may be called by the ContextCompat.getDrawable(context, mView)
getDrawable() is deprecated and may be called by the ContextCompat.getDrawable()
Might be better to move this to handleShall we also log all the message processing.
It is not needed since you are already calling executeMethod.
Might be better to move this to handleUrl() method.
If the goal is to use multi-catch, then we should probably do it in the other code.
If the goal is to use multi-catch, then we should probably do it in a finally block.
If the goal is to use our own nonNull method, then you don't need to use it.
please use getAuthzName() instead of dbUser.getAuthzName()
Use getAuthzName() instead of dbUser.getAuthzName()
please use getAuthzName() instead of dbUser.getAuthzName().
I don't know if this can happen but we might want to log it here since we can do the same thing on different places.
I don't know if this can happen but we might want to log it here since we can do it on other places.
I don't know if this can happen but we might want to log it here since it may be hard to debug.
Should use host_uuid/name here.
Should use host_uuid and host_uuid
Should use host_uuid
It seems like we're making a mistake here. Should we move the check for a constant somewhere?
It seems like we're making a mistake here. Should we move the comma at the end of the previous line?
It seems like we're making a mistake here. Should we move the comma at the end of the string instead?
This block seems to be i think that it's the only thing to do here and not as an instance of annotation.
This block seems to be i think that it's the only thing to do here and then conditional on that has no value.
This block seems to be i18nized.
I don't think we need this unchecked cast. We can save the cast on this:.stream().anyMatch( annotation -> isAnnotationAllowed( clazz, processedAnnotations ) )
I don't think we need this unchecked cast. We can save the cast on this:.stream().anyMatch( annotation -> isAnnotationAllowed( annotation, processedAnnotations ) )
I don't think we need this unchecked cast. We can save the cast on this one.
please use Map<String, GlusterStatus>
please use Map<String, GlusterStatus> and change it to HashMap
please use Map<String, GlusterStatus> and change it to key
I think we can simplify this method by: java return new DistributedQueue<T>(String itemNode, long start, int endItemsBeforeRefresh, long start, int endItemsBeforeRefresh, int endItemsBeforeRefresh, long end); It's less readable, and we'd avoid the break.
I think we can simplify this method by: java return new DistributedQueue<T>(String itemNode, long start, int endItemsBeforeRefresh, long start, int endItemsBeforeRefresh, long end); It's less readable, and we'd avoid the break.
An alternative would be to either do this or remove the overload if it was already there.
Is it sufficient not to compare getId() because TrackInfo#equals already considers mId? (ditto for others)
Is it sufficient not to compare getId() because TrackInfo#getId() considers mId? (ditto for others)
Is it sufficient not to compare getId() because TrackInfo#getId() doesn't contain any information on the driver.Id?
I think it's better to throw an exception if the visit isn't null.
I think it's better to throw an exception if the visit is not null.
I think it's better to throw this exception explicitly.
Please use the [try-with-resources](<LINK_0> syntax instead of "job1".
Please use the [try-with-resources](<LINK_0> syntax.
Please use the [try-with-resources](<LINK_0> syntax instead of "job2".
Why is the intent lower bound here? Isn't the wildcards already doing type1?
Why is the intent changed here? Isn't the wildcards wildcards already doing type1?
Why is the intent lower bound here? Isn't the wildcards already used if there is enough?
nit: can remove final.
nit: can remove final here and other examples.
%n
Formatting.
Formatting: add spaces around if block
Formatting: add spaces around ifs
rename to dir
rename to attemptFree
rename to attemptMatch
Can you move it down with if (LOG.isDebugEnabled()) { LOG.error(id, e); } block?
Can you move it down with if (LOG.isDebugEnabled()) { LOG.error(msg, e); } block?
Can you move it down with if (LOG.isDebugEnabled()) { LOG.error(id, e); }
why not use subsystemWriter.writeContent() here?
why not use subsystemWriter.writerDefinition(entryMapper, t); here?
why add this check?
IIUC, you are still closing the input stream here. Would it make sense to use try-with-resources, to close the streams in a finally block?
I'm not sure if we need to close streams here. Can't we use try-with-resources here?
I'm not sure if we need to close streams here. Can't we use try-with-resources around the close?
Please add a get() method
Please put the instance name in a variable
Please put the instance id in a variable
@maria-farooq Hmm, this line should also be removed. The remove is in this particular place for the code, right?
@maria-farooq Hmm, this line should also be removed. The remove(callInfo) method is called below (callInfoMap.remove(senderPath));
@maria-farooq Hmm, this line should be removed. The remove is in this particular place for the code, right?
I would use the same filter function here, e.g. extract a method and compare() with bibFile::endsWith() and bibFile.
I would use the same filter function here, e.g. extract a method and compare() with bibFile::endsWith()
I would use the same filter function here, e.g. extract a method and compare/asserts/else objects.
1. Consider moving this piece of code to the parent toggleGhost 2. should consider also 'enabled'
1. Consider moving this code to the parent toggleGhost 2. should consider also 'enabled'
1. Consider moving this piece of code to the parent toggleGhost 2. should consider also 'value'
I don't see the reason for this change, as it was before.
I don't think we need to change this, just remove it.
I don't think we need to wrap the exception in it.
mkPreview returns null here, so you don't have to set the input to null. The line number will be null here.
mkPreview returns null here, so you don't have to set the input to null. The line number will be null here anyway.
Unnecessary?
System.out?
LOG.error?
System.out.println
I think we don't need to check if the variable is null. You can use Optional.ofNullable()
I think we don't need to check if the variable is null. You can use ServerVariable.fromVariable(io.getVariable())
I think we don't need to check if the variable is null. You can use ServerVariable.fromNullable(io.getVariable())
Probably, there is something wrong with idenations.
Probably, there's something wrong with idenations.
Probably, there is something wrong with idenations and values
I believe this should be true?
I believe this should be true only if there are other areas in the same package.
I believe this should be true only if there are other instances of this.
Same here about the use of the null check below
Same here about the use of the null check below.
Same here about the use of the null check.
sysout?
sysout? :)
sysout
Consider the following code: * Move the calls to rbStore[3]Store[3](length); * Remove the set of parentheses on the next line. * Remove the if (rocIn) { rbStore[3].length(); } * /** * @param a method on a deprecated object. * * @param the value to add the rocIn * @param the value to store. */ public void add(byte) { rbStore[3](byte) ); } private void add(byte) { rbStore[3](byte) { rbStore[3](data); } public void add(byte) { rbStore[3](byte) { rbStore[3](data); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) {
Consider the following code: * Move the calls to rbStore[3]Store[3](length); * Remove the set of parentheses on the next line. * Remove the if (rocIn) { rbStore[3].length(); } * /** * @param a method on a deprecated object. * * @param the value to add the rocIn * @param the value to store. */ public void add(byte) { rbStore[3](byte) ); } private void add(byte) { rbStore[3]((byte) ); } public void add(byte) { rbStore[3](byte) ); } public void add(byte) { rbStore[3](byte) { rbStore[3](data); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore
Consider the following code: * Move the calls to rbStore[3]Store[3](length); * Remove the set of parentheses on the next line. * Remove the if (rocIn) { rbStore[3].length(); } * /** * @param a method on a deprecated object. * * @param the value to add the rocIn * @param the value to store. */ public void add(byte) { rbStore[3](byte) ); } private void add(byte) { rbStore[3]((byte) ); } public void add(byte) { rbStore[3](byte) ); } public void add(byte) { rbStore[3](byte) { rbStore[3](data); } public void add(byte) { rbStore[3](byte) { rbStore[3](data); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void add(byte) { rbStore[3](service); } public void
you must use "XXX name". Also, the message should be externalized.
you must use "final". This applies to other messages.
you must use "final". XXX appears to have been doing the same thing
what if getTreeLogger().log(Class) returns an instance of the class?
use INJECTOR_ANNOTATION constant instead of hard coding the value?
use INJECTOR_ANNOTATION_GINJECTOR_ANNOTATION
one more test also with an assertion on the three principal of the two?
one more test also with an assertion on the three principal of type.
one more test also with an assertion: compareTimeMap(x.e. timeMap)
You should always set the subscriber to null in this case instead of calling get.
You should always call onNext before the channel is closed.
You should always set the subscriber to null in this case.
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no need to save it from all the DAOs.
This entire method is redundant. What you should have as well replace it with.
oh yeh
Not sure about this. The same logic is in two places.
Not sure about this. The semantics of write don't like this is guaranteed to return a non-null value for the first byte[]. In this case, you have to send the Buffer that is not the stream.
Not sure about this. The semantics of write don't like this is guaranteed to return a non-null value for the first byte[]. In this case, you have to send the Buffer that is not the length of the file.
can we define 'ex' as default value at VoiceCallLeg' and use that constant for the callLeg
can we define 'ex' as default value at VoiceCallLeg' and use the same constant?
can we make this string a constant?
I don't see any reason for this change. Before, we would use assertEquals(String, long), which is more than the line expected.
I don't see any reason for this change. Before, we had a timeout to stdout with a timeout of 2 rows.
I don't see any reason for this change. Before, we would use assertEquals(String, long), which is more than the line.
this is unnecessary - the frame will come in and therefore the managementRegistry will come in the map.
this is unnecessary - the frame will come in handy when the pool is shut down.
this is unnecessary - the frame will come in and therefore the managementRegistry will come in here.
i'd rephrase to warn
i'd use: warn
i'd suggest to move the logging line after the 'if'
It's better to use LOGIN_SEARCH_CAPABILITIES for consistency.
It's unfortunate that we have to specify the privacy consent options.
It's better to use LOGIN_SEARCH_CAPABILITY instead.
For other exceptions, can we catch the RuntimeException and rethrow it as IllegalStateException? I'm not sure we care to have to catch it.
For other exceptions, can we catch the RuntimeException and rethrow them the same as catching them? I'm not sure about that.
For other exceptions, can we try to resume all the time?
Can we check on a resourceProfile being null?
Can we add a map to the resourceProfile map? That way we will have a map on the resourceProfile twice.
Can we add a map into the map?
Pull this uri logic out into a separate method and then call it from these methods
Pull this uri logic out into a separate function and then call it from these methods
Pull this uri logic into a separate method and then call it from these methods
nit: to make this a bit clearer, can we just pass in the arguments
nit: to make this clearer
nit: to make this a bit clearer
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
Hello @mcimbora I think the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the presenter as well.
should we assert that this value will never be positive?
should we assert that this value will never be negative?
should we assert that we never get here?
Looks like this will fail if the refset is not encoded?
Looks like this will also fail if the refset is not null.
Looks like this will also fail if the refset is not encoded?
It seems like a candidate for an isEmpty() method to check for null
It seems like a candidate for an isEmpty method. Is there a case when we want to check for null
It seems like a candidate for an isEmpty method to check for null
Replace this with: if (userId == null) { keys.add(user); }
Replace this with user = getActiveUserKeys();
Replace this with: if (!user.getCallingUser()) { keys.add(user); }
You need to pass result._source instead of just result as a profile content.
nitpick: You need to pass result._source instead of just result as a profile content.
You need to pass result._source instead of just result as a profile content._source
if we are outside of the loop, then there is no need to re-check the state of the temp directory...
if we are outside of the loop, then there is no need to re-check the logic.
if we are outside of the loop, then there is no need to re-check the old configuration here.
Same: static import for consistency.
Same: static import for readability.
Same: static import for consistency with the other classes.
you are passing 'true' to 'exitStatus' in case of FAILED as well.
you are passing 'true' in case of 'exitStatus' in case of FAILED as well.
you are passing 'false' to 'exitStatus' in case of FAILED as well.
nit: use final TopicNode topicTopic = childTopic;
why do we need this line?
why do we need this condition?
Can you also check what the code is doing in transaction.delete below?
Can you also check what the code actually was doing in this PR?
Can you also check what returned means.
I guess this could be moved to a separate method
I guess this could be moved into a separate method
I guess this could be moved into a separate method.
Shouldn't we at least log this error?
Shouldn't this be "which" instead of "mySQL"?
The alternative is to call get...that will cause the connection to be closed.
Check source data. And same for below.
You can fix this.
You can get rid of this.
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters.putAll(parameters); }
I feel like the previous code was better, since we still create a new map for our own internal data structure. What do you think? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters.putAll(parameters); }
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (!parameters.getParameters().get(Property.class)) { glueParameters.putAll(parameters); }
Instead of passing the exception to this method, we can create a specific exception so we can handle it in a cleaner way.
Instead of passing the exception to this method, we should validate the errors using the service.
Instead of passing the exception to this method, we can create a specific exception so we can handle it in a way that it is obvious in the future.
Can you move this if statement outside of the try?
Can you move this if statement outside?
Can you move the util class of the class?
Shouldn't be the first condition.
Shouldn't be Elasticsearch.Index(filtersToQuery)?
Shouldn't be Elasticsearch
try to exploit map and co for this method
try to exploit map and co for this function
try to exploit map and co for this class
It was left from debugging. I'd remove it
It is left from debugging. I'd remove it
It's going to work with one or two  chars per line
Right, we can avoid doing Set.of and use another Collection.
Let's remove this empty line.
Right, we can avoid using Set.of and use another Collection.
We should not log the error, and print the entire stack trace.
We should not print the stack trace. Who will call this method?
We should not print the stack trace. Who will call this method.
Please add the permission needed => "Requires 'Administer' permission on the specified project"
Please add permission needed => "Requires 'Administer' permission on the specified project"
Please add the permission needed => "Requires 'Administer' permission on the project"
I think that you should also check the actual size of the commit. <LINK_0>
I think that you should also check that the first change is the actual commit.
I think that you should also check that the first change is the actual commit. <LINK_0>
What is the purpose of this loop?
What does the optimizer mean?
What are the names of the variables expected?
commandName is declared here. I think I'd prefer to keep this constant (and the command name).
commandName is declared here. I think I'd prefer to keep this variable unchanged.
commandName is declared here. I think in this case it would be better to define final variable
Is it possible to convert to a String and then back to a byte array? I think that the method should be renamed to avoid duplications
Is it possible to convert to a String and then to a byte array? I think that the method should be renamed to avoid duplications
Is the formatting necessary?
Not sure if this is the best place to do this check.
Not sure if this is the best place to do this.
Not sure if this is the best place to do this
What about TimeUnit.SECONDS.toMillis(uptime)
What about TimeUnit.SECONDS.toMillis(long milliseconds)?
What about TimeUnit.SECONDS.toMillis(idleMilliseconds)?
Interesting, so this one is ineffective?
Interesting, so this one is a bad idea :)
Interesting, so this one is unlike the edit page eh
You could use the AbstractParameterizedType annotation to get a provided group for the label.
You could use the AbstractParameterizedType annotation to get a list of group properties map.
You could use the AbstractParameterizedType annotation to get a provided group.
This clause is redundant.
This clause is already done in a separate method
This clause is already done in a few other places
Why is only a remote unlock acceptable? I know right now we don't actually need local unlock commands because we only use them for remote lock.
Why is only a remote lock now? I know right now we don't actually need local unlock commands because we only use them for remote lock.
Why is only a remote unlock acceptable? I know right now we don't actually need local unlock commands because we only use them for remote tx cleanup, but would it complicate things to allow them anyway?
What happens if there is a repository named "s" in the "s"? I think we should return true.
What happens if there is a repository named "s" in the s3f? I think this change should be still work.
What happens if there is a repository named "s" in the "s"? I think we should be able to use FileRepositoryMapping.getRemoved().
Can you log this as a warning?
Can you log.warning(" found: ", idsList);
Can you log warn here?
should be logGenotypeLikelihoods = allele1 && allele2
probably want to suggestion logGenotypeLikelihoods = allele1 + nGeno2 + 1
should be logGenotypeLikelihoods = allele1 && allele2(snp, user,
'else' would be clearer here: if (Objects.equals(attribute.getName())) { return null; }
'else' would be clearer here: if (Objects.equals(attribute.getName())) {'
Consider using ObjectUtils.isnot(null) here.
should it be internationalized like others buttons?
can it be internationalized like others buttons?
should it be internationalized like others buttons?
I'm still confused why this. Why are we visiting this and returning the value in this method?
I'm still confused why this. Why does the same thing with "id" and "ID" in both cases?
I'm still confused why this. Why does the same thing with "id" and "id" as a parameter?
Again, move this to line 92.
Again I think this is correct..
Again I think this is correct.
Why are we comparing with the name of the topic?
This test should be testing against the batch size.
This test should be testing against the owner of the topic--name.
Why is this necessary? Couldn't we write the test w/o it and then directly fail if shutDownCluster is being called?
Why the change? Couldn't we write the test w/o it and then directly fail if shutDownCluster is being called?
Why is this necessary? Couldn't we write the test w/o it and then directly fail if shutDownCluster has been called?
I think this should be debug
I think this should be info
I think this should be debug or info
any reason to not have this as Set<StoreKey>?
any reason to not duplicate this?
any reason to not do this? Set<StoreKey> blobName = new HashSet<>();
Is this line safe? I don't think it's necessary since it's part of the code above.
Is this line safe? I don't think it's necessary since it's part of the if (v.length == 0 &&!array.isEmpty()) However, I think this is fine and may be potentially more readable.
Is this line safe? I don't think it's necessary since it's part of the if (v.length == 0) check below, but I think this is fine.
Nitpick: I found this a little bit easier to read: final MARGIN_SCREEN*2
Nitpick: the finally block is redundant.
Nitpick: the same thing around final.
This is no longer needed if we remove.
This is no longer needed if we get the same information.
This is no longer needed if we remove the generic args update.
Could we just check if the data source isRoot.isPresent()?
Could we just check if the root class is a boolean?
I don't think this is what is defined for.
maybe you can instead use logger.debug("Found updated template file {}", modifiedFile);?
maybe you can instead use logger.debug("Found updated template file {}", e.getMessage());?
maybe you can re-use the logger?
I wonder if this test should wait for the reply collection instead to fail the test. WDYT?
I wonder if this test should wait for the reply message to be TRUE level somewhere. What do you think?
I wonder if this test should wait for the reply message to be TRUE level somewhere. What do you think?
[minor] Why not make Pattern.compile() into a variable?
Shouldn't this match only if email address is null?
[minor] Better to use regex instead of compile here?
I'm confused. The 'alwayslink' here is the same as the one above *should* be called *before* the feature is updated - is this intentional?
I am not sure why the behavior is 'alwayslink' here. The 'ics' will have no 'attribute' to the end of the rule. The problem is that if you move the logic to the 'ics' from 'a' to add a blank line before the.attributes().has("alwayslink")
I am not sure why the behavior is 'alwayslink' here. The 'ics' will have no 'attribute' to the end of the rule. The problem is that if you move the logic to the 'ics' from 'a' to add a blank line before the.attributes() call.
LGTM = Looks Good To Me
Assert.isNotNull()
Assert.isNotNull
Could we move this check to the top of the function?
Could we move survey.getSurveyByModule(survey.getSurveyByModule()) before check if the survey is in the cache?
Could we move survey.getSurveyByModule(survey.getSurveyByModule()) before check if the survey is aeyesee?
Typo in a method name
Typo in the method name
Typo in source source
Same as above, why is this needed?
Can you refactor this to be able to reuse the same format code?
Can you refactor this to be able to reuse the same change?
exception message doesn't match cube id
RuntimeException
exception message doesn't match. Exception will be thrown from cube
We should probably move the initInternal() call into the sTargetInitialized.
We should probably move the initInternal() call into the 'init()' method.
If this method fails, it should probably throw an illegal argument exception. We should consider using return() instead.
nit: space after if
nit: make it final
nit: make this final
Here we are setting up the true and not setting anything, so it should be fine
Here we are setting up the true and not setting anything, so it should not be set
Here we are setting up the true and not setting the focus on the button, so it should be fine
I think this log line is too long
I think it would be a bit cleaner to put this line after the try/catch block, so that we have a chance to add the exception to the log statement.
I think it would be a bit cleaner to put this line before the try/catch block to avoid nested blocks of code.
Why e?
Why not: throw new CustomFilePersistenceException("Custom class " + e)
Why not: throw new CustomFileDownloader
why do we need to log the exception?
why do we need to log the exception here?
why do we need to log the exception here?
s/non-null/empty/
s/B/a/
s/non-null/inmanent
Oh, so the number of retries actually includes as well.
Oh, so the number of try as well.
Oh.
Is this aLocatedBlock task? I don't see how busy does it.
Is this aLocatedBlock task? I don't see how this is going to work
Can we pre-calculate this for now?
I wonder if we should use an enum for NODE_DIST_NAME here.
I wonder if we should use an enum for NODE_DIST_VALUE.
Should we use an index here?
extract a variable
extract a variable to improve readability
extract to variable
This line is too long: @ScalarFunction @Description("Calculates the great-circle distance between two points on the Earth's surface") @Nullable double calculateDistance(Math.sin(doc, "toRadians)"))
This line is too long: @ScalarFunction @Description("Calculates the great-circle distance between two points on the Earth's surface") @Nullable static final double DOUBLE = dist * (SquareIn == lng1)
This line is too long: @Coordinates(paul)
Please remove as this is related to the fix required in #6610
Please remove as this statement is related to the fix required in #6610
Please remove as this is related to the fix required in #661025
assertThat(statistics).hasOnlyKeys("keyB")
assertThat(statistics).hasOnlyKeys("keyA")
assertThat(statistics).hasOnlyKeys("keyB").hasSize(2);
This should have changed to && docValues.equals(searchAnalyzer) as well.
This should have changed to || so that we don't have the full parenthesis.
This should have changed to && docValues.equals(searchAnalyzer)
Not sure worth changing a deprecated class.
Not sure worth changing a private static.
Not sure worth changing a private static for this.
OPEN_PET_FOOD_FACTS_FOOD
OPEN_PET_FOOD
OPEN_SIACTS_FOOD_F
space after cast parens
don't need both classes?
double semicolon
Changed to be true?
Changed to be true.
Changed to be false.
This is going to log the reactive stream Subscription
Context context = new SimpleResponse<>( options);
Context context = new SimpleResponse<>( options.getModelVersion(), language);
The layout could be passed in the constructor.
The layout should be passed in the constructor.
The layout could be passed in?
This log message makes no sense, if the user goes wrong here. I would move it to the log line.
This log message makes no sense, but usually occur outside the if, and after the null check.
This log message makes no sense, if the user goes wrong here. I would move this line down to the if clause.
I think we could use DCPanel.DEFAULT_INPUT_EVENT_RENAME here
I think we can use DCPanel.DEFAULT_INPUT_EVENT_RENAME here
I think we could use DCPanel.createDatastoreButton() here
You can use params.contains("sponsor") to check if the parameter is available. Using that, you don't have to deal with the exception anymore.
You can use params.readInt("sponsor") to check if the member is available. Using that, you don't have to deal with the exception anymore.
You can use params.contains("sponsor") to check if the member is available. Using that, you don't have to deal with the exception anymore.
See below, the requirement should always be Status.
See below, the requirement should always be Status, just set the old endpoint.
See below, the requirement should always be Status, just set it here and leave it at all.
Should it be >= and not <=?
Should it be >= or some other number in the string with a descriptive message?
Should it be >=?
I would change this to WARNING. instead of Exception.EMPTY (just for now)
I would change this to WARNING. instead of ERROR.EMPTY (probably a typo?)
I would change this to WARNING. instead of ERROR.EMPTY (just for now)
Again, the id is not "owningCommunity" here. These variables (in this method) and this error should be renamed to say something like "parentCommunity" instead.
Again, "owningCommunity" isn't a concept in DSpace. These variables (in this method) and this error should be renamed to say something like "parentCommunity" instead.
Again, the id is not "owningCommunity" here. These values should be the first Community" class and not the SubCommunity.
Same here, this line is too long
Does this need to be rebased?
Is this line really needed?
It looks like this condition is already replaced by!models.isEmpty()
It looks like this condition is already present in the if/else above.
It looks like this condition is already present in the parent class
This will only work for sacrificeances support.
This will only work for sacrificeances from cd.getSymbolicName() to track this problem.
This might need to be a lot more efficient.
Please make this static constant
static import
Please make this private static final
does it mean we should remove one of them?
does it mean we should remove one Handshaker here?
does it make sense to remove one of them?
This part of the code doesn't seem to match the behaviour of a try/catch block. Would it be possible to do a unit test for this method, with a unit test?
This needs a unit test for "null" below.
This needs a unit test for "null"
I am wondering if we can use File.createTempFile("ogr", ext), and then use File.createTempFile("ogr", ext) instead of hard coding them
I am wondering if we can use File.createTempFile("ogr", ext), and then use File.createTempFile("ogr", ext), instead of hard coding them
I am wondering if we can use File.createTempFile("ogr", ext), and then use Files.createTempFile?
what happens when an exception is returned and the session's status is not updated? Can you update the session status with UNKNOWN/something equivalent and log this error instead?
What happens when an exception is returned and the session's status is not updated? Can you update the session status with UNKNOWN/something equivalent and log this error instead?
what happens when an exception is returned and the session status is not updated? Can you update the session status with UNKNOWN/something equivalent and log this error instead?
ERROR->NOT_FOUND.
ERROR->NOT_FOUND
This variable is unused.
Although not introduced by this PR, this method is completely hot at all.
Although not required, this could be changed to return timeComparator.compare(timetime, lhs, rhs)
Although not introduced by this PR, this method is completely hot at the moment and is not necessary
can we throw a runtime exception if the key is not a bucket?
can we throw an exception if the key is not a bucket?
can we throw a runtime exception if the bucket is not available?
just wondering, why do we need an iterator? Can we just iterate over the values and not check at all?
just wondering, why do we need an iterator? Can we just iterate over the values and not check?
just wondering, why do we need an iterator? Can we just use the iterator.
This block is going to be executed for every pull, so we shouldn't have to run our own event.
This block is going to be executed for every pull, so we shouldn't have to run this code.
This block is about making the case of committing.
I believe this is fine but I'm not sure why I added this to the 'java.lang.Exception'. If this happens, we should forbid this.
I believe this is fine but I'm not sure why I added this.
I believe this is fine but I'm not sure why I added this to the 'public' methods.
It's good to have tests for whether the subscription is actually created or not
I'm afraid that this doesn't work for many tests. It's good to have a try/catch in the executor.
It's good to have tests for Instant resolution.
extract this to another method: boolean explainLocalConnections(call)
extract this block to a method: boolean isRinging(call) { if (call == null) { return; } hangup(); }
extract this block to a method: boolean isRinging(call) { if (call == null) return; } hangupAllConnections(call); }
Is there a reason for not using the error logging?
Is there a reason for not using the blobId's name here?
Is there a reason to keep the error message from the underlying exception?
s/with/getStart//
s/with/getStart/g/
s/with-resources/g/
Why a test in impl instead of using hamcrest matchers?
Why a test in this method? It's not a test.
Why a test in this method?
Can you log the path?
Can you log the exception?
Can we log the exception?
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this:... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); }... }
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this: public static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace =... } } }
This check (and the one above) are going to break DEX preverification. Can you instead move these to a separate class, similar to this:... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); }... }
Should it be a warning?
Should it be debug level?
Should it be warn?
nit: can we make this a little clearer
nit: can we make this into a function and have the test case for the expected result
i++
what about returning an empty list instead of null?
Can you explain what your doing here? What do the following variable do: if (sType == ANYELEMENT) {
Remove the variable
I think you also need to call this method otherwise the directory will be created for every file.
I think you can replace this with File.getProjectRelativePath().equals(file.getProject().getName())
I think you can replace this with File.getProjectRelativePath().equals(o1.file.getProject()).
Put ITEM in front of OTHER_FUNCTION.
No need to convert OTHER_FUNCTION here.
OTHER_FUNCTION.
There is no.show() in this file.
There is no.show() here, just return here as well.
There is a small typo here, you should probably click on that element.
Maybe a space here, and below?
please reference the existing constant here. This also means we need to reference the existing values again.
Maybe an empty constant with a meaningful name here?
How about adding a log statement at the beginning of this method and throwing InvalidParameterValueException?
How about adding a log statement at the beginning of this method and throwing RuntimeException?
How about adding a log statement at least for an error message.
You can just use bufferMessages.add(message)
You can remove this line.
Please have a logger.warning instead of DEBUG.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind staff is held in any of the two hands, you can use isItem(...) for this.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind-staff is held in any of the two hands, you can use isItem(...) for this.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind-up is held in any of the two hands, you can use isItem(...) for this.
You can use the isComparisonChain here.
You can reuse isTimerRelatedEvent here.
We can reuse isTimerRelatedEvent here.
Prefer using AssertJ (and have it fail("Found monitor, not events")
Unnecessary System.sleep()
Loading the submonitor fails here
A minor grammar error is in the description: output should not display any of the options.
A minor grammar error is in the description: output should not display any of the options: ((By.xpath(\"1\\2\\))
A minor grammar error is in the description: output should not display any of the options that are structured.
You can use a lambda here?
You can use ActionChartViewer.PLUGIN_ID here
You can use ActionChartViewer.PLUGIN_ID constant
prepend with a stream?
prepend with a stream here?
(not related to this change)
%n should be used.
In general, "language" should be removed.
In general, "language" should be used.
I see that the trades are from the'resteasy. However, the trades should be from the trades to the user to make it work. If you have the hbase times, you don't need this class.
I see that the trades are from the'resteasy. However, the trades should be from the trades to the user to make it work. If you have the hbase times, you don't need this anymore.
getExecAmount() can be null
Slightly confused by the implementation. Is there a way to let this test fail if the hash code is null?
Slightly confused by the implementation. Is there a way to let this test fail if the hash code is false?
Slightly confused by the implementation. Is the hash code not the same?
Can we check that the result is not null?
No need for final.
Can we check that the result is non-empty?
The refreshToken method can be changed to protected.
The refreshToken method can be changed to private.
The refreshToken method can be moved out of the refreshToken check.
Is this the same as the testing for the exception?
Is this change related to this PR?
Is this the same as the testing for this?
what is the difference between line 131 and 132?
what is the difference between this call and the other async client?
what is the difference between this wait and the other ufs listing?
Instead of calling isBlank above, you should use instanceof here as well.
@slubwama This is not required since you do not need to check if the encounter type is null.
@slubwama This is not required since you do not need to call isBlank below
need to check the group is not null before adding it to the list.
need to check the group is not null before adding it to the method
core method for this
This line doesn't do anything.
This line can be removed.
This line doesn't need to be removed.
Seems like you can have the same code in two places. Can we have a utility method to do this?
Seems like you can have a class cast exception.
Seems like you can have the same code in two places, right?
![MAJOR](<LINK_0> 'Severity: MAJOR') Apply this method to the most likely one-liner. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this use of String.valueOf() with a Joiner.on(" [![rule](<LINK_1>](<LINK_2>
Tabs vs.
We usually use a try-with-resources construct here
We usually use a try-with-resources pattern here
We usually use a try-with-resources construct here.
can import static
can import this class
can import this static
Can you fix the typo in endByte == 0?
Can you fix the typo in "is hex"?
Can you fix the typo in endByte == 0 instead?
nit: remove extra blank line
nit: remove extra whitespace
nit: remove extra whitespace before {
Shouldn't this assert that networkInterfaceCardProperties networkInterfaceCardProperties is initially called?
Shouldn't this assert that networkInterfaceCardProperties networkInterfaceCardProperties is the expected one?
Shouldn't this assert that networkInterfaceCardProperties networkInterfaceCardProperties is initially initialized?
I wonder why this has to be here.
I wonder why this has to be here?
Do we need this?
Nit: This code looks good, but could we extract a private method to simplify it?
Nit: This method and this one could be private.
Nit: This method and the one below could probably be renamed to indicate the class
Before this change, the line is no longer necessary after the change.
Before this change, the line is no longer necessary.
Before this change, the logic was correct, but now I think the need to remain in here is correct, since the line is of type TiLineLocation.
this could be more concise like: if (symbolStatistics.getFixedSize() * ColumnStatsProvider.builder() / partitionCount) { //... }
this should be: if (!symbolStatistics.getFixedSize() || sourceRowsCount / partitionCount / partitionCount) { //... }
this could be more concise like: if (symbolStatistics.getFixedSize() * ColumnStatsProvider.builder() / partitionCount) { //.setAverageRowSize(totalRowCount); }
please use host.getId() instead of host.getId()
this will not work as expected.
this will not work as expected. please use host.getId()
Not sure if I am wrong, but I think it would be better to change the message to: "insert " (true)" and "insert into R5" respectively.
Not sure if I am wrong, but I think it would be better to change the message to: "insert into R5 values" and "insert into R5" respectively.
Not that it matters much, but I am pretty sure that you have a reason of that change here.
Like above, can we have a test for <LINK_0> with the current implementation?
Like above, can we have a test for calling LInjectableBehaviourObjectStore.resetAlterTableModifier?
Like above, can we have a test for <LINK_0> with the current implementation??
Why not use LiftOverMinMatch instead of lift?
Shouldn't this error be updated?
Why not use LiftOverMinMatch?
The empty builder is probably not required.
The empty builder is probably unnecessary.
The empty pair of both of these methods should probably be the same.
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
Can you set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself can contain it
style nit: missing space after )
style nit: missing braces
style nit: missing curly braces
in this case you need to 'hasCpuPinning' to be 'false' which is not 'null'.
in this case you need to 'hasCpuPinning' to be 'false' which is not required
in this case you need to set the default value for both getModel().getSelectedCluster() and isVisible()
Typo in "delete"
Cleanup: Remove all **delete** methods
Typo here. "delete"
I think I would want to keep the tests similar to the one in PartitionedFileSetConfig, and remove the projections from the PartitionedFileSet too.
I think I would want to keep the tests similar to the one in PartitionedFileSetConfig, and remove the projections from the PartitionedFileSet method here.
I think it would be better to keep the tests in the PartitionedFileSet method and have the PartitionedFileSet passed in the constructor so that we can delete these.
I know that it's the opposite of what this check does, but it seems the opposite would be to say something like: if (relatedItems == null ||!urls.isEmpty()) { return false; }
I know that it's the opposite of what this check does, but it seems the opposite would be to say something like: if (relatedItems == null ||!urls.isEmpty()) { return; }
I know that it's the opposite of what this check does, but it seems the opposite would be to say something like: if (relatedItems == null ||!urls.isEmpty()) { return; }...
@vmaletta assertEquals will be more elegant
@vmaletta 6000 can be a constant in all tests
@vmaletta 6000 can be a constant as well
Are these kind of locking necessary here? Or can we just call them Monitor#addMonitorsFromNames?
Are these kind of locking necessary here? Or can we just call them Monitor#addMonitorsFromNames that takes a lock?
Are these potentially Strings being caught?
Let's put requireNonNull around this.
Let's put requireNonNull around this
Let remove requireNonNull.
lookup in the multimap here
aspectClass
lookup in for the multimap here
Don't need this, use entrySet() instead.
Don't need this, use entrySet()
Don't use keySet() since the here is not the same.
"Successfully wrote header to file".
"Successfully wrote header...".
"Successfully wrote header to file" or "Something failed".
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers? You could just call 'ExternalRegistrationConfigurationMapper' like the other mappers.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers? You could just call 'ExternalRegistrationConfigurationMapper' like the other mappers?
@Suseika hm. how about this: if (this.users.containsKey(pwd)) { } else { }
@Suseika hm. how about this: if (this.users.containsKey(pwd)) { } else { }?
@Suseika hm.. looks like code duplication. how about this: if (this.users.containsKey(pwd)) { }
you could collapse this two lines to: KoreUtil.addKoreUtil(context, kodiButton); KoreUtil.addKoreUtil(tag);
you could collapse this two lines to: KoreUtil.addKoreUtil(tag);
I think this should be null
not sure why we need this.
incorrect.
not used.
shall we have try-with-resource?
shall we have try-with-resources?
shall we add debug log?
sysout?
Debug code?
Debug?
change this to Utils.deleteApplicationFiles
Minor: "Could not unregister the application master"
Minor: "Could not unregister the application master."
This makes me wonder if there is a neat method to pack() on ByteBuffer. Would it be better to use ByteBuffer to get the unpackString and unpackString?
This makes me wonder if there is a neat method to pack() on ByteBuffer. Would it be better to use ByteBuffer to get the unpack string and collect the bytes and unpackString?
This makes me wonder if there is a neat method to pack() on ByteBuffer. Would it be better to use ByteBuffer to get the unpackString and unpackValue to them if not?
Perhaps we want to use the argument more than one argument, which is more readable.
Perhaps we want to use the argument more than one argument, which is why the assertion failed, not just the last one?
Perhaps we want to use the argument more than one argument, which is where we want to set the error message.
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in sync? Shouldn't we always test both tables for those values then?
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that Instances table has all the TaskColumns as well? Shouldn't we always test both tables for those values then?
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in sync? Shouldn't we always test both tables for those then?
map is the same as the method above. At least the map can be private.
map is the same as the map. However, you may want to replace listFiles() with the map.
map is the same as the method above. At least the map.
should this be warn?
should this be warn? or INFO?
Proper English wording would be cleaner?
assertEquals(excpected, actual)
Assert the name of the conflicted file too. Here and elsewhere.
assertEquals(excpected, actual) Here and elsewhere.
nit: it would be nice to have a log message in case operatorChain is null
nit: it would be nice to have a log message in case operatorChain is null?
nit: it would be nice to add constant for 3_000_000 in operator : operatorChain_
The logic should be simplified here. We can merge this.
The logic should be simplified here. We are creating a new EventData for every single event.
The logic should be simplified here. We are creating a new List of the headers for every single event.
There is no need to create a ListItemAction manually now.
There is no need to create a ListItemAction here.
There is no audit log here!
how do you handle "BEGIN" here?
how do you handle "BEGIN" here? It looks strange.
how does this handle exception?
Asserting the actual text and the other one be the safer length
Assert with the text and the other one be the safer length
Asserting the actual text and the other one be none of them.
Why did we rename optionsPath to unsubscribeDataChanges()?
Why did we rename optionsPath to optionsPath?
Why did we have to rename optionsPath to var?
Same remark as for registration
Same remark as for registration: if (wrapperCount.contains(wrapper))
No need to check for null here, right?
You can update test1 to 1 since we moved it to javadoc. This is similar to other tests.
You can update test1 to 1 since we moved it to javadoc. This is not legal.
You can update test1 to 1 since we moved it to javadoc. This is similar to other test.
I think we should throw an exception in this case as a default profile is provided.
I think we should throw an exception in this case as a default profile is defined in the config file
I think we should throw an exception in this case as a setting is not defined value?
@NielsCharlier fix resource leak with a try-with-resources block?
Please convert these tabs to spaces. Can this be converted to a Java 7 try-with-resources?
Please convert these tabs to spaces. Can this be converted to a Java 8 try-with-resources?
Map instead of concrete type
Looks a lot better!
Map instead
Love it!
Was this change intentional?
Log a debug message here and below
please use Cluster#hasGateway
please factor it into Cluster#calculateGateway
please factor it into Cluster#hasGateway
.ifPresent(consumer -> consumer.readEvent().ifPresent(consumer -> consumer.readEvent().ifPresent(consumer -> consumer.readEvent()));
Couldn't we just use eventsQueue.map(eventsQueue::get) instead of.ifPresent?
Less code duplication
Any reason for not using session?
Any reason for not using void? :)
Any reason for not using session? It was there before.
use "+" :)
use "+"
use : {}
I don't understand why this is here. Why "get" String and not from the definition of "payload-methods"?
I don't understand why this is here. Why don't we use the property defined here?
I don't understand why this is here. Why "get" String and not from the definition of the component?
I think it is cleaner to have the following: if (request.getDataSources().equals(request.getDataSources())) { return true; } if (request.getPartitionId()!= null) { return false; } return true;
I think it is cleaner to have the following: if (request.getDataSources()!= null &&!request.isEmpty()) { return false; } else { return request.getPartitionId() == null; }
I think it is cleaner to have the following: if (request.getDataSources().equals(request.getDataSources())) { return true; } if (request.getPartitionId()!= null) { return false; }
or we need to take out of the CmdLineParser if there was an issue with the CmdLineParser instance in the list. Just to be sure to wait for whatever reason
or we need to take out of the CmdLineParser if there was an issue with the CmdLineParser instance
or at the least use a logger?
I don't think we need to set the user to null. Youtube functionality call from the changesetUser method to the createUser(user, salt)!= null.
I don't think we need to set the user to null. Youtube functionality call from the changesetUser method.
I don't think we need to set the user to null. Youtube functionality call from the changesetUser method to this PR.
You can omit the dialog.setText()
You can remove the null check and use the StringUtil.notNull() below.
You can omit the dialog.
I think we can revert this change.
I think we can revert these changes.
I think we can revert these changes, since we already have a "for each" call.
Change to SubMonitor.convert(pkgName)
Use the array as loopvar, so that you do not need to create the array manually.
Use the array as loopvar, so the += operator will be needed
break?
This should be java builder.append("IF NOT EXISTS WITH NO DATA : ");
This should be a constant
typo: should be letter
Objects:nonNull is useless.
typo: should be equals
I think you can use setCommitIdGenerationMode(true) here, and then setCommitId() is called as many times as it doesn't throw an exception. You can setCommitIdGenerationMode to false by default.
I think you can use setCommitIdGenerationMode(true) here, and then setCommitId() is called as many times as it doesn't throw an exception. You can setCommitIdGenerationMode to false by calling mkdirs which will cause an exception.
I think you can use setCommitIdGenerationMode(true) here, and then setCommitId() is called as well.
why does this need to be changed?
need to go into "CS"?
need to go into "assertEquals"?
I think that's fine to remove this. This will actually hit the exception!
I think that's fine to remove this. In this case, the IOException doesn't tell us anything.
I think that's fine to remove this. In this case that's fine to remove the catch block.
this line can be simplified to: if (getVmTemplate()!= null &&!getVm().equals(getParameters().getStorageDomainId())) {
this line can be simplified to: if (getParameters().getStorageDomainId()!= null &&!getVm().equals(getParameters().getStorageDomainId())
you can use.equals instead of ==
You cannot rely on list of attributes. You can use something like this: list<String> tcsMailsValue = new ArrayList<>(Arrays.asList(getEmailValues(sess, user, user));
You cannot construct this list because of constructor.addAll(). Use ArrayList<String> from all those methods.
You cannot construct this list because of constructor.addAll(). Use ArrayList<String> from loop.
replace with Contentlet contentlet = new ContentletDataGen().nextPersisted();
replace with Contentlet contentlet = new banner(banner1, user2, page3)
replace with Contentlet contentlet = new Contentlet();
We shouldn't put this in an objectId. It can just throw IllegalStateException, since this is already handled in the request-back connection.
We shouldn't put this in an objectId. It can just throw IllegalStateException, since this is already handled in the request-updated hook. The value must be validated every time this method is called.
We shouldn't put this in an objectId. It can just throw IllegalStateException, since this is already handled in the request-updated hook. The value must be validated while date isNewer.
We already have getGroupSeenQueryGroupAccessManager().selectSeen -> parentSeenQuery.getGroupSeenQuery(Level.SEVERE, "failed to get group seen for group key: " + groupIdQuery);
We already have getGroupSeenQueryGroupAccessManager().selectSeen -> parentSeenQuery.getGroupSeenQuery(Level.SEVERE, "failed to get group seen for group key:"
We already have getGroupSeenQueryGroupAccessManager().selectSeen -> groupIdQueryCallback for this
400 errors are Bad Request errors which are usually populated as IllegalArgumentException errors.
Can we add a check so this only applies to the version negotiation requests, and propagate the exception otherwise?
400 errors.
shouldn't we be catching InterruptedException instead?
shouldn't we be catching InterruptedException instead of RuntimeException?
shouldn't we be catching TableException instead of Exception?
What if this is empty?
Two spaces before and after :(
Two spaces before and after :
Is there any reason to initialize this here? I think it olf is already initialized when the olf is null).
Is there any reason to initialize this on line olf and just sock?
Is there any reason to initialize this here? I think it olf is already initialized when the olf is null.
Is retries checked in the loop?
Could we catch the specific exception here?
Is it possible to reach this code if retries is empty?
Same as above: could use the list directly to avoid the intermediate list.
Same as above: the list is a list.
Same as above: could use the list directly to avoid the pack name
This should be IllegalArgumentException
This error message is completely wrong.
This doesn't seem like it should be here.
It's good practice to make this configurable and have the default value specified in the constructor
It's good practice to make this configurable and have the default value set in the constructor
It's good practice to make this configurable
nit: could be assertTrue(bp > o.get())
nit: could be assertTrue(bp.get())
nit: this is not the correct timeout. I think you want a timeout like 1 second.
This can be static
This can be static.
This should be strings.xml
Shouldn't these be defined in the activity_level constants?
Shouldn't these be defined in the activity pane?
Shouldn't these be set in the flags passed to #28?
Braces
setCommit returns a builder, you should put this statement into the else branch
setCommit returns a builder, you should put this into the else branch
I think you should remove the request, because this is a payload that's already a payload.
yes I don't think this is correct.
I think you should remove the request, because this is a payload that's supposed to be the connection.
LOG.info("JDBC connection string is not supported on port " + port + ".");
LOG.info("JDBC connection string is invalid");
log message should have a space
I would prefer to use forEach, I am not sure how this is fast enough.
I would prefer to use forEach, I am not sure if it is needed.
I would prefer to use Util.isEmpty()
why not log it?
why not logging it instead of printStackTrace?
Why do you print it again?
can do this without if (e.getMessage().contains("404 Not Found) && e.getMessage().contains("ServerInfo"))
can do this without if (e.getMessage().contains("404 Not Found) \n
can do this without if (e.getMessage().contains("404 Not Found) && e.getMessage().contains("ServerMessage")) {
We don't need this if else if we set the lastMeasuredTimestamp in the constructor
We don't need this if else if you set the lastMeasuredTimestamp in the constructor
Typo in lastMeasuredTimestamp
Since you are using a builder, you can drop the extra parameter.
All these extra lines are redundant.
All these extra lines are unnecessary.
I'd go with property = new Properties
I'd change variable name "someProperty1" to "someValue1" or "someProperty2".
I'd change variable name "someProperty1" to "someValue1".
Perhaps this block should be moved inside the if, right?
Perhaps this block is too long and may be useful to have a if (getReadOptions().isIgnoreTrim()) return false;
Perhaps this block is too long and may be useful to have a if (address.getTrimmedAddresses() == DataType.HOLE)
It seems like this logic is also also used in calculateSpaceSecond()
It seems like this logic is also also used in calculateSpaceScaleRestriction and may be removed for consistency. Could you please remove it?
It seems like this logic is also also used in calculateSpaceSecond() and can be removed here.
Do we need this variable here? It seems like it's going to be used only once and we're going to use it.
Do we need this variable here? It seems like it's not used anywhere else.
Do we need this variable here?
shouldn't it be getVm()
shouldn't it be getVm()?
shouldn't be toString
The equals() impl could be written as return Objects.equals(this.serverTemplateSelected) && Objects.equals(this.serverTemplateSelected, that.serverTemplateSelected)
The equals() impl could be written as return Objects.equals(this.serverTemplateSelected) && Objects.equals(this.serverTemplateSelected, that.serverTemplateSelected);
The equals implementation should include attributes from the hash.
Minor: you can just use Files.delete here.
Couldn't we just move this out of the try/catch?
Shall we move this to a Util class and also use Files.delete from commons-lang?
callback.remaining() == 0?
callback.remaining() invocation may be zero.
callback.remaining() invocation may be zero
I don't think this is a good idea. The docs say "Field" rather than "Application Interval".
I don't think this is a good idea. The fields are immutable already, not the attributes. The constructor will iterate over them. If you have a better performance, please use that instead.
I don't think this is a good idea. The fields are immutable already, not the attributes. The constructor should be called after the meter is initialized.
Why not package private?
Why not package private visibility?
What about STATIC_FLOW?
when ch is null?
NPE if channel is null
NPE if f becomes null
Why don't you re-throw UnknownIndexException here?
Why don't you leave the logger in error log for now?
Why don't you re-throw UnknownIndexException here? Now that we have toString() don't need this catch.
I don't think the variable updatedChange is necessary
What about the message of the change?
What if the change being null?
@orhan89 This could be reduced to log.warn("Failed to login entity id after login: {}", ex);
please use log.warn("Failed to get zauth tenant id after login id: {}", APPLICATION_JSON, e);
can be replaced by log.warn
Is this really a 400 or is it a 500?
Is this a 400 or is it a 500?
Is it really a bad idea to put a constant here?
use the returned list here
use ImmutableList.copyOf
use the returned list directly
Might be worth moving these values to constants
Might be worth moving these strings to constants
Might be worth moving these values to constants.
This is the tenant ID 3 times. Is it possible to do that?
This is the first unit test. Is it possible to do: java assertEquals(expected, actualUrls.size());
This is the first unit test. Is it possible to do: java assertEquals(expected, actualUrls.size());?
why the wrong set to NIOServerCnxn by default?
why the wrong set to NIOServerCnxnFactory here?
why the change to INFO and not error here?
Can expectedValues be a for-each?
Can you replace the for loop with expectedValues.iterator().next()?
Can expectedValues be a fori loop?
ImmutableMap.of(
ImmutableMap.of(_source.yaml, Collections.singletonMap())
ImmutableMap.of(_source.yaml)
Here we need to set the item to the original item.
Here we need to assert that this item is not there
Better to use the Items collection
Avoid attempting to set the status to null by default. Use IWorkbench.getElevationSources().add(loadStatusChanged);
Avoid attempting to set the status to null by default. Use IWorkbench.getElevationSources().add(loadStatusChanged);.
Avoid attempting to set the status to null, which may cause a lot of error, and allow the user to decide what to do with a NullPointerException.
I'm not sure how I missed this. Shouldn't it be last 'if (cond)'?
I'm not sure how I missed this. Shouldn't it be last 'previousData'?
I'm not sure what you want.
Why do we need a new instance of check checkMessage() here? Can't we put the toString() call in a static block.
Why do we need a new instance of check checkMessage() here? Can't we hold on the same class instead of the first one?
Why do we need a new instance of check checkMessage() here? Can't we put the toString() call in a static method.
It doesn't matter, but this if looks set to the prior value for the request. It may be worth checking before converting the resulting URL to a String.
It doesn't matter, but we gain this if around.
It doesn't matter, but this if looks set to the prior value for the request. It may be worth to set the first param in the method too.
I think we should not use the iterator directly.
I think we should rather use the iterator directly.
I think we should not already lock the graph directly.
I think you need to rewind the copyBuf reader's index, otherwise it might only print the part of the buffer that's unread.
I think you need to release the ByteBuf as well to avoid needing to use Codec's InputStream.
I think you need to release the buffer here and return null in the finally block.
Why use an overload?
Why do we need this? Is it actually used?
Why do we need this?
Please adjust this check to be consistent with the other two: one for each variable declaration, and the other is good.
Please adjust this check to be consistent with the other way around: int[] patternName = null; if (superName!= null) { nodeSuper.get(name); }
Please adjust this check to be consistent with the other two: one for each variable declaration, and the other is good to read.
suggestion webSession.getToken();
suggestion webSession.get();
suggestion
Is there a guarantee that the result path is an HDFS path?
Is there a guarantee that the result path path is an HDFS path?
Is there a guarantee that the result path isn't an HDFS path?
I think this should be mListShown(), and mProgressContainer should be null.
I think this should be recursive.
mListShown()
Maybe you can add the value to the component status
Maybe you can add the true.
Maybe you can add the condition back
Can you please add className to error message?
Can you please add className to exception message?
Can you please add className to error messages?
This is awkward as a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
This is a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
This is likely a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
use.substring(0, socket.getRetryCount()) once and use
use.substring(0, socket.getRetryCount()) after removing newline, put the rest of the code below
use hamcrest?
Please follow the formatting used on the project guidelines, but this could be a bit more fine ;)
Please follow the formatting used on the project guidelines, but this could be a bit more standard.
Please follow the formatting used on the project guidelines, but this could be a bit more standard. _Updated to use 0_ _-1
getMessage in the log instead of throwing.
error should have a space after the +
Failed to have a parameter in the error message?
@vilchik-elena Why not use a cast to PyFunctionDefTree?
@vilchik-elena Why not use a static import?
[minor] inline.
Can we simplify this block by using map.isEmpty()?
Can we simplify this block by using map.equals(result, false)?
Can we simplify this block by using map.equals(result)?
This should not be union. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).get(i));
This should not be union(). Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).get(i));
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i));
core data should not be thread safe
core data should not be part of the data
core?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
Do we need to throw here?
Move the lambda into a private method for readability
Probably we should throw a proper exception here.
1. The column type is not included in hasher. 2. We don't support different values for all column types. What do you think?
1. The column type is not included in hasher. 2. We don't support all other cases when it's not included in either.
1. The column type is not included in hasher. 2. We don't support different values for all column types. What do you think about that?
rename to type
rename 'private'
rename to member
I think it'd be clearer if you create an abstract method and reuse it.
I think it'd be clearer if you create an abstract method and call it "setMulticast(String)" which will invoke the same methods.
I think it'd be clearer if you create an abstract method and call it "setBind".
s/Man.URI/usernameClosed
s/Man.URI/
s/Man.URI//
can you add a default requestHandlers!= null.
can you add a default requestHandlers!= null
can you add one more check for requestHandlers!= null
Shouldn't it be one_UTC?
Shouldn't it be one here?
Shouldn't it be one_UTC?
pls. use String.format instead.
pls. use String.format instead?
pls. use String.join instead
This should be updated to use Cohort.getMemberships().getMemberships()
This must be updated if a membership is found
This should be a void
Why add empty string?
Why add empty line?
Might be better to create an empty list?
Check if urlPath is null, so that the file is deleted only.
Check if urlPath is null, so that the file isn't deleted at all.
Check if urlPath is null, so that the file isn't deleted, the log message is misleading. The other way around can be centralised to this class
I think we should throw RuntimeException here, since the operation usually catch an Exception (or the caller might want to catch it)
I think we should throw Exception here, at least to make it consistent with other other places
I think we should throw RuntimeException here, since the operation usually catch an Exception and the caller might want to catch it.
I recommend to use the edge case for the timestamp field, so that you know if it is there as well.
I recommend to use the edge case for the timestamp field, so that you know what kind of edge cases you need.
I recommend to use the edge case for the timestamp field, so that you know if it is there or not.
you must begin all in if already authenticated so you do nothing....
you should begin all in if already authenticated so you do nothing....
can you please explain why to put false? the absent of property is an existing return.
combine line 1593 and 1594
change this to hostAssignment.isLegacyClusterConfig()
change this to hostAssignment.getPartitionId().equals(cloneHost.getModel())
Should this be a uint16?
Should this be a uint16.
final
One thing here is that because we're using WaitUntil, it would be pretty dangerous to reset the dialog to the user. I would prefer it to add the whole thing (so the dialog will not go through all dialogs).
One thing here is that because we're using WaitUntil, it would be pretty dangerous to reset the dialog to the user. I would prefer to leave the code here.
One thing here is that because we're using WaitUntil, it would be pretty dangerous to reset the dialog to the user. I would prefer it to add the whole thing (so the dialog will not go to the main window).
use Variables.getDefault().nextInt(10) instead of 5
Use Variables.getDefault().nextInt(10) instead of 5
use Variables.getDefault().nextInt(10) instead
Shouldn't this be at the beginning of the method, and not there?
Shouldn't this be wrapped in a try/catch instead?
Shouldn't this be at the beginning of the method?
insert space before.
insert space before each.
rename to delim
There is a null check before deleting resource.
NIT: consider adding the null check as before.
Maybe define a constant for that?
Can we not letting the exception only by throwing it? I would use a RuntimeException here.
Can we not letting the exception here?
Should we not letting the exception here?
Hmm, did you want to test the case that this check doesn'tumorRevPos > 0?
Hmm, I didn't see the below code in this line. What's the point of doing this line?
Hmm, I didn't see the below code in this line.
For readability. Same for other columns.
For readability. Same for other checks suggestion Preconditions.checkState(arguments.contains(column));
For readability.
s/then/else/
s/in/in/
fyi, I think the original version of this test was more readable (in case I missed another commit on your commit)
this try-with-resources is not needed.
can we use try-with-resources here?
this try-with-resources is not necessary.
We're casting the whole suri to a MessageBubbleDrawable, perhaps it would be better to store the BubbleDrawable, and use it here and in the related function.
We're casting the whole suri to a MessageBubbleDrawable, perhaps it would be better to store the BubbleDrawable, and use it here and in the related subclass.
We're casting the whole ads here? Maybe passing it in a String and then passing it in?
Braces
Braces are correct here
Braces are correct.
I think it would be better to move this inside the synchronized block.
I think it would be better to move this logic to the RTPManager
I think it would be better to move this inside the synchronized block. Then the calling code doesn't need to be synchronized.
rename to occurrence
rename to pack
rename to child
Shouldn't we use here something like this: final CanvasElement canvasHandler = canvasHandler.getDomainObjectUUID(); if (canvasHandler.getDefinition() instanceof DomainObject) { canvasHandler.getContent(); } else { canvasHandler.getDefinition(); }
Shouldn't we use here something like this: final CanvasElement canvasHandler = canvasHandler.getDomainObjectUUID(); if (canvasHandler.getDefinition() instanceof DomainObject) { canvasHandler.getContent(); } else { canvasHandler.getContent(); }
Shouldn't we use here something like.equals(someNodeObject)?
I think we can initialize this variable in the try block. After all the if/else block, this condition is always true.
I think we can initialize this variable in the try block. After all the if/else block, this condition is redundant.
I think we can initialize this variable in the try block. It is only used once after each iteration.
Please remove this.
Please refactor this assertion to something like: assertThat(a, is(not(a))
Please fix this.
@martin I think we can move it to ProxySelectorUtils
@martin-kanis Based on your discussion on PRs, but it looks like we'd be better to use StringUtils.isEmpty(proxySelector).
@marcaurele I'm not sure if we can move it to the client point of view.
need space after if
needs space after if
typo
Yuck! I think this should be Locale.ROOT so the default shouldn't be "ddf".
Yuck! I think this should be Locale.ROOT
Yuck! I think this should be Locale.ENGLISH?
please use asGuid() instead of Guid.create()
please use asGuid() instead of Guid.createGuid(Vdc.getId())
please use asGuid() instead of Guid.create().
I would inline this variable.
I would inline outputSymbols
I would inline all the intermediate variables.
This should be a Set<Statement>, no need to add it.
This should be a Set
Not sure about that oneStatement.
Do we need the fully qualified name here?
Do we need the fully qualified name?
Do we need the GL11.GL_QUADS f permission here? I would expect this to get raised by the forgef work.
I think it should be trace
Is it necessary to catch exception here?
I think we should remove this catch statement.
I don't like this multiple times. What about just: java final List<String> authenticationToken = aadJwtBearerTokenAuthenticationConverter.convert(claims, authenticationTokenAuthenticationConverter.convert(claims)).add(principals);
I don't like this multiple times. What about just: java final List<String> authenticationToken = aadJwtBearerTokenAuthenticationConverter.convert(claims, authenticationTokenAuthenticationConverter.class); assertThat(principals).get("tid");
I don't like this multiple times. What about just: java final List<String> authenticationToken = aadJwtBearerTokenAuthenticationConverter.convert(claims); assertThat(principals.getPrincipal());
Nitpick: vertex.getNumEdges() can be replaced with vertex.getNumEdges()
I would like to have these two methods be refactored to be a single method.
I would like to have these two methods be refactored.
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource(shardUuid, Optional.ofNullable(shardDeltaMap.get(shardUuid)), deltaFileContext);
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource(shardUuid, Optional.ofNullable(shardDeltaMap.get(shardUuid)), deltaFileContext.getShardUuids().iterator().next());
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource(shardUuid, Optional.ofNullable(shardDeltaMap.get(shardUuid)), deltaFileContext::getShardUuids());
I'm not a fan of this kind of fan of internal returns. I think you'd have to use a Response here.
I'm not a fan of the api calls to Lists.newArrayList(), could you just use the diamond operator?
I'm not a fan of this kind of fan of internal returns. I think you'd have to use a List here.
Should probably assert that elemSize <= 0?
Should assert that elemSize <= 0.
Should be assert.
one more :-)
one of these is bad.
one finals
Could you extract this to a method, maybe?
Is there a reason not to extract this variable?
Is there a reason not to extract this to a variable?
These properties go away anyway, so perhaps it's a best practice to make the property be static
These properties go away anyway, so perhaps it's a best practice to make them protected? I think it's dangerous to have a lock on the properties array, but we could potentially make it impossible to add a paren here.
These properties go away anyway, so perhaps it's a best practice to make them protected? I think it's dangerous to have a lock on the properties array, but we could potentially make it impossible to wrap this with an unmodifiable map
Same as above for the unused variable.
Same as above for these 3 methods
Same as above for these 3 methods?
What do you think of this? I don't see how/why we need a slicer?
What do you think of this? For the client, we don't need to create a slicer, right? I don't see how/why we need it.
What do you think of this? For the client, we don't need to create a slicer, do we need to ensure the cleanup?
Need to be a set.
No need to cast.
Need to be a set. Same for the initial test.
If we don't need to pass a new ImmutablePageWithPositionComparator(), we can remove the need to create a new one.
If we don't need to pass a new ImmutablePageWithPositionComparator(), we can remove the need for a new one.
If we don't need to make a new one, we can just pass a new SortOrder.
I'd prefer to avoid the nested ifs: if (conditionContext == null) { builder.setWrappedQuery( queryContexts ); } builder.createQuery(() );
I'd prefer to avoid the nested ifs.
I'd prefer to avoid the nested ifs: if (conditionContexts.isEmpty()) { builder.createQuery(() ); } builder.add(...)...
Could you replace this with log?
Could you replace this with LOGGER.debug?
Could you remove the debug messages?
I think this one needs to be unsigned
I think this one needs to be configurable
I think this variable is unnecessary
can you just append operationTimeMs?
can you also append operationTimeMs?
can you just sb.append(blobId);
Is there a test for the both old and new behaviour?
These tests are the same as the old tests, could you please undo these?
These tests are the same as the previous tests, could you please undo them?
Typo: _expectedDataStart_
Typo: "expected"
Typo: _expectedDataCount_
Minor: move this to a method.
Minor: move this check to a private method.
Minor: move this check to a method.
The "id" parameter appears to be always the id. It may be that there is a 'element' in the 'element'.
The "id" parameter appears to be always the id. It may be that there is a 'ID' in the 'index'.
The "id" parameter appears to be always the id. It may be that there is a 'ID' in the 'index'..
It seems to me that selection and evaluation can be done outside of the for loop.decision block would return the result of the evaluationCache. In that case, you are going to get back the original node.
It seems to me that selection and evaluation can be done outside of the for loop.decision & I think this will return the result of the query.
It seems to me that here we need to return null for parsedDecision.decision & POSTPONE
Typo: request
Extra space between if and (
You must use the same message for both retries
I think the strings can be replaced with.split("=", 2) as the string is important.
I think the strings can be replaced with.split("=", 2) as the string is now a regular expression.
I think the strings can be replaced with.split("=", 2)
I think we have to be careful about the referenced entity over and over here.
I think we have to be careful about the intermediate collection, but the notion of class symbol is not of a imported kind.
I think we have to be careful about the intermediate collection, but the list of classes of symbols pre-core can be too large.
Unnecessary parentheses
I don't think it should be a preconditions check, since it is not null in the build method
Unnecessary else clause
This seems like an odd behavior change, how about adding a method to TNFWithManager. Then we can leave the filter as-is
This seems like an odd behavior change, how about adding a method to TNFWithManager. Then we can leave the filter as-is.
This seems kinda weird, how about adding an overloaded method to TNFWithManager. Then we can leave the filter as-is.
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we have such a test with 2 nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we have multiple nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
why 10? it is not important for test.
Don't use.toString()
Don't use nanoTime() for this.
Don't use nanoTime()
style nit: we don't use braces around single line blocks
i think we can replace this with Objects.firstNonNull(gitHubUser.getLogin.getName())
this.
You can return the actual type DTO type.
You can return the actual type DTO type DTO type.
You can return the actual entity type DTO type.
should we make this "if (condition) {" not "return true" somehow?
should we rename the nodeUrlSpent to a better name?
should we rename the nodeUrlSpent to be more specific?
Builder builder = new Builder(); builder.setThumbnail(desc.getThumbnail(), builder.getCanonicalUri()); builder.setChapter is deprecated.
We have a unit test for this.
We have a utility function for this.
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
minor: the message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
minor: the message here is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
I guess for this to be the type of the try-with-resources, it's cleaner.
I guess for this to work, our socket is also logged in this method.
I guess for this to be the type of the try-with-resources, this will handle this automatically
Optional<SolShip> instead?
isEmpty()?
ShipID -> LOAD
warn maybe?
add some logging here as well
add some logging here?
Shouldn't this be done in a for loop? suggestion List<Label> lightweightAPI = apiList.getAllLabelsWithoutID();
Shouldn't this be done in a loop? suggestion List<Label> lightweightAPI = apiList.getAllLabelsWithoutID();
suggestion return!label.isEmpty();
It seems this method can be private.
It seems this method should be private.
It seems this method is statically used and only one thread can be used.
Do you need to call it first?
do we need to wait for the PeopleAdapter in this if clause?
do we need to wait for the PeopleAdapter to be closed?
In general, I would put this in a loop, so that we don't have to deal with a null array. You may race with an orElse and just check with the null case.
In general, I would put this in a loop, so that we don't have to do multiple reads.
In general, I would put this in a loop, so that we don't have to do multiple reads. You may cache the result.
shouldn't be a space after the beginning of the file
shouldn't be a warning for an error
should be externalized
If the end of the last one is the last one, there should be a space after the if.
Probably simpler to use a CACHE_NAME variable for the last element.
If the end of the last one is the last one, there should be a space after the (
Is it an overhead to calculate sizeInBytes() for every call?
Would it be an overhead to calculate sizeInBytes() for every call?
Is it an overhead to calculate sizeInBytes() for every call? In fact, we can't seems like it is not required to write _read_ every time.
you can initialize it in the declaration.
you can initialize it in the declaration, right?
you can inline the condition.
I think these System.out.println should be removed.
I think these System.out.println() should be removed.
I think these System.out.println() should be removed
Again, the indexes should be calculated outside of the while loops.
Again, the indexes should be calculated outside of the while loop
Again, the indexes should be calculated outside of the compare method when the filtering is done
Ditto.collect()
Ditto.collect(Collectors.toList())?
Ditto.collect(Collectors.toList());
i haven't looked at all the edge cases, but can buffer.length - end ever be less than 0? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
i haven't looked at all the edge cases, but can buffer.length - 1? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
i haven't looked at all the edge cases, but can buffer.length - 1 at least be less than 0? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
don't we just want to do this?
Now that I see this, can we just do this here?
Now that I see this, can we just do this?
The body of the method must be required right?
The arguments are unused now right?
The arguments are unused.
This should be removed from the config
This should be removed right?
This should be removed from the protocol
It think it'd better to have singleton GSON instance in static field
It think it'd be better to have singleton GSON instance in static field
It think it'd be better to have a static final field
suggestion } else if (public void reformat) {
We should have a better name for this method; it's not too big.
UncheckedIOException?
It would be much easier to follow if we could take File.getAbsolutePath() as a File object.
It would be much easier to follow if we could take File.getAbsolutePath() as a path instead of the Path.
It would be much easier to follow if we could take File.getAbsolutePath() as a path instead of a File.
Should we log a warning?
Should we move this up to the start of the file?
Should we move this out of the try/catch? I don't think it does.
do we need this?
do we need to check for nullable results?
do we need this? :)
I don't think this needs to be a part of this PR, but seems like it would be a bit cleaner to either use the lifecycle manager based on the callback name tosched or does this even the compat version desched?
I don't think this needs to be a part of this PR, but seems like it would be a little cleaner to either use the lifecycle manager based on the callback name tosched or does this even the compat version desched?
I don't think this needs to be a part of this PR, but seems like it would be a bit cleaner to either use the lifecycle manager based on the callback name, or better yet let the class be implement it so that the context is clear enough.
I'm not sure if we should call getString on user side.
I am not sure why we should call getString instead of display.
I am not sure why we want to call getString instead of storing in string.
Why are we swallowing all exceptions here?
Why are we swallowing an exception here?
Why are we swallowing all exceptions here? What if we are not doing something upstream?
But since this service is only available in the app, I think we should have a flag about this property. Maybe in general, it would be better to provide an instance of the service, something like: java class Activity { public static final String registerReceiver() { //... } @Override public void update(String name) { if (m.getVersion()) { m.setClassName(context); } }
But since this service is only available in the app, I think we should have a flag about this property. Maybe in general, it would be better to provide an instance of the event type that gets propagated to the settings.
But since this service is only available in the app, I think we should have a flag about this property. Maybe in general, it would be better to provide an instance of the service, something like: java class Activity { public static final String registerReceiver() { //... }
These strings need to be externalized
These strings need to be externalized and use the same constant
The strings need to be externalized
What's the difference between getMuted and send2?
What's the difference between getInterface versus getInterface?
What's the difference between getMuted and 'new'?
Please revert the change for the rest of the PR.
Be careful, why you use ID in the ID? return emptyList()
Please revert the change for the rest of the PR
I'm not sure this is what's going on with the PR, was it intentional that this is not?
I'm not sure this is it's going to work well, since you just moved all the other calls to mavenProxyRepository.removeFromRemoteIfExists method above?
I'm not sure this is what's going on with the PR, was it intentional that this is it's not?
<LINK_0>
Can we define a method sendMessage?
Can we define a function for this.
This could use the same variable for more than one-time initialization.
This could use the same variable for more than one-line statements.
This could use the same variable for the first argument.
I guess this should be CFG_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION.put("javax.persistence.Avro_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_VERSION")
I guess this should be CFG_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION.put("javax.persistence.Avro_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION", "org.hibernate.service.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.SANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION", "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DATA)"
I guess this should be CFG_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION.put("javax.persistence.Avro_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION", "org.hibernate.service.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.SANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION", "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.internal.util.GWCVars.put(name, KieServerConstants.DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_PERSISTANCE_DEFAULT_DESCRIPTION, "org.hibernate.s.internal.jta.command.AbstractSharedManager.ENABLED").build();
Since we will return a StatusUtils reference, I think we should have the same error message in both cases.
Since we will return a StatusUtils.createErrorProxy(ActionType.COMPLETE, ASYNC_CONSTRAINT) instead of ASYNC_CONSTRAINT.
Since we will return a StatusUtils.createErrorProxy(ActionType.COMPLETE, ASYNC_CONSTRAINT)
WhiteListContexts.add(split[0], split[1]);
should we also consider the above if (whiteListContexts == null) check as well?
WhiteListContexts?
Don't introduce redundant braces
Don't introduce redundant brackets
Don't need the else if
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them?
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them? If so, then you need to keep the method order closer to the previous revision, so that the gerrit diffs can match them.
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them? Would keep the method order closer to the previous revision, if (attachment == null) {... }
I wonder if it's better to create a StreamListenerResultAdapter with an ComponentListenerResultAdapter and have the return type adapter for the invocation on interface?
I wonder if it's better to create a StreamListenerResultAdapter with an ComponentListenerResultAdapter and have the return type DefaultChannelAdapter interface as the implementation?
I wonder if it's better to create a StreamListenerResultAdapter with an ComponentListenerResultAdapter and have the return type DefaultChannelAdapters(StreamListenerResult.class) in the end.
Why not just include the directory in the message?
Why not just include the directory in the error message?
Shouldn't this still be an exceptional condition?
Should this be collapsed to a single if block? I.e. return availablePhoneAccounts.contains(defaultPhoneAccounts); Also, I think this will be consistent.
Should this be collapsed to a single if block?
Should this be > 0?
The same RuntimeException on STDERR
The same RuntimeException on Serializer would be better.
Probably would be better to check on RuntimeException not on OCS
conitpicking: I think you could use a LinkedHashSet here to avoid having to check if the workflow is even closed
conitpicking: I think you could use a LinkedHashSet here to avoid having to CWL when this is actually used
conitpicking: I think you could use a LinkedHashSet here to avoid having to CWL when this is actually checked
You can use context.getDependentCapabilityRequirement() instead of context.deregisterCapabilityRequirement()
You should be able to use context.getDependentCapabilityRequirement() here so that you don't need to use contains.
You can use context.getDependentCapabilityRequirement() here so you don't need to check for null.
This test is not sufficient
This test is not sufficient if we release the connection before we do not get it.
This is not needed
Why does this need to be cast?
What does this change do?
Why does this need to be changed?
If you move this line up above the loop, then you don't need to initialize parameters in the loop.
If you move this line up above the loop, then you don't need to initialize parameters in the list.
If you move this line up above the loop, then you could just initialize parameters in the loop.
Collections.emptyMap() could be used here
You could use Collections.emptyMap() to make this value a constant.
You could use Collections.emptyMap() to make this line a bit clearer.
Please use logger.error instead of e.getMessage()
Use logger.error() instead of e.getMessage()
Use logger please.
Is this debugging output necessary?
Is this debugging leftovers from debugging?
Is this debugging code you want?
Can't we use 'vm.getVm()' as a parameter?
Please re-use the variable name 'plugFromExternalNetwork' (it is unused).
Please re-use the variable.
I recommend switching this to use a local variable: int[] seen = isCompact? newIds[offset] : newIds; newIds[offset]; Arrays.fill(positions, offset, length);
I recommend switching this to use a local variable: boolean seenCompact = isCompact;
I recommend switching this to use a local variable: int[] seen = isCompact? newIds[offset] : newIds;
You can simplify this a bit by using SWTBotTreeItem.wait(ConditionHelpers.ACT_ITEM_NAME, true)
You can simplify this a bit by using SWTBotTreeItem.wait(ConditionHelpers.IsOpened(notActive, true), which is the same logic as in TestBotTreeItem class
You can simplify this a bit by using SWTBotTreeItem.wait(ConditionHelpers.IsOpened(notActive, true), which is the same logic as in CreationTreeItem.
Could you add the check of at least dateFormat?
This is unused, so why make it?
Is this a safe cast?
log.tracef
log.trace
log.tracef?
Make this a static constant, since it is used more than once.
Make this a static constant, since it is used in more places
I'm not sure how this relates to artifacts as content. It is easier to draw the existing rows in this table if it is too big. Could you extract it?
No, this method can throw interrupted exceptions.
No?
No.
Can you explain what is the reason behind this?
Can you explain what is the purpose of this string?
Can you explain what we are trying to do here?
I would prefer to throw an exception here instead of swallowing it. That way the caller doesn't have to handle the exception in another thread.
I would prefer to throw an exception here instead of swallowing it. That way the caller doesn't have to handle the exception in every thread.
I would prefer to throw an exception here instead of swallowing it. In fact I think it's better to stop the thread and do the caller to handle it.
Why is this not also EntityTypeFilter?
Why is this not also EntityTypeRegistry?
Why is this not also EntityTypeResource.entityType()?
Extract "user" in a method to make it more readable
Extract "Internal" in a method to make it more readable
Extract "Internal" in a method to make it clear that it's the same method?
do we need this check? IMO, it should be moved to ScenarioGridModel.call() method
do we need this check? IMO, it should be moved to ScenarioGridModel.call()
do we need this check?
This could just be a public static final
This could be a bit more concise: for (String segment : segments) {...
nit: This could be a bit more concise like this: if (segments == null) { return; } // do something }
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a little safer.
Simpler proposal: registerResourceInCrossReferencer(sessionResource); This should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a little safer.
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now).
You certainly meant "myCache".
You certainly meant "myCache" here (and in the following lines).
You certainly meant "empty caches" here (and'monitor')
It is like a hack. Probably reset() would be a better choice.
It is like a hack. Probably reset() would be a better choice, since its a doall of it and it is not a logSizeLimit.
It is like a hack. Probably reset() would be a more natural choice.
Should this method be private?
Could use <> for the comparison
Could put this in {}
Extract 500L to a variable.
Extract Extract 500L to a variable.
Extract Extract 500L into a variable.
Add a new method for the default case?
Add a new method for this so it will default to STDOUT
Add a new method for this so it will be easier to read.
You will need to use ShellIsAvailable
You will need to add new DefaultTree(1), natureID).asList()
You will need to add new DefaultTree(0)
remove finally {
replace finally {
inline variable
can we use.isEmpty() instead of.equals?
can we get rid of this? we're still using toString.
can we get rid of this? we're still keeping our map.
In this case, please use info instead of System.currentTimeMillis
In this case, please use info instead of System.out
In JUnit, [Test](<LINK_0> is an example of JUnit
Please rename the variable to "file" or "targetContents"
input is missing in the error log.
Please rename the variable to "file" or "target"
Use FileUtils.listFiles here as well?
Not sure if this is a good idea.
Use FileUtils.listFiles here as well
You removed the refreshIsoListFromVDSM methods now, but if you already did it in the ctor, why do we need it here?
You removed the refreshIsoListFromVDSCommand() method in the class. Can you explain it?
You removed the refreshIsoListFromVDSM methods now, but if you already did it in the ctor, why do we need this here?
Arg may not always have a shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Arg may not always have a shape. We might have some place holder code we want to put in here. At least checking for null shapes before you do this would be good.
Arg may not always have a shape. We might have some place holder logic we want to place in here. At least checking for null shapes before you do this would be good.
can we use constants for the header strings?
can we use constants for the same key?
can we use constants for the JSON_TOKEN_HEADER?
This returns too early. It is probably more efficient to create new objects to make the code shorter and more efficient.
This would probably work well if you add new images to JSONHelper.optJSONObject() and convert to string. The method itself may return null.
This would probably work well if you add new images to JSONHelper.optJSONObject() and convert to string. The method is now deprecated and may return null.
when would this happen and if it happens then the window will simply have progress indication and actually nothing will happen
This appears to me to be a redundant check as it is already done in update()
Why not call this with paramsList.forEach()?
This line needs a colon, to make it "case new ItemStack(Material.STONE, item, " + Material.STICK), new ItemStack(ci, b)
This line needs a colon, to make it "case new ItemStack(Material.STONE, item, " + Material.STONE_SLAB), e.g. that would crash.
Use a ItemStack here.
You may also want to test something for the state of the response and see the contents of the list. Could you have a test for this?
You may also want to test something for the state of the response and see the contents of the list. Could you have a test for that?
You may also want to test something for the state of the response and see the contents of the list. Could you have a test for it?
this if should be in network, not inside network.
code duplication
naming
you don't need that line, verifyTitleUrl is already checking that. See point1
you don't need that line, verifyTitleUrl is already checking that. See point.
you don't need that line, it is enough to put it in try block
I think we can use the constant from <LINK_0>
I think we can use the constant from <LINK_0> Also, I think this is not a good idea, but we should consider moving it to a constant.
I think we can use the constant from <LINK_0> Also, I think this is not a good idea, but let's use it when possible.
Missing braces
Missing braces around the condition.
Missing braces.
How about assertThrows() instead?
The return value of waitForWriteRequest() is not thread-safe, so I think this test could be simplified by making the test thread-safe.
How about using assertThrows() instead?
Worth adding a method to org.sonar.java.util.List?
We don't need this condition and again use an empty list.
We don't need this order as we're dealing with immutable lists.
why was this removed?
Why was this removed?
why remove this?
Can't we just use: return o1..compareTo(maximumSize) == 0; instead?
Can/should this be a set?
Can/should this be configurable?
use start()
use progress.isEmpty
use ArrayList
Sorry, we must keep this test untouched. Why?
Sorry, we must keep this change
why?
style nit: missing braces
Please ignore the finals
style nitpick: missing braces
Leftover debug statement?
Swallowing stop session should be removed
Minor: Replace all System.out.println by logging.
rename to action
rename to experiment
rename to pack
please log in error
log.error("Exception", e);
log should be logged in case of error
suggestion InputStream inputStream = classLoader.getLinkedHashMap(KEY);
suggestion InputStream inputStream = jmxConf.get(resourceName);
suggestion InputStream inputStream = jmxConf.get(SunUtils.class);
I think we should just set the filters inside buildSortBuilder
I think we should just add a debug log message to the logger.
I think we should just add a debug log message to the console when this.
this could be done in a static way (we only need the deep branched)
this could be done in a static way (we only need to check for nulls).
this could be done in a static way (we only need the deep branch).
.first(Audience.class) ->.getImmutableSet().of("No null"))
.first(Audience.class) ->.getImmutableStack().of("No usable"))
orElseThrow doesn't look appropriate.
Why not letting RuntimeException be thrown here? That way there is no need to declare it here.
Why not letting RuntimeException be thrown here? That way there is no need to catch RuntimeException during reflection.
Why not letting RuntimeException be thrown here? That way there is no need to catch Exception but what's the actual behavior?
I believe the logic below can be simplified.
I believe the logic below can be simplified?
I believe the logic below can be simplified? The question button is still here.
onCreate() is called one time on start, so it's always null. If we got onCreate called second time then the database is corrupted (one time on database connection close).
onCreate()?
url?
Wouldn't this be a separate preference? I personally dislike autocompletion, but I do want (same-level) auto indent (i.e. pressing enter preserves the indentation of the previous line, it should not increase indentation after a { for me).
I personally dislike autocompletion, but I do want (same-level) auto indent (i.e. pressing enter preserves the indentation of the previous line, it should not increase indentation after a { for me).
Wouldn't this be a separate preference? I personally dislike autocompletion, but I do want (same-level) auto indent (i.e. pressing enter preserves the indentation of the previous lines, it should not increase indentation after a { for me).
Why is this wrapped to a OperationException? You would need to wrap the multicastResult.
I think it would be better to inline the multicastResult.
Why is this wrapped to a OperationException? You would need to wrap it to a specific exception
please remove this change
why this is not in RunVmValidator?
please check if vm is null before this check
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can quietly use the same short version.
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can quietly use the same short version elsewhere.
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can _read_ both versions - but write only in this case.
Do we need to keep these separate tests as those are the same?
Do we need to keep these separate tests as they are testing?
Do we need to keep these separate tests as those are the only relevant test?
We already have getFont's FaceResources. For the reason it works is on the previous line. I think it should be in the else statement.
We also have to adjust'refresh' and'refresh' messages.
We already have getFont's FaceResources. For the reason it works is on the previous line. I think it should be in the else block.
Why is this necessary?
Why do you need this?
Why is that changed?
You could do String.valueOf(src.getContent().getTrace()) to avoid the instanceof check and use the null one below
You could do String.valueOf(src.getContent().getTrace()) to avoid an extra sId.
You could do String.valueOf(src.getContent().getTrace()) to avoid the instanceof check and use the null one in the resolve method
wouldn't it be more readable to use an ImmutableList vs a new array?
wouldn't it be more readable to do this in a foreach loop instead, and then do a single call to Color.values() below?
wouldn't it be more readable to do this in a foreach loop instead, and then do a single return statement separately?
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/shard/:shard
The url doesnt give a sense that the request has to get "metrics". May be something like this? /v2.0/:tenantId/metrics/shard/:shard
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/shard
The other formats are actual formats (HTML or MD) whereas simple is just plain-text.
The other formats are actual formats (HTML or MD) whereas simple, it could be txt or text for plain-text.
The other formats are actual formats (and the ones below)
You can check the ColumnType.PROPERTY_PATH here.
You can check the ColumnType.STRING here.
You can check the ColumnType.PROPERTY_KEY is not null
Call confirmActivity.getCard().getAppLanguageCodes().size() instead of calling it multiple times.
Call confirmActivity.getCard().getAppLanguageCodes().size() instead of checking it again.
Call confirmActivity.getCard().getAppLanguageCodes().size() instead of calling it multiple times?
The following code snippet is the same as the if/else: java if (connectionLifecycleHandler.isSuccess()) { handler.onNewConnection(newConnection()); }
The following code snippet is the same as the if/else: java if (connectionLifecycleHandler.isSuccess()) { handler.onNewConnection(newConnection); }
The following code snippet is the same: java if (connection!= null) { handleNewConnection(newConnection); }
This also needs to be changed to handle the case where the compiler is complaining about an error.
This also needs to be changed to handle the case where the 'else' is not available.
This just change the existing code.
How about a test where it fails if no barcode files are found? How about a test if not all the tiles were found? My apologies if they are already there.
How about a test where it fails if no barcode files were found? How about a test if not all the tiles were found? My apologies if they are already there.
How about a test where it fails if not all the tiles were found? My apologies if they are already there.
-1000000000 isn't a constant...
1000000000 becomes a constant...
[minor] Why a mock?
isn't it required to start the async queries from the cluster?
Shouldn't we be able to use the old volume here?
isn't it required to start the async queries from the db?
Nitpick: Would be good to separate the exception onto different lines.
Nitpick: Would be good to separate the exception message unless it's possible, although I don't want to know that there's a need.
Nitpick: Would be good to separate the exception message unless it's possible to do that.
Why not catch MessagingException here? The interrupt might be here.
Why not catch MessagingException here? The interrupt might be here
Why do you catch this exception here? The interrupt is going to be here...
Can we reuse "isNotEmpty"
Can we use "isNotEmpty" for the framework?
Can we use "isNotEmpty" for the cipher already?
suggestion Deadline.fromNow(Duration.ofSeconds(10), 5L);
suggestion Deadline.fromNow(Duration.ofSeconds(10), 10L);
Why do we need this this?
static import
static import?
static import?
this is now outside of the if (isImagesAlreadyOnTarget()) scope. is it on purpose?
this is now outside of the if (isImagesAlreadyOnTarget()) scope, is it on purpose?
this is now outside of the if (isImagesAlreadyOnTarget()) scope. is it on purpose to validate it?
For the hook, use the same name (last in the list of hook providers)
IMHO you need to name the webhook with the name?
IMHO null-safe string could be provided.
I don't know how this Build class is instantiated. Can you leave as it is, please?
I don't know how this Build class is instantiated. Can you leave as it for now?
I don't know how this Build class is setup. but can you please leave as it is (and to do it for the whole test)?
Why an existing PendingConfirm that can be used?
Why an existing PendingConfirm that would be used?
Why an existing PendingConfirms.clear();?
Does it really make sense to use a stream here? Or should it be a Publisher?
Does it really make sense to use a stream here?
Should this be removed?
Should be simplified to use Objects.equals(channel, other.channel) here
Should be equals
add braces
This exception makes no sense to the caller and it will always be false. If you are just sanity checking, throw an AssertionError.
This exception makes no sense to the caller and it will always be false. If you are just sanity checking, throw an AssertionError. This one will always be false.
This errorResId.
I just realized that these checks should be applied to both Overwrite and GCS methods since they should be merged into one.
I would just put.setOverwrite(...) here and let the default be false when it's false.
I just realized that these checks should be applied to all link classes.
Shouldn't we measure the note id here?
Shouldn't we log the note too?
Shouldn't we measure the noteId in the interpreter?
Should this be a checked exception?
Should this be a checked exception too?
Should this be a constant?
shouldn't this be DeepLinkManager?
shouldn't this be DeepLinkAdapter?
shouldn't this be more specific?
isn't the default 2?
isn't this the default 2?
isn't a hard time value?
> Again, should be > totalTimeSpentReadingBytes
> Again, should be > 0 as well.
..it's trivial.
No need for this variable, same below.
No need for this variable, just assert the actual size > 0 on failure.
No need for these extra lines.
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a delete. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
That's what I meant. But now that I see it I're asking myself why we don't use diff.getPath here, it returns the old path in case of a delete. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a directory that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
Shouldn't we use final here?
Shouldn't we use final for the actual parameters?
Shouldn't we use final for the parameters?
This should be in the same commit as in the test
This should be in a new method.
This should be a simple return as an argument.
Minor: you can use the local variable commandTargetResolver directly here.
can we use the member get() here instead of the commandType?
can we use the member get() here instead of the first?
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen");
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen");
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen"); This might be placed just before the line.
it seems like this should be config.storeLocalStore()
it seems like this should be config.storeLocalScheduler here.
it seems like this should be config => just this.config
lastChunk.buf.length() == 0 is not a reliable check since buffers can have position > 0 and yet have no data because position == limit. Also, what happens if there are zero sized buffers in the middle? I think it should be fine - but a test would be useful (if not already there)
lastChunk.buf.size() == 0 is not a reliable check since buffers can have position > 0 and yet have no data because position == limit. Also, what happens if there are zero sized buffers in the middle? I think it should be fine - but a test would be useful (if not already there)
lastChunk.buf.length == 0 is not a reliable check since buffers can have position > 0 and yet have no data because position == limit. Also, what happens if there are zero sized buffers in the middle? I think it should be fine - but a test would be useful (if not already there)
autobixing?
please change to 'continue' instead of the else branch
1. There's no need to load a map here, see Guids
Do we really want to confirm every time we send the event?
Do we really want to confirm every time we send a subscribableStreamObserver is called?
Do we really want to confirm every time we send a subscribableStreamObserver get called?
nit: extra space after }
nit: This is a bit awkward to make sure we don't rely on the current processor being leaked on the ProcessorContext#poolableProcessorContext. Please find a way to properly handle the leak.
nit: This is a bit awkward to make sure we don't rely on the current processor being leaked on the ProcessorContext#poolableProcessorContext. Please find a way to properly handle the leak here.
possible NPE?
List<String>
check?
Can we make the rest of the code more readable? I don't think the m prefixing is required here.
Can we make the rest of the code more readable? I don't think the m prefixing is required.
Static import?
This is a breaking change, the index is used for all the segments and this is something that should be included in the user input.
This is a breaking change, the index is used for all the segments and this is something that should be included in the log.
This is a breaking change, the index is used for all the segments and this is something that should be logged.
As per above, this one should be.commit() right?
As far as I understand this one is not required
As far as I understand this one is not required.
why are you using instanceof here? could you use the interface instead of both?
why are you using instanceof here? could you use the interface?
why are you using instanceof here?
This code is the same as the original logic of the equivalence. Is it possible to get a null type here?
This code is the same as the original logic of the equivalence. Is it possible to get a null value from the superclass?
This code is the same as the original logic of the equivalence. Is it possible to get a null value on the superclass?
is there a reason you can't just store the message as a field?
is there a reason you can't just extract out the keySet() and then use it?
is there a reason you can't just store the header in a field?
Could you avoid using e.printStackTrace() here?
Could you add a logger?
Could you add a logger here?
We can't use an explicit "else" statement here: Charset cs = Charset.defaultCharset(); if(fileString!= null) { return new Charset(fileString); } return null;
We can't use an explicit "else" statement here: Charset cs = Charset.defaultCharset(); if(fileString!= null) { return null; } value = Charset.defaultCharset();
We can't use an explicit "else" statement here: Charset cs = Charset.defaultCharset();
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :)
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :) Please explain.
OK. sounds good. Anybody step up and tell me where to put the code and parameter?
:ant: I think you meant this.
:ant: I think you intended for use null checks here.
:ant: I think you can just use null checks here.
nit: seems like this is just a copy&pasted from 401
nit: seems like this is almost always the same as the assertion above?
Not really sure why this is asserting the result.
try-with-resources for better readability
try-with-resources for better readability.
try finally?
Instead of returning a String, better yet: String diagramCategory = (String)next; if (next instanceof Object[]) {... }
Instead of returning a String, better yet: String diagramCategory = (String)next; if (next instanceof Object[]) {... return ""; }
Instead of returning a String, it may be better to define a variable for the entire class
@ashijtimiihoxha Sure 'else' looks wrong.
@ashijtimiihoxha Sure 'else'?
@ashijtimiihoxha Shouldn't this be conditioned?
This fails and so the other confidence won't be updated.
This fails and so the rest of the method fails (throws an exception if it fails).
This fails and so the other confidence won't be updated. And as far as I can tell the problem.
For consistency, I suggest using EntityType.FEED.name() as the default and only use it if it is used.
For consistency, I suggest using EntityType.FEED.name() here.
Braces are correct at the end.
It's possible to propagate the InterruptedException here instead of swallowing it.
It's possible to propagate the InterruptedException here instead of adding a log message.
It's possible to propagate the InterruptedException here instead of adding a public method
Could we consider a config setting something like "schema-version-{Version} ms"
Could we consider a config setting something like "schema-version-whatever" in case if "client" is null?
Could we consider a config setting something like "schema-version-{Version} ms" in case of fail?
Extract into a variable for the timeout?
Extract into a variable for the delay.
Extract into a variable for the state of the task.
Do we know why we are throwing a checked exception here?
Do we know why we are throwing an exception here?
Do we really need the empty check?
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to be reused in the testFindLiveVersionFile test and also to leave the test shorter and cleaner
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to be reused in all testFindLiveVersionFile test and also to leave the test shorter and cleaner
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to be reused in this testFindLiveVersionFile test and also to leave the test shorter and cleaner
Does the segment need to be updated?
Does the segmentMoved/bytes need to be removed?
Does the segmentMoved/bytes need to be updated to 0?
Null check needed here. This suggests that articleVersion is not Null, but we just want to see this in the future.
Null check needed here. This suggests that articleId is not Null, but we just want to see this in the future.
Null check needed here. This suggests that articleId is not Null, but we just want to see this in the else below.
Do we need to catch exceptions here? For example, if someone specifies a config problem, it will look like a warn log or warn indicating that the workflow has been removed from the config. Or maybe throwing an exception would be more appropriate.
Do we need to catch exceptions here? For example, if someone specifies a config problem, it will look like a warn log or warn indicating that the workflow has been removed from the config. Or maybe throwing an exception would be more appropriate?
Do we need to catch exceptions here? For example, if someone specifies a config problem, it will look like a warn log or warn indicating that the workflow has been removed from the config.
I think it should be e.get()
This is fine, but I think it worth doing two things
extra space
No permissions needed to make the test pass.
Just a matter of preference: but I don't think we need to make the permissions given that we're using the system properties.
Just a matter of taste: but I think the test like this doesn't make sense.
I find this confusing. Why not just use monitor.getWorkWidth() here?
I find this confusing. Why not just return monitor.getWorkWidth() here?
I find this a little hard to read. Why not just use an int?
Can you please print the body of the msg?
Can you please change this one to msg?
Can you please rename this one to something like responseHeaders
Can we assert on the ANY_STAGE_ANY_STAGE_NAME?
I'm assuming that this is a bug. If I have two ANY_STAGEs, this one will break this test
I'm assuming that this is a bug. If I have two ANY_STAGEs, this one will break the tests
Should it be substitutions?
Should this be substitutions by type?
Should this be substitutions?
Can you elaborate why we need to do this? In the case of URISyntaxException it would be better to provide a more specific message, which the message (e.g. "onNext").
Can you elaborate why we need to do this?
Let's discuss how tomorrow.
Just shorter: patternsDir.isDirectory() && patternsDir.isDirectory())
Just shorter: patternsDir.isDirectory() && patternsDir.isDirectory();
Just shorter: patternsDir.isDirectory() && patternsDir.isDirectory()
This looks like it could be a bit shorter: StringBuilder buffer = new StringBuffer(); StringBuilder(values.append("Version", ','); buffer.append(buffer).append("\n"); for (int i = 0; i < options.length; i++) { char c = 0; StringBuilder buffer = new StringBuilder(); for (int i = 0; i < options.length; i++) { char c = 0; StringBuilder buffer = cycleLogs; if (i == 0) { builder.append("foo"); } } return new StringBuffer();
This looks like it could be a bit shorter: StringBuilder buffer = new StringBuffer(); StringBuilder(values.append("Version", ','); buffer.append(buffer).append("\n");
This looks like it would create a StringBuilder for each line.
This should actually happen in the test. See for example the test class: SessionManager.getSessions().isEmpty()
This should actually happen in the test. See for example the test class.
This should actually happen in the test. See for example the test.
Exception is not logged or thrown
Exception is never thrown and can be removed.
computeIfAbsent
I wonder if we should keep the original logic here. Let's have the text at the end of input.
I wonder if we should keep the original logic here.
I think you need to modify the static import.
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=add) and then let it override metrics?
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=VARCHAR)?
nit: Should be metricsQuery.getMetrics().stream()
if (packageName == null) { throw new URISyntaxException("Supplied"); }
if (packageName == null) { throw new URISyntaxException(obj); }
nit: add braces
In the previous version of this method, "gr_id" is not named "grId". Maybe instead of "grId" the old values?
In the previous version of this method, "gr_id" is not named "grId". Maybe instead of "grId" there should be a better name.
In the previous version of this method, "gr_id" is not named "grId". Maybe instead of "grId" there should be a null check somewhere?
Use a variable for the title, like File..
Use a space after if, will make it more readable
Use a space after if, will make it more readable?
Please use "0000" (I know, but still.)
Please use "0000".
Better to use "0000".
The name is not consistent with the merge of the conditions
The name is not consistent with the merge of this method.
The name is not consistent with the merge of the conditions in this file.
should this exception be caught and handled inside the IllegalArgumentException below?
should this exception be caught and handled in the IllegalArgumentException below?
should this throw an IllegalArgumentException?
L82-L84 can be removed.
L82-L84 can be removed since this is not used.
checkArgument?
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures. Would be nice to avoid using it.
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures.
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures. Might be nice to avoid using it.
This line can be simplified to if (outputs.containsKey(event.getChunkId()!= NotebookDocQueue.CHUNK_EXEC_FINISHED)) { output.setPopupPosition(event.getChunkId()); } else { output.setPopupPosition(event.getChunkId()!= NotebookDocQueue.CHUNK_EXEC_FINISHED); }
This line can be moved to a new line.
This line can be moved to a return statement.
unrelated bug fix?
unrelated bug fix? and should we split this into separate commit?
unrelated bug fix? and should we split this into the actual bug?
add message to exception
add a message to exception
add some message to exception
I would divide this method into 3 methods. One for final aggregation, and one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity.
Maybe remove Parts.computeIfAbsent()
Maybe remove Parts.computeIfAbsent()?
Maybe IOException is better?
Maybe IOException is enough to indicate a problem that an IOException is thrown?
Maybe IOException is enough to indicate a problem that an IOException is thrown.
> What about the rest of the tests to do with schema change without any query's db'? > Is it possible to support multiple dbs in the same transaction?
> What about the rest of the tests to do with schema change without any query's db'? > Is it possible to support multiple dbs in the same query?
> What about the rest of the tests to do with schema change without any query's db'? > Is it a concrete implementation?
We should be more descriptive here. Let's say "Search for search"
We should be more descriptive here. Let's log the exception
We should be more meaningful here. Let's log a more useful message.
why not just use NIOServerCnxnFactory.this?
why not just use NIOServerCnxnFactory.this as the default constructor for this class
why not just use NIOServerCnxnFactory.this as the default constructor I used above?
Maybe this can directly be valuePointers.set(nodePointers.getPositionCount(), groupIds);
Maybe this can directly be valuePointers.set(nodePointers.getPositionCount(), groupIds.position())
Maybe this can directly be valuePointers.set(nodePointers.getPositionCount(), groupIds.get(category)));
Would be better to use operand.getSecond().longValue() since it's more flexible?
Would be better to use operand.getSecond().longValue() since it's more safe to do.
Would be better to use operand.getSecond().longValue() here since it's more safe to do.
Move the logic of the timeout code inside the ProbeResult.unhealthy method?
Are the logic changed from and to Guava?
Move the logic of the timeout code inside the catch block?
condition could be inversed and in fact the for each can be applied no matter what, if empty, this is a noop. Thus, no need to collect.
condition could be inversed and in fact the for each can be applied no matter what, if empty, this is a normal statement.
condition could be inversed and in fact the for each can be applied no matter what, if empty, this is a normal loop.
No need to call Integer.parseInt(getUuid()) more than once.
No need to call Integer.parseInt(getUuid()) more than once in a method.
No need to call Integer.parseInt(getUuid()) more than once in these methods.
you cannot loop only one time on the full entryset?
you would not need to print the full path, since you are sending it to the file in line 403
you cannot loop only one time on the full entryset? why not loop only one time?
This code block is duplicated within the test, it can be extracted to a separate method.
This code block is duplicated within the tests, it can be extracted to a separate method.
This code block is duplicated within the test, it can be extracted to one method.
This can be moved to a try-with-resources block.
This can be moved to a guard clause.
This can be moved to a method.
Change this to with tab?
Change the method name to formItem or formItem?
Change the method name to formItem.biosSerialNumberInLine
While you're here, you could use the introduced method instead, so that the old data setSneaking() never returns null.
While you're here, you could use the introduced method removed, especially since you're applying the introduced methods, which does the same thing.
While you're here, you could use the introduced method instead, which does the NPE.
If you're at it, try to refactor this line to "isOsrCode("run. interpreter")" into a separate method.
If you refactor this line to a new method, at least you can save a line of code.
If you're at it, try to refactor this line to "isOsrCode("run. interpreter")" into a variable, try to keep it cleaner.
As I think it should be equals instead of trimAddress()
As I think it should be trimAddress() instead of trimAddress()
As I think it should be trimAddress() instead of trimAddress().
I'd prefer to have each request in a different order than what you're trying to achieve.
I'd replace this with assertThat(result, hasItem("UUID")).hasItem(param)
I'd prefer to have each request in a new query.
You could extract the three lines of SSH configuration in a dedicated private method (in case we need to add more config for exmaple).
You could extract the three lines of SSH configuration in a dedicated private method (in case we need to have more config for exmaple).
You could extract the three lines of SSH configuration in a dedicated private method (in case we need to add more config for exmaple)?
@vmaletta Variable name should be singular
@vmaletta I think we can keep this final
@vmaletta use criteria.getPersistentClass()
I'd suggest to remove this log message as it duplicates the ones in mdnsInstances.
I'd suggest to remove this log message as it duplicates the ones in the 'UpdateService'.
I think it's better to use parameterized logging here.
better assert that the list is sorted
better assert that it is not invoked two times, once per second, right?
better assert that it is not invoked two times, once per second, move final
What about: java if (fulltext!= null && fulltext.startsWith(fulltext)) {
What about: java if (fulltext!= null) { return; }
What about: java if (fulltext!= null) {
Is there a reason you can't change the test to fail("Skip test to fail");?
Is there a reason you can't change the test to fail("Skip test for HSQL to fail");?
Is there a reason you can't change the test to fail("Skip test for HSQL " + ps + " on this table?
Shouldn't these two lines be a method that takes the id lock and id?
Shouldn't these two lines be a method that takes the id lock id?
Shouldn't these two lines be a method that takes the id lock lock lock lock lock lock?
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about ownedPartitions 2) even if it does, it will not know about updates (such as metadata/subscription change, missed rebalance) while the ConsumerCoordinator's subscriptions.assignedPartitions is always up to date. To address 1), I think it is reasonable to assume/force a **Cooperative** assignor to have some knowledge of ownedPartitions especially since we are ok to assume it will be able to handle the "adjust assignment" logic. And regarding 2), we could actually just pass along the current assignment to the PartitionAssignor prior, or as a separate PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting ownedPartitions in ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer misses a rebalance. It's partitions get assigned to another consumer but there's so much state to restore it doesn't get very far before the first consumer manages to rejoin. The first consumer's state is up to date while the second consumer is very far behind, but only the second consumer will join with a non-empty ownedPartitions so it is more likely to get the partitions again. (this scenario requires a more advanced assignment strategy than we currently employ, but even the current sticky assignor leverages this information to improve stickiness where possible) @guozhangwang @hachikuji
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about ownedPartitions 2) even if it does, it will not know about updates (such as metadata/subscription change, missed rebalance) while the ConsumerCoordinator's subscriptions.assignedPartitions is always up to date. To address 1), I think it is reasonable to assume/force a **Cooperative** assignor to have some knowledge of ownedPartitions especially since we are ok to assume it will be able to handle the "adjust assignment" logic. And regarding 2), we could actually just pass along the current assignment to the PartitionAssignor prior, or as a separate PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting ownedPartitions in ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer misses a rebalance. It's partitions get assigned to another consumer but there's so much state to restore it doesn't get very far before the first consumer manages to rejoin. The first consumer's state is up to date while the second consumer is very far behind, but only the second consumer will join with a non-empty owned partitions. (this scenario requires a more advanced assignment strategy than we currently employ, but even the current sticky assignor leverages this information to improve stickiness where possible) @guozhangwang @hachikuji
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about ownedPartitions 2) even if it does, it will not know about updates (such as metadata/subscription change, missed rebalance) while the ConsumerCoordinator's subscriptions.assignedPartitions is always up to date. To address 1), I think it is reasonable to assume/force a **Cooperative** assignor to have some knowledge of ownedPartitions especially since we are ok to assume it will be able to handle the "adjust assignment" logic. And regarding 2), we could actually just pass along the current assignment to the PartitionAssignor prior, or as a separate PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting ownedPartitions in ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer misses a rebalance. It's partitions get assigned to another consumer but there's so much state to restore it doesn't get very far before the first consumer manages to rejoin. The first consumer's state is up to date while the second consumer is very far behind, but only the second consumer will join with a non-empty ownedPartitions so it is more likely to get the partitions again. (this scenario requires a more advanced assignment strategy than we currently employ, but even the current sticky assignor leverages this information to improve stickiness where possible) @guozhangwang @hachior
It's recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
I think PlatformUI.getWorkbench().getDisplay() is better to use here.
It's recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay().
I have a concern here, we introduced WorkbenchManager.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchDockEntryPresenter.createPermissions
I have a concern here, we introduced WorkbenchManager.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchTreeProvider.createPermissions
I have a concern here, we introduced WorkbenchManager.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchDockEntry#createPermissions
Since this is the only place you need to check for anonymous injection.
Since this is the only place you need to check for anonymous versions.
Since you are not using args at all, you should use isPreemptiveAuthentication() to filter out the parentcache.
I think these should be complete
I think these should be complete?
I think these should be an UnknowSerializer.
Init
DiskControllerType.UNASSIGNAL
DiskControllerType.INDEX
We need to check for languageMaps.getDisplayName() and use getBaseDirectory() instead.
Probably we need to check for file separator before concatenating the locale. Also, since this is not expected to happen in every request or other file.
Probably we need to check for file separator before concatenating the locale.
A newline is missing between \n and '('
A newline is missing after the parenthesis.
A newline is missing between \n and '('.
I think you should add a constant for "assignmentToMenu" to the menu title. It would be good to avoid the StructuredResult and do something like that: title = "assignmentToMenu(); if (action == null) { title += "assignmentToMenu(); } //NON-NLS-1 }
I think you should add a constant for "assignmentToMenu" to the menu title. It would be good to store the menu title in a constant, and then use that in each menu title.
I think you should add a constant for "assignmentToMenu" to the menu title. It would be good to avoid the StructuredResult and do menu.add(action) to the menu title.
We could probably just do return typeAnnotation.class.equals(typeAnnotation)
We could probably just say return typeAnnotation.class.equals(typeAnnotation)
We're just using a static import here.
I'm afraid this will fail to fix the OS by default. The point of talend is that when the system versions are configured, but all users must be configured by the system.xml, so by default this PR, the android version will be just target.
I'm afraid this will fail to fix the OS by default. The point of talend is that when the system versions are configured, but all users must be configured by the system.xml, so by default this PR, the android version will be just configured to target.
I'm afraid this will fail to fix the OS by default. The point of talend is that when the system versions are configured, but all users must be configured by the system.xml, so by default this PR, this will fail to fix the issue. The WDYT?
@rishabh-997 I think this is the wrong way of doing the empty check in the above method
@rishabh-997 I think this is the wrong way of doing the empty check in the above method.
@rishabh-997 I think this is the wrong way of doing the empty check in the above code.
Sorry, but I don't see the test case for this test case. It may be useful to have a test case for the test case below.
Sorry, but it is hard to distinguish between test coverage of the case where these tests run. Is this the case?
Sorry, but I don't see the test case for this test case. It may be useful to have a test case for the test case.
This variable is redundant here
This variable is now redundant here
This variable is redundant here.
The usual manpattern is to use assertEquals(TestRegexMountPoint regex, "user/hadoop/user/hadoop/user/src/test/java/org/ppelin/cloud/core/b/c/org/csanit/core/b/c/core/b/c/b/c.java.
The usual manpattern is to use assertEquals(TestRegexMountPoint regex, "user/hadoop/user/hadoop/user/src/test/java/org/ppelin/cloud/core/b/c/org/csanit/core/b/c/core/b/c/b/c/
You can use assertEquals directly
Extract constants
Extract constants?
remove ;)
you could do here itself if(closeProfilingStatsModel)
you could do here itself if(closeProfilingStatsModel)?
you could do here itself if(closeProfilingStatsModel) { return null; }
Why is this a breaking change?
Is there a reason for using a static method rather than public?
Was there a reason for using the extra minus function?
Can we chain the two lines together, so that we don't have to do the same thing?
Can we chain the two lines together, so that we don't have to do the other bits?
Can we chain the two lines together, so that we don't have to do the other string concat each time?
1. Does this change make sense? 2. createWorkspaceFromDevfile does not overflow the workspace in this case. I think it is better to put this line in removeWorkspaceFromDevfile.
1. Does this work if it is adding this same name as the original one? 2. put it in removeUserFromDevfile.
And this line does not work
I think we need to remove the version=\"1.0\"
I think we need to migrate file so that it's sufficient here.
I think we need to remove this try/catch at all.
Can we remove the line break? It seems to be having the same functionality on the new block with the error block.
Can we remove the line break? It seems to be having the same functionality on the new block.
Can we remove the line break? It seems to be having the same functionality.
you should call into.trim() on files
you should call into.properties
you should use below
I'd suggest creating a map of exceptions for the sheet and needing to handle the sheet.
I'd suggest creating a map of exceptions for each sheet and then throwing it (if necessary) in the try-with-resources block.
Arrays.asList()
You should not use setter with a default value and check for null before adding it.
You should not use setter with a default value and check if there's only one used in this class.
You should not use setter with a default value of false.
Is the check needed in the first place?
Is the check needed in the async callback? <LINK_0>
Is the check needed in the first step of the savePrevTitle()?
The instance of the SQLDataException is never thrown.
Same. Could add the exception to the logger.
The return type is not necessary.
Why propagate the error? We don't handle it anywhere.
Why propagate the error?
Why propagate the error? We don't store the current thread?
Can you change the assertion message to something like sourceInfo.getWatermarkType().toString()
Can you change the assertion message to something more descriptive?
Can you change the assertion message as well?
Is there no reason to check for the TelephonyManager directly? The system should explicitly take care of it.
Is there no reason to check for the TelephonyManager directly? The system should automatically take care of it.
Is there no reason to check for the TelephonyManager directly? The system should take care of it.
not sure about the difference between downloadLayout and deleteNextRowEmittedAtMillis?
not sure if relevant for the long timeSinceLastRowEmittedAtMillis?
not sure about the difference between downloadLayout and downloadNextRowEmittedAtMillis?
We don't declare executor in the class. That would make it sucks.
We don't need to declare executor in the class.
We don't declare executor in the class.
Could you please extract the nullToEmpty call to the new NoSuchMethodException?
Could you please extract the nullToEmpty call to a separate PR?
Shouldn't we override the nullToEmpty method?
You're better off just checking the first letter: <LINK_0>
You're better off just checking the string directly, no need to check if it's a string.
You're better off just checking the string directly? I guess it's better than trying to use a String directly!
This might be better as a separate method to convert the refresh tokenDAO to a token.
This might be better as a separate variable?
This might be better as a separate method called refreshUrl(List<RefreshToken> tokens)
II think this code was also inherited but it seems a bit weird.
II think this code was also inherited but it might be clearer if the WikipediaApp.getInstance() were also used in the ViewModel.
II think this code was also inherited but it might be clearer if the WikipediaApp.getInstance() was used in a way.
I think you should use a method boolean isNewIdentifier(Repository newIdentifier)
I think you should use a method boolean isPatient(Repository newIdentifier)
I think you should use a method boolean isPatient(Repository)
let's move this condition to the previous catch block
let's move this conditional to the declaration
let's put this conditional in the try/catch block
Maybe we should remove this exception, since this is already done in the catch block.
Maybe we should use this exception instead of printStackTrace. In this case, I would use StringUtils.join instead of.map
Maybe we should use this exception instead of printStackTrace. In this case, we use our [pattern](<LINK_0>
All this could use min instead of min() == 0 I would say that min is likely more than 100.
All this could use min instead of min() == 0 I would say that min is more than 100.
All this could use min instead ofmin() - min is 0.
Please use org.assertj.core.util.Lists#stream instead.
Please use org.assertj.core.util.Streams#stream instead.
Please use org.assertj.core.util.Lists#size not 0.
Do we need to assert that the message is the same as inOrder?
Do we need to assert that we're not calling.isEqualTo() here?
Do we need to assert that we're not calling.out here?
Typo in method name
Typo in the method name
Typo in the method name? I think it would be better to have the right method name
This condition will either always be true or always be false; the watchService local variable needs to be updated at the bottom.
maybe while statement here make code more readable?
This condition will either always be true or always be false; not sure.
This method may be able to be used here too, e.g. as below: bind( s, "CHE_SINGLE_PORT")
This method may be able to be used here too, e.g. as below: bind( s, "CHE_SINGLE_PORT", "Provisioners");
This method may be able to be used directly from the Provisioners method
you don't need the check for null here. Tasks.getRunAt(numMissingInstances.size() - 1) does this check internally
you don't need the check for null here. Tasks.getRunAt(numMissingInstances.size() > 0 is a valid value
you don't need the check for null here. Tasks.getRunAt(numMissingInstances.size() - 1) does this check internally and it makes sense to get a SingularityPendingTask that is either empty or null?
Is the loop necessary? Why not use a StringBuilder and use the key pair
Can't we use the key-repeatable columns here?
Is the loop necessary? Why not use a for-each loop here?
Can we just do a post() here, and not keep track of whether it's needed?
Can we just do a post() here, and not keep track of whether it's empty?
Can we just do a post() here, and not keep track of whether it's needed? I think we can keep track of whether it's needed.
As discussed, the method should return an Optional<String> instead.
As discussed, the method should return a List<String> instead.
As discussed, the method should return a Map<String, Object> instead.
should this be in a finally block?
should this be in a Logger so that we have to touch other paths here?
should this be in a Logger so that we have to touch other paths?
Can we make this a stream.filter(e -> e.getMessage()).map(e -> e.getMessage()).collect(Collectors.toMap(e -> e.get(), e -> e.getMessage()))
Can we make this a stream.filter(e -> e.getMessage()).map(e -> e.getMessage()).collect(Collectors.toMap(e -> e.getLocalizedMessage(), e -> e.getMessage()))
can be replaced with: return new VideoConstraints(e -> e.onstagePreferredHeight(selected)));
MapRewriterMap = new URIRewriter(darkServiceName, v -> { URI configuredURI = darkServiceName; return originalRequest.get(darkServiceName).toString(); }
MapRewriterMap = new URIRewriter(darkServiceName, v -> { URI configuredURI = darkServiceName; return originalRequest.get(darkServiceName).toString(); }?
MapRewriterMap = new URIRewriter(darkServiceName, k -> { URI configuredRequest = darkServiceName; return originalRequest.get(darkServiceName).toString(); }
Have you considered using ++i instead of this.
Have you considered using ++i here?
Have you considered using ++i instead of ++i here?
Does this work? We don't need to change it if the JsonSerializer type is a singleton.
Does this work? We don't need to change it if the PR is creating a new serializee.
Does this work? We don't need to change it if the PR is creating a new serializee, then why do we have it here?
why synchronized?
it is possible to use the Clock interface for the iteration order, with no change that is required.
it is possible to use the Clock interface for the provider
Here is another example of what should be done here: <LINK_0>
Here is another case where we should make it final.
Make it final.
We should test if the file exists in the resource set which is a given resource. If the tree is in the resource set it is not a resource but a resource set is in the map. Something like this: java if (res == null) { resource = resourceSet.getResourceSet() } if (res == null) { resource = resourceSet.getResourceSet(); } else { resource = resourceSet.getResourceSet(); }
We should test if the file exists in the resource set which is a given resource. If the tree is in the resource set it is not a resource but a resource set is in the map. Something like this: java if (res == null) { resource = resourceSet.getResourceSet() } if (res == null) { resource = resourceSet.getResourceSet(); } else { resource = resourceSet.getResourceSet() }
We should test if the file exists in the resource set which is a given resource. If the tree is in the resource set it will be created
spelling: Shouldn't it be **_**?
spelling: Shouldn't it be "**"?
spelling: any
Please use try-with-resources statement for the try-with-resources statement.
Please use try-with-resources statement for the resources.
Please use try-with-resources statement for the try-catch statement.
This should be private and the ExposedField class is not null. The ExposedField constructor will always return a null, so you could get an NPE here.
This should be private and the ExposedField class is not null. The ExposedField constructor will always return a null, so you could get an NPE here
This should be private and the ExposedField constructor should be static
I might suggest including the Exception in the next line.
I think the Exception should be a string
I might suggest including the Exception in the resulting HTTP response
If we pattern to be consistent, I think we should also add a log message here.
If the classIdClassMapping is!classId.getName().equals(classId), we don't need to check for null. Just use the method directly
If we pattern to be consistent, I think we should not use the packageId. It is on the method name
Would it make sense to move this condition to the beginning of the method and keep the code readable.
Would it make sense to move this condition to the beginning of the method and keep the code simple.
Would it make sense to move this condition to the beginning of the method, with writeToHeaderToNull()?
Why not just assert if there is only one question?
Why not just assert if there is only one question expected?
Why not just assert if there are more details?
Move to debug
Move to bundle.
Move to debug level
I think you can check if q.getByKey("failed")!= null
I think you can check if q.getByKey("failed") for null
I think you can check if q.getByKey("failed")
reorder
there is no need for'in message
please add getMessage : {}\n{}
If we can't go directly to the framework directly, we should be able to use the <LINK_0> here.
If we can't go directly to the framework directly, we should be able to use the data directly without deferring to the index for the rest of the library.
If we can't go directly to the framework directly, we should be able to use the data directly without deferring to the index management.
The statement getItems() can be null. It is not necessary to add any check, since getItems() could be null.
The statement getItems() can be null. It is not necessary to add any check, since getItems() may not be null.
The statement getItems() can be null. It is not necessary to add any check, since getItems() may be null.
Log consumer has a better message than "Committed partition to commit is required " + offset
Log consumer has a check for "Committed" prior to calling commit. Probably unnecessary if you prefer here.
Log consumer has a better message than "Committed partition to commit is required " + offset);
this does not look like it is being tested anymore and can be removed.
this does not look like it is being tested in runTests method. I think this is the reason the tests are executed in the right order.
this does not look like it is being tested in runTests method.
I'd prefer to use getHostName() to ease correlation with other issues and logs
I would prefer to use getHostName() to ease correlation with other issues and logs
I'd prefer to use getHostName() to ease correlation with other issues and logs.
Nit: the style guide would ensure the correct spacing between if and (.
NIT: the style guide would ensure the correct spacing between if and (.
Nit: the style guide would ensure the correct spacing between openStream and.
Why did you change it to something like this?
Why did you rename this to something like "waitTill"?
Why did you change it to the method call?
(you actually could _not_ have GitHub), but that's not the way we are working with this issue. What if left and right are deterministic by the way?
(you actually could _not_ have GitHub), but that's not the way we are working with this issue. What if left and right are deterministic by our users?
(you actually could _not_ have GitHub), but that's not the way we are working with this issue.
These two should be in the first unit test. These should be as fields.
These two should be in the first unit test. There are a number of fields in the sample app that don't have actually been read.
We need to use the utility methods, right?
please remove
please remove alias setting (should be encapsulated in addVmLeaseStorageDomainCommand).
please remove alias setting (should be encapsulated in addVmCinderDisks method).
and there are no vms, why can't the gateway end user will be able to create vm disks?
and there are no vms so why do we need to stop vm and call?
and there are no vms, why can't the gateway end user will be able to create vm disks from DB?
using log template is preferred
using logging template is preferred
using log command is too complicated
What if isIdentifier is false?
Is there any validation to make sure the tokens are allowed to be the same?
Is there any validation to make sure the tokens are allowed to be valid correctly?
Missing method header.
Errr, @Baughn?
This method is never called with @Brightness header.
Use??
Use same constants??
Use BusService.getSFavouritesList(false);
this can never happen now, can it (assuming you are checking for bytesWritten < size).
this can never be null now, can it (assuming you are checking for bytesWritten < size).
this can never happen now, can it (assuming you are checking for charset conversion).
can you use host instead of EVENT_RECEIVER_SERVICE_PREFIX?
can you use host instead of replicating, right?
can you use host instead of EVENT_RECEIVER_SERVICE_PREFIX here
should probably be named m
should be named m
should probably be renamed
Can we also keep the naming of the variable final?
Remove the else and the next line?
Remove the else and the condition after the if?
We can use the function in FeedActivity.searchFeedItemOrDirectory().
We can use the function in FeedActivity.searchFeedItem, which is already there so it can be reused for other tasks.
We can use the function in FeedActivity.searchFeedItem, this is now also used by FeedActivity.searchFeedItemList()
can we use a const for this?
can we use a Objects.requireNonNull here?
can we use a const or package name here?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
"assert false" will always fail. I think this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks. WDYT?
is this the same as localUpdates.isEmpty()?
is this the same as localUpdates.removeAll(tableName)?
is this the for loop necessary?
The app is closed so that we don't need to close it.
The app is closed so that we don't need this line.
The app is closed so that we don't need this anymore.
Is this change related to the topology?
Is this change related to the topology? If so, can we remove it?
Is it possible to use a human-readable name for the topology?
does it make sense to drop the brackets?
does it make sense to drop the values()
does not need to be public
Minor nit: Usually we just let the exception bubble up, would be nice.
Again, we should move the notebook object to the beginning of notebook object to avoid them.
Again, we should move the notebook object to the beginning, and notebook map to the notebook map.
Missing Assert.fail().
Missing Assert.fail(..)?
assertFalse
hint: support hostName instead of null or empty string
hint: support hostName instead of null or empty values?
hint: support hostName instead of null or empty values.
To be consistent, use.then() in all code below.
To be consistent, use DtoFactory.newFile(BREAKPOINT EMPTY_ID).
To be consistent, use DtoFactory.newFile(BREAKPOINT_file) instead.
why do we need it - we get the Down event...
why do we need it - we get the Down event? IIUC this method is for the case when vdsm stops reporting a VM. Also, IIUC this code only called when vdsm stops reporting a VM. I don't like seeing the VM after a network call to vdsmVm. Shouldn't we do it only on the pre-run mode? i.e. we have the VmExitStatus.COMPLETED in the first place?
why do we actually need it - we get the Down event...
I don't think you need to do it here. The placeholder is handled by the routing data, not the routing data.
I don't think you need to do it here. The placeholder is handled below.
I don't think you need to do it here. The placeholder is handled by the routing key.
StringBuilder
handle null case?
handle null case
assert return value
call encoderChannel.finishAndReleaseAll() to fix LEAK
I see that you're putting a release in the main test.
ImportRewrite to remove declaration.
ImportRewrite
ImportRewrite to remove the field declaration.
Throwing the exception in a constructor is probably better, I think.
solo paramid
solo paramid?
Another way to do this (if you don't use TreeSets)
Use.stream()
Another.stream()
The cast can be removed, as done here.
The cast is not needed here.
The cast is not needed here
It might be more helpful to print the decoded value here if the decoded is null. There's also no sentinel check for that.
It might be more helpful to include the spec name in the error message here.
It might be more helpful to include the spec name in the error message for debugging purposes.
Not related to this PR but FWIW we are trying to get rid of this "hasTabs". It is possible to use the adapter directly.
Not related to this PR but FWIW we are trying to get rid of this "hasTabs". It is possible to use the adapter directly from the list directly.
Not related to this PR but FWIW we are trying to get rid of this "hasTabs". It is possible to use the adapter directly from the tab list, as the only tab is available in the NavTabView
Type is not a number so the expected value can be removed.
Braces are misleading in this case.
Type is not a number so the expected value can be retrieved without a actual value.
You may want to use ObjectUtils for this null check.
You may want to use ObjectUtils for the null check.
Use ObjectUtils for the null check.
This is a little clunky to me. It might be better to explicitly close the data if the protocol is in the parcelable or in the other cases.
This is a little clunky to me. It might be better to explicitly close the data if the protocol is in the same file or in some way.
This is a little clunky to me. It might be better to explicitly close the data if the protocol is in the same file or in some other way.
Won't this fail if there are no events?
Won't this fail if there are other caches that are using?
Won't this fail if there's another test running in parallel?
"consider changing the plugin filename"
"consider changing the plugin filename", or use "consider changing the plugin filename"
"consider changing the plugin filename", or " instead of "
suggestion filterCLabel.true;
note that it doesn't work anymore
yep
I don't think this should be the responsibility of the user to set the Hibernate address. This will make all queries related to the Hibernate settings stored in the environment. We should set the entity to the user instead.
I don't think this should be the responsibility of the user to set the Hibernate address. This will make all queries related to the Hibernate settings stored in the environment. We should set the entity to the Hibernate configuration. Recommend creating the entity/cluster config and re-use it.
I don't think this should be the responsibility of the user to set the Hibernate address. This will make all queries related to the Hibernate settings stored in the environment. We should set the account to the Hibernate settings to make sure that the result is the same as the user.
expected is always first.
assert on the resulting file too?
assert on the resulting file deletions
Think @sandeepSamudrala mentioned in the another pull request. Should be protected if all types are defined as public.
Think @sandeepSamudrala mentioned in the another pull request. Should extension name be html instead?
Think @sandeepSamudrala mentioned in the another pull request. Should be protected if all types are defined as public
What is the purpose of this line?
What about creating a constant for this line?
What about creating a constant for this line? There is no need for it
is calling removeClientListener thread safe?
is there a reason why is this synchronized?
is removeClientListener thread safe?
fix formatting
fix the id
fix fix
result will be null. add a blank line before if.
result will be null. add to avoid NPE at line 134.
result will be null. add a blank line before the if.
Please use a distinctMark, it makes for "TestMethodExecutor".
Now that we have a custom executor, I'm not sure we should be using the @Inject in general. Please use the private executors.
Please use a distinctMark
Does this need to be final?
Does this need to be a mock?
Does this need to be created KafkaConsumer?
I think this is dependent on org.eclipse.e4.core.java.io.PluginModule.java. It will be easier to read.
I think this is dependent on org.eclipse.e4.core.java.io.PluginModule.java. It will be easier to test.
I think this is dependent on org.eclipse.e4.core.java.io.PluginModuleModule.java. It will be easier to read.
If the fs is not set, should this be hdfs-site.xml?
If the file system is not set, should this be syshdfs.xml?
If the file system is not set, should this be syshdfs?
I think we should avoid this type casting (let's say List<T> toYielder( YieldingAccumulator, Yielder<T>).
I think we should avoid this type casting (let's say List<T> toYielder( YieldingAccumulator, Yielder<OutType>).
I think we should avoid this type casting if we have nested @Yielder(?
Is there a reason to use StampLReq here?
Is it worth BigDecimal part to use writeInt()?
Is it worth BigDecimal part to use writeInt instead of 0L?
nit: I think we should start the new term within condition to make code more readable.
nit: I think we still need to check if a new property is set
nit: I think we should start the new term even if no property is available.
zoneDate.setEnabled(Instant.now()) may be better here.
zoneDate.DATE_FORMAT = Utils.DATE_FORMAT;
Seems like zoneDate could be null here?
IOException is never thrown in this method
lock is not needed
IOException is never thrown in the constructor
use the method that sets the status to true
Is this condition different than the one || || || || || || || ||
use isNotBlank method
This line is not good. If we want to use the Awaitility for the retry policy, we should probably create a new configuration that takes a Context to get the configuration from getRequiredContext(siteName, null) and then put the wiki here.
This line is not good. If we want to use the Awaitility for the retry policy, we should probably create a new configuration that takes a Context as a parameter.
This line is not good. If we want to use the Awaitility for the retry policy, we should probably create a new configuration that takes a Context as a parameter and returns a boolean.
don't you need to synchronized?
Can be synchronized.
don't you need to synchronized?
put all parameters on one line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
put arguments on the same line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
put all parameters on one line
This could be simplified to: java ColumnCombination b = new ColumnCombination(b); columnCombination.set(0);
This could be simplified to: java ColumnCombination b = new ColumnCombination(b); b).set(0);
This could be simplified to: java ColumnCombination b = new ColumnCombination(b); b).setNot(b);
It doesn't really matter but this will return null if there is no location. What about just the last part of the list (ex.getMessage())?
It doesn't really matter but this will return null if there is no location. What about just the last part of the list (ex.get().equals(2));
Might need to change this to a specific exception like RuntimeException. Or just get rid of the RuntimeException that throws the last one.
Do we have a use case for this person being null here?
Do we have a use case for person being null here?
Do we have a use case for person being voided?
I think you should wrap the original exception to the log.
I know you're just copying here, but I think it is worthless to preserve the original code.
I know you're just copying here, but I think you should wrap the original exception to the log.
Shouldn't we close the socket here?
Shouldn't we close the socket, it will be closed in the finally block?
Shouldn't we close the socket, otherwise it will be closed twice?
method name no longer correct.
method name no longer correct. lets use ":" as it will be more readable.
method name no longer correct. lets use ":" as it won't be null
[optional] Could we please use more descriptive variable name?
[optional] Could we please move this to separate line?
[optional] Could we please use for loop instead of nested if?
This seems like a static member of this class, why not use something more stable (like RawByteSequence)?
This seems like a static member of this class, why not use something more stable (like RawByteSequence)? Is there any advantage of using that?
This seems like a static member of this class, why not use something more stable like the text. If you're using something more often than the constant, like 0.01.
minor: use MockStorageManagerTestUtils.assertInNewTransaction
minor: add a metric for the metrics -> testDataAccessor.
minor: use MockStorageManagerTestUtils.assertInNew()
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.
1. i don't think this can be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and might cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.
This is fine, but for future reference there is also a MyService constructor. It is used to be modifiable, but for future reference.
This is fine, but for future reference there is also a MyService.class. It is used to be modifiable, but for future reference.
This is fine, but for future reference there is also a MyService constructor. It is used to be modifiable, but for future reference there is also a reference to the Entity.MyService2 class, which is called when the server is created by the target.
Add a "break" statement here.
Add a "this" keyword here.
Add "this" keyword here.
I think we can remove the else since we log the exception twice.
I think we should hide the original exception in the constructor. This can be a separate PR, since it is the one who cares about the metadata?
I think we should hide the original exception in the constructor. This can be a little bit debug since we are doing the lookup twice.
Alternatively, you could use bitwise OR.
It may be worth using bitwise OR.
Use map.put instead
Should this be int?
I think we need to add an IllegalArgumentException for this in all cases.
int
You can just use world.getNotifier().map(World::getCauseStack) here.
You can just use world.getNotifier().addContext(event.getCauseStackManager().getWorld world());.
You can just use world.getNotifier().addContext(event.getCauseStackManager().getWorld world()).
This can really be an example of what's happening here.
This can really be an example of what's happening.
This can really throw an exception.
RingbufferContainer.isStaleSequence(long sequence) We can then reuse this logic in the operations and in RingbufferContainer#checkBlockableReadSequence. Otherwise, I always get confused when checking the sequence - should I check the tail or the head, can it be equal to the head or strictly less and so on and so on.
RingbufferContainer.isStaleSequence(long sequence) We can do this directly in the loop itself, can it be equal to the head or strictly less and so on and so on.
RingbufferContainer.isStaleSequence(long sequence) We can then reuse this logic in the operations and in RingbufferContainer#checkBlockableReadSequence.
Same as above - no need to check if savedInstanceState is not null - just trying to get it.
Same as above - no need to check if savedInstanceState is null - just trying to get it.
Same as above - no need to check if savedInstanceState is not null check
Please create a Logger and use it here.
Please use parameterized logging.
Please create a Logger and use a logger here.
Could you at least use a logger instead of System.out?
Could you improve this message? There are some kind of failure cases in this case.
Could you improve this message?
Is it possible to break the log statement after "if (logFragment!= null)" check?
Is it possible to break the log message to a local variable?
Is it possible to break the log statement after "if (logFragment!= null)".
Missed it at the beginning of the method and throw exception.
Missed it at the beginning of the method.
Missed this one - it's really a bad idea to swallow exceptions.
Can you use a iterator of the items and not a collection?
Can you use a iterator of parent and not a collection?
Can you use a iterator?
Transaction is opened the fun begins
Transaction is opened the fun begins. Why right?
Transaction was opened the fun begins
I think that getTopic() should return a boolean
I think that getTopic() will create a string (that is) without exception should be used
I think that getTopic() will create a new RangeException when you give it a chance
The following two statements can be extracted to a method with a proper name: scopes.stream().anyMatch(symbol -> Type.VARIABLE).filter(symbol ->!symbol.equals(symbol.getType())).forEach(symbol -> { Scope currentScope = scopes.stream().filter(symbol ->!symbol.equals(symbol.usages())).map(Token::scope).collect(Collectors.toList()); }
The following two statements can be extracted to a method with a proper name: scopes.stream().anyMatch(symbol -> Type.VARIABLE).filter(symbol ->!symbol.equals(symbol.getType())).forEach(symbol -> { Scope currentScope = scopes.stream().filter(symbol ->!symbol.equals(symbol.usages())).map(Token::scope).collect(Collectors.toList()); });
The following two statements can be extracted to a method with a proper name: scopes.stream().anyMatch(symbol -> Type.VARIABLE).filter(symbol ->!symbol.equals(symbol.getType())).forEach(symbol -> { Scope currentScope = scopes.stream().filter(symbol ->!symbol.equals(symbol.usages())).map(Token::scope).collect(Collectors.toList());
If we have the _table_ data point at init time, we will not need this cast.
Need space after.
Do we need to retry?
The name of the variable is not necessary.
The same here.
The same as above.
It seems possible for us to create a new map of 1s, but we won't allow this map to be empty. I think the following is better: if (opType == null || opType.isEmpty()) { builder.withCurrentFateMetricValues(opType); } if (v == null) { builder.withCurrentFateMetricValues(opType); } } return builder.withCurrentFateMetricValues(false);
It seems possible for us to create a new map of 1s, but we won't allow this map to be empty. I think the following is better: if (opType == null || opType.isEmpty()) { builder.withCurrentFateMetricValues(opType); } if (v == null) { builder.withCurrentFateMetricValues(opType); }
It seems possible for us to create a new map of 1s, but we won't allow this map more than once.
I think it would be better to use exact comparison for these two cases (if possible) > startAt < endDuration> now etc.
I think it would be better to use exact comparison for these two cases (if possible) > startAt < endDuration.ttpURLConnection.R
I think it would be better to use exact comparison for these two cases (if possible) > startAt < endSeconds
There is a login strategy in this method. So I don't think it's necessary to add these parameters to an extra param?
There is a login strategy in this method. So I don't think it's necessary to add these params to an extra param?
There is a login strategy in this method. So I don't think it's necessary to add these parameters to an extra param.
command.getAffectedKeys() can be replaced with cast to ctx.hasAnyFlag()
command.hasAnyFlag(ctx, command, null); should be enough.
command.getAffectedKeys() can be replaced with cast to ctx.hasAnyFlag().
I would have put this into its own column. You only have 41 characters defined thus far on a line, and we usually have an 80 character wide terminal.
I would have put this into its own column. You only have 41 characters defined thus far on the line, and we usually have an 80 character wide terminal.
I would have put this into its own column. You only have 41 characters defined thus far on an 80 line, and we usually have an 80 character wide terminal.
In my opinion, we could simplify this if statement: java if (packageBinding == null) { packageBinding = packageBinding; } since packageBinding.getUniqueModules() is called many times.
In my opinion, we could simplify this if statement: java if (packageBinding.isDeclaredIn(packageBinding)) { packageBinding.add(packageName); } since packageBinding.isDeclaredIn(this); is also done below.
In my opinion, we could simplify this if statement: java if (packageBinding.isDeclaredIn(packageBinding)) { packageBinding.put(Package.of("packageName", packageBinding); } Otherwise it seems that packageBinding is not used anymore
We can probably extract the condition on its own line of the if clause above so it could be simplified: if (child.getFirstChild().equals(alias)) {
We need to check whether the namespace is a member-element.
We can probably extract the condition on its own line.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), true)).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
This can be replaced with assertThatThrownBy(() -> message.doLocalPut(partitionedRegion, mock(InternalDistributedMember.class), true)).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), true));.isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
This looks wrong <LINK_0>
Is there any way to split this into two lines, such as this.getName()
Is there any way to split this into two lines, rather than refactoring?
Makes sense to swap FLAG2 and FLAG3 since volatile functions are less common than the varargs ones.
This check has become too stringent since there is more room is available in firstBytes.
This check has become too stringent since there is more room is available.
validate paddingBlockSize int value?
validate padding block size == 0
validate padding block size == 0?
How about creating a new Doc here?
It's a little weird to have a Set here
How about one of the following: * Set<String> headers = new HashSet<>(context.request().headers()); * Set<String> sending the boolean to an ClientRequest 'do not have any effect' concept or not. * add another one for it
this try-catch block is redundant here.
This assertion should be removed, as part of setUp method was used in DiagramElementBuilder.
duplicate :D
Right, you sometimes use "this" when you add the string.
Right, you sometimes use the.valueOf() as your Booster will solve it.
Right, you forgot to add the.setText(new () {
you should return something like printStackTrace(); in the test and throw an exception if it fails.
I think you want to return here so that the test will be skipped if you go to the previous line
you should return something like printStackTrace(); in the test
please move this to the block.
move this to the block above.
move this to the block above where it is needed.
Does this need to be public?
Does this need to be public? I am not sure why this method should be synchronized.
Does this need to be public? I think it should be synchronized as well.
You need to check if (hwnd == null) && (hwnd == null)
You need to check if (hwnd == null) below.
Sorry that I missed this before.
new line
new line.
new line after =
Not a fan of the default, and via the getter, why not keep the setter setter inside setAbbreviated?
Not a fan of the default, and via a very Config here.
Not a fan of the default, and via the getter, why not keep the setter setter inside setAbbreviatedName?
is this good way to do this?
is it worth to check if Cues is not null here?
is this good way to fix it?
.toString() is just a formatting thing
no... this should be.toString()
you may consider to move this into a.xml method
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
If this array isn't meant to be modified aftewards, we can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
If this list isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
Is it possible for this to be null?
Is it required for us to use the size?
Is there a reason not to use CountDownLatch?
Minor: We could extract this part to a private method and use it in both places.
Minor: We could extract this part to a separate method.
Is it possible to extract this as a private method?
given that you create a SelectionListener/Handler at this line, I think it'd be better to re-create the dialog
extra blank line
externalize
Are you sure this is the right thing to put in a query? Or is there a query parameter for that?
Are you sure we should make this a job that runs on a fault? I didn't see it before.
Are you sure this is the right thing to put in a method?
I'm not sure this is the correct way to do this. The test should be like with a different RedisLock instance.
I'm not sure I like the name of the RedisLockRegistry and this test are exactly the same (they have to check the RedisLock instance and assert that the lock was acquired by another thread)
I'm not sure I like the name of the RedisLockRegistry and this test are exactly the same (they have to check the RedisLock instance and assert that the lock is equal to the same instance). Mentioning this logic has the advantage of making the test below easier.
Is it possible to move move to the beginning of this method, for example: if(cursor.getTopic()) {
Is it possible to move move to the beginning of this method, without any condition?
Is it possible to move move to the beginning of this method? This code is already in namespace.
should be outside the try block
not related to the try block
this should be outside the try block
Please add message entity here by describing the error.
Please add log message.
Please add message entity here as well.
I think you get the added value of 'path' here.
I think you get the Project.getUser() from the previous resource and this logic will return the old directory.
I think you get the Project.getUser() from the previous resource and this logic will return the old path of the new directory.
Can be rewritten using return filterResult!= null? filterResult.isFiltered() : new HashSet<FilterResult>()
return an empty collection instead of null?
Can be rewritten with a stream.
Can we return taskInfo here as well?
Can we return taskInfo.shutdownFuture immediately if the taskInfo is null?
Can we return taskInfo.shutdownFuture immediately if there's no task?
Minor thing, but could you extract a message fixed as something like "Consider casting must not be called for any string literal."
Minor thing, but could you extract a message fixed as something like "Consider casting must not be called for any string literal."?
Minor thing, but could you extract a message fixed as something like "Consider casting...?
Declare templateStream hear?
Declare templateStream hear
Declare template stream
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this useless assignment to local variable "identifier. [![rule](<LINK_2>](<LINK_0>
!className.equals(getClass())
rethrowing this as a try-with-resources is redundant here
Nit: We can use parameterized logging java LOG.info("Rewriting file because of purge operation {}", meta, Str.size());
Nit: We can use parameterized logging java LOG.info("Rewriting file because of purge operation {}", meta, filesToDelete);
Nit: We can do the full path read. writeFile(bucket, () -> delete(meta)).remove(); and avoid the full path.
Please use logger instead of printStackTrace()
Please use logger instead of e.printStackTrace()
Please use a logger instead of printStackTrace()
shouldn't we initialize this as blacklistPath?
why are we using the default constructor?
shouldn't we put "useIPFS" in constants?
Just a thought, this is no more correct?
You might want to throw the RuntimeException from the switch block
You might want to throw the RuntimeException
This line and the next one can be simplified to: if (!isNestedIfStatement(ast)) { return; }
This method is a little bit hard to read. The only thing you are using isNestedIfStatementTree, no need to make it public.
This method is a little bit hard to read. The only thing you are using isNestedIfStatementTree, no need to make it return true.
What is the reason behind this change?
In this case, you don't have to change the enum type, but instead create a new object type for STRING.
What is the reason for changing this?
Can we have the hashCode calculation back to the super call here?
Can we have the hashCode calculation back to the following? This was result.
Can we have the hashCode calculation back to the super class?
can we use stream api here?
can we use stream api here?
replicaIdsToReturn
I think we should move character '|' to a constant.
I think we can change cell.isEmpty() to isBlank()
I think we can change cell.isEmpty() to.isEmpty()
here you can call originalClass.get(originalClass) from the context.
here we always use the original classToTable, right?
here you can call originalClass.get(originalClass) from these two lines
We need to use thread.sleep here to make it configurable.
We need to use thread.sleep here to wait for the thread to finish
We need to use thread.sleep here to wait for a thread.
I think we need to collapse the types of JSONs into single JSON.
I think we need to collapse the attributes
Long term, I think we should be able to parse it.
Couldn't we use the same code as in org.apache.commons.lang.StringUtils.
Couldn't we use the same code as in org.jboss.as.util.StringUtils.
Couldn't we use the same code as above?
I don't think this should be done in the execute()
TableBucketConfigurationException should be thrown from execute().
I don't think this should be done in execute().
Is a plain "else" block also needed here to at least log the cases where no PaymentWorks processing is needed?
Is a plain "else" block also needed here to at least log the cases where no PaymentWorks processing is done?
Why do we need a special case for no PaymentWorks?
personally, I would find an if more readable here. Could also be changed later.
personally, I would find an if more readable here. Could also be changed later. suggestion if (isGroovyPresent(target)) {
personally, I would find an if more readable here. Could also be changed later. suggestion if (isGroovyPresent(...)) {
There is a separate method that does not need to be public.
@mbarbieri Let's not use the AtomicReference model since it's the only way to get the client.
@mbarbieri Let's not use the Exception from Spring logs, please remove them.
why don't you replace this with switch
why don't you replace this with a default locale?
why don't you replace this with a default Locale from the package?
ToStringBuilder?
To avoid looping over the streams, maybe better to use streams?
Why the double comma?
We should probably import PrimitiveType() here as well
We should probably import PrimitiveType() here too, since it is a really specific type.
We should probably import PrimitiveType(clazz) here too
Are we sure that this is a directory?
Are we sure we want the java.util.File here?
} else {
use getVmDeviceDao(), instead of VmHandler
shouldn't we check if vm is null here?
use getVmDeviceDao(), instead of VmHandler.
It would be nice to highlight the docs in the message.
It would be nice to highlight the docs how the message is feedback to users.
It would be nice to highlight the docs how the message is generated from the docs.
And if getTimeGraphViewer().getPreviousEventAction() is called in two places. Perhaps it's better to put it in a method and call it in manager.
And if getTimeGraphViewer().getPreviousEventAction() is called in two places. Perhaps it's better to put it in a private method and make it readable.
And if getTimeGraphViewer().getPreviousEventAction() is called in two places. Perhaps it's missing?
Hi @mbarbieri wdyt about renaming some additional constructors to something like: public final onViewCreated() { callback.setAccount(account, savedInstanceState); } and then in other callback method, since they are both the hacks in this callback and the other for loop.
Hi @mbarbieri wdyt about renaming some additional constructors to something like: public final onViewCreated() { callback.setAccount(account, savedInstanceState); } and then in other callback?
Hi @mbarbieri wdyt about renaming some additional constructors or utility methods for that?
Shouldn't this be get(message, extAntiCSRF);?
Shouldn't this be getCustomParameters()?
Shouldn't this be get(message, extAntiCSRF, session)?
The index is the column creation order, but the 'columns' parameter can be in any order.
The index is the column creation order, but the 'columns' parameter can not be in any order.
The return string array must be in the same order.
For consistency, I would prefer to throw exception here instead of returning null.
For consistency, I would throw Optional if metricKey > 0 and just do containsKey.
For consistency, I would throw Optional if metricKey > 0 and just add containsKey.
why not to use for.. in here?
why not to use here StepUtils.IS_PerformanceDataTypes((supportedPerformanceDataTypes)?
why not to use here StepUtils.IS_PerformanceDataTypes.size()?
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
![Codacy](<LINK_1> Issue found: [Method names should not contain underscores](<LINK_0>
![ ](<LINK_0>
name it to pollPeriodinMS.
name it PollTask
name it PollTask, and pollTimeMS
Can we change this to: Thread.currentThread().interrupt();
Could we change this to: Thread.currentThread().interrupt();
Can we change this to: "Binding {} are not supported by the handler"
should be reverted too
The other change is a bit too late in the hot path. It looks like this should be reverted too
should be forEach
Would you mind to remove the double brackets (way....)? Also for the above statement
Would you mind to remove the double checking (way....)? Also for the above statement
Would you mind to remove the double brackets (way....)?
If you're going to get the event from a network request, can you move it to a separate thread?
If you're going to get the event from a network request, can you move it to a separate thread so it's block?
If you're going to get the event from a network request, can we move it to a separate thread so it's block?
If flush() returns 0, the index will be 0 when index = minTime.get(index).keytime; Is that correct?
This may cause an NPE if maxTime is 0.
Use equals to compare elements.
couldn't we just delete this file system path instead of logging it?
couldn't we just delete this file system path instead of logging all of them?
couldn't we just delete this file system path instead of logging all of the error?
I think we should be able to use Arrays.asList(...)
I don't think we need to ensure the file is not null here.
I don't think we should be able to use Arrays.asList(...)
Can you make this a separate method please? It's a lot cleaner as it currently stands
You should make a separate method. I'd deserve a separate one, this if block is a separate one.
You should make a separate method. I'd deserve a separate one.
What about extracting the networkUuid to a constant?
What about extracting the value to a constant?
What about extracting the networkUuid to a constant to avoid duplication?
Why was this change needed?
Why not move this into the constructor?
Why not move this into the loop?
This is not a good candidate for a simple while loop, it can be simplified to: if (prop == Value.ROLE &&!prop.equals(((Value)prop).name())
This is not a good candidate for a simple while loop, it can be simplified to: if (prop == Value.ROLE &&!prop.equals(((Value) prop).name())
This is not a good candidate for a simple while loop, it can be replaced with a call to this.prop = null
The fix here should be to format the code, and check for the result of the search
The fix here should be to format the code, and check for empty or null before passing the result.
The fix here should be to format the code, and check for empty or null before passing the sort.
so better to not use System.readOnly if the user didn't want to read both properties before and after that line
so better to not use System.readOnly if the user didn't want to read both data from here.
so better to not use System.currentTimeMillis() here as well
You can write the right hand side of writing a stream like: java int destedLinks = stackedLinks.values().stream().map(LinkAddress::getInterfaceName).collect(Collectors.toList());
You can write the right hand side of writing a stream like: java int destedLinks = stackedLinks.values().stream().map(LinkAddress::getInterfaceName).forEach(Objects::nonNull);
You can write the right hand side of writing a stream like: java int destedLinks = stackedLinks.values().stream().map(LinkAddress::getInterfaceName).forEach(Objects::write);
please decrease to TRACE level
change to warn or trace
change to warn
Not 100% sure if the counter is greater than desired, but could you add a check for it and throw if it is greater than than silently?
nit: generated -> existing
nit: generated -> available
Please merge these "add" and "set" strings into constants
Please merge these "add" and "set" strings into constants.
Also add a space after popupText.
If possible, tests should not share any state between them as it may hide bugs. Why is this account related to the original situation?
If possible, tests should not share any state between them as it may hide bugs. Why is this account initialization running for any other tests?
Will this incur a whole bunch of places?
@inverno rename 'element'
I would rename element to identifierTree to make it clear that identifier is a function, not a symbol.
I would rename element to identifierTree to make it clear that identifier is a special
Here we should use equals instead of ==.
Here we should use Objects.equals
Here we should use equals()
nit: no need to create Map here
nit: no need to have this check outside of the loop
nit: no need to have this check within the loop
stdout
System.out
I think System.out is unnecessary, just for a test case.
Please use GroupsManagerImpl.isDirectGroupMember() which is currently present only on Mac type.
Maybe you should use GroupsManagerImpl.isDirectGroupMember() which is currently present only on group type.
Maybe you should use GroupsManagerImpl.isDirectGroupMember() which is currently present only on group initialization.
Arrays.toString() is probably better than just print the stack trace, since it won't be visible as a string.
Arrays.toString() is probably better than just print the stack trace, since this method is not there?
Arrays.toString() is varargs
nit: rename these map to childNode: map
nit: rename these map to childNodes
nit: rename these local variables
rename to simple
rename as simple
rename to simpleTypes
This DateFormat object never changes. Maybe make it static final in the method?
This DateFormat object never changes. Maybe make it static final in the class scope?
This DateFormat object never changes. Maybe do the same here?
@o-alex can we replace this with LOG.info("Failed invoking the read metrics {}", e.getMessage());?
@kouzant Just use LOG.warn("Failed invoking method '{}' in dfsclient {}", e.getMessage(), e);
@kouzant Just use StringUtils.EMPTY
Rename to CACHE_KEYS_RANGE
Rename to CACHE_KEYS_RANGE;
should we rename this to CACHE_KEYS_RANGE
Typo: repository -> NFC
Typo: repository isExpired
Typo: repository
These ERROR messages should be DEBUG DEBUG or TRACE log
These ERROR messages should be DEBUG level
These should be warn
You should be able to replace the "rpcManager.getFineGrainedAtomicMap().
You should be able to replace all this with org.junit.Assert.assertEquals.
You should be able to do.collect(Collectors.toSet())
Origin.MONITORING should not be removed since we don't have Origin.MONITORING any more
Origin.MONITORING should not be removed since calling Origin#getAgentName will throw an exception if the value is not set. But it is not obvious.
Origin.MONITORING should not be removed since calling Origin#getAgentName will return null. You don't have to check if Origin.MONITORING any more
Missed spaces before and after "="
Missed spaces before and after = operator
Missed spaces before and after "=".
Shouldn't we use new File(repo) here?
Do we still need the repo anymore?
Do we still need the repo?
I think this name should be "advanced". Perhaps "advancedMsg"?
I think this name should be "advanced to render". Where it is used?
I think this name should start with a capital
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.toList());?
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.toList())
Can be replaced with: hosts.getVds().getHostName()
Why is this line needed?
Why is this check needed?
Why is this condition needed?
Use try with resources
Use a try with resources
Use try with resource
Spe
this will raise an exception if the file doesn't exist. Use log.error
this will raise an exception if the file doesn't exist. Use log.error here.
bigtable-hbase.hbase.hbase.hbase.version
bigtable-hbase.hbase.hbase.version
bigtable-hbase.hbase.hbase.hbase.hbase.version
name.toLowerCase()
name.endsWith(".jar")
use toLowerCase()
File
File has a directory with more than one element. Use the repository name here instead.
unnecessary blank line
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
The setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplusplus
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw a NullPointerException. So we need to add a check here.
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw an exception. So we need to add a check here.
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will return null. So we need to add a check here.
I'm not sure how this is working, but I wonder if it's better to create a method that gets the name and print it, instead of the entire file by the caller?
I'm not sure how this is working, but I wonder if it's better to create a method that gets the name and print it, instead of the entire file, that is more reliable.
I'm not sure how this is working, but I wonder if it's better to create a method that gets the name and print it, instead of the model?
Looks like we don't need a loop here.
Looks like we don't need a loop
Looks like we need a loop
A Sqlkind is not needed for parens, since unparseCall()+1] will be on a different line than the same problem.
A Sqlkind is not needed for parens, since unparseCall()+1] will be on the same line
A Sqlkind is not needed for parens, since unparseCall()+1] will be on a different line than the one above it will still return null if unparseCall is not there.
Here's the source source?
return
otherwise return
This should be otherTumorType.mainType.
This should be otherTumorType.mainType
This should be otherTumorType.mainType || this.mainType.
If partitionLeader is null, than requestPolicy is not Bolt. Why is it needed?
If partitionLeader is null, than requestPolicy is not an error.
If partitionLeader is null, than request runner.
space and else if
space after if
space and else if statements
I think this can be shortened to: if (color!= null) { return ((String) value).toUpperCase(); } else if (value instanceof Integer) { return ((String) value).matches(); }
I think this can be shortened to: if (color!= null) { return ((String) value).toUpperCase(); } else if (value instanceof Integer) { return ((String) value).longValue(); }
I think this can be changed to switch (value.toUpperCase()) {.
while (!isInitialized) should probably be in populator
while (!isInitialized)... should probably chain instead of total if
simplify to isInitialized()
the return value is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
the return value needs to be void. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
the return value is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, and there is no mapping to a handler.
Should be visible in the custom action bar.
Should be visible in the custom interface?
Should be visible in the custom action bar, maybe?
I don't think this is a good idea, but we should be using a default user ext_ext_sources_id and by the user ext_ext_source (which is the same as with login and is the same as VON_sources_id of the same user). Also in order to remove user_id from user_id and VO_SourceMappingSelectQuery, it should be a part of this interface and not a specific implementation.
I don't think this is a good idea, but we should be using a default user ext_ext_sources_id and by the user ext_ext_source (which is the same as with login and is the same as VON_sources_id of the same user). Also in order to remove user_id from user_id and VO_SourceMappingSelectQuery, it should be the same as with "factory.user_id".
I don't think this else is needed because this specific implementation does not handle this behaviour.
I think it's worth improving this method so that it will work without additional null check
Unnecessary empty line
Unnecessary null check
suggestion child.onNext(n);
suggestion child.onNext(T t);
suggestion child.onNext(T t).onCompleted());
Does this English need to be formatted as well?
Does this not need to be null at this point?
Does this not need to be null-check for radioting?
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Long, Long> subKeyRangeList = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.computeIfAbsent(blockId, Long.valueOf(blockId)); subKeyRangeList.add(subKeyRange); });
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Long, Long> subKeyRangeList = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.computeIfAbsent(blockId, Long.valueOf(blockId)); subKeyRangeList.add(subKeyRange); }); } );
Maybe it'd be easier to read if we use stream here as well
Use same same as the method above.
Use another method this.
Use another method this catch block for other exceptions.
Use ConfigurationException or custom exception.
Use ConfigurationException or custom exception
Use ConfigurationException instead of IOException here
@tsweisebrazil rename that test method name
@tsrishabh-997 use static constant to avoid magic numbers
why?
It would be nice if we could skip that when statistics are not enabled. System.nanoTime() adds some overhead.
It would be nice if we could skip that when statistics are not enabled. System.nanoTime() adds some overhead. System.nanoTime() adds some overhead.
It would be nice if we could skip that when statistics.queryPlanCacheHit is not null
@rishabh-997 I'd move the logic here in a similar way.
@rishabh-997 I'd move the the storagePool check here before the the volume is retrieved.
@rishabh-997 I'd move the the storagePool check into the the method
I don't think this is the best way to handle exceptions. If you think this needs to be used in the s3 example, it will make sense to have a dedicated logAndThrow() method in S3Bucket, and have S3Bucket handle the exception.
I don't think this is the best way to handle exceptions. If you think this needs to be used in the s3 example, it will make sense to have a dedicated file for it.
I don't think this is the best way to throw exceptions. If we ever add the s3 bucket to the exception message, we'll have a dedicated exception for a specific message.
Why do we need a filter here? Is it used by the filters part?
Why do we need two filters here?
Why do we need two filters here? Shouldn't we only have one?
This method should be private.
This method should be called only once.
Looks like we're going to validate all the time to create the new host.
Could you please elaborate on this condition - it seems a bit suspicious -> it seems like we perform "unfollow" action after the user clicks on follow when it's a feed
Could you please elaborate on this condition - it seems a bit suspicious -> it seems like we perform "unfollow" action after the user clicks on follow when it's a feed.
It would be better if we handle the case where it's a user error.
I don't think we need this extra variable.
I don't see why we need this extra variable.
Please use lambda style.
This text is not good for this use case.
This can be moved to the block above the try block
This text is not good for this use case. It might be better to add a static method
While interesting, it does a lot of unnecessary code, maybe we should define a common parent method (e.g. ChkRPC / ChkRPC) and then do a null check here.
While interesting, it does a lot of unnecessary code, maybe we should define a common parent method (e.g. ChkRPC / ChkRPC) and then set the scheduler to false (bug)
While interesting, it does a lot of unnecessary code, maybe we should define a common parent method (e.g. ChkRPC / ChkRPC) and then do a null check instead of duplicating the items?
this check should be done in the while loop and return immediately.
this check should be done in the while loop and return directly.
this should be Iterator<Integer>
Style-nit: We don't use braces around single line blocks.
Nit: you can do this filtering before on the result.
Style-nit: We don't use braces around single line blocks
This is going to be hidden by a warn, since it can be hard to identify which operator was processed and there's no reason to include it in the log.warn.
This is going to be hidden by a warn, since it can be hard to identify which operator was processed and there's no reason to include it here.
This is going to be hidden by a warn, since it can be hard to identify the operator that this is running and if it is null, it should be caught and logged.
No string concatenation here, please.
No need for Version.valueOf() here.
No need for Version.valueOf(packageInfo).
Do we need to use brackets here?
Do we need a guard here for non-empty private methods?
Do we need a guard here for non-empty set operations?
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to system time. These have been a performance issue in the past.
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to update() in pollForFetches(). > If an existing connection is made and the new data is not updated, the read() call would still be called. Is that ok?
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to update() in pollForFetches().
suggestion final long requestText = this.getRequestTime();
suggestion long requestText = this.getRequestTime();
suggestion if (jsonRequest.get()) {
We should have some kind of utility to do this for the wait. This is the super class that is responsible for handling it.
We should have a better name for this method. This way it is done consistently with the other SDKs calling it themselves.
UncheckedIOException?
Better to throw an IllegalArgumentException or add a proper message.
Better to throw an IllegalArgumentException or exception.
Better to use 'id' instead of 'id'
The original code is returning the target filename when the cluster is not found.
The target file extension is added to the target directory,..
The target file extension is added to the target directory,...
Remove this.
Remove ERROR.
Remove this ERROR
i don't think this is correctly formatted when file is not receive
i don't get what this method does and how this is supposed to be used
i don't think this is correctly formatted when fileData source is null
Nit: magic numbers are not used, should this be extracted as a constant?
Nit: magic numbers are not used, should this be extracted to a constant?
Nit: static import SECONDS
negotiated timeout. This just uses negotiated timeout.
negotiated timeout. This just uses negotiated timeout. But just makes it very little y.
negotiated timeout.
The RVVVVVVVVVR does not look to be changed.
This is an incorrect change.
This is an incorrect variant.
It's a bit confusing to have a set here. You could do it like this: java List<ASTName> subExpressions = expressions.findDescendantsOfType(ASTNamenode.get(node.getImage()).stream().filter(node ->!isCompileValid(node.getImage()).map(ASTName::get).collect(Collectors.toList());
It's a bit confusing to have a set here. You could do it using expressions.findDescendantsOfType(ASTNamenode.getImage()) instead
It's a bit confusing to have a set here. You could do it using expressions.findDescendantsOfType(ASTNamenode.get(nameNodes.size())
other.first == null is redundant.
Can be simplified to: return fst.first == null || other.first == null;
Can be simplified to: return fst.first == null || second == null;
reduce to debug
This might be better to define REFRESH
This line should be REFRESH
remove this and following our.println?
remove this and following our. library?
remove this and following our. library? It is compatible with java 8.
throws IOException goes into separate line
throws IOException goes into single line
throws IOException goes into separate line.
This test is not necessary, the main method still throws an exception if the output fails
This test is not necessary, the actual bug thrown in the test is supposed to be catched already.
This test is not necessary, the main method still throws an exception if the output is not filled.
I'm not a fan of build.writer(writer, settings) and concat. I know it's a code, but it doesn't matter much.
I'm not a fan of build.writer(writer, settings) and concat.
I'm not a fan of build.writer(writer, settings) and concat. I know it's a code, but it doesn't help to write.
I don't see where this is used.
I don't see why you are setting headers.entrySet().stream().forEach((Message) headers.entrySet().iterator())?
I don't see why you are setting headers.entrySet().stream().forEach()?
Can we use logger instead of System.out?
Can this be replaced with logger?
Can you please rename this variable?
I think we should also verify that the violation is still there, otherwise it's not a problem anymore.
I think we should also verify that the violation is still there, otherwise it's not a exact error message.
I think we should also verify that the violation is still there, otherwise we can't get the corresponding message.
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Not necessary. The web plugin should be bound in the Gerrit-HttpModule itself.
Not necessary.
Emm, do we really need a map here? The reason is that if the processorList is not null, it will throw an exception, right? And it is not really a bug, do you really want to do it?
Emm, do we really need a map here? The reason is that if the processorList is not null, it will throw an exception, right? And it is not really the case.
No need for the duplicate check.
should be k
should be k.warn
can be removed
Use the empty sequence constant. In the evaluate, just reset or clear the pointables variable.
Move the creation of the pointables object to the constructor. In the evaluate, just reset or clear it.
Use the empty sequence constant.
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each group as 'id' (id.getLastSegment().isPresent()) {...} else { throw SelectionContext.get(); }
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each group as 'id' (id.getLastSegment().isPresent()) {...} else { return 'id.getParent().get(); }
i think this logic works. Needs to be synchronized.
lower case "/question"
lower case "/projects"
also this else if
this one seems to be calculated as if there is no change
this one seems to be calculated as if there is no change...
this one seems to be incorrect - it's the default screen that is displayed when reading the red box.
I'm not sure this is the right use of the final variable here. This makes it hard to read. What do you think about changing the name to fileExists or vice versa?
I'm not sure this is the right use of the final variable here. This makes it hard to read. What do you think about changing the name of the fileExists to java java boolean fileExists = PlayableUtils.createInstanceFromPreferences(activity, media.getContentResolver(), media);
I'm not sure this is the right use of the final variable here. This makes it hard to read. What do you think?
You can use SWT.DEFAULT and not "Bidi".
You can use SWT.DEFAULT and not "Bidi". Maybe we could just use something like that?
You can use SWT.DEFAULT and not "Info"
This is what the network network network network is already being used. Either we need to check the network network network network network network and if it is null, we can create the networkNodeListAndNetworkNodeInfo to return the network network and avoid null checks.
This code is duplicated from the the get() method. Either it will be extracted to a local variable
This code is duplicated from the the get() method. Either it will be extracted to a new method or we need to update the retrieveNetworkStatementsDTOList()
@bxf12315 @efgef Please move this to a constant
@bxf12315 @efgef Please use Objects.equals()
@pynicolas why not inline variable?
see org.junit.util.Test
As written in the previous PR, why contains magic numbers?
readRefOpcodes.next()
Again, better to add assertTrue(m.get()).
Again, please add the Assert.assertNull(...).
Again, better to add assertTrue or assertEquals.
Let's check for null as well
Let's check for null as well.
Let's check for null as well, i.e. on it
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.getUploadedUrl can be null or empty.
I wonder if we should place Config.getUploadedUrl() in the method somewhere, so that we can assume it is always the single argument.
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level.
"*** Error occurred while trying to extract plugin"
"*** Error occurred while trying to extract this plugin"
"*** Error occurred while trying to extract "
Should this be a global, instead of timeToFirstFrame()?
Needs a get on the same line
Should this be a global, instead of timeToFirstFrameNs
You can replace with: getStoragePool().setEntity(dataCenter).getConstants().setEntity(dataCenter).updateDataCenter().setSelectedItem(null);
You can replace with: getStoragePool().setEntity(dataCenter).setManagementMode(dataCenter).getConstants().setEntity(dataCenter().getType())
You can replace with: getStoragePool().setEntity(dataCenter).setManagementMode(dataCenter().getConstants().getSelectedItem());
consider to have the storage pool id as a constant (and having it as a whole class)
consider to have the storage pool id as a constant (maybe even in a ctor)
consider to have the storage pool id as a constant (maybe even in the HostMap.class)
This should be static.
This should be static. This should be part of the same change object creation.
This can be static.
could you add an if (noExtraOutput!= null) check?
could you add an if (noExtraOutput == null) to avoid possible NPE?
could you add an if (noExtraOutput == null) to the string, at least > stdout
These two lines should come before the if. (Remove in the other branch.)
This does the same, but is somewhat easier on the eyes: text.equalsIgnoreCase(values())
These two lines should come after the if. (Remove in the other branch.)
How about an MultiResult<Class<?>> and not a MultiQuery<Class<?>>?
How about an MultiQuery<Class<?>> and not a multi-map?
How about an MultiQuery<Class<?>> and not a multi-entity?
//NON-NLS-1
// You need to specify the stack trace
so you need to specify the stack trace
Why is this cast needed?
Why is this cast needed?
Why is this check necessary?
Suggested the aggregator.getOutputName() to be consistent with other aggregators
Suggested the aggregator.getOutputName() to be consistent with other names?
Suggested the aggregators
@TShapinsky nice find! Store the retrieved view within an instance field instead. it should be available as soon as onViewCreated is called.
@TShapinsky nice find! Store the retrieved view within an instance field instead. it should be available as soon as onViewCreated() method.
@TShapinsky nice find! Store the retrieved view within an instance variable instead. it should be available as soon as onViewCreated is called.
The problem with this call is that as child.isWildcard() already returns a boolean. So if you remove this directly from the loop you can use context.get()
The problem with this call is that as child.isWildcard() already returns a boolean. So if you remove this directly from the loop you can use context.get().
The problem with this call is that as child.isWildcard() already returns a boolean. So if you remove this directly from the loop you can use context.get() in.
Does this need to be in an else block? (for example if I understand correctly)
Does this need to be in an else block? (for example, it doesn't fail)
Does this need to be in an else block? (for example, it doesn't look to me)
We shouldn't need to check event.post here.
We need to check event.post!= null before calling event.post.get().
We need to check event.post!= null before calling event.post.getLifecycle().
[minor] There are a few more places, try to do this on the same line.
[minor] There are a few more cases where [get(name)](<LINK_0> Consider using "get(name)" method to do the logic.
[minor] There are a few more cases where [get(name)](<LINK_0> Consider using "get(name)" method.
This seems to be a bit hard to follow. Can you please update the code to use the same indentation for the rest of the file?
This seems to be a copy of the same array; so it would be better to make it a member variable.
This seems to be a bit hard to follow. Can you elaborate? It's not obvious from the logic in this class.
The message could be more explicit, something like 'invalidPanel'.
The message could be more explicit.
The tab style used here is strange.
This isn't a bit confusing, look at the command line output. We should look into it a bit more like a TopologyUtils class.
This isn't a bit confusing, look at the command line arguments. Why both?
This should be a LOG.error
No need to create a new List, just call "contains".
No need to create a new object on each iteration, just update its internal value as key.
No need to create a new object on each iteration, just update its internal value as well.
This looks like it should be a static method.
This looks like a bug. Should it be logged in the client? If this is not, it should be logged out in the client.
This looks like a bug. Should it be logged in the caller?
why not first run the network status and then check whether it is enabled?
why not first run the network status and then check if it is set?
why is it necessary to run the command if it is null?
This technically isn't needed since it will be invoked by default in getLong anyway
what happens when can it be null?
This technically isn't needed since it will be called by default in the future.
Why do you need to reset the interrupt state? Wouldn't be easier if you call Thread.currentThread().interrupt() instead?
Why do you need to reset the interrupt flag? Wouldn't be easier to just call run() on the thread pool?
Why do you need to reset the interrupt flag? Wouldn't be easier to just call run() on the thread context?
Refactor found(...); and remove the for loop
Refactor found(...); and remove the if/else block.
Refactor found(...); and remove the if/else block: } else {... }
I am pretty sure that you have assertNotNull() on the list. Normally you use the message when you use the argument.
I am pretty sure you have assertNotNull() on the list. Normally you use the message when you use the argument.
I am pretty sure you have assertNotNull() on the list. Normally you use the diamond operator here.
we should use msg / default (name) instead of v <=
we should use msg / default (name) instead of v <= 0.
we should use msg / default (value for these cases)
What happens if there's a race between scheduleExecution and executeExecution?
What happens if there's a race between scheduleExecution and execute?
What happens if there's a race between scheduleExecution and executeExecutionException?
shouldn't you check audioURI!= null here?
Doesn't handle audioURIs also for audioURIs?
Doesn't handle audioURIs also for audioURI?
Should we change the naming from above to something like **note**?
maybe we can use the same naming for the methods of the used above.
maybe we can use the same naming for the methods of the above method, instead of adding them to the filters file
nit: extract a private method that we can use in this class
nit: extract a private method that we can use in these two places,
nit: extract a private method that we can use in these two places, right?
The capabilities.add(new ReferenceCount(Application_A_Params.ON)) should be a set of capabilities to it.
The capabilities.add(new ReferenceCount(Application_AuluL)); should be moved to capabilities.add(new Rating());
The capabilities.add(new ReferenceCount(Application_AuluL)); should be moved to capabilities.add( capabilities.get(0).getMute_VERSION());
@xupyprmv inline this one as well
@ivandalbosco why not just.up()?
@xupyprmv inline this one
when it is false, it's not a true/false. Please put it back.
Is it possible to extract this to a method? If not, it will be more readable
Is it possible to extract this to a method? If not, it will be more readable.
Put the "id" in a local variable to make it really readable.
Put the "id" in a local variable to make it more readable.
missing braces
So the.collect line should be removed? I thought we didn't move the commit, but we might want to keep this in the future.
So the.collect line should be removed? I thought we didn't move the commit, but we might want to keep the commit baseline for acceptance.
So the.collect line should be removed? I thought we didn't move the commit, but we might want to keep the commit baseline for acceptance as well.
style nit: no braces around single line blocks
style nit: you could use listener.test() instead of mIncludeFilters.contains(testName)
You could also use mIncludeFilters.isEmpty() here, which would simplify the code.
Can we pull this out into a isGoodPath helper method or something?
Can we pull this out into a isGoodPath helper function or something?
Can this file be reused?
@yingsu00 remove this.
@kachayev this is not correct. I'll explain why you remove this.
@kachayev this is not correct. I'll remove this.
Can we make this method static and call it from here?
Can we make this anonymous class a constant?
Can we define a constant for the cameraState?
This should be a constant
we should probably return a constant
we should probably log the individualUserAgents
"assert false" will always fail. I'm not sure why we are putting a message here. Better to make a message more explicit.
"assert false" will always fail. I'm not sure why we are putting a message here. Better to just make a message more explicit.
"assert false" will always fail. I'm not sure why we are putting a message here. Better to just have a message in the assertion, with a message that clearly explains the problem.
@pynicolas Too many "or" :)
@pynicolas this loop looks over-complicated. Let's remove it
@pynicolas Too many "if" here :)
Needs defaults
Let's use this pattern for readability java variable = conditional? passed_conditional : failed_conditional
Needs defaults.
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to retry for some time if they can.
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
Does this work for all cases?
Does this make sense?
Does this code make sense?
Can you use try-with-resources here?
Can you use try-with-resources for this?
Can you use File.pathSeparator so this works on Windows?
Let's remove the "OpenGLUtils."
Let's remove the two lines above this. They're not used.
Let's remove the two lines above this. They will not be in one line.
This will spam like crazy, but maybe it would be better to log at debug instead of info so that we can give the full exception.
This will spam like crazy. How about the next sentence instead?
This will spam like crazy. How about the next new line?
We can get rid of this if/else branch, the I think.
We can get rid of this if/else, I think it would be better to use the method reference.
We can get rid of this if/else, I think it would be good to use the method reference.
I'm not sure about this change. Should this be a SEVERE error?
I'm not sure about this log message. I get the chance to identify the issue being fixed in this PR, but how about a separate JIRA/ patchset.
I'm not sure about this log message. I get the chance to identify the issue being fixed in this PR, but how about changing the log message a bit more user-friendly.
I see some work in this PR, but I'd suggest to avoid any kind of printouts if the code is not trace or debug.
I see some work in this PR, but I'd suggest to avoid any kind of printouts if the code is not trace or debug if it is expected.
I see some work in this PR, but I'd suggest to avoid any kind of printouts if that is necessary (e.g. output it?)
Use getPermanentOrLKI if only one player can be null.
Use getPermanentOrLKI if only one of them failed.
Use getPermanentOrLKI if only one player can be null
shouldn't this be true?
shouldn't this be line above?
shouldn't this be line above it?
command.getAdminAccess() might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
response.getAdminAccess() might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
command.getAdminAccess() will always return false here since it's the sole use of this variable and it wasn't any less readable before.
Can you please use a more meaningful variable name? Current is a hot test.
Can you use a more meaningful variable name? Please change the method name to something like getOrCreateCache
Can you use a more meaningful variable name? Please change the method name
please use configuration to have per version values (it will save doing the per-version checks)
please use configuration to have per version values (it will save doing the per version checks)
please use configuration to have per version values (it will save doing the per-version checks).
Please update this implementation.
Please update WHOLE_FILE_CONTEXT_CONTEXT_CONTEXT_KEY instead of the ListBox (and make a note on that).
Please update WHOLE_FILE_CONTEXT_CONTEXT_CONTEXT_KEY instead of WHOLE_FILE_CONTEXT.
is the reason for this?
I think that is the reason for this?
this is entire debugging statement.
Can we really don't have this on the output?
Can we really don't have this on a separate PR?
Can we really don't have this on a separate CL?
Yeah I'm surprised this is a getPublicAddresses. If so, this should probably be _privateHostname!= null.
Yeah I'm surprised that this is a getPublicAddresses. If so, this should probably be _privateHostname!= null.
Yeah I'm surprised this is a getPublicAddresses. If so, this should probably be pre-readed twice.
Redundant cast.
Style nit: Space before {
Style nit: Space before (
Just double checking: Was it intentional to go from 10K ms to 1K ms?
Just double checking: Was it intentional to go from 10K ms to 1K?
Just double checking: Was it intentional to go from 10K ms to 10K ms?
suggestion InputColumnPosition<Expression> generatedColumns = ImmutableMap.of();
suggestion InputColumnPosition<TableIdent> generatedColumns = ImmutableMap.of();
suggestion InputColumnPosition<ColumnIdent> generatedColumns = ImmutableMap.of();
Wondering what if there is an error in this case.
Wondering what if there is an enum for this one?
Wondering what if there is an enum for this parameter.
This should be } else {
This should be taken out as a callback
This should be taken out as a result of the operation
I'm wondering if it should be possible to refactor this PR into a separate PR, what do you think?
HibernateUtil.closeAndCommitTransaction();
I'm wondering if it should be possible to refactor this PR into a separate PR, what does the "backasset" variable mean?
Unused variable
We have to be careful with using System.currentTimeMillis() here. It may be better to use getBeansScopes.ERO here.
Unused variable?
We still need to set this value here, right?
We still need to set this value here
We still need to update this method name.
Coding style :(
this can be removed, since resource is not a member.
this can be removed, since resource is not a member of this resource.
Do you need to use the constants for this hard coded string?
Do you need to use the local variable for this URI?
Do you need to use the sub path here?
Doesn't this imply that this is true on the real updateMessageOnIccEf? If so, it might be safer to pass the TMS and throw an exception when it makes sense.
Doesn't this imply that this is true on the real updateMessageOnIccEf?
Get it from this variable and use it.
use CollectionUtils.isNotEmpty
use CollectionUtils.isEmpty
CollectionUtils.isNotEmpty
Why the returned list?
images -> list
Why the list?
The naming is a bit confusing. I'd suggest to put times(0) into a variable, to make it more readable.
The naming is a bit confusing. I'd suggest to put times(0) into a variable, to make it clear that the string is being set.
The naming is a bit confusing. I'd suggest to put it into a field.
Should use constant instead.
Should use constant.
Should use log instead.
Use ObjectUtils helper
needs space after if
Use ObjectUtils helper method
The code here was a bit complex and is probably necessary but if you don't want to do it this way (i.e., create a boolean property on the label and if you want to add it to the logging level)
The code here was a bit complex and is probably necessary but if you don't want to do it this way (i.e., create a boolean property on the label and if you want to add it to the logging level).
The code here was a bit complex and is probably necessary but if you don't want to do it this way (i.e., create a boolean property on the FormattedMessage)
We could rename the test method into executePredicate.
Maybe using String::format would be easier?
Maybe using String.format would be easier?
Why are we passing the construction into the constructor?
Why not public.
Why not public
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "now"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
I don't understand why request.getPassword() is used here, right?
Improve this request to login in the name
add locale to param
add locale to param syntax
add locale to param?
I think if (! is redundant
I think if (! is redundant) otherwise there is a return
I think if (!se.isEmpty()) {
Please use Set instead of ArrayList
Please use Set<DiskInterface> here.
Please use Collections.singleton instead of creating new HashSet
what about memory and network costs?
what about project.network cost?
what about project.network()?
I can see the code follows the previously defined expression but I guess we could simplify this with assertNotNull.
I can see the code follows the previously defined expression but you could simplify this with assertNotNull.
I can see the code follows the previously defined expression but we could simplify this with assertNotNull.
Wouldn't it be better to directly return the number of events in the array?
Wouldn't it be better to directly return the list in the private method, the save operation should be triggered?
Wouldn't it be better to directly return the list in the private method, the save operation?
This breaks the current implementation, but I'm not sure I like the idea of doing this. I think it should be in the SpanContext here. Then you won't need the MessageHandler (similar to e.g. SelfTrace)
This breaks the current implementation, but I'm not sure I like the idea of doing this. I think it should be in a synchronized block.
This breaks the current behavior, but I'm not sure I like the idea of doing the extra work in the ctor. I think the SpanKind should be created in the AbstractTraceContext itself, and passed as a parameter here.
This test will also fail if host is not a IPv6 address. Since a Mac is not a host address it should contain all address parts of the host....
This test will also fail if host is not a IPv6 address. Since a Mac is not a host address it should contain all address nodes, not just the address that is not a host address.
This test will also fail if host is not a IPv6 address. Since a Mac is not a host address it should contain all address parts of the host.
I'm not sure about this. Instead, we should modify the zoomLevel to oomlevel = Math.pow(Math.pow(getToolBar(), diffLevel).intValue();
I'm not sure about this. Instead, we should check whether zoomLevel is > oomlevel.
I'm not sure about this. Instead, we should check whether zoomLevel is < 0 or not.
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)?
assertTrue(queues.size(), "Expecting empty queues but was %s", queues)?
assertTrue(queues.isEmpty(), "Expecting empty list", queues)?
Its nitpickpick: you can use Iterables.empty() instead
Its nitpicky but in particular, you can use: assertThat(address1, is(2, is(node2)
Its nitpicky but in particular, you can use: assertThat(address1, is(node2)
Why is this as a separate method?
Why not use the empty JSONArray here?
Why not use assert?
Let's avoid this format and use slf4j placeholders instead. Also, when there are other arguments to format.
Please format this.
Please format this message using slf4j placeholders instead of concatenation.
Could you use.getMap() instead of.getMap() here?
looks like you are using 10 as a value.
looks like you are using 10 as a sleep here?
I wonder if it would be better to use Math.abs() here. And also check the result.
I wonder if it would be better to use Math.abs() here. And also check it would be better if we declare this method private.
I wonder if it would be better to use Math.abs() here. And also check it would be better if we declare this method private?
Please move this line into the if/else branch, e.g. @Override public void initSelectedProfile(ListModel<VnicProfileView> profileList, VmNetworkInterface networkInterface) { if (Objects.equals(profile)) { profileList.setSelectedItem(profiles.stream().filter(profile ->!Objects.equals(profile.getItems(), networkInterface.getVnicProfileView())).orElse(Collections.emptyList()); } else { Collection<VnicProfileView> profiles = Optional.ofNullable(profileList.getItems()).orElse(Collections.emptyList()); profileList.setSelectedItem(profiles.stream().filter(profile ->!Objects.equals(profile.getItems(), networkInterface.getVnicProfileView())).findAny().orElse(VnicProfileView.EMPTY)); } }
Please move this line into the if. I think it would be better to keep it if needed.
Please move this line into the if.
nit: if (!project.getAction(FailureCause.class) &&!project.getAction(FailureCause.class))
nit: if (!project.getAction(FailureCause.class)) { return; }
nit: if (!project.getAction(FailureCause.class), Action.class)
Why did you add these similar lines here?
Why did you add this statement after the loop?
Why did you need to call.setHeader here?
For all asserts, provide a 3rd parameter "message".
Don't use assertNull.
Remove all asserts.
Consider null case.
Consider null pointer dereference to the value.
Consider null value.
You could use this variable here too
You could use a local variable here too
You could use a local variable here.
config.getPluginDirectory() this is ok without locking?
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be more appropriate and the suggester at least.
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be better
not sure, what if this causes the error to be logged?
log this?
remove?
what if we don't add yet another state will be sent?
remove if, else's code is covered.
what if we don't add yet another state will be returned?
We can use result.getProtocol() here.
We can use == on enum here.
We can use == on enums.
is it possible that rowCount is different than mapBlock?
is it possible that rowCount is different than expected?
is this change needed?
Missing spaces around ==.
Missing spaces around operators.
Missing spaces around =
Can we just add a space after if and before the else?
Can we just make this method final?
Can we just add a space after if and (
Please check exception message
Please check exception message, we must be sure that it's really expected exception.
Let's check exception message
I think we need to check here that the host is null
I think it would be better to change the logic of host and 'host' to 'null'.
I think it would be better to change the logic of host and 'host' to 'validate' method, i.e., add the warning to the system property.
initialize to null
initialize to modifiedBranch
initialize to modified_ID
Wondering if we should make this a static method in AbstractClass that can be used in several places?
can be replaced with just lambda
Nice catch Exception
This can be rewritten as: if (item.getLoggedIn() == null) { // do nothing }
This can be rewritten as: if (StringUtils.isEmpty(item.getLoggedInUser())) { // do stuff }
This can be addressed.
The Java 8 has been introduced in Java 7, so this is no longer necessary.
The Java 8 has been introduced in Java 8 for this.
The Java 8 has been introduced in <LINK_0> for checking the null for the password
i'd suggest to put this in a try-finally block, so that the JobRepositoryFactory.getJob() never returns null.
i'd suggest to reset the JobRepositoryFactory to a local variable.
i'd suggest to reset the JobRepositoryFactory to perform the job.
Is a config specific to this location?
Shouldn't this be a UNDERLINE_HEARTBE?
Is the assumption that this is negative?
CRS can we more specific here? It does not make sense for this to be null.
CRS can we more specific here?
CRS can we throw a NPE here?
The same goes for all the changes in this file.
The same goes for all the different app types.
The same goes here.
Same question. E. g. in constructor, it uses NullHandling.emptyToNull(), and empty string, if value is null.
NullHandling.emptyToNull()
Same question
Don't you want to rename this to authzClouds?
Don't you want to rename this to authzClouds that are slightly different than what it was before?
Don't you want to rename this to ps?
LiveInstance?
Please do not use Thread.sleep(). It will wait for the process to finish.
Please do not use System.out.print. It will help debugging.
This is the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
This should be the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
This should be a pre-existing HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
I think you're loading all the strings in AndroidApiUrl, could you reuse them?
I meant to use otpApiUrl.get().isOldOtpApiUrl() instead of these two lines.
I meant to use otpApiUrl.get().isOldOtpApiUrl() instead of duplicating its logic.
Check that the RyaStatement and Config are not null.
Check that the RyaStatement and Values are not null.
Null check
suggestion if (!passwordToEncrypt.getWorkflow())) { I think this should be negated.
suggestion if (!passwordToEncrypt.getCorrelation().isEmpty()) { I think this should be negated.
suggestion if (!passwordToEncrypt.getCanDoOnCurrentPage()) {
Just use Guid.isNullOrEmpty
just use Guid.isNullOrEmpty
this will be entry.getValue()
style: space after 'if' and before {
style: space after if
style: space after 'if'.
In my opinion we shouldn't need to hide the error text here. If you're showing an error message why it's failing for a newsnackbar error, isn't it?
In my opinion we shouldn't need to hide the error text here. If you're showing an error message why it's failing for a newsnackbar here, isn't it?
In my opinion we shouldn't need to hide the error text here. If you're showing an error message then we should show the error for this error.
Use FileUtils.mkdirs
This is one of the callers that can be used to check for empty directories. Use FileUtils.mkdirs
Unnecessary blank line.
hmmm, shouldn't we have this logic at all?
hmmm, shouldn't we use VmInit.getInstance().getRootPassword() now?
use VmInit constant
.* and.*
isEmpty()
.isEmpty()
Use the new method.
Use the getTestLogger().cleanupSoftwareProcess method.
Use the getTestFrom method.
If you want to include the file name in the error message, better to read it and return empty string instead of throwing exception.
If you want to include the file name in the error message, better to read it and return empty string instead of null.
If you want to include the file name in the error message, better to read it and return empty string instead of throwing an exception.
cannot be null. "default user with the username" or something?
cannot be null. "empty user with the username" does not exist.
cannot be null.
Static import?
Static import for Assert.*
Static import
Not needed given the old code
Not needed given the old constructor
Not needed
If we're fixing this bug, we should probably also log the exception. I think we should include the details of the problem into the log. Also, we should rephrase the error message: "all flags are not supported because you didn't include the new flag."
If we're fixing this bug, we should probably also log the exception. I think we should rephrase the warning to make it consistent.
If we're fixing this bug, we should probably also update the variable here.
Would it be better to use the same JSON abstraction instead of the literal?
Would it be better to use the same format as the previous line?
Would it be better to use the format of the attributes?
In this case we can compare lists
In this case we should probably change it to <LINK_0>
In this case we should probably change this to compare/replace
I think you can use Arrays.stream(constantFilterFunction).filter(column -> function.get(columnIndex), true).filter(new Page(columnIndex), positions.length == 1);
I think you can use Arrays.stream(constantFilterFunction).filter(column -> function.get(columnIndex)).filter(Objects::nonNull).findAny().ifPresent(column -> { int[] {0}; return value; }
I think you can use Arrays.stream(constantFilterFunction) here
Don't you need to print the stack trace when the output gets null?
Don't print the stack trace when the frame is open.
Don't you need to print the stack trace when the output is null?
Perhaps use IsNullOrEmpty() here?
Perhaps use Collections.singleton(...) instead of errMsg?
Perhaps use Collections.emptyList() here rather than null
nit: Maybe we can move this down to the DeltaShardRewriter constructor.
nit: Maybe we can move this down to the DeltaShardRewriter constructor
nit: Maybe we can add a check to if it is null or empty?
Not sure if you want to break this line here
Not sure if you want to break here.
Not sure if you want to break this line right here.
This catch block is identical to the one above in "if (!unitOfWork.isNotRunning())". It's better to put the exception there.
This catch block is identical to the one above, maybe we should factor it out?
This catch block is identical to the one above in "if (!unitOfWork.has already committed())". I think this would be cleaner if extracted to a separate method
Being paranoid here, is it possible that the test is failing and returning empty strings?
Being paranoid here, is it possible that the test is failing and return the empty string?
:images:
does this throw any exception?
do not use quark for state system
debug?
We may want to log the operation / chain id? I'm not sure "this operation" will work for jmx-messages.
We may want to log the operation _log_ trace.
We may want to log a isDebugEnabled here.
If the type of the editPart is the EditPartOperation it is not a component, so a null check should be added before the isEditPartOperation
If the type of the editPart is the EditPartOperation it is not a component, so a null check should be added here.
If the type of the editPart is the EditPartOperation it is not a component, so a null check should be added before the isEditPoliciesOperation
I think you need to set UDAF currentlyExists function to false, since for instance you are already checking for blank strings.
I think you need to set UDAF currentlyExists function as well, to avoid unnecessary cast.
I think you need to set UDAF currentlyExists function to false, since for instance you are already checking for existence of the function
This should no longer be > 120 characters.
This should no longer be > 0 since we don't want this to be running with adb host commands
This should no longer be what we want.
I think you meant to call getMessage() here. Otherwise the stack trace will be printed.
I think you should throw InterruptedException. Otherwise the stack trace is strange.
Unnecessary.
Is path == null the same as the old one? Should we use "" instead?
Is path == null the same as the old one? Should we use "" here?
Is path == null the same as the old one? Should we use "" as the constants?
Make this a ternary and the one above a ternary return, i.e: java return Const.POINTS_NOT_SUBMITTED && Const.POINTS_NOT_SUBMITTED && Const.POINTS_NOT_SURE;
Make this a ternary and the one above a ternary return, i.e: java return Const.POINTS_NOT_SUBMITTED || pattern == Const.POINTS_NOT_SUBMITTED || Const.POINTS_NOT_SURE);
could simplify this by a switch and just write the text as a single static final constant at the top of the file.
This should be a loop over the result of object.getObjectClass(). This will not throw an IllegalArgumentException if it is null.
This should be done in the loop as well (but it will have to be optimized each time)
This should be a loop over the result of object.getObjectClass().
How about getTxStreamProcessedTs instead of getTxStreamProcessedTs?
How about getTxStream() instead of getTxStream()? It seems like this method is only used in createTxStream(), so it doesn't need to be protected.
How about getTxStream() instead of getTxStream()? It seems like this method is only used in createTxStream() and not getTxStream()?
The delivery of the command is that the object is either of the not the object.
The delivery of the command is that the object is provided. See the method type
The delivery of the command is that the object is either of the Sender or we are doing this.
getParameters().getParentCommand()
getParameters().getTaskIdList()
getParameters().getTaskIdList() is null
will this be easier to read if you get an exception?
Don't you think it's important to be e.g. targetFile.getLink()()?
Don't you think it's important to always return a file if there is no directory?
Sharable??
Sharable?? I'd delete it, but that's a nice patch
Sharable?? I'd delete it, but that way you won't need ACTIVE check
Use class naming, to be consistent with the rest of the class
Use class naming rather than "old"
This needs to be in the if statement below
why is it important that the 'if' statement returns false?
don't we need to check if the lease is >= 0?
don't we need to check if the lease is cached?
to be consistent, we should probably also assert the task's UUID is empty.
to be extra careful with other tests.
to be consistent, we should probably also assert the task's name and the task names are empty.
We need to have a method that does this.
We need to have a method that does this: getParamNames().add(actionMethod);
We need to have a method getParamName(), I think.
Just a warning. The user will enter only the input and output dir in the input filename. That can't show up. Just removing the file and adding it as a comma will make it easier to consume consume.
Just a warning. The user will enter only the input and output dir in the input filename. That can make it clearer to "Add file inRootElementArray" as it was before.
Just a warning.
@rishabh-997 I'd introduce a variable for qualityMod.getOptions().booleanOption() and the reader directly.
@rishabh-997 I'd introduce a variable for qualityMod.getOptions() and getQualityNames() to vanishAction.
@rishabh-997 I'd introduce a variable for qualityMod.getOptions() and the reader directly.
Will this cause NPE in eventDetails array?
Will this cause trouble later in this line?
Will this cause trouble later on setTask(String text)?
Wouldn't it make sense to return fromToEvent() when the request is done?
Wouldn't it make sense to return fromToEvent() when the context is strength? Otherwise, if the current behavior is to request the event, the variable should be gone.
Wouldn't it make sense to return fromToEvent() when the context is strength? Otherwise, if the current behavior is to request a block as expected, then they're not used.
style nit: we don't use braces around single line blocks
style nit: now that you're using this expression :)
style nit: now that you're using this expression :), I think it can be simplified.
rename to channel
rename to channelToLock
rename to channelOrLock
"for (
"for" -> "while"
"forCompletion"
cboYItems[0] is going to be very generic, but still.
cboYItems is going to be very globally slow in case of an error.
cboYItems is going to be very globally slow in case of errors.
toString() is not required
You should do not need to call toString since you cannot access the subject.
You should do not need to call toString since you cannot access the subject under the message
Would it make sense to reduce the columns that are relevant?
the minimum shouldn't be restricted in this case.
Would it make sense to reduce this to the columns that are relevant?
Printing a variable is not a good idea.
Printing the variable is not necessary.
Printing a variable is not a good practice.
No null check for zone?
NoCidrBlocks in this case?
NoCidrBlocks in that case?
Shouldn't it be template.isDefaultDeployment()?
Shouldn't it be template.getReadOnly()?
Shouldn't it be template.getAction()?
Maybe log the command is missing here?
Maybe log the command is missing: command.doJobTriggerConditionMet.Processing();
Maybe log the command is missing: command.doJobTriggerConditionMet.Processing()
If I'm reading this correctly, it may be a good idea to pass a stream or a reference to the enum here. I would go for the "indexedTypes" approach: java private final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes;... Builder output.add(worker.get(i));... remove this duplication and the one below.
If I'm reading this correctly, it may be a good idea to pass a stream or a reference to the enum here. I would go for the "indexedTypes" approach: java private final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes;... Removed output.writeBoolean(worker.get(worker)); final boolean output.writeObject(types); return output.getVersion(); } I'm not sure if it can be mapped to a single IndexedTypeIdentifier, a StatusCodeTypeIdentifier, and a STARTING.
If I'm reading this correctly, it may be a good idea to pass a stream or a reference to the enum here. I would go for the "indexedTypes" approach: java private final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes; private static final Set<LegacyIndexedTypeIdentifier> workerTypes;... Removed output.writeBoolean(worker.get(worker)); final boolean output.writeObject(types); return output.getVersion(); } I'm not sure if it can be mapped to a single object.
Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.
Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication?
Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the logic more readable and reduce duplication.
Please use a private static final String variable for the key
Should this be "file.txt"?
Should this be "file.txt" as well?
I think the better option would be to use the same-key syntax here, and add a space before the comma. Also, I'm good to see the trailing space on the next line, but I think that's a good idea.
I think the better option would be to use the same-key syntax here, and add a space before the comma. Also, I'm good to see the trailing space on the next line, but I think that's a good opportunity to add a space after the comma.
I think the better option would be to use the same-key syntax here, and add a space before the comma.
Is it log.tracef("LOCK[%s]: {}.
Is it log.tracef("LOCK[%s]: %s", getName(), getStartingtime);? I prefer to use the slf4j log statement here.
Is it log.tracef("LOCK[%s]: {}.", getName(), exception);
I think this should be Objects.equals(this.context, that.class) && Objects.equals(this.hash, that.class); (though I may be wrong)
I think this should be Objects.equals(this.context, that.class) (though I may be wrong)
I think this should be Objects.equals(this.context, that.class)
The usual pattern for this is to have a single "version" method (here and below): private getFeatureType(KvpConfiguration feature, boolean "query") { return getFeatureType(type, "CQL_FILTER").toString(); } That way it isn't clear to me.
The usual pattern for this is to have a single "version" method (here and below): private getFeatureType(KvpConfiguration feature, String "query_json") { if (type == null) { return null; } return "Filter" } This would avoid the "query" cast.
The usual pattern for this is to have a single "version" method (here and below): private getFeatureType(KvpConfiguration feature, boolean "query") { return getFeatureType(type, "CQL_FILTER").toString(); }
In this case, you can drop the indexConfig for the test.
In this case, you can get rid of the indexConfig for the test.
In this case, you can drop the indexConfig for the test. This would make sense as well.
Is it possible to use a real username or password here?
Is it possible to use 0 here?
Unneeded empty line
Missing curly braces.
Same here. Haven't thought of having a method for the workflows.
Same here. And the same above.
For symmetric purposes, we can use the breaches loop pattern here: for (int i = 0; i < <LINK_0>
For symmetric purposes, this can be just the TemporaryFolder createOption...
For symmetric purposes, this can be just the TemporaryFolder query(s) method.
This effectively cause flaky tests. I don't think this is a good idea.
This effectively cause flaky tests. I don't think this can be simplified.
This effectively cause the thread to be interrupted. I think it's better to use a boolean flag, than a synchronized block for the test itself.
We could use Objects.equals(dmnModelPath, modelName) here as well.
We should use Objects.equals(dmnModelPath, modelName) here as well.
We should use Objects.equals() here as well.
Is this test finished? It looks like test is only testing the result.
Is this test finished? It seems to check if the function is called when not.
Is this test finished? It seems to check if the function is created and false, isn't it?
I don't think that this is going to work, but seems like it would be better to just replace these two lines with a simple if (value == null) { return null; } else if (vte.contains("self_update")) { return new ValidatorError(BASE_KERNEL_OPTS, bte); } else { return null; }
I don't think that this is going to work, but seems like it would be better to just replace these two lines with a simple if (value == null) { return null; } else if (vte.contains("self_update")) { return new ValidatorError(BASE_KERNEL_OPTS, tmp); } else { return this; }
I don't think that this is going to work, but seems like it would be better to just replace these two lines with a simple if (value == null) { return null; } else if (vte.contains("self_update")) { return new ValidatorError(BASE_KERNEL_OPTS, bte); } else { return this; }
nit: Deleting table is a bit weird here.
nit: Deleting table is pretty a bit weird here.
nit: Deleting table is pretty a bit weird to see the _table_ in the log record.
Group exception types handled identically in a single catch block.
travis is failing because this class wasn't updated suggestion throw new IllegalArgumentException(e);
Who else throw an exception?
10 and 100 will be a magic number. Why don't we use the constant directly?
10 and 100 will be hard to understand.
10 or so.
I don't think this is what you want. The main issue is that the user is running on a OS and not the OS, which is the default behavior. Is it necessary to have the user bind to run all the time? Maybe just use a logger?
I don't think this is what you want. The main issue is that the user is running on a OS and not the OS, which is the default behavior. Is this the user agnostic?
Is this the main reason why you have to wrap this into a logger?
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: org.osgp.adapter.protocol.dlms.exceptions.TechnicalException, com.alliander.osgp.shared.exceptionhandling.FunctionalException [![rule](<LINK_2>](<LINK_0>
Shouldn't it be warn, not info? Or debug?
Shouldn't it be warn, not info? The DlmsDevice object is available, so not sure the message is correct.
This will fail if the host is either selected or not. I would say, it's better to clear the initial volume only if we are on the first host.
This will fail if the host is either root or Host.
I think we can use the filtering form here.
Also with explicit contentType check java if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } else { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } I think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can be deferred to flatmap operator.
Also with explicit contentType check java if (data == null) { return callApi(data,..); } else { return data.windowUntil(..).flatMap(fluxes -> { var contentType = getContentType(cachedBuffers); if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } }); } I think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can go away.
Also with explicit contentType check java if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } else { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } I think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can be deferred to flatmap operator. What do you think?
You're missing some handling for the DataTransactionBuilder. It should not be part of the interface, which should be handled here.
You're missing some handling for the DataTransactionBuilder.result(DataHolder.class) call. It should not be here.
Likewise here.
As a practice its a good idea to call commit on a GatewayAPIDTO before the call to commit
As a practice its a good idea to call commit on a GatewayAPIDTO before the call to commit the latest version
The statement above seems superfluous
plz remove pokemon.
plz remove pokemon.from_JSON()
plz remove this
Missing null check
The null check is necessary here.
The changes made here are never read.
I don't see why we need to synchronize here entire Producer implementation :(
I don't see why we need to limit the buffer size...
I don't see why we need to synchronize here entire Producer implementation.. ourselves.
It would be nice to ensure that the reader is closed even if an exception occurred.
It would be nice to ensure that the reader is closed even if an exception occurs.
What happens if the reader is not set?
yarn@EXAMPLE.COM?
Name "c" -> "c"
Name "c" -> "b"
Errr... you should verify this before you even push a new commit! =)
you should verify this before you even push a new commit! =)
Errr... you should verify this before you even push a second push! =)
Why "next"?
Why add a blank line?
Why add a "next"?
Is this really needed? "getIdFieldName" is more specific than "currentClass" log message.
Is this really needed? Doesn't the getIdFieldName() return a descendant of the working directory?
Is this really needed? Doesn't the getIdFieldName() return a descendant of the working path?
why not keySize? from all parameters of the called pattern, we select the bound ones... so the source width should be the number of symbolic parameters
why not keySize? from all parameters of the called pattern, we select the bound ones... so the source width should be the number of symbolic parameters
why not keySize? from all parameters of the called pattern, we select the bound ones... so the source width should be of symbolic parameters
It's good to implement toString() in debugging, as they are generated with the same implementation.
Let's generate all the fields for the same info.
Let's implement all the other similar methods as with toString() to render fields.
This test is doing quite strange thing, because there is no way to go through java8.util.format.
This test is doing quite strange thing, because there is no way to go.
should rather be.contains_not_Valid
Should this be removed?
Should this be changed to: <LINK_0>
Shouldn't this be removed?
Do you think it makes sense to use an iterator() here?
Do you think it makes sense to use an iterator over the list?
Do you think that for performance should be synchronous?
It looks like we can use the scheduler.waitForServer() here instead of the for loop
It looks like we can use joiningServers here but not in the previous test.
It looks like we can use the scheduler.waitForServer() here instead of the thread.
Make "1L" a constant.
Why is this needed?
Make this values as constant.
why can we extract this code to a method?
why can we rename this variable?
why can we extract this code to a test?
IOException?
may be we need a try-with-resources here?
may be a good idea to have a directory in the body?
Same here with the merge below.
Same here with using NONE might be better here.
Same here with using ooReaderWriter().getExtent().
We don't want to swallow exceptions here.
We don't want to do this.
We don't want to do the other 'final' keyword in this class.
Can we be more precise? taskDataPath = null && taskName.equals("idea")
Can we name this case-sensitive for DataNode?
Can we be more precise? taskDataPath = null && taskName equals to ideaProject
Could we include the name of the exception message? That will help us more quickly diagnose the failure in those cases where the caller shows the exception stack trace.
Could we include the name of the exception message above to help diagnose the failure?
Instead of logging the exception message, we should print the stacktrace
This will throw an error from the default runTask.rake(buildTask()); if there is no CRBuildTask in the same condition
This will be adjacent to the boost
This will throw an error from the default runTask.rake(buildTask()); if there are no boost info
Maybe this check is redundant I guess?
Maybe this check is redundant
Maybe "Unknown version ordinal %s found when recovering"?
I think it's too bad to have a copy and paste error. What does it mean to have a test?
I think it's too bad to have a copy and paste error. What does it mean?
I think we don't need to change the getMapping method. I think it's too complicated for your tests.
why is this line needed?
why is this line moved up?
why is this line necessary?
Better: new HashMap<>(Collections.singletonMap(str))
Better: new HashMap<>(Arrays.asList(str))
Avoid re-coding from scratch utility code which already exists.
Same as above.
This looks like a very odd log message.
This looks like a very long log line.
should probably be Integer.valueOf(100).
should probably be Integer.valueOf(100)
'int' => Integer.valueOf(100)'
Can you put the if condition around this block? If not then this if would be wrong.
Can you remove this null check? If not then this if statement can be merged.
Can you move this if statement into a method?
hasSize(array.length)?
hasSize(null)
hasSize(2)
I think we can use ImmutableSet.of or EnumSet instead of a Set. But this is not very important.
I think we can use Set<String> here, and similar to the methods below.
I think we can use ImmutableSet.of or EnumSet instead of a Set.
This should be: if ((x <= '') || c <= '')) { builder.append(c); }
This should be: if ((x <= '') || c <= '')) { builder.append(x00A0); }
This should be: if ((x00A0 || c <= 'z') || c <= 'z')) { builder.append(c); }
The operation runs in a background thread; this access to get the checkout result may not work.
The feature runs in a background thread; this access to get the checkout result may not work.
I think this could be done in a background thread that runs checkout in a background thread (see commit 786698088)
I think we should create a defensive copy of the Map
I would create a defensive copy of the Map
I think we should create a defensive copy of the Map here
Remove this catch and let the exception be thrown as that'll make the test pass.
Remove this catch and let the exception propagate.
Remove this try-catch and let the exception propagate normally.
I think this belongs to a service -> a sniProxyAddress
I think this belongs to a service, in the end, in case of a keystore type, truststorePassword, keystorePassword and a truststore?
I think this belongs to a service, in the end, in case of a keystore type, truststorePassword, keystore, truststorePassword, etc.
Would createUnresolved work as well?
redis() should be accessed as static method.
Would createUnresolved work as well as create(byte[]) method?
@ndinuan Is it possible to interrupt storage immediately? What is the purpose of unlock?
Looks like return value is never used?
Looks like return value is never used.
Why not make more sense:.equals(this.sources) here?
How about more? I mean, not all.
Why not make more sense:.equals(this.collection)
nit, it would be nice to have: private List<SlotExecutionVertexSchedulingRequirements> allocateSlot( Set<SlotExecutionVertexSchedulingRequirements> executionVertexId) { return new SlotRequestFutures(allExecutionVertexId); }
nit, it would be nice to have: private List<SlotExecutionVertexSchedulingRequirements> allocateExecutionSlot( Set<SlotExecutionVertexSchedulingRequirements> executionVertexId) { return new SlotRequestFutures(allExecutionVertexId); }
nit, it would be nice to have: private List<SlotExecutionVertexSchedulingRequirements> allocateSlot( Set<SlotExecutionVertexSchedulingRequirements> executionVertexId) { return new SlotRequestFutures(allExecutionVertexSchedulingRequirements.getExecutionVertexId(), executionVertexId); }
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but since some people want it i won't object)
woudln't this be the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but since some people want it i won't object)
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but)
please add getMessage : {}\n{}
reorder
there is no need for 'this'.
I think Assert.fail() is missing here - won't be called if the app is null.
I think Assert.fail() is no longer appropriate - should you use AssertJ for assertions?
I think Assert.fail() is missing here
Same as above, can you please use a try-with-resources block here?
Same as above, can you use cursor.moveToFirst()?
Same as above, can you use cursor.moveToFirst(), just in case of broken initial position
Should this be passed in?
Should this be package protected instead?
Should this be passed in from the other constructor?
Is this condition really needed?
Is this change necessary?
Is this class used?
What if the future was already initialized?
What if the future was already initialized, does this still need to be updated?
What if the future was already initialized, does this still need to be done?
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis()
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be enough?
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis()?
We have to also show the snackbar in the activity. Right now, there are a few different places where we need to use the same activity - the Themes prefs should probably be re-used.
We have to also show the snackbar in the activity. Right now, there are a few different places where we need to use the same activity - the Themes prefs should be re-used.
We have to also show the snackbar here, otherwise in the error message you are still using. Right?
should this be taskReports.getWorkerRunningTaskLocation(taskId)?
should this be taskReports instead of null?
should this be batch?
I think we should pull this metric from thread local metric list outside of metricList metricList in this method.
I think we should pull this metric from thread local metric list outside of a metricList metric?
I think we should pull this metric from thread local metric list outside of metricList metric?
Minor: Convention is to use curly braces around single line blocks
Minor: Convention is to use curly braces and for single-line if statements
Minor: s/requirejs/getHost/
Should not use pluginInfo here? It should be escaped as well.
Should not use base class here? It will be super easy to see in the code.
Should not use base for this PR, but also the pluginInfo.isEmpty()
Maybe it would be better to move the if block into a separate method?
Maybe it would be better to move it into the if block?
Maybe it would be better to move the if block to the else branch?
Here in line 81 we have redirect. If it is null then in line 81 we will get NPE. It means we have to put null check somewhere above and handle it correctly.
Here in line 81 we have redirected a <LINK_0>
Here in line 81 we have redirect. If it is null then in line 81 we will get NPE. It means we have to put null check somewhere above and throw it correctly.
We should turn the auth system back on after creating the test data.
We should turn the authSystem back on after creating the test data.
I believe the Auth system should remain on in this method.
I don't think this is a good idea. The caller of encodeEncoder should have to release the buffer before calling createEncoder.
I don't think this is the right place to release the buffer. The contents of the buffer may be different from encoding (that is the case). If the utility is in DataBuffer, then we should give it a member of this class.
I don't think this is the right place to release the buffer. The contents of the buffer may be different from other languages if the buffer is in DataBuffer.
Poller has a quick PollerFactory on the way up here, so we don't need to do this check on the PollerFactory just because it's a Spring poller and not the channel name to be used by the consumer.
Poller has a quick PollerFactory on the way up here, so we don't need to do this check on the PollerFactory just because it's a Spring poller (possible), if it is the case, otherwise we are going to be able to use it. So, right?
Poller has a quick PollerFactory on the way up here, so we don't need to do this check on the channel's afterPropertiesSet().
You should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
you should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
you could probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
Now it's correct! :+1:
Now it's correct! :+1: But it's quite strange!
Now it's going to support your changes! :+1:
Same as above: if (!isEmpty()) { discardConnection(); }
Same as above: if (!isEmpty()) { discardConnection(); } else { // do the trick
Same as above: if (!getSucceeded()) {
no need to call principal_address in this context.
no need, you can call principal_address directly.
no need, you can call principal_address in this context.
When you open a repository you have to ensure to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close().
When you open a repository you need to ensure to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close().
When you open a repository you have to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close().
maybe change this to be a Map<String, Integer>?
maybe change this to be a boolean hasAdditionalKeySize(int keySize )
maybe change this to be a separate commit?
Please update this example according last changes in the master (look.)
Please construct this API inside the API calls.
Please construct this API inside the conditional and reuse code.
Does the list need to be modifiable? If not, List.of() is the conventional preference for empty lists.
https:www -> https://www
Does the list need to be modifiable?
Maybe move this to a method so we can have a test that ensures that the RedisStore is updated elsewhere?
Maybe move this to a method so we can have a test that ensures that the RedisStore is updated.
Maybe move this to a method so that the GraphQLService is more specific?
I think you can just use hash.hashCode(). lists should implement it correctly.
I think you can just use Objects.hashCode(o) here.
I think you can just use return Objects.hashCode(o) here.
Looks like a candidate for a method isRemote(ChangeData p)
Looks like a candidate for a method #build(ChangeData p, String key, boolean limit)
Looks like a candidate for a method #isRemote(ChangeData p)
what is this new condition about? is this related to the original story? anyway, this seems a good place to use 415/Unsupported Media Type
what is this new condition about? is this related to the original story? anyway, this seems a good place to use Extra checks.
what is this new condition about? is this related to the original story? anyway, this seems a good place to use.equals() instead of instanceof.
I don't think this is needed. The code should be "else if" (the AttributeCriteria contains both parameters)
I don't think this is needed. The code is already checking for the property "property".
I don't think this is needed.
Should the implementation of KeyMaterial as well be a class?
Should the implementation of KeyMaterial as well be called by the KeyMaterial interface?
Should the implementation of KeyMaterial as well be called by the KeyMaterial implementation?
Should be collisionMod.getCollisions().
Should be collisionMod == null || collisionPatchge
Should be collisionMod
@westonized the task says: "map.headers." [put(Entry.getKey(), entry.getValue())](<LINK_0>
@westonized the task says: "for loop cannot be specified on the entry " + entry.getValue()
@westonized the task says: "for loop cannot be specified on the entry " + response.iterator().next()?
No need to use UriBuilder
No need for UriBuilder
No need for this.home
I think you need to assert that the return value is 0.
I think you need to assert that the return value of the command is 0.
I think you need to assert that the return value of the assertion fails.
to be consistent, please use variable and remove return.
to be consistent, please use variable and extract to variable
you can simply use Collections.singletonList()
Oh, I see PlainStreamingSender is exactly the same. Could you please extract it?
Oh, I see PlainStreamingSender is exactly the same. Could you please extract it to a local variable?
Oh, I see PlainStreamingSender is exactly the same. Could you explain please?
Perhaps we should not validate the options here, but we don't want to continue with options?
Perhaps we should not validate the options here, but we are doing a validation for all exceptions?
Perhaps we should not validate the options before merging this change.
Add doc Add @Override
Add doc Add @Override annotation.
Add doc Add @Override.
This should be value instanceof Integer || value instanceof Integer.
This should be value instanceof Integer, is it?
This should be value instanceof Integer, not Integer.
In the next line, this pattern is captured and wrapped in a try-catch block. Can we move this outside the try-block?
This lookup is duplicated. It would be nice to move this out into a single place (RepoObjectMetadata(Repo) method.
This lookup is duplicated. It would be nice to move this out into a small helper class.
I think the 'if' can be removed now
I think the 'if' can be removed then
I think the 'if' can be removed then :)
All of this can be replaced with a call to assertFalse.
The same?
All of this can be replaced with assertFalse.
I don't think this is a good idea. But we need to be careful when there are multiple executors.
I'm not sure about this. Why do we need this when we're only using the callback?
I don't think this is a good idea. But we need to be careful when there are multiple executors. This is the "connection" flag to timeout.
please decrease to TRACE level
please decrease or decrease to TRACE
please decrease to TRACE
Suggest a final variable for this.
This is a --threaded API and should be replaced with a lamda.
This is a --threaded API and should be created again in a finally block.
Don't need a timeout here
Don't need this?
Don't need to be local
java try (FileOutputStream output = new FileOutputStream(dest, resourcePath)) {
java try (FileOutputStream output = new FileOutputStream(dest, resourcePath)) {...
java import java.util.stream;
Could you simplify this by only doing string.append(repository.getAdded().isEmpty())?
Could you simplify this by only using string.append(repository.getAdded().isEmpty())?
Could you simplify this by only adding the string like string.append(repository.getAdded().isEmpty()), so it only happens once?
I would make this stronger. For example, that will be handled by a few other cases, like STR_LINE_BREAK + "-1"
I would make this stronger. For example, that will be handled by a few other cases, like STR_LINE_BREAK (name + "ParagraphStart")
I would make this stronger. For example, that will be handled by a few other cases, like STR_LINE_BREAK (name + "ParagraphStart "). Also, use replaceAll instead of replaceAll
instead of calling a double negative. Use the double negative.
could you set a local variable to null after the double negative?
could you set a local variable to null after the catch?
Could you keep the regex in the file, and say it's a server-side author? That's what I meant.
Could you keep the regex in the file, and say it's a server-side author? That's what I meant to say.
Could you keep the regex in the file, and say it's a server-side author? Because of that, the output is a bit unclear.
Unnecessary. You can't just call this method.
Unnecessary. You can't just use an IPatchSet here.
Unnecessary.
A method on an interface should never return ElasticSearchUtils.getMappingSource(table.getName(), indexName); Its much clearer here.
A method on an interface should never return ElasticSearchUtils.getMappingSource(table.getName(), indexName); should be extracted as a class variable. Perhaps even saving it out of the method, but it's not necessary to do that?
A method on an interface should never return ElasticSearchUtils.getMappingSource(table.getName(), indexName); should be extracted as a class variable.
You can use the ShardSyncTaskManager creating the ShardSyncer, instead of doing it every time.
Why does it need to be public?
You can use ShardSyncTaskManager here in the constructor.
I think we should log this error, as it will be confusing with a user that something went wrong on their session.
I think we should log this error, as it will be confusing with a user on what went wrong at this point.
I think nextElement.config().getCertificateException should be thrown and handled as a KeyStoreException.
S is not a good variable name. Rename it to something more descriptive.
change this variable to a more descriptive name that explains its purpose.
S is not a good variable name. Rename it to something more descriptive. :)
Method on MethodInvocation has 45 lines of code (exceeds 25 allowed). Consider refactoring.
Method on lines 45 and 6 lines of code (exceeds 25 allowed). Consider refactoring.
Method on lines 45 and 6 lines of code can be simpler on lines of code (exceedly). Consider refactoring.
if (getWindow()!= null ) {..} may help
try using 'getEntity().getStoragePoolId()' instead.
if (getWindow() == null ) {..} may help
If 'commit' is being removed from the pool, I think it's better to leave it as is.
If 'commit' is being removed from the pool, I think it's better to leave it as it was before.
If 'commit' is being removed from the pool, I think it's better to fetch the'macPool' from the pool.
remove changes in this class
remove "success" string
remove it.
i think you need to check to see if the filter is null, in this case, we should return a DefaultFilter instead of null.
nit:.apply(null)
i think you need to check to see if the filter is null, in this case, we should return a DefaultFilter instead of null....
We can probably remove that System.out.println before merging.getExtent().toString().
We need to move this out before.getExtent() since that's what the code is doing.
We need to move this out before.getExtent() since that's what the code does.
This is for debugging, right? You should wrap this in a if (log.isDebugEnabled()) block.
This is for debugging, right? You can just use the log.debug() instead.
This is for debugging, right? You should wrap this in a if (log.isDebugEnabled()) check.
exception
invest()
exception id
not sure how you want to use the unit tests? if you have a pre-test, you can just use it.
not sure we want to have this in the same thread, just in case...
not sure how you want to use the unit tests? if you have a pre-existing span, you'll get a nice NPE
@crankumarkolli - please make this <LINK_0>
@crankumarkolli - please make this a variable.
will this be invoked for each invocation?
These two lines are unnecessary since the beginning of the try block do the same thing.
These two lines can be moved outside the try block.
These two lines can be moved inside the try block.
Do we need that log?
Do we need that log here?
Do we need that log?
Use logger if needed
Use logger if you would want to print it
Use logger.
if you set a modifier - protected seem suitable
if you set a modifier - why not use a setter? setHardTimeout getter?
if you set a modifier - why not use a setter?
shouldn't there be a fail() after this?
I think we should have the fail() after this line?
I think we should have the fail() after this line.
call byteBuf.forEachByte(ch.finish()); and assert the return value.
call byteBuf.forEachByte(ch.close());
call byteBuf.forEachByte(ch.int(), StandardCharsets.UTF_8)
unused
unused or already
unused or removed
return StringUtils.isNotBlank(value) && StringUtils.isEmpty(value) && StringUtils.isEmpty(value)
return StringUtils.isNotBlank(value.get(value)) && StringUtils.isEmpty(value)
return StringUtils.isNotBlank(value) && StringUtils.isEmpty(value) && StringUtils.isNotBlank(value))
else not needed, the null check will never be reached.
else not needed, result in the same statement
else not needed, the null check will never be necessary.
Super nit: unintentional additional white space.
Super nit: unintentional additional white space
Not sure what to do with this?
should use the String.valueOf()
the random text should be added as a separate attribute instead
the default charset is not extraneutral.
I prefer the latter of the class because it's more readable form of voltdbPlanTreeDto :)
I prefer the static findPlanNode. I don't see how this code works
static import
Why do we need the "host"? It is a typo only I don't like "port"
I think the original bug was that the replacement didn't work anymore, because I can't see any other change. Could you make the change to just "host/port" and "port"?
Why do we need the "host"? It is a typo only
I think catching this is more appropriate than just logging the error.
I think catching this is more appropriate than just logging the exception.
Nitpick: I think it's more readable if you create a custom class (event) rather than catching the exception.
Try something like try-with-resource.
Try something like try-catch/finally for exceptions in these tests.
Try something like try-catch/finally/finally for exceptions in these tests.
This callback is also a little weird. Maybe we can use callback.addCallback(callback); in a separate PR?
This is necessary, but there's a problem with adding callback on callback.
This callback is also a little weird. Maybe we can use callback.addCallback(callback); here?
You should try-with-resource block: try (FileChannel fileChannel =...) { // use the resource } It will automatically close the resource when exiting the block.
Why not try-with-resource?
You should try-with-resource block here. If you don't want to close the file first, it is always closed.
The intent of this method is strange to me. It is strange to have to introduce a helper method to do this (and could be reused in other methods to reduce duplication).
The intent of this method is strange to me. It is strange to have to introduce a helper method to do this (and could be reused in other methods to reduce the code duplication).
The intent of this method is strange to me. It is strange to have to introduce a helper method to replace the elements, but not the first time it is given by this (now that it is common to all those methods). The more common approach is to add a method to the parent class that returns the the result.
What's the purpose of this change?
What's the purpose of this expression?
What's this expression?
I think it would be better to use awaitility instead of sleeping.
I think it would be better to use awaitility instead of Thread.sleep...
I think it would be better to use awaitility instead of Thread.sleep?
orElseThrow(() -> new GlobalSequenceTrackingToken(Instant.now(),...). This can be replaced by.map(GlobalSequenceTrackingToken::getdateTime).
orElseThrow(() -> new GlobalSequenceTrackingToken(Instant.now(),...). This can lead to a NullPointerExceptions.
orElseThrow(() -> new GlobalSequenceTrackingToken(Instant.now(),...). This can be replaced by.map(GlobalSequenceTrackingToken::getInputs).
This method is a very long. Please use it.
This method is a very long.
This method is a static extension.
Replace this by System.getProperty(snapOS.getName(), StandardCharsets.UTF_8).
Replace this by System.getProperty(snapOS.getName(), StandardCharsets.UTF_8)
Replace this by System.getProperty()
This can be simplified to IgniteEx snp = startGridsWithCache(igniteltCacheCfg.get(SNAPSHOT_METRICS))
This can be simplified to IgniteEx snp = startGridsWithCache((Object) startGridsWithCache(2, dflt);
This can be simplified to IgniteEx snp = startGridsWithCache(pltCacheCfg.get(index))
Remove or extract as a variable.
Remove empty line.
Please don't include model classes for errors.
should this change in the category class?
should we use the constant name here?
should we use the ternary operator?
Can we have a default value of _periodicTriggerInterval in this class?
Can we have a default value of _periodicTriggerInterval in this method?
Can we have a default value of _changeType_?
shouldn't the test return with null as the first statement?
would be better if you used multipleCode.size() instead of 1 here
would be better if you used multipleCode.size() instead of 1.
I don't think we should use the builder: - if(object instanceof Map) { toStringBuilder(object.getClass()) } else { the same for all objects
I don't think we should use the builder: - if(object instanceof Map) { toStringBuilder(object.toString()) } else { the same for all objects
I wonder why we are creating the object here instead of using the one in the constructor?
do we need this if block at all?
do we want to log any exception in this case?
do we want to log this?
Shouldn't we be using cacheManager.getAdvancedCache()?
Shouldn't we be using cacheManager.getAdvancedCache()?
Shouldn't we be using cacheManager.getAdvancedCache().get()?
gtk_widget_realize
gtk_widget_realize should be on a separate line.
gtk_widget_item should be x - y.
nit: can use isEmpty()
nit: can use CacheUtil.toImmutableList
nit: can use CacheUtil.toImmutableList()
this is generally an anti-pattern in the project. I'd suggest appendFind() as a log.
this is generally an anti-pattern in the tests and leads to FP. e.g. some users can see on some RuntimeException thrown in the wild, this can be a violation.
this can be a static method
System.currentTimeMillis()
LOGGER.debug()
String.format()
Don't bother. This doesn't help, as we found out.
Don't bother. This doesn't help, as we found out. Should we update the elevator while we're moving the clamp?
Don't bother. This doesn;t help, as we found out.
I'd use the version of this method, rather than the brooklyn.util.logging.Logger.
I'd use the toString method of the URL for the perhaps common part.
I'd use the version of this method, rather than the deprecated version.
Please use diamond operator: new HashMap<>()
Please use key/value separator instead of field names
Please use key/value separator instead of field/variables
Can you put this into a try-catch block so that the Throwable is closed first?
Can you put this into a try-catch block so that the Throwable is an instance?
I'm not sure if this works, but would it make sense to put it inside checkFilterLastLine(Map<String, String> data) so that the contents of the map doesn't get stored in the map?
Can this if statement be moved outside the if statement?
Can you add final here and below?
Can you add autoOffsetResetOptional.ifPresent(autoOffsetReset::add); here?
call super.hasMailAuth()
call super.hasMailAuth();
calling super.hasMailAuth()
If we keep this, could we use the ExternalFileTypeByExter to store a String here? I.e. could this be just a key?
If we keep this, could we use the ExternalFileTypeByExter to store this logic in a helper?
If we keep this, could we use the ExternalFileTypeByExter to store a String here?
I'd rather this method be split in to : "getEOpposite()!= null" and "getEOpposite()" with the same value.
I'd rather this method be split in to : "getEOpposite()!= null" and "getEOpposite()" with "getEOpposite()"
I'd rather this method be split in to : "getEOpposite() == DifferenceState.UNRESOLVED", etc.
This may replace a string, perhaps we should prefer: LOGGER.debug("JabRefPreferences.PARAM("JabRefPreferences.DELIMITER")
This may replace a string, perhaps we should prefer String.format("JabRefPreferences.DELIMITER).
This may replace a string, perhaps we should prefer: LOGGER.debug("JabRefPreferences.TAG: Nicklas");
Should this be more specific and error handling?
Should this be under the try-catch block?
Should this be more specific and specific error handling?
Shouldn't this be the thingType id instead of the modelId (modelId can be null)?
Shouldn't this be the thingType ID check?
Shouldn't this be the thingType id instead of the model id?
I think this can be merged with the previous one, as well as onEventConsumer.accept(event)
I think this can be just'return get(SinkEvent.class);' statement, no?
I think this can be merged with the previous one, as well.
should be the responsibility of the check
should be the responsibility of the checkImportFromImportAction
should be the responsibility of the method
Did you mean to add the following code: if ((CallUtils.isAllocatedTo(path)) { return; }
Did you mean to add the following code: if ((CallUtils.isAllocatedTo(current)) { return; }
Did you mean to add the project?
This looks like a breaking change.
Do you need to do this? <LINK_0>
Also, please add { and } to each branch.
I would have thought that this condition should be: if (isInactive) { return false; }
I would have thought that this condition should be: if (!isInactive) { return false; }
I would have thought that the condition should be: if (isInactive) { return false; }
It's a warning. Do we want to log the complete exception stacktrace for a warning? Check with <LINK_0>
It's a warning. Check with <LINK_0>
It's a warning. If I start a transaction, I would expect a warning.
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable e) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any object (but I'm not aware of such magical Error properties).
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) { Both Error and Exception are instances of Throwable, but the Error are throwables.
Rather than do the check any more, I think it would be better to use the platform specific encoding instead of UTF-8
Rather than do the check any more, I think it would be better to use the platform specific encoding instead of UTF-8.
Rather than do the check any more, I think it would be better to use the platform specific encoding instead of UTF-8 here
nit: Could statically import these assertion methods.
nit: Could statically import these assertions.
nit: Could statically import these assertion classes.
A [minor] What is the added value of the above method used?
A [minor] What is the added value of the enum?
A [minor] What is the added value of the above variable?
I wonder if using Arrays.asList(..., Type) would perform better?
I wonder if using Arrays.asList(..., Type) would perform the same?
I think this needs to get the Type param a Type param, not a Type
nonVmMtu5000 ==> nonVm
nonVmMtu5000 ==> nonVmNics
Should also set vlanId?
is this the 'button' described in commit message? do we really need this Label?
is this the "+" missing? do we really need this Label?
is this the 'button' described in commit message? do we really need it?
Could we rename the variable previously to something like previouslyComputedResults
Could we rename the variable previously to something more descriptive?
Could we move the try-with-resources statement inside the try
Same here, seems that there is missing "getTask" parameter.
Same here, seems like the value is not used anywhere else.
Same here, seems like the value is not used, can remove it
I think it's better to require <LINK_0> if we can drop it and use <LINK_1> Also <LINK_2>
I think it's better to require <LINK_0> if we can drop it and use <LINK_1>
I think it's better to require <LINK_0> if we can avoid it
Probably better to get the sorted set at the end instead of calling.size()
Probably better to get the sorted set at some point.
Probably better to get the value of this Map.
We need to reset the interrupt flag via printStat() if the threadId is not printed properly.
We need to reset the interrupt flag via printStat() if the threadId is not printed otherwise.
We are using Double.toString() not needed. String.format is cleaner.
This seems a bit strange to me. Wouldn't it be better to just continue usingRenditions [here](<LINK_0> to do the actual logic to force a quick cleanup?
This seems a bit strange to me. Wouldn't it be better to just continue usingRenditions [here](<LINK_0> to do the actual conversion to an array?
This seems a bit strange to me. Wouldn't it be better to just continue usingRenditions [here](<LINK_0> to do the actual logic to force a quick refresh?
Might be better to log LASUtils.BLACK_METAS_TAB instead of PUT
Might be better to log LASUtils.BLACK_METAS_TAB instead of PUT?
Might be better to change this to be updated.
the exception won't be thrown here
I think it would be better to provide a configuration object for userCrn instead of clientConfig.getEnvironment()
I think it would be better to provide a configuration object for userCrn instead of userConfig.getSaltSecurityConfig()
Please use ==
Please use a ==
Use ==
I guess you can get rid of this.
I think this is wrong. You should not have this.
I think this would be better off being the default constructor of dictionary.
You can remove this line. It is already done in bind().
You can inline this variable.
Pool
You could use a try with resources here to make this test safe
You could use a try with resources here (and no need to a specific exception).
Couldn't this be on a long period?
I would get rid of the word "clouds" here, and instead just "clouds" it could get the name of the instance, and if it's used elsewhere, then it could be confusing.
I would get rid of the word "clouds" here, and instead just "clouds" it could get the name of the instance, and if it's used elsewhere, then it's not obvious what it is.
I would get rid of the word "clouds" here, and instead just "clouds" it could get confusing.
Let's say setState(KEY_SESSION_TOKEN)!= null, and CLIENT_AUTH_DATA.build(); then setState(KEY_SESSION_TOKEN) will be enough.
Let's say setState(KEY_SESSION_TOKEN)!= null, and CLIENT_AUTH_DATA.build(); or something like that.
Let's say setState(KEY_SESSION_TOKEN)!= null, and CLIENT_AUTH_DATA.get(KEY_SESSION_TOKEN)!= null
If we remove the!AlreadyisEmpty() this line, we will not need to fetch the preview.
If we remove the!AlreadyisEmpty() this line, we can remove the!!isEmpty().
If we remove the!AlreadyisEmpty() this line, we can remove the check from google.java.
Since we already have the base class AbstractTraceToken, it would be useful to support it here.
Since we already have the base class AbstractTraceToken, it would be useful to define what this method is doing
Since we already have the base class AbstractTraceToken, it would be useful to define what this method is
nit: we need a test that ensures that the cell can be completely lower than 0.
nit: we need a test that ensures that the cell does not contain the values.
nit: the cell does not need to be a list, the size of keyValueService.
You can use OrganizationDto to check the built-in value
You can remove this line.
You can remove this line
This seems to be redundant with the test above
This can be changed to: java Map<String, String> params = toParamsMap(new URL(authUrl, APP, 2))
This can be rewritten to collect DbxWebAuth.USER.
Here too, it should be API line.
Here too, it should be newDatum.
Here too, we need to have an example fixed message.
Why not just try/catch around the block?
Why not just catch HConstants.SwiftTestException?
Why not just catch HConstants.HBASE_PHONE_HOME anymore?
This makes me think that TransactionManager should no longer be used. The other constructor is annotated with @Inject, but the policy is to register itself. So it doesn't need to be changed at all.
This makes me think that TransactionManager should no longer be used. The other constructor is annotated with @Inject, but the policy is to register itself. So it doesn't need to be changed later.
This makes me think that TransactionManager should no longer be used. The other constructor is annotated with @Inject, but the policy is to register itself. So it doesn't need to be changed at all...
Should not this code be extracted to a separate method
Should not this code be in tokenExtractor and not connection?
Should not this code be in tokenExtractor and subject?
Class createPageSourcePage
IDE hint: remove "format"
IDE hint: remove this.
same as above. You are not checking readInt() anymore.
same as above. You are not checking readInt()() anymore.
are you sure that the methods are not PK?
I was just wondering if we should have the client token auth error and return it with the client token enabled, or maybe we could just add a default to the client, and have that continue to use the consumer. This is more strict.
I was just wondering if we should have the client token auth error and return it with the client token enabled, or maybe we could just add a default to the client, and have that continue to use the consumer one if it is not found?
I was just wondering if we should have the client token auth error and return it with the client token enabled, or maybe we could just add a default to the client, and have that continue to use the consumer one if it is not found.
Hm, maybe we should use a lambda here (e.g. 'public') instead of 'public'? I also think it is used in tests.
Hm, maybe we should use a lambda here (e.g. 'init' method'setPath') instead of a lambda? I also think the patch will be written in the future.
Hm, maybe we should use a lambda here (e.g. 'init' method'setPath') instead of a lambda? I also believe the patch will be written in the future.
This should be final
Currently the assigned variable is never used.
This should be assigned to a variable.
Again, the parens aren't needed.
Again, the parens are not needed.
Again, the parens are redundant.
The assert above can be removed.
The asserts are superfluous here.
The asserts are superfluous here
Maybe it is a constant.
Maybe it is a good idea to add a constant.
Maybe it is a good idea to test that a problem is be fixed.
That's a separate behavioural change, should be done in a separate patch?
That's a separate behavioural change, should be done in a separate patch, or at least in the PR
That should be part of the equals?
Does this need to be public?
It's preferable to use the StringBuilder here. Just a thought.
It's preferable to use the StringBuilder here.
Please add null check for entity.
Minor- you could reuse entity here.
Please add null check for entity!= null case
better use assertThat(storedDefinitions.size(), is(1));?
better use assertThat(storedDefinitions.size(), is(1));
avoid duplicate code
Please rename these to simply to new templates
Please rename it to new variable
Please rename it to new templates
please use!vm.getVmType() instead
please use!vm.getVmType().isConfigurationOrClusterNextRunExists() instead
please use!vm.getVmType() instead of!vm.isStateless()
In my opinion, this should be.getIntervalsOfType(IntervalType.JUNIT).getIntervalsOfType(IntervalType.JUNIT).getIntervalsOfType(IntervalType.JUNIT) instead.
In my opinion, this should be Type.JUNIT, right?
In my opinion, this test method should be switched to contributors.
Expected before actual value.
I think this is how the model should be deserialized: if the scores are present, ideally they would populate all the fields that represent them. What I expected from the test was to check the structure of the JSON response, which is the part that is causing us problems. Of course that doesn't mean this test isn't useful!
I am not sure this is how the model should be deserialized: expectedValue = actualScores.get(i); assertEquals(expectedValue, actualValue);
Small thing, but I think we should use context.requestHandler() instead
Small thing - use a lambda here instead of if.
Small thing: use context.request() instead of context.substring()
should not we handle this exception here?
should not we handle this in a "tryAddBatchWithData" path?
should not expose this in a query management as it does not necessarily need to be a sync with the other PRs
Should it be changed to warn?
Why not use the MappingKey constructor?
Why not use the MappingKey constructor to transfer the mapping key?
Is there a reason to use ImmutableSet.of() instead of findFirst()?
This extra variable seems unnecessary.
Is there a reason to use ImmutableSet.of()?
Use a static import
Use a constant instead of duplicating this literal "if"
rename indent to indent
Cannot render interstitial ad. Please move message to render()
Cannot render interstitial ad. Please move message to exception.
Consider turn into render()
Same question here - what's the purpose of this change?
Same question here - what's the purpose of removing the null check?
Same question here - what's the benefit of returning the jsonRpcServer if not null?
nit: do we have different meanings here?
nit: do not create the file in test.
nit: do we have different meanings for the project name than wrt "file"?
Probably a nitpick, but can we log in debug, instead of info?
Probably a nitpick, but can we log in the exception (which is fine) instead of notebookId?
Probably a nitpick, but Paragraph is going to be null, so we should check notebook is not null. It may be incorrect.
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(this, "Project"); projectLoader.postEvent(this, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(this, "This is to test createProjectManager"); projectLoader.post(this, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
Remove this
I would throw an AssertionError here - this must be impossible from a programming error
I would throw an AssertionError here...
my opinion
Should probably use ResteasyProviderFactory.newInstance() to keep the singleton reference if possible.
Should we use ResteasyProviderFactory.newInstance() to automatically reset the bpf?
Should probably use ResteasyProviderFactory.newInstance() to keep the singleton reference.
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() || runningVms.size() > 1 && ag.isVmAffinityEnabled() || affinityGroup.getVdsIds().isEmpty())
Please remove unnecessary parenthesis:!ag.isVdsIds().isEmpty() || runningVms.size() > 1 && ag.isVmAffinityEnabled() || affinityGroup.getVdsIds().isEmpty())
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() || runningVms.size() > 1 && ag.isVmAffinityEnabled() || affinityGroup.getVdsIds().isEmpty()) We don't need this condition.
we can use method call directly
we can use method reference
rename to user
It looks like the logic worked here. I would prefer to remove the if (injectedTypes.contains(parameterType)) { add(parameterType); } (and remove the else part)
It looks like the logic worked here. I would prefer to remove the if (injectedTypes.contains(parameterType) part.
It looks like the logic worked here. (and we could remove the if (injectedTypes.contains(parameterType)) { add(parameterType); }
Shouldn't we not throw an exception if the user doesn't specify an empty config file?
Shouldn't we throw an exception if the user doesn't specify an empty config file?
Shouldn't we not throw an exception if the user doesn't specify an explicit configuration?
why are you checking whether Utils.isEmpty() is true?
why are you null check here?
why are we no longer throwing an exception?
I think it's best to move this end up to the previous line so that we'll end up with a call to hitStorage.
I think it's best to move this end up to the previous line so that we'll end up with no session state.
I think it's best to do this end up with the last update?
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos auth. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos auth. Regardless, I think that the system property you discovered. should be set only if the krb5 file exists.
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use KerberosManager.krb5File.
I think it would be a bit clearer to break if part1. If part2 is not null, then return null.
I think it would be better to always return true here instead of false.
String.format would read better here.
I think we don't need to write this as strings.xml.
I think we should replace this with Files.isWindows() call.
I think we should replace this with Files.isLoadingPage()
while(it.hasnext())
while(!it.hasnext())
while(it.hasnext()){
suggestion getLog().warn("You should use the deprecated *aggregateMissingLicensesFile* parameter instead of " + reactorProjectDependencies.get());
suggestion getLog().warn("You should use *missingFile* parameter instead of " +
please use getLog() instead
Doesn't it override user decision when user de-selects this radio button?
What are these strings used?
Doesn't it override user?
Is it worth changing the variable name to "skipableContentAsObjectNode"?
Is it worth combining both with the same name?
Is it worth changing the variable name to something like getDecryptionResult?
I don't think we need this log..
I don't think we should log this here..
I don't think we need to log anything here..
onErrorMap?
onErrorMap? From a screen when onErrorMap is called I don't think we should use the ClientLogger to build these exceptions.
onErrorMap? From a screen when onErrorMap is called I don't think we should use the ClientLogger to build these messages.
We shouldn't be using putInt(String,int) here.
We shouldn't be using putInt("button", "linkId") here, right?
We shouldn't be using putInt("linkId", builder.buttonPositiveId()) here as well.
it would be nice to use a constant for "removeFromNetwork" and "targetLinks"
it would be nice to use a constant for "removeFromNetwork" and "targetLinks".
it would be nice to extract the "target" string to a constant
suggestion return Optional.ofNullable(new InputStreamReader(inputStream)).map(publicKeyURL::openStream).collect(Collectors.joining());
suggestion return Optional.ofNullable(new InputStreamReader(inputStream).map(publicKeyURL::openStream).collect(Collectors.joining());
suggestion return Optional.ofNullable(new InputStreamReader(inputStream).map(publicKeyURL::openStream)).collect(Collectors.joining());
"log.error" is redundant here, can you remove it?
"log.info" is not necessary
warn
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file trades"?
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file trades" or even saved to the trade type? It doesn't have to be ignored
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file trades" or even saved to the trade type? It doesn't have to be ignored.
Unnecessary e.getMessage()
> It's not 1.11 right. Can you elaborate? Are you sure that there is no valid version at all?
Shouldn't we swallow the exception here?
add a check that bitstreamformat is still here
check that bitstreamformat is still here
add a check that bitstreamformat is not null
Optional: better to invert equals to avoid potential NPE
to avoid duplicating code, we should extract it to class field
to avoid duplicating code, please extract it to class field
This should be List<URL>
You can use Collections.singletonList here
You can use Collections.singletonList here instead
fBot can be used here
fBot can be used
fTrace.bot()
This has to be ((String name > 0 && colon > 0 && (colon > 0 && (colon > 0? name > 0) : name
This has to be (i.e. <LINK_0>,%20java.lang.String)
This has to be ((String name > 0 && colon > 0).
let's use ternary operator here
let's use ternary operator
please use ternary operator
I would pass the boolean as a parameter, so we don't have to parse it.
I would pass the boolean as a parameter so we don't have to parse it.
I would pass the boolean as a parameter, so we don't have to parse the String manually.
Missed a space between if and (
Missed a space after if
Missed a space after if,
may be better to use ds.getName() here?
may be better to use ds.getHostname() here.
may be better to use ds.getHostname() here?
Can we switch to exception?
Can we keep the current approach?
Can we keep the current approach?
bikeshedding, but return null and then put the tid under.
do you want to use the tid system here, this is hard to understand
do you want to use the tid system here?
Should we pass the name of the line to XmlTextRange() here?
Should we pass the name of the line to XmlTextRange as well, to avoid an unnecessary conversion?
Should we pass the name of the line to XmlTextRange as well, to avoid an unnecessary assignment?
:ant: You can use player.getLibrary() instead of creating a new card.
:pencil2: No need to create a new card if it's indeterminate.
:pencil2: No need to create a new card if it's not tapped, just return true.
I don't think we want to copy the header if it's null. Please use Set-Cookie here.
I don't think we want to copy the header value here. This will be updated in the future.
I don't think we want to copy the header if it's null. Please use Set-Cookie, with the following.
Please use a try-with-resources pattern here.
Please use a try-with-resources statement here
Please use a try-with-resource pattern here.
@dalifreire join this line and the next line.
@dalifreire join this code with a logger?
Add a logger.
do we need a different test case for the two previous versions?
do we need a different test case for the actual quota?
nit: Don't need the "." in the test.
This might be wrong. Why would you need the original message?
This might not be required anymore. The message will be helpful while you are at it.
This might be wrong. Why would you need the original message here?
minor: maybe we can also update updatePartitionStateAndClusterState(partitionService, partitionService.getMaxAllowedBackupCount()) here?
minor: maybe we can also update updatePartitionStateAndClusterState(partitionService, partitionService.getMaxAllowedBackupCount()) here
minor: maybe we can also update updatePartitionRuntimeState(partitionService, partitionService.getMaxAllowedBackupCount()) here?
Do we need these escapes?
Do we need these escapes? If there's a good reason to use them.
Do we need these escapes? If not, I would prefer using them.
We should make this a unit test too: java boolean successfullyProcessed = LocalTime.now().isAfter(endTime); LocalTime startTime = endTime.isBefore(endTime);
We should make this a unit test too: java boolean successfullyProcessed = LocalTime.now().isAfter(endTime);
We need to make this method synchronized
could this method be defined as <LINK_0> and not from other methods as well?
isn't this one always true?
could this method be defined as <LINK_0>
We should never use null as default value here
We should never be sending null here
We should never return null outside the catch block
nit - move the deceleration one line up..
nit - move the deceleration one line up.. }
reorder
Who else is not atomic? ;)
Who else is not atomic? 1. You could just return here if the file doesn't exist. 2. if status is not set, there is no need to set it.
Who else is not atomic? 1. You could just return here if the file doesn't exist. 2. if status is not set, there is no need to read it.
I would think that you should have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
I think that you should have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
I would think that you should have some kind of info.
How about using a for-each loop instead of iterators?
How about using a for-each loop instead of a lambda?
I don't like this reordering the code blocks. What about all these lines?
ditto about isEmpty()
ditto about.remove()
ditto about 'final'
Catch a NPE in a few places. It's not a good idea to throw an NPE in such a case.
Could use hamcrest matchers here. They're more concise and easier to read in case of failure: assertThat(entries).getMessage(), is(null));
Could use hamcrest matchers here. They're more concise and easier to read in case of failure: assertThat(entries).getMessage(), is(nullValue()));
Would you also add an IS_NULL filter here?
Would you also be able to use an import here?
Would you mind adding an import for the Presto codebase?
Is it possible that the assigned value for parameter goes into this method, so we don't have to do it twice?
Is it possible that the assigned value for parameter goes into this method, so we don't have to pass it twice?
Is it possible that the assigned value for parameter goes into this method, which is not assigned to this variable?
nit formatting 2 spaces.
nit formatting 2 spaces. 2 spaces.
nit formatting 2 lines.
As long as we don't need for for loops, do we just pass it as a default?
As long as we don't need for for loop, we can remove the log after this.
As long as we don't need for for loops, do we just have 2 abilities for each listener?
is this supposed to be retryHolder.retry()?
is there a reason we don't check for exception here?
is there a reason we don't check is that this is retry() first?
2nd parameter should be enough. Do you know what it is?
2nd parameter should be enough. Do you want to see a reason why we do not use single event loop mentioned above?
2nd parameter is confusing.
minor: It is extremely difficult to test for this test to actually call NoSuchFieldException when the property is not set.
minor: It is extremely difficult to test for this test to actually call NoSuchFieldException when the property is not available.
minor: It is extremely difficult to test for this test case without error.
Looks like the complexity is a duplicate of the same method
Looks like the only place where this method is used is to check delegate is an error.
Looks like the only place where this method is used is to check delegate is null.
Use 4 spaces for indentation.
Use 4 spaces for indent.
Use 4 spaces.
Let's move the null checks to the.getByResourceGroupAsync(resourceGroupName(), this.name()) line above
Let's move the null checks to the.firewallRules() method below.
Let's move the null checks to the.getByResourceGroupAsync(resourceGroupName(), this.name()) line above.
since this is debug logging provide an e.getMessage() instead and re-add the placeholder.
since this is going to be called a lot, let's reduce the level here by simply checking if this is debug and not info.
since this is going to be called a lot, let's make sure the receiver can be set to null here.
can we get rid of the for loop?
Consider using a static import for GENOSQL to improve readability.
can we move this to a single location?
Can you elaborate on why this change?
Can you elaborate on why this change is necessary?
Can you elaborate on why we need 2 lists?
Please change'returnType' to 'not return an integer (not a long value).
Please change'returnType' to 'not handle'
Please change 'not' to be no longer supporting
Should we have a null check here?
Should we still be marked this synchronized?
Should we still be closing the record in the send operation?
I think it should be instances.abortProcessInstances(processInstanceList.stream().map(p -> p.getId).forEach(ProcessInstance::add);
I think it should be instances.abortProcessInstances(processInstanceList.stream().map(p -> p.getId).forEach(serviceProcessInstanceId::add);
I think it should be instances.abortProcessInstances(processInstanceList.stream().map(p -> p.getId).collect(Collectors.toList()));
toString() isn't needed here
toString() seems unnecessary here.
toString()
not sure if we should add a timeout here if the code is not inspected.
not needed
final
I know this is part of your original code, but should we rename this to path?
I know this is part of your original code, but should we rename this to path instead of content?
I know this is part of your original code but should we rename this to path?
check whether Exception throwing
check whether Nimbus is possible
check whether Nimbus is allowed
Hmm, would it make sense to add something like "BACK. PushButton.getAllFacultyMemberProfileList" to the view?
Hmm, would it make sense to add something like "BACK_QUESTION = -1;"
Hmm, would it make sense to add something like "BACK_QUESTION = -1;"?
Exception#printStackTrace goes to stderr by default.
Exception is never thrown.
should we also add a logger here?
Similar
Similar, could you rename this to logger
Similar here, we are testing this.
This message is not right.'submitting' can be removed.
This message is not clear to me.
This message is not consistent with other services.
Should this be System.err instead of System.out?
Should this be println instead of println?
Should this be System.out.println instead?
I don't understand this catch - why is it needed and not only on exception?
I don't understand this catch - why is there a particular exception we need to catch?
I don't understand this catch - why is there a particular exception and not a particularly Exception?
Why not use GatewayServerBuilder for this?
Why the java convention not use GatewayServerBuilder for this?
Why not use GatewayServerBuilder instead of GatewayServerBuilder?
Can we just use a different thread here?
Can we have a different error message for the retries?
Can we have a different error message for each case?
Nit: if (m.group(1)!= null && m.group(1)!= null)
Is it possible to have this... and use getDefault?
Nit: if (m.isDefault())
'null!= editingDomain' is always false in this case.
'null!= editingDomain' is not what we want here...
'null' must be set up on the table
Would it make sense to have case insensitive comparison in case COLON is defined?
Would it make sense to have case insensitive comparison in case COLON is empty?
Would it make sense to have a switch here?
please use assertEquals or assertThat.
for "k" and "v"
for "k" and "k"
please make this assertion before the hasSize.
please make this assertion before the hasSize. Its not the equalTo but the order of the arguments.
please make this assertion before the hasSize. Its not the equalTo but the message.
@lautarobock why not using Pattern.compile()?
@lautarobock what about using Pattern.compile() here?
@Override
can we use here.equals instead of!=?
can we use here.equals instead of ==?
can we use a regex here?
This anonymous class feels a bit awkward. Maybe have it just be projectWidgetsByName.get()?
This anonymous class feels a bit awkward. Maybe have it just be projectWidgetsByName.
This still needs to be public
Can you maybe use a Set in the returned list?
Can you maybe use a Set in the returned list instead of Arrays.asList
Can you maybe use a Set in the list of tests instead of Arrays.asList
Call this out once in the constructor instead of calling it twice
Call this out to ensure that the card is not null.
Call this out once in the constructor instead of calling it twice.
It would be even better to use UserModel.createCredentialModel(auth) here, since we know it's not actually used in any code.
It would be even better to use CredentialModel.createCredentialModel(auth) here, since we know it's not actually used in any code.
It would be even better to use UserModel.createCredentialModel(auth) here, since we know it's not just used used in other classes.
CheckForNull
Why did you change the code?
CheckForNull?
Can we make this method private?
Can we make this a case-insensitive comparison?
Can we make this a case-insensitive check?
Again, this should probably be ++ints
Again, this should be spacing
white space
Why not simply iterate over threads.toArray(threadName)?
Why is this required new threadName? I thought the threads were to be threads.
Why not simply iterate over threads.toArray(threadName)?
This isn't wrong, but the cast should be reverted.
Ditto.
This isn't wrong, but you need to fix the string version in your last review.
Is it possible to break this out into a separate file as a subclass? I think adding too much to an Activity or Fragment is tempting but once we get a third card type in will start getting a bit hazy.
Is it possible to break this out into a separate file as a subclass? I think adding too much to an Activity or Fragment is tempting but once you get a third card type in will start getting a bit hazy.
Is it possible to break this out into a separate method? I think adding too much to an Activity or Fragment is tempting but once we get a third card type in will start getting a bit hazy.
This can be replaced with getItems().isEmpty()
this can be replaced with getItems().isEmpty()
Please use getItems().isEmpty instead of getItems().isEmpty
Should we name this values something to make this values shorter?
nit: Could we please rename this to removedRegionId?
formatting
It's totally okay to have a single timeout here since the code is blocking and handles all of the factories that are really needed. If you want to limit the number of factories you could use by calling.collect(Collectors.toList())
It's for a bugfix, but it should be logged in the PR.
It's totally okay to have a single timeout here since the code is blocking and handles all of the factories that are not the same.
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos..
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos let's at least make a ticket for now.
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos, pool..
You can use try with resources
You can use return directly here
You can use try with resources here
instead you can use something like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin to see if there is no filter node
instead we should use something like: com.facebook.presto.sql.planner.TestLogicalPlanner#assertPlanContainsNoApplyOrAnyJoin to see if there is no filter node
ditto :)
The relaxedInserted is not a standard bean, we want to get all of therelaxedInsertedProperties through the relaxedInserter. As it is, we want to get all types and not relaxedInserted only.
The relaxedInserted is not a standard bean, we want to get all of therelaxedInserted properties within the relaxedPack
The relaxedInserted is not a HashMap, we want to avoid potential nulls.
I would use a plain equals here
I would use a plain equals here.
isRedundant
ContainerUtil#isEmpty
ContainerUtil.isEmpty
ContainerUtil.addproperty == null
Let's change this to Assert.isTrue(property.getType() == Long.class, "Version property %s must be of type Long.");
Let's change this to Assert.isTrue(property.getType() == Direction.class)
Let's keep the same order as above for symmetry.
This line is too long. It's not used anywhere else.
This line is too long. It's not really needed to keep it.
This line is too long. It's not really needed to keep it it.
I know this is not part of this PR but we already have getThemesChanged() in this class, but we are already changing this line. That way we can keep this in a separate PR.
I know this is not part of this PR but we already have getThemesChanged() in this class, but we are already changing this line. That way, the theme handling is something wrong.
I know this is not part of the existing, but we already have getPendingThemesChanged() from this line, but we do not want to update this PR. That way we can keep this consistent.
This is exactly the same as publishIdOptional, so please add a new method to publishIdOptional
This is exactly the same as publishIdOptional, let's add a saveRequest method to publishIdOptional
I think this is safe as you are constructing a new object and then publishIdOptional from that object. There are good ways to do this.
Extra query[offset]
Extra space
!query[offset]
Add context specific message without using e.getMessage().
Catch relevant exceptions.
Add context specific message without using e.getMessage()
Can you use StringUtils.isNotBlank here instead? Also, how about swapping lines 47 & 47 into this if?
Can you use StringUtils.isNotBlank here instead? Also, how about swapping lines 47 & 47 into this if block?
Can you use StringUtils.isNotBlank here instead?
[minor] missing braces.
[minor] missing [this?
[minor] missing braces
Would it make sense to change this to "mkdirs()" so that we don't have to check if the directory exists?
Would it make sense to change this to "mkdirs()" so that we don't have to handle the case where the files are in the same directory?
Would it make sense to change this to "mkdirs" instead?
The current code would be easier to read if it were written further: java String tempIn = getBoundingRect(); int tempTop = js.executeScript("left"); tempTop.append("top");
The current code will try to get long: <LINK_0>
The current code would be easier to read if you use "return jQueryScript" here.
nit: No need to use StringUtils.split() here.
nit: No need to use String.split() here.
Nice variable name :)
I would expect the default to be false. Don't allow remote installation.
I would expect the default to be false. Don't allow remote user to see.
I would expect the default to happen first. Don't allow remote installation.
Better to have the System.lineSeparator() to be used here?
Should this be options.getMaxRetries() instead?
Better to have the System.lineSeparator() to be used instead of \n
Can we use the org.apache.commons.lang3.StringUtils#isNotEmpty here?
Can we use the org.apache.commons.lang3.StringUtils#isNotEmpty here instead?
I believe this can be shortened to: return (sort == null? "" : key.getReverse());
I think you're totally okay, but I think you should be doing ShadowDOMUpdate.getRootElement() here, since it's a constant of the root.
I think you're totally okay, but I think you should be doing ShadowDOMUpdate.getRootElement() here, since it's a constant of ShadowDOMProvider. I think you can move this logic into a private method.
I think you're totally okay, but I think you should be doing ShadowDOMUpdate.getRootElement() here, since you are just adding a number of children. I think you should not get the extra context, but we can potentially traverse many children in different places.
I think the exception should be caught here to be more specific. Could you please modify the description of the exception?
I think the exception should be caught here to be more specific.
I think the exception should be caught here to be more specific. Could you modify the description of the exception?
Could we change this to use findPar == 0? This duplicates the call below: java if (parameters!= null) { printer.print("(i) body).getExpression().accept(this, arg); }
Could we change this block to use findPar == 0?
Could we change this to use findPar == 0?
Let's change fupackServices to include the number of nodes in the log statements.
Do we need to change this as well?
Let's change fupackServices to a separate one for clarity
Can you use a try-with-resources block here?
Would this be a RuntimeException?
Can you use a try-with-resources statement here?
Style-nit: We don't call this method with braces.
Style-nit: I'd add a null check on repo.readDirCache(repo)?
Style-nit: I'd add a null check on repo.readDirCache() in this method, and at the end it in one line.
Is the purpose of this method?
Is the reason why the unmodifiable map is not mutable?
Is the reason to keep the typemap here?
Should this fail the test? (same with other catch locations)
Should this fail the test? (same with other places)
Should this fail the test? (same with other assert locations)
java.subscribe(new Action1<ResultType> { });
suggestion.subscribe(new Action1<ResultType> { });
java.subscribe(new Action1<ResultType> { }); You can also use.subscribe(this::hide);
This should be cursor.query(...), not Pair.
This should be cursor.query(Query) not the indexOrder.
Unnecessary cast.
I guess this should be private Gen<Tuple2<T>> Gensperse(Gens._2, generatorss.setAndGet(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._1.apply(generators._2, generators._2.apply(random);
I guess this should be private?
static import
Add a static import for Mockito.when here.
Can be simplified to Mockito.when(csm.getGameEvent()))
Add a static import for Mockito.verify
assuming both upper and lower are non-null, can you use == instead?
assuming both upper and lower are non-null, can you use that instead?
assuming both upper and lower are non-null
this seems like it should be sent out when you are installing a column.
this seems like it should be ==
this probably doesn't belong here?
We should have the kEvent instance as the path
We should have the kEvent instance in the call to kPathStat.recordPathStat(path) here.
We should have the kEvent instance in the call to kPathStat.recordPathStat() in case of failure
Do we need to validate the permission here or is this some other way around?
Do we need to validate the permission here or is this some other way round?
Do we need to validate the permission here or does this need to be done in the mapper?
It would be great if we could use a single session here to have a check for an inactive user.
It would be great if we could use a single session here to have some validations, like "validationInput" and "filtered".
It would be great if we could use a single session here to have a validation group name also.
are you sure it's correct to return null?
are you sure it's correct to return null? we need to handle it.
are you sure it's correct to throw an exception?
We have a few more places we used to do this. We should probably move it out into a method in Utils.java.
We have a few more places we used to do this. We should probably move it to isCached.
We have a few more places where SAP. K is the first argument to this method. This code is doing it for you.
Given that equals() returns false, it's pointless to check!= o.getEnchantments() instead of o.hideCanPlace().
Given that equals() returns false, it's pointless to check equality.
Given that equals() returns false, it's pointless to check!= o.hideCanPlace().
"constants" can be used here
"constants" is not needed here
"constants don't need to be provided here :)
nit: **Test** test helper method
nit: **should be** assertEquals
nit: Line break between arguments.
getLabelFormat().add(FontFormat.BOLD_LITERAL); might be better.
getLabelFormat().add(FontFormat.BOLD_LITERAL); will be better.
Why not have this for touch notifications?
Why not the default instance?
why not the default instance?
Why the default instance?
Hmm, is this intended to be set in the same place?
Hmm, is this intended to be set in a different way?
Hmm, is this intended to be done in a separate PR?
suggestion ConfigurableApplicationContext profile = (ConfigurableApplicationContext) applicationContext.getTemporaryFolder()? ConfigurableApplicationContext.getTemporaryFolder() : null;
suggestion ConfigurableApplicationContext getInstance = new ConfigurableApplicationContext(ConfigurableApplicationContext.class);
suggestion ConfigurableApplicationContext profile = (ConfigurableApplicationContext) applicationContext.getEvaluationContext().getBeanFactory().get(queueExpression);
Shouldn't the output need to be {"org.carlspring.strongbox.xml": <LINK_0>??
Shouldn't the output need to be {"WS", "org.carlspring.strongbox.xml" }??
Shouldn't the output need to be {"expectedChecksums":true }??
Same again here, just pass db into the method call
Same again here, just pass db into the method call.
Same again here, just pass db into the method call below
I think this can be simplified to just check for null, and have it return if it's null, so we can remove it from here.
I think this can be simplified to just check for null, and have it return if it's null, so we can remove this.
I think this can be simplified to just check for null, and have it return if it's null, like it's done in other places.
why not making a rule from this directly? It would be easier to read PREFIXED_CONSTANT), so there is no rule named rules.
why not making a rule from this directly? It would be easier to read PREFIXED_CONSTANT), so there is no rule named rules in the same tree.
why not making a rule from this directly? It would be easier to read PREFIXED_CONSTANT), so there is no rule named rules in the same place.
can call the same method from here.
can call the same method as in previous.
can call the same method as in previous class
nit: change to assertFalse(workflowByPath.contains("\"aliases\":?
nit: change to assertFalse?
nit: change to _and_
do we need this?
do we need this? I think I understand that we don't need these lines.
do you need this line?
nit: you can use the variable type as the callback instead of the anonymous class, and then use it here.
nit: you can use the variable type as the callback instead of modifying the argument.
nit: you can use the variable type as the callback instead of modifying the variables here.
The params should be valid here? (i.e. should have FEEDBACK_QUESTION_TEMPLATE_NUMBER param?)
The params should be valid here? (i.e. should have FEEDBACK_SESSION_NAME, and it should be valid)
The params should be valid here.
GENOTYPE_VALUES is a bit confusing, should it be name?
GENOTYPE_VALUES is a bit confusing, could you explain why it is not a list?
GENOLLCORFU...
isn't used...so perhaps do not set?
isn't used
@Override
ServiceException is better, as you're creating a stream stream.
ServiceException is better, as you're not throwing an exception anyway.
s/n/Payload/
Consider making this a constant for the field name.
Consider renaming m.getResponseXML() to toString()
Consider making this a constant for the field being initialized in the constructor.
You need to remove all the parts about property and instead look for other nodes in the metadata.
You need to remove all the parts about property and instead look for other nodes in a metadata.
You need to remove all the parts about property and instead look for other nodes in this path.
We should probably move a separate catch block for this.
We should be able to continue using Preconditions of a null object for a style group.
We should probably move this check into BitmapFJld.
Change this to log
log and get rid of this line
add the new error message
Maybe we could move this check to the if condition as well.
Maybe we could move this check to the method instead of this if condition.
Maybe we could move this check to the method instead of this if condition?
Release needs to happen here as well.
Should this be done with a session?
Is this required?
Why is this variable outside the while loop?
Why is this variable outside the for loop?
Why is this "colIdx"
We don't return Mono here. It's not very clear to me what this is doing.
We don't return Mono. It's not such a big deal.
We should close the Mono when it's closed.
You can just throw Exception here.
You should throw Exception here.
You can throw Exception here.
maybe we could use: for (int i = 0; i <...; i++) {... }
maybe we could use: if (myAlgorithm == null) { return; }
maybe we could remove this variable?
I think this should be Object -> List<>()
I think this should be a List<User> rather than a List<>();
should probably return UnulpritIds().size()
Humm, JournalData is not really the place to log errors, so I think this should just be JournalData.
Humm, JournalData is not really the place to log errors.
s.a.
Inside the if you use an else, you use two lines with the same name. Seems like it should be a temp variable
Inside the if you use an else, you use two lines with the same name. Then you won't have the if/else, and the log lines in cleanup.
Inside the if you use an else, you use two lines with the same name. Seems like it should be a temp variable, and then use an if statement below
You should probably use getRenditions directly to the last one. See for example redirectResolverContributions / redirectResolver in DownloadServiceImpl.
You should probably use Renditions.getCoreSession() to do the actual conversion of PDF through the rendition definition (and so use the whole chain Image.copy().
You should probably use Renditions renditionEntity
We shouldn't catch interrupted exceptions, but just return false (instead of swallowing it)
We shouldn't catch interrupted exceptions, but just return false (instead of swallowing it).
We shouldn't catch any exceptions, but do we want to have a case where we call consume() on a failure, wdyt?
I suggest to extract "Cruntfile.js" into a constant since it is used in many places
I suggest to extract "Cruntfile.js" into a constant since it is used in many places.
I suggest to extract "Cruntfile.js" into a constant since it is used in other places.
Move this.deviceRepository( 'X') to a constant
Move this ) to a constant
Move this ) to a constant'static' class
Returning null here seems unnecessary, because the action was not disposed.
Returning null here seems unnecessary. The caller never knows if the repository is not disposed.
Missing @Override
Why we want to include the profile info and error in the message for debugging?
Why we want to set the environment to null and then let it go to debug?
Why we want to include the profile info and error in the message?
Should be isEmpty()?
Should be one level deep.
Should be Collections.emptyList() instead
This is too much of a hack, it could be done once in the constructor, and then used in each of the JSONArray methods.
This is too much of a hack, it could be done once in the constructor, and then used in each callback for other decoration types.
This is too verbose, too.
we can directly use mapPointFrom(symbol, null)
we can directly use mapPointFrom(symbol, expression)
we can use Log.d
Would it make sense to add check for BYTE_ARRAY as well?
Would it make sense to add check for double and float values as well? I'm not sure how much this will be called for every number.
Would it make sense to add check for double and float values as well? I'm not sure how much of this will be called for every number.
This really isn't the right way to go. Use getLeaf() to get the refs from HEAD and getLeaf() to get the ref.
This really isn't the right way to go. Use getLeaf() to get the refs from HEAD and getLeaf() to get the precise position.
This really isn't the right way to go. Use getLeaf() to get the refs from Ref.
I think we want to use waitingsession here instead of time to wait for the timeout to be longer than timeout.
I think we want to use waitingsession here instead of time to wait for the timeout to be longer than System.currentTimeMillis()
I think we want to use waitingsession here instead of time to wait for the timeout to be < endTime
It looks like you can remove the paramsProperty variable and return paramsProperty directly.
It looks like you can remove the paramsProperty variable and return paramsProperty.
It looks like you can do paramsProperty.get(key) once and then reuse.
Could we refactor these long and big if/else into a single return?
Could we refactor these long and big if/else into a single line?
Could we refactor these long and big blocks to use a single line?
It is worth including the path of the file.
It is _only_ the path of the file. Please use it here.
It is _only_ the path of the file. Please use the path constant.
Does this work for all processes that have a 'equals'? You end up with two issues here.
Does this test fail on windows?
Does this test work without your changes?
use style provided with callback instead
add style as parameter to clarify
add style as parameter to clarify style
this is important for backward compatibility, we should not support indexes.
this is important, but it seems to be consistent with other indexSpec implementations (getNGeometry, IndexSpecs)
this is important, but it seems to be consistent with other indexSpec implementations.
Please factor this out into a separate method something like createJsonWithStatus or so.
Please factor this out into a separate method something like requestsList and records that we don't have a dead code
Please use ids that are somewhat easier to read.
This test is OK, but it looks like it doesn't have to do this.
This test is OK, but it looks like it doesn't use the new method.
This test is OK, but it doesn't assert that the name of the method is tested.
nit: can you name the delta version as.
nit: can you name the delta version as.size()?
nit: can you name the deltaUuid to be consistent with the name?
Throw a warning if lhs is not null
This should be lhsPosition.isLhsNull().
Returning null is not necessary
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages. I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages. This kind of weird behavior in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
You forgot to update storageUsage(...)
You should remove the return from storageUsageFromPath.
You forgot to update storageUsageUsage(...)
Why is this being equals? If so, is there a reason we need to make the comparison unique?
Why is this being equals? If so, is there a reason we need to stick with the original properties?
Why is this being equals? If so, is there a reason we need to make the comparison first?
please rename the variable. It is not used anymore.
No need for the + "" as this is not needed
please rename: getRam()
I don't think you need the storageUsage.setInt() call here in a finally block.
I don't think you need the storageUsage.setInt() call here since you are doing the no-op.
I don't think you need the storageUsage.setInt() call here since you are doing the no-time check.
nit: don't need this variable. It is used only once.
nit: don't need this variable. Is it used anywhere else?
nit: don't need this variable. It is used only once below
notification should be built in new BigDecimal
why not negate?
notification should be built in threads
This also doesn't help much with log errors. It would be better to have a log entry, such as log.error("Unlame Pinot found", e); Activator.log(message, e);
This also doesn't help much with log errors. It would be better to have this return a job name, and in case there are multiple unrelated files.
This also doesn't help much with log errors. It would be better to have a log entry, such as log.error("Unlame Pinot found", e); maybe?
return CompletableFuture.completedFuture(null); I think it's better to use a variable for the return value of the catch block to simplify the code.
return CompletableFuture.completedFuture(null); I think it's better to use a variable for the return value of the catch block to simplify the code a bit.
return CompletableFuture.completedFuture(null); I think it's better to use a variable for the return value of the method.
It's possible that the user can't have random prefix. A better name might be something like otherUser, randomFilePathForUser and/or existingUser.
It's possible that the user can't have random prefix. I don't think that's a good idea.
It's possible that the user can't have random prefix. I don't think that's a good idea to keep it as small as possible.
username can be null.
Log exceptions should be handleed the rest.
Log exception?
Looks like we should not use org.apache.commons.lang.SuccessHandler here, e.g. (or org.apache.hbase.shaded.protobuf.generated.ClientUtils.SKIP_REMOTE_LOOKUP))
Looks like we should not use org.hibernate.validator.SKIP_REMOTE_LOOKUP_MODE_LOCAL here. Rather than org.hibernate.search.shaded.protobuf.generated.ClientUtils.isSuccessHandler() I return a boolean instead of a boolean.
Looks like we should not use org.hibernate.validator.SKIP_REMOTE_LOOKUP_MODE_LOCAL here. Rather than org.hibernate.search.shaded.protobuf.generated.ClientUtils.isSuccessHandler() I'm a bit too :D
I don't think it's necessary to have ____TS(...) test separators inside the testAccessControl method. The reason is that it will make the test easier to read.
I don't think it's necessary to have ____TS(...) test separators inside the testAccessControl method, as it is doing the same thing.
I don't think it's necessary to have ____TS(...) test separators inside the testAccessControl method, as that is what the test does.
This is wrong, the message should be 'new GerritCallback()'.
This is wrong, the message should be localized
This is wrong, the message should be 'this'
1. print the exception stack trace (e.g. "Not adding extended policies with list = PolicySpec.create(policy.getClass(), "policy"); PolicySpec.create(policy);
1. print the exception stack trace (e.g. "Not adding extended policies with list = PolicySpec.create(policy.getClass(), "policy"); PolicySpec.create(policy);?
1. print the exception stack trace (e.g. "Not adding extended policies with list = PolicySpec.create(policy.getClass(), "policy") 2. I'd be consistent with the message that passed in the policy.
This can't be cached due to value.get(i) being used for the case where value is less than ObjectType.FDigest, so it should be the default case.
This can't be cached due to value.get(i) being used for the case where value is less than ObjectType.FDigest, so it should be the default conversion.
This can't be cached due to value.get(i) being used for cases where value is a String.
We should use the commons-lang3 assertEquals.
We should use the commons-lang3 assertEquals(....)
We should use the commons-lang3 assertArrayEquals here as well
Just return here to avoid having so much "if" statements for readability reasons.
Just return here to avoid having so much "from interface" statements for our app
Also, return false here?
It might be a whole lot easier to just use logger.error() here rather than trying to report all the objects in an exception.
It might be a whole lot easier to just use logger.error() here rather than trying to report all the stack trace.
It might be a whole lot easier to just use logger.error() here rather than trying to report all the stack trace on the stack.
I think that it is better to put the error message in the log, as it is a warning.
I would change this to trace or debug log.
I think that it should be the same, as before
Please use lambdas to make this more readable
Please use lambdas instead of stream.
Please use for loop instead of collect(...)
why do we need this?
why do you need this?
why do you need the similar check here?
Is using mAdConfig here make sense? We should use banner size that returned in VungleBannerAdapter#getSupportedAdSize().
Is using mAdConfig here make sense? We should use banner size that returned in Vungle adapter.
Is using mAdConfig here make sense? We should use mAdConfig here.
findbugs will tell you there is a NPE here... as Jenkins.getInstace() is checkForNull
findbugs will tell you there has a NPE here... as Jenkins.getInstace() is checkForNull
findbugs will tell you there is a NPE here... as Jenkins.getPlugin() will throw null if it is null
Why would we want to throw an exception here?
I am wondering as to whether this is a problem. Could we just throw an exception in this case?
I am wondering as to whether this is a problem.
Nit: Add the additional check for pluginChecks ->...
Recommend adding the new method to get the plugin from k -> v.
Nit: Add the additional check for pluginChecks.getEmpty to make it more obvious
this is probably the same as the original test, why is this needed?
this is probably the same as the original test. Do we need to set it to true or false by default?
this is probably the same as the original test. Do we need to set this?
Warn log level seems to high for a normal state transition.
Warn log level seems to high for a normal state transition..
Why do you need to thenCompose here?
ignore case => don't build this screen.
HEADER_LENGTH -> firstPosition.length
ignore case.
Trivial: missing {... }
Trivial: missing braces
whitespace
Should not change this file
Should not allow RTL search strings in the app.xml
Should not allow RTL searches here.
I think it would be easier to read if.parent.getParent() is a local variable. Then you can do node.getParent().getParent() here instead of this check.
I think it would be easier to read if.parent.getParent() is a local variable. Then you can do node.getParent().getParent() here instead of this for loop.
I think it would be easier to read if.parent.getParent() is a local variable. Then you can do node.getParent().getParent() here instead of calling isLocalVariableDef.isOfType(node).
you can reuse GoFunction#getParentOfType
Please extract block in GoFormatting function
you can reuse GoExpression#getParentOfType
This works, but it looks like all the old methods create a new one. Can we have some static factory methods for create?
This works, but it looks like all the old methods create a new one. Can we have some sort of check that only the first thing we see in which a new future is added to?
This works, but it looks like all the old methods create a new one. Can we have some sort of check that only the first thing we see in which a non-null future is?
Isn't this always true at this point?
Isn't this always true at this point?
why not use!= null
Let's use a local variable here if the stack is a class member, not a class member.
Let's use a local variable here? It is only used once at the beginning.
Let's use a local variable here if the stack is a class member, not a member.
getOrDefault?
Nit: space after (
getOrDefault should handle the case properly
I think it is better to use try-with-resources here to ensure the stream is closed.
@DielsCharlier try-with-resources?
I think it is better to use try-with-resources here
This creates a new object, which means that the previous one is not used. Please use reformat: String commonURL = layerParam.stream().filter(layerParam -> layerParam.toUpperCase(col)).map(item -> String.valueOf(colParam));
This can also be changed to String.valueOf(colParam)
This creates a new object, which means that the previous one is not used. Please keep it closer to what we have in other parts of code.
Minor: if body is null, then body can be named "request".
Minor: If body is null, shouldn't we handle this case better?
Minor: useful error message
unsubscribe is redundant here.
[minor] Shouldn't this be a unsubscribe?
[minor] Should we handle this also somehow?
You can also assert the return value of the method.
Could it also check the return value?
Could also assert the return value of the method.
This should be other stuff for working item things. And it looks like a list of question widgets can be created in case of an empty answer.
This should be other stuff for working item things. And it looks like a list of question widgets can be created in case of an error.
This should be other stuff for working item things. And it seems like a good idea to have the return value here.
Why do we need this register?
Why do we need this register check?
Why do we need this register call?
Hi @xupyprmv I think we need to move the code after the PR, but I think the PR looks good to me :)
Hi @xupyprmv I think we need to move the code after the PR, but I think the PR looks good to me :) WDYT?
Hi @xupyprmv I think we need to move the code of the Chose to utils, like java.sorted(Comparator.comparingDouble(TableReference::getValue))
In the future, waiting for the status would be better.
In the case of admin-only kafka endpoints, it looks like DataException would be better.
Danger. It is not the case though.
This is wrong. You should be able to call DataUtil.createNBTData(stack) here, which will make the code more readable.
This is wrong. You shouldn't be building the data if the item is an item or a data function.
This is wrong. You should be able to call DataUtil.createNBTData(stack) here, and should be called the same way.
I don't think it needs to be in a order.
I don't think it should be in a finally block
I don't think it needs to be in a order. If we have a specific CombineHeaderFile, then I'd say.
Interface appended to variable name
Interface appended to variable name.
Interface appended to name of variable
minor: Segments for readability usually are a bit confusing.
minor: Line before {}.
minor: Line break before {}.
Place in ApplicationConstants instead.
Give getString(R.string.toString()) to the form.
Place in ApplicationUtil instead.
Add a check here to verify that the broadcastSerialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called.
add a check here to verify that the broadcastSerialDataReceived method was not called.
s/task/task/task/task/task/task/task/task/task
s/task/task/task/task/task/task/task/task
s/task/task/task/task/task/task/task
Could we provide a method that only these log messages in IgniteToBackupFaiureAndRemoveHandler?
Could we provide a method that only these log messages here?
Could we please provide a method in BackupSnapshot that checks to avoid logging and throwing an exception for the logging?
This is unnecessary, you can remove this check <LINK_0>
This check is unnecessary, you can remove this check <LINK_0>
This is unnecessary, you do not need this check <LINK_0>
I think you can take the word "quit - Print" here because it's not obvious what the user is doing.
I think you can take the word "quit - Print" here, to ease the maintenance.
I think you can take the word "quit - Print" here, to ease the maintenance. Something like "quit - Print: command line, commands,...".
Response is not closed if code below throws
Response is never closed
Response is not closed
Ideally it's right to throw an exception instead of just returning null
Ideally it's right to throw an exception instead of returning null
Ideally it's right to split the test. Lets not repeat this.
Is it ok to remove this?
Is it ok to have this System.out here?
Is it ok to use this.batches?
a random column name can be misleading. Can you check withDotSupport.get(vc.getOutputName().isEmpty())?
I think this condition can be simplified to java if (virtualColumns == null || virtualColumns.getOutputName().isEmpty()) {
a random column name can be misleading. Can you check withDotSupport.getOutputName()!= null and use a different result instead?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean).toString(),
String.valueOf(boolean)
couldn't this be handled via a similar function as the ValueValue?
couldn't this be handled via a method like HasBusyTracker?
couldn't this be handled via a similar function as the Value class?
don't use an external library (test)
don't use static method. It can be declared in other places
don't use static method. It can be declared in other tests
I believe this could easily be LOGGER.info, but would we be willing to print the exception if the app doesnt do anything? This might just print the stack trace
I believe this could easily be LOGGER.info, but would we log a warning?
Needs a space between if and (
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior.
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable, _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior.
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior. When the app resource state is corrupted, the currently seated app is not usable, so we might want to still preserve that behavior.
I think ConflictException is a better fit here
I think ConflictException is better here
should be ConflictException
Navigating again...
Navigation is performed twice here or am I missing something?
Navigating "new" here is good.
Presumably you're trying to stop the topic but have not changed from time to time. This is a fixed timeout.
Presumably you're trying to stop the test.
Presumably you're trying to stop the topic but have not changed from time to time. Why?
Use Assert.assertEquals
Use Assert.assertEquals here.
Use Assert.assertEquals instead.
TemporaryReply is an internal TemporaryReply. No need to set these properties here or do I understand that we need a TemporaryReply.
TemporaryReply is an internal TemporaryReply. No need to set these properties here.
Headers constants are not needed for this method!
You can use StringUtils isBlank.
You can use Nonce here instead of raw Nonce.
You can use Nonce here.
If job state is CANCELED we will not cancel job. This is a breaking change.
If jobCurator.merge throws an exception, it should reset the state to 0.
If job state is CANCELED we will not cancel job. This is a breaking change I'm still not sure about this.
If the value is same as bonus values in the enum then this can be removed.
If the value is same as bonus values we could just update them here and add it again.
If the value is same as bonus values in the enum then this can be removed
!ignoredConditions.isPresent()?
!ignoredConditions.isEmpty()?
missing final
Why the extra local variable?
Why the extra variable?
Why this extra local variable?
Baking this logic into RollingUpdateOpFactory this way seems a bit out of place and conflated, PR.
There's no need to do this, since RollingUpdateOpFactory is thread safe
There's no need to do this, since State.RUNNING could have been already in the list.
NullStage shouldn't be present here?
NullStage shouldn't be present here
Extract code from conditional to function?
I think you don't need to return false if the repository doesn't exist. Or if you just return false and let the Commit return null, and let the repository throw an exception?
I think you don't need to return false if the repository doesn't exist. Or if you wanted to be able to return true from a commit that you are back to the commit message and just returns false if it fails.
I think you don't need to return false if the repository doesn't exist. Or if you wanted to be able to return true from a commit that you are back to the Commit commit?
Not a property that open source HBase or Phoenix recognizes.
This is a property that open source HBase or Phoenix recognizes.
Not a property that open source HBase or Phoenix recognizes, because KTableDescriptor creates a TableDescriptor object.
Typo: Somehow an extra 'And' got introduced here
shouldn't we use seekToTimestamp instead?
shouldn't we call resetOffsetAutomatically() instead of resetSaved?
!doi.equals(nodeName)
!doi)
!doi.isEmpty()
Pry would leave the method like this and move the code in MainActivity.newIntent().
Pry would leave the method in MainActivity like this, which is a bit of indentation.
Pry would leave the method in MainActivity like this, but use the one in MainActivity like this.
Have this return an int instead of a return value? It's never used.
Have this return an int instead of a return value?
Have this return map(imageProxy -> imageProxy.getImage()) instead?
This should be a stimationsObservedRatios
This should be a synchronized block, to keep the changes out.
This should be a synchronized block, to keep the changes to this file
The name of the method would be clearer.
The naming seems more clear.
storage
Generally we should be using GTK.GTK4J instead of GTK.GTK4. Here it should be GTK4j. There is a simpler solution for this in: GTK3.14.13 instead of 3.14.0. If there is no specific reason, then please change it to: if (GTK.GTK.GTK4.GTK4) { Cairo.GTK4.tiro_rectangle = Cairo.color(GTK4); } return width;
Generally we should be using GTK.GTK4J instead of GTK.GTK4. Here it should be GTK4j. There is a reason for it it.
Generally we should be using GTK.GTK4J instead of GTK.GTK4. Here it should be GTK4j. There is a simpler solution for this in: GTK3.14.13 instead of 3.14.0. If there is no specific reason, then please change it to: if (GTK.GTK.GTK4.GTK4) { Cairo.GTK4.tiro_rectangle = Cairo.color(GTK4); } return SWT.airo.GTK4J_FAIRTairo.dest_field;
I think that the next 2 lines should be replaced with return (obj!= null && other.activeImage.equals(other.id)) && Objects.equal(activeImage, other.state);
I think that the next 2 lines should be replaced with return (obj!= null && other.activeImage.equals(other.id)) && Objects.equals(obj, other.state);
I think that the next 2 lines should be replaced with return (obj!= null && other.activeImage.equals(other.id)) && Objects.equals(adapter.get(), other.state);
We might want to make ObjectMapper a static member so that we can have all this logic in one place.
We might want to make ObjectMapper a static member so that we can have all this method return empty.
We might want to make ObjectMapper a static member so that we can have all this method return a List<RingTimeFromAttributes>
Is this enrichmentTagItem is correct? Please check that the fileItemReader is not null.
Is this enrichmentTagItem is correct? Please check that the fileItemReader is not empty.
Is this enrichmentTagItem being null?
Not sure this is worth the test in production code.
Not sure what this test is supposed to do, but can you please explain it a bit more in which testPlatform is executed?
Not sure what this test is supposed to do, but can you please explain this change?
Can we do a tmp variable instead of creating a new variable?
Can we do a tmp variable instead of calling a tmp variable?
Can we do a tmp variable instead of calling a variable?
Not sure, would it make sense to have this in a finally block to ensure that messages are sent even if an exception occurs?
Not sure, would it make sense to have it in a finally block to ensure that messages are sent even if an exception occurs?
Not sure, would it make sense to have this in a finally block in case an exception occurs?
no need I think. iccRecords is null always if uiccProfile is null.
no need I think. iccRecords is null always if uiccProfile is null?
no need I think?
On second thought, instead of JDOHelper.isDeleted, is that relevant?
On second thought, we should check for JDOHelper.isDeleted to be null here.
On second thought, we should check for JDOHelper.isDeleted to avoid node race?
move test debug log
move method
move debug log
why not reuse tempVar from line 63?
why not reuse tempVar from line 131?
Why not reuse tempVar fromTaskIdList?
Can we just do buf.hasRemaining() instead of this.buf.remaining()?
Can we just do return (buf == null) && len < off; in the try/catch block?
Can we just do return (buf == null) && len < off; in the try and finally block?
style nit: we don't use braces around single line blocks
this block of code is identical to the new method, can be removed
this block of code is identical to the block above in the if block?
Minor: Please remove final
Unnecessary get()
Minor: Please remove
I thought this should be changed tsDBMetricsRecordingTriggerThread.RUNNING and in the constructor
If you change this, you should do without the 'if' below - you should just return immediately.
I thought this should be changed tsDBMetricsRecordingTriggerThread.RUNNING and in the constructor.
I don't think this is good. If you extract to a method and also use it below.
I don't think this is good. If you extract to a method and also use it, the Externalize will not have to do the action.
I don't think this is good. If you extract to a method and also use it, the code will be simpler.
this variable name _position_, not arrayLength
Have this a block with a name "arrayLength"
this variable name _position_, not arrayLength_
Should this be in an else clause?
This should be "/", not.
This should be "/", not /.
And _can_ use ==, to be consistent.
And _can_ use ==, or equals?
And _can_ use ==, or better, to be consistent.
This is barely readable, since the menuItem view is returned by the method.
This is barely messy. Please change to a OfficeView.isSheetEmptyMap(item.getOpenedView(), menuItem.getText());
This is barely messy. Please change to a OfficeView.isSheetEmptyMap(item.getOpenedView().getOpenedView()..
Should be exchanged.
Should use constants for the "=" and "="
Should use constants for the "=".
Why not use the enum?
Why not use.iterator()?
Why do you need this?
Please use generics properly: List<Map<String, Object>> nets = new ArrayList<>();
Please use generics properly: List<Map<String, Object> nets = new ArrayList<>();
Please use generics properly: List<Map<String, Object>> nets = new HashMap<>();
Just pass in the constructor into updateTimeSince method.
Just pass in the constructor of getCacheMode(), since they are the default value.
Just pass in the constructor of getCacheMode() instead of null for the future.
Strange. Why not just have a null-check?
Strange. Why not just have a no-op the logic here?
can be null.
Can't that be shared and therefore constructed once in configure?
Can't that be shared and therefore constructed once in configure? It would be more efficient to put the parens in, to avoid the if.
Can't that be shared and therefore constructed once in configure? It would be nice to put all of these parameters into the configure method.
Can we reduce the number of returns, I think it's not necessary to use the logger anymore.
Can we make the use of empty string instead of null?
Can we reduce the number of returns, I think it's not necessary to use the logger anymore?
This should be before the switch from the previous line.
This should be on the next line, not on the if
This should be before the for loop
Same as above, but using Guava's Splitter instead of Joiner and extending the same QuotedListItem to produce an object of T via a method called like T parse(Object). In this way you'll have the knowledge of quoting inside the QuotedListIem only.
Same as above, but using Guava's Splitter instead of Joiner and extending the same QuotedListItem to produce an object of T via a method called like T parse(String). In this way you'll have the knowledge of quoting inside the QuotedListIem only.
Same as above, but using Guava's Splitter instead of Joiner and extending the same QuotedListItem to produce an object of T via a method called like T parse(Object). In this way you'll have the knowledge of quoting inside the QuotedListIemIem only.
Maybe reformat SQL here
Open-source code should never use internal names.
reformat SQL here
Could also use parent, false pattern.
Could refactor this if block into a function.
Not this pr s scope but this should use parent instead.
if.newIntValue() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the switch entirely and just do prioValue.unboxInt()..getType() is more more for when you want to query state system/attributes we do not know anything about.
if.newIntValue() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the parse below, and just do prioValue.unboxInt()..getType() is more more for when you want to query state system/attributes we do not know anything about.
if.newIntValue() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the check for when Type is null and just do prioValue.unboxInt()..getType() is more more for when you want to query state system/attributes we do not know anything about
This reminds me that we should probably deprecate this method in favor of logError. This should be localized.
This should be a singleton.
This should be a constant.
Due to the previous code, the instanceof check above is redundant, it should be extracted to a method
extract to local variable
extract to local variable?
add if (streamPosition >= null) {
add if (streamPosition < null) {
add curly braces
we don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
We don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
Don't we want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
ooh, I would have probably missed this.
ooh, you could have probably missed this.
ooh, I would have probably missed this..
Ok, better to use the [FileData holder](<LINK_0> option instead of doing it here
Ok, better to use the [FileUtils.writeFromPath](<LINK_0>
Ok, better to use the hamcrest library.
You know that this is copy/pasted from the binding.widgetAnswerText then you can just return binding.getRoot() at the bottom of the method
You know that this is copy/pasted from the binding.widgetAnswerText object you should move this to it's own method.
You know that this is copy/pasted from the binding.widgetAnswerText then you can just return binding.getRoot() at the bottom of this
When the reservation type is not available from the resource, it will always be available from the resource type. You can declare this as final and remove the field completely from the class.
When the reservation type is not available from the resource, it will always be available from the resource type. You can declare this as final and use it.
When the reservation type is not available from the resource, it will always be from the resource type. You can declare this as final and avoid the implicit =/else block below.
This should probably be "else if" since UnixSHACryptPassword is not a supported password.
This should probably be return ((key instanceof UnixSHACryptPassword) && ((SecurityUtil.class) ).equals(password);
This should probably be return ((key instanceof UnixSHACryptPassword) && ((SecurityUtil.class) ).getKeySpec(key);
should this be info?
should this be updated to true somewhere?
should this be just dir.count()
IMHO this should be DEBUG logging.
I would use the remote hostname being set.
I would use the remote hostname being null.
Do we need to do this? We have too many of these in the tests to make them easier to read.
Do we need to do this?
Do we need to do this? We have too many of these in the tests to follow.
don't need new String[] {
don't need new String[] {"}
it's not the same as the other fields?
Can we assert on the contents of the method? Otherwise this test will fail anyway
Can we assert on the contents of the method? Otherwise, this test will fail anyway
Can we assert on the contents of the methods for this test?
Can we simplify the logging a bit? Not sure if it is useful in this case.
Can we simplify the logging a bit? Not sure if it would be useful in this case.
Can we have a more explicit log message for this case?
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getTaskPaginated" or something like that. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Replace this use of "getTaskPaginated" by a separate method. [![rule](<LINK_1>](<LINK_0>
This logic is not necessary.
Should it be a void method rather than an instance?
Should it be any IndexFile?
Should it be the other way around?
Probably should be some log warning message here identifying the value was not convertable
Probably should be some log warning message here identifying the value was not defined.
Probably should be some log warning message here identifying the value was not found.
How about adding something like this: if(Objects.nonNull(title)) { return; }
How about adding some logging if it's never truncated?
How about adding some logging if it's not equal to zero?
change to error
please change to error
use error
minor: you can use CountDownLatch.await(2, TimeUnit.SECONDS);
minor: you may put a message like "assert false"
metric?
Capture of arguments and some metrics can be factorized.
Capture of arguments and some metrics can be factorized in constants.
Capture of arguments and some metrics can be factorized in other tests.
What is the difference between this change and the existingSearchLoader?
What is the purpose of the default searchIn == null? It seems like it should be the case-insensitive.
What is the difference between the two? I'm wondering if we can use a common utility method to check the cache list.
Update the error message to be more generic
Update the error message to be more specific
Update
What is this test supposed to do?
What is this test supposed to do? Did you intend to reuse it?
Do we need this property any more?
use a Readers.nextOfType(PartitionStateBindingConfig.class, (int) objectNumbers[i]
use a Readers.nextOfType(PartitionStateBindingConfig.class, GTROUBLE_MEMORY); instead we can remove isInAnyOrder()
use a Readers.nextOfType(PartitionStateBindingConfig.class, GTROUBLE_MEMORY); instead we can remove this (see isDebug())
Should it be closed with try-with-resources?
Should it be closed with try-with-resource?
Should it be closed when the connection is closed?
UnchangedCommitMessage -> UnchangedCommitMessage
UnchangedCommitMessage -> UnchangedCommitMessage.
UnchangedCommitMessage -> UnchangedCommitMessage?
do you use orElseThrow(...) here
do you use orElseThrow here
unwrap the exchange
Please update the test name to reflect the new message.
Please update the test name to reflect the new test name.
Please update the test name.
I think we need the second protected conversion?
Redundant cast.
I think we need the extra space.
This is not necessary, just get closed in the breeding method. A local map can be used to avoid reading it.
This is not necessary, we can get rid of these "s"s.
This is not necessary, we can get rid of these "sus"s.
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling.
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling.ofDefault()?
This method isn't called very often, so I think it's better if the dimension is a private member of this class, and have just one static factory method.
why not String.format?
why not String.format?
why not String.format here?
It is a bit strange that UNKNOWN_DIALECT_VALUE is a string literal here and have a constant for the 1.
There is a smalicious exception here.
It is a bit strange that UNKNOWN_DIALECT_VALUE is a string version, but no string literal is a double.
Shouldn't this method be the if (loadedHost == null) { return false; } since it's a user agent debuggable user.
Shouldn't this line be removed?
Shouldn't this method be made static?
use this? and use it later?
use this? I'm a bit confused with how it's been replaced here.
use this? I'm a bit confused with how this name it :cry:
Please double check if it's really needed.
Please double check if it's really instanceof
Please rename the variable to stack
I prefer fail-fastso first == 1, but not strong feelings
I prefer fail-fastso first == null, but not strong feelings
I prefer fail-fastso first == 1
Please use [Objects.nonNull](<LINK_0> for this method.
What is the use of Objects.isNull? I know it wasn't done in the PR, but maybe it makes sense to use it?
What is the use of Objects.isNull? I know it wasn't done in the PR, but maybe you should use it as a variable name.
please add specific error message for this action
please add specific error message for this method
please remove the new message
This logic is duplicated, please factorize it out.
Exception?
This is common to all the comparatorList.size() checks
should we log a warning here - the exception's name is misleading.
should we log a warning here - the exception's message is different from the exception here?
should we log a warning here - the exception's message is different from the exception here, or just we couldn't acquire the persistent lock?
Not sure if it is worth logging?
Shall we use debug level here?
Shall we use debug level here?
Can we put these messages into the Builder?
Can we use Enum here?
Can we put these constants into the Builder?
This would be much simpler if you extracted a method of the Activator.getDefault().
This would be much simpler if you extracted a method of the Activator.handlePluginChangeable.
This would be much simpler if you extracted a method of the Activator.log2 methods
We should check the size at this point in the beginning of apply method, then we can use the same code as visitEval.
We should check the size at this point in the ExprEval length.
We should check nullability here as well.
I believe we can use if (mFabView!= null && mFabView.isAdded()) { }
I believe we can get rid of the HandlerUtil here.
I believe we can use 'isAdded()' here.
Please combine lines 96 and 98 into one line.
Please combine lines 96 and 98 into one line. The code above only use the AsciiLineReaderIterator implementation.
Please combine lines 96 and 98 into 1 line.
Please make sure that "" is always the same as primary and not null here
Please make sure that contains() is not null, while the isEmpty() checks for null.
Please make sure that contains() is not null, while the isEmpty() is true for the latter
If no executor block exists, this will return null which even with defaults below I believe would cause an NPE.
If no executor block exists, this will return null which even with defaults below, doesn't cause an NPE.
If no executor block exists, this will return null which even with defaults below, doesn't cause an NPE. The default configuration is specified in some standard configuration.
same under_score format for the parameter here IMO
same under_score format for the message here IMO
same under_score format for the parameters
This catch isn't needed anymore?
This catch-block should only be removed.
This is addressed by <LINK_0> which is now fully acked
Isn't this the same as backups?
Can we have one return for the next 2 cases instead of: if (backupRestoreConfig.BackupVerificationSLOInHours >= 0 && backups.isEmpty())
Can we have one return for the next 2 cases instead of: if(backupRestoreConfig.BackupVerificationSLOInHours >= 0 && backups.isEmpty())
What's the reason to use String.format here?
What's the reason for this case?
What about this case?
Why this line?
Isn't this line duplicated?
Isn't this a bit high?
Findbugs will have an findbugs issue - this will trigger it. Please use the following code: if (strDesc.length() > 0) { return StringDesc; } else if (strDesc.length() > 0) { return StringDesc; } else { return indexDesc.length() - 1; }
Findbugs will have an findbugs issue - this will trigger it. Please use the following code: if (strDesc.length() > 0) { return StringDesc; } else if (strDesc.length() > 1) { return StringDesc; } else { return indexDesc.length() > 3 && pathDesc.length() < 2) }
.isEmpty()
The name "result" is a little misleading. If this is not a user-input, consider creating the predicate and return it.
The name "result" can be extracted as a constant.
The name "result" is a little misleading. If this is not a service. Use the jclouds name.
suggestion } catch (InterruptedException exc) {
suggestion all exceptions are handled by the LeaderConstructor
suggestion all exceptions are handled by the LeaderLogger.getLeaderPingableLeader()
Seed size with result.size?
To save an RPC roundtrip, could you create a new suggestservice that does both of these queries and returns the combined results instead? I think that it is important to ensure a single RPC for an oracle since it needs to respond quickly while users are typing. Additonnaly, such an oracle could perhaps already filter out the Registered and Anonymous User groups?
To save an RPC roundtrip, could you create a new suggestservice that does both of these queries and returns the combined results instead?
It would be good to throw a RuntimeException here.
Shouldn't this be: throw new UnsupportedOperationException()
Shouldn't this be: throw new UnsupportedOperationException() {
I would reformat the code in this class to avoid formatting changes in the future
I would reformat the code in this class to avoid formatting changes in unrelated classes.
I would reformat the code in this class to avoid formatting changes in the future.
do not throw Throwable: throws Exception
do not throw an exception here even if the companyTypeCode is not zero?
do not throw an exception here.
This can cause a null pointer exception when header is null
This can cause a nullpointer
This can cause a null pointer exception if the requestSize is null
Use [try-with-resources](<LINK_0>
Use [file.set()](<LINK_0> instead.
Use [file.set()](<LINK_0>
Yeah this is clearer. I'd keep the data.getFetchIntervalSeconds in the constructor and save it in a variable.
Yeah this is clearer. I'd keep the data.getFetchIntervalSeconds in the constructor and save it in the constructor.
Yeah make it clear that the data is mutable.
Style-nit: I'd prefer to write a method like this: private void get(int orig); The reason is, you're not looking for.
Style-nit: I'd prefer to write curly brackets around the ternary operator.
Style-nit: I'd prefer to write a method like this: private void get(int orig); The reason is, you're not creating a new array yourself.
can we move this to the top of the method?
Can we refactor this to be slightly more readable?
can we refactor this to be slightly more readable?
So if the mBranches.size() is null, it's not clear from the preference? What we really need is: if (mBranches.size() == -1) { builder.setCancelable(false); }
So if the mBranches.size() is null, it's not clear from the preference? What we really need is: if (mBranches.size() == 0) { builder.setCancelable(false); }
So if the mBranches.size() is null, it's not clear from the preference? What we really need is: if (mBranches.size() == 0) { builder.show(); }
int enbale = 1;
int enbale = 1; try { AccountObject accountJSON = AccountObject.ENABLE; accountJSON = accountJSONEnum.ENABLE; } finally { accountJSON = accountJSONEnum.ENABLE; }
intenbale = 1;
I think that "There was a class loader that was found by a class loader"
I think that "There was a class loader that was found by a class loader (e.g. " + expectedType).
I think we need to remove this now
For me this could be: java val val = stringToTons(keys); if (value == null) { return false; } return true;
For me this could be: java val val = stringToTons(keys); if (value == null) { return false; } return value.trim();
For me this could be: java val val = stringToTons(keys); if (value == null) { return false; } else { return -1; }
This probably isn't needed since the next statement in the synchronized block is the main thread.
This probably isn't needed since the next statement in a synchronized block is the "if" statement.
This variable is not needed
should be a print instead of System.out
should be a print here
should be a print() after the original line
IIUC, maxSize would be a better way. It might be preferable to to have an explicit iterator rather than just for (int i = splits.length > maxSize) { long nextSplit = splits.get(i); if (nextSplit == null) { break; } long nextSplit = splits.get(i); if (nextSplit == null) { break; } long nextSplit = splits.get(i);
IIUC, maxSize would be a better way. It might be preferable to to have an explicit iterator rather than just for (int i = splits.length > maxSize) { long nextSplit = splits.get(i); if (nextSplit == null) { break; } long nextSplit = splits.get(i);...
IIUC, maxSize would be a better way. It might be preferable to to have an explicit loop instead of a for-each loop.
you may want to not merge the new line. LOG.info("Skipping table {} because of {}", tableName, e);
you may want to not merge the new line. if(tblDesc!= null) { LOG.info("Skipping table {} because it {}", tableName, e); }
you may want to not merge the 3 ifs in a single line. LOG.info("Skipping table {} because of {}", tableName, e);
why are you changing the storeId information?
why are you changing this?
why public?
Should calling getSurveyInstanceDto(instance, surveyInstanceId) also be set to false? (not sure if this doesn't happen)
Should calling getSurveyInstanceDto(instance, surveyInstanceId) also be set to true
Should get survey here
Should this be extracted to a separate method?
Should this be extracted to a constant?
Why are they not asserting about the result?
Shouldn't this rather be void? public void handleContentRecovery(Node file, NodeNode file, NodeNode file) { long start = NodeNode.start(); if (nodeNode!= null) { activateUnreply(start); } else { activateUnreply(start); } builder.withText(true); }
Shouldn't this rather be void? public void handleContentRecovery(Node file, NodeNode file, NodeNode file) { long start = NodeNode.start(); if (nodeNode!= null) { activateUnreply(start); } else { activateUnreply(start); } builder.withText(true); } or so; }
Shouldn't this rather be void?
isn't it possible to share this in the constructor?
isn't this going to throw an exception?
isn't it possible to share this in the same map?
This shouldn't be needed, as the method already checks if the handlers are part of the if/else body.
This shouldn't be needed, as the method already checks if the handlers are installed.
This shouldn't be done with the user-defined message.
doesn't this line cause any issues?
doesn't this fit on one line?
does this line work?
Math.max(a, b)?
Math.max(a, 0, "BootDevice")
Math.max(a, b) -> 1
whitespace
we can merge these 2 conditions since the operation is the same in both cases (FIXME above)
whitespace question
@ivandalbosco Why not introduce a variable for the return value of sonar?
@ivandalbosco Why not introduce a variable for the return value of METHOD_INVOCATION like you did that in other places?
@ivandalbosco Why not introduce a variable for the return value of SECheckKind?
Does a compile function check instead of a compiler warning?
Does a compile function check instead of a runtime check?
Doesn't need the compile.
I think it is better to use == rather than equals to negate the condition.
I think it is better to use isGroupingKey(PARTITION_QUERY_BY_GROUPING_SETS))
I think it is better to use isGroupingKey(PARTITION_QUERY_BY_GROUPING_SETS)) instead of findAny().
isn't this supposed to be set by timezones?
isn't this supposed to be set by timezone?
Please add on the same line: Calendar.getInstance();
Can we change this to something like SenseiPluginRegistry.json().
Can we make this an enum to SenseiPluginRegistry or StandaloneA?
Can we make this an enum to SenseiPluginRegistry or StandaloneVersion?
where did you broadcast notebook = null?
where did you add notebook -> notebook -> notebook
where did you add notebook -> notebook
Can we move the member creation to a class level method?
Can we move the top line to the top?
Can we move the class definition into the top?
Maybe you could replace all these code with a call to the addField method?
Couldn't you just call doc.addField("owner") here?
Could be rewritten with a single line
Can't we directly cast this into a map?
Can't we directly cast this into a map instead of a map?
Can't we directly cast this into a Map?
What about something like this: return (opState.getNodeStatus().getOperationalState()) && nodes.add(opState.getNodeStatus().getOperationalState());
What about something like this: return (opState.getNodeStatus().getOperationalState()) && nodes.getHealthStatus()!= null;
What's the purpose of modifying it?
Why not using vm.getForce() here?
Why not use getVm() instead of vm?
Why not use vm.getForce() == null?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a little more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variables / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
This method is impossible to understand and review, full of casts and untyped methods.
do we really really need this msg temp var?
This method is impossible to understand and review, full wording.
I think this check should be moved in the [AbstractRemoteConfigurationGenerator](<LINK_0>. Arguably you will have to add this check here, but I am not 100% sure if it's necessary though...
I think this check should be moved in the [AbstractRemoteConfigurationGenerator](<LINK_0>. Arguably you will have to add this check here, but I am not 100% sure if it's necessary though.
I think this check should be moved in the [AbstractRemoteConfigurationGenerator](<LINK_0> method as well
all these exceptions have to be propagated.
all these exceptions have to be propagated to all the other places
all these exceptions have to be thrown from method.
please extract these constants
please move these constants
please extract constants
You may initialize this stream with "tar" local variable.
You may initialize this stream with "tar" local variable and use it to start processing threads.
You may initialize this stream with "tar" local variable and use it to start with "HOME"
same here: could be decided outside of the factory
same here: could be decided to use Optional if possible
same here: could be decided to use switch statement
change log message to "The file is missing"
change log message to "The file was not found for extensions"
change log message
Can you extract this to a method? There is code duplication here.
Can you extract this to a method? There is code duplication here and it
Can you extract this to a method? There is code duplication here and below.
[minor] This should be: if (response.getStatusCode() == OK || response.getStatusCode() == OK || response.getStatusCode() == OK)
[minor] This should be: if (response.getStatusCode() == OK || response.getStatusCode() == OK || response.get() == OK)
[minor] This should be: if (response.getStatusCode() == OK || response.get() == OK)
should specify an expected exit code
must specify an expected exit code
expected value is always true
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes.
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order.
Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes. newValue and oldValue are the same, so they all log messages are the same.
Three spaces here may be a bit more readable, since it's obvious that the user that they want to use.
Three spaces here may be a bit more readable, since it's obvious that the user that they need to use.
Three spaces here may be a bit more readable, since the separator is a reserved keyword.
@unyoungwax, it's not that important for this test, but this looks like it does. Can use an enum (e.g. foo openForSpecificUser(courseId, courseId, 1)
@unyoungwax, it's not that important for this test, but this looks like it does. Can use an enum and make use of the constant param to be used here.
@unyoungwax, it's not that important for this test, it fits better into multiple tests.
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
It'd probably be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too. What do you think?
I would probably rename the variable to resilienceStrategy
I would probably rename the variable to resilience.
I would probably move these two calls to the addBulk method
Access is marked as @NonNull. It's not necessary to add the null check.
Access is marked as @NonNull. It's not necessary to add an import.
Access is marked as @NonNull. It's not necessary to add the null value in the expression.
Could you please extract this piece of code in a private method, instead of repeating it in both places?
Could you please extract this piece of code in a private method, instead of repeating it 3 times?
How about putting this as a incompatiblePluginMap.computeIfAbsent(incompatiblePluginMap.values()), instead?
It's just a personal preference, but I would rather use java _periodicMetrics.instant().getRun(cachedJob.getLastRun(), true); //...
It's just a personal preference, but I would rather use java _periodicMetrics.instant().getRun(cachedJob.getLastRun(), _periodicMetrics.firstRun(cachedJob.getLastRun(), true)); so it is clearer to determine which job.
It's just a personal preference, but I don't think this is worth the simplicity of the task.
anonymous "new Image()" is a resource leak. Please use MultiModel instead.
uiManager.open() should be used instead of anonymous inner classes.
anonymous "new Image()" is a resource leak. Please use MultiTreeContentProvider instead.
I think it is better to put this in a method, because it is not obvious what is happening.
I think it is better to put this in a method, because it is not obvious what is going on.
I think it is better to put this in a method, because it is not obvious what is happening
I think that we should raise the issue only if statements.size() is a loop, to avoid the loop altogether.
I think that we should raise the issue only if statements.size() is true.
I think that we should raise the issue only if statements.size() is a loop.
Iterators are more readable
why not using for(i : i)?
Iterators are bound via iterator
extract this to a method?
extract this into a method?
extract this to a separate method?
LinkedList is not thread safe, you can use foreach instead
LinkedList is not the right alternative, you can do instead
LinkedList is just a thought
Aren't we missing something else?
So here you write it to the string, since this is the only new instance of the cookie object.
So here you write it to the string, put it into the log.
Remove (<LINK_0>
Remove (nit)
Remove (i)
I think the method name is not related to this patch, right?
I think the method name should be refactored to be,
all these can be replaced with method reference.
I think it's better to pass the parameters into createIfNotValidation instead of creating a new one.
I think it's better to keep this one.
I think it's better to pass the parameters into this method as a parameter. Then you don't have to pass the parameter again in the list.
Use binarySearch instead of Long.MIN_VALUE.
Can you add a check that locus is not null?
Use binarySearch instead of Long.MIN_VALUE
Same here: if (PageProviderService.getService(CORE_SESSION_PROPERTY, session)) {.. }
Same here: if (PageProviderService.getService(CORE_SESSION_PROPERTY, (Serializable) session) { Id too
Same here: Move this up and call the constant from normal entry
given that we might want this loop, I think we could extract the array to a local variable and initialize it in each loop. Also, this loop could be replaced with a call to clear().
given that we might want this loop, I think we could extract the array to a local variable and use that in each loop. Also, this loop could be replaced with a call to clear().
given that we might want this loop, I think we could extract the array to a local variable and use that in each loop.
Variable not used; please, remove this line.
Variable not used; please use it in these cases directly.
Variable not used; please use it in these places.
do we need to also check if util.isNull() is false here?
do a null check here to ensure util doesn't get returned
do not use util.List here
We can use newTrie<Integer>(Arrays.asList(...)) here.
We can use newTrie<Integer>(Arrays.asList(args)) here.
We can write this as return newTrie<>(newTrie.isEmpty())?
Minor: Wouldn't it be better to use some constants for "http" and " port" to be used in case some default value changes in the future? Otherwise, it does not make sense to have this default value in some places.
Minor: Wouldn't it make sense to use a default value here?
Minor: Wouldn't it be better to use some constants for "http" and " port" to be used in case some default value changes in the future?
Needs to do this for the Spring Framework: <LINK_0>
Needs to do this for the Spring  producers, and when everything is subscribed to the same client.
Needs to do this for the Spring  producers, and when everything is subscribed to the same event...
I think it is better to use try-with-resources here to ensure that we close the connection inside the finally block.
I think it is better to use try-with-resources here to ensure that we close the connection inside closed block.
I think it would be better to explicitly close the connection here.
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED'.
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()'. What do you think?
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState() > 0'. I think that this would be easier to read now but perhaps it's just me.
you could use log.debug("Non http request {}", session.getId(), session.getId()); instead of the else
you could use log.debug("Non http request {}", session.getId()); instead of the else
you could use log.debug("Non http request {}", session.getId(), session.getId());
Typo: context -> permission
Typo: context -> direct check
Typo: context -> direct prefix
Instead of adding {}, move it to if (isValidImport(code, message)) { which I think is a bit better than adding the same thing.
Instead of adding {}, move it to if (isValidImport(code, message)) { and move the check for string inside the if {}.
Instead of adding {}, move it to if (isValidImport(code, message)) { which I think is a bit better than adding the limit.
I believe this should be an interface (VolumeDriver) to avoid the need to cast to objectManager.
I think an exception should be thrown if a volume is not found.
I think an exception should be thrown if a volume is down. It's not a class.
Was this cast to TracingActor unnecessary in the first place? Otherwise I didn't catch a change that would explain why it is not needed anymore
Why do you need to cast to TracingActor unnecessary in the first place? Otherwise I didn't catch a change that would explain why it is not needed anymore
Why do you need to cast this?
nit: it seems like it isn't obvious what the Realm instance is?
nit: it seems like this is not needed?
nit: it seems like this is not needed
this is not a valid project, you should check if the packedRepo is not null before doing an empty check.
this is not a valid project, you should check if the packedRepo is not null before doing an equality check.
this is not a valid project, you should check if the packedRepo is not null before adding the same value.
This log message is a little confusing, since it's not a user's fault. Please use the word "got-" instead of "got unsupported"
This log message is a little confusing, since it's not a user.
This log message is unused.
Maybe we could move this code into KotlinMethodAdapter.findKotlinClass(baseClassMethod) and make it more readable.
Maybe we could move this code into KotlinMethodAdapter.findKotlinClass(baseClassFunction) and make it more readable.
Maybe we could rename the variable to baseClassFunction?
Can we use an appropriate message here? It would be nice to inform the admin what's wrong with the way we are expecting the operation to be scheduled.
Can we use an appropriate message here? It would be nice to inform the admin what's wrong with the server.
Can we use an appropriate message here? It would be nice to inform the admin what's wrong with the way we are expecting the exact count of rows.
We could have another method which does this in theory, and does this still search for sorted locales?
We could have another method that does this handle the case where the user-provided compat is set to the language from the ovirt-engine.xml.
We could have another method which does this in theory, and does this still look like we would have a non-null language object.
We need a timeout here at least in case of exception. Future is declared.
We need a timeout here because the test is waisd in production code.
We need a timeout here at least in case of exception. Future is declared but not async.
Missing braces.
Should this be a switch statement?
Should this be a local variable?
Not sure what to do about this. We get the stacktrace from the logs. Why is this needed?
Not sure what to do about this. We get the error message from the logger. Why would it throw it?
Not sure what to do about this. We get the error message from the logger. Why would it throw twice?
This doesn't need to be a static import.
This doesn't need to be public.
This is now unused.
Since you have fixed the problem before this line, you fixed the init/fetches methods. But you fixed it.
Since you have fixed the problem before this line, you fixed the problem: <LINK_0>
You fixed this.
Have a look at the "p" variable, and put that in a "version" class (the same for the "public" declaration). This makes the code more readable and less clear.
Have a look at the "my" feature used in the "my" support, and not the "f" itself.
Should be "p" here.
Won't this cause the test to fail if there isn't an exception?
Won't this cause the test to fail if there's an exception?
Won't this fail if there's an exception?
also do schedulerState.removeTask(...)
also do schedulerState.removeTask(..)
too many
Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open(); try { } finally { db.close(); }
Please don't assign null. I would prefer the idiom to stay explicit.
Please don't assign null. I would prefer an empty declaration.
What happens when this isn't a valid credentials?
Why this isn't static?
Why this?
You don't need the else here. You can just return String.format("%s", UNMATCHED_COLUMNS,...))
You don't need the else here. You can just return String.format("%s", UNMATCHED_COLUMNS,..."));
You don't need the else here. You can just return String.format().
You could reuse the method input[i].getFullName() here.
You could reuse the method input[i].getFullName() here. And you could reuse that in the if below.
You could reuse the method input.getFullName() here.
I would move this to a new method so we don't have to repeat this code.
I would move this to a new event.
I would move this to a new line
I like the.getNotBefore() call, but this method is basically the same. You should refactor the test if you're using it in other places.
I like the.getNotBefore() call, but this method is basically the same. You should refactor these 2 lines into a new method in the existing one.
I like the.getNotBefore() call. You're changing the behavior of the assertValidDate().
Shouldn't this be inside the try block?
I'm confused by this line. Is it really a draft change?
Shouldn't this be more consistent with 'oldResponse'?
Should we be more specific here?
Should the second parameter be debug?
Should be trace
Line 74-75 are 116. Can you change it to a [StringUtils.isNotBlank](<LINK_0>?
I think we need to check getStatus here.
Line 74-75 are 137 too.
The null check for otherStatus is not set by the other constructor, so it shouldn't be here.
The null check for otherStatus is not set to null.
The null check for otherStatus is not set by the other status, right?
I think it is possible to keep it without running other tasks.
I think it is possible to keep it without running other tasks. What about trying to do that?
I think it is better to introduce second map of the same map, such as JobConfig and use that.
We can't do it at all. What you want to do is to setRemoteCostPerPartition(...)?
We can't do it at all. What you want to do is to setRemoteCostPerPartition(...)? I'm not quite sure if it is possible to setRemoteCostPerPartition(...).
We can't do the calculation, but just use costEstimate.setRemoteCostPerPartition(...)
Nit: The variable name is a little confusing, I'd prefer the original one.
Nit:!Strings.isNullOrEmpty(es) implies!Strings.isEmpty()
Nit:!Strings.isNullOrEmpty(es)
This test is confusing, I'd rather not use the existing testComplete() method with a flag that makes it explicit that the test fails
This test is confusing, I'd rather not use the existing testComplete() method with a timeout, as we do in other tests.
This test is confusing, I'd rather not use the existing testComplete() method with a timeout.
@jomarko Are you sure it is not null? It is possible that "hasError in GIVEN" has an FactIdentifier, but no FactIdentifier is set.
@jomarko Are you sure it is not null? It is possible to call "hasError in GIVEN" and put it in a local variable, so it is more clear.
@jomarko Are you sure it is not null? It is possible to call "hasError in GIVEN" and put it in a local variable.
Does this for loop need to be made a lot more readable? That could probably be extracted to a function so you can just return the first awardAccount that meets this condition.
Does this for loop need to be made a lot more readable? That could probably be written as awardAccount = awardAccount.getCurrentLastBilledDateByInvoicAccount();
Does this for loop need to be covered?
style: no curly braces for single line statement
style: no curly braces for single line block
unnecessary space after if
Use collapsing this with the next line.
Use collapsing this, notpermutation will be true.
Use collapsing this, notpermutation will be needed.
This is an error in the case of selectFromWhereOrderBy(). I think that's what this change is about.
This is an error in the case of selectFromWhereOrderBy(). I think that's what this change is for?
This is an error in the case of selectFromWhereOrderBy().
Is this meant to be public?
Is this meant to be a duplicate of the overrides in AbstractCorreSHOutputScript?
Is this meant to be a static instance of ScriptBuilder?
nit: you don't need the local variable.
nit: consistent use of final.
nit: consistent use of.expectNext(Duration.class, message)
inline to the error message.
inline to leftPredicate
even if leftPredicate == null we should have one
nit: this should be in the new RuntimeException(e) constructor.
When we change the error message, please add a new one.
nit: this should be in the new RuntimeException(e);
Could you change this to something like: if (i.e. > "?i > "
Could you change this to something like: if (i.e. > "?i > ".
Could you change this to also include the URL?
WSO2
WSO1
WST
Why is this not a warn level? Or why is it not a warn level?
Why is this not a warn level? Or why is it not a warn?
Why is this not a warn level? Or why is it not a warn level?
same here, need to do it here too.
same here, need to do it here.
remove.
These changes are not necessary. They are covered by tests.
These changes are not necessary. They are covered by the test below.
These changes are not necessary.
The cast to MediaStore.Images.MediaColumns is not necessary in this case.
The cast to MediaStore.Media.DATA is not necessary in this case.
The cast to byte[] is redundant, can be done outside of the try block.
can we get rid of the double spacings between click listeners?
Can we get rid of the double spacings between click listeners?
can we get rid of this double spacings between click listeners?
You can put this into try block.
You can put this in try block.
Const
I would like to see it as a method that takes the FQDN and the type of the FQDN to return a Map<String, String>.
I would like to see it as a method that takes the FQDN and the entity names would be nice.
I would like to see it as a method that takes the FQDN and the type of the FQDN to be consistent.
Is there a reason not to catch InterruptedException here?
multi-catch
multi-catch here too?
Missing a space before the for loop.
Missing space before the for loop.
Missing a space before the for loop :)
This is not that useful, but in the other nodes you are not simply removing the class field and adding it to ResourceLocation.
This is not that useful, but in the other nodes you are not simply removing the class field and using a "path" field. Users might rather see a new instance of ResourceLocation (which is the same but with different providers)
This is not that useful, but in the other nodes you are not simply removing the class field and using a "path" field. Users might rather see a new instance of ResourceLocation (which is the same but with different providers) that possibly hold away when you use the same approach that you have.
Nice fix! Could you please explain this change?
Just use String.format() here and below
Just use String.format() here and elsewhere
Does the test require to call this method if it is not > 1?
Does the test require to call this method if we don't call it again?
Does the test require anything?
Can this go in RequestActionSupport
Can this go in Requester? Will this cause NPE?
I don't fully understand this. Why is this needed?
countUpTo is not required. You don't have to use primitives in the implementation.
countUpTo is not required. You don't have to use primitives.
countUpTo is not required.
Indentation is too long here. Please make a space after if.
Indentation is too long here. Let's make it a bit easier to read.
TypeSpec -> TypeSpec
This could be refactored into a for loop, but also reused below.
This could be removed and the test will actually fail as it's not activities
This could be removed and the test will actually fail as it's not possible to reach this section.
I'm pretty sure this is what you meant. You might want to test with a File object, then call premisLogger.getCoreObject() instead of folderObj.get(".")
I'm pretty sure this is what you meant. You might want to test with a File object, then retrieve it from the interface.
I'm pretty sure this is what you meant. You might want to test with a File object, then call premisLogger.getCoreObject() again.
Is this condition always true?
Is this condition correct? It seems like objectSet.get(objectSet.keySet()) is always false
Is this condition always false?
I think this should be at the end of this method. Also, I am not 100% sure this could be done in this init().
I think this should be at the end of this method. Also, I am not sure this could be a simple iteration over the iterator.
I think this should be at the end of this method. Also, emptyIterator could be required here.
We probably should use the default note here instead of false.
We probably should use the default color in this case instead of false here.
We probably should use the default locale in settings.xml instead of 0
why not using moveVm()?
why not using StringBuilder?
how about using StringBuilder?
same here: use getDeclaredConstructor().newInstance()
same here, please use getDeclaredConstructor().newInstance()
same here: use getDeclaredConstructor().newInstance()?
Dangerous use String.format here.
Probably worth doing this here.
Dangerous casting. We may be getting back to the server.
suggestion bannedStopsHardWalksOptions = clone();
suggestion bannedContainer.clone();
suggestion bannedStopsHardWalks...
Please use IllegalArgumentException here instead of RuntimeException
Please use IllegalArgumentException in these places
Please use IllegalArgumentException or better message for that
This should actually be APIException, the + should be a, and the other part should be wrapped in new Object[] { } so this gets properly localised.
This should also be APIException, the + should be a, and the other part should be wrapped in new Object[] { } so this gets properly localised.
This should actually be APIException, the + should be a, and the other part should be wrapped into new Object[] { } so this gets properly localised.
why do we need a separate forceWriteThread sleep?
why do we need a separate default timeout for 1?
why do we need a separate default timeout here?
I'm wondering if we have to continue using NIO buffers? @saudet Was there a reason for this?
I'm wondering if we should continue using NIO buffers? @saudet Was there a reason for this?
I'm wondering if we have to continue using NIO buffers. @saudet Was there a reason for this?
I don't see the difference between this and the previous one. Use just one or the other?
I don't see the point here. This is what I mean: OS1 = System.currentTimeMillis() + 1 / (sel_application.get())? 1 : 0;
I don't see the difference between this and the previous one.
We can put this on one line
Wrong map name?
Unnecessary cast needed
How about using FileStoreResolver.get(corfuDir, fs)?
How about using FileStoreResolver.get(corfuDir, int)?
How about using FileStoreResolver?
For this case, mprovedSkyCalcMethods.altit(elMin, mprovedSkyCalcMethods)) could you be doing that?
For a matter of preference, but I think we're missing a format (and I'mprovedSkyCalcMethods), because it needs to be the format check.
For a matter of preference, but I think we're missing a format (and I'mprovedSkyCalcMethods), because it needs to be the format information in the input parameters.
Is it possible for accumulator to be null? There is code below (lines 145 and 148) where accumulator.get() is called without checking isEmpty().
Is it possible for accumulator to be empty? There is code below (lines 145 and 148) where accumulator.get() is called without checking isEmpty().
Is it possible for accumulator to be null? There is code below (lines 145 and 148) where accumulator.get() is called without checking equals on it.
This message is not always very helpful, e.g. if I set "org.apache.cassandra.logging.exception.Error" then the message cryptic error (which is not always enabled) will be logged.
This message is not always very helpful, e.g. if I set "org.apache.cassandra.logging.exception.Error" then the message cryptic error (which is not a valid system property, e.g. for me). The message'sonar.python.version' will always be set to 'null' (= 2.7). Versions: 3.8.
This message is not always very helpful, e.g. if I set "org.apache.cassandra.logging.exception.Error" then the message cryptic error (which is not a valid system property, e.g. for me). The message'sonar.python.version' will always be set to 'null', as it will be always set to 'null'.
Can we set the default cases to 4 here?
Do all these switch statements need to be inside switch statement?
Do all these switch statements really need to be inside switch statement?
If this is called before the diskImageList => you will use here
If this is done inside the if, please use it instead of if/else
If this is done inside the if, please use it instead of if/else.
Throwing a RuntimeException isn't enough.
Throwing exception is a bit sensible.
Throwing exception is a bit stylistic
I guess it'd be better to set locale in Main class. I guess it's not set for unit tests.
I guess it's not set for unit tests. We actually set locale in Main class.
I guess it's not set for unit tests.
Replace with "Exception"
Replace with "Exception"?
Replace with checkArgument
The layout could be passed in the constructor.
The layout should be passed in the constructor.
The layout could probably be passed in the constructor.
can be replaced with forEach
what if replicaCounter < replicaCounter?
can be simplified to.collect(Collectors.toList())
Shouldn't this be inside NfsMountPointConstraint's logic?
Please use the formatter. The line is too long and should be broken to two
Please use the formatter. The line is too long and should be broken to two.
I would prefer to not expose this map directly to KItem
I would prefer to simply not expose this map directly to KItem
I would prefer to just store the KItem in a local variable and not cast it directly.
we still need this logic if we are not doing TS
we still need this logic if we are not doing wpcom sites
we still need this variable for getString
Since you're in BackendClusterResource, do we really need to validate the given 'null'?
Since you're in BackendClusterResource, do we really need to validate it at all?
Since you're in BackendClusterResource, do we really need to validate it?
assertTrue(node0.isReconnecting()).isFalse();
assertTrue is not necessary
assertTrue is not necessary I think
Shouldn't this be 'if (sideband) {'?
Shouldn't the message be "Invalid server error:" instead?
Shouldn't this be 'if (sideband) {' above?
change this to a default: case> default: default: // do nothing
change this to a default: checkSupported(pluginSupportedOptions, options);
change this to a default: case (Points & NORMAL),
This should be removed.
Just out of curiosity, why is this System.out required?
Just out of curiosity, why is this System.out necessary?
I'm not really sure you're iterating over this list. What about about something like: Iterator<Cell> result = new ArrayList<>(post.getPostFiltered()); result.forEach(postFilteredCellsMap.values(), endRow);
I'm not really sure you're iterating over this list. What about iterate over?
I'm not really sure you're iterating over this list. What about we think of iterating over Entry?
what's the difference between using setJcrChecks and performDetailedChecks?
what happens if there's no error?
what's the difference between using setJcrChecks and performDetailedChecks.
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume(); In the same way, you can re-use the method?
suggestion return tx.run("CREATE (v:VersionedThingWithAssigned id {id:1})").consume();
I would add e.getMessage() to this message.
I would add e.getMessage() to this exception message.
I would add e.getMessage() to this message
This is an important change that should be done by the asyncExec runnable, in which case the message should be more detailed. In a normal way of handling this, we can wait for the selection to be'multiple selections'.
this can be an 'else if'?
this can be an 'else if'
How about the user trying to enable a hook which is already enabled? Also if there are no up servers, command should fail
How about the user trying to enable a hook which is already enabled? Also if there are no up servers in the cluster, command should fail
How about we do this as well?
nl and return directly
nl and return directly.
nls
consider to use "-TMPDR" as a constant
use "-TMPDR" as a constant
consider to use "-TMPDR" as a constant?
the bug that should be included in the exception message.
the bug that should be included in the locale.
the bug report has been added to the bug report.
Please, remove "final URI"
Typo in "Uri"
Please, remove final.
I think we should avoid displaying toasts here.
Maybe we should use builder.close() here.
I think we should avoid displaying warning messages.
can it be replaced by writeAndFlush()
can this be replaced with write?
can this be replaced with write( x -> promise.isActive())?
qryProc = ((ctx) op;?
Curious why line qryProc is null?
Why?
why are we doing this?
why are we doing this multiple times?
Can this be done with.map?
Since RuleInfo#getDependencyGraph() is already called on the OperationInfoProvider, shouldn't it be simplier than to have a call to ssRuleInfo?
Since RuleInfo#getDependencyGraph() is already called by RuleInfo#getDependencyGraph(). Nodes and getInTriggerEdges() in the same order to make sure the code is not moved there.
Since RuleInfo#getDependencyGraph() is already called by RuleInfo#getDependencyGraph(). Nodes and getInTriggerEdges() in the same class, needs to be forwarded to a field definition.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a little more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a lot more readable, especially when you'll be passing in other things besides the ResponseMessage.
Is it intentional to not adding the following? if ((path!= null) && sqlType.setNull(null, sqlType.NULL)) { return; }
Is it intentional to not adding the following? if (Null.class.isInstance(path)) { return null; }....
Is it intentional to not adding the null check here?
@ivandalbosco Better to use ProjectTest file = new ProjectWrapper(project, classpath1);
@ivandalbosco Better to use ProjectTest for testing
please move to constant
The list is initialized as a default value so this change is redundant
The list is initialized as a default value so this change would be simpler
Are you sure to keep those values the same as the set of items? I would keep them unchanged
This should be done at the beginning of the method, not here.
This should be removed
This should be done at the beginning of this method, like the one above it
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return null; }
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount()!= 0) { cursor.close(); return null; }
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return null; } Also, just to be sure, is this variable really needed?
suggestion return output.toString() > 0? output.toString() : "");
@vilchik-elena Why is this needed?
suggestion return output.toString() > 0? output.toString() : "spring.profiles"
@raver119 I feel like this should have a util class of some kind?
@raver119 I feel like this should be in a PR?
Is this redundant?
Not sure if this is right. It's safe to compare to true in all cases.
Not sure if this is relevant. It looks like it's either open or not open
Not sure if this is right. It's safe to compare File object here as well.
use getId() since the node id is already known.
use getUuid instead of getNodeId
use getId() since the topology id is already the UUID?
There is no need to downcast the type on the CompletableFuture class.
Add cause or even more specific message?
Add messages to the exceptions.
Not necessary.
Not necessary to call getString(R.string.Title) twice.
Not necessary to call getString(R.string.get()) twice.
Shouldn't we be testing for expressionLiteral here?
Shouldn't we be testing for expressionLiteral here? Something like: java if (value.get(0) instanceof Expression) {... }
Shouldn't we be testing for this? Java 8 has expression :...
White space between if and (
White space between if and ( )
Missing an 'else' after this?
I would have this loop in all the test cases: ccJudgmentRepository.setCourtDivisions().toArray(int judgments);
I would have this loop in all the test cases: ccJudgments = mock(CommonCourt, commonCourt); ccJudgments = testPersistenceProfileDivisions.createCourt(); ccJudgments = testPersistence(false);
I would have this loop in all the test cases: ccJudgmentRepository.setCourtDivisions().removeAll(Collections.singleton(i));
Isn't it possible to get the string for android.graphics.PointF here because it's a special type? And I don't think that's a good idea to make it null-safe
Isn't it possible to get the string for android.graphics.PointF here because it's a special type? And I don't think that's a good idea to make it null-safe...
Isn't it possible to get the string for android.graphics.PointF here?
Since you are creating a new service, why not just create a regular test case?
Since you are creating a new service, I think it would be good to have them as a function that returns a account here.
Since you are creating a new service, I think it would be good to not create an inner class here.
I always think the 2nd argument should be goGraphResult
I always think these two methods should probably be moved down
I always think these two methods should be moved down
This variable is unused
Typo: should be 'a'
Typo: should be'server'
I think you can do this more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x -> StringUtils.isNotBlank(x.getValue())).findFirst().map(Field::getValue).ifPresent(metaBuilder::setAbstract(x.getValue()));
I think you can do this more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x -> StringUtils.isNotBlank(x.getValue())).map(Field::getValue).ifPresent(metaBuilder::setAbstract(x.getValue()));
I think you can do this more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x -> StringUtils.isNotBlank(x.getValue())).findFirst().map(Field::getValue).ifPresent(metaBuilder::setAbstract(x.getValue())));
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes)
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes)...
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes) As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes)
This exception is not thrown in the method, which is handled below. Wouldn't it be better to "throwExceptionIfResultNotOk" instead?
This exception is not thrown in the method, which is handled below. Wouldn't it be better to "throwExceptionIfResultNotOk" instead of "replace keys on device elements"?
This exception is not thrown in the method, which is handled below. Wouldn't it be better to throw or at least log a warning?
Is this the only line needed when you have a StringBuilder?
Is this the only line needed?
Is this the only line needed when you have a string?
the profile should be StringUtils.commaDelimitedListToStringArray(profile)
the profile should be StringUtils.commaDelimitedListToStringArray(profile))
the profile should be added to the ArrayUtils.isNotEmpty.
What does this look like? Since it is called to stop multiple times, I think it would be better if we add a LOG.warn("Trying to start Transcriber while it's hit.");
What does this look like? Since it is called to stop multiple times, I think it would be better if this isn't called multiple times.
What does this mean? Since it is always true?
I'm sorry, but can you explain why it's necessary to throw an exception here?
I'm sure you're getting this again.
I'm not sure why this is necessary. We already have a map of learnersos Response
At this point, it would be better to move these to resources.
At this point, you could move the initModel call to the modelModel into the queryModel, so the property can be set to null.
At this point, it would be good to move the start of the query Model into the localizable class, so that the method can be tested elsewhere.
Shouldn't this be checked only in case cluster is secure?
Shouldn't this check be checked only in case cluster is secure?
Shouldn't this be checked only in case cluster is secure?
are you sure it is not null? you could use Arrays.asList
are you sure it is not null? you can use Arrays.asList
are you sure it is not null?
I don't think you need to keep this value in the test.
I don't think you need to keep this value in the test. It's used for the BeforeEach.
I don't think you need to test that the big date is equal, but for the value of nanos should be left out.
as above, need to enhanceRemotes
as above, need to have the inputStream and the class name
as above, need to have the enhanceRemotes
This test should be written as: assertThat(AvroUtils.isString(AvroUtils.isString(Schema.STRING)).isString(Schema.STRING);
This test should be written as: assertThat(AvroUtils.isString(AvroSchema.Type.INT_STRING, StandardCharsets.UTF_8).isString(Schema.STRING))
We should have more assertions here.
Why not use the primitive long initialDelay parameter as the initial delay?
Why not use the primitive long initialDelay parameter as the return value?
Why not use the lower bound here?
or just equals?
or do we need to make sure it is not the right place? calling client.introspectAccessToken("error", " + token);
or just equals()
If this screen is gone, then it'd be good to call this function in onDestroy().
Will this call happen in onMeasure in this view? Requesting layout during a layout pass.
If this app is mutable, then we should use setImageDrawable instead.
You can change the behaviour of the saveFeatureData to a variable to remove the duplication.
Why did you change the behaviour of the saveFeatureData, but here you just did it for the featureStream?
You can change the behaviour of the saveFeatureData to support the feature types.
this should use an actual value and assert that the refund stores this value
I think it would be clearer if the value returned by the createValidRefundAsRefundedRefunds were retrieved from the Lambda as well: java return RefundCalculator.createValidRefundedRefunds(createRefundedRefunds( refund1, refund2, refund3.getStatus(), refund2.getAmount());
I think it would be clearer if the value returned by the createValidRefundAsRefundedRefunds were retrieved from the Lambda as well: java return RefundCalculator.createValidRefundedRefunds(createRefundedRefunds( refund1, refund2, refund2, refund3.getStatus());
Use Rule-Encoding: java char[] bytes = new String("Content-Type"); out.write('\n');
Flush out please.
Use Rule-Encoding: java char[] bytes = new char[a.txt] JREOR
We should use curly brackets.
We should use slf4j parametrization instead of concatenation.
We should use slf4j to log properties.
The expected order is different. expected is always the same.
The expected annotation should not be here.
The expected order is different. expected is fine.
Remove the redundant null check
static import?
static import
style nit: no braces around single line blocks
style nit: extra space
extra space
It is not necessary to assert on expectedVersion.
It is not necessary to assert that expectedVersion is not null.
It is not necessary to assert that expectedVersion is not null. The assert should probably be on the line above.
Nitpick: this should be java if (log.isTraceEnabled()) { throw new PersistenceException(fe.getLen(), keyLen fe.keyLen, keyLen fe.keyLen, fe.keyLen); }
Nitpick: this should be java if (log.isTraceEnabled()) { throw new PersistenceException(fe.getLen(), keyLen fe.keyLen, keyLen ); }
Nitpick: this should be java if (log.isTraceEnabled()) { throw new PersistenceException(fe.getLen(), keyLen fe.keyLen, keyLen fe.keyLen, likewise method.
Might be good to wrap this in a log statement in case response is null.
Not sure to include data in the log.
If data has been read, suggest using!= vs.!=
![MAJOR](<LINK_1> 'Severity: MAJOR') Refactor this method to not always throw at most one. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Refactor this method to not always return at most one. [![rule](<LINK_2>](<LINK_0>
same, extract constant
createOrUpdate is better?
createOrUpdate returns the value that belongs to the Request
createOrUpdate is a bit better?
Can you remove this duplicate code (and the one below) as well?
Can you move this to method call?
Can you remove this duplicate code (and the one below)?
Either move this to a Util class and call it infinite time, or you should do something like that.
Either move this to a Util class and call it infinite recursion loop
Either move this to a Util class and call it infinite recursion loop.
if you are sure you should log this exception?
if you are sure you should log this error?
I would log this exception too.
Maybe there should be a baz property here that isn't included?
Maybe there should be a baz property here that isn't included? I'm not sure, but we should make it work.
Maybe there should be some constants for the old tests?
View.edit() should not return a boolean, the impact should be able to avoid boxing/unboxing.
View.edit() should not return a boolean, the impact should be able to avoid that deep nesting and the code can be avoided.
View.edit() should not return a boolean, the impact should be able to avoid that deep nesting.
suggestion List<Principal> roles = new ArrayList<>(principalName);
suggestion List<Principal> roles = new ArrayList<>()
suggestion List<Principal> roles = new ArrayList<>(principal.getId());
Brace next to class definition please.
A little bit strange to read. Can you create a new sessionVariables with three keys instead?
Brace next to class variable?
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate.
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid CertifcateMessage" would be more appropriate.
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate?
I think it would be nice to check whether the assetSources.getNormalisedAsset is an empty content and an exception if it's not a legit
I think it would be nice to check whether the assetSources.getNormalisedAsset is an empty content and an image (of which I would check the constructor).
I think it would be nice to check whether the assetSources.getNormalisedAsset is an empty content and an image (of which I think is a small)
We shouldn't be catching all exceptions, even if just one, we could.
We shouldn't be catching all exceptions, so we could just do a RuntimeException like this.
We shouldn't be catching all exceptions, so we could just do a RuntimeException ;)
We can have a test that verifies the expected number of elements is as expected.
We can have a test that verifies that the expected number of expressions is expected.
We can have a test that verifies the expected number of expressions is expected.
I think this probably should be split in several lines.
I don't think this is a good idea.
I think this probably should be warn
Need to be version checked for GTK 3.6 or newer.
Need to be version checked for GTK 3.6 or newer. But this version is still backwards.
Need to change this method to throw RuntimeException if isRTL?
I would say that it's better to use a loop
I would say that it's a better practice
I would go for better readability
Is this really needed?
Is there a test for this method?
Is this part of the logic changed?
Just a nitpicking: do you need the cast to ConditionalBuilder so that you can get rid of the cast on ConditionalBuilder.
Just a nitpicking: do you need the cast to ConditionalBuilder so that you can avoid the cast to ConditionalBuilder?
Just a nitpicking: do you need the cast to ConditionalBuilder so that you can get rid of the cast.
Can you please rather throw this exception? I think this would not be possible and wouldn't be.
Can you please rather throw this exception? I have a look at this code.
Can you throw a RuntimeException here instead of testing the state?
What happens if we call driver.create and then ignore? Will the app not obtain the data from the DictionaryType..?
What happens if we call driver.create and then ignore? Will it be called again?
Why are we calling.copy() at the same time? What about just making sure we don't have to rely on the data in the DictionaryType.
Consider wrapping these lines, to make it clear what we are doing.
Consider declaring dataContainer.size() as final.
Consider wrapping these lines, to make it clear what we are checking.
This seems like a bad change.
This is for CRCancelled
This seems like a bad idea to me. It should be UpdateDuckModule
Lets not do this, I know this is for debug purposes but you should have a single log file.
Lets not do this, but in the case of image loading, we should use the else block
Lets keep these debug logging
I don't see any reason for this test to be failing if Jenkins is stopped.
I don't see any reason for this test to fail if Jenkins is stopped.
I don't see any reason for this test to fail if Jenkins is not running?
Do we need this assert? I'd only check for srvcProc instanceof srvcProc instanceof srvcProc
Do we need this "srvcProc instanceof srvHistos" check here?
Do we need this assert? I'd only check for srvcProc instanceof srvcProc instanceof srvcProc is not null.
I think this needs to be an else if (regkey == null) { // throw new RedirectResult(Const.ActionURIs.COURSE_SESSION_PAGE, student.
I think MISSION_EDIT_PAGE should be changed to be consistent with the other permissions.
I think this needs to be changed.
We don't need this try-catch, just let it throw exceptions.
I think try-with-resources is better.
We don't need this try-catch at all, just let it throw exceptions.
mavenProject is a bit more readable name
mavenProject can be final
mavenProject is a bit longer.
Please use the nfs profile settings as well.
you can use the nfs profile settings as well.
you can use the nfs profile entity, creating a new Object() method
wrong casting
correct the id
correct the casting
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to be the same with and without it?
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to have the same code twice?
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to have the same code as the next line?
you can use this instead of calling createLabelAreaDialog
you can use this instead of calling createLabelArea...
you can use the constructor
please move the code below the initEmulatedMachinesNonOperational
please move the code below the initEmulatedMachinesNonOperational method
please move to separate patch
I think we need to override handleDirectory()
I think we need a better structure. For example declare dateFormat as RepeatStatus execute();
I think we need a better structure. For example declare dateFormat as date correct.
Unnecessary when the string is the same.
Unnecessary when the string in the same line: String msg = gw!= null? new RevisionInfo.substring(1);
Unnecessary when the string is the same, the string will be the same.
throws BindingConfigParseException
throws BindingConfigParseException But that should be thrown as such.
throws BindingConfigParseException if a field is missing.
Shouldn't this line be in <code>if (i.e. below) {? If we want to fall back to the defaultFitness name then shouldn't it be allowed?
Shouldn't this line be in <code>if (i.e. below() || goals.getFitness == "true")</code>?
Shouldn't this line be in <code>if (i.e. below() || goals.getFitness == 'true')</code>?
Use NUM_CASE
Use NUM_CASE constant?
Use 4 space after }
there is no need to declare childPath as an argument. Just can be sure that the parent path is the right one.
there is no need to declare childPath as an argument. Just can be sure that the parent path is the same as project name.
you are missing spaces between if and (
ImportExpr
Import?
Import and GuiFunctionalException?
Can you remove this is redundant
Can you remove this is redundant?
Can you remove this?
Maybe we could avoid the final int wheelchairEncoder, which is not needed for tests?
Maybe we could avoid the final int wheelchairEncoder, which is called with a function. And then we can get rid of the final param.
Maybe we could avoid the final int wheelchairEncoder, which is called with a function. And then we can get rid of the final param?
Why is this needed? It's not called directly on your call.
Why is this needed? It's not called from doRefreshing logic.
Why is this needed? It's not called from doRefreshing() as well
Can't we use parent.setClip(false)? And get rid of the similar null check.
Can't we use parent.setClip(false)? And get rid of the similar 3 lines above?
Can't we use parent.setClip(false)? And get rid of the similar for the above?
Can c4db be null?
Would this be better named c4DBChanges?
Wouldn't this be easier to read if the loop was replaced with c4DBChanges?
Is the check outside of the master? If so, what will happen if the schema is null?
Why is the check inside the constructor? Also, is this for size > 0 not a check?
Is the check outside of the master? If so, won't the code return null be the best?
Now that we check for empty set, we don't need the for loop.
mgrsToUpdate.isEmpty()?
Now the result of mgrsToUpdate is removed? It will be empty if display is empty.
This could be a private function then in-line it rather than creating a local boolean variable e.g. Response.ok()? Response.Result::isHealthy(Map<String, Boolean> results) { return results.values().stream().allMatch(HealthCheck.Result::isHealthy); } I'll stop here since Oz has reviewed the rest. This isn't mandatory, it works and makes sense as-is.
This could be a private function then in-line it rather than creating a local boolean variable e.g. Response.ok()? Response.Result::isHealthy(Map<String, Boolean> results) : Response.ok(); private boolean allHealthy(Map<String, Boolean> results) { return results.values().stream().allMatch(HealthCheck.Result::isHealthy); } I'll stop here since Oz has reviewed the rest.
This could be private I think
In the case of null, it can be null. I suggest to explicitly check queryContext.get()!= null.
In the code base, it is possible that queryContext.setNumBytes() will be null. I don't think stats can be null.
In the code base, it is possible that queryContext.setNumBytes() is called from all the stats table. That means, when the query is added to all the stats table always get stored.
Why not mock the DAO to return null in this case?
Why not mock networkCenterDao.getCenterDao()?
Why not mock networkCenterDao.get(any(Guid.class));?
Rename task. It's not used anywhere.
Rename task. It's not used anymore.
Rename task. It's not used.
Minor: can move this line down to the top, with getUploadStatePartNumber() call.
Minor: can move this to a separate PR, with a more descriptive name.
Minor: can move this line down to the top, with getUploadStatePartNumber() method.
I am not sure about this part. It would be better to have a custom error message to show the web app
I am not sure about this part. It would be better to have a custom error message to show the reason
I am not sure about this part. It would be better to have a custom error message to show the web app (server or error)
instead of duplicating the code, could you create a method, e.g., String getFilteredString( probe, mapOwner, defaultProperties) { return Optional.empty(); }
instead of duplicating the code, could you create a method, e.g., String getFilteredString( probe, mapOwner, defaultProperties) that calls the other method?
instead of duplicating the code, could you create a method, e.g., String getFilteredString( probe, mapOwner, defaultProperties) { return Optional.ofNullable(mapManager.getNodeId().getUuid()), defaultProperties); }
can be turned into field: > <LINK_0>
can be turned into constant
can be turned into field layout
should be int y
should be int i
should be getgenes
I'm confused by this. groupBy.isIndexQuery only checks if the query isAggregationQuery.isGroupBy() is true, how do this?
I'm confused by this. groupBy.isIndexQuery only checks if the query isAggregationQuery.isGroupBy() is true, but the IF statement is false. So, maybe this condition should be false?
boolean apply?
This also doesn't work. The compiler doesn't auto-close the inner writer unless it's assigned to a variable.
This is interesting. I had to actually look at the implementation of StandardBaseEncoding to see that close() is not a no-op (or just a wrapper for flush()). It writes out any pending padding. As far as being a leak, it's a false positive, as neither the stream nor the writer actually holds on to any resources besides a buffer that gets GCed. I'm not opposed to fixing this, since some libraries are picky about padding. That said, the fix should actually be: try (OutputStreamWriter w = new OutputStreamWriter(w)) { src.writeTo(e); e.flush(); }
This is interesting. I had to actually look at the implementation of StandardBaseEncoding to see that close() is not a no-op (or just a wrapper for flush()). It writes out any pending padding. As far as being a leak, it's a false positive, as neither the stream nor the writer actually holds on to any resources besides a buffer that gets GCed. I'm not opposed to fixing this, since some libraries are picky about padding. That said, the fix should actually be: try (OutputStreamWriter w = new OutputStreamWriter(e)) { src.writeTo(e); e.flush(); }
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "add". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "outside" of the if statement. [![rule](<LINK_1>](<LINK_2>
what is the point of this line?
You can probably use assertFalse here.
You can use assertFalse here.
You can probably use a single assertThrows here.
I have noticed this test case. Shouldn't this be a different test check here?
I have noticed this test case. Shouldn't this be a different test case?
I have noticed this test case. Shouldn't this be a different test check something else?
We shouldn't put this condition in History.revealCurrentPlace() method. Let's put all the logic in else if.
We shouldn't put this condition in History.revealCurrentPlace() method. Let's put it in History.java
We shouldn't put this condition in History.revealCurrentPlace() method. Let's put it in History.java.
path separator?
path separator? path separator?
path separator
Hasn't the second parameter true.. is it only to be present or not?
Hasn't the second parameter true? what's the point of having a second parameter?
Hasn't the second parameter true? what's the point of having a second parameter?.
This returns an empty list. Is this intentional? We could't simply return results from the returned object.
This returns an empty list. Is this intentional? Please put that into a constant.
This returns an empty list. Is this intentional? Please put that into a constant on the left side of the mapping.
I think we need to close the resource here as well.
We have an alternative, but we need to close the resource. I think we should just throw an IOException, otherwise we get an empty object from the cache.
We have an alternative, but we need to close the resource. I think we can just throw an IOException, otherwise we get an empty object from the cache.
You didn't execute this PR, but I think it would be great to have some test cases around it
You didn't execute this PR, but it would be great to have some test cases around it
You didn't execute this PR, but I think it would be good to have some test cases around it
Suspicious log.isDebugEnabled()?
This is null if userRolesCacheEnabledString is null. So it's a breaking change.
This is null if userRolesCacheEnabledString is null. So it's best to do this check anyway.
What's the point for having this switch? If I understood correctly, the _if_ block can be removed.
What's the point of the switch, and if ("rcpp") == null?
What's the point for having this switch? If I understood correctly, the _if_ block can be removed (and I think it could be removed).
I don't think we need to check for exception.getMessage() here. This is a common pattern to throw other exceptions.
I don't think we need to check for exception.getMessage() here. This is different from the one in the above log statement.
I don't think we need to check for exception.getMessage() here. This is different from the one in the remaining log statements.
Why do you need to call it again?
Why this change?
Why do you need this change?
Do you really want to call GatewayArtifactsMgtDBUtil.getArtifactSynchronizerConnection() within the try-with-resources block? It looks like there are a lot of code which is used here.
Do you really want to call GatewayArtifactsMgtDBUtil.getArtifactSynchronizerConnection() within the try-catch block? It looks like there are a lot of code which is used here.
Do you really want to call GatewayArtifactsMgtDBUtil.getArtifactSynchronizerConnection() within the try-with-resources block?
no need, please put it in configuration file at /usr
I would have added specific config so that we can implicitly have a key to the vdc_table which may be different than the profile.
I would have added specific config so that we can implicitly have a key to the vdc_table which is unsupported
Remove the static import?
Remove the throws Exception?
Remove the double "else".
1. do we need to check if getVmManager().isAutoStartNormal() 2. we do the comparison via rest.equals()
1. do we need to check if getVmManager().isAutoStartNormal() 2. we need the if check as in the else section
1. do we need to check if getVmManager().isAutoStartNormal() 2. we need the if check as in the else branch
This isn't checking that the disks store is the same.
This isn't a test, it just prints it out.
This isn't checking that the disks store is the same. assertEquals(hal, never())?
Can we have one DAO method that does the conversion to string and then add it here?
Can we have one DAO method that sets the productHasSubscriptions to the SQL? For example, I'm not 100% sure how I feel about.
Can we have one DAO method that sets the productHasSubscriptions to the SQL?
Should we encapsulate this logic in a method, e.g., int qNameRefCount = qName.substring(qName prefix)? null : qNameRefCount;
Should we encapsulate this logic in a method, e.g., int qNameRefCount = qNameRefCount.substring(qName prefix)
Should we encapsulate this duplicated logic?
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
Shouldn't this have withOsgpException(osgpException) instead of withOsgpException(exception)? It would get rid of the Sonar complaint about useless assignment to osgpException on line 103, and make sure exception e from that catch block is passed on if it occurs instead of ignored.
Shouldn't this have withOsgpException(osgpException) instead of withOsgpException(exception)? It would get rid of the Sonar complaint about useless assignment to osgpException on line 164, and make sure exception e from that catch block is passed on if it occurs instead of ignored.
used callback style instead
used callback phenotype instead
used callback pheno callback instead
:bug: this is a problem for me. The link is called from inside a specific package and doesn't override it.
:bug: this is a problem for me. The link is called from inside a specific package and doesn't define an icon for it.
:bug: this is not a good idea.
Do we need this?
Do we need to support 'pattern' as the default for 'em-z'?
Do we need to support all of the extra spaces as well?
What about if we don't have the last element? There is no real reason for it to be an array. This will make the estimation and the size of the array.
What about if we don't have the last element? There is no such thing as checkCondition.
Also consider using the same pattern about ByteArrayOperation.
A foreground and background color should be updated.
A lambda?
A lambda
I think this is one of the reasons I chose to use the local result instead of a try/catch here.
I think this is one of the reasons I chose to use the local result instead of local variables.
I think this is fine, but the realmIdentity has already been set before we do this. I don't think it is worth to make the check here.
This and the corresponding overloaded get is not necessary. Will explain below.
This and the corresponding overloaded get is no longer necessary. Will explain below.
This and the corresponding overloaded get is no longer used. Will explain below.
add a message to this exception.
add a message to the exception.
add a message to the exception
Can you please log the exception here?
Can you please wrap this if block inside the try block?
Same here, better to log the exception.
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
As with others, I would not assert on the return value of the operation
As with others, I would not assert on the return value of the operation, only on the resilience strategy being invoked.
Instead of join, why not use java try (InputStream raw = raw.byteCountToDisplaySize(entry.getSize())) { html.appendCellHeader("last modified"); }
Instead of StringBuilder, just use appendCellHeader("last modified")
Instead of join, why not use java try (InputStream raw = raw.byteCountToDisplaySize(entry.getSize()) { html.appendCellHeader(", "); html.appendCellHeader(", "); }
I'm not quite sure this is what the else is doing. It should be something like if (geometry == null) { return unifyWindingOrder(geometry, counterClockWise); }
I'm not quite sure this is what the else is doing. It should be something like if (geometry == null) { return unifyWindingOrder(geometry, counterClockWise) result; }
I'm not quite sure this is what the else is doing. It should be something like if (geometry == null) { return null; }
Not sure why you added libraryProperties in constructor
Not sure why you added libraryProperties in code... Just do that?
Not sure why you added libraryProperties in code...
I would move this to line 184 - you can then remove this query from the patch.
I would move this to line 184 - you can then remove this line.
I would move this to line of the patch
This is wrong. You should just use the defaultPreferenceConstants.P_DUMP_NOT_FOUND
The value of this line should be switched back to the String
This is wrong. You should just use the defaultPreferenceConstants.P_ISMARKS
Should this be.toString()?
Should be toString()
Don't need this
Is there a reason we are not offering a dialog to the user?
Is this more of a safety check?
Is this a race condition?
I'd avoid using toString() if possible. Could you please change it to just use upper case?
I'd avoid using toString() if possible. Could you please use instanceof instead?
I'd prefer to use enum for better readability.
Please assign line 66 to  MismatchedTokenException.
Please assign line to a variable to avoid repeated calls.
Please assign line 66 to  MismatchedTokenException
Can we not just catch the IOException here? Maybe safer to use a more specific exception than just rethrow it?
Can we not just catch the IOException here? Maybe safer to use a more specific one?
Can we not just catch the IOException here? Maybe safer to use a RuntimeException
I don't know why this is a String?
I don't know why this is a String, isn't it a String?
I don't know why this is a String. This seems like a good candidate for a class.
We're using sub-classes of the same name.
We're using sub-classes for the same trace.
We're using sub-projects for the error view so this is the error message in the UI.
Please retain the entity column cache. EntityQueries.from(...) is a good example of external API.
Please retain the entity column cache.
Please retain the existing code style.
The old constructor is still there, why did this need to be changed?
The old constructor is still there, why did this use the old constructor and remove the old one?
The old constructor is still there, why did this use the old constructor and remove the else block?
wrap this line
wrap this block
wrap this condition
Would be nice to also ensure that the subject is closed at the end.
The [forEach](<LINK_0> is missing here?
Would be nice to also ensure that the subject is closed after the _while_
Can we re-use the overload here?
Can we re-use the getMessages function instead of duplicating this line?
Can we re-use the getMessages function instead of removing these whitespace?
A good idea to not have the test for the case where the survey is created but the first one should not be raised.
A good idea to fail the test at this point without a message.
A good idea to not have the test for the case where the survey is created but the first one should not be thrown.
Can you split this up, not the 2nd argument?
Can you please split this up into separate methods?
Can you split this up, not the 2nd one?
move this line inside the if block
move this up
move this line up
Is there a reason to use the builder instead of directly passing a CalendarContract? This applies elsewhere as well.
Is there a reason to use the builder instead of directly passing a CalendarContract? This applies to all the other methods in this class which modify the public one.
Is there a reason to use the builder instead of directly passing a CalendarContract? This methods will be used internally.
REQUEST_NATIVE and return null?
REQUEST_NATIVE and REQUEST_TIMEOUT_STRING
REQUEST_NATIVE -> REQUEST_TIMEOUT_PATH
I think!Stings.isNullOrEmpty() is more fail safe.
I believe!Stings.isNullOrEmpty() is more fail safe.
I think!Stings.isNullOrEmpty() probably more fail safe.
The closing of the int clause is unnecessary here.
The closing of the int should be on the same line.
The closing of the int clause is unnecessary.
What if limit is null? Should we throw an exception?
Move this to the previous line.
Move this to the checkNotNull so that we throw an exception if not?
I believe you have a good reason to use the Util.getUUID() as second parameter here.
I believe you have a good reason to use the Util.getUUID here. Can you use that instead?
I believe you have a new construct method
lookup for the view instead
lookup for the map contents
lookup for the writer before closing?
This code has nothing to do with the new temporary storage lookup. Can you clean this up and remove the entry if needed? The p.getProperty() will get called twice anyway.
This code has nothing to do with the new temporary storage lookup. Can you clean this up and remove the getDataStore variable when the store is properly properly?
This code has nothing to do with p2, can you remove?
I'm looking for an expert check on all these. The ones below are fine.
I'm looking for an expert check on all these Exception and. The ones below are fine.
Another fine.
Why not try to use volUUID here?
Why don't you create the taskType as a variable and use the value?
Why don't you create the taskType object as a variable and use the value?
can you print the root path as well?
can you print the arguments?
can you print the directory as well?
'hasViews' instead of 'all' here.
'hasViews()' can be called by 'checkField'.
'hasViews()' can be removed
You can extract the query variable for better readability.
You can extract the query variable for both query and query parameters?
You can extract the query variable for both query and query parameters.
use filter() instead of findAny().
use filter() instead of filter()
use filter() instead of findAny()
Should this be using a try/catch?
Should we log it as a warning?
Should we log it?
This entire method has the same behavior as Iterator<Object>, we need to extract as a method
This entire method has the same behavior as Iterator<Object>, no need to extract an extra method
This entire method has the same behavior as Iterator<Object>.
I removed this code here and the one below. Why is it needed?
if (WalletLock.isWalletLocked(walletLock)) { WalletLock.getInstance().exec(false); }
if (WalletLock.isWalletLocked() && walletLock.isWalletLocked()) {
state is started but not stopped. Nothing can stop it if lookup failed
state is started but not stopped
suggest final
Same here, no need to assign this.
Same here, no need to assign this. here, we are implied by the operator here...
We don't need this. here, the next line looks like it is adding the same functionality.
Could probably take out this if; the null checks will take care of the case where these preferences don't exist on the database
Could probably take the case where these preferences don't exist on Lollipop devices
Could probably take out this case where these preferences don't exist on Lollipop devices
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins /etc. but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
If this is needed it should be in the if (!successful) { entryDAO.delete(entry.getId(), entryDAO::delete); }
If this is needed it should be in the if (!successful) { entryDAO.delete(entry.getId(), entryDAO.get()); }
If this is needed it should be in the if (!successful)
This needs to be a log statement.
This is not going to be a log statement.
This extends the needs to be a log statement.
It could be log.info("{} seconds for {}", baseUrl, e);
Maybe log.info("{} seconds for {}", baseUrl, e);
Maybe log.info("{} seconds for url {}", baseUrl, e);
I think a banName is not the banId, but the banId is not the banId, so the banId is not the banId, but the banId is not the banId. It may be more correct to use the banId from the banId, but to the banId, not the banId.
I think a banName is not the banId, but the banId is not the banId. It may be more correct to use the banId from the banId, but to the banId, not the banId.
I think a banName is not the banId, but the banId is not the banId, so the banId is not the banId, but the banId is not the banId. It may be more correct to use the banId from the context.
I know this test is failing to change behaviour, but why do we need it?
I know this test is failing to see that we do not use the same thing in a different test. But it's fine to keep it as is.
I know this test is failing to change behaviour, but why do we need to wait 5 seconds?
assertEquals(baseDir, "accumuloConfig", "mdir");
assertEquals(baseDir, "accumuloConfig", "mdir", "mDir"));
assertEquals(baseDir, "accumulo")
s/unnecessary/boxing
s/fsckOperation/hostCommand
s/fsckOperation/numCommand
Instead of casting to an int, could we just use the returned value of theTrackableLog lhs?
Instead of casting to an int, could we just use the value returned by sorting()?
Can we ever use the drive-by Comparator here?
ClassDescriptor::contains
ClassDescriptors.stream().filter(ClassBasedTestDescriptor::isInstance).map(DefaultClassDescriptor::getName).collect(Collectors.toList());
ClassDescriptors.stream().filter(ClassBasedTestDescriptor::isInstance).map(DefaultClassDescriptor::getName).collect(Collectors.toList()); I would be safer
If If there is a problem with this config, it would be better to throw an exception here than to catch it. The whole mechanism is to catch exceptions that may be triggered by the Tasks, user (e.g. NullPointerException or OutOfMemoryError etc. I don't think that is necessary here, but those are not needed :)
If If there is a problem with this config, it would be better to throw an exception here than to catch it. The whole mechanism is to catch exceptions that may be triggered by the Manager.updateTask below, and not here.
If you're throwing an exception, don't you want to log it twice?
Why do we need to register the descriptor for the register?
Why do we need to register the descriptor for the simple registry?
Why do we need to register the feature?
The line 108-110 are going to be a heavy processing. Could you reuse the code in the other methods?
The line 108-110 are going to be a heavy processing. Could you reuse the code?
The line 108-110 are going to be more readable.
GraphQL can return response object. We should be able to query query directly from the response.
GraphQL can return response object. We should be able to query query directly from here.
GraphQL can return response object. We should be able to query query objects.
this can be moved into the "launch_count" variable
this can be moved into the warmup service.
this can be moved into Constants
invert this. java if (public Object instantiate(target, parameters)) { return multiInstantiator.instantiate(target, parameters); } return conver....
invert this. java if (public Object instantiate(target, parameters) { return multiInstantiator.instantiate(target, parameters); } return conver....
invert this
request can be null here
I think that this should be deleted
request can be null here.
Asserting the message might make this more sense.
Asserting the message might make this more readable.
Asserting the message might improve readability.
I don't think this is the right place to put this since we are either calculating the distance (which is paired with both it and the mate mapped) below.
I don't think this is the right place to put this since we are either calculating the distance (which is paired with both it and the mate mapped)
I don't think this is the right place for this since we are either returning a non-null blacklisted column or #Resolved
fix all the places as above except GET
fix all the places as above except GET.
remove line 97
I am still not the part of the PR, but this line may be moved to another class. Is it possible to have it in one place? If yes, I would prefer to have it in the PR.
I am still not the part of the PR, but this line may be moved to another class. Is it possible to have it in one place?
I am still not the part of the PR, but this line may be moved to another class. Is it possible to put it here?
Why not define it as a constant for it?
Why not define it as a constant for initialDelayMinutes?
Why not define a constant for it?
entry.toLowerCase() is not valid.
entry.toLowerCase() is not used.
entry.toLowerCase() is not used
Is the suggested declaration necessary here? If it's the same description could be made static, as well.
Is the suggested declaration necessary here? If it's the same description could be added, as it's used in multiple places.
Is the suggested declaration necessary here? If it's the same description could be added, as it's the method.
Maybe we should also log the keyIdObjectResolver as well?
s/withMessageMetadataKeyResolver/onComponentMetadata
s/withMessage("MetadataKey resolved to %s")"
I think that adding this like this makes more sense as part of the changed method signature.
I think that adding this error message is not very useful
I think that adding this like this makes more sense as part of the error message
Same here, break the loop
This is not crazy
Same here, break the method
RexProgram.isIdentity(targetProjs) is true but has a "rexNode" parameter. Or is it more readable?
RexProgram.isIdentity(targetProjs) is true but has a boolean return value from here. Or does it need a boolean to indicate that its purpose?
RexProgram.isIdentity(targetProjs) is true but has a "rexNode" parameter. Or is it easier to use the existing method here?
@Serranya same here. See above.
@essobedo same here, use throws Exception
@Serranya same here. See above. Thanks!
you can change the message to totalSize here.
formatting issue
formatting
I would instead use System.out here, like this.Async.head(int) in the test. All the others use LOG instead of System.out
I would instead use System.out here, like this.Async.head(int) in the test class: 1. use log instead of System.out
I would instead use System.out here, like this.Async.head(int)
"Could not find item..." is a better worded
"Could not find item..." is a better name.
Shouldn't this be warn?
This orElse is redundant, since we probably don't want to catch it.
This orElse is redundant, since we probably don't need the type of the method
This orElse is redundant, since we probably only need to iterate over the maven version info
Is there a reason not to use Map instead of HashMap?
Is there a reason why to use Map instead of HashMap?
Is there a reason why using Map instead of HashMap?
I know this is following code, but I'm wondering if we should use a user object: env.get("POSTGRES_JDBC_URL") (which I think is what you want)
I know this is following code, but I'm wondering if we should use a user object: env.get("POSTGRES_JDBC_USER") (which I think is what you want)
I know this is following code, but I'm wondering if we should use a user object: env.get("POSTGRES_JDBC_URL") (which I think is what the default is)
again no null check.
again no null check needed?
Again, good test
why do you need to check for null here? shouldn't it be the brick's name from the message?
why do you need to check for null here? shouldn't it be the brick's name from the parameters?
why do you need to check for null here? shouldn't it be getGlusterBrick()?
I think these two variables are not used? Can we remove?
I think these two variables are not used?
I think these two fields are not used? Can we remove?
I don't know if it should be event.getInstaller() or event.getWorkspaceId(), but I think it can be replaced by event.getOwnerId()
I don't know if it should be event.getInstaller() or event.getWorkspaceId(), but I think it can be null
I don't know if it should be event.getInstaller() or event.getWorkspaceId(), but I think it can be replaced by event.getWorkspaceId()
Could you use.join instead of.keySet() here?
Could you use.join instead of.iterator()?
Could you use.join instead of.iterator?
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackErrorCount(e, p); }... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptLong) || (e instanceof PackFile)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePackErrorCount(). PackFile.getPackErrorCount().
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackErrorCount(e, p); }... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptLong) || (e instanceof PackFile)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePackErrorCount(). PackFile.getPackErrorCount() + ": " + pack); } return tmpl; }
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I would factor it out.
You can do the check in the if statement below since getCredential() returns null.
You can do the check in the if statement below since getCredential() never returns null.
You should be checking for null here rather than throwing an exception with a check to see if the user specified an empty directory exists.
I think it should be fFields.get(field.get()) to make sure that the fields are not null.
I think it should be fFields.get(field.get()) to make sure that the fields are not null
I think it should be fFields.get(field.get()) to make sure that the fields are not null. Otherwise the string will be stored in the XML and may result in a NullPointerException.
Formatting nit (add space after if)
Formatting
Format
Could you use [File.separatorChar](<LINK_0> here?
Could you use [File.separatorChar](<LINK_0> here
Could you add getAbsolutePath() to the enum?
In general for the test purposes, you should be able to use the assertArrayEquals method.
In general for the test purposes, you should be able to use the.parseable(new Object[]{4}, policyManagerProvider.parse(session))
In general for the test purposes, you should be able to use the.parseable(new Object[]{4}, policyManagerProviderFactoryProvider.parse(session))
Could this be replaced with a call to the two-argument constructor?
Could this be replaced with: actionSet.keySet().stream().map(playerId::get).collect(Collectors.toList());
Could this be replaced with: actionSet.keySet().stream().map(playerId::get).collect(Collectors.toList())
I think this still might need to be set. In org.jboss.as.server.ServerEnvironment its still referenced, and if present used to set a deprecated variable. I haven't tested that though.
The problem with the call to setErrorMessage here is that you still need to set a deprecated method. I think this code should be moved to a new method.
I think this still might need to be set. In org.jboss.as.server.ServerEnvironment its still referenced, and if present used to set a deprecated variable.
Don't use.equals() here. Use assertEquals() like JUnit wants you to. It works now that we fixed.equals() on RevObject. :-)
Don't use RefSpec.UNINTERESTING here, FS join does that for you.
Don't use.equals() here. Use the object.
nit: I wonder if this can be simplified as: testUnifyRead(result) { return new WindingOrder(result); }... testUnifySound(this.getExteriorRing(), result);
nit: I wonder if this can be simplified as: testUnifyRead(result) { return new WindingOrder(result); }... testUnifySound(this)?
nit: I wonder if this can be simplified to assert(result instanceof Polygon.class) to remove the duplicate check.
I wonder if we could keep the null check as in the else if (this.canProcessMessage()) { }?
I wonder if we should keep the null check and move the check in the end of the if (this.canProcessMessage()) { }
I wonder if we could keep the null check as in the else if (this.canProcessMessage()) { } and move the check for null to the end of the same for all exception messages.
We don't actually need to set this in the loop. You can just make sure that the demotedContent doesn't break the loop.
We should only use the demotedContentT, so we could set it in the next layer.
We don't actually need to set this in the loop. You can just make sure that the demotedContent doesn't actually exist.
this message doesn't exist anymore, so the message doesn't need to be formatted here
this message doesn't exist anymore, so the message doesn't reflect what it contains the actual properties
this message doesn't exist anymore, so the message doesn't need to be formatted here.
@jainxrohit We should have a method for this.
@jainxha Shouldn't this line be in a finally block?
@jainxrohit We should have a test for this method.
If I'm getting this check right, PartitionByExpressions can be modified inside the test method, right? It seems like it would be easier to test as follows: PartitionByExpressions string = new PartitionByExpressions(pn.getDatabase(), pn2.numberSortExpressions); for (int i = 0; i < pn2.numberSortExpressions.length; i++) { String pn = pn2.numberSortExpressions.get(pn2.numberSortExpressions); assertEquals(pn2.numberSortExpressions.getSortExpression(), pn2.numberSortExpressions); }
If I'm getting this check right, PartitionByExpressions can be modified inside the test method, right? It seems like it would be easier to test as follows: PartitionByExpressions string = new PartitionByExpressions(pn.getDatabase(), pn2.numberSortExpressions); for (int i = 0; i < pn2.numberSortExpressions.length; i++) { String pn = pn2.numberSortExpressions.get(pn2.indexSort.getValueSize(1)); assertEquals(pn2.numberSortExpressions.get(0).getConstraint().getValueSize(1).getValueSize(), pn2.numberSortExpressions); }
If I'm getting this check right, PartitionByExpressions can be modified inside the test method, right? It seems like it would be easier to test as follows: PartitionByExpressions string = new PartitionByExpressions(pn.getDatabase(), pn2.numberSortExpressions); for (int i = 0; i < pn2.numberSortExpressions.length; i++) { String pn = pn2.numberSortExpressions.get(pn2.indexSort.getValueSize(1)); assertEquals(pn2.numberSortExpressions.getValueSize(1)); }
So we are defaulting to zero here? Or is this for clarity?
So we are defaulting to UTF-8 here? Or is this for clarity?
Do we actually want this to be an option? Or is this an arbitrarily large size to the default?
This should probably be renamed so it's not the parser
This should probably be renamed so it's not the plugin
This should probably be renamed so it's not the parser.
extension could be omitted as well.
extension could be omitted here, please use VCFHeaderLines.
extension could be omitted here, please use VCFHeaderLines
Type field is not needed anymore according to Sun's description <LINK_0> I think it would be better to leave it empty and make GWT IDE asking project type instead of hardcoding it.
Type field is not needed anymore according to Sun's description <LINK_0> I think it would be better to leave it empty and remove this line.
Type field is missing here
We could shorten this to: java replaceLabel("px", replaceLabel.getText().toString());
We could shorten this with something like: java replaceLabel("px", replaceLabel.getText().toString());
We could have something like: java.addLeftWidget(replaceLabel)...?
We should include the 'ex' part of the exception message to help users to understand what's wrong.
We should include the 'ex' part of the exception message to help users. It is much less confusing when it happens.
We should include a useful message here about what's wrong.
Log messages like you're returning an empty string :)
Log messages like you're returning an empty string?
Log the resource.
I don't think it should be removed. We don't want to assert that the mb hasn't been removed in the tests. Now, I think it should be removed. No one will assert that the toString() method does a System.err.println but it has more than one assertion.
I don't think it should be removed. We don't want to assert that the mb hasn't been removed in the tests. Now, I think it should be removed. That should assert that the toString() method is called with a well-known toString() call to System.err.
I don't think it should be removed. We don't want to assert that the mb hasn't been removed in the tests. Now, I think it should be removed. That should assert that the toString() method is called with a well-known toString() call.
isn't this line redundant?
nit: can use isNull bestScore
nit: can use isNull()
This could probably be a static constant
Will throw a workflowException if workflow.type <LINK_0>
This could probably be a static final constant
Use a LinkedHashSet here. It's certainly a matter of preference though.
Use a LinkedHashSet here. It's certainly hard to understand what the code means.
Use a constants for the values
We can move SeleniumWebDriver#waitProjectExplorer(String) method to separate method instead
We can move SeleniumWebDriver#waitProjectExplorer(String) method to separate method instead of using it.
We can move SeleniumWebDriver#waitProjectExplorer(String) method to the **SeleniumWebDriverHelper** method.
Do we need to keep this in info level?
Do not change the System.out.println in production code. Use info instead.
Do you need to keep this in info level?
nit: should this be a constant?
nit: should be a constant
nit: should be a constant of this
I wonder if it would be better to interpret a AudioManager.FLAG_MUSIC_AND_SOUND = true?
I wonder if it would be better to interpret a AudioManager.FLAG_MUSIC_AND_SOUND role in the sub-context?
I wonder if it would be better to interpret a AudioManager.FLAG_MUSIC_AND_SOUND role in the sub-page?
Shall we do a null check on realmAccess.get(CLAIM_RESOURCE_ACCESS) here?
Shall we do a null check here?
Shall we do a null check on realmAccess.get(CLAIM_ROLES) here?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "reader". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "Unnecessary"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
Small nit, but, I think this whole block could be shortened to: if (options.equalsIgnoreCase(DO_ROLLUP_OPT).equals(NO_CHART_OPT)
Small nit, but, I think this whole block could be shortened to: if (options.equalsIgnoreCase(DO_ROLLUP_OPT).contains(NO_CHART_OPT)
Small nit, but, I think this whole block could be shortened to: if (options.equalsIgnoreCase(DO_ROLLUP_OPT).equals(options.get())) {
remove from here and the following lines
Remove or use debug log
remove from this debugging output?
this makes the result of the operation, which is not what we want. I guess we have to solve this problem, but wonder if it makes sense to have the "boolean" parameter, and then re-set the result to the user, which is not the problem.
this makes the result of the operation, which is not important, but I guess we have to improve the readability of the test here.
Nitpicking: "execute"
I think it would make sense to have "my" as a parameter. User may want only to upload DomainDeployment and then assign it to several groups manually (or via additional CLI script)
I think it would make sense to have "my" as a parameter. User may want only to upload DomainDeployment and then assign it to several CLI requests
I think it would make sense to have "my" as a parameter. User may want only to upload DomainDeployment and then assign it to several CLI requests. Most servers don't like the up-to-option scenario, and when that were not in the addDeploymentContentProperty, we might want to add additional CLI dependency to it. So instead of allowing it to be loaded in other CLI options.
how about TimeUnit.SECONDS.toMillis(pool.getWaitTime())?
how about TimeUnit.SECONDS.sleep(COMPLETED, TIMEOUT_MILLIS)?
what happens if we don't get here?
shouldn't need this?
shouldn't need the synchronized block
at configuration time, need to do this check
nit: Maybe it's better to add a method on PlanNodeProvider to make it clear what it does.
nit: Maybe it's better to add a method to getASplitLifeCycleFactory which returns an Optional<PlanNode>
nit: Maybe it's better to add a method to getASplitLifeCycleFactory which returns an Optional<PlanNode>?
I would not use e.printStackTrace(), Log it properly.
I would not use e.printStackTrace(), Log.error to warn the stack trace.
I would not use e.printStackTrace(), Log.error to warn the warning and not ignore.
Should this be : <LINK_0>
Should this be 'equals'?
Should this be equals?
an alternative is to log at just one place with the error code.
an alternative is to log at just one place with the error code. Could you elaborate?
an alternative is to log at just one place with the exception.
Remove empty line
Remove empty line?
Remove all the castings
This should be imported.
Should we include the actual esp?
Should we include the actual field?
this will need to be set to null. I would suggest we avoid using Objects.requireNonNull when the value is null.
this will need to be set to null. I would suggest we avoid using Objects.requireNonNull.
this will need to be set to null. I would suggest we avoid using Objects.requireNonNull when the columns are not empty.
error message is correct here..
error message is correct.
Well, I think we should reject nodeList.addContext(nodeList.get()));()));
You can directly use getDbFacade().getStoragePoolId()
The return value of getDbFacade().getStoragePoolId() can be moved to line 115
The return value of the 'newConnectionParametersForVdsCommand' may be null.
I would put these together. We don't want to expose all nodes to the CliOptions.
I would put these together. We don't want to need to modify the CliOptions.
I would put these in the static method.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
As a small improvement you could switch this to: isAccessible(member) { final Class memberClass = memberClass.getKey(); final Class memberClass = memberClass.getPackage(); final Class memberClass = memberClass.getKey(); final boolean memberClass = memberClass.getValue(); final Class memberClass = memberClass.getPackage(); //resolves access to memberClass.get(memberClass); return memberClass; }
As a small improvement you could switch this to: isAccessible(member) { final Class memberClass = memberClass.getKey(); final Class memberClass = memberClass.getPackage(); final Class memberClass = memberClass.get(memberClass); final Class memberClass = memberClass.getKey(); final boolean memberClass = memberClass.getValue(); final Class memberClass = memberClass.getPackage(); final String memberClass = memberClass.getKey(); final boolean memberClass = memberClass.getValue(); final Target memberClass = memberClass.getPackage(); if (memberClass.isTypeExcluded(memberClass)) { targetClass = getProject(); } return memberClass;
Minor nit: I think you could extract this.needToRefreshCreds to a local variable.
I think this would be a good idea. Can you elaborate?
I think this would be a good idea.
Why is this variable outside the try-catch block?
Why is this method no longer being used?
Why is this variable outside the try block?
What do you think about public contains(Collection<T> dataProvider, T items) instead of creating the dataProvider itself? This could increase the performance especially if you call containsinside a loop like in addItems, addItemsAfter or addItemsBefore.
What do you think about public contains(Collection<T> dataProvider, T items) instead of creating the dataProvider itself? This could increase the performance especially if we call containsinside a loop like in addItems, addItemsAfter or addItemsBefore.
What do you think about public contains(Collection<T> dataProvider, T items) instead of creating the dataProvider itself? This could increase the performance especially if you call containsinside a loop like in addItems, addItemsAfter or addItemsAfterItems.
Is this method used on line 61? If not, I would prefer making this a PR out to be a PR.
Is this method used on line 61? If not, I would prefer making this a call to setChunkOperationComplete(false, true) and call this method directly.
Is this method used on line 61? I think it would be a bug and we should have a Util.getChunkException(operation) at the end.
are the variable name 'group' too?
are the variable name "group" perhaps?
are the variable name "group" too?
don't you want to 'add(0, null)'?
don't you want to also add the status of the cluster?
please don't add populate() on vms
I think it would be better to move two methods with a class such as PalantirContent.class.
I think it would be better to move two methods to a class such as PalantirContent.class.
I think it would be better to move two methods with a class such as PalantirContent.class.getName() to close the object in the next class.
consider adding a log on failure
need to catch exception also here?
consider adding a log about adding a log on failure
Can we have an patient that has a patient has all of the patients?
Can we have an patient that has a patient has all of the given locations and needs to be added?
Can we have an patient that has a patient has no patient, and don't have to add the identifier?
Let's import static org.apache.commons.lang.StringUtils;
Let's import static org.apache.commons.lang.StringUtils.isEmpty;
Let's import static org.apache.commons.lang.StringUtils.isEmpty
move this check into the JobConfig constructor.
move this check into the JobConfig constructor?
move this inside the if block
This should be removed.
This should be logged, but logged at INFO.
This should be logged, or removed.
Exception#printStackTrace goes to stderr by default.
I think we should just catch Exception and let the developer handle it.
I think we should just catch Exception and let the application crash the app
Redundant. There are no transformations around this
Magic number
Redundant.
if StringUtils.split(group) is true, it won't be empty.
if StringUtils.split(group) is true, it will throw an NPE.
if StringUtils.split(group) is true, it will be empty.
Need to close the connection in a finally block
Need to close the connection in the finally block
Need to close the connection in a finally block for this case?
are you sure you need credentials temp variable?
are you sure you need credentials temp variable? why not just inline credentials.
are you sure you need credentials temp var?
why do we check for both default size and user-configured size? It should be either one, right?
why do we check for size > maxDataSize? It should be either -1 or ignore the size.
why do we check for size > maxDataSize? It should be either maxSize or ignoreSize.
StateObserver?
Master is marked as final.
StateObserver is required for the success case.
assertTrue is redundant here.
assertTrue would be more descriptive here.
You can also use assertTrue here.
Who else is using this? It does not seem to handle the exception.
Yes, I think you can collapse it into your new StudentAttributes constructor.
Who else is using this? It does not seem to handle the exception. Suggest changing it to InvalidStudentException.
I'm not following what we need here. Can you explain a bit, and maybe move this code into a well-named helper method?
What happens when we log a message here? I don't think we need to log this line?
I'm not following what we need here. Can you explain a bit, and maybe move this code into a well-named method?
This should be immutable
same here: add the exception to the log
same here: add the exception as the cause
SysMutex magic: [CLASS_NAME]
Does this work? I thought the logger returned is the same.
SysMutex "?"
I think this method is too much java private static ElasticsearchTableDescriptions(...).stream().map(ElasticsearchTableDescriptions::getElasticsearchTableDescriptions).collect(Collectors.toList()).forEach(e -> log.debug("Loading elasticsearch table definitions from %s", tableDefinitions, JsonCodec));
I think this method is too much java private static ElasticsearchTableDescriptions(...).stream().map(ElasticsearchTableDescriptions::getElasticsearchTableDescriptions).collect(Collectors.toList()).forEach(this::setSchema).collect(Collectors.toList());
I think this method is too much java private static ElasticsearchTableDescriptions(...).stream().map(ElasticsearchTableDescriptions::getElasticsearchTableDescriptions).collect(Collectors.toList()).forEach(e -> builder.build());
Can you put it in the tank?
Can you put it with the tank contents to make this more readable?
Can you put it with the tank contents to make this easier?
The difference between this is a bit strange to me. The ModelGradleDistribution.useBuildDistribution is just a local variable with the method name, it is called 'useGradleDistribution'. So it could be simplified.
The difference between this is a bit strange to me. The ModelGradleDistribution.useBuildDistribution is just a local variable with the method name, it is called 'useGradleDistribution'.
The difference between this is a bit strange to me. The ModelGradleDistribution.useBuildDistribution is just a local variable with the method name, so it is easier to read.
I guess this should be && accessAllowedToAccessAllowed
I guess this should be && accessAllowed; same for the conditional operator
I read this method only once.
This is a breaking change - we don't know whether the format is a correct or not. We're going to validate anything if we omit this check. We can basically check whether the type is a Number or not. If the type is not a AmqpValue, then we can validate whether it's a valid value.
This is a breaking change - we don't know whether the format is a correct or not. We're going to validate anything if we omit this check. We can basically check whether the type is a Number or not. If the type is not a AmqpValue, then we can validate whether it's a valid type or not.
This is a breaking change - we don't know whether the format is a correct or not. We're going to validate anything if we omit this check. We can basically check whether the type is a AmqpValue.
This check is not necessary because you will have two statuses with one.
This check is not necessary because you will have two statuses (one for the next review) for one of the status, Status.active = true and one for the other status.
This check is not necessary because you will have two statuses with one of the same name. If the status is UNKNOWN, you will have to check whether it is status or not.
You may have just used int[] blockEnd = block.getBlockSize(); for (int i = 0; i < blockEnd; ++i) { int blockEnd = block[i]; } while ((blockEnd < blockEnd; ++i) { blockEnd = blockEnd; } }
You may have just used int[] blockEnd = block.getBlockSize(); for (int i = 0; i < blockEnd; ++i) { int blockEnd = block[i]; } while ((blockEnd < blockEnd; ++i) { blockEnd = block[i]; } }
You may have just used int[] blockEnd = blockStart + (byte) memCipher.precision() >  8;
It would be great to have a local variable for the second parameter
It would be great to have a constant for the interval (static).
It would be great to have a constant for the interval (static)
Did you intend to use multi-catch blocks here?
Did you mean to use "BCF" for this header value?
Did you mean to use a generic VCF_ header expectation here?
Use try-with-resources to ensure that close is closed even if it is an exception.
Use try-with-resources to close these file
Use try-with-resources?
Why did you catch this?
Why do you catch this?
Left over?
no need for the "if"
no need for the "List" variable.
no need for the "if" to be removed from here
Shouldn't content length of 0 be excluded from here?
isNullOrEmpty?
isNullOrEmpty
It is confusing that the loop in the calling method is the same as the initial check above. Please add it to the block.
It is confusing that the loop in the calling method is not used outside of the loop. Please add it as a member variable
It is confusing that the loop in the calling method is not used outside of the loop. Please add it as a member variable and reuse.
Not sure this is the right way to do this: if (m_parent == null) { return; }
Not sure this is the right way to do this. Will this cause a race condition?
Nit: do you need this?
Please add spaces between ) and {
Please add spaces between +
Please add spaces between,
This should be mBannerView.load(), not mBannerView.
This should be mBannerView.load().
This should be mBannerView.
No need to delete absolute path when fileOrDirectory is not found in the folder.
No need to delete absolute path when fileOrDirectory is not defined, it will be ignored anyway
No need to delete absolute path when fileOrDirectory is not defined, otherwise the project will be deleted
Simpler: if (entry.getKey().compareTo(entry.getKey()) >= 0) {
Simpler: if (!entry.getKey().equals(entry.getKey())) { indexSegment.set(entry.getValue()); } You can still use IndexSegment.values() to create a IndexSegment.
Simpler: if (!entry.getKey().equals(entry.getKey())) { indexSegment.set(entry.getValue()); } For a clearer, please.
@ivandalbosco I think this is probably easier to use: for (List<String> states : treeMap.getCatches().size() - 1; i >= 0; --abortInCatches.getCatches().size() ) {
@ivandalbosco Why not use map.getCatches().size() == 0?
@ivandalbosco Why not use map.getCatches().size() == 0?
Consider setting this to true instead of false.
Consider setting NON_STRICT_SUBSTITU.
Consider setting NON_STRICT_VARIABLE_SUBSTITU.
try-with-resources
try-with-resources? And in any case, a non-static method is repeated, maybe move it outside the try block
try-with-resource is suppose to close a writer
I don't think we can have an assertion, but we have one, to verify that the token(""+ is not of the 99.
I don't think we can have an assertion, but we can't use one character set of tokens, instead, it's possible to have some kind of tests.
I don't think we can have an assertion, but we have one, to verify that the token(""+ is not of the expected one. That's why it was reported, but let's try to fix it.
can the new code be refactored to use the existing code instead of duplicating it here?
This can be replaced with 'existingBatches' instead of 'existingBatches'
This can be replaced with 'existingBatches' instead of 'existingBatches'.
The methods addAndGet() I'm not sure, but I think we should use a counter instead of a 0
The methods addAndGet() I'm not sure, but I think we should use a consistent name for the key
The methods'fetchTree()' are thread-safe and useless. You could use a <TmfTreeDataModel> and use the handler directly.
This still isn't the third argument to add/set + in getErasure() when necessary.
This still isn't the third argument to add/setsErasure logging and then throw it.
This still isn't the third argument to add/setsErasure
suggestion throw new ByteArrayOutputStream(APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML,
suggestion MediaType.APPLICATION_XML(APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML,
suggestion throw new ByteArrayOutputStream(APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, APPLICATION_XML, DOMAIN_SERVER_ERROR
can't we use versions.getAndAssert(version, referenceFlag, referenceDatacenterIdAndAssert.checkNotNull(version, "UseSetter")?
please change this to: version = Objects.firstNonNull(version, referenceDatacenterId);
can't we use versions.getAndAssert(version, referenceFlag, referenceDatacenterIdAndAssert.checkNotNull(version, "UseSetter on").setAndAssert(null);?
Why do we need this change?
Why do we need the warn here?
Why do we need this?
Add problematic host to the exception and also add the reason why can't. Because he has no privilages to use this hostName.
Add problematic host to exception and also add the reason why can't. Because he has no privilages to use this hostName.
Add problematic host to the exception and also add the reason why can't. Because he has no privilages to use this hostName only once.
That would catch RuntimeException, and rethrow. I think: if (commit!= null) { throw new RuntimeException(e); } else { }
That would catch RuntimeException too, because the core of the catch block is not wrapping any exception.
That would catch RuntimeException too and log it.
Should we use a logger here?
Should use the same logger syntax
Should use the same logger syntax here.
Single pass is needed here.
Single pass is required here.
Single return is needed here.
Can we use a hashmap with the size?
Can we use a Collections.emptyMap here?
Can we use a regexp cache here?
I guess you should return directly after the logging? And please log the executors that you are logging in both cases.
I guess you should return directly after the logging? And please log the executors that you are talking about the logging?
I guess you should return directly after the logging? And please log the executors as well.
I'd change this to use the null check instead of the next line.
I'm not sure how this is correct. The messages are in the wrong order.
I'm not sure how this is correct
Close in finally.
should this just throw the Exception?
should this just throw an exception?
We should call refreshBounds() here to avoid calling refreshBounds in refreshBounds().
We should call refreshBounds in the refreshBounds() method above.
We should call refreshBounds() here to avoid calling refreshBounds in refreshBounds()
This is also suspicious, I guess we shouldn't need it now.
This is probably better done in setup methods.
This is now part of the original code now.
injector.getInstance(defaultClass)
injector.getInstance(defaultClass);
Use  injector.getInstance(defaultClass)
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only if getVm()==null
I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only if getVm()==null
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way no?
Should this be in a finally?
Should this be in the finally block?
Should this be in a finally block?
Where is it going on?
Where is the host 'disallowed' handled?
Where is the host going on?
I would suggest changing this to java updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE, ThingStatusDetail.OFFLINE);
I would suggest changing the contract of this method to only do a check for null (and not for any other reasons).
I would suggest changing the contract of this method to only do a check for null (nn)?
You should do it this way, you don't need to create another variable for the same value.
You should do it this way, you don't need to create another variable just return value.
You should do it this way, you don't need it inside of the loop.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::reset); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
Let's move this to the block, since it will be closed in finally block anyway.
Let's move this to the block, since it will be done in the constructor.
Let's move this to the block, since it will be called twice if Helix manager is closed.
Move this into the try block and remove the finally clause
Move this into the try block and remove the finally clause?
Move this into the try block and remove the finally block.
Similarly here; it looks like other questions are asked
Similarly here; it looks like other questions can be taken care of by the design.
Similarly here; it looks like other questions can be taken out of the try-catch block
Who is calling cleanupRecursive on this?
Who is calling cleanupRecursive on this line?
Typo: 'dir'
Can we use dpr for this?
Can we use dpr for this or at least make it static?
Can we make this a convention?
Please get the instance name from bigtableInstanceName.toGcbInstanceName(), if it exists.
Please get the instance name from bigtableInstanceName.toGcbInstanceName()
Please add a null check.
nit: consider using PoolEntry::removable;
nit: I think the'removable' below is unnecessary
Static import
suggestion i < argumentValues.size();
suggestion i = argumentValues.size();
No need for check in list
NIT: we should use JenkinsUtil.getModLog instead of VersionNumber, it will allow us to override Jenkins core.
NIT: we should use JenkinsUtil.getModLog instead of VersionNumber, it will allow us to override Jenkins core versions.
NIT: we should use JenkinsUtil.getModLog instead of VersionNumber, it will allow us to drop the plugin paths.
Use lambda syntax
Use lambda approach
Use lambda approachable.
Same note above about missing curly braces and relying on a a default-constructed ReferenceSource applies here.
Same note above about missing curly braces and relying on a a note is not a good practice.
Same note above about final...)
I would say that we must be able to set the host name to a different property. Otherwise there is a risk of breaking some of the relative paths.
I would say that we must be able to set the host name to a different property. Otherwise there is existing DOBTrackerUrl or just a few lines below
I would say that we must be able to set the host name to a different property. Otherwise there is a risk of breaking some cases.
You're missing a try/catch here.
You're not using its getStringValue() result on the previous line.
You're missing a try with resources (though this is a typo)
We have to make sure we have an instance of BriefcaseException. I'm not a fan of catching an IOException here.
We have to make sure we do not fail the writer when doing this. I don't think it's possible to read a file needs to be updated or not.
We have to make sure we do not fail the writer when doing this. I don't think it's really necessary.
nit: remove unnecessary blank line
nit: same here
nit: remove unnecessary
Looks like the schema has been ordered by default..
Looks like the check can be simplified by re-use the logic here.
Why 2?
isEmpty()?
<code>verifyAccessible</code> should be used instead.
<code>verifyLoggedIn</code> should be used outside the <code>verifyLoggedIn</code> function
Do not need the System.out.println. ;)
Is there a reason why you need the line break?
Do not need the System.out.println. The test will fail.
F.map(r -> i.getBound()).filter(c -> i >= 0);
F.map(r -> i.getBoundName() == null ||!r.isEmpty())
F.map(r -> i.getBoundName() == null ||!columnsToMoveColumnsToMoveColumn(..) )
define final
May be extract this code in a helper class?
define constant
Why not simply create a new SetMemberMemberSearchRequestEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorConverter?
Why not simply create a new SetMemberMemberSearchRequestEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorEvaluatorConverter?
Why not simply use the same MTrimBar here?
is this test going to run after the executor has been shutdown? It looks like it's using the executor.
is this test going to run after the executor has been shutdown? It looks like it's using try with resources.
This sleep doesn't seem to be necessary.
Should be a call to check for the vector.getAccrualPeriods()
Should be a call to check for the size of the array.
Should be a call to check for the vector.
Logging should be done in a debug or trace
Logging should be done in a logger.
IMHO it'll be better to have this in a constant.
Define a constant in SdkConstants and use it here.
Extract notification to own method notify...
Define a constant in SdkConstants instead
how about storing the results in the local history table?
how about storing the results in the local table?
how about storing the results in the local history location?
Do we need a assertFalse() assertion here?
Do we need a assertFalse(rootFileStatus.getAclStatus(rootDecl.class))) here?
Do we need a assertFalse(rootFileStatus.getAclStatus(rootDecl.class)); above?
I think we should move the for loop out of the for loop
I feel that we should be consistent with the equals in this method. I would have moved the Observations to the Observation class and use it there.
I feel that we should be consistent with the equals in this method. I would have moved the Observation#add method, that should be renamed to getServer().
space between -1
space
-1
Why is that moved down?
Why is that moved down? Can't we apply the same check?
Why is that changed?
Why the null check here? Why not just use Bbable elsewhere?
Why the null check here? Why not just use BbAdapter.create(Directive) here?
Why the null check here? Why not just use BbAdapter.create(Directive)?
This variable should be named expense.
This variable should be named userId instead of categoryName.
Could you put the time_name and time_millis into a variable?
you can use FiltersHelper.Constants.HEADER_PREFER here.
you don't need this here
you can use FiltersHelper.Constants.HEADER_PREFER here
if you mean it won't be coupled to this line, no need for more characters won't hurt. :old_popup:
if you mean it won't be needed other places won't be used? :older_
Name it "old" :P
can we use a try-with-resource pattern here?
can we use a try-with-resource block here?
can we use a try-with-resource idiom here?
Why don't we log something if debug is enabled? Seems like a kind of warning.
Why don't we log anything if debug is enabled? Seems like a kind of warning.
Why don't we log something if debug is enabled? Seems like a kind of warning if we're going to remove.
Throw HIVE_METASTORE_ERROR
Throw Exception instead of returning null
Throw Exception
you can ignore these.
you can ignore this.
you could return null in these two places.
Why on earth do you use a LinkedList for this?
Why on earth do you use a linked list here?
Why on earth do you use a LinkedList here?
@njhill after some more digging this actually depends on if jdk 1.7 support, we should not use braces around single line blocks.
@njhill after some more digging this actually depends on if jdk 1.7 support, we should not use braces around single line blocks. The rationale is to change it if we change the order of the return value of lineStartOffsets to be -1 on the first line.
@njhill after some more digging this actually depends on if jdk 1.7 support, we should not use braces around single line blocks. The rationale is to change it if we change the order of the return value of lineStartOffsets to be a public method on the left.
I think this is a behavioural change that requires us to support the token to be specified in the configuration.
I think this is a behavioural change that requires us to support the token to be specified in the token.
I think this is a behavioural change that getContent() returns null
Not sure if you're just getting a little more clear here :P
Why not just continue during the loop?
Please remove the throws.
Can we move closeFailed to the closeFailed method? This logic looks wrong.
Can we move closeFailed to the closeFailed method?
Can we move closeFailed to the closeFailed method? This logic is wrong.
Let's only use this type when logging is not supported. No LoggingUtility.logError()?
Let's only use this type when logging is not supported.
Let's put this outside the if statement
This seems a bit weird. I can't tell why every operation is in a queue...
This seems a bit weird. I would prefer to use the diamond operator: new ArrayList<>()
Should you use the interface?
java if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { try { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } catch (Exception e) { expectedResult.setExceptionMessage(e); } } } I know it looks a bit spaghetti like, but at least it is more readable
java if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { try { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } catch (Exception e) { expectedResult.resetStatus(); } } }
java if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { try { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } catch (Exception e) { expectedResult.resetStatus(); } } } I know it looks a bit spaghetti like, but at least it is more readable
Could we make this a little smarter than once we explicitly set the option?
Why did the first one be removed?
Could we make this a little smarter than once we first create the String on demand?
The message should be "The file cannot exist."
The message should be changed to "The file cannot exist."
The message should be: "The file cannot exist. Do you want to have a.shown?
exception, so STDERR
main(), so STDERR
That's fine, but STDERR
Values seem to be of a particular user. Change them for notNull asserts or something that can be run by anyone.
Values seem to be of a particular user. Change them for Values is @VisibleForTesting, or something that can be used for Values
Values seem to be of a particular user. Change them for Values is a sample.
space after "if"
space after "!"
space after the (
I think this would be better as a variable name.
Looks weird to me. Can you move this to the previous line?
This seems unnecessary
We don't want to change this, as it should be the init() method of DecimalFormat.
We don't want to convert to String since it is a RuntimeException, but we should be able to remove the System.err
We don't want to convert to String since it is a RuntimeException, but we should be able to remove the System.out
Make this constant at the beginning of the class as the variable.
Make this constant at the beginning of the class as well.
huh?
In my opinion like this is a good candidate for Util.isAvailable() since it will return null.
In my opinion like this is a good candidate for Util.isBlock(), like below.
In my opinion like this is a good candidate for Util.isAvailable() since it checks for the state.
Suggested to pull predicate creation code into a separate method.
Suggested to pull predicate logic into a separate method.
Suggested to pull predicate creation code into a separate method to avoid duplication
Why is this done? I think it should be final.
if (trendsToShowLeft && e.getMessage()) maybe? I don't think that maybe it should be a more clean.
if (trendsToShowLeft && e.getMessage()) maybe? I don't think that maybe it should be a normal cast.
You don't need to change this line.
You don't need to catch Exception.
You don't need to test this code. Why are you using an assertFail() test method without assertions?
you can check that c.getVdsGroup() is not null
you can check that c.getVmOsId() is not null
you can check that c.getVdsGroup() not null
@ivandalbosco super minor: no need to test for a 'private' variable.
@ivandalbosco super minor: no need to return at all in the return value.
Rather than return true.
entries.get(key) -> null
Could we put the invocation on the remote line here?
entries.get(key) -> { });
There's no need to use a boolean variable, can you change it to boolean isAllowedConnectionType()
There's no need to use a boolean variable, can you change it to boolean isAllowedConnectionType
Please put { } around if body.
If a user might want to not have an explicit connection, maybe we should just use instanceof here.
If a user might want to not have an explicit connection, maybe we should just use a boolean and a throw IllegalStateException()?
If a user calls setHeader in the background, we should not need to validate the data in the send request.
I don't think it matters in the future, just the name of the file should be renamed.
I don't think it matters in the future, just the name of the file should be renamed. If that's the other way around, we should keep it in the same way
I don't think it matters in the future, just the name of the file should be renamed. If it was the other way around, it should not be the same on different environments (the naming scheme of the file).
You updated the port which is good - can't we have the hostname be localhost?
You updated the port which is good - can't we have the hostname be localhost?
You updated the port which is bad.
I was thinking what you could do with this but it doesn't make sense for the value to be formatted incorrectly
I was thinking what you could do with this, but it doesn't make sense for the value to be formatted incorrectly
this doesn't need to be public
can we switch this to the Apache Commons Lang library?
can we do this without line 198?
can we handle this by using the Exception?
Can you split this into two statements?
There is already a TypeType.RIGHT inside this else{}
There is already a break here.
When the thread is interrupted, it makes sense to wrap the InterruptedException in a unit test. I don't think the tests are failing in it.
When the thread is interrupted, it makes sense to wrap the InterruptedException in a unit test. I don't think the thread needs to be closed properly here.
When the thread is interrupted, it makes sense to wrap the InterruptedException in a unit test. I don't think the thread needs to be closed properly when a request is generated.
This step is same for standalone as well as domain ;-)
This step is same for both cases as well as domain ;-)
This step is same for both cases as well FinderNames.SUBSYSTEM
Please move the if condition to an top of the method, so that it is called only once.
Please move the if condition to an top of the method, e.g. boolean nfs = true;
Please move the if condition to an else if.
Why is this change needed?
Why are we setting this to true here rather than false?
Why are we setting this flag here rather than the previous behavior?
Looks like this will copy all the fields to the same object, right?
Looks like this will have 0 as well. Do we need to change the other.major at this point?
Looks like this will have 0 as well. Do we need to change the other.major in this case?
This is very fragile approach. When would this method be called?
This is very fragile. How about adding a assertion to verify that the slots are empty before adding it to the array?
This is very fragile. How about adding a assertion to verify that the put is actually a non-zero key?
i'd prefer a constant for the arithmetic of comparisons with Character class.
i'd prefer a constant for the 'count' value
i'd prefer a constant for the arithmetic of comparisons with Character class
why are you comparing the Group instead of the real group?
why are you comparing the Group and the other one?
Group0 is not used
Would this be better as package private instead of protected to minimize scope? Since there's no subclasses in other packages, is there a need to be protected?
Why segmentReplicatable() instead of server.getIdentifier()?
Why segmentReplicatable() instead of server.getIdentifier()? This code can be simplified to: server.get(segmentServerMap.get(segmentServerMap.get(segmentServerMap).build())
"if (index.size() > 0)" is redundant
"if (index + AGED LOADGENGENERATION.isTrue() ||!isWriteThreadRunning())" can be removed as well.
"if (index.size() > 0)" is redundant and can be removed.
use s.o.
use.equals()
use s/this./
Please specify why this is no longer needed and just after the for loop above
Please specify why this is no longer needed and just after it is called for a terminal
:ant: I think you might want to log here
suggestion URI propertyURI = classProperty.getLinks().get(propertyLink);
suggestion URI propertyURI = classProperty.getLinks().get(property);
suggestion URI propertyURI = classProperty.getLinks().get(0);
I think that we should not have protected methods ("symbol!= null") as only one call to visitVariableIdentifierSymbol()
I think that we should not have the ENUMs defined in the Scout [strings](<LINK_0>
I think that we should not have protected methods ("symbol!= null") as only one of these are possible.
Would be good to add a log.
Would be good to add a break so we don't accidentally trigger failure
Would be good to add a correct exception to T.
Please revert this change, too. e.printStackTrace() may help debugging.
Please revert this change, too.
Please revert this change.
I think we need to wrap the node in a InboundTransferTask at this point.
I think we should wrap this on a InboundTransferTask at least.
I think we need to wrap this on the executor
It seems like this line should be called from all activities and sort of intuitively fits in with that method.
It seems like this line should be called from all activities and sort of intuitively fits in with that method. Can we call it in some other places?
It seems like this line should be called from all activities and sort of intuitively fits in with that method. Can we call it in some other places? Thanks!
This basically comes from when the snapshot was written, but it doesn't have any effect. Did you test this?
This basically comes from when the snapshot is going to be the same time, right? Shouldn't we have a time to understand this?
This basically comes from when the snapshot is going to be the same time. It should be update, not a write.
You can use TestUtils.assertContains instead of assertTrue.
You can use TestUtils.assertContains instead of assertEquals.
You can use assertEquals.
in different implementations it might be better to use ByteBufUtil.prettyHexDump(msg)
in different implementations you can use ByteBufUtil.prettyHexDump(msg)
in different implementations it would be better to use ByteBufUtil.prettyHexDump(msg)
possible NPE
possible NPE here: index might try to eval Integer index = pair.getSecond().getFirst(), index==null)
potential NPE
This bit can be factored out into MultiModel, and reused below.
This code is easier to read: Optional<String> author = model.getOptional().filter(Predicate.isEqual(content)).findFirst(); if (condition) { return Optional.empty(); } else { return Optional.empty(); }
This bit is easier to read if you extract the difference into a method.
Any reason to not use the file name here and not FileText?
Any reason to not use the file name here and not FileText?
Any reason to not use getPath()?
This variable seems not needed.
This variable seems very specific to me. What about returning a single one simple connection that is not used?
This variable seems not needed
The field name is not nullable.
The field type should be ARRAY.
The field type should be dest
style nit: final Date dateToString = new HashMap<>();
DRY: final Date dateToStringMapping = new HashMap<>();
style nit: final Date dateToString = dateToStringMapping.get(dateToString);
I think you need to be extra back to the original code: context.getBindingResult();
I think you need to be back to the original behavior here: <LINK_0>
I think you need to be back to the original behavior here
Could you please add @Override annotation here?
Could we please add @Override annotation here?
Could we please add @Override annotation here?
valueOf is never called, why are we leaving it as null?
valueOf is never called, should be removed
valueOf is ignored here.
The app supports multiple users? If not why need the parameter? Also, could create a default method without parameter where internally could call getUser(1) something called as getDefaultUser().
The method name could create a default method without parameter? If not why need the parameter? Also, could create a default method without parameter where internally could call getUser(1) something called as getDefaultUser().
The app supports multiple users? If not why need the parameter? Also, could create a Default method without parameter where internally could call getUser(1) something called as getDefaultUser().
nit: Exception -> IllegalArgumentException
nit: Add space before (
nit: Exception -> IllegalArgumentException?
@essobedo use Boolean.TRUE.equals(scope)
@essobedo use!org.apache.commons.Pin.Artifact.SCOPE_SYSTEM)
@essobedo use!org.apache.commons.common.Artifact.SCOPE_SYSTEM)
nit: use Map.Entry instead of KeyedStream<ClientWithSeq<ClientWithSeq<Client>>.
nit: I think this is redundant as the map's present in the filter method below
nit: drop the map?
getId() should only be called if the object does not exist. Please add a null check.
getId() should only be called once, not every time. Please add the object.getId() call here.
getId() should only be called once, not every time. Please add the object.getId() call too
Change it to List<Commit>.
Change it to ImmutableSet.of();
Change it to List<Commit>?
This could be replaced with java return aliases.stream().collect(toMap(identity -> new ArrayList<>()).add(editorComponentAlias));
This could be a bit shorter: java if (pluginComponentAlias.isEmpty()) { aliases = wsAttributes.get(0); } else { names.add(pluginComponentAlias); }
This could be a bit shorter: java if (pluginComponentAlias.isEmpty()) { aliases = wsAttributes.get(PLUGINS_ALIASES_ATTRIBUTE) } return new ArrayList<>(emptyList);
Why is this covered? I don't see any tests for it.
Why is this covered? I don't see any test for that.
Why is this simpler? I don't think it can be: return ch == 1 || ch == 1
As mentioned above, here we have 2 options: 1 and 2 options, because of the equals() method. I don't think it is correct. If these 2 are the same, we have to find a better way to avoid the null check.
As mentioned above, here we have 2 options: 1 and 2 options, because of the equals() method. I don't think it's a good practice.
As mentioned above, here we have 2 options: 1 and 2 options, because of the equals() method. I don't think it is correct. If these 2 are the same, we have to find a better way to avoid the null checks.
This change shouldn't be necessary. Even if you set the set to negative set, the caller can't deal with an empty set.
This change shouldn't be necessary. Even if you set the capacity to 0 then you set it to a different value, I would test the range check.
This change shouldn't be necessary. Even if you set the set to negative set, the caller can't change the range of the set.
use actualMatch.isEmpty() && actualMatch.isfy(actual)
use actualMatch.isEmpty() && actualMatch.isfy(actual);
use the same message as above, remove the extra space before/after
Consider using org.eclipse.debug.core.ActionUtils.addSingleDockable
Consider using org.eclipse.debug.core.ActionUtils.addSingleDockable.
Consider using proper verb.
Overdid: if (out instanceof IMetaData) {.. }
Overdid: if (out instanceof IMetaData) { Bytes.write(u); }
Overall HashSet logic?
It seems that the code (vs.a.b.v) should declare that this will never be used. Maybe we can remove the need for this line.
It seems that the code (vs.a.b.v) should declare that this will never happen, and the method above will throw an exception if none is found. If that's the case, we should handle this differently.
It seems that the code (vs.a.b.v) should handle this case.
Why is this necessary?
Why is the ArrayData?
Why is the ArrayData necessary?
do we have more than one segment? (Which is a more restrictive?)
do we have test(or(mBool(or(vBool(or(vBool(or(vBool(or(vBool(d)));?
do we have test(or(mBool(or(vBool(or(vBool(or(vBool(or(vBool(f)))?
we also need to check that the errors is empty. I suggest to use the reverse check, if (isEmpty()) { return empty(); } else { return empty(); }
we also need to check that the errors is empty. I suggest to use the reverse check, if (isEmpty()) { return empty(); } else { throw new Seq<E>(otherErrors); }
we also need to check that the errors is empty. I suggest to use the reverse check, if (isEmpty()) { return empty(); } else { throw new Seq<E>(values); } (and...
Won't this exception lead to an infinite loop?
Won't this be the log message?
Line 1203
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is not is the biggest obstacle why we didn't have autocrlf.
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. an optional byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is not is the biggest obstacle why we didn't have autocrlf.
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is not are the biggest obstacle why we didn't have autocrlf.
Should this be e?
Should this be e.getMessage()?
Should this log message be a field?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
I am just not 100% sure why the conversion to BigInteger is needed here.
I am just not 100% sure why this is needed here.
I am just not 100% sure why the conversion to int is needed here.
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can we use class for both methods?
Use assertEquals(lockIdentifier.getLockManager(), greaterThan(0));
Use assertEquals(lockManager.getLockManager(), greaterThan(0));
Use assertTrue(lockIdentifier.getLockManager().releaseLock()) instead
Can't we use sSelel?
Can't we check sSelItem?
Can't we check sSelItem??
Share the string.
Shall we use the same message.
s/conf/pack
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now). Would there be any drawbacks for this?
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now).
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column. Would there be any drawbacks to always returning them?
Could use Assertions.assertThat with a static import.
Could use Assertions.assertThat with a useful message.
Could use Assertions.assertThat with a useful message
We're changing the %02d value for any type since it works for any type. It works for me, but I'm not sure if it is possible to avoid
We're changing the %02d value for any type since it works for any type. It works for me, but I believe we can avoid changing the resulting String value.
You can avoid the equalsIgnoreCase by using ==
you don't need the.length() == 0 check, so use the if (args.length == 0) { return; } else { LOG.info("Staring flows " + folder.length + 1", args); }
you don't need the.length() == 0 check, so use the if (args.length == 1) { return; } else { LOG.info("Staring flows " + folder.length + 1", args); }
you don't need the.length() == 0 check, so use the first.isEmpty()
This should be here too.
This is just odd. You're right.
This should be here in case there's no public API.
Shouldn't it be the first check for getAuthorizationUrl!= null &&!stateData.isEmpty()
Shouldn't the == and!= be replaced with ==?
Shouldn't it be the first check for getAuthorizationUrl!= null || authorizationUrl.isEmpty()?
should be Log.e
should be removed
should be a newline
Can you make this a bit more specific and not just return the boolean? e.g. boolean failed = mount.isDirectory(); if (f1.isDirectory()) {... }
Can you make this a bit more specific and not just return the boolean? e.g. boolean failed = mount.isDirectory(); if (f1.isDirectory()) { return (f1.isDirectory(); }
Can you make this a bit more specific and not just return the boolean? e.g. boolean failed = mount.isDirectory(); if (f1.isDirectory()) { return (f1.isDirectory()) }
this method should be private
this method is identical to the method above, it should be private
just put the method as it is used through all the methods.
synchronizing on synchronization across threads
synchronizing inside synchronization
synchronizing on synchronization
why is it necessary to dispose the repository here?
why was the variable removed?
why is it necessary to check the value?
Could you please move the test with the enum value? The test is going to pass with the expected value, so it would be easier to distinguish between the two kinds of enum values?
Could you please move the test with the enum value? The test is going to pass with the expected value, so it would be easier to distinguish between the two enum values?
Could you please move the test with the enum value? The test is going to pass with the expected value, so it would be easier to distinguish between the two kinds of enum values.
You should freeLock after the transaction is committed.
You should lock the status first, see if the engine crash.
You should lock the status first.
This is often used in several places, I think it would be better to use a constant.
This is often used in several places, avoid the K calls. I prefer to use null on the constant.
This is often used in several places, make it a constant.
Except for the purpose, you should use String.join from the toString method as well.
Except for the purpose, you should use String.join from the rest of the code, not that important.
1. You should be checking name.length == 25 instead of String.join here. 2. The separator separator is a bit strange.
I think this should be the request.spec().isFinished() instead of get(0)
I think this should be the request.spec().isFinished() instead of get(0).
I think this should be the request.spec().isFinished() instead of getNodes().
Could this be caught and handled in the else block?
Could this be caught and handled in the else block? Could this be caught and handled in the outer if else?
Could this be caught and handled in the else block? There's overhead to creating an exception.
Keeping timeColumnName is not null. Let's keep the format final.
Keeping timeColumnName is not null. Let's keep the if condition on the first line
Keeping timeColumnName is not null. Let's keep the if condition on another line
suggestion long immutableTsLock = TransactionSupplier.getImmutableTimestamp();
suggestion long immutableTsLock = TransactionSupplier.startTransactionWithWatch(immutableTsLock.getImmutableTimestamp());
suggestion } catch (Throwable e) {
Can we use new ActiveMQQueue<> here?
Can we avoid it?
Can't we use this instead?
This is not an example of the use of operations in test. should we just remove the non-empty operations and remove?
This is not a good use, as you are only adding the new operations to the existing operations. should we just remove the "removeDeploymentGroup"?
This is not a good use, as you are only adding the new operations to the existing operations.
This method is not used right?
This method is not the same as before (as the class is the core component)
This method is not used now (as before)
It looks like this will iterate over all the fields and find the preferred prefix in a sanitizer. Could you use Locale.ROOT instead?
It looks like this will iterate over all the fields and find the preferred prefix in a sanitizer. Could you use something like 'Module' here?
It looks like this will iterate over all the fields and find the preferred prefix. Can you believe that is newLine is a better name than Assert.assertEquals?
should be "public".
Should be "public".
Should have all this parameters in the same file.
what are you trying to execute when the parameters are parsed as well?
what do you want to execute when the file failed?
what are you trying to execute can you please be more robust
I am a bit confused by this. Why not you only have one boolean check for nulls? And the other needs to be synchronized - if you have a limited reason why you haven't defined the flag.
I am a bit confused by this. Why not you only have a few public constructors?
I am a bit confused by this. Why not you only have one boolean check for nulls?
Style-nit: Remove space before {
Style-nit: Remove space before closing {
Style-nit: Remove space before closing curly.
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it. Also you use the same key set here.
Given the verifyeroInteractions that you inserted aren't these individual verifications redundant?
Just use!secondaryIndexes.isEmpty()?
Just use!secondaryIndexes.isEmpty() instead of adding new field.
Just use!secondaryIndexes.isEmpty()
As we are moving the circuitBreaker.getMetrics() and circuitBreaker.getNumberOfSuccessfulCalls() method, we should not duplicate it
As we are moving the circuitBreaker.getMetrics() and circuitBreaker.getNumberOfSuccessfulCalls() methods, we should not duplicate it
As we are moving the circuitBreaker.getMetrics() and circuitBreaker.getNumberOfSuccessfulCalls() method, we should not duplicate it in some other function
Is there a reason not to use the device and find the return value of this function?
Is there a reason not to use the device and find the return values of this function?
what does this flag mean?
style nit: no braces here
style nit: no braces around single line blocks
style nit: no braces around single line block
This looks a logic change? Is this correct?
This looks a logic change?
Same issue
here should be.next() since testIndexFunction.getInt(1));
here should be.next() since testIndexFunction.getInt(0) does not affect the return value.
Also test here that the return is changing from 1 to TEST_INDEX_ON_INDEX to something else.
extract to constant
extract (extractyAnnotatedFields)
extractyAnnotatedFields to a constant
nit: can we make this a public static final variable in order to be consistent with other methods?
nit: can we make this a public static final variable in inner class?
nit: can we make this a public static final variable in order to be consistent with other constructors?
correct the name of the logger.debug()?
correct the name of the logger (debug)?
So, here we have the same logic as the other components?
The port number should be set in the test.
why this change? This doesn't seem to be necessary.
why this change?
Consider adding all the null checks to studentProfile
Consider adding all the null checks to the googleId constructor
Consider using a builder
I don't think it's necessary to check this.
I don't think it's necessary to combine dataModels from dataLoadTimeSummary into a single field.
I don't think it's necessary to combine dataModels from dataLoadTimeSummary.
@ptirador shouldn't this be replaced with a simpler solution:.delegate(() -> new NullShapeDefFactory().delegate(container, new NullShapeDef(), () -> new NullShapeDefFactory().delegate(container, null, () -> new NullShapeDefFactory().delegate(container, null, () -> new NullShapeDefFactory().delegate(container, null, () -> new NullShapeDefFactory().delegate, no need to introduce a new NullShapeType enum, right?
@ptirador shouldn't this be replaced with a simpler solution:.delegate(() -> new NullShapeDefFactory().delegate(container, new NullShapeDef(), () -> new NullShapeDefFactory().delegate(container, null, () -> new NullShapeDefFactory().delegate(container, null, () -> new NullShapeDefFactory().delegate(container, null)).delegate(container, new NullShapeDefFactory().delegate).delegate(container, null, null);
@ptirador why this one should be removed as well?
use assertFalse
Please add one more Input file, please
Please add one more Input file.
:bug: ditto about this.
:bug: ditto about this. I'm not sure what is the meaning of the test.
:bug: ditto about this. I'm not sure what is the meaning of the cast.
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> position conversion
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup
I don't understand this change. posInRowGroup points to the first row in this method.
msg
binder -> create
binder -> pool
Can you move this assertion to the test method?
Can you move these asserts into the same class?
Can you move these asserts into the same method?
How about moving this logic to line 47, so it is more clear that they are only set once?
How about moving this check to line 47, since its not a requirement in a certain amount of time.
How about moving this logic to line 47, so it is more clear that we are not dealing with moving forward slashes in this file?
nit: this should be o, not object, right?
nit: This should be o, not object, right?
nit: this should be o, not object
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local variable.
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a variable.
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in local variable.
could be moved to a level since it's being used for anything else
could be moved to a level since it's being used for anything
could be moved to a level since it's being used for other things
This is not used.
This seems like a lot of code to me. Can you rephrase the message?
This seems like a lot of code. Can you rephrase the message as follows?
We need to set the mout of the previous line.
We need to set the value of deviceSession to null.
Should we switch to null?
getQualifierType() can return null if it is empty. This one has a null check.
getQualifierType() can return null if it's not a valid value
getQualifierType() can return null and the empty check is not necessary
Is this correct? Why the return type should be an enum?
Is this correct? Why the return type should be an array?
Is this correct?
mobile.openArticlesWithPagination
mobile.open method method name is not relevant
mobile.open method method name is not relevant anymore
Is it possible to have a switch statement instead of an string?
Is it possible to have a switch statement instead of an enum?
Is it possible to have some generic method to handle these? I think that we should check for it.
Since we are creating a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via rest call.
Since we are creating a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via other fields.
Since we are creating a fresh new index, we might as well add the _size field, so then later on we don't have to worry about updating the mappings via rest call.
What do you think of returning 0 result rather than null?
What do you think of returning null rather than null?
What do you think of returning null rather than returning nothing?
suppress warning (unused parameter e)
make error message more descriptive.
constant?
Might be cleaner to set the local time zone to UTC, or make it configurable.
Might be cleaner to set the local time zone as UTC, or make it configurable.
Might be cleaner to set the local time zone to UTC, or change the default.
Why shouldn't this be in an existing test?
Why shouldn't this be in BLACK"?
Why shouldn't this be in StateSystemAdmin?
I think this change broke your test cases, can you have a look please? Also while you are at the tests have a look if the others are still working.
I think this change broke your test cases, can you have a look please? Also while you are at the tests have a look if you are still running the tests without any changes.
I think this change broke your test cases, can you have a look please? Also while you are at the tests have a look if you are still running the test without any changes.
move the persistor.write() to a finally block?
any reason to catch Exception?
move the persistor.write() to a finally block.
You can use a constant for this.
You can use a constant for this, like you did in other places.
You can use a constants for this.
You can use the BoundingBox.toString() method here
You can use the BoundingBox.toString() method to have a null on the UI.
use a constant
Logging and throw is imho an anti-pattern since the code doesn't have it.
Logging and throw is imho an anti-pattern since the code doesn't get invoked.
Logging and throw is imho an anti-pattern since the code doesn't care about.
Why is this needed?
Why is this used?
add methods for each test
use PROJECTS_VOLUME_NAME for the name
use PROJECTS_VOLUME_NAME here.
use PROJECTS_VOLUME_NAME for the volume name
should we add this list of pipelineConfigs, for consistency?
should we add this method to the list of pipelineConfigs, for consistency?
should we add this list of pipelineConfigs, just the links list?
I believe we do not need to use Rule here. Is test execution case handled by the new test case?
I believe we do not need to use Rule here. Is test execution case handled by the previous line?
I believe we do not need to use Rule here. Is test checking that the default behavior is on the normal side?
Why are we catching and ignoring all checked and unchecked exceptions?
Why are we catching and ignoring all checked and unchecked exceptions? The compiler seems to allow this type to be ignored.
Why are we catching and ignoring all checked and unchecked exceptions? The compiler seems to always pick them up.
The exception is not thrown in updateStackV4Request. Shall we move this to the catch block? Or leave it as is.
The exception is not thrown in updateStackV4Request. Shall we move this to the catch block?
The exception is not thrown in updateStackV4Request. Shall we move these to the common catch block?
rename'resource'
rename 'final'
rename to Copy
Any thoughts on whether we should also allow the empty string through this filter? (And exclude it from the filter below?)
Any thoughts on whether we want to allow the empty string through this filter? (And exclude it from the filter below?)
Any thoughts on whether we can also allow the empty string through this filter? (And exclude it from the filter below?)
Why this? This line is not necessary.
Unrelated change?
Any reason for this? This looks odd.
binObj -> dip
binObj is never set to null. It's best to use the empty collection instead of checking that something is empty.
binObj --> filePath
i think you can use [driver](<LINK_0>
i think you can use assertThat(driver, hasSize(2));
i think you meant page.get(0)
Please add code to avoid further duplication.
Please add code to avoid completely sizings.
Please keep line length under 110 chars.
redis() should be accessed as static method.
redis() should be accessed as static method. This will createUnresolved work as well.
redis() is accessed as static method.
Could you explain this change?
Could you explain why this change?
Could you explain what these two lines are doing?
This probably needs to be reworked once #6327 is merged.
This can be simplified to use CollectionUtils.isNotEmpty(id)
This seems wrong. Shouldn't we use the default block to create the service groups.
[nit] : wrap this with {}
Extra semicolon
Extra space
I don't think this log message is unique, as the actual lock may have been lost from the DB. I'd suggest make "LockLockLock" field state.
I don't think this log message is unique, as the actual lock may have been lost from the DB. I'd expect the actual lock to happen if the lock is not done.
I don't think this log message is unique, as the actual lock may have been lost from the DB. I'd suggest make "LockLockLock" field of lock.
I think we can remove this variable?
I think we can remove this condition because it can't be null at this point
I think we can remove this condition because it can never be null.
I'm not sure what is going on here. You are logging in this class. What do you think?
I'm not sure what is going on here. You are logging in this class. What do you think about is?
is there any method to protect against such method?
![MAJOR](<LINK_1> Reduce this lambda expression number of lines from 7 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_2>](<LINK_1>
Could be useful to split this into Charge not available in ledger and Charge status mismatched so we will be able to quantity them by type (missing / mismatch..)
Could be useful to split this into Charge not available in ledger and Charge status mismatched so we will be able to quantity them by type (missing / mismatch ).
I think we need to split this into Charge not available in ledger and Charge status mismatched so we will be able to quantity them by type (missing / mismatch ).
I think it would be better to move this to superclass
I think it's better to move this to superclass
You should move this to superclass
Do we need to call dismiss() here?
Do we need to call trim() here?
Can we rename this to dialog or something similar?
Why removing this?
Why exclude the connectionList and adding a new connectionList?
Why exclude the connectionList and a new one?
need to think about this one.
need to use System.out
need to use brackets here
how URISyntaxException is handled in places where this method is called?
how URISyntaxException is handled in places where we handle this case?
how URISyntaxException is handled in places where we handle this?
use ArrayNode instead?
use ArrayNode
Use ArrayNode instead?
are you sure?
not sure why you are moving this
not sure why you removed this
If leaderElector.onFatalError returns false and then immediately handle leaderElector.onFatalError will return false if the leaderElector.onFatalError returns false. Is this intentional?
If leaderElector.onFatalError returns false and we are not waiting for leaderElector.onFatalError() will call onFatalError anyway.
maybe call onFatalError here?
This means we would be able to clean up the exception if the value is "aerogear" a value, not a value. I would imagine that the "value" has the advantage of being a static value, rather than "aerogear" being a value.
This would be clearer as a system property, not a value, but value is only "aerogear"
This means we would be able to clean up the exception if the value is "aerogear" a value, not a value.
rename to entry
rename to category
rename to key
use isEmpty() instead of size()
use putIfAbsent instead of _size_
This looks like we are using the same query as before
Can you please move this condition to the fetchCpuProfileValidator and remove the duplicate null check?
Can you please move this block to the fetchCpuProfileValidator and call it twice?
Can you please move this block to the fetchCpuProfileValidator and call it twice? It's more readable
Are we not setting the account id?
Are we expecting this to be null?
Are we not setting the account id too?
Shouldn't we use warn here?
Shouldn't we use.toString() here?
suggestion.warn("Channel is not open, no connected message.", e);
Did you mean to remove this?
Did you mean to remove the System.out?
Did you mean to remove this? It is always the same as the method above?
Please consider to add space between "if" and "(" to be consistent with )
Please consider to add space between "if" and "else if"
Please consider to add space between "if" and "else"
I don't think we need to add some basic handler here - when the poller is transactional, we can clear the queue without a max size.
I don't think we need to add more details when the exception handler is not set to the message.
I don't think we need to add some basic handler here - when the poller is transactional, we can clear the queue without a maxSubscriber.
jsonMapper should never be null, it's possible for getAggregators to be a null for a queryableIndexAndSegments method.
jsonMapper should never be null, it's possible for this method to return a non-null Map<>, so a null check is unnecessary.
jsonMapper should never be null, it's possible that a aggregator can't be null.
this variable should be made into something like TextView?
this variable is unused
this variable looks like it's used twice
Please use close to avoid a race condition for this
It's actually shorter to use brooklyn.util.newWriter to avoid copying the files
Please use close to avoid a race condition
Why do we need to set this to null?
Why do we need to set this to true when sent to the client?
Why do we need to set this to true when sent from the client?
objects cannot be null after the constructor. (write if (fTrace == null), you will get a compiler error)
objects cannot be null after the constructor. (write if (fTrace!= null), you will get a compiler error)
objects cannot be null after the constructor. (write if (fTrace == null)
please use ClusterUtils.hasGateway
please use ClusterUtils.hasGatewayConfig() here
please use ClusterUtils.hasGatewayConfig()
Should we have a version of createHttpClients method that does this code?
Should we have a version of createHttpClients method that takes a String argument and use it in async client?
Should we have a version of createHttpClients method that does this code in the API call?
Maybe change this to trace level?
Can you please change this to trace level?
Maybe change this to containerId = containerId to Optional<String>.
suggestion TRACE_error("RequestResp:" + e.getMessage());
suggestion TRACE_ERROR = trace.get(AcceptedId.class);
suggestion TRACE_error("RequestResp: " + e.getMessage());
Maybe we should use logging instead of BatteryObject.
Maybe we should use logging instead of printing the stacktrace to stderr.
Maybe it should be a guard
I usually like this, we check for purge and listFiles to not return null.
I usually try to use purgeConfig() instead of hamcrest matchers.
I usually like this, we check for purge and listFiles, not the size
Why not use readResource-multi-value.txt here?
Why not use readResource-multipolygon and prestoImmutableList() for any reason?
Why not use readResource-multipolygon and prestoImmutableList()?
can you please keep the former constructor and remove the static from here?
can you please put this into the constructor?
should you use the fields directly?
Instead of directly using try(InputStream o) to ensure that the stream gets closed even if an exception occurs. Perhaps move this to a try-with-resources?
Instead of directly using try(InputStream baos, s) to ensure that the stream gets closed even if an exception occurs.
Instead of directly using try(InputStream baos, s) to ensure that the stream is closed even if an exception occurs.
datanodeCount?
incorrect. This should be datanodeCount
incorrect. This should be datanodeCount?
Why is this added?
Why are we not just added this here?
Why are you added this here?
This is not consistent with the rest of the code (seems like it also exists in the diff template).
This is not consistent with the rest of the code.
This is not consistent with the rest of the code (seems like it also exists in the diff template), use Collections.emptyMap()
I would prefer to move this to the Broadcaster
I would prefer to move this to a Broadcaster
I would prefer to move this to a constructor.
[minor] Space before Object
[minor] Space before Object?
[minor] Space before Object?
If user has accepted selection of let's say 30 elements (without "Don't show this again", does it make sense to show this again when unselecting some (e.g. going down to 20)?
If user has accepted selection of let's say 30 elements (without "Don't show this again", does it make sense to show a dialog to the user?
If user has accepted selection of let's say 30 elements (without "Error", then the dialog will not show this again"
You can use the ComponentCategory.DESCRIPTION constant for this Request
You can use the ComponentCategory.DESCRIPTION constant for this param.
You can use the ComponentCategory.DESCRIPTION constant for this Request.
Suggestion: Can unrelated changes be pushed as separate iteration?
Style-nit: Can't we avoid parens here and elsewhere?
Style-nit: Can't we avoid parens here and in the else case?
I think the method name is a bit confusing. How about something like "FeedItemItem" instead?
I think the method name is a bit confusing. How about extracting something like FeedItem, with two words, that one for the two item is registered at the same time?
I think the method name is a bit confusing. How about extracting something like FeedItem, with two words, that one for the two item's owner and one for the other?
Why is ldapApiEnumeration returned an empty string? You could use for these cases.
Why is ldapApiEnumeration returned an empty string? You can use for these cases.
Why is ldapApiEnumeration returned an empty string? You should use those for these properties.
Unnecessary empty line
Switch to the word Java?
Could be static.
This seems to be similar to ImportVmModel.createSearchPattern() It would make it more readable and not duplicated.
This seems to be duplicated...
This seems to be similar to ImportVmModel.java
prefer interface Set<String> tos = copy(destinationBccs, ccs.size()); if (isEmpty()) { return; }
prefer interface Set<String> tos = copy(destinationBccs, ccs.size()); if (isEmpty(subject) {
prefer Strings.isEmpty() to check for null.
!equals()
Change this to use an early return.
!equals() please
Suggest checking for null before calling getIntervalHistogramAnd{4}() instead.
Suggest changing the creation of the metric name to "thPercentileLatency".
text should be in the message
Perhaps a message like "Should not be present"?
Perhaps a message like "Should not be able to get issue"?
Perhaps a message like "Should not be able to get statement"?
potential NPE: db is @Nullable
Please write a loop for this.
potential NPE.
Typo in exception message.
Log it too.
Typo.
This is wrong, but I think the first arg should be IType.class, right?
This is wrong, but I think the first arg should be the IStructuredType index. There is no need to be a IStructuredType index.
This is wrong, but I think the first arg should be the IStructuredType I believe.class in this case the string should be of type IType.
Shouldn't we use getText() here, for better readability?
Shouldn't we use getText() here?
Shouldn't we use getText() here, regardless of whether the view is disposed?
try to avoid removing environment variable entirely
try to avoid necessary environment variable in code
try to avoid necessary environment variable
this should come after the volume==null check
the volume==null check should come after the volume==null check
here the volume should be shown even if the volume is down
can you use the first element only here?
is it necessary to do the split?
is it possible to define the first argument here?
Agree with @DaanHoogland here. sysuptime isn't indeed now(), but for how long the system takes place...
Agree with @DaanHoogland here. sysout isn't indeed now(), but for how long the system has been up.
Agree with @DaanHoogland here. sysuptime isn't indeed enough?
are we setting a property? this seems to be a constant
formatting
A formatting looks off
Please use proper logging instead of printStackTrace()
Please use proper logging.
Please use proper logging in output.
I think it's better to have a boolean isInstructor = Boolean.parseBoolean(isToBeRemoved); and use it in the else block instead.
You should have a toast message here.
You should have a toast here.
How about bring this to a method that returns the labelNames?
Maybe use a for loop here for (LabelType label : multiple LabelTypes) { labelNames = labelNames.add(labelNames); }
Maybe use a for loop here for (LabelType label : otherNames) { labelNames.add(labelNames); }
Format?
Format? Please use { } for all blocks.
Format this file.
Why don't you create the taskType as a variable and use the value?
Why not try to use volUUID here?
Why don't you create the taskType object as a variable and use the value?
Shouldn't we put the name of the file in a constant somewhere?
Shouldn't we put the second part of the ifs before the if?
Shouldn't we put the second part of the ifs before the if? I think it could be removed
A better way to understand if, why not to use append here?
A better way to understand if, why not to use the existing dynamic instance of the queue pool?
A better way to understand if, why not to use append here.
Instead of removing the trailing white space, I'd recommend removing the else here.
Instead of removing the trailing white space, I'd recommend adding a else statement here.
Instead of removing the trailing white space, I think it's necessary to just copy the URL.
Consider to use Objects.equals method.
Consider to use Objects.equals()
Consider to use Objects.equals for comparing
Just a suggestion, Why don't we set checkpointing to 1000?
Just a note: Why don't we set checkpointing to 1000?
Just a note: Why don't we set checkpointing to 1000 here?
I think we can make this a bit cleaner by using the code here, in the future we have moved, create the variable if we're not going to use it
I think we can make this a bit cleaner by using the code here, in the future we can avoid the need to do the trick.
I think we can make this a bit cleaner by using the code here, in the future we have moved, create the variable if we're not using it
forgot to commit the printStackTrace()
forgot to commit the stack trace and let the exception propagate.
forgot to commit the stack trace and print the stack trace and message
You can remove ".isEmpty()" variable.
You can move this to strings.xml
You can remove.split().getFullName()
Agreed. I think that you want to match the valid intervalExpression here, but not a list.
A better error message would be: "Cannot parse range expression by one of intervalExpression: %s"
Agreed. I think that you want to match the style of the surrounding code.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported and that method is unused, so both can be removed.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported and that method is unused, so both can be reused.
We don't like abbreviating variable names -- clarifies them.
this is always true hence can be skipped
why not use the constants from LfsCommand?
why not use the constants from LfsBundle?
- [x] Not required to check isDebugEnabled, because no heavy function on logging.
- [x] Not required to check isDebugEnabled, because no heavy function on locale is provided.
- [x] Not required to check if locale is null.
Can't break early here. Wrap the next loop in a null check instead
Can break early here. Wrap the next loop in a null check instead.
suggest break instead.
nit: Can we name this as well?
nit: can be simplified to constants.
nit: can be simplified to if (AvoidCommit(key)) {... }
Using Long instead of long could open the door for returning a null object.
Using this method is still part of building the object. Could this be encapsulated in another method?
Using this method is still part of building the object. Instead of using a null object, create a private method returning a null object.
Log the actual logger isn't good here.
notNull
Unneeded parentheses
There shouldn't be logic in the Bean-classes, please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitches" class. Please consider, what the code does and where it should go.
There shouldn't be logic in the Bean-classes, please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitches" class. Please extract it to the TaskService.
There shouldn't be logic in the GeneratorSwitches. Please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitches" class. Please consider, what the code does and where it should go.
I doubt this is related to the issue you're trying to solve actually. But _if_ you want to make a fix also for this here, then synchronized is not the right way.
I doubt this is related to the issue you're trying to solve actually. But _if_ you want to make a fix also for this here, then synchronized is not the cause.
I doubt this is related to the issue you're trying to make.
use a for output property and use distinct
use a for:
use distinct
try-with-resources?
Not a try-with-resources block here?
Not a try-with-resources block here.
This is there a system property I remember seeing as a jboss.server.dir system property: [ERROR] /home/travis/build/spring-projects/spring-boot/src/main/java/org/jboss/as/jelly.json.FileAttributeHandler.HOST_ADDRESS: [INFO] Initializing Mac is not sufficient.
This is there a system property I remember seeing as a jboss.server.dir system property.
This is there a system property I remember seeing as a jboss.server.dir system property, and I think only the allocator is there.
You could use String.valueOf(proposalNumber) here instead of 6
You can use String.valueOf(proposalNumber) here instead of 6
You can use StringHelper.isNullOrEmpty()
This is not thread safe but I think this method should be synchronized (this) { setTraceProperties(openedTrace); } else { String t = getValue(); if (ITmfTraceProperties.isTraceSet(openedTrace)) { return traceProperties; }
This is not thread safe but I think this method should be synchronized (this) { setTraceProperties(openedTrace); } else { String t = this.getLocation(); if (clazz.isTraceSet(openedTrace)) { return traceProperties; }
This is not the case though the trace is a trace, so this whole thing (lines 40 - 42) will be handled by the trace in the constructor.
This will not be necessary, if something is wrong with the default. A better solution would be to call Stopwatch.createStarted() instead of the raw ExecutorService.
This will not be necessary, if something is wrong with the default. A better solution would be to call Stopwatch.createStarted() and then have the register method instead of the raw ExecutorService.
This will not be necessary, if something is wrong with the default. A better solution would be to call Stopwatch.createStarted() and then have the register method instead of the raw boolean.
Remove the else {... }
Remove the else {... } frame.
remove the else {... }
Why divert and separate address is needed. Why not have the retroactive message under the original address? With having separate address will mean message has to be copied rather than it simply being a message reference to existing message.
Why divert and separate address is needed. Why not have the retroactive message under the original address? With having separate address will mean message has to be copied rather than it simply being a message reference to existing message?
Why divert and separate address is needed. Why not have the retroactive message under the original message?
nit: Seems like a good candidate for if (ID.getValue() == null)
nit: Seems like a good candidate for if (ID.getValue() == null)...
nit: Seems like a good candidate for if (ID.getValue() == null) {
Is there a reason you can't just say path.get('.')?
Is there a reason you can't just say path.get()?
Is there a reason you can't just do this: final ret = split.split(key);
Other implementations of Comparable in Java don't even check for null, do we have to?
Other bits of Comparable in Java don't even check for null, do we have to?
Other implementations of Comparable in Java don't even check for null?
I think we could use just one or two separate variables for the test: java doReturn(client).when(multiGetItemResponse).getHits()).thenReturn(any(MultiGetItemResponse.class), any(multiGetItemResponse));
I think we could use just one or two separate variables for the test: java doReturn(client).when(multiGetItemResponse).getHits()); Assert.doReturn(client.getHits());
I think these two lines can be replaced by: assertThat(indexResponse).getHits(), contains(2));
are we sure that the values are different than the one in the MockId?
since we are checking for the invalid value, would it make sense to change this to assertNotSame()?
are we sure that the values in the MockId are not 0?
Are you sure you need the getDeclaredConstructor() here?
Are you sure Throwing Exception is not a good idea?
Are you sure you want getDeclaredConstructor() here?
This should probably be 400, not 500.
This should probably be 400 rather than 500.
It might be better to use a custom mapper here as well.
Log using log instead of printing
Use log instead of printStackTrace
Log using log instead of e
Couple of things here: (a) we can use Preconditions.checkArgument here? ERO, this returns a boolean. The shape of the array might be a bit faster.
I think we should use Preconditions.checkArgument here?
I think we should use Preconditions.checkArgument here.
Same as above, would prefer that we assert on the invalid list size (obtained from txClient) instead.
Same as above, asserting on printed output is brittle.
Same as above, would prefer that we assert on the invalid list size instead.
Right, in event.getSize() instead of event.getSize()
Right, in event.getSize() instead of position()
Right, in event.getSize() isn't needed anymore
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future.
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future).
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future. Can we fix that in the future?
Hmmm... I really don't like the logic in this method. I would argue that the function is not formatted in a regular expression.
Hmmm... I really don't like this.. it should be a static method.
Hmmm... I really don't like the logic in this method. I would argue that the function is not formatted but a set.
what is the purpose of this line?
what is the purpose of this function?
what is the purpose of this?
Is there a reason why we're gonna use this block instead of adding a new line?
Is there a reason we're gonna use this form instead of breaking out the whole block inside the conditional in build().
Is there a reason why we're gonna use this line instead of breaking it up into a method to validate the list, it is a check in the constructor.
I think we will need to remove this as well
I think we should remove this one as well
I think we should remove this log and make it debug
why not make "update" a constant too?
why are we using two different sortBys for the match type?
why are we using two sortBys for the sort order?
Is "Delete %s" the correct log message?
Is "Delete %s" the correct index?
Is "Delete %s" a better name?
I think it would be better if you calledContentHandler().contains(repo) here.
I think it would be better if you add a {} placeholder in the message, so it is not added in the {}.
Unchecked assignment.
I would handle this in a finally block.
I would move this logic to a method. It is more readable.
I would move this logic to a method. It seems to work with a logical operation.
What's the reasoning for flipping the parameters? I think that's fine to replace that with an(?<!\\ with a Pattern.compileByte() function, but when testing(?<!\\ is only used once.
What's the reasoning for flipping the parameters? I think that's fine to replace that with an(?<!\\ with a Pattern.compileByte() function.
What's the reasoning for flipping the parameters? I think that's fine to replace that with a single String.
Should we change this to info or warning?
Should we change this to info or error?
Should we change this to info?
Can we make this an Optional<Error>? So that we can at least return a valid response code.
Can we make this an Optional<Error>? So that we can't get to this code path.
Can we make this an Optional<Error>?
I think this should use the new KeyExtent(tableInfo.tableId, tableInfo) function.
I think this should use the new MetadataTableUtil function.
I think this should use the new KeyExtent(tableInfo.tableId, tableInfo) function
This would change accordingly, as well.
This would change accordingly, as well as several other parts of this file.
This would change accordingly, as well as several other parts of the code
checkState
checkState instead of!
checkState?
nit: make this message clearer
nit: make this message clearer.
mutations
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom APIs that aren't region names, which would be much harder to implement/maintain.
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom API URLs that aren't region names.
Please list the injected instances with the variable.
Please list the injected Instance and then use it in constructor.
Please list the injected Instance and then use it.
Please use the variable name instead of null.
Please use the variable name "input" - this is redundant.
Please use the variable name "input" - this is redundant
StringBuilder.append(System.lineSeparator()) would make this whole block a bit clearer.
StringBuilder.append(System.lineSeparator()) should be available since that's not a string.
StringBuilder.append(System.lineSeparator()) would make this whole block a bit cleaner.
I think this is fine. We don't have to change the logic here.
I think we should change this method to use the continue statement in this method.
I think we should change this method to use the continue statement here.
This would be better as an example.
This could be done in the for loop below.
This could be done in the for loop below, as well.
@fanifieiev please, fix the indentation.
@fanifieiev please, fix the indentation. Thanks!
@fanifieiev please, fix the indentation here.
I think that we didn't set the method to be called....so this is fine, but you're setting the method that's being set differently already.
I think that we didn't set the method to be called....so this is fine, but you're setting the method that's being set differently already (here and in the other methods below).
I think that we didn't set the method to be called....so this is fine, but you're setting the method that's being set differently based on the data view that we're using, right?
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column names
final
please don't use parameterized logging
please don't use parameterized log
please use parameterized logging
shouldn't it be <code>false</code>?
shouldn't it be ERROR?
shouldn't it be <code>false</code>?
Don't forget to add this.
Don't forget this.
Don't forget to add the correct value for this.
StringUtils.EMPTY_STRING
StringUtils.join?
StringUtils.EMPTY_SET
Please include the file name in the log message.
Please include the file name as a variable.
Please remove the redundant space.
.getResident() is not guaranteed to return null
.getResident() ->.getProcesses()
[minor] use { } please.
This complicates code quite significantly. Can you move it to a separate method?
This complicates code quite significantly. Can you move it to TracingTags?
This complicates code quite significantly. Can you move it to TracingTags that looks like a do-while loop?
I think it's better to have.map(attr -> colLenghts.length).collect(Collectors.toList()) here
I think it's better to have.map(attr -> colLenghts.length).collect(Collectors.toList()) in all next methods
I think it's better to have.map(Column::valueOf)
if we fail here we have a stale VM version in hand. we should roleback
SDR or Stanford Digital Repository?
this is not necessary
Minor: Space between if and (
Similarly, Space after if.
Minor: Space after if.
May be worth providing the exception type?
May be worth providing the exception's logged or information just to help with troubleshooting.
May be worth providing the exception when the log says that it was logged?
can we flip this around for readability's sake and put the isIgnoreInvalidRows outside the if?
log.warn("Ignoring invalid row [%s] since parsing error {}", granularitySpec.getTimestampFromEpoch(), e);
is this correct?
Do we need to create a new one each time?
Do we need to register a new eventProcessorRegistry for each event?
Do we need to register a new eventProcessorRegistry for each event? In the case, you don't need a registerEventProcessor.
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder().read(gcb.build()) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder.read(gcb.build()) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder().read(gcb.build())) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
I think you're missing the case in the first case so far.
I think you're missing the case here.
I think you're missing the case in the first case here.
This should probably be a WARN instead of an ERROR.
This should probably be a rethrown and not an exception.
Space after if,
i dont think clear is needed, it looks to me its called only once per run
i dont like teh needed, it looks to me its called only once per run
i dont think clear is needed, it looks to me its called only if vm is created
Missing space after,
Missing space after ","
Can this be removed?
consider doing this to call Notification.createNotification().
consider using a mixpanelPushNotification.isValid instead
consider doing this to call Notification.isValid()
Instead of manually building the query, this could be: java if (Objects.equals(sortField, SortOrder.ASC) { entities.addAll( sortField, filters); } else { entities = searchService.findAll(); }
Instead of re-implementing the backend, this could be: java if (Objects.equals(sortField, SortOrder.ASC) { entities.addAll( sortField, filters); } else {
Instead of manually building the query, this could be: java if (Objects.equals(sortField, SortOrder.ASC) {
Isn't it possible to keep the config static final and change it to a constant?
Isn't it necessary to enable/disable this?
Isn't it possible to keep the config static final and return a non-static field?
I wonder if this check shouldn't be in isDone(). Also, I wonder if it would be cheaper to skip the isDone() check and always return the result.
I wonder if this check shouldn't be in isDone(). Also, I wonder if it would be cheaper to skip the isDone() check and always return the future if (notifier.isDone()) return null;
I wonder if this check shouldn't be in isDone(). Also, I wonder if it would be cheaper to skip the isDone() check and always return the future.
Should be in a finally block to unlock.
Should be in a finally block to unlock?
Should throw a SQLException.
nit: should this be in the constructor?
nit: can you change this back to 'Json(RestResponse.BuilderHolder.class)'
nit: can you change this back to 'JsonRestResponse.Builder'?
Does OpenShift machine have meaningful toString() to use here?
Does OpenShift machine have meaningful toString() to be used here?
Does OpenShift machine have meaningful toString() to use it here?
should be or equal to poolStatusParameters
should be or equal to oldStatus
should be or equal to oldStatusParameters
Might the sleep suffices to wait for the thread to finish?
Might the sleep suffices to wait for 10 seconds to finish?
Might the sleep be more readable?
Isn't this going to be the same as the LOGGER.log(RunT.class.getName(), re)?
Isn't this going to be the same as the previous log?
You don't need to check this.
While this is done, it's great to use a lot of tough action :wink:
While I know this isn't done, do we want to use a setClampHeight() method here?
While this is done, it'd be good to use a normal while loop.
Why not just let the type parser handle the extra logic?
Why not just always set damage and then add it?
Why not just always use map, and then we don't need the type to be consistent?
This line could be removed (does not add much, it already goes to next cycle).
This line could be removed (does not add much, it would have to be deprecated)
This check is not necessary as it would have caught already.
not doing this kind of logic. Should be moved out of the loop.
not doing this kind of logic but should be moved out of the loop so that check and decrement are done in a separate loop.
not doing this kind of logic but should be moved out of the loop.
Assert.assertEquals(connectionString, "User " + token + " = " +
@bxf12315 should we use printQueueProperties here?
use assertEquals here.
How could we get a null value for the externalFileTypeByExtension?
How could we move the code in the if and else statement to a function in the else?
How could we move the code in the if and else statement to a function?
Why are we hardcoding the value here?
Why are we hardcoding the value here? Why not just use the default value?
Why are we hardcoding the value here? What will happen if we run the successfully run?
Why was this removed?
why remove this?
why was this removed?
Why don't you just use o as a variable?
Why don't we just use o as a property?
Why don't this just be o.get("id")
The test case should run in a transaction and throw a TransactionHelper.runIn transaction when the method is called.
The test should run in a transaction and nothing else.
The test case should run in a transaction and throw a TransactionHelper.runIn transaction when the method is executed.
I think it is more readable if/else here.
I think it is more readable if/else block here.
I think it is more clear to just add else { return valueData; }
java8-isation [forEach][filter]
java8-isation [forEach]
java8-isation [forEach][map]
GitHubCertificatess may be null. If so, it must be closed automatically.
GitHubCertificatess may be null. If so, it must be closed closed.
GitHubCertificatess may be null, so it must be closed automatically
Our toasts are nice - and you could perhaps instead pass an entry into the constructor and then set it up with an empty map - and you do not need this.
Our toasts are nice - and you could perhaps instead pass an entry into the constructor and then set it up with an empty map - and you do not need this...
Our toasts are nice - and you could perhaps instead pass an entry to the constructor and as an argument, and then instead of adding an entry to the constructor
This would be a bit clearer as a one-liner: @Override public void getElementToHighlightAtPosition(View element, View child, Rect bounds) { final View child = element.getChildCount(); if (bounds == null) { child = element.getChildCount(); } else { child = element.getHitRect(); } return parent; }
This would be a bit faster if we could use an getChildCount method.
getChildCount can be removed
Maybe you should use BL layer name or not, like we have above in the API <LINK_0>
You should ignore parametrization instead of string concatenation.
You should ignore parametrization instead of string concatenation
Should we still keep this project (the abstract projecT) query here? Or should we look for all modules?
Should we still keep this project (the abstract projecT) query here?
Should we still catch this exception, you need to update it to debug logs?
Static import?
To make this a bit more readable, I would re-use the variable name.
Static import
nit: we could do this as a getPartitionState().equals(dataNodeId)
nit: we could do this as a.equals(dataNodeId)
nit: we could do this as a.equals(dataNodeId) method like you do for the other similar cases.
containerByteOffset is probably more appropriate here, but containerByteOffset is always zero
containerByteOffset is probably more appropriate here, since containerByteOffset is always 0
containerByteOffset is probably more appropriate here, since containerByteOffset is always zero
Shouldn't we remove the Realm and its management files?
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios?
Is it possible to make this check be moved after migrate()?
One more nitpicky but I'd prefer to see DelayedViewJGroupsTransport.Scattered() here.
Will DelayedViewJGroupsTransport be true?
Will DelayedViewJGroupsTransport ever return false?
Better to keep this variable declaration inside the loop as it changes on every loop iteration. Having it declared inside the loop ensures that it's value can't "leak" from one iteration to another.
Better to keep this variable declaration inside the loop as it changes on every loop iteration. This is the only place where it's used except in the loop.
Why did you put this inside the loop? It's hard to read.
Please use org.ovirt.engine.ui.uicompat.external.StringUtils#isNotEmpty
Please add a check here please :-)
Please add a check here that can be null
I think the code would be clearer if the number of times into a method "set" or something like that.
I think the code would be clearer if the number of times into a method "set" or something like that. (more efficient)
Code duplication
To make it more logging, we can log this as a warning.
To me it would be better to log this at info level.
To make it more log statements we can move this to a log statement.
can we use sleep here?
same here, it is not(30) to be more readable
same here, it is not(30).
If this array isn't meant to be modified aftewards, you can now use ImmutableList.of
If this array isn't meant to be modified aftewards, you can now use ImmutableList.of(eventName).
Assert not necessary since the elements are counted below
Save an... --> Saved an...
Save an... --> SavedEvent
Save one line
This test and the test before would be more interesting if just the "includeData" parameter when building VariantMongoWriter is changed (now we are changing include samples too). If one of both is required, it should be made explicit in VariantMongoWriter (I don't see that check)
same here, this test and the test before would be more interesting if just the "includeData" parameter when building VariantMongoWriter is changed (now we are changing include samples too). If one of both is required, it should be made explicit in VariantMongoWriter (I don't see that check)
This test and the test before would be more interesting if just the "include" parameter when building VariantMongoWriter is changed (now we are changing include samples too). If one of both is required, it should be made explicit in VariantMongoWriter (I don't see that check)
If you move this to handleManagerFactory handleManagerFactory handle providers, then you don't have to pass the factory to the user.
Let's move this to handleManagerFactory handleManagerFactory returns the factory.
If you move this to handleManagerFactory handleManagerFactory returns the factory against the application.
Is this meant to be public?
Delete this line.
This will throw an exception if the object doesn't have a reference to the corresponding object.
I think it would be beneficial to use == for the check.
I think it would be beneficial to have check for the expression and the expression.
I think it would be beneficial to use == for enum and implementation (you'll need to check for the expression and the value.
Where is the exception caught?
I think the exception is not an interrupt, so you probably want to log something too.
Where is it being shut down?
This is too long. We can have a wait here, perhaps?
This is too long. We need to have a wait here?
This is too long. We can have a wait here!
link with the problem of dependency explained in MANIFEST.MF
link with the problem for the moment.
link with the problem of dependency explained in MANIFEST.MF.
[nit] I think we don't need a local variable here.
Several things here... First, the condition you're using is slightly different order than the actual number of values. The first thing is to use more than the actual number of values.
Several things here... First, the condition you're using is slightly different order than the actual number of values. The first thing is to use more than the actual number of entries.
suggestion assert( constraint.isValid( Byte.MIN_VALUE ) );
suggestion if ((byte) ) ) ) {
suggestion assert( constraint.isValid( Byte.MIN_VALUE, new ), true);
Why not to get it once?
Why not to get it each time?
Why not to get it once?
no need for.toString()
no need for the read here
read-only
Was this change necessary?
Don't you think we need clean up the path of the python file?
Don't you think we need clean up the path in the envData?
AnnotatedTypeMerger.
I don't think it is right to put this else here.
The first if and else blocks are redundant.
We should probably use.equals instead of CamelContext.
I don't think this is a good idea. We should not add a prefix to this.
We should not be doing this in a loop.
Add a break here, just to make the code more obvious.
Add a line before the "if" to avoid any break.
Add a break here, either.
Just to be pedantic, I'd prefer using <LINK_0>
Just to be pedantic, I prefer using <LINK_0>
Just to be pedantic, I prefer using <LINK_0> as it doesn't yet support java.lang.Long
log.tracef
log.infof
logf?
I think there's no need to change this behavior. Before, we could have a new returnType's body, and then use it to handle the case where it's empty.
I think there's no need to change this behavior. Before, we could have a new returnType's body, and then use it to handle the case where there's no body.
I think there's no need to change this behavior. Before, we could have a new returnType's body, and then use that to handle the case.
Since you are testing the callback on the result of the test, you should probably define it into a @Before method.
Since you are testing the callback on the result of the function, you should probably define a mockCredential method and avoid having to call it twice.
Since you are testing the callback on the result of the test, you should probably define it into a setup method.
Looks like you dropped the 1. Do you need this? 2. Create an external server with a basic auth string in Authenticator.setDefaultProxyHost and it will just print the appropriate url on the login machine.
Looks like you dropped the 1. Do you need this? 2. Create an external server with a basic auth string in Authenticator.setDefaultProxyHost and it will just print the appropriate url by name.
Looks like you dropped the 1. Do you need this? 2. Create an external server with a basic auth string in Authenticator.setDefaultProxyHost.openConnection() and then just return null which it is.
Any reason not to use collect(...) instead of manually adding the entire collection?
Any reason not to use AtomicReference here?
Any reason not to use AtomicReference?
if (StringUtils.isNotEmpty(request)) {
if (StringUtils.isNotEmpty(authorizationInfo)) {
if ( (StringUtils.isNotEmpty(request)) {
UndefinedDatabaseException should be handled.
UndefinedDatabaseException also should be handled.
UndefinedDatabaseException must be handled.
Use new BlockRealMatrix(shape[0], shape);
nit: maybe use new BlockRealMatrix(shape[0], shape); here (and in the loop below)
nit: maybe use new BlockRealMatrix(shape[0], shape);
@dskalenko yes I found that you missed some of these "\n"s in [AST generic = DiamondOperatorCheck.this](<LINK_0>
@dskalenko yes It would be great if you can move this IF block into isNotArray method.
@dskalenko yes It would be great if you can move this IF block into isNotArray method and return it in findFirstTokenCheck.
This seems like an executor. Why not use the Timer.alertEmails?
This seems like an unnecessary call to.toString() on executor.
This seems like an unnecessary call to.toString() on executor. Is this intentional?
you need a null check here to ensure it's not null
can't you reuse the application instance here?
can't you use the application instance here?
This would be better to be in Utils. testConnection( userAgentHeader)
This would be better to be in Utils, but 'userAgentHeader' is ','refreshHeader'.
This would be better to be in Utils, but i'd prefer to use reflection assertions.
Why did you call req. Getting file? Is it more readable?
Why write?
Why remove?
suggestion var myField = new InputStreamReader(new InputStreamReader(conn.getInputStream()));
suggestion var myField = new InputStreamReader(conn.getInputStream(), "foo");
suggestion var name = new URL("<LINK_0>");
Isn't EMPTY_COPweight.FLAGS_C == false?
Isn't EMPTY_COPweight.FLAGS_C == false by design?
Isn't EMPTY_COPweight.FLAGS_C == false by default?
"vault.isEmpty()" seems like a good idea.
"vault.isEmpty()" seems like a bad idea, because it is not supposed to return a number.
"vault.isEmpty()" seems like a bit strange.
Unhandled
Unhandled equals(...)
Unhandled?
Why not return Collections.emptyList()?
Why not return Collections.emptyList()?
Why not return Collections.emptyList() like you do in the constructor?
do you need to clean this up?
do you need this?
unneeded formatting
Aren't you making the constructor private?
Are you sure we should use a styles file here?
Aren't you not showing up in your case?
We should make this run in a separate thread. I suggest to either use execute() or getDiscoverySpiCustomMessage(), but not one from other?
We should make this run in a separate thread. I suggest to either use execute() or getDiscoverySpiCustomMessage(), but not one from other.
We should make this run in a separate thread. I suggest to either use one or another one.
This is redundant.
Why is this necessary?
Remove this.
Similarly here for the csv variable.
Similarly here for the csv template.
Similarly here for the csvRecord
Throwing an exception is not a good practice. You can just catch the exception and log it.
Throwing an exception here could make the code more readable. There are two options: 1.
Throwing an exception is not a good practice. I think it is better to just catch the exception.
We actually don't like this method. Why are we checking Math.abs() and Math.abs()?
We actually don't like this method. Why are we checking Math.abs() here?
We can use **collapse** method
same here as above.
Extract "x-y" to constant.
Extract as constant.
I rather like to see this function triggered by simulating a mouse click on the main thread, which is not right?
Can be replaced with: main().notifyListeners(new Version());
Can be asserted on a function function
if (list.contains(folder)) { list.add(folder); } else { //change the code }
if (list.contains(folder)) { list.add(folder); }
Move the if inside the if.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported by default.
Please add a note about how MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported.
use realmName.add(authorization-realm); instead.
Is it really worth to use realms.add(authorization-realms); instead?
Is it really worth to use realms.add(authorization-realm); instead?
equals() should be compared using hashCode().
Needs a null check here: if (!(obj instanceof Ds3Element)) return false;
Extra parentheses
Accidental rename?
Accidental white space
Formatting
awaitRetentionExpiration(1_000);
awaitRetentionExpiration(1_000); 10ms -> awaitRetentionExpiration(1_000);
awaitRetentionExpiration(1_000); 10ms
Should we define a public static final variable here?
Should we define a public static final variable for getString(Class<?> callback) method?
Should we define a public scope parameter for getString?
Is this dependent on the computer's time zone?
I think this is time zone, not the computer's time zone
I think this is time zone
Again, can you use if (Strings.isNullOrEmpty(name)) {
Again, can you use if (String.equals("tera")) {
Use Constants.HEADER_VERSION constant
I think this should not be done in every iteration (for example projects).
I think this should not be done in every project.
I think this should not be done in every request.
add quotes and replace
add some static import for String.format
add quotes and replace.
It's better to use <LINK_0>
It's slightly better to use <LINK_0>
It's not reasonable to use < coins, so you don't be touched.
remove empty line
Add try/catch everywhere please.
Remove empty line
Why apply the conversion to JSON here? Why not apply it into one place?
Why apply the conversion to JSON here? Why not apply it via Translator instead?
Why apply the conversion to JSON here? Why not apply it into the cache?
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in a way that's loggable.
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in its own method.
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in a try/catch.
null check
null check please
null check needed
Not sure if we have a test for this.
Not sure if we have a test for it.
Not sure if there are any methods in getAnnotation that have given name.
You should do LOG.info("Update injection for this injection.", e); instead of printing the message yourself.
You should do LOG.info("Update injection for this injection: {}", rootOfClass);
You should do LOG.info("Update injection for this injection.", e);
Same here - [ERROR] Failed to delete the responseParsed..[![rule](<LINK_1>](<LINK_2>
Same here - [x] Dead code base (where you modified the responseParsed..) to re-use the whole string.
Same here - [x] Dead code base (where you modified the responseParsed..) to re-parse the whole string.
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here! So you should only limit the returned values, not when there are still incurring the cost of iterating over every project here!
This solution still does this lookup and these tests potentially many times for the same parentproject. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either data has been sent in the stream? Should MessageInfo offer a constructor that does not require TTL so that 'unset' TTL is hidden behind its interface? 0 or -ive TTL seems like implementation details that should not be required in the interface.
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either data has been fetched from MessageInfo? Should nt that be an internal exception type?
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either data has been fetched from MessageInfo? Should nt that be an internal exception type? Should MessageInfo offer a constructor that does not require TTL so that 'unset' TTL is hidden behind its interface.
Missing final
Is 'Sonar' not needed here?
Is there a particular reason to have final Set here?
This looks like it's impossible. Given L68, sampleRateIndex can only be 0,1,2 or 3 here, I think? If you agree, can you remove this block (and the TAG constant near the top).
This looks like it's impossible. Given L68, sampleRateIndex can only be 0,1,2 or 3 here, I think? If you agree, can you put this block in #90 like so?
This looks like it's impossible. Given L68, sampleRateIndex can only be a constant value, and the TAG is used only for this method.
It is getId() of the pool -- see the other Tracer invocations
It wasn't clear to me that this would mean that the other Tracer invocations have the same pool. So is it intentional to remove it?
It wasn't clear to me that this would mean that the other Tracer invocations have the same pool. So is it intentional to change it?
If the topology container has been removed from the list, it will be problematic to try to find the standby of input standbys. But since you have two concerns: 1. The topology container first, there is a standby of 2. If the topology container has been removed and the second standby is removed from the list, the check in will be true. 3. The list of standbys have been removed from the same container. 4. The standby list is empty (i.e., standby_container_id_2) will be zero.
If the topology container has been removed from the list, it will be problematic to try to find the standby of input standbys. But since you have two concerns: 1. The topology container first, there is a standby of 2. If the topology container has been removed and the second standby is removed from the list, the check in will be true. 3. The map is empty. 4. The check here should be done again, not 1.
If the topology container has been removed from the list, this check will not work. I think we can just iterate over the map. Then the check is done in that order.
I think we can just use the same QueryException
As I think we don't need this then.
I think we can just use the same QueryException is thrown.
Rename this variable too?
Rename this variable too.
Rename these two lines into one
I think this should be done in a finally block.
I think it would be good to at least log the instance info here instead of just the error.
I think it would be good to at least log the instance info here (maybe debug)
I couldn't figure out the implementation of this method. The loading of the entries is already done on line 19.0. Why do we need to save any identification of entries?
I couldn't figure out the implementation of this method. The loading of the entries is already done on the entry7 we can't just do the conversion.
We can do the same in other round trips, to keep windowating as far as possible.
minor: change exp to exc, since this is also done for response status
minor: change exp to exc, since this is also done for other cases
minor: change rest to exc, since this is also used in other places.
Can this inside the first line be merged into the condition? java String[] strings = Joiner.on("encountered a user")).split("encountered a user agent that doesn't exist")
Can this inside the first line be merged into the condition? java String[] strings = Joiner.on("encountered a user")).join(Collectors.toList());
Can this code be reused?
remove
remove the log
remove the version
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
I think you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will likely need to reuse the threadpool
Don't change this just add spaces: if (vote == 0) { return...; }
Don't think this is possible if the mover is inside of the if block, but here is very strange.
Can't you just use lambdas here?
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-frontend?
I have question about this config. Will this determine the serverfactory for ambry-server?
I think it could be isValidOverBlackListPatterns(input).matches(input);
I think it could be isValidOverBlackListPatterns().
it could be isValidOverBlackListPatterns
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException))?
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException))?
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e instanceof CancellationException || (e instanceof CancellationException && (e instanceof CancellationException || (e instanceof CancellationException))?
shouldn't we check the return value of the action?
shouldn't you check the return value of the action?
shouldn't we check the return value from glusterVolume?
Here is the same as below. Also, do you need to assert that the text is correct?
Same here, do you need to set the values for it?
Same here, do you need to set the values for foreignAchTasks?
Use static import CUSTOM_DATA_SCHEMA and CUSTOM_ENTITY_PREFIX
Use static import CUSTOM_DATA_PREFIX
Use static import CUSTOM_DATA_SCHEMA
Consider changing the variable name as well.
Please change the variable name as well.
Please make the variable names bigger.
please create a java.util package so that we don't create the project here.
please create a java.util package so that we don't create the directory here.
please create a java project named "Project" and use it in the project name.
Probably want to keep this warn level as well.
Probably want to keep this warn level to reduce the noise.
Probably want to keep this warn.
This print stack trace would be useless in some cases.
This print stack trace is useless in some cases.
This print stack trace would be useless if you use logger?
null check after use
null check after the cast to GuavaGroupReady.
null check after the cast to GuavaGroupReady?
Why the message?
Why the whole message?
Why the stacktrace?
It's strange that we could introduce the same condition for both routingTableUpdate and decrementTableUpdate. Could you please rename it to applyRoutingTableUpdateReplyMsg or something along those lines?
It's a bit hard to follow. Could you please rename it to applyRoutingTableUpdateReplyMsg or something along those lines?
It's strange that we could introduce the same condition for both routingTableUpdate and decrementTableUpdate. Could you please undo the checks in [1] <LINK_0>
This timeout is longer than 120 seconds. Travis builds are failing because you're waiting for the task to finish.
This timeout is longer than 120 seconds. Travis builds are failing because you're waiting for 2 seconds.
This timeout is longer than 120 seconds. Travis builds are failing because you're waiting for 2 seconds. Please fix this test.
final
this can be final
this can be private
Can we have a test that verifies that checkEvict will always return false?
Can we have unit tests for both count and expectedReads?
Can we have a test that verifies that checkEvict will always return true before doing assign?
what I don't understand is the the else clause in line 437 below? Why is there an else?
what I don't understand is the else clause in line 437 below? Why is there an else?
why do you need to clear this.
What about using org.eclipse.swt.events.SelectionListener.widgetSelectedAdapter(Consumer) and simply call the comboViewer() if it is empty.
What about using org.eclipse.swt.events.SelectionListener.widgetSelectedAdapter(Consumer) and simply call the comboViewer() if it is not null?
What about using org.eclipse.swt.events.SelectionListener.perform(this)?
Is it future-proof to look for the second element? In the future couldn't collapse these fields. Maybe if you look for the second element? In the future couldn't you look for the second element?
Is it future-proof to look for the second element? In the future couldn't collapse these fields. Maybe if you look for the second element? In the future couldn't you have the field's name?
Is it future-proof to look for the second element? In the future couldn't collapse these fields. Maybe if you look for the second element? In the future couldn't you have the field's name.
typo: you have two "if"s To avoid confusion?
typo: you have two "magic" numbers
typo: you have two "f"s To avoid such typos, please copy from the config directly.
nit: can you also use assertNotEquals instead of == operator combined with assertFalse, == does not work properly for non-objects. <testing
nit: you could use assertNotEquals instead of == operator combined with assertFalse, == does not work properly for non-objects. <testing
nit: you can use assertNotEquals instead of == operator combined with assertTrue, == does not work properly for non-objects. <testing
I think this should be checked at the beginning of the method, before the getWorkTree() call in order to avoid the need to check for null, and return the stagingEntry.getPath() call in order to return the latest one
I think this should be checked at the beginning of the method, before the getWorkTree() call in order to avoid the need to check for null, and return the stagingEntry object once.
I think this should be checked at the beginning of the method, before the getWorkTree() call.
Magic for HTTP, not for redirect.
Magic for user agents
Magic for HTTP, not for HTTP.
The oldFile variable is not used.
The oldFile variable is not used. It is better to use getPath() here
The oldFile variable is not used. This is how we log an error if the file is empty.
I would move this into the catch block
s/readMetricCounter/totalResponse/g
I would move this to the catch block
This is fine. If you just want to have an empty scenario from here, you should probably do this in a more fine-grained manner.
This is fine. If you just want to have an empty scenario from here, you should probably do this in a more fine-grained way to make sure that the listener will actually get the event from the ui.
This is fine. If you just want to have an empty scenario from here, you should probably do this in a more fine-grained way to make sure that the listener will actually get the event from the ui
s/public//
Please add spaces before and after +.
Please add spaces before and after =
May be separate into two lines?
convert to System.identityHashCode to avoid that
convert to System.identityHashCode
Here you can use UIModel.GitResSyncShell.GitResSyncShell(GitResSyncShell.DIST_END);
Here you can use UIModel.GitModelWorkingTree_ID here.
Here you can use UIModel.GitModelWorkingTree_ID_SUFFIX instead of hardcoding this value
nit: if (value.equalsIgnoreCase(Calendar.DAY_OF_YEAR)) { Code style.add(...) }
nit: if (value.equalsIgnoreCase(Calendar.DAY_OF_YEAR)) { Code style }
nit, please follow the same convention as in other places
is this if necessary?
why is this inside the loop?
why is this synchronized?
:bug: ditto
hasPermission(Item.CONFIGURE)) is a null check, no?
hasPermission(Item.CONFIGURE)) is better
Check if (excludeSet!= null)
Check if (excludeSet!= null) first
Check if (excludeSet == null)
Instead of typing "A, B" I think you can just use B" here.
Instead of typing "A, B" I think you can just use B" here?
Instead of change this to an index, you can use count as the capacity to match the index
Should we at least log warning if clientConfig.isUsedPortConfiguration()?
Should we put this as the default value of clientConfig.getPropertyAsBoolean()?
Should we at least log this as warning?
I'm not sure I like this idea: executor.execute(() -> executor.get(i))
I'm not sure I like this idea: executor.execute(() -> executor.get(i)). The same goes for all the other operations in this class.
I'm not sure I like this idea: executor.execute(() -> executor.get(i)) may be used twice.
no need for this local variable. at the end of the method.
redundant Guid.isNullOrEmpty(userId)
there is no real reason to return true here?
It seems that result is false by default.
It seems that result is a duplicate of the above code. Any reason it isn't?
It seems that result is a duplicate of next logout() and kerberos auth.
Why do you wrap it with an ArrayList and not just return registry.getContent()?
Why do you wrap it with an ArrayList and not just return?
Why do you wrap it with an ArrayList and not just return result?
Hourly jobs can only run on the time? are we limited to these time?
Curious - why not use milliseconds?
Curious - why 10?
Yuck. hdfs is not a good name
Yuck. hdfs.....
Yuck. hdfs = new Configuration(config);
I think this should be more for UI testing. Open trace, open the view, make sure that it is the same...
I think this should be TmfTraceManager.getInstance().getAnalysis(source).
please remove this
We should probably use something like /stor/multipart string as well.
We should probably use the separator for the slashes in the /stor/".
We should probably use the separator for that, since it's listing.
Could use assertFailureFromClusteredLock(...)
Could use assertFailureForClusteredLock(...)
Could use assertFailureFromClusteredLock(...).
Move this condition higher
Move this above the if/else
Move this above the if block
This would throw an NPE if the variable is not null.
This would throw an NPE if the variable is null.
This would throw an NPE if the method is not null.
Should be listener.fire(new IEventListener(args));
Should be listener.fire(new IEventListener());
Should be done in UserPortal ApplicationInit#init() method.
I guess this must be an assertion instead of a default?
I guess this must be an assertion.
I guess this case should be possible. It is a default, but it would be legitimate to have a default in some cases.
This seems to be failing compilation.
This seems to be failing compilation. Would it make sense to parse the entire response, rather than failing the test?
This seems to be failing compilation. Would it be possible to parse the entire response from the portal here?
Let's change this to something like logger.debug("Session is in transaction {}: {}", getBase().getSession().createProducer(), ex);
Let's change this to something like logger.debug("Session is in transaction : {}", getBase().getSession().createProducer(), ex);
Let's change this to debug as well.
can we rename the string -> docId for more clarity
can we rename the string -> docIds for more clarity
can we rename the string -> docId for more readability
<LINK_0>,%20java.lang.Object%5B)
<LINK_0> is more appropriate here.
<LINK_0>
Is this necessary? The view is already a child of the view but this can't be null.
Is this necessary? The view is already a child of the view, so we can just do child.layerName().
Is this necessary? The view is already a child of the view and will be called by the view
Can you please break this line into two lines?
Can you please break this line into multiple lines?
Can you please indent the throws?
s/local timeout/timeout/g
WARN is too frequent here. I think we should log this at a higher level.
WARN is too frequent here. Ignoring warn in the log below.
name1 -> configured
name1 -> poolCont2
name1 -> name
This close() method needs some refactoring to make sure that all the stream readers are guaranteed to be closed. For example, what happens if or columnHashes is less than 1.
This close() method needs some refactoring to make sure that all the stream readers are guaranteed to be closed. For example, what happens if or input write fails?
This close() method needs some refactoring to make sure that all the stream readers are guaranteed to be closed. For example, what happens if or columnHashes is less than 'empty'?
What's the difference between this and the try...catch?
What's the difference between this and the try?
This should be an exception?
shouldn't you check whether the enable value is true or false?
shouldn't you check whether the enable is true or false?
shouldn't you check whether the enable value is true or false too?
this text should be externalized
This should be externalized
This should be outside the if block, not outside
Response is never closed
Response is not closed
Response can be closed
This should just be config.getCheckIdleInterval()
This should just be WARN
This should just be warn
This probably isn't needed, unless we click on it?
This probably isn't needed, right?
This probably isn't needed?
We could keep the URI comparison as it may not be the case.
We could keep the URI comparison as it may be simpler to do: <LINK_0>
We could keep the URI comparison as it may not be null.
Better use the spec.getSymbolicName()!= null, in order to avoid the double parsing of the spec
Better use the spec.getSymbolicName()!= null check instead.
Better use the spec, so you can get rid of the if.
timeoutSeconds is instead of totalRuntime in seconds.
timeoutSeconds is too long?
timeoutSeconds is instead of totalRuntime
c instead of t here for Connection?
c instead of s here for Connection?
c instead of t here for Connection
Has this 3 any relation to the one in Schema?
Has this 3 any relation to the one in WAITask?
Has this 3 any relation to the one in hand? If so, or perhaps even if not, then introducing constants is a good idea and really a developer can affect it.
I would add this line before line 134, so we first fetch the LunDisk and from it we will fetch the lun.
cleaner way: return failCanDoAction(diskValidator.isVirtIoScsiReservation(getVm()));
since it is possible to add disk (LUN as well) without vm ("floating") then getVm() can be null here
1. what if vm is not in the parameters class? 2. you have to check if vm is down, and if it is pinned or not, then no need to add the host to the message?
1. what if vm is not in the parameters class? 2. you have to check if vm is down, and if it is pinned or not, then no need to add the host to the message.
1. what if vm is not in the parameters class? 2. you have to check if vm is down, and if it is pinned or not, then no need to add the host to the message. 3.The check should be good enough.
I would prefer to have a single stopKerberosLoginThread call in this method instead of from here.
I would prefer to have a single stopKerberosLoginThread call in this method and from here to see if the KerberosLoginThread is running and from here.
I would prefer to have this as static final and refactor etc.
should be debug
should be debug.
alert
The only thing I would do here is: if a component contains an TypeResolver and you don't need to have a TypeResolver, you can simply cast to TypeResolver.getInstance().ResolveDefault.class
The only thing I would do here is: if a component contains an TypeResolver and you don't need to have a TypeResolver, you can simply cast the TypeResolver to TypeResolver.
The only thing I would do here is: TypeResolver.valueOf(String)
Should we still start the activity if the search fragment is not enabled?
Are we sure we can't pass the site information in this activity without the site picker?
Are we sure we can't pass the site information in this activity without any action?
I think it would be better to use a StringBuilder here.
I think it would be better to use a constant.
I think it would be better to use a locale variable here.
Just put this line in a return at the end of the method. No need to define it.
Just put this line inside the if clause and then return false.
Just put this in a try...catch block. No need to reformat.
Doesn't compile.
Doesn't look like this is used
Doesn't seem like this is used
Isn't there a constant for the number of records?
Isn't there a constant for the next line?
Shouldn't there be a constant for the next line?
also PORT_name?
Log.error?
also PORT.toString()
java vertices.getStateTimestamp(lastChanged, job.getStateTimestamp())
java vertices.getStateTimestamp(lastChanged, job.getVertices());
java vertices.getStateTimestamp(lastChanged, highestChanged);
Why do you catch this? Should not you just ignore the index?
Why do you need this? Should not you use the index type above?
Why do you need this? Should not you use the index type above already?
The indentation is wrong. Won't this also work well when the string is not found?
The indentation is wrong. Won't this also work well?
The indentation is wrong. Won't this also work when the string is not found?
I know I'm not part of your code, but I think I'd be safer if we just stick with the default "customParagraph" and "replaces" with the name of the topic too
I know I'm not part of your code, but I think I'd be safer if we just stick with the default "customParagraph" and "replaces" with the name of the map to "String"
I know I'm not part of your code, but I think I'd be safer if we just stick with the default "customParagraph" and "replaces" with the name of the map to find it.
You may just write maxRetries, which uses the defaultRetryInterval and defaultRetryInterval. We should either create a new variable called maxRetries, or set it to the defaultRetryInterval.
You may just write maxRetries, which uses the defaultRetryInterval and defaultRetryInterval. We should either create a new instance of the Args that breaks every call with the new member.
You may just write maxRetries, which uses the defaultRetryInterval and defaultRetryInterval.
I think we want to use the same timeout as retryAfter, to avoid flooding the log.
I think we want to use the timeout here...
I think we want to use the same timeout as retryAfter.timeout() in case of timeout exception.
Use assertEquals instead of size.
Use assertEquals.
Use assertEquals instead of assertThat.
I believe this should be Objects.requireNonNull(slot, protections.getCharge()))
I believe this should be Objects.requireNonNull(slot, "variableEntitySelectorsItem.class");
I believe this should be Objects.requireNonNull(livingEntity, "env");. The same goes for all of them.
nit: I think we could use fragmentToByteArray.write(message, FRAGMENT_OFFSET_BITS)) to make the parameter optional.
nit: I think we could use fragmentToByteArray.write(message, FRAGMENT_OFFSET_BITS)) here (and below) as a parameter
nit: I think we could use fragmentToByteArray.write(fragmentByteArray); here and below
Shall we not send the offsets object in the loop. The logic looks like it's only used in the try-with-resources, and it still needs to be moved there?
Shall we not send the offsets object in the loop. The logic looks like it's only used in the try-with-resources, and it still needs to be moved there.
Shall we not send the offsets object in the loop. I am not a big fan of _switch_ to avoid repeated operations.
Does this really need to be public? It should be marked private.
Does this really need to be public?
Does this result in an extra branch that should be added here, or can it be removed?
ObjectUtils.tryCast(expression.get(expression)));
ObjectUtils.tryCast(expression.getClass())
Object -> boolean
This should be: LOGGER.log(Level.WARNING, GWCConfig.class);
This should be: LOGGER.log(Level.WARNING, GWC_CONFIG_FILE);
This should be: LOGGER.log(Level.WARNING, GWC_CONFIG_FILE_BYTES);
This could be a separate method to help readability
This could be a static method
This could be a separate method to help readability.
Minor: I'd personally prefer moving this inside the switch block.
Minor: I'd personally prefer moving this inside the switch block. Also, if it is a 'false', then we're not 'false' check this.
Minor: I'd personally prefer moving this inside the switch block. Also, if it is a 'false', then we're not 'true' check this.
Maybe store the metric type in the metric?
Maybe store the metric in the metric?
Maybe store the metricType in the metric?
ugh, blocking ALL insertions while you're iterating on the whole thing to do a query would be a huge slowdown
ugh, blocking ALL insertions while you're iterating on the whole list!
ugh, blocking ALL insertions while you're iterating on it...
do we really need to return true here?
do we really want to return true here?
do we really want to call content.insertTagMarker(content)?
remove useless blank line
remove useless blank line?
useless blank line
Use %s rather than %s
Use %s rather than %s since it's more efficient.
Use %s rather than %s since it's more readable.
rename to child
rename to removal
rename to removalContext
I would suggest moving this out of the loop.
I would suggest moving this before the try block.
I would suggest removing this part.
Shall we catch a more specific exception here?
We should log this properly too, if we need to know this is expected
We should log this properly too, if we need to know the correct exception
Can you keep the type of exception as the second argument?
Can you remove this, since it is going to be depositRecordPid be a RevCommit?
I know you haven't written this code, but would it make sense to have one abstract class that implements the interface?
Any reason to use AssertJ for assertions?
Any reason to use assertArrayEquals here?
What are your thoughts on using assertArrayEquals?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean).toString(),
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean).toString(), and String.valueOf(boolean)
Make sure you drop the pci_0000_1 and _1 :)
Make sure you drop the variable here.
Make those strings constants.
This should be a test error.
This should be 60000000 not 4000.
This should should be a test error.
I would also check the line length 1.
I would also check the line length /foo/bar here.
I would also check the line length /foo/bar.
This block can be removed.
This block can be removed?
This block can be removed, the tests would have been able to set the initial text of the login request as well.
this should probably be an ImmutableList
this should probably be an error
this should probably be an ENUM
Same question as above
Similar to the update method below, we should report errors here
Same issue with the change in the commit message.
How come we don't have this? I think the adapter needs to be a pixel at the same time.
How come we don't have this? I think the adapter needs to be a pixel at this point.
How come we don't have this? I think the adapter needs to be a pixel on the button.
make this assertion shorter?
name should be local.
name should be local
String.valueOf(input) is preferred over new String(String)
String fn = 'this' is not used?
String.valueOf(input) is preferred over new String(format())
![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
@omkreddy can you make the code shorter and more readable? Something like getCode("Error occurred while tagging entity UID ("Error occurred while tagging entity UID " + CatalogResponse.ResponseMessage.SUCCESS.getCode());
@omkreddy can you make the code shorter and more readable? Something like getCode("Error occurred while tagging entity UID ("Error occurred while tagging entity (" + CatalogResponse.ResponseMessage.SUCCESS.getCode());
@omkreddy can you make this a bit better and simplify the code here a bit? Something like getCode() -> CatalogResponse.ResponseMessage.SUCCESS.getCode()
As far as I can tell, difference is not just anything. It is either an error or a handler is specified, but it doesn't seem to be in any case. This will be in place of anything, but it's not logged as an error.
As far as I can tell, difference is not just anything. It is either an error or a handler is specified, but it doesn't seem to be in any case. This will be in place of anything outside of the RequestLifeCycle for it.
As far as I can tell, difference is not just anything. It is either an error or a handler is specified, but it doesn't seem to be in any case. This will be in place of anything outside of the RequestLifeCycle. It should be a response.
I think it's necessary to make this constant.
I think it's necessary to make the same issue here.
I think it's necessary to make this constant unwise.
no need... you will end up with profile.
no need... you will end up with N/A
no need... you will end up with N/A :)
acquireLockInternal() should be here only if acquireLockInternal() is called above
this message is not related to the version check
acquireLockInternal() should be added here as well
Construct this dynamically with a reference to the enum value for the error code instead of hardcoding 28
Construct this dynamically with a reference to org.eclipse.che.ide.ext.java enum values for the error code instead of hardcoding 28
Construct this dynamically with a reference to the enum values for the error code instead of hardcoding 28
Just use Objects.equals()
Just use Objects.requireNonNull()
Just use Objects.equal() instead.
fail
fail()
fail();
This one is not the place to use brackets.
This one is on the wrong line.
This one is not the same as the one in RA-D...
minor: I think it is much better to have an explicit test that says what the expected node is? This is a test case.
minor: I think it is much better to have an overload for this method.
minor: I would have used an assertTrue() here.
Missing: 'void handleLostAll'
1. Let's make it a warn instead of a debug. 2. The task can be deleted by the caller, and logged in the task.close()
1. Let's make it a warn instead of a debug. 2. The task can be deleted by the caller, and logged once it will be too frequent.
I think we need to check for a file name.
I think we need to check for a file name using isEmpty()
I think we need to check for a file name. We can check it, I believe.
This is entirely pointless, mDevice is null anyway (not initialized).
This is entirely pointless, mDevice was null anyway (not initialized).
This is entirely pointless.
Please add <br><br>
Please have brackets around the body, at least in a single line
Please have brackets around this statement
This is not a test, so this is not necessary.
This is not a test, so this is OK.
This is not a test, so this is not necessary
This seems to be a no-op if the validation fails.
This seems to be a no-op if the validation fails. I'm not sure we should log the exception to the server.
This seems to be a no-op if the validation fails. I'm not sure we should log an error here.
suggestion private void MITSearchAdapter(getActivity().getApplicationContext(), mitSearchAdapter.getDefaultSharedPreferences) {
suggestion final MITSearchAdapter view = PreferenceManager.getDefaultSharedPreferences(getActivity().getApplicationContext(), recentSearches);
suggestion private void MITSearchAdapter(getActivity().getApplicationContext(), mitSearchKind.NOT_SEARCH_HISTORY) {
same here, don't need to get the IDs across threads
same here, don't need to define a constant for this.
same here, don't need to define a constant for this?
Should this be BasicDBObject instead of object.
Should this be BasicDBObject instead of Arrays.requireArray(owners, dateQueryBuilder)?
Should this be BasicDBObject instead of object instanceof Map.Entry?
this is not needed since you are using the sprite.indexOf(sprites.get(sprites.get(sprites.get(sprites.getWidth()) ;
this is not needed since the sprite is itself a singleton, not used directly.
this would fail if the sprite is not written
Same here. We want to move this into a separate class.
Same as above. We want to move this to a separate function.
Same as above. We want to move this into a separate function.
Cache this value.
Cache the value.
UserHolder should never be null.
Formatting: should be at the beginning of the method.
Formatting: should be at the start of the method.
Formatting: should be at the end of the method.
This would render in a lot of things, especially when they include other things in the directory. Extract into a separate method.
This would render in a lot of things, especially when they include other things in the logs. Can we make this more generic and include things in the log message?
This would render in a lot of things, especially when they include other things in the logs. Can this be an other file?
Shouldn't this be java origUser.setText(origUser.get().getLocalizedMessage());?
Shouldn't this be java origUser.setText(origUser.get().getName());?
Need to catch the exception and handle it properly.
A better fix would be to use a different converter to read the data.
A better fix would be to use a different converter to read the data. I did not see it in any case.
A better solution would be to use a different converter to read the data.
Again please fix all occurrences of this exception message. You can probably follow existing method.
Again please fix all occurrences of this exception message. You can also use parms.getLogHex(parms.getVoById(parms.getObject) method. Also please fix other exceptions too.
Again please fix all occurrences of this exception message. You can probably follow existing one.
See my above about upstreamInfo.getUpstreamInfo() - we should remove the "host" prefix from upstreamInfo.
See my above about upstreamInfo.getUpstreamInfo()
See above about upstreamInfo.getUpstreamInfo()
should we do the check first?
should we make the "start" object a constant as well?
should we make the "start" object a static variable?
The first arg is not a type, this line doesn't seem necessary
The first arg is not a type, the second arg is used.
The first arg is not defined.
Does this make sense? Because of no background jobs, couldn't this be turned into a persistent cache (in case of somebody's working without it)
maybe make util a class in util?
maybe make util interface?
Should be lastCollisionLocation, not collisionEvent.
Should be lastCollisionLocation, not collisionEvent
Line 5002 should be logged.
Is it actually that we don't use the name here?
Is it actually that we don't use the raw assignment?
Any reason to use the name here?
nit: The non-null ledgerId isn't used for argument validation. These are intended to be removed.
nit: The non-null ledgerId isn't used for argument validation. These are intended to be removed, so do an NPE if the object is unexpectedly null.
nit: The non-null ledgerId isn't used for argument validation. These are intended to be removed, so do an NPE if the object is null here?
Is it possible to keep the old log of this exception?
Is it possible to keep the old log of this exception (wrapped in some kind of warn level)?
Is it possible to keep the old log of this exception (wrapped in some kind of log) and log it?
Where is this string coming from?
Where is this debug logged?
Where is this log level debug?
This check is not needed; it's already done in the super class
This check is not needed
This check is not needed.
This and the next two lines can be removed since we already know that it is not null.
This and the next block can be removed since we do this logic.
This and the next two lines can be removed since we already know that it is not part of the onDeletionHandler and is called.
I don't think this is right. The message should contain the expected parameters, and the message should be the expected one.
I don't think this is right. The message should contain the expected parameters, and the message should be the expected value. The message should be something like "expected true but got false".
I don't think this is right. The message should contain the expected parameters.
Can this entire map be: java return allOf( Pattern.compileTimeConstExpression(timeExpression, state).matches(unsafeArgName))
Can this entire map be: java return allOf( Pattern.compileTimeConstExpression(timeExpression, state).isSameAs(state.toString());
Can this entire map be: java return allOf( Pattern.compileTimeConstExpression( field.
Shouldn't this be Set<EClass>?
Shouldn't this be only one of the sort using Set?
Shouldn't this be Set<String> intersection =...?
For consistency with the rest of the library, I would use Util.springframeworkParserParser.parse method
For consistency with the rest of the library, I would use Util.springframeworkParser to grab the BAD_REQUEST from the parsing class.
For consistency with the rest of the library, I would use 'java.net.http.MapMappr' instead
Shouldn't this be done in the @After method?
Shouldn't this be get in the @After method?
Shouldn't this create a cleanup method in the @Before method?
Avoid "a" and use a logger if possible.
Avoid println() and use a logger if possible.
Avoid "a" and use a StringBuilder instead.
can be here java for (Tile tile : renderSet.get( tile ) { TileCanvasViewGroup.setTile( tile ); tileCanvasViewGroup.setTile( tile ); }
can be removed
looks like there is a reason for the same thing...
Was this intended to be configurable?
Was this intended to be a static method? If so you might want to make it more clear.
Was this intended to be a static method? If so you might want to make it configurable.
style nit: no braces around single line block
style nit: no braces around single line blocks
style nit: no braces around single line block.
I think this will break on Windows. Please use a try-with-resources block.
I think this is better in a follow-up PR.
Can't we just add a fail() statement in the try block?
I don't think this will work if the quorum numazed addresses is a IPv6 addresses, as Flag uses it.
I don't think this will work if the quorum numazed addresses is a IPv6 addresses, as ANY is a entries. We should think about allowed to use the supervisor.
I don't think this will work if the quorum numazed addresses is a IPv6 addresses, as FlagNode.
Shouldn't this be factory.generatePasswordSpec(filtered)?
Shouldn't the factory be closed here?
Should the factory be closed here?
Something strange is going on here. I don't think this result in the job of KairosDB.. but now this is always true.
Something strange is going on here. I don't think this result in the job of KairosDB. Won't it ben'ed once described?
Something strange is going on here. I don't think this result in the encoding being null.
Can you use a StringBuilder here?
Can you please use a local variable for all parameters?
Can we use a StringBuilder here?
I think we should remove the Realm instance before calling into cache.
I think we should remove the Realm instance before calling RealmCache.clear()
I think we should remove the Realm instance before calling RealmCache.getCache();
Why a list? It seems to be a set.
Why the array list?
Why a list?
I think the whole method should be a util method as cmsAdminRole, meaning, if the _role_ is a CMS Admin Role we return all the role in the tree.
I think the whole method should be a util method as cmsAdminRole, meaning, if the _role_ is a CMS Admin Role we return all the role in the stream.
I think the cmsAdminRole can be null, meaning, if the cmsAdminRole is null or is a CMS Admin Role we return all the role information.
Thinking out loud, wouldn't it make more sense to use the file creation time, or the last modified file?
Thinking out loud, wouldn't it make more sense to use the try-with-resources?
Thinking out loud, wouldn't it make more sense to use the file creation time?
@vilchik-elena Shouldn't this be error?
@vilchik-elena Shouldn't this be >= 1, so you can set the response to true?
@vilchik-elena Shouldn't this be >= 1, so you can set the response to false?
I don't think we need to skip the null check here. It's not necessary to throw an exception if it's not loadable.
I don't think we need to skip the null check here. It's not used.
I don't think we need to throw checked exceptions in case of skip.
You can reuse with Window.OK. Or even pass it in to startVolumesForForceStart().
You can reuse with Window.OK. Or even pass that in to startVolumesForForceStart().
You can reuse with Window.OK.
So it may be more obvious to say what the user did about ungreetings. This way, for example, the two options don't have to do with the same logic.
So it may be more obvious to say what the user did about, e.g. throw new RuntimeException(in a sentence) with the message about the issue?
So it may be more obvious to say what the user did about ungreetings. This way, for example, the two options don't have to do with how they implement the same logic.
This looks like a typo.
This looks like a constant value that can be used to avoid duplication
This looks like a constant value that can be used
You may want to use a [default](<LINK_0> here, to get an error from a _default_ string.
You may want to use a [default](<LINK_0> here, to avoid possible NPEs.
You may want to use a [default](<LINK_0> here, to get an error from a _default_ object.
I don't think this is the correct fix. You should add @Template annotation to the method signature.
I don't think this is the correct fix. You should add @Template annotation to the method.
I don't think this is the correct fix. You should add a note to <LINK_0> and not retrieve it at all.
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think it would be good.
Do we need the checks both here and in the WindowAgg operator?
I think validate can be CURRENT_ROW.
We should be able to reuse code from AsyncQueryEntry if possible.
We should be able to reuse code from AsyncQueryEntry.get()
We should be able to reuse code from AsyncQueryEntry.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception.ResourceNotFoundException' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception. runtime[![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception.ResourceNotFoundException' which is a runtime exception. [![rule](<LINK_1>](<LINK_3>
It is possible that getAgents() may return null
It must be registered for workspace-binding event
It is possible that getAgents() can be null
Why driver.startContainer()?
Why empty line?
There is no reason to catch InterruptedException anymore
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make "getParentPreview not available" a "static" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make "getParentPreview" a "static" method. [![rule](<LINK_1>](<LINK_2>
Can you use a more descriptive message?
Can you use a more meaningful exception in these catch blocks?
Can you use a more meaningful exception in these catch clauses?
Duplicated code. Maybe refactor the common part into a method?
I think this can be simplified to: if ( buffer.getLengthEncodedNumeric()) {
Duplicated code
Remove the "this".
Remove the "this" prefix from the method name.
Remove the "this" prefix from the method name?
Please do the same for this.
Please do not change this. This is a public API.
Please do not change it. This is a public API.
Can you close the stream on the finally block?
Can you close the stream in finally block?
Can you close the stream on a new line to avoid the finally clause?
move this branch into the if block above.
move this line before the if (headRef!= null) branch
move this line before the if (headRef!= null) block
If a "No" header is next, the next line will throw an exception, like "Limit of next". Where is that coming from?
If a "No" header is next, the next line will throw an exception, like "Limit of next". So, the next line would be: if (EOF..... { throw new IOException(e); } }
If a footer is necessary, a full list of options is supposed to be the last item. Why not use a list of "this" row?
This should be PathAddress address = context.getCurrentAddress();
This should be context.get(UUID).name() for consistency.
This should be context.getUUID()
Can we make it a ConcurrentHashMap instead?
Are we sure this is not already asynchronous?
Are we sure this is not going to make it thread safe?
Instead of passing a NewInstance as I think we could just use the same ValueExtractor instead of casting here.
Instead of passing a NewInstance as I think you can just use the same ValueExtractor instead of casting here.
Instead of passing a NewInstance as I do not think we want to use the same ValueExtractor instead of asking the size.
For consistency, would it be nice to use!driver.getLatexRangeChanged()?
For consistency, would it be nice to use the same externalized string?
For consistency, would it be nice to use the same engine partition as the one used in the driver?
Code duplication: "getScenes()"
Methodness is meant to be active for this instead of using thegetScenes() method. I think it's a better approach.
Methodness is meant to be active for this instead of using thegetScenes() call. I think it's a better approach.
Why do we set this to null then pass it into the builder?
Why do we set this to null then pass it to the builder?
Why do we set this to null then pass them into the builder?
@original-brownbear isn't it performance problem? shouldn't it be done in finally block?
@original-brownbear isn't it performance problem? Couldn't it be done via try()?
This may be a good addition to handling the exception.
I am reading the class again again and I think we do not need sourceIndex to be consistent. I think we can keep its scope just in the for loop. Then I think we do not need sourceIndex to be consistent.
I am reading the class again again and I think we do not need sourceIndex to be consistent. I think we can keep its scope just in the for loop. Then I think the only usage of sourceIndex is in the loop.
I am reading the class again again and I think we do not need sourceIndex to be consistent with current column name. I think we can keep its scope just in the for loop. Then I think the only usage of sourceIndex is in the loop.
It would be necessary to have indexIndexerClient = createIndexerMapper(indexer1.getName()); indexer2.setName("b");
It would be necessary to have indexIndexerClient = createIndexerMapper(indexer1.getName()); indexer2.setName("b")
It would be necessary to have indexIndexerClient = createIndexerMapper(indexer);
The MiddlewareQueryException is a RuntimeException, not a RuntimeException. So, you can use String.format(message, e) instead of the 5th line.
The MiddlewareQueryException is a RuntimeException, not a RuntimeException. So, you can use String.format(message, e) instead of the try-catch.
The MiddlewareQueryException is a RuntimeException, not a RuntimeException. So, you can use String.format(message, e) instead of concatenation.
How about inverting the condition for readability. java if (status == null ||!status.startsWith("Pulling from %s")) {
How about inverting the condition for readability. java if (status!= null &&!status.startsWith("Pulling from image.")) {
How about inverting the condition for readability. java if (!status.startsWith("Pulling from image.")) {
You can remove this part since it is no longer required.
You can remove this part since it is no longer needed.
You can probably rename this to CheckpointState.
please rename variables variables, it is confusing to read this variable called localModelDesc or something.
please rename variables variables, it is clearer that they are just used for assignment.
why!= null &&!...
Shall we provide a JIRA ticket for how to remove this part?
Shall we just log the actual account id here and let the user know that the operation failed to find the issue?
Shall we just log the actual account id here and let the user know that the operation failed to perform?
this variable is not used
better to use a variable than the assigned value
this initialization is useless since you already have a marker
Not worth changing the commit for, but this could also be replay(command, request, backoffHandler, cache);
Not worth changing the commit for, but this could also be replay(command, backoffHandler, request, backoffHandler)
Not worth changing the commit for, but this could also be replay(command, backoffHandler, request, backoffHandler);
verifyConstraint has a unique name
use assertThat instead of assertEquals, or assertThat.
do we need those booleans?
move this to start()
move this to a constant
wrong id
The existing code is throwing an exception if the entry is not actually loaded. Wouldn't it be better to wrap it in a try { } finally { offset.index = new Indexed<>(index.index, position); }
The existing code is throwing an exception if the entry is not actually loaded. Wouldn't it be better to wrap it in a try { } finally { offset.index = new Indexed<>(index.index, offset); }
The existing code is throwing an exception if the entry is not a number. I think it would be better to wrap it in a try/catch and throw an exception if the entry is null.
Please extract this repetitive code to a separate method (e.g. private String getBlobKeyFromRequest(String containerName, String message)
Please extract this repetitive code into a separate method (e.g. private String getBlobKeyFromRequest(String containerName, String message)
Please extract this repetitive code to a separate method (e.g. private String getBlobKeyFromRequest(String name)
You can use ops().forEach here to do this: ops.remove(batch); ops.add(batch);
You can use ops().forEach here to do this: ops.remove(batch); ops.remove(batch);
This should use ops.forEach.
I think the name should be enough to construct the cacheComponentRegistry.
I think the name should be enough to check the cacheComponentRegistry.
I think the name should be enough...
this could be collapsed to new Gson().withText(paymentId + "2018-01-01T11:85").build()
this could be collapsed into one line
don't need this anymore?
It's not necessary to pass the stream into this method.
It's not necessary to pass all of them into the factory method.
It's not necessary to pass all of them into the build method.
I think we could make this a bit more readable: java return new Builder().map(QueryBus.class::cast).map(Message::getPayload).filter(update -> Objects.nonNull(update)).collect(Collectors.toList());
I think we could make this a bit more readable: java return new Builder().map(QueryBus.class::cast).map(Message::getPayload).filter(update -> Objects.nonNull(update)).map(Message::getPayload).collect(Collectors.toList());
I think we could make this a bit more readable: java return new Builder().map(QueryBus.class::cast).map(Message::getPayload).collect(Collectors.toList());
since we already check for null, I think we should use isPresent
since we already check for null, I think we could avoid the null check
since we already check for null, I think we should use isPresent check
You are missing implementations for the same element, but after the check for the present-required project, please :)
You are missing implementations for the same element, but after the check for the present element.
You are missing implementations for the same element, but before the present check
You should probably use stateToCheckAndEvents.isEventBasedEvents() here, because you don't need to check for it later.
You should probably use stateToCheckAndEvents.isEventBasedEvents() here, since you are using the same logic.
You should probably name the method eventsToCheckAndEvents or something like that.
Looks like a copy&paste error here.
Looks like a copy&paste error, should it be firstRecordExpression.
Looks like a copy-paste error here.
This will not work if the user wasn't manually typed. But, if it is already done in the editor, we should remove the orphaned files.
This will not work if the user wasn't manually typed. But, if it's not present, we should just remove the viewer from the SWTBot and call this PlatformUI.getWorkbench().getDisplay() below.
This will not work if the user wasn't manually typed. But, if it's not present, we should just remove the viewer from the SWTBot and call that, right?
We should also check if message is an instance of the MessagingService.
We should also check if messageInMessage is an MessagingService.
We should also add the channel's version check to ensure a message is always created.
you can use lamba expression here too.
you can use lamdas.
you can use litter here.
Can this be something like the following? GenuatedFileIsReadable
Can this be something like the _warning_?
Can this be something more specific?
This is another example where we should have a method for creating an object that does this: @Override public void toHtmlForAnthology(StringBuilder result) { return this; } @Override public void toHtmlForAnthology(StringBuilder result) { return result.toString(); }
This is another example where we should have a method for creating an object that does this: @Override public void toHtmlForAnthology(StringBuilder result) { return this; } @Override public void toHtmlForAnthology(StringBuilder context, int result) { return result.toString(); } }
This is another example where we should have a method for creating an object that does this.
Object[] is not aPOINTER_SIE, so we can cast the size to a single array.
Object[] is not aPOINTER_SIE, we can just add a counter of the array.
Object[]
Too long
same as before. try with PreviewImageView
extra
I'm surprised you didn't use a lambda... :p
I'm surprised you didn't use a lambda... ;)
I'm surprised you didn't use a lambda... ;) Or if you don't use a lambda... ;)
I don't think this is correct. The copy/pasted code should be moved to the next method.
I don't think this is correct. The copy/pasted code should be moved to the next method, to avoid duplication.
I don't think this is correct. The copy/pasted code should be moved to the presenter, as they are added in this method.
Is it possible for the vector to be zero? It seems that the loop in that case is not handled.
Is it possible for the vector to be zero? It may be worth checking in some cases (e.g. when the vector doesn't exist).
Is it possible for the vector to be zero? It may be worth checking in some cases (e.g. if the vector doesn't exist)
why not throw Exception?
Call.toString() on the new line?
Call.toString() on the new line.
This should also not be an error.
This shouldn't also not be an error.
This should also not remove.
If the text is null, don't need to add a new line here.
If the text is null, don't you need to add a check that the text is valid?
If the text is null, don't you need to add a check that the text is null?
Please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
please verify that snapshots are not null
Shouldn't this be parentContext.getRoot()?
Shouldn't this be parentContext.getActiveParent()!= context.getRoot()?
Shouldn't this line be removed?
You can use the isEmpty() matcher here too
You can use the isEmpty() matcher here.
Are these two assertions necessary?
nit: Looks like the lock is missing here
nit: you can use dataCount -> inputAction
nit: Looks like it is UPDATE_IN_PROGRESS.
Change first occurrence to Set
Change first occurrence to addr.isLoopbackAddress
Change first occurrence to addr
Please use meaningful variable names. x is unhelpful in reading the code.
Please use meaningful variable names.
Please use meaningful variable names. x is unhelpful in java.util.
Are we sure we want to un-static-ize this? Can't we get the trace from the EventDefinition?
Are we sure we want to un-static-ize this? Can't we get the trace from the EventDefinition? Maybe we should cache that string.
Are we sure we want to un-static-ize this? Can we get the trace from the EventDefinition?
can we remove these blank lines?
Condition should be negated, no spaces around!=.
Condition should be negated, no spaces around ==
shouldn't we also generate a test when collectSet is called? Similarly for other test methods
shouldn't this test be called "Test.operateOn()"?
shouldn't this test be called "Test.operateOn()" instead of 0?
This will throw NPE if the topic is not found, instead of catching it here.
This will throw NPE if the topic is not found, instead it's silently ignored.
This will throw NPE if the topic is not found, instead of returning null. That is the correct behavior
I think this should be: java if (tmpEntity.isAssignableFrom(ENTITY_FE)) {.class.isAssignableFrom(ENTITY_SERVER.name())); }
I think this should be: java if (tmpEntity.isAssignableFrom(ENTITY_FE)) {.class.isAssignableFrom(ENTITY_SERVER.name()); }
I think this should be: java if (tmpEntity.isAssignableFrom(ENTITY_FE)) {.class.isAssignableFrom(ENTITY_SERVER.name()); } else {
Missing { and }. ;
Missing braces for if statements. Line 59-119
Missing { and }. ;.
please add the actual values to the error message, in case it ever fails
please use %d instead of %d
please use %d also here. It is easier to read the original code.
Consider refactoring this into a function named addBuyOrderToOrderBook or simply addBuyOrder. Extract method refactoring.
Consider extracting this into a function named addBuyOrderToOrderBook or simply addBuyOrder.
Consider extracting this into a function named addBuyOrderToOrderBook or simply addBuyOrder. Extract method refactoring.
We are not using kLayoutManager directly?
minor: I think statsLogger could be set to kLayoutManager directly
minor: I think statsLogger could be set to HkLayoutManager directly
Nit: we can move this out of the test above.
Nit: we can move this to a public static method.
Nit: we can move this to a dedicated test method.
What is the rationale for adding this as well?
You could use model.setAccessIpvus() here as well.
You could use model.setAccessIpvus() here as well?
Can we rename this to something like "enableFuture" or something similar?
Can we name this variable something like "enableFuture" or something?
Can we rename this to something like "enableFuture"?
rather than needing an ArgumentCaptor here, you should just use the method and the service name to be used
rather than needing an ArgumentCaptor here, you should just use the method reference.
rather than 120
These can be final and no need for declaring them beforehand.
These can be final and no need for write operations.
@writeStringToFile I think you can use writeAll for an example
nit: What is the setting here for?
nit: What is the message for?
nit: What is the behavior for this?
I dont think this is necessary. The password is just a hack, and this is just a hack.
I dont think this is necessary. The password is just a hack, and this is how it should be.
I dont think this is necessary. The password is just a string, and this is what it should be.
please remove this one
Can you replace this one with a warn level please?
Can you replace this one with a.replace() call?
ditto, to avoid duplication
ditto - is there an extra space after the ;?
ditto - is there an extra space after the, or is it?
we can avoid creating a string constant variable
we can avoid the null check by using StringUtils.containsStringCollection
we can avoid the null check by using containsString()
schema can be null
schema can be null and will cause NPE
schema cannot be null
Can we consider pulling this out into a separate method please? It's immediately long lines.
Can we consider pulling this out into a separate method for clarity?
Can we consider pulling this out into a separate method please? It doesn't seem like the proper code.
Can't you use the same error message for all exceptions? Should this be something like "Error loading AtsStateItemCore extensionItemCore extensionItemCore" instead of "error"?
Can't you use the same error message for all exceptions?
Can't you just add the if branch into the if block?
This is incorrect. If there's no payload, then it'd still be create a variable for each payload. If there's something else that needs to be seen.
This is incorrect. If there's no payload, then it'd still be create a variable for each payload.
This needs to be Log.e
Always make sure to wrap the entire Runnable that you are scheduling in a try/catch if you want it to actually continue running. If an exception _ever_ makes it out of the Runnable, the schedule will halt. You have a try/catch over some of the business logic, but what happens if you get an NPE on dataSource == null?
Always make sure to wrap the entire Runnable that you are scheduling in a try/catch if you want it to actually continue running. If an exception _ever_ makes it out of the Runnable, the schedule will halt. You have a try/catch over some of the business logic, but what happens if you get an NPE on dataSource, which is what you want.
Always make sure to wrap the entire Runnable that you are scheduling in a try/catch if you want it to actually continue running. If an exception _ever_ makes it somewhat more data, the metric system will be running.
doesn't need to add a remove.
doesn't need to do this.
remove.
Shouldn't the message be "in %s" instead of "actual"?
Shouldn't the message be "in %s"?
Should be assertCoverage(actual, expectedBranches);
please use a better name for the failure case.
please use a different name for the failure case.
please use a constant for the failure path, the variable name is more explicit.
Why are you comparing against type name?
Why are you comparing type here?
Why are you comparing this to a primitive type here?
No reason to isNotEmpty() here - a lot of lines would be more readable
No reason to isNotEmpty() here - a lot of lines would be more readable.
No reason to isNotEmpty() here - a lot of lines was more readable.
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which are not being queried here.
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source, but I looked into the details, and it only caches textures, which are not being queried here.
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which were not being queried here.
just for readability, better creating a new method isReprocessDefinition(processData, properties) inside the AbstractSubprocess class.
just for readability, better creating a new utility class (subprocess definition) to avoid duplicated code, is it?
just for readability, better creating a new method isReprocessDefinition(processData, properties) inside the AbstractSubprocessDefinition.
For each refactor
For each method, maybe: java if (authP == null) { return; } // Update line below }
For each Java 8 this is, maybe: java if (authP == null) { return; } // Update line below }
Isn't there a timing issue involved here, e.g if the server is still open?
Isn't this reporteed as not working somewhere else?
Isn't this reporteed as a problem? I'm not sure we care at all.
why did you change to final here? should be outside of the scope of the patch.
the should be outside of the loop, should be outside of the loop.
it should be final here.
So I am concerned about this approach. It is a little confusing to try to attach LocalSlot to other MetricsMetrics. Can you elaborate more about this? I am asking myself if we could try to toggle it in a way that makes it easier to follow.
So I am concerned about this approach. It is a little confusing to try to attach LocalSlot to other MetricsMetrics. Can you elaborate more about this? I am asking because we are doing this so it would be a possible solution.
So I am concerned about this approach. It is a little confusing to try to attach LocalSlot to other MetricsMetrics. Can you elaborate more about this? I am asking because we are doing this so it would be a little confusing to lack another time.
Use Collections.emptyList() to avoid unnecessary object creation
Use Collections.emptyList() rather than a static field.
Use Collections.emptyList() to avoid unnecessary object creation.
are you sure this is correct?
are you sure this is the correct location when you do this?
are you sure this is the correct location if there are asynccube
I think this would be better done as two cases, 1) if profile, add it to both registries and 2) if package, add it to just the package registry.
I think this would be better done as two cases, 1) if profile, add it to both registries and 2) if package, add it to just the package registry. And then return early if package, add it to just the package registry.
I think this would be better done as two cases, 1) if profileNsURIToPackageLocationMap is null, add it to both cases if the if statement is met. 2) if profile.getContributor().equals( sessionFactory.getAttribute("id") return true;
I think the message needs to be updated.
I think the message needs to contain enough information.
I think the name of the variable is misleading.
(nit) space before if
(nit) drop the 'else'
(forever!)
This class has only one set of supported facultyMemberEditor, so it could be reused in other methods.
This class has only one set of supported facultyMemberEditor, so it could be reused in other methods
This class is deprecated, so it could be removed
Rewrite as Map<String, Decision> typeRef = model.getHitPolicy().resolveType( dmnModel.getOutput().get( 0 ).getType(); String prefix = model.getHitPolicy().resolveType( dmnModel.getHitPolicy().resolveType(namespace ), dmnModel.getTypeRegistry().resolveType(namespace );
Rewrite as Map<String, Decision> typeRef = model.getHitPolicy().resolveType( dmnModel.getHitPolicy().resolveType(namespace)); if ( model instanceof Decision && ((Decision) model).getTypeRegistry().resolveType(namespace.getName() ) ) { return resolveTypeRef( dmnModel.getHitPolicy().resolveType( namespace ); } );
Wouldn't oc.getHitPolicy() be null here?
In the mapping you don't need to convert an object to a list, you can return the original list
In the mapping you don't need to convert an object to a list, you can return the map directly.
redundant
I like we can have such changes in the PR, but maybe we should not only use those here?
I like we can have such changes in the PR, but maybe we should not only support here. We should not only use the native build for compareFound.
I like we can have such changes in the PR, but maybe we should not only support those two static methods?
This should be in the trace message.
This should be inside the if (trace) too.
This should be inside the if (trace) block.
Is the event being propagated to the Updater level?
Is the event being propagated to the exception?
Is the event being propagated to the admin?
Removed it
Removed all 2 types
Removed all 0s
Since we're going to end up doing multiple 'lock' locks, this could lead to deadlocks. I believe the following code is the same, and that should be handled properly: 1. acquireLock() should be acquired as 2. do it on the following line (lock.getLock().getSharedLocks()!= null) { // freeLock.putAll(lock.getLock().getSharedLocks()); } 2. endLock() is called on the following two blocks, and there are few more calls to acquireLock() for the following case: 1. startLock() should be performLocks = true 2. acquireLock() should be in the following two
Since we're going to end up doing multiple 'lock' locks, this could lead to deadlocks. I believe the following code is the same, and that should be handled properly: 1. acquireLock() should be acquired as 2. do it on the following line (lock.getLock().getSharedLocks()!= null) { // freeLock.putAll(lock.getLock().getSharedLocks()); } 2. endLock() is called on the following two blocks, and there are few more calls to acquireLock() for the same lock. 3. performLocks() to lock.lock() this result can be done on the following line
Since we're going to end up doing multiple 'lock' locks, this could lead to deadlocks. I believe the following code is the same, and that should be handled properly: 1. acquireLock() should be acquired as 2. do it on the following line (lock.getLock().getSharedLocks()!= null) { // freeLock.putAll(lock.getLock().getSharedLocks()); } 2. endLock() is called on the following two blocks, and there are few more calls to acquireLock() for the following case: 1. startLock() should be performLocks = true 2. acquireLock() should be done after the following two
Could you please add the exception e.getMessage() to the log message?
Could you please add the depgraphs to the message? The same goes for all the other classes.
Could you please add the depgraphs to the message? The same goes for all other places.
Maybe eventSeenAt I'm missing something here. At the moment I don't think we need to track this only if we are waiting for the event to be sent?
Maybe eventSeenAt I'm missing something here. At the moment I don't think we need to track this only if the first event is cancelled. We can always set a local trackMetrics below. I think that would be safer if we check events in the event thread.
Maybe eventSeenAt I'm missing something here. At the moment I don't think we need to track this only if the first event is cancelled. We can always set a local trackMetrics below.
Can you use org.apache.commons.lang3.StringUtils.isNotEmpty here instead? It's more readable.
Could you use org.apache.commons.lang3.StringUtils.isNotBlank(String) here? It's not like that.
Could you use org.apache.commons.lang3.StringUtils.isNotBlank(String) here? It's more readable.
Using Charset.defaultCharset() makes the code more readable.
Seems like this method should be private.
Instead of this error, maybe UnsupportedOperationException or IllegalStateException?
I don't think you need to explicitly declare this. in the other methods as well.
I don't think you need to keep this, unless you want to explicitly set it in the overridden version which is important to the default.
I don't think you need to keep this, unless you want to explicitly set it in the overridden version of the class to the default one.
whitespace is a bit off
whitespace is off here
whitespace is wrong
toArray(new String[0]) can be replaced with just Arrays.setAlls)
map(int -> String).toArray(new String[0])
toArray
The logged in user has a message stating that it is not found for this container - e.g. "Failed to get the getUser"
We can't return an empty list if the content is not found instead of getting the _last_ one.
The logged in user has a message stating that it is not found for this container...
captor is not used
captor is not used in verify() method.
captor
I would replace lines 82 and 90 to: if (f.equals(config.getRam()) {
What is the purpose of this change?
why is this required?
This test is still failing for me, remove it.
This tests don't need to verify explicitly for any reason, right?
This tests don't need to verify explicitly for any reason, but then we can't duplicate the tests for the same reason.
It might be worth comparing with substring() here, to avoid an indexOf/substring call.
It might be worth comparing with substring() here, to avoid an indexOf/substring parsing.
It might be worth comparing with substring() here, to avoid an indexOf/substring of the fullImageName.
Duplicated code - wsAgentPingUrl variable
.toString() is not required
.toString() is not required here
I don't think you need to mock the Metadata object here.
I don't think you need to mock the metadata object here.
I don't think we need to mock the metadata object here.
Could you please remove this line?
Could you please remove this line? These two lines can be replaced with assert messages.
Could you please remove this line? These two lines can be merged.
nit: remove the () so that the whole block can be replaced with if (StringUtils.join(...)).
nit: remove the 'if'
nit: can use putIfAbsent
Missing space before the curly brace.
Missing space after the curly brace.
Needs a space before the curly braces.
Here you are right, the jseEvent will always be null. I mean, you don't need to check if the context is not null.
Here you are right, the jseEvent will always be null. I think we don't need this catch block because you can't call it from within the loop.
Here you are right, the jseEvent will always be null. I think we don't need this catch block because you can't call it from the main InputStream.
1. I'm not sure if we should add the storageDomains as a Set... 2. How about changing the check to a Set<Pair<StorageDomain>>?
1. I'm not sure if we should add the storageDomains as a Set... 2. How about changing the check to a Set<Pair<StorageDomain>>? The filtering out 'find' and 'all' together (i.e. storageDomain -> StorageDomainStatus.Down()'))
1. I'm not sure if we should add the storageDomains as a Set... 2. How about changing the check to a Set<Pair<StorageDomain>>? The filtering out 'find' and 'all' together (i.e. storageDomain -> StorageDomainStatus.Down()')
Please always return IResource.adapt(...)
Please always return I'm not a big fan of this!
Please always return I'm worried about this!
We can't add the listener here. How to EMDeviceUtil.setOnSizeChangedListener(R.id.exomedia_video_image)?
We can't add the listener here. How to EMDeviceUtil.setOnSizeChangedListener?
We can add a listener here. We always have the listener at the top.
Items.DEBUG
Items.forEach((Items) )
<LINK_0>
change the message as well
can you use BlobId.class.toBytes() here?
can you use BlobId.toBytes() here?
Is this test necessary? I didn't see it before, but I'm not sure how it's written to it
Is this test necessary? I didn't see it here as well, the test didn't do the same thing
Is this test necessary? I didn't see it here previously
I don't think this is needed anymore..
I think you should do this in the listener
I don't think you need to modify the model anymore.
I would prefer having a dedicated method for this close...
I would prefer to have a dedicated method for this close...
I would prefer to have a dedicated method for this, as it's used in 2 places.
Unit tests for fetchThresholdBytes?
Unit tests for fetchThresholdBytes? Seems like they can still be used for the KafkaFetchThresholdBytes
Unit tests for fetchThresholdBytes? Seems like they can still be used for the default value.
@vilchik-elena I would move this condition into the if/else to improve readability.
@vilchik-elena I would move this condition into the if/else to avoid the else branch.
@vilchik-elena I would move this condition into the if/else to improve readability
we should probably keep the ByteBufAllocator as it was originally written.
we should probably also write outBuf.clear()
we should probably keep the ByteBufAllocator as it was before the test case
I think this should be <code>return new ArrayList<>()</code> right?
I think this should be SftpServerRelativePath
I think this should be <code>return (sftpRemoteRelativePath</code>.
Use {} placeholders instead of concatenation
Use logger rather than concatenation
Use {} placeholders
bp = t.getMarker().getResource().getType(); and there are two different methods (which are different in this file): bp = t.getMarker().getResource().getType();
bp = t.getMarker().getResource().getType(); and there are two different methods (which are different in this file): bp = t.getMarker().getResource().getType()!= null? bp : null;
bp = t.getMarker().getResource().getType(); and there are two different methods (which are different in this file): bp = t.getMarker().getResource().getType(); return pkg;
is that intentional?
is there any reason to skip.skip() here?
is there any reason to skip 'this' here?
I think this should be called valueCount > 0 to avoid a race condition.
I think this should be called valueCount since not a list
I think this should be called valueCount instead of valueCount.
sounds fine to me.
sounds fine to me. Exception gets caught as a second argument
sounds fine to me!
you are testing start_ts and end_ts
why start_ts is 1?
why start_ts is 0?
I think we set it from the encoding, value: <LINK_0>
I think we set it from the encoding? It's possible that a constant is not set there.
I think we set it from the encoding?
Why was this removed?
Why call finishAndRelease() on both channels?
Why call finishAndRelease()?
Why is this invoked for every test case?
Why can't we move this method to _generateMapTask_ method?
Why are we no longer throwing this exception?
RuntimeException?
Exception? Is this expected?
Exception?
Why not lift this logic in the try-catch block?
Why not lift this logic in the existing try-catch block?
Why not lift this logic in the try block?
In all the tests, the 'Trace" is never null so we can avoid that.
In all the tests, the trace is already opened. No need to close these traces.
In all the tests, the trace is already opened. No need to open a new trace, after all the UI changes.
Can use RawUtf8::length
Can use ByteStringBuilder
Can use ByteStringBuilder instead.
I'm a little unnerving, but I'm not sure the performance implications of doing this here.
I'm a little unnerving, but I'm not sure the performance implications of doing this here. Since you are grabbing the span from the iterator, could you make it an iterator?
I'm a little unnerving, but I'm not sure the performance implications of doing this here. Since you are grabbing the span from the iterator, it might be better to set leading or trailing spaces, or make a separate method to return a void.
Nice to use Objects.hash
Nice catch (InterruptedException | ExecutionException e)
Nice catch (InterruptedException | RuntimeException e)
The message should be upper case
Maybe its better to use capital stats :)
Maybe its better to use capital stats
maybe we can make it a class member.
maybe we can make it a constant with a name that describes what it is.
maybe we can make it a constant with a name that makes it more readable.
better to have if (timeEnabled instanceof DruidExpression) { inputColumn = ((double)timeFormat; }
public final
format
constant?
Extract this to constant?
Extract this to a constant?
Is it possible that this gets called after a connection is closed?
Is it possible that this is called after a connection to a connection to close?
Is it possible that this is called after a connection to a connection to a connection?
Couldn't Granularities.ALL be used here?
Couldn't Granularities.getQuerySegment().getValue() be used here?
Couldn't Granularities.getQuerySegment() be a set of descending=true?
Why was this removed?
Why did you change this?
Why did you add timeout?
why the final need here?
why the final need here.
why final?
Please move this to the next line.
Please move this line to the next line.
This is not necessary.
should it be log.writeObject(filterAndConverter);?
should it be log.writeObject(filterAndConverterEventFilter.value())?
should it be log.writeObject(filterAndConverterEventFilter.values())?
free the lock in a finally block
free the lock, you should use vmSnapshotId
free the lock in a finally blocks
Let's not use the same approach as for blobUploadSuccessCount. We can directly pass the blobUploadSuccessCount local variable.
We should not use try-with-resources syntax here.
Let's not use the same approach as for blobUploadSuccessCount. They seem like there are two error messages to check blobUploadSuccessCount.
Since the variable is no longer used other than once, please remove them.
Since the variable is no longer used other than once, please remove it.
Since you are modifying a value here, I think this check should be removed.
please declare variable in first usage
please declare variables in first usage
please declare variable
nit: Unnecessary?
nit: change this to be a standard variable.
nit: Unnecessary finally clause?
What are your thoughts about tables being updated, which should be something like "Only one database file in the index " + indexName?
What are your thoughts about tables being updated? Not sure what the id is part of the transaction, which is part of the select()?
What are your thoughts about tables being updated, which should be something like "Only one database file in the index " + indexName? ;)
Add final keyword.
Ah, I see. And is there a reason you are using the same proxy?
Ah, I see. And is there a reason you chose Context and proxy?
You can use a TreeMap here.
You can use a TreeMap here instead of sorted operations.
space
Should this be in the catch block above?
Should this be in a t?
Should this be in the catch block below?
Please rename the variable to oldLowWater, because it is just Status
Please rename the methods here as well
Please rename the methods here as well.
Why not use getClass().getClassLoader()?
Why not use the InitializationConfiguration constructor here?
Why not directly throw HadoopConfiguration?
.* and.*
.*
.isEmpty()
I think this should be set to final
I think this should be set to true otherwise the underlying error message might be wrong.
I think this should be set to true somewhere else.
Because destroy() is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
Because destroy() is now async, there is a high chance it will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
Because destroy() is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init().
style nit: no braces here
Should be in a finally block.
Should be in a finally clause?
this code should be in a private method
this code should be in a private method and access the method instead
this code should be in a private method with an e.g. String getAPI()
Do we need to use the default minsec instead of timeone?
Do we need to use the default minsec here?
Do we need to use the default minsec for this table?
You could directly use runInternalAction()
You could directly use runInternalAction here.
What if disable cli snapshot schedule failed?
members can be replaced with isFactors
members must be statically
members -> argument
can we reuse this constant instead of duplicating the string?
Can we reuse this constant instead of duplicating the string?
can we reuse this string instead of adding a constant?
If the cacheMode is null (which is not), then it will have a NPE. Also it would be nice to use componentType.cast(new ExpirationManager(this.transactionMode(), cacheMode.class).cast(timestamp); instead.
If the cacheMode is null (which is not), then it will have a NPE. Did you intend to use componentType.cast(new ExpirationManager(this.transactionMode())?
If the cacheMode is null (which is not), then it will have a NPE. Did you intend to use componentType.cast(new ExpirationManager(this.transactionMode(), cacheMode.class)? It seems like that is inconsistent in the PR.
Do we need to wrap in a TreeMap here? In general, is there a way to keep it as addAndGet?
Do we need to wrap in a TreeMap here?
Do we need to make this into a synchronized block?
@kujtimiihoxha Shouldn't this also be == setAllowsRedeployment(true), setAllowsRedeployment(false)?
@kujtimiihoxha Shouldn't this also be == setAllowsRedeployment(true), false?
@kujtimiihoxha Shouldn't this also be &&?
You don't want to display the information to the end-user!
You don't want to display this information to the end-user!
You don't want to display this information. The listDrafts to a Map is never null.
@CarlosGines bout could be inlined
@CarlosGines let's inline bout here as well
@CarlosGines let's extract bout here as well
no need to modify this, it is enough.
no need to change context.
no need to modify the messages.
Please break the line after if
Please break the return statement
break
Why do we need to call this in the synchronized block? It's just in case?
Why do we need to call this in the constructor? It's just a local variable.
Why do we need to call this in the synchronized block?
This could be a builder. MockConnectorFactory.Builder builder = MockConnectorFactory.builder();
This could be a builder
This could be a builder. MockConnectorFactory.Builder<ConnectorFactory>builder()
There is NPE in this method.
There is NPE in this method. So you prefer to declare it static.
There is NPE in this method. It is strange to declare a static variable and reuse it.
There is already a ListItemButtonActionPerformer. Can we just use that here?
There is already a ListItem-like method which can return a LabelPerformer and all the calls to it throws an Exception. Let's do this on the next line.
There is already a ListItem-like method which can return a LabelPerformer and all the calls to it throws an Exception. I'd suggest just doing this on the next line.
Why is it needed?
Why is task.getFirst() not needed?
Why is it needed here?
nit: use braces and space after if
nit: use map + lines here
nit: use braces and space after if.
Should this be in a finally block to ensure the iterator is always called?
Should this be in a finally block to ensure the iterator is always closed?
Should this be in a finally block to ensure the iterator is always populated?
Probably should be some log warning message here identifying the value was not convertable
Probably should be some log warning message here identifying the value was not found.
Probably should be some log warning message here identifying the value was not defined.
Any reason for this change? Can't we make it one field instead?
Any reason for this change? Can't we just pass in the emailValidator here instead?
Any reason for not using the FQN?
enumerated, this should not happen in the GSOC dead code. There are a single single element enumerated, this should not happen in the GSOC dead code.
enumerated, this should not happen in the GSOC dead code. There are a single single element enumerated, this should not happen in the GSOC or do not need to add this regex.
enumerated, this should not happen in the GSOC dead code
Please throw an exception wrapping the STripleException.
Please throw an exception.
Please double check
I'm worried that this code is called twice. Contingently when the code is called smartly in the past is the variable name to be different.
I'm worried that this code is called twice. Contingently when the code is called smartly in the past is the variable name and the assigned value can be null. I prefer this consistently.
I'm worried that this code is called twice. Contingently when the code is called smartly in the past is the variable name and the other two, does it make sense to use one?
Please move this to the log.
typo, should be "file"
missing space after if
I think this might be easier to use.map(x -> MDC.get()).ifPresent(x -> { MDC.put(x.getChargeFromRequest(x.getGatewayName(), gatewayAccount.getChargeFromRequest()); });
I think this might be easier to use.map(x -> MDC.get()).ifPresent(x -> MDC.put(x.getChargeFromRequest(x.getGatewayName(), MDC.get())
Maybe we should use getAndSet(null) here to get the external response.
why do you need to stop?
why don't you use.next() here?
why don't you use.single() here?
lambda?
I believe that similar code exists somewhere already, but that's ok I guess.
This looks even nicer: if (f instanceof HierarchyEvent) { ((MtfTmfEvents) parent).print(this); }
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException()) can be used instead of the mock.
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock().
Looks like this should be getSource() check.
Looks like this should be an assumption that getSource() can return null.
Looks like this should be an exception.
rename to child
rename to key
rename to childList
Remove System.out.println
Logs?
Remove System.out.
better to use hamcrest matchers
better assertResult.equals(...)
consider Assert.assertEquals
Couldn't this be done at the map instead of inside the map?
Couldn't this be done with map instead of iterating over all of the built once?
Couldn't this be done with map instead of iterating over all of the map?
This can be a constant.
This can be moved outside the loop.
This can be a string resource.
Instead of doing this, it would be more consistent to use something like: final ChangeListener event = new screenWidth("."); bundle.setForceScroll(false); c.setForceScroll(false);
Instead of doing this, it would be more consistent to use something like: final ChangeListener event = new screenWidth("LOG.getLogger().xxx"); c.setForceScroll(false);
Instead of doing this, it would be more consistent to use something like: final ChangeListener event = new screenWidth("LOG.getLogger().xxx"); c.addAll(g.getProperty("Home"); c.setForceScroll(false);
If inputStream would be declared as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
If inputStream would be defined as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
If inputStream would be declared as class variable then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
make these behave like the rest of the aspects
make these methods private?
externalize
doesn't need to be else statement
can be blank
doesn't need to be else statement here
This if-else block is unnecessary.
This if-else is not needed.
This if-else is redundant.
I suggest to change the order of the arguments to: @Override public void validate() { String commandName = factory.unwrap(ExecutableUtils.class); if (interceptors.size() > 0) { handler2 = handler1.unwrap(event); } else { String[] args = factoryCommands2.unwrap(name); if (event instanceof declaringClass2 && (( Pair.class) == 0) { throw new IllegalArgumentException("Unrecognized handler handler"); } }
I suggest to change the order of the arguments to: @Override public void validate() { String commandName = factory.unwrap(ExecutableUtils.class); if (interceptors.size() > 0) { handler2 = handler1.unwrap(event); } else { String[] args = factoryCommands2.unwrap(name); if (event instanceof declaringClass2 && (( Pair.class) == 0) { throw new IllegalArgumentException("Unrecognized handler"); } }
I suggest to change the order of the arguments to: @Override public void validate() { String commandName = factory.unwrap(ExecutableUtils.class); if (interceptors.size() > 0) { //
why BodyInternalTypes.AGENT_ENTITY and not BodyInternalTypes.AGENT_ENTITY?
why BodyInternalTypes.AGENT_ENTITY and not BodyInternalTypes.AGENT_ENTITY?
why BodyInternalTypes.AGENT_ENTITY and not BodyInternalTypes.AGENT?
the interface should accept a pin object directly here. no?
the interface should accept the pin object directly here. no?
this seems dangerous. shouldn't it be attach to the interface?
maybe should be a switch?
maybe should be an switch?
maybe should be a switch statement?
A better option would be to use assertThat().
A better option would be to use assertThat(). Matchers.instanceOf()
Codacy has an issue for this.
If the diskInterface is null, would it be better to use Objects.hashCode()?
If the diskInterface is null, it will throw NPE.
If the diskInterface is null, would it be better to stick to "disk" for now?
After the change this assignments to delimiter is ignored, so the tokenized path is joined without delimiters. To maintain functionality, the whole for loop needs to be extracted instead of just the body.
After the change this assignments to delimiter is ignored, so the tokenized path is joined without delimiters. To maintain functionality, the whole for loop can be extracted instead of just the body.
After the change this assignments to delimiter is ignored, so the tokenized path is joined without delimiters. To maintain functionality, the whole for loop would be extracted instead of just the body.
Why is this needed? I think it would be useful to have a log.error here.
Why is this needed? I think it would be really nice to have a special log.
Why is this needed?
Can't we avoid this synchronization by using a get instead?
Can't we avoid this variable a bit of code?
Can't we avoid this variable?
Please use Verbs.gather instead of "Gather" here
Please use Verbs.gather instead of "gather"
Please use Verbs.gather instead of " "
why not just'setFeatureInt'?
why not just 'hasSize' here?
why not just 'hasSize'?
why a file here instead of BAOS like others and before?
why a file here instead of BAOS like other file names?
why a file here instead of a hardcoded value?
assertThat(linesOfCode).hasSize(1);
assertThat(linesOfCode).hasSize(1);?
i think it's a bit easier to read by using assertThatSensorContextTester.hasSize(1); instead of assertThat().
do you need to handle the case where the config is null?
do you need to handle the case where the config is a default value?
do you need to handle the case where the config is a default section?
Isn't there a possible race condition here?
consider a switch statement instead to make it more explicit.
Isn't there a risk to use list instead of keys?
if you are sure this is properly handled. I think it is better to make it explicit that this function gets called once at the beginning and then use it.
if you are sure this is properly handled. I think it is better to make it explicit that this function gets called once, and just return directly from the parsers.
if you are sure this is properly handled. I think it is better to make it final and just use it.
I don't understand this method. Why would the negative case be better than this?
This also seems dangerous. Why would you want to set next to null?
I don't understand this method. Why would you define a new isWhitespace for this?
You don't want to fire an event if the widget is selected. The model should be saved in the lower case.
You don't want to fire an event if the widget is selected. The model can't manage the selected item, since the widget is already attached to the model (but the DB should be opened in the editor)
You don't want to fire an event if the widget is selected. The model can't manage the selected item, since the widget is already attached to the model. The model should be the first selected item.
I think we might consider renaming this to something like handleErrorDialog
I think we might consider renaming this to something more meaningful.
I think we might consider renaming this to something more meaningful
This is not correct. Why not use ProjectResourceFactory.REF_CONFIG?
This is not correct. Why not use ProjectResource here?
This is not correct. A project is not created by this method might return null. Why does this need to check?
No, no expression. It is really assigned a value and property. It is just an id.
No, no expression. It is really assigned a value. It's really assigned a variable.
No, no expression. It is really assigned a value.
Any reason for using an Object as a subtype instead of a specific type? That would allow this exception to be thrown by the method.
Any reason for marking with Throwable as instance of a specific type?
Any reason for using an Object as the method to throw an RuntimeException? Do you want to catch an Exception for any specific exceptions?
I would also add an info log here.
I would also add an info log that says that Killing is not running.
I would also add the status into the exception message?
might be good to have more details regarding the key than the server (i.e. hashing the value and key)
might be good to have more details regarding the server and key.
might be good to have more details regarding the key than the server (i.e. additional server)
Is testing for null outside of the for loop? or is it just a personal preference?
Is testing for null outside of the for loop? or is it just a mandatory behavior?
Is testing for null outside of the for loop? or is it just a mandatory to have a delete?
nit: seems like this can be simplified to if (hasPost() || isAskedToLike()) {
nit: seems like this can be simplified to if (hasPost() || isAskingToLike()) {
let's rename this method to handlePreDelete()
Is it possible to add a table name to the log message?
Is it possible to add this in the constructor with one argument per line?
Is it possible to add a table name to the log message?
please check here isSetPmProxies() otherwise you can get NPE
please check here isSetPmProxies() otherwise you can get it
please check the host name as well.
Nitpick: is there any reason to rename the variable?
Nitpick: no braces here.
Nitpick: no space after {
This is a style nitpicky, but I think the isEmpty() check is redundant here.
This is a style nitpicky, but I think the 'else if' is redundant here.
This is a style nitpicky, but I think the 'else if' is redundant since you already check for not null here.
unnecessary else clause
Again, not sure if I like that this could just be final
Should just throw an IllegalArgumentException if something is null
I appreciate the centralized code of this approach, but i think it is going to result in all the pre-est file processing and all in this approach is going to result in all the pre-est file processing and all of the pre-est file processing may end up being a partial file. It may be hard to go with this approach without a larger code change
I appreciate the centralized code of this approach, but i think it is going to result in all the pre-est file processing and all in this approach is going to result in all the pre-est file processing and all of the pre-est file processing may end up being a partial sharing. It may be hard to go with this approach without a larger code change
I appreciate the centralized code of this approach, but i think it is going to result in all the pre-est file processing and all in this approach is going to result in all the pre-est file processing and all of the pre-est file processing may end up being a partial sharing. It might be hard to go with this approach without a larger code change
It seems that the method is only used after copy (getDetails()!= null &&!isEmpty) is more readable.
It seems that the method is only used once, I would remove the method.
It seems that the method is only used once, I would recommend to remove the method
So if this is possible, add a function to the brokerRequest that does this work differently than split the method calls.
So if this is possible, this is split into multiple lines?
add {}
That would be much nicer if we should have distance rules here and set them to 0.
That would be much nicer if we should have a listener, and then have a listener just a field.
That would be much nicer if we should have a listener, and then have a listener just a single listener.
Since you're adding the exception to the log message, you could use String.format() to change the message: log.error("Failed to edit label for {}: {}", id, e);
Since you're adding the exception to the log message, you could use String.format() to change the message: "Failed to edit label for {}: {}", id, e);
Since you're adding the exception to the log message, you could use String.format() method
@ikhvostenkov please name it just json
@ikhvostenkov please name it json
@ikhvostenkov please name it something more meaningful
Could you please externalize the name of this file along with the following lines? java.filter(Objects::nonNull).filter(Objects::nonNull).forEach(formItem -> {.... });
Could you please externalize the name of this file along with the following lines? java.filter(Objects::nonNull).forEach(formItem -> {.... });
Could you please externalize the name of this property into a constant like : java private static final List<FormItem> policyName(List<FormItem> allFormItems) { List<PluginDescriptor> policyName = new LinkedList<>(); allFormItems.add(formItem); return focusedPolicyPlugin.getViewModel(); }
I am wondering if we shouldn't allow people to call catalogManager.getCatalog(catalogName), otherwise we'll get an exception
I am wondering if we shouldn't return an Optional.map rather than a map.
I am wondering if we shouldn't allow people to call catalogManager.getCatalog(catalogName), otherwise we will return an empty list
@vilchik-elena Hoiw about extracting code to a method assertThrows(StringHolder input, StrictSimpleDateFormat.class)
@vilchik-elena Hoiw about extracting code to a helper method.
@vilchik-elena Hoiw about this already...
move error log to condition body
move error log to condition block
move error log to logic.
If it's "right" from the extractWhereExpression, I think it should be moved to the beginning of the method.
If it's "right" from the extractWhereExpression, I think it should be moved to the beginning of the function.
If it's "right" from the extractWhereExpression, I think it should be moved to the beginning of the function, like it.
nit: formatting
static import
nit: spaces
This code is present in two places, so it would be easier to read if it was extracted into a helper method
This code is present in two places, so it would be easier to read if it was extracted into a method.
This code is present in two places, so it would be easier to read if it was extracted into a method
We should avoid having to wait for the browser if the user comes before going through it to the standardResolutionData. That way if we needed to change it, we can just call getVideos().
We should avoid using System.currentTimeMillis()
We should avoid having to wait for the browser if the user comes before going through it to the standardResolutionData. That way if we needed to change it, we can just create it once and use it.
As we discussed, this should be debug level, I think
As we discussed, please add a log here and in the else clause
As we discussed, please add a log here and in the else clause.
Registration should be null, no? if so, Registration.getRegistrationEndpointAddress()
Registration should be immutable.
Registration should be null, no need for the empty check.
Can you explicitly check that the columns are either null or null?
Make this one final variable.
Make this one final.
I'm not sure whether do we need to loop here? If the rowId is negative, we should not throw the exception, right?
I'm not sure whether do we need to loop here? If the rowId is negative, we should not throw the given rowId at all. Instead, what about that?
I'm not sure whether do we need to loop here? If the rowId is negative, we should not throw the given rowId at all.
This will throw an exception if the getUriMaker() is not null
This will throw if the getUriMaker() is not null (line getUriMaker().getInputName())
This will throw if the getUriMaker() is not null
I'd like to avoid calling get twice here.
I'd like to avoid calling getByteBuffer here.
I'd like to avoid calling get() multiple times here
nit: This can be taken out along with last line in if and else block can be removed.
nit: This can be taken out along with last line in if and else blocks.
nit: This can be taken out along with last if.
I think this should be two-space?
I think this should be a negative?
I think this should be two-space indented.
This line needs a null check.
This line needs a null-check.
This line needs a null-check, to make it "true".
include the'record.getKey()' call in the second part?
I think this needs to be an improvement.
include the'record.getKey()' call in the second record.
I think it's better to create a class that extends ConfigAction and use it instead of duplicating the code here.
I think it's better to create a class that extends ConfigAction and use it instead of duplicating the code.
why the _R controls.
I think this is a bit a bad idea because you don't have to allocate a new byte array for each buffer. There is a ByteBuffer in this class that you could use to serialize the buffer.
I think this is a bit a bad idea because you don't have to allocate a new byte array for each buffer. There is a small bytes between this and back, so you could create a new byte array that you know is length of the buffer. WDYT?
I think this is a bit a bad idea because you don't have to allocate a new byte array for each buffer. There is a small bytes between this and back, so you could create a private static byte[] buff(int buffer) method that does this work and you don't need to worry about the buffer length.
I believe appPath can be an empty string which will cause lastSegment() to return null, which then will cause an NPE. You can try this by leaving the program text box empty.
I believe appPath can be an empty string which will cause lastSegment() to return null, which then will cause an NPE. You can try this by leaving appPath.getText().isEmpty() as null, then.
I believe appPath can be an empty string which will cause lastSegment() to return null, which then will cause an NPE.
Shall we print the full toString() result here?
don't you need to pass the capacity to this variable instead of the string?
don't you need to pass the capacity to this list instead?
nit: Maybe put keySerializerConfig in the constructor?
nit: Maybe put keySerializerConfig in the method?
nit: could put if on a line above
Shall we change this to use MockSinkConnectorConfig?
Shall we change this to use the method URI?
Shall we change this to use the method name?
Wouldn't it be simpler to use symbolInput.getName() here?
Wouldn't it be easier to use symbolInput.getName() here?
Wouldn't it be easier to use symbol.getName() here?
suggestion log.error("Couldn't open the schema provided by the schema", e);
suggestion log.error("Couldn't open the schema provided by the tenant.", e);
suggestion log.error("The JAR is empty, but can't be combined", ", ")
final?
Nit: final?
can be final?
Minor thing: Can't we move the snapListSize call here? Stream.of(dt.lastProcessed).filterSealIntegrity(dt.class);?
Minor thing: Can't we move the snapListSize call here? Stream.of(dt.lastProcessed()).filterSealIntegrity(dt.lastProcessed);?
Minor thing: Can't we move the snapListSize call here? Stream.of(dt.lastProcessed)
if (!pathList.isEmpty())
if (!pathList.isEmpty()) {
isEmpty()
@lautarobock This test is coupled with the other parts of the page. Shouldn't this be ShareType.USER_Shares(file,ShareType.USER_LINK))?
@lautarobock I'm not sure that the other codeShares are necessary with the same string test.
@lautarobock This line is now unnecessary
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction call, we'll end up with the same endAction call.
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0> and call detachUserToVm instead of detachUserToVm)
Please use parameterized logging instead of string concatenation.
Please use parametrized logging of slf4j instead of string concatenation
Please use parametrized logging of slf4j logging.
I would prefer to protect using this semaphore. acquire and release calls are too far away from each others to be confident that we don't run into a dead lock imo.
I would prefer to factor this out into a separate method something like createJsonWithStatus or so.
I would prefer to protect using this semaphore. acquire and release calls are too far away from each others to be confident that we don't run into a dead release path.
Isn't this check redundant?
Shouldn't this be if (!totalSizeAndSizeAndSizeAndSizeAndOffset) { idx++; }?
Shouldn't this be if (!totalSizeAndSizeAndSizeAndOffset && end >= totalSize) { idx++; }
Why not return abstract?
Why not return the file name?
Why not return the file.getName()?
I think this test is still passing when the teh participantService is null. Should we still call this?
I think this test is still passing when the teh participantService is null. It's the thing I'm not sure. We're setting the correct account to this.
I think this test is still passing when the teh participantService is null. It's the thing I've seen in the above mess.
Left over?
println("\nScenarios should be removed
Leftover?
Can we be sure it is not a good idea to throw an exception?
Can we be sure it is not null? If so, we should throw a NullPointerException if it's not a number.
Can we be sure it is not null? If not, we should throw a NullPointerException if the resolve() method is called.
Don't need to throw exceptions in the response.
Don't need to catch exception, throw the same way as that.
Don't need to throw exceptions in the log.
this seems like an opportunity to box the number of updates to the mature data store to be converted to a specific method that can be used by both data and data.
this seems like an opportunity to box the number of updates to the mature data store to be converted to a specific method.
this seems like an opportunity to box the number of updates to the mature data store to be converted to a String. Is this method used to convert the JSON to a JSON object?
Can we use @Test(expected =GridColumn.class) and use this instead of doReturn(0)?
Can we use @Test(expected =GridColumn.class) and use this instead of the for loop?
Can we use @Test(expected =GridColumn.HeaderMetaData) here?
I think we should add a new method in AbstractInjectionTargetFactory: protected <T> Object createBeanAttributes(Class<T> injectionTarget, Class<T> attributeContext) { return createBeanAttributes(cls, context); } here - what do you think?
I think we should add a new method in AbstractInjectionTargetFactory: protected <T> Object createBeanAttributes(Class<T> injectionTarget, cls, context, final )
I think we should add a new method in AbstractInjectionTargetFactory: protected <T> Object createBeanAttributes(Class<T> injectionTarget, String value, cls, context, final )
the new vdsm will fail on NPE, now I think that it was null
the new line is redundant, please remove.
the new line is redundant
Should we be more specific here? I guess it's not always the case.
Should we be more specific here? I guess it's not always the case?
Should we be more specific here? I guess it's not always local to this class.
@cvrebert let's use it here as well
@cvrebert let's use it instead of this.
@cvrebert let's use this.self.login.remove() as mentioned above.
Please use Predicates.withArg(variantEntityList.size() ) to avoid the unnecessary 'limit' loop.
Please use Predicates.withArg(variantEntityList.size() ) to make the code more readable.
Please use Predicates.withArg(variantEntityList.size() ) to avoid possible NPE.
suggestion.orElseThrow(() -> new InvalidParamsException(...))
suggestion.orElseThrow(() -> new InvalidParamsException(e)
suggestion.orElseThrow(() -> new InvalidStatusException(e)
Should be 60000000.
Is 500 really needed?
Is this the test really failing?
Could you elaborate the reason for this case?
Could you elaborate the use case when candidate == null?
Could you elaborate the reason for this case? We already checked <= timeout!
no need to cast to URI
no need to cast
no need to external
I'm not sure if you want to keep this as is, but it may be cleaner to add a assertTrue(e.getResource().hasProperty(RDF.type, Cdr.Tombstone));
I'm not sure if you want to keep this as is, but it may be slightly more readable to test the contentType as well
I'm not sure if you want to keep this as is, but it may be slightly more readable to combine these two lines into one
Table name says un-zero name but it is partitioned. Probably use better name!
Table name says un-zero name but it is partitioned. Probably use better name as it is acid name
spacing before and after = and +
Again, no System.out here
Again, please remove the System.out calls.
Again, no System.out here.
getMessage is already a String
getMessage is just a message
getMessage
Do you really want to declare declare variables here?
Do you really need to declare these methods as public?
Do you really want to declare declare these methods as final?
There is a class called.setExtraEditText which will save you to use.
There is a class called.setExtraEditText which will save you from calling this.
There is a class called RESULT_OK constant instead.
let's just propagate the exception
let's revert this.
let's just propagate the T?
Missing
not used
not convinced
Can do this in one line
Can be removed.
Can you remove.get()?
This method is called twice in this loop, I think we can extract it to a local variable.
This method is called twice in this loop, I think we can extract it to a static method.
This method is called twice in this loop, I think we can move it to a private method and call it in the constructor
Can we extract this part to a private method?
if you're testing the same path as testBasePath, this is not the proper name
if you're testing the same path as testBasePath, this is the same in the result
is this the same in BlockBigArray?
is this the same as for SliceSlice?
is this the same?
Why can't we iterate in this case?
Why can't we use a simple copy constructor?
Why create this?
Same deal here. Hibernate's containers tend to not adhere to the contract on.equals and.hashCode, so this is not clear. I'm not sure we need to keep this simple.
Same deal here. Hibernate's containers tend to not adhere to the contract on.equals and.hashCode, so this is not clear. I'm not sure we want to keep this simple.
Looks like this is potential NullPointerException: _this.getReleaseVer_
nit: () -> RefreshingExecutor.start()
nit: () -> long
nit: () -> ()
I think this check will always be true here.
I think this check is not needed; we don't check if the element is null.
I think this is always false here.
I think it's correct to assume that we don't want to start the encryption here, right?
I think it's correct to assume that we don't want to start the checkpoint for the given checkpoint.
I think it's correct to assume that we don't want to start the checkpoint for the given encryption.
If this can be null, I would prefer a NPE here. This can be solved by using a builder: private void addBucket(BucketObject ex) { if (bActions!= null) { try { builder.canLikeActionFor(builder, noteId); } catch (NullPointerException ex) { addTemplate(e); } }
If this can be false, I would prefer a if (null == OK) to throw a NPE here. This allows users to remove a non-null set.
If this can be false, I would prefer a if (null == OK) to throw a NPE here.
This should be done with setting of the fieldEntity.getType().
This should be done with setting of the fieldEntity.getType() as well.
This should be done in a different try catch statement.
You can also use a regex to see if you need it
You can also use a regex to see if you need it later
You can also use a regex to see if you need it.
use TextUtils instead
use method from Const.java
use TextUtils.isEmpty() instead
This can be simplified to: java public static void alarms(Alarm newAlarmList<Alarm>(alarms, alarms) {
This can be simplified to: java public void alarms(Alarm newAlarmList<Alarm>(alarms, alarms) {
This can be simplified to: java public void alarms(Alarm newAlarmList<Alarm>(alarms, alarms, clientId);
No need for the regex here ;)
No need for the empty line at all.
No need for the suffix on the class name.
Formatting from 2 places
Formatting issue
Formatting
Please, add an empty line before this and after the opening bracket
Please, add an empty line before this and the for loop.
Please, add a message to the end of the file to make it easier to read
Still needs to be true in both cases (i.e., in other places where weldCapability is used).
Still needs to be true in both cases (i.e., in other places where weldCapability is enabled).
Still needs to be true in both cases (i.e., should be true).
you should not be checking a single field type. you can just use the schema object directly, don't need to check field by field.
you should not be checking a single field type. you should assert the entire Schema object is equal to a single field type. you can just use the schema object directly, don't need to check by field.
you should not be checking a single field type. you should assert the entire Schema object is equal to a single field type. you can use TermId to be safer
Regkey.getNonNullRequestParamValue(Const.ParamsNames.STUDENT_RESULT) can be removed.
Regkey.equals(userInfo.googleId)
Regkey.getNonNullRequestParamValue(Const.ParamsNames.STUDENT_RESULT)
I think it would be more obvious to use this one: String name = (e.g. 'name') == null;
String Missing space after "=".
I think this condition can be put in the braces.
I'd add a WARN here
I'd replace this with a getSignatureInfo
I'd replace this with a getSignatureInfo.
Can you please elaborate on why this changed? It should be the default core PR.
Can you please elaborate on why this changed? It should always be true.
Can you please elaborate on why this changed? It should be the default core param.
can we catch the Exception to make it clearer
can we catch the Exception here?
can we catch the Exception to make it clearer to read?
Does this commit have to be sync from the server? It seems to me that its shared between the commit hook and the commit event should either this or it should be a merge request?
Does this commit have to be sync from the server? It seems to me that its shared with both commit and commit. I'll squash a bit about this commit and some refactoring.
Does this commit have to be sync from the server? It seems to me that its shared with both commit and commit. I'll squash into one commit and submit this commit

Why the code you did so early?
probably not needed?
Could use getImageChainFromDb().removeAll(chainFromStorage) here
Could use getImageChainFromDb().removeAll(chainFromStorage) here, as a suggestion
Could use getImageChainFromDb().removeAll(chainFromStorage) here, as a suggestion.
I think we should also include the content of the unknown namespace (in the error message) as well.
"config".equals(webNamespace) (probably doesn't need to be externalized)
"config".equals(webNamespace) (probably better)
The config should be injected into the builder.
The config should be parsed from the Java bean.
The config should be parsed from the Java 8 and not here.
I think throwing RuntimeException would be more appropriate.
I think throwing RuntimeException would be better.
String.format may be needed.
Should this be timeout instanceof Integer? 5000 : timeout
Should this be timeout instanceof Integer?
Should this not be timeout instanceof Integer?
Can you use CollectionUtils.isEmpty()?
Can you use CollectionUtils.isEmpty() here?
Can you use CollectionUtils.isEmpty()?
final List<String> candidates = (List<String>) ((List<String>) ((List<String>) optedRules))
final :)
final
add break
well, if the user is about to remove a certain block - this can be done with some other cases using the command.
well, if the user is about to remove a certain block, does it matter?
Add space after catch.
Add space before catch.
Add space between catch and (.
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
2 things: 1) If a DataException is thrown is it a good practice to go on? 2) Did this kind of error logging work with casting exception object to string message?
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting error message to string message?
There should be another log.warn("Couldn't find name for entity {}: {}", entityId, e);
There should be another log.warn("Couldn't find name for entity {}", entityId, e);
There should be another log.warn("Couldn't find name for entity '{}': {}", entityId, e);
The previous statement seems to be unnecessary if we remove the null check.
The previous statement seems to be unnecessary if we remove them.
The RuntimeException isn't needed here.
@adrielparedes here the call for metadatastore
@adrielparedes here the call for metadataStore
@adrielparedes here the call for metadatastore..
Same here, we don't need to add a variable for the filename.
Same here, we don't need to add a static import
Nit: Indentation is too long here.
I would rather store the string as a JSON object and regenerate it in AlgoliaException?
I would rather store the string as a JSON object and regenerate it in AlgoliaException or CUSTOM
I would rather store the string as a JSON object and regenerate it in AlgoliaException and equalTo
rename to projectSession or just "Project"
rename to "Project" to "manager"?
rename to projectSession or projectSession
I don't think we need to log any data, we can just use offsetAndMetadata.getCurrentEpoch().ifPresent(offsetAndMetadata::set)
I don't think we need this log.info anymore.
I don't think we need to log any data, we can just use fetchPosition, right?
This check is duplicated in MethodValidator.
This check is duplicated in TransposeTest on a MergeResult
This check is duplicated in MethodValidator#validateBean
Another option would be to remove this printout.
Safer to remove this
Is there a reason why this was needed?
It's not good practice to put the password in "sync token returned from broker resume". We can use it in the callback #Resolved
It's not good practice to put the password in "sync token returned from broker resume". We can use it in the callback rather than passing in 0.
It's not good practice to put the password in "sync token returned from broker resume". We can use it in the callback rather than "cancel".
Do you need this?
Do you need the method.getCount() here?
Do you need the method on TopNNode?
Should these two try/catch blocks be moved to a method?
Is it possible to call this getSubmitted call with a null value?
Should these two try/finally blocks be moved to a method?
Could we send this as a POST request with a battery SA?
Could we send this as a POST request
Could we send this as a battery banner method.
I think this should be after the tags are added to the tags.
I'm not sure what this means, but we need to make the LocatorAndConsolidateTokens follow the new SplitAndConsolidateTokens method (with two params) as they should be on the Locator and equals.
I'm not sure what this means, but we need to make the LocatorAndConsolidateTokens follow the new convenience method. If you want to update this, it will make the Locator and CRITICAL_NAME less readable.
Split into two lines for readability.
Use a logger statement for this
Use a logger statement for these logs
If this is going to be simplified using the LOGGER.error("message", e) would be good enough.
If this is going to be simplified using the LOGGER.error("message", e) would be good enough
If this is going to be simplified using the LOGGER's message also, would it be good to include the full stacktrace?
Nice! I'm not sure if we should have a condition here - something like: checkArgument(partitionConcurrency).equals(newConcurrency("Gather exchange must not have partition channels");
Nice! I'm a little keen on using checkArgument() here
Nice! I'm a little keen on using checkArgument() here, as it makes the code more readable.
shouldn't this be taken out?
shouldn't the FileInputStream be closed when it is set?
shouldn't this be taken out?.
don't need the else clause. You could use the default closing closing.
don't do this. You could use the default encoding for encoding
don't need the else clause. You could use the default closing statement
Shall we move this one to the parent class?
Shall we move this one to the parent class and to test if it's null?
tab
It is a pretty significant change to an assert method with applicable values but the style will be numaFreeBearerMap<String, int>
It is a pretty significant change to an assert method with applicable values but the values are not a string.
Really?
in general, we don't need to check if the first thing is true, since it's not the event that we're interested in.
in general, we don't need to check if the first thing is true, since it's not just any leader election.
I think it is okay to add a null check here.
suggestion Button headerButton = grid.getParent();
else if you don't have headerButton.removeColumn
else if you don't have headerButton.addColumn
Ideally LocalEnvProvider.rewriteLocalEnv would declare to return a ImmutableMap since all of its implementations actually do so. Could you please change environment to ImmutableMap and use ImmutableMap.copyOf(localEnvProvider.rewriteLocalEnv(...)) until that is fixed?
Ideally LocalEnvProvider.rewriteLocalEnv would declare to return a ImmutableMap since all of its implementations actually do so. Could you please change environment to ImmutableMap and use ImmutableMap.copyOf(localEnvProvider.rewriteLocalEnv(item.getSandboxOptions())?
Ideally LocalEnvProvider.rewriteLocalEnv would declare to return a ImmutableMap since all of its implementations actually do so. Could you please change environment to ImmutableMap and use ImmutableMap.copyOf(localEnvProvider.rewriteLocalEnv(item.get(0).getSandboxOptions())?
I'd do this filtering before the previous one - it's much cheaper.
1. I'd do this filtering before the previous one - it's much cheaper. 2. you can do something like: if (getParameters().getImageIds() == null) { taskHandlers = new ArrayList<>(); }
I think it's better to do this filtering before the previous one - it's much cheaper.
Please change this to: if (i1.equals(dex)) { return false; }
Please change this to: if (!(o instanceof InsnNode)) { return false; }
Please change this to: if (i.e. regardingIndexIndex(index1, insn2);
Just for consistency's sake, do we need to add a fail() here?
Just for consistency, see below.
Just for consistency's sake, do we need to add a fail() here?
Should be a constant
Should not we need to apply dynamic compatibility version here? I'm assuming that explicitly passing BC UI would have issues related to the cluster compatibility.
checking distributionVersion is a Map<String, >?
Add brackets
Add here URI to the previous check
Add here URI to the original URL
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
Shouldn't this be in an else case?
Shouldn't this be in a else case?
Don't need a null check for serviceInstance
Don't need this check, just set the attribute for service is enough
Don't need this check, just set a default value
Again, this could be handled by a lot of the db queries.
Again, this could be handled by a lot of duplicated code.
I think this should be handled by a lot of different types.
I don't think the exception happened here. It is helpful for debugging purpose. You can set it to debug level.
I don't think the exception happened here. It is supposed to be propagated to the readonlyBookiesFuture. It is not the first operation, but in this case the flow is moving future. The exception can be wrapped in a CompletableFuture<Void>.
I don't think the exception happened here. It is supposed to be propagated to the readonlyBookiesFuture. EXCEPTION_FUNCDEF
This is not the case that the WizardMessages are casted to the representation of the object.
This is not the case from the WizardMessages.e.e. not the span of the dialog.
This is not the case from the WizardMessages.e.e. not the span of the current one.
Did you take a look at this? <LINK_0>
Did you take this? <LINK_0>
Did you still need to print this?
Can you make this a private method with a descriptive name?
Can you make this a variable final?
Can you make this a private method, like the other one?
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, BlockBuilder blockBuilder)
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder) { // Reformatting the image from the current code }
you can run this once and cache the result, no?
please do not check the return code implicitly, I see there is getSucceeded() that can be used to raise an exception.
please do not check the return code implicitly, I see there is getSucceeded() that can be used to raise an exception..
Can we expect this to return valid SQL output? (e.g. "ero-defined SQL" or "(\\d+)"
Can we expect this to return valid SQL output? (e.g. "parameterIndex".toString().replace("", effectiveSql)
Can we expect this to return valid SQL output? (e.g. "ero-")
Can't we do this in one line as it's a comma?
Can't we do this in one line as well?
Can't we do this in one line?
This is not a OSGi service. You should not access the class name, it is not possible to use it.
This is not a OSGi service. You should not access the class name, it is the class name.
This is not a OSGi service. You should not access the class name, it's out of the class.
You should use Objects.equals() instead of hashCode.equals().
Please use Objects.equals(o) instead of hashCode which is Objects.equals.
You should use Objects.equals() instead of hashCode.equals(name)
Please move it to separate patch and use it in two places.
Please move it to separate patch and use it in two places
Utils.validateArg("ObjectMapper map.class")
Do you need this?
Do you think you need to check doc.put()?
Do you think you need to check Map.of()?
This is unnecessary, when the previous Venue object is used... The tests are ugly.
This is unnecessary, when the previous Venue object is used?
This is not needed, it is best to use the constructor
You are getting out here if out isn't null. You want to return out here if out isn't null.
You are getting out here if out isn't null. You want to blow up in case out <LINK_0> so once we get out of the loop.
You are getting out here if out isn't null. You want to blow up in case out <LINK_0> so once we get an NPE.
I think this should be!file.exists()
I think this should be isDirectory(), so that it checks for existence of file.getName().
I think this should be isDirectory(), so that it checks for existence of File.exists()
This is not the right way to fix it, but from other mappers, I'd suggest to do it the following: if (disk.isSetStorageDomains() && vm.get(0).isSetId()) {... } else if (...) {... }
This is not the right way to fix it, but from other mappers, I'd suggest to do it the following: if (disk.isSetDisk()) {... } else if ("disk.get(0).isSetStorageDomains() && validateParameters(disk, "name")) {... }
This is not the right way to fix it, but from other mappers, I'd suggest to do it the following: if (disk.isSetStorageDomains() && vm.get(0).isSetId()) {... } else if ("disk.get(0).isSetStorageDomains() && validateParameters(disk)) {... }
why not just initialize the buffer in the constructor?
why do you create a new buffer here?
why not just initialize the buffer to 4?
synchronized (LongJVMPauseDetector.class) looks like a bug
synchronized (LongJVMPauseDetector.this) looks like a bug
what if pause is false?
You could say SSE_C operations must be performed over a secure connection.
You can say SSE_C operations must be performed over a secure connection.
You could put this to a private method to avoid code duplication.
Why do we need to check this?
The parts of the code have nothing to do with byte[].
The parts of the code are now configurable.
This and below can be replaced with Collections.singletonList()
This and below can be replaced with Collections.singletonList(domain)
This and below can be replaced with Collections.sort(domainDomains::get)
unnecessary blank line
unnecessary type argument
unnecessary blank lines
I think that this logic is intended to be in a thread pool
I think that this logic should be replaced with a simple set of _waiting_ items.
I think that this logic should be replaced with a simple set of AsyncRunLoopWorkerMap construct.
isn't this redundant?
isn't this redundant? @Override
isn't this redundant? @DwordierMode What does it mean?
You can remove the this line.
You can remove this line since the call to.when() is redundant.
You can remove this line since the call to'setStorageIds' will be more efficient
I think you should support to have L106L112 and L11417.
I think you should support to have L106L112 and L114317.
static import
I wouldn't import the file name since it's a file.
I wouldn't import the file name, s/File.separator/prefix
s/File.separator/ref/<<>/
How is it reset if the test failed before?
How is it reset if the test failed after?
Looks good.
The code Precondition checks should be added since there is no message for it. So if you have to pass a valid error code and throw it will be better.
The code Precondition checks should be added since there is no message for it. So if you have to pass a valid error code and throw it then you'll get a stacktrace other than null.
The code Precondition checks should be added since there is no message for it. So if you have to pass a valid error code and throw it then you'll get a stacktrace more informative.
Does it make sense to have Test-case as a singleton?
Does it make sense to have tests for the upgrade?
Does it make sense to have Test-case?
we are still doing a while loop here, but use a while loop instead.
we are still doing a while loop here, but we are only writing a state of a file as a state, and then ignoring the sumOfQualify field.
we are still doing a while loop here, but we are only writing a state of a second param?
I know this is copied, but we should just use if else here
Am I missing something?
Am I missing something? :D
IDE says to use Collections.emptyList() here
IDE says to use Collections.unmodifiableList here
IDE says to use Collections.emptyList() to avoid constructing a new ArrayList.
@dalifreire It would be cleaner to throw exception here instead of returning null.
@dustinpho maybe we should throw exception here instead of returning null?
@dalifreire It would be cleaner to throw exception here instead of throwing it.
Would it be better to use isRegistered() here?
Would it be better to use isFirstSite() here?
Wouldn't it be better to use isFirstSite() here?
This blocks the formatter will be there: final List<String> keys = Arrays.asList(formatterList.size());
This blocks the formatter will be there: final List<String> keys = Arrays.asList(formatter.getFormat()).add(formatter.getFormat());
This blocks the client when calling the ArrayList constructor will create a new ArrayList.
you could here return the old one
you could here return getFieldValueWithoutException("label", true);
you could here return old one
You can just do return toArray(new Integer[0]);
You can just do return toArray(new Integer[0]); to avoid unnecessary array allocation.
You can just do return toArray(new Integer[0]); to avoid unnecessary object creation.
Could it be done in configureRequest method? Seems like it could be a good feet if it applies to all requests.
These two checks are not needed. Seems like they should be done in configureRequest method.
These two checks are not needed.
Why not use the same code as above in the method?
Why not use the same string as in the previous section?
Why not use the same code as in line 233?
Can you use interval terminology here, perhaps LeftEndpoint and RightEndpoint?
Maybe its better to use interval terminology here?
Can you use interval terminology here?
have we seen this error before?
have we seen it in the log before?
have we seen it this error before?
do it in this PR?
do it in this line?
do it in one line
Maybe you could set the listener on the next line in the test so that you don't have to wait for it.
Maybe you could set the listener on the trigger <LINK_0> and use the constant on the left side.
Maybe you could set the listener on the trigger <LINK_0> and use the constant on the start method.
Move this line inside the if block so it is consistent with the rest of the chain?
Move this line inside the if block so it's not needed?
Move this line inside the if block so it is consistent with the block below.
I think this should be a set, no?
I think this should be a set, to make the map smaller than the same values (e.g., non-default priority)
I think it should be okay to add the coimration only if there is an issue with the same change. The bug fixed in commit message, but I'm not sure.
This line is duplicated
This line can be moved inside the loop
This line can be moved inside the loop.
should we use a SQL parser here?
should we use a SQL spec here like hdfsEnvironment.get()?
should we use a SQL spec here like hdfsEnvironment.exists()?
Static import
static import
Static imports
Please move this line inside createDriverCommand.
Please move it to debug level.
Please move it to line 83.
LOG.info("Getting jar file from {}", tarFile);
LOG.info("Getting jar file from {}: {}", tarFile);
LOG.info("Getting jar file from %s", tarFile);
why you not using setUriInfo()?
same here, have setUriInfo()
same here, have setUriInfo() at setUp
Should we also test the result of /any(), pair.getValue()?
Should we also check status?
status?
I would recommend saving this value in a variable for readability.
I would recommend saving this value in a variable for reuse.
I would make this default value a constant
The check for hostProvidedPools is moved to the beginning of the method, so this block of code needs to be re-written as part of the conditional.
Nitpick: I'd prefer having the check here whether hostProvidedPools is empty (which is a valid check as well).
The check for hostProvidedPools is moved to the beginning of the method, so this block of code needs to be re-written as part of the for-loop.
MARKED_ROLLBACK, so that we have a lot of consistency of our code.
MARKED_ROLLBACK, so that we have a lot of consistency of our code, awesome.
MARKED_ROLLBACK, so that we have a lot of consistency of our code, very clear!
You should be able to use 'getStoragePoolId' and 'hostedStorageDomains' to get the storage domain from the storage domain.
You should be able to use 'getStoragePoolId' and 'hostedStorageDomains' to get the storage domain from the first storage domain.
You should be able to use the 'getStoragePoolId' method.
Remove Braces so it can be removed.
Remove Braces so it can't be removed.
Remove Braces so it can't be removed :)
This looks like it would be better to rewrite it in a try-with-resources block
This looks like it would be better to rewrite it in a "try-with-resources" block
This looks like it should be removed.
This equals implementation should include attributes from the Command super class.
Please implement equals() to avoid comparing any value.
Missing hashCode method.
And this else branch is redundant with the if (w1 == o2.getClass().getName()) return 1;
And this one should be public.
And this one
final
per up, but do you want to move this to a for loop?
foreach?
Minor nit: I would prefer a constant here like a name that describes what is happening here.
Minor nit: I would recommend using a try-with-resources block to make this more readable.
Minor nit: I would recommend using a try-with-resources here to make this more readable.
Are there no other standard utilities or libraries that can get this information?
Are there no other standard utilities or libraries which can get this information?
Are there no other standard utilities or libraries which want to be able to use?
Could you please explain why it is needed?
Could you please move the mockedRequestLogLine to the previous line?
Could you please omit the arguments?
Please use the same test case as the other tests.
Please use the same scope as the other tests.
Please use the same test case as the other test cases.
nit: this should be reader.getArguments() % 2
nit: this is unnecessary (and is unused)
nit: this is unused
magic? extract to constant
extract to constant, it is more clear (maybe)
extract to constant, it is more readable
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints.
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be closed. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints.
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints. design.
check if input is null
stateDefinitTime
Store the tree in a variable
Should check to see if the result is empty?
Should check to see if the result is empty.
Should do this in the if block below.??
Please use singletonList instead of assertEquals.
Please add reload after the assert.
Please use singletonList instead of + operator.
This change just caused me to realize that key should never be null
This change just caused me to realize that key should be null
This change seems incorrect
log.warn in default block is a good idea, but we should have case FAST_FORWARD_CONFIG.
log.warn in default block is a good idea, but we should have case FAST_FORWARD_file.error.
log.warn in default block is a good idea, but we should have case FAST_FORWARD_file.ignorecase.
I would change it to assertThat(updatedOrder.get(0)).hasState(order).hasState(order.getLineItems().get(0).getId())
I would change it to assertThat(updatedOrder.get(0)).hasState(order).hasState(order.getLineItems().get(0).hasState(order));
I would change it to assertThat(updatedOrder.get(0)).hasState(order).hasState(order));...
This can be replaced with Iterators.tryFind(address -> chain.append(readKeyBuffer).iterator().next().getPayload()).
This can be removed.
Looks like this the same as the next line.
We can use the Kind.R_PP_ComponentGenerator here.
We can use the Kind.R_PP_ComponentGenerator here instead.
We can use the Underscores default clunky here
(minor) I would have expected a single assertion on the expected value too. Also, might be nice to have a test with the expected value too.
(minor) I would have expected a single assertion on the expected value too. Also, might be nice to have a test with the expected value as well.
(minor) I would have expected a single assertion on the expected value too. Also, is it really necessary to have the expected value?
I know it's not your patch but those 5 lines should be replaced by: grouped.keySet().removeAll(collection);
I know it's not your change but those 5 lines should be replaced by: grouped.keySet().removeAll(collection);
I know it's not your patch but those 5 lines should be replaced by: grouped.keySet().removeAll(collection); This is much clearer.
i wonder if 'interval.getIntervals()' has been changed from "minutes" to 'MoreMinutes' may be a better name.
i wonder if 'interval.getIntervals()' has been changed from "minutes" to'maxMinutes' may be a better name.
i wonder if 'interval.getIntervals()' has been changed from "minutes" to "5 minutes"?
if we should show this condition every time... We should be able to view the analysis.
We should be able to move this logic to the view method in particular. Let's discuss in person.
We should be able to move this logic to the view method in particular. Let's discuss how tomorrow we.
I don't know why you can be versionId = "" can be null
I don't believe versionId can be null.
I don't know why you can be versionId = "" can be empty string.
Rather than getting a null from a map, I think we should get rid of the null check and just return the empty string.
Rather than getting a null value, I think we should get rid of the null check and just return the empty string.
Rather than getting a null value, I would prefer to instantiate an empty map.
why debug level and not error?
why debug level and not warn?
please remove the debug log, or add more context.
Would it make sense to return volumes with size -1?
Would it make sense to break the long-way conversion to an int?
Would it make sense to break the loop here?
I don't think this will work well if filepatterns is empty. Should we throw an IllegalStateException during call() if filepatterns.isEmpty() is true?
I don't think this will work well if filepatterns is empty. Should we throw IllegalStateException during call() if filepatterns.isEmpty() is true?
I don't think this will work well if filepatterns is empty. Should we throw an IllegalStateException during call() if filepath throws an exception? And we can decide if we can throw in this case.
Shouldn't you close the stream in a finally block? Wouldn't that be better?
Shouldn't you close the stream in a finally block? Wouldn't that be better to display the name of the file in the constructor?
Shouldn't you close the stream in a finally block? Wouldn't that be better to just have a return statement here?
Do we need a separate function for this? Can we have just a wrapper function that takes a list of bindings list?
Do we need a separate function for this? Can we have just a wrapper function that takes in a list of bindings list?
Do we need a separate function for this? Can we have just a single addAndDismiss function that takes a list of AppLists, and give it a singleton list in that case?
This should just be response.sendError(HttpServletResponse.SC_FORBIDDEN());
This should just be!Service.sendError(HttpServletResponse.SC_FORBIDDEN)
This should just be!Service.sendError(HttpServletResponse.SC_FORBIDDEN());
This is not the best practice for flipping the value. Let's change it in the future.
This is not the best practice as it is null and we cant change the meaning of the evaluation object.
This value is not used
The same as for-loop below, do the modify and return at the end: Collections.sort(subClasses, ids);
The same as for-loop below, do the modify and return at the end of the method.
The original code was easier to read, but it would be good to use <LINK_0> if it can go back to trouble.
Hmm, now I see why you need to return the future here. I think it should be the other way around: java CompletionStage<Session> process(Response.class, DefaultSession session, () -> {... }). I don't think it's a good idea to keep the interface unchanged here.
Hmm, now I see why you need to return the future here. I think it should be the other way around: java CompletionStage<Session> process(Response.class, DefaultSession session, () -> {... }). I don't think it's a good idea to keep the try/catch that is.
Hmm, now I see why you need to return the future here. I think it should be the other way around: java CompletionStage<Session> process(Response.class, DefaultSession session, () -> {... }). I don't think it's the best option here.
you aren't removing duplicated entries...
you aren't changing this from public to public
you aren't changing this from public.
Should this be an an utility method? Now it can be updated from multiple places to make it easier to read.
Should this be an pulsePairs
make it an pulsePairs
Ah, this is why we are opening the liveReloadServer to start. Why don't we use the scheduler. It will create a new task and not start it if it fails to start or stop.
Ah, this is why we are opening the liveReloadServer to start. Why don't we just use the scheduler.
Ah, this is why we are opening the liveReloadServer to start. Why don't we just use the scheduler. I'd rather introduce a new method to do this check.
I'd use the instant() method here, and also use it for the validate() method.
I'd use Objects.firstNonNull here.
I'd use the instant() method here, with a getTraceEntry.
Does this need to be final?
Does this need to be 30 or so?
This seems like a good candidate for a constant.
java try ({ gatewayPath}}") {
java try ({ gatewayPath}}") { //... }
java try ({ gatewayPath = context.getServerPort()? "Can't generate:%d" : ") { }
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count)
This is not optimal for localization (for languages that don't use arabic numerals) Consider using something like NumberFormat.getInstance().format(count)
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance()
Why we want to fail such queries? Presto can still query from such table if we disable bucket-by-bucket right -- Also it depends on our configuration on hive.max-outstanding-splits-size right?
I think we should fail such queries if we don't want to fail. getBucketProperty isn't called by getColumnHandles(). (and also, suggested not calling getColumnHandles() anyway)
I think we should fail such queries with getBucketProperty too.
Maybe it would be better to use IntNodeUtils.parse here.
Maybe it would be better to use IntNodeUtils.getNumber() here.
Maybe it would be better to use IntNodeUtils.getNumber()?
Catch relevant exceptions.
Catch relevant exception.
Add context specific message without checking
Use Assertions.assertThat(elements.get(0)).isNotEqualTo(elements.get(0)).containsExactly(elements); instead.
Use Assertions.assertThat(elements.get(0)).isNotEqualTo(elements.get(0)).containsExactly(elements.get(0))
please use asserEquals for all the services
Can we assert that the range of values are correct? For example, I think we should assert that the range is greater than. But in any case, since we're parsing the header string.
Can we assert that the range of values are correct? For example, I think we should assert that the range is greater than. But in any case, since we're parsing the metadata.
Can we assert that the range of values are correct? For example, I think we should assert that the range is greater than. But in any case, we're parsing the header string.
I would change this to res.load()
I would change this to res.load().toOSString()?
I would change this to res.load() + "res".
Why do we need to cast these to ReplicaEventType?
Is this method used for convenience?
Why do we need to cast these to the implementation?
should we use _is_simple_to_dateLists_ in a list to iterate through the values?
should we use _is_simple_to_dateLists_ in a list to iterate through the codeList?
should we use assertCodeLists?
This consumer can be a static constant.
This consumer can be a static constant. The same goes for the next line.
This consumer can be a constant.
I think it would be better to move the verifyOpen method to the LedgerManagerFactory constructor.
I think it would be better to introduce a method storage.gcThread.setForceGC().syncExec().getLedgerManagerFactory(conf, conf.gcThread())
I think it would be better to introduce a method storage.gcThread.setForceGC().syncExec().getLedgerManagerFactory(conf, conf, LedgerManagerFactory.class)
The getEpisode() method is called twice. Please remove this author from the original line
The author in this file is not what we want. Please handle the exception.
The getEpisode() method is called twice. Please remove this author from the original line.
Uh. I think you could replace the for loop with Stream.ifPresent(expression -> toReturn.add(scenarios.getFactIdentifier(), clonedFactMapping);
Uh. I think you could replace the for loop with Stream.ifPresent(expressionElement -> clonedFactMapping
Uh. I think you could replace the for loop with Stream.ifPresent(expression -> toReturn.add(scenarios.getFactIdentifier().cloneFactIdentifier());
Please don't create a new error message for this, keep the log error.
Please don't create a new error message for this: Unable to find if no entry is found. If you are not in the index, you can name the remote repository.
Please don't create a new exception in the log, keep the cause.
You don't need to add this here. The call to put in the OS file here. You only iterate over the processes.
You don't need to add this here. The call to put in the OS file here. You'll end up with something like: OS[] fsArray = fileList.iterator().next(); for (Entry<String, NLSKey> file : fileList) {.add(entity); }
You don't need to add this here. The call to put in the OS file here. You'll end up with something like: OS[] fsArray = fileSystem.getFile(file); for (Object fs : fs) {.add(entity); }
Since this is important then we should have a test that validates that we never lose the error.
Since this is important then we should have a test that validates that we never lose the error during the downstream process.
Since this is important then we should have a test that validates that we never lose the error, shouldn't the getMessage() return null?
Newline before the try?
Newline before the try.
Newline before the try
nit: This is really just a plain JavaScript function object rather than a functor.
nit: This is really just a plain JavaScript function object rather than an functor.
nit: I really don't feel like this is really an error.
== 0 should assign the first element to the variable
== 0 should assign the first element to the method.
== 0 should assign the first element to the variable.
Won't it be better to test this as well?
Need to test this.
readInsertionIndex
I don't understand why you need to set core.. this should be in here.
I don't understand why you need to set core.. this should not be parsed
I don't understand why you need to set core.. this should not be in here.
suggestion final boolean received = false;
suggestion final boolean a = "Terminating".
suggestion final boolean a = "Terminating: " + Ping.
I think this is not used.
Perhaps add a "create" here, since it is used in multiple places
Can you move this to a private method?
Why is this being used here?
Why is this a special case of canonicalizedHeaders?
Why is this a special case of the headers?
This block looks the same as in the other constructor. Should it be DRYed out?
This block looks the same as in the other constructor. Can you extract this block?
This block should be synchronized as well.
Replace with IProject.isPublic
Replace with IProject
Replace with ||
It would be nice to simplify the logic a bit by extracting the url to a separate method.
It would be nice to simplify the logic a bit by extracting the name to a separate method.
misspelled
I wonder if it would be better to wrap this in a separate if (extractFieldsFromFilter!= null) check.
I wonder if it would be better to wrap this in a separate if (extractFieldsFromFilter!= null) check to avoid the extra lookup?
same question
I prefer constant because it's also used in other classes.
I prefer constant because it's also used in other places.
I prefer name bindDoc method which returns a property value rather than String.
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1). The behavior is the same, but it makes the intent more explicit.
Please put back the parentheses around (getIndexForKey(previousChildKey)). The behavior is the same, but it makes the intent more explicit.
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1). The behavior is that it makes the intent more explicit.
Couldn't you use Collections.emptyList() here?
Couldn't you use Collections.emptyList() here instead?
Couldn't you use Collections.emptyList()?
Looks weird here. Keep the indentation level as before?
Can be given a more meaningful name, like totalAnswer,?
Can be given a more meaningful name, like totalAndAnswer
The message isn't wrong, it just gets logged twice and not by the next message
The message isn't wrong, it just gets logged twice and then the message is wrong.
The message isn't wrong, it just gets logged twice and not by the squashed commit.
Please do not write into System.out.print. Please use log instead.
Please do not use System.out.print(), please.
Please do not use System.out.print. Please use log instead.
You can use a try-with-resources to ensure that the stream is always closed.
You can use a try-with-resources as you're automatically handling the buffer.
You can use a try-with-resources to ensure that the stream is closed.
@mehturt: Above where the assignment is made, please write this back to the old method, and re-assign to the new assignment.
@mehturt: Above where the assignment is made, please write this similar change to the old code, too.
Is this needed?
if you modify this change, please prefer to use only public void set(final SourceSink record) { message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.valueSchema(), record.getValue()); }
if you modify this change, please prefer to use only public void set(final SourceSink record) { message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.getValue()); message.setHeader(message, record.getValue()); }
if you modify this change, please prefer to use only public void set(final SourceSink record) { message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.getValue()); message.setHeader(Message.FIELD_SOURCE, record.getValue()); }
if we are going to do this, can we make it _this_ instead of tautious?
if we are going to do this, do we still have to go through the map?
is this correct?
Can you undo this?
Can you undo this change?
can you undo this?
This is not needed here.
Can you move this assignment here and other places?
this is not needed
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
While you're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
While we're on here, could you replace that with this: for (Object selectedObj : structured.toList()) {
look at PentahoSessionHolder.getSessionParameter(null)
format
UUID.fromString can return null.
If we're counting the interval (I have no idea why 2 concurrent connections?) we would get the last interval from the first interval.
If we're counting the interval (I have no idea why 2 concurrent connections?) we would get the first interval every time for a second interval.
If we're counting the interval (I have no idea why 2 concurrent connections?)
Maybe we need to read the file stream in a finally block
Can we have a cache in the class and have a final variable for it?
Maybe we need to read the file stream in a finally block or just in case.
lz check if (ds!= null)
prefer ==
prefer == operator
use createSafeXmlSource
use createSafeXmlUtils
use createSafeXml(...) instead
@komazaspalacio IIRC, in the other cases of the SDK, we need to limit the scope of this check so that the view would be taken care of.
@Torenko Same here. You need to check for null from the other methods in the SDK.
@Torenko Same here. You need to check for null from the web UI in the SDK metadata since this could return null.
We shouldn't be using File.getProject() here but just IResource[].
We shouldn't be using File.getProject() here but just to be consistent with the rest of the codebase.
We shouldn't be using File.getProject() here but just to be sure that repository is in the name.
Should be "lookup".
Should be an else
Should be an else block
Again, please don't make recursive RPCs, use data from the ProjectDetail object.
Again, please don't make recursive RPCs, but instead add the necessary data to the ProjectDetail object.
This isn't can be recursive?
ditto - I think it is better to use realmFactory. It will be easier to understand this.
ditto - I think we can use realmFactory.makeLaunchAndCompactOnLaunch(realm, RealmConfiguration.class). It will allow us to get rid of the need for realmConfig.
ditto - I think we can use realmFactory.makeLaunchAndCompactOnLaunch(realm, RealmConfiguration.class). It will allow us to get rid of the need for RealmConfiguration.
I think this should be externalized
Could you please rename this to getInputStream or something similar
I think this should be translated to IndexCommand
Could use BufferedReaderProvider.append(...).
Could use createSSLContext() directly.
Could use stringbuilder
Why not add this lock to the queue itself?
remove method
Same as above, remove method
Same here. Let's remove this line
Same here. Let's remove this line.
Same here. Add a log statement.
Again, "Branch %s" is not supposed to be tested.
Again, "Branch".
Again, "Branch %s"
Use the first letter in exception message
Use the first letter variable
Remove the extra space
Should this log statement be at the end of the method?
Should this log statement be changed to LOG.info?
Should this log statement be changed to LOG.debug?
The.requiredString, not the value.
You should also check.requiredString, not just the field.
You should also check.requiredString, not parquet.
I would wrap this in a try-with-resources, ie. throw new CRSDefinition().containsKey("..."));
I would wrap this in a try-with-resources, cleaner and safer code
I would wrap this in a try-with-resources, cleaner and safer code a bit.
I find this easier to read as: java final InputStream stream =.stream().filter(first -> is(first, is(instanceOf(Dog)).findFirst().orElse(null);
I find this easier to read as: java final InputStream stream =.stream().filter(first -> stream.equals(Object.class)).map(Object::cast).toArray();
I find this easier to read as: java final InputStream stream =.stream().filter(first -> stream.equals(Object.class)).toArray();
Is it possible to use the method name?
Is it a bug that it's a key, not a password?
Is it a bug that it's a key?
You don't really need to declare this variable here. You can do setText(new Integer(SessionHistory.totalPoints));
You don't really need to declare this variable here. You can do it once on line 97 of this line.
You don't really need to declare this variable here. You can do it once on line 97
We can use Guava's Sets.newHashSet(...)
We can use Guava's Sets.newHashSet(...) instead
We can use Guava's enum instead of the String.format() here
A little detail on the usage of the ParameterFormatter would be better extracted as a function.
Agreed, it's a copy/paste error.
Agreed, it's a bit odd to instantiate a new array and then set the size.
Should return replicationLoadSource never be null, and make sure start getReplicationSourceList return an empty list in this case.
Should return replicationLoadSource.
Should return replicationLoadSource never be null, and make sure start function is never called.
This change will break all other versions of ReviewFile.
This change will break the API.
This change will break all other versions of Review file.
This line is repeated in all the tests, why not put it in a @Before method?
This line is repeated in all the tests, why not have it in setup()?
This line is repeated in all the tests, why not put it in a @Before method? @BeforeClass and @AfterClass?
I'm not sure it is good to have the method to throw IOException and rethrow as UncheckedIOException. Could be converted to PicardException
I'm not sure it is good to have the name of the file in this error message. How about "Database directory and didn't write to or close output file"?
I'm not sure it is good to have the name of the file in this error message. How about "Can't write to file and not found."
Can we change the variable name Beneficiiciici to match the formatting of the variable name? That is not the same as the variable name.
Can we change the variable name Beneficiiciici to match the formatting of the variable name? That would be confusing.
Can we change the variable name Beneficiiciici to match the formatting of the variable name? That is not the same as the original code.
NIT: you can use o2.equals(o1.getLeftPlace())
NIT: you can use o2.equals()
NIT: this is not going to be enough to call this variable for clarity.
Here and below: Please, remove curly brackets for one-line statement after if
Here and below: Please, remove curly brackets for if-block.
Here and below: Please remove curly brackets for one-line statement after if
There's no need for this new HiveSQL annotation.
There's no need for this variable here.
There's no need for this variable here, right?
Please rename the variable to something more specific, like ConfigParams or ConfigParams.instanceId
Please rename the variable to something more descriptive, like ConfigParams or ConfigParams.instanceId
Please reformat code according to our formatter.
I assume this is only for debugging?
I know this is only part of the new code, but still. This is the place where it should be.
I know this is only part of the new API, but please add a new method here.
This is fine, but you might want to add a new method for this.
This is fine and should be handled.
This should be handled.
We actually don't need this, just filter out the range of timestamps
We actually don't need this, just.map(this::get) will throw a NPE
We actually don't need this, just filter out empty map?
I think we should rather call the lamda here rather than this: java if (hasIdField(result)) {.. } else if ( ) { the }
I think we should rather call the lamda here rather than this: java if (hasIdField(result)) { this.message = Util.INSTANCE.getDataObject(); }
I think we should rather call the lamda here rather than this: java if (hasIdField(result)) {.. } else { the }
Should use EntityList.stringToClassMapping(class) instead.
Should use EntityList.stringToClass(class) instead.
This should be a EntityList.createEntityByName(String, int)
Is it worth a warning that the entry is an unknown (as it can be null)?
Is it worth a warning that the entry is an removed node?
Is it worth a warning that the entry is removed?
This is a great opportunity to rename it to function, I can see that you are using the result of sorting.
You can inline all the places in this file.
This variable is declared final
Could you use StringUtils.isBlank here (and in the other places)?
Could you use StringUtils.isBlank here (and in the other places) to avoid NullPointerException?
Could you use StringUtils.isBlank() here (and in the other places)?
Why do we need to clear the list after the addAll? (just curious)
Why do we need to clear the list after the addAll?
Why do we need to clear the list after the addAll? (line 177)
Why the issue results when a check is enabled? The issue happens with a quick fix.
Why the issue results when a check is enabled? The issue happens with illegal argument exception, which is very difficult :-)
Why the issue results when a check is enabled? The issue happens with a solution for me.
what's the point of an explicit index?
what about State.INIT?
what's the point of RpcKey?
I am concerned about this change. It seems that this code is rather similar to what's already in the IterationStack#process() method. Can't we just throw an exception instead of returning null?
I am concerned about this change. It seems that this code is rather similar to what's already in the IterationStack#process() method. Can't we just throw the exception on the next iteration instead of returning null?
I am concerned about this change. It seems that this code is rather similar to what's already in the IterationStack#process() method. Can't we just throw the exception on the first loop?
Has there been a reason for % with %?
Short.append(System.lineSeparator()).append(System.lineSeparator() )
if you want to run this code with a nullable Boolean rather than double
index = csl.get(cs);?
index = csl.get(cs);
Here too, files are consumed. Remove this line, too.
While you're at it, could you also use assertEquals() instead of assertEquals()?
While you're at it, could you also use assertEquals()?
While you're at it, could you also use assertEquals() instead?
Could you describe how many rows in the name does not match?
The name in the exception message is confusing, since the name doesn't have a type.
The name in the exception message is confusing, since the columns are already fetched.
can you rename this variable to usePurapWorkflowConstants.e.
can you refactor this if statement to match the rest of the method?
should this be } if (nodeName.equals(nodeName)) { return -1; }
Same here, we can return the 404 from the Id object.
Same here, we can return the 404 from the Id method.
Same here, we can avoid the else
The last item is always the right.
This last item is always the right.
The last item is always the same.
I hope the event producers are not shared across the connectors?
I hope the event producers are not shared across the connectors? We don't want to use it across the connector.
I hope the event producers are not shared across the connectors? We don't need to use it across the connector.
1. Again, why not use 2.putShort((short)(q.length() * 2)
1. Again, why not use.putShort(Short.BYTES)?
1. Again, why not use 2.putShort(Short.BYTES)?
@ktoso What was the reason for this not getting caught by the implementations?
@ktoso What was the reason for this not getting caught by Exception?
@ktoso What was the reason for this not getting caught by @Override?
according to the original code the "isInternal" can be null so it would fail here. Are you sure that "isUser" is never null here?
according to the original code the "vm" can be null here. Wouldn't it be better to return an empty list instead of null?
according to the original code the "vm" can be null here. Wouldn't it be better to invert that?
smaller than 1?
smaller than 1
smaller than bigTo.longValue()
Should be like this: java @Override protected boolean isExplicitly(...) { barcodeLookupButton.click(); }
System.out call is useless (i.e. prefer to have a constant or constant).
Should be else if
I think it's better to use DEFAULT_SNAPSHOT_SIE_FACTOR and use it here as well.
Can we use DEFAULT_COMMIT_LOG_COUNT and DEFAULT_COMMIT_LOG_COUNT here?
I think it's better to use DEFAULT_SNAPSHOT_SIE_FACTOR and use it as the default value.
Why not use streams here?
Why not use blockDao in the first place?
Why not move the try block inside the while block?
Would you mind to replace all these tests with lambdas?
Would you mind to replace all these tests with a single GroupRepresentation test(group.getId())?
Would you mind explaining a bit?
nitpick: I would move this logic to the top of the method.
nitpick: I would move this logic to the top of the method since it is used here.
Should be static
You should use Exception here.
The Error message should be "Invalid IOException", e
You should use Exception here
This can be replaced with forEach.
This can be moved outside the try/catch block.
This can be moved outside the try/catch, right?
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should throw an exception instead.
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should be removed (Minimize.MAX_VALUE).
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should be removed (Minimize.Default)
I don't think this catch statement is needed since UnsupportedEncodingException is already caught by the catalog service implementation.
I don't think this catch statement is needed since UnsupportedEncodingException is already caught by the catalog service.
I don't know if this catch block is needed since UnsupportedEncodingException is already caught by the catalog service.
I think you want COLUMN_FAMILY loaded as false for expected values.
I think you need COLUMN_FAMILY loaded as false for expected values.
I think you need COLUMN_FAMILY loaded as false for expected values to be empty and test the clear.
Shouldn't we add the original condition as a boolean?
Shouldn't isOperation be null check here?
Why is this call necessary?
Can these three System.out be removed?
Can these be removed?
Can you convert this to use the logger style, rather than system out?
could you use.mapToLong( PoolArenaMetric::numDirectL) instead?
could this ever be 0 and 1?
could this ever be null?
Please use if-else
Please use DateTimes.wrapFormatter(ISODateTimeFormat.basicDateConverter())
Please use DateTimes.nowFormatter.
nit: I think we can avoid the use of webDriverContainer.getCurrentAddress()
nit: I think we can avoid the use of webDriverContainer.getContainerInfo().getMounts() variable :)
nit: I think we can avoid the copy over this line.
It's preferable to change the existing method (to pass the currURL) to avoid code duplication.
It's preferable to change the existing method (to pass the currURL) to the constructor (to avoid duplication.
It's preferable to change the existing method (to pass the currURL) to the constructor (to make the code shorter and clearer.
Should be initialized on that?
Should be initialized on that.
These are not constants?
remove, dead code.
call is still used to create an Aggregation down below.
call.getFilter().getOutputSymbols() could be null
rename to res
rename to contribution
rename to launch or config
note that the VM compatibility version may be different than the cluster compatibility version - this assumes they are the same, right?
how about replacing those with: getVm().setUseHostCpuFlags(false);
how about replacing those with 'RunVmParams' field? it would be clearer
The name of the method is misleading. 'ex' is when we add'release' to the flow.
The name of the method is misleading. 'ex' is when we add'release' to the flow. Is that intentional?
if you wrap, you can call addAll on the output
It would be great to have a convenience method for getting caught UriUtils.
It would be great to have a convenience method for getting caught by the remote name since it is also used twice.
It would be great to have a convenience method for getting caught by the remote host.
This method is doing a double-take, it might be better to move it into a separate method. Then we can call it in this file as well, which would save code duplication.
This method is doing a double-take, it might be better to move it into a separate method. Then we can call it in this file as well, which would save some work.
This method is doing a double-take, it might be better to move it into a separate method. Then we can call it in this file as well.
It is better to use TestUtils.assertInEventCount() instead of string concatenation.
It is better to use JUnit4-style.
It is better to use TestUtils.assertInEventCount() instead of "".
Why do you need this line?
Why is this line necessary?
Why do you need this?
Also this needs to be a form of _then_ guarded_ to avoid code duplication.
Also use ConcurrentMap.putIfAbsent().
Also this needs to be changed.
What happens if the above condition was non coded?
What happens if the above condition was not set?
What happens when the above condition was non coded?
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error,...))
Could also change to use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error,...))
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error, No_Error))
for(final Row input : row) {
not sure if it's possible that the row could not be closed.
not rethrowing the exception.
Embed the caught exception in the newly thrown exception
Embed the caught exception in the newly created exception
Embed the caught exception in a newly thrown exception
Shouldn't the schema lifecycle follow the Realm instance lifecycle instead? E.g. release it when we release the cache?
Shouldn't we wrap the exception in a separate catch block to catch any exceptions?
Shouldn't we wrap the exception in a RuntimeException instead?
I don't think that data.getDensity() can return null, but this can be null.
I don't think that data.getDensity() can return null, but I think this should be null.
Magic constant?
It's better not to provide this boolean value as parameter. Otherwise if debug logging is enabled you will block the collection status change event every time it's called.
It's better not to provide this boolean value as the parameter. Otherwise if debug logging is enabled you will block the collection status change event every time it's called.
Rename LOG.warn
looks like the file is never deleted
Please use the tested constructor with parameters.
Please use the tested constructor with parameters instead.
We could use the findFirst method.
We could use the findFirst method that takes a file name as a parameter.
We could use the findFirst method that takes a File as parameter.
we can avoid the null check by calling getStatisticsTruncateLength() here and below.
we can avoid the null check by moving this to the previous line
we can avoid the null check by calling getStatisticsTruncateLength(), and shouldn't be necessary here.
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
I think it would be better to do the same thing in Provider constructor.
what's the point of the method here? Just call startFrom here?
How about just one filter? I think we just need to do it in the apply-up PR.
what's the point of the method here? Just call startFrom
return zkProp.toString()? this : zkProp.getJvmBackOffPolicy();
return zkProp.toString()? this : zkProp.getJvmStatic();
return zkProp.toString()? it is less readable
Remove all references to this.
Should there be a constant for this?
Remove all references to our tests.
I think these two lines can be merged into 1 if condition.
I think we can remove these extra lines (here and in TextUtils.isEmpty(mBrowserType)
I think we can remove these extra lines (here and in TextUtils.isEmpty(mBrowserType) basically.
can priority be null?
can priority ever be null?
priority is non-null, while actionPriority is null
state.tryLock()
state is a boolean - no need to tryLock
state == null -> state.tryLock?
We could remove the duplicate exception's logProvider call since it would also give the stack trace.
We could remove the duplicate exception's log.trace
please add a message
can we replace this with containsKey(tag)
can we define a private method that can be used by both 54?
can we replace this with containsKey(tag)?
Do we need this?
Why have this copied to the memory?
Is this complete?
The params are not used?
Are paramsNotOwnedCourses not enough?
Are paramsNotOwnedCourses actually redundant?
not sure why this is needed?
not sure why this is needed here
not sure why this is necessary?
Smells like cleanup(requestTimeout, TimeUnit.MILLISECONDS, new LeaseRequest());
Double-checked locking, but not needed in the new code
Smells like cleanup(requestTimeout, TimeUnit.MILLISECONDS)
This is wasteful as you end up calling ColumnUtils.logWithRetry(), so I'd suggest this instead: try {... } catch (Exception e) { Thread.currentThread().interrupt(); } It's sucks, though.
This is wasteful as you end up calling ColumnUtils.logWithRetry(), so I'd suggest this instead: try {... } catch (Exception e) { Thread.currentThread().interrupt(); } It's sucks, though we're checking soperational behind them.
This is wasteful as you end up calling ColumnUtils.logWithRetry(), so I'd suggest this instead: try {... } catch (Exception e) { Thread.currentThread().interrupt(); } It's sucks, though we're checking for anything else than s.
I'd very much prefer the String.length (the last argument be a length of the file)
I'd very much prefer the String.length call, it gives very specific error message.
I'd keep the naming - it was weird that there is no index of length 1
This could be simplified to: java if (this == o) return true; if (o == null ||!description.equals(measuredUnit)) return false; return measuredUnit.stream().filter(this::cast).map(this::cast).collect(Collectors.toList());
This could be simplified to: java return measuredUnit.stream().filter(this::cast) &&!description.equals(measuredUnit.description))
This could be simplified to: java return measuredUnit.stream().filter(this::cast).map(Measure::description).collect(Collectors.toList());
You should test if the method is not deprecated then no log should be issued
You should test if the message is not deprecated then no log should be issued
Please test if the method is not deprecated then no log should be issued
Minor detail: should be DOT@ADDRESS.
Minor detail: should be DOTized
Possible NPE in next line when command.get() is null.
@dilini-muthumala Dilini, Can we move this code to AbstractExecutor so we can adjust the order of the existing code?
@dilini-muthumala Dilini, Can we move this code to AbstractExecutor so we can adjust the order of truth?
AbstractExecutor is an internal class, so remove all the static imports
Could you configure the GeodeAwaitility message from the function definition.
Could you configure the GeodeAwaitility message from the function definition instead?
Could you configure the GeodeAwaitility message from the function definition instead of leaving it up?
This is a bit nitpicky, but since you're using googlePlayServicesCheck I would suggest using a ternary operator here.
This is a bit nitpicky, but since you're using googlePlayServicesCheck I would suggest putting this into the last conditional so you don't need it.
This feels like it might be more readable.
This doesn't look right.
This doesn't look right. is that really necessary?
Is this really needed?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a little more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variables / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
This should be moved into the try block so that the catch block is always closed.
This should be in a finally block
This should be moved into the try block so that the catch block is always executed.
Put space between "MEMORY based eviction" and "not".
Put space between "MEMORY based eviction" and "not set..."
Put space between if and (
...and get the injected cleanUp() method return null
Yes, it's an error.
Yes, it's an invariant that cleanUp() can return null and if it is null, so, we don't NPE.
Disable caching on the client and also test fetchAll. Also, waitForWrite option doesn't seem to be directly tested.
Disable caching on the client and also test fetchAll. Also, what about testing the page size in the test?
Disable caching on the client and also test fetchAll. Also, what about testing the page size (see MR P.isClasspath())?
Good catch. But let's have a message to pull after that.
Good catch. But let's have a new exception type for this.
Should be error, not.
nit: cleanup "public"
Keep in mind the throws block of the test methods
Keep in mind the throws Exception
else { is redundant
else { }
else if
@vilchik-elena This looks wrong:!shape.stream().filter(element ->!shape.getId().equals(element.getId())).findFirst().orElse(null);
@vilchik-elena why not Stream.of(element.getId())?
this block looks wrong, why not Stream.of?
Tiny detail, but I think we should have been more clear when there is no async task.
Tiny detail, but I think we should have been more clear when there is no async call.
Tiny detail, but I think we should have been more clear here.
else { is redundant
Will this error message match the condition?
Will this error message be confusing?
nit: the null check is unecessary
nit: the code is simpler to understand.
nit: the code is simpler to use database.getDatabase().
Use settings.getBiomeSettings().copy(type, settings); instead
Use settings.getBiomeSettings().copy() instead
Use settings.getBiomeSettings().copy() instead of type!= null
Can you use iEvent instead of iEvent?
Can you give a meaningful name for the event because of that?
Can you give a meaningful name for the event to be?
When is timestamp 0?
When is this null?
When actionCount is 0, can we use 0?
Can we put this block in the try-catch block?
Can we put the null check on the right hand side of the.exists() call?
Can we put the null check on the right hand side of the.exists() check?
I think this change is deprecated. Please call the variable remove.
I think this change is deprecated. Please call the variable removeMissingSession
I think this change was removed.
I tried using a different method to increase readability. It is a good improvement.
I tried using a different method to increase readability. It looks like a simple loop, but this method is not really necessary.
I tried using a different method to increase readability. It looks like a reasonable change.
I think we can use the OffsetAndMetadata constructor here instead of calling it multiple times.
I think we can use the OffsetAndMetadata constructor here instead of the copying directly.
I think we can use the OffsetAndMetadata constructor here instead of calling it twice.
double check here. Can you use jwt.getSubject()
double check if this is done in jwtConsumer.getClaimAsString
double check if this is done with an exception. Can we avoid that?
is this needed?
I would avoid the magic number here by using a constant instead.
I would avoid the magic number here by using a constant.
Typo : "param"
Typo : param -> variable name
Typo : param -> variable
else if (value instanceof String) { return ((String)value).getBytes(); } else { return buffer.putLong(value); }
else if (value instanceof Number) { return ((String)value).getBytes(); } else { return buffer.putLong(value); }
else if (value instanceof String) { return ((String) value).getBytes(); } else { return buffer.putLong(value); }
Use ObjectUtils for all of these ifs
Use ObjectUtils for all of these casts.
Use ObjectUtils for all non null checks.
I think the else is redundant, can be CellCollection.EMPTY_LIST_PATH.
I think the else is redundant, can be CellCollection.singleton(content)
I think the else is redundant, can be CellCollection.
IINW, this call has the potential to produce NPE, since we don't check for the existence of the host.
IINM, this call has the potential to produce NPE, since we don't check for the existence of the host.
IINW, this call has the potential to produce NPE, since we don't check for the existence of the host. Same for the other commands.
Shouldn't we be defensive here?
Shouldn't we be using forEach here too?
Shouldn't we be using forEach here?
If processWorker is running in parallel to overwriting the member variable, we may as well set it to null.
If processWorker is responsible to call processWorker.run by taskName we will never get read/write a request. Do we need this again?
If processWorker is responsible to call processWorker.run by taskName we will never get read/write a request, do we need a processWorker?
See above, but timeTakenNanos should take a long or this will be broken for times over 3 seconds (Integer.MAX_VALUE nanoseconds)
See above, long timeTakenNanos should take a long or this will be broken for times over 3 seconds (Integer.MAX_VALUE nanoseconds)
See above, but timeTakenNanos should take a long or this will be broken for times over 5 seconds (Integer.MAX_VALUE nanoseconds)
I would suggest to use StandardCharsets.UTF_8 here.
I am not sure if this should be able to work on a Druid server since the constructor is only allowed to read a file.
I am not sure if this should be able to read the file without a custom IOException
getComponents() will be always not null.
You could re-use componentNames from the intent as well. My thinking was that getComponents() would be always not null because it would be null.
You could re-use componentNames from the intent as well. My thinking was that getComponents() would be always not null, and if so, just return null.
This code can be improved, with a single check of isCurrentConnections and do all you need inside there. With the current code you're checking this twice, in this lines and then shortly below, making it more confusing to read.
This code can be improved, with a single check of isCurrentConnections and do all you need inside there. With the current code you're checking this twice, in this lines and then shortly below, making it more confusing to read. Can you check this with a single check of all you need, in a single check of isCurrentLocation()
This code can be improved, with a single check of isCurrentConnections and do all you need inside there. With the current code you're checking this twice, in this lines and then shortly below, making it more confusing to read. Can you check this with a single check of all you need, in a single check of isCurrentLocation()?
I don't think you need the type parameter in new ArrayList<>. You could just use "new ArrayList<>". But I don't think it hurts. Sometimes Eclipse removes these unnecessary types for you.
I don't think you need the type parameter in new ArrayList<>. You could just use "itemMatcher". But I don't think it hurts. Sometimes Eclipse removes these unnecessary types for you.
I don't think you need the type parameter in new ArrayList<>. You could just use "itemMatcher". But I don't think it hurts it. Sometimes Eclipse removes these unnecessary types for you.
Minor, but shouldn't we also set session token on session before calling this method?
Minor, but shouldn't we also set session token on participant before saving it?
Minor, but shouldn't we also be closing session here?
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service failed? At least log a warning, which is what we expected
This would only happen if the service returned an invalid Sentiment type correct? Maybe skip the result, log a warning, and continue processing the other responses.
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service failed? Maybe skip these two?
There is a join method that accepts Collection that would make this code much simpler..
There is a join method that accepts Collection that would make this validation much simpler..
There is a join method you can use here
should we log this?
should we log in the exception?
should we log in the exception?
What does output means?
What does output continue from here?
What does output continue getting?
shouldn't this be 'index' as well?
shouldn't this be 'int'?
formatter
Any chance for a real progress monitor?
Any chance for a real progress monitor? I can't see it.
Any chance for a real progress monitor? That's not enough for all this.
If the connectionDetails is null, the config should be added to the constructor.
If the connectionDetails is null, and the constructor will throw NPE. Please check for null before trying to create the connection.
If the connectionDetails is null, and the constructor will throw NPE. Please check for null before trying to sync up the config.
Type safety: The spec is not correct here.
Same here with the following: return "CommandForMessage" interface.
Same here with the following: return "CommandForMessage" interface
This could be debug if we rename the attribute's to something like "org.module.email.com".
This could be debug if we rename the attribute's to something like "org.bean.config.Configuration".
In this class we don't need to build "config" prefix.
It feels like we might want to separate out the validations into two methods -- can we combine them into one? if (contentObj.get().trim().isPresent()) {... } else { //... }
It feels like we might want to separate out the validations into two methods -- can we combine them into one? if (contentObj.isRegistered()) {... } else { //... }
It feels like we should encapsulate this if a piece of code out of the transformer
You should be able to run the "if (!argument.get(xsltAclCallExpression.get()) && checkCallExpression(argumentByTree)) {" here.
You should be able to run the "if (!argument.get(xsltAclCallExpression.get()) && checkCallExpression(argumentByTree)) {" }
You should be able to run the "if (!argument.get(xsltAclCallExpression.get()) && checkCallExpression(argumentByTree)) {" }, since it is not an instance variable.
isn't it enough to create new ArrayList in addBootOrder()?
isn't it enough to create new ArrayList in addBootOrder method?
isn't it enough to create new ArrayList?
Ics should be ICS=false
ICS=false could be extracted to a product with ICS=false
ICS=false could be used
I think we can write this as a log.
I think we can write this as a method?
I think we can inline this?
Here we do not need an explicit == null check. Something like if( sourceType.isCollectionOrType( targetType, targetType)) { return; } else if (targetType.isCollectionOrTypeOrMapType( targetType, sourceType)) { return; } Otherwise we do not have an obvious dependency on the object.
Here we do not need an explicit == null check. Something like if( sourceType.isCollectionOrType( targetType, targetType)) { return; } else if (targetType.isCollectionOrTypeOrMapType( targetType, sourceType)) { return; } Otherwise we do not have an obvious usage of the object.
Here we do not need an explicit == null check. Something like if( sourceType.isCollectionOrType( targetType, targetType)) { return; } else if (targetType.isCollectionOrTypeOrMapType( targetType, targetType)) { return; } Otherwise we do not have an obvious dependency on the object.
I would not use System.out here, but instead use printf the other format.
I would not use System.out here, but better to use printf-like instead of +
I would not use System.out here
Probably should include tableToKeep.isPresent() in tableToKeep.
Related to this patch?
Probably should include the table name in the log message.
minor: rename IGNORE_csv to something else
minor: rename IGNORE_csv to FormatterBuilderGenerator.
minor: rename IGNORE_csv to FormatterBuilder and CR
lol +1. That is one thing which makes me think of a Runtime exception if the test fails. I'm wondering why we would not define the default port in the BROKER_PORT first.
lol +1. That is one thing which makes me think of a Runtime exception if the test fails. I'm wondering why we didn't define the default port as a constant.
Combine with the line above.
nit: No need to use String.format
nit: No need to use String.format here.
nit: line break between arguments
Is this previous test working? It is expected that we want to test the merge_insert_remove_user from the target table.
Is this previous test working? It is expected that we want to test the merge_insert_remove_user from the target directory.
Is this previous test expected? It is 0.
We shouldn't use here the setting, because currentDate -> now
We shouldn't use here the setting, but if it's set to false, then our own could be merged.
We shouldn't use here the setting, but if it's set to false, then our own could be resolved.
new HashSet<Resource>(fileURI) ) is useless.
Does this really need to be a public static method?
new HashSet<Resource>(fileURI) )
Why should nodes necessarily have an ssl enabled port?
Why are we catching all exceptions here? This should throw Exception, right?
Why are we catching all exceptions here?
s/pageOffset/fileLen + bufferOffset
Missing "page" -> "re"
s/pageOffset/fileLen
Add an index to the list or store the index.
replace with index += 2;
Why do we store the index here?
Can't say "not found".
Can't we have 3 separate configurations?
Can't we have 3 separate configuration values here?
static import JDBC.
static import?
static import
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
I remember some discussion for coming up with this logic of selecting cards randomly. Have we decided to remove that?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that? If so, I remember some discussion for coming up with this change to it.
nit: please put { } around if body.
nit: please put { } on the same line
nit: put @Nullable on the previous line
be careful here since there are no query parameters.
plz move this into the try/catch block
be careful here since there are no query parameters..
Why don't we use SingleMachines.getMachine().getName() in this case?
Why don't we use SingleMachineWrapper as it can?
Why don't we use SingleMachine here?
This might have been a bit shorter. Since we are using the config options, do we need to use the client config?
This might have been a bit shorter. Since we are using the config options, do we really need to warrant a config option to set the options at all?
This might have been a bit shorter. Since we are using the config options, do we really need to warrant a config option to set the config options at all?
Why do we need this setup here?
Why do we need this setup method?
Why do we need this setup in the test?
Should there be a constant instead of these values that could be used?
Should there be a constant instead of these values here?
Should the constants here be moved to constants instead of these properties?
what is the intent of this method?
what is the intent of this method? Can you please extract it to a method "findDir" or something?
what if you end up doing an untar method returning a file name "tar"?
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationTree.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationTree. I would just no declaration.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclaration, we can just no declaration.
Can this be made non-static?
Can this be made non-empty?
Can this be made non-null?
You are using ResourceBundle bundle while there is only a single call to retrieve. On the other hand, if there are multiple methods in the same class, we could skip the call to ResourceBundle bundleHelper.updateSsh(String key, String messageSource, Map<String, String> messageSource, String source source, String messageSource, String messageSource, Throwable exception);
You are using ResourceBundle bundle while there is only a single call to retrieve. On the other hand, if there are multiple methods in the same class, we could skip the logic for "debug".
You are using ResourceBundle bundle while there is only a single call to retrieve. On the other hand, if there are multiple methods in the same class, we could skip the call to ResourceBundle bundleHelper.updateSsh after calling toString() on each call.
It would be better to do something like java if (tags == null) { return.isEmpty(); }
It would be better to do something like java if (tags == null) { return Collections.unmodifiableMap(tags); }
It would be better to do something like java if (tags == null) { return true; } if (tags == null) { return.. }
I don't see a particular reason to cast here aMarkerAnnotationPresent.
I don't see why this cast is needed.
I don't see why this method has to be changed?
I think that the nodeUrl is the empty token in the updateNodeTokens call. In this case it will not be clear, we can remove this filter.
I think that the nodeUrl is a Set, in which case it will not be empty.
I think that the nodeUrl is the empty token
Any chance we can use this method in the ViewpointRegistryImpl?
Any chance this can be in effect?
affect this
Consider refactoring to getTaskIdList()
why clone the disk, instead of using the same object?
why clone the disk, instead of using the same list?
Was this change intentional?
Was this merged with the previous line?
Was this merged with the error message?
try catch BithumbException needed here
This does not match the try catch logic... catch anyBithumbException needed here
This try/catch block is redundant, you can simply do.map(BithumbException::getOrderId)
better to use the official way here true instead than "true"
better to use the official way here true instead than "false"
better to check that no changes have been applied
Believe it or not you actually need 4 assignments here, one for each of {lo,lt}.openStream() as well.
Should be a try-with-resources block.
Believe it or not you actually need 4 assignments here, one for every of {lo,lt}.openStream() as well.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.extract"
Could you change the name to oldProvidedObject?
Could you change the name to oldProvidedObjectHolder?
Should this be removed?
Yes this will cause a ClassCastException if the style is empty.
Yes this will cause a ClassCastException if the style is empty or not.
""
This should be error back.
This should be error
This should be error?
I wonder about we don't use primitive types here? It is expected to be the case like we do for types collection. 1. Check the types collection. 2. It is a clone of primitive types and not a primitive array.
I wonder about we update the type of the array to avoid creating a new array list and just replace the array with primitive type.
I wonder about we replace the typesArrayList with primitive type.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate().
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmListModel#cloneTemplate.
Same here, it would be better to use entry.getValue() instead of keySet() since it's more efficient.
Same here, it would be better to use entry.getValue() instead of keySet() since it's probably immutable.
Same here, it would be better to use entry.getValue() instead of getKey().topic()
Please move the above log entry to info level. In normal mode it's enough to say cache updated (and it took xxx second).
Please move the info log entry to info level. In normal mode it's enough to say cache updated (and it took xxx second).
Please move the above log entry to info level. In normal mode it took xxx second and put in debug mode.
Why not putting NONE and MANDATORY together?
You can extract result.setMessage and NONE_TYPE_FAILED to constants and define them as constants.
You can extract result.setMessage(Messages.ALREADY_CLASS) into a local variable and add not making result.
Same here. Also, there should be a space between, and {.
Same here. Also, avoid using SAMPLE_BOARD_PANEL?
Same here. Also, avoid using SAMPLE_BOARD_PANEL if the panelData is empty.
Why do we have this catch?
Why do we have the empty RepositoryException?
Why do we have this catch block?
In the case of this block, it seems strange that this could be the same as the ProducerRecord's messageId.marshal(messageId, moduleId)
Isn't this just a debug level?
Isn't this just braces?
Why not use model.getSelectedItemsChangedEvent()?
Why not use model.getSelectedItemsChangedEvent().addListener(this, model.getSelectionModel(), IProgressMonitor) instead?
Why not use model.getSelectedItemsChangedEvent().addListener((ViewType) model.getSelectedItemsChangedEvent())?
Why change this?
Why change these?
Why can't you replace this with a string literal?
Could we get the filePath at the end of the loop?
Could we get rid of this?
Could we get the filePath at the beginning of the loop?
The second condition is redundant - please remove it from the second part.
The second condition is redundant - please remove it from here as well
Should be done in one line: return failCanDoAction(domainFromIrs);
will we consider logging the content of the user user?
will we consider logging the content of the request if the user has not configured?
nit: remove all the null checks
are you streaming an empty list here?
are we streaming an empty list here?
streaming an empty list
still need to use getAllTargetAddresses instead of hardcoding :: in ExternalProject
still need to use getAllTargetAddresses instead of hardcoding :: in ExternalSystem.java
still need to use getProcessOutput() here
This also seems to be unused and you can remove it.
This also seems to be unused.
This also seems to be unused and you can remove it
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not?
Maybe checking the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not?
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not be on Windows?
Is that by default preferred super.makeLocation() or just re-use the getter?
Is that by default preferred super.makeLocation() or just re-use that one?
Is that by default preferred super.makeLocation() or just re-use the term?
You can check if list of results is empty and our property is in ArrayProperty
You can check if list of results is empty and our property is in ArrayPropertyProperty
You can check if element is in the list
I would prefer constant there.
If value is null, user will not have to set it. I would prefer constant there.
If value is null, user will not be able to set attribute value. I would prefer constant.
Thanks for the refactoring! It doesn't seem to be accurate.
Thanks for the refactoring! It doesn't look like a good change.
Thanks for the refactoring! It doesn't seem to be correct.
please add this logic to separate method
you can use this constant from this class
you can use this constant from this test
I believe ou can fix that in the sop method of the trigger
I believe ou can fix that in the sop method of this class.
possible NPE
How about putting the exception in the map?
How about making this default value as key?
How about making this default value as Integer and value?
I don't think it's appropriate to have a checkState method here, as we don't usually have one statement. One might restructure like: java if (rewrittenSource.isPresent()) { return rewrittenSource.getLookup(aggregation, idAllocator..LOCAL, source, inputsAsOutputs); }
I don't think it's appropriate to have a checkState method here, as we don't usually have one statement. One might restructure like: java if (rewrittenSource.isPresent()) { return rewrittenSource.isPresent(); }...
I don't think it's appropriate to have a checkState method here, as we don't usually have one statement.
bad name
implements initMocks(this)
Rename to setPrefSize(800,
This code is not needed as we already have it in the patch
This code is not needed as we already have it in the patchset 6 lines above, no?
This code is not needed as we already have it in the patchset 3.
can't we combine this and the above if into one loop?
can we combine this and the above for loop into one loop?
can't we combine this and the above for loop into one?
I would have a test for the 'null' and then use it.
I would change the text of the Accident.
I would have a test for the 'null' type.
I would have thought this could be implemented as a method instead of direct access.
I think this line can be removed.
I would have thought this could be implemented as a method instead of direct HashMap.
There would be no need to get a size of the array, right? Also, access to the array, you can use an array with size 4 times.
There would be no need to get a size of the array, right? Also, access to the array, will be slower. So, you'd need to create a set of size 4 times.
There would be no need to get a size of the list. Just call it directly.
@xupyprmv do we need this?
@xupyprmv we need to rename this one as mentioned above
@xupyprmv do we need this? I think it's better to explain selected.
> Why add a new object to the list?
> Why add a new object to the cache?
> Why add a new object?
I would think we could simplify this as return Bindings.get(0).getLinkBinding().filter(element ->!getLinkBinding(StandardField.FILE_NAME_BASE_URL)).map(s -> ((String)s.get(0).get()).findFirst().isPresent()).orElse(null);
I would think we could simplify this code by using.filter(getSelectedEntries()).map(entry -> stateManager.getSelectedEntries().get(0).get()).orElse(null)
I would think we could simplify this code by using.filter(getSelectedEntries()).map(entry -> stateManager.getSelectedEntries().get(0).get()).orElse(null);
This -1 smells a little. I wonder if a constant may speak more about the fact that it is a non value
This -1 smells a little. I wonder if a constant may speak more about the fact that it is an instance of the http status.
This -1 smells a little. I wonder if a constant may speak more about the fact that it is an instance of the event.
Please use assertEquals.
Please use assertEquals
assertNull
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap?
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections?
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap()?
Missing a break.
Missing a bracket here.
2 here.
Please revert this method.
Please revert this.
Please revert this method and leave this method public.
the right way to fix this is: 1. leave this code as is 2. override map() 3. in map() call supper.map() and than inject() the result of performCreate()
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "Type"); in this if()
the mapping should happen via Backend.getInstance().getDomainType()
It looks like this method should be synchronized and not a thread.
Shouldn't we have this method synchronized?
It looks like this method is not a thread safe.
This will always be true right now, you'd have to setAnalysis() only once. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
This will always be true right now, you'd have to setAnalysis to null. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
This will always be true right now, you'd have to setAnalysis to null. I'm not sure what this adds, it's one more call the module developer will have to make, you can't call this method anymore.
Just out of curiosity, why do we need this change?
suggestion IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
Just do.equals(path)
While it's kind of weird to see this as a list, I think it's worth caching the result as a Map
While it's kind of weird to have this return a String. I think it's better to change the signature of this method as well.
While it's kind of weird to have this return a String. I think it's better to change the signature to String.
remove
you should remove this line
you could remove this line
Has to be removed.
Same here. Needs a better error message to indicate what went wrong
Same here. Needs a better error message.
Let's extract the code out into a method. It will reduce duplication.
Shouldn't it be an error?
Let's extract the code out into a method.
should be possible to rename the provider to provider
should be possible to rename the provider to something more specific? I was thinking of the current change
should be possible to rename the field to provider
The 'from parameter' is not used <LINK_0>
What about moving the "if" statement to separate method?
What about moving the "if" statement to inside the if?
What is this logging intended? We want to be able to remove.
What is this configuration doing? We need to be able to remove these tests.
What is this configuration doing? We need to be able to remove these tables.
@ptirador why you can't use isAnonymous() here?
@ptirador why you can't use isAnonymous() instead of accessing it?
@ptirador why you can't use isAnonymous() instead of duplicating the loop?
Why use Promise<?>) to avoid the casting? This could be done in the Context constructor.
You could use timer.stop() instead of Timer.Context.timer(this) as it is re-used.
You could use timer.stop() instead of Timer.Context.timer(this) as it is thread-safe
can we just keep it.getHive().getMaster()?
can we just keep it.getHive().getMaster() and use ThreadLocalRandom instead of db?
how about introducing TableDesc inside ThreadLocalRandom?
Instead of a mock mock, we should use a logger for this test. This way we will have a info log in the test instead of a mock.
Instead of a mock mock, we should use a logger for this test. This way we will have a single test which is more reliable.
Instead of a mock mock, we should use a logger for this test. This way we will have a info log in the test instead of a logger
I'm wondering if we shouldn't use an ApplicationPropertyChangeListener to update the preference store.
I'm wondering if we shouldn't use an ApplicationPropertyChangeListener to update the preference store as an instance variable.
I think this should be an app.
This method is not used, but it is defined in a common interface. We should move this into a method in this class.
This method is not used, but it is used in a few other places. We should find a better name for this. What do you think?
This method is not used, but it is used in a few other places. We should find a better name for this.
Why not combine these two catch blocks into one?
Why not just use runStateMachine() here?
Why not combine these two catch clauses into one?
Nit: update this to getQuantity()
Nit: update variable name to 'itemDetailMode'
Nit: update this to make sure the user didn't specify the additional values.
I am not sure if this is the correct place, since we have the class name, let's put it in the constant.
I am not sure if this is the correct place, since we have the class name, let's put it in the constant
The previous code was correct.
How about this? java this.virtualHost = virtualHost == null? 0 : virtualHost; if (virtualHost == null) { return null; }
How about this? java this.virtualHost = virtualHost == null? 0 : virtualHost; return Objects.hash(virtualHost, identity);
How about this?
silent test is not working as expected. Are you are getting the test on those 2 tests? I get the test error but the test fails without your changes.
silent test is not working as expected. Are you are getting the test on those 2 tests? I think it should not be possible to avoid some test failures without test data conversion.
Minor inconsistency: Are you are changing those test parameters by not using.withQuery() here?
Minor nit: for (final PrefManager file : filesList) {
Minor: for (final PrefManager file : filesList) {
Minor: for (final File child : filesList) {
Remove it. It was used at some point but I forgot to remove it after code restructuring.
Remove it. It was moved at some point but I forgot to remove it after code restructuring.
Remove it. It was used at some point but I forgot to remove it before.
unused
unused variable
unused variable name
suggestion long ids = ids.iterator();
suggestion long ids = ids.iterator().next();
style nit: no braces around single line blocks
I think we should check that response.getStatusLine() >= 400 also.
I think we should check that response.getStatusLine() >= 400 first?
I think we're checking return status
This can never be null, since it never happens, but instead it should be an IllegalArgumentException.
This can never be null, since it can never be null
This can never be null, since it never happens, but, is it just an illegal state?
nit: No need to hyphenate unrecognized.
nit: ignore_ever_submit() -> <LINK_0>
nit: ignore_ever_submit vs sink/cache.<LINK_0>
Is there any reason why you didn't use forEach here?
Is there a reason why you didn't use forEach here?
Is there any reason why you can't use forEach here?
I don't think it's a good idea to throw an exception here, rather than silently ignore it. It's a symptom of a problem. In this case, the default is the current behavior. I think it is a good idea to throw an exception.
I don't think it's a good idea to throw an exception here, rather than silently ignore it. It's a bit surprised to catch it from a Visitor.
I don't think it's a good idea to throw an exception here, rather than silently ignore it. It's a symptom of a problem. In this case, the default is the current behavior. I think it is misleading to keep the WindowAgg operator (which is not the expected behavior).
It's time to create constant
Static import?
Static import
TB too?
String.format?
TB too.
nit: this empty line is not necessary
This doesn't belong here.
nit: this empty line is not needed
I think you should do this at the end of the test.
I think this should be higher than INFO.
I think you should do this at the end (line750)
This fails for me, this test is not correct. I can't understand the code, it's altering the file.
This fails for me, this test is not correct. I can't understand the code, fqn
This fails for me, I have not understood how you can use fqn
log.warn in default block is a good idea, but we should have case FAST_FORWARD_ONLY break without logging.
log.error in default block is a good idea, but we should have case FAST_FORWARD_ONLY break without logging.
log.error
Bad idea. Why not log the exception here - let exceptions bubble up and let the exception propagate.
Bad idea. Why not log the exception here - let exceptions bubble up and let the exception do anything.
Bad idea. Why not rethrow the exception in a generic helper like this?
nit: I think the extra space is unnecessary (and helps readability)
nit: I think the extra space is unnecessary (and a space after "
nit: I think the extra space is unnecessary
why relaceFirst instead of replace
why reliance on aar, why relaceFirst instead of replace
why reliance on aar, why relaceFirst instead of replace return null
![MAJOR](<LINK_1> 'Severity: MAJOR') Replace this expression with a single expression. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Replace this lambda with a local variable '![rule](<LINK_2>](<LINK_0>
If the project name is not bound, does it need to be lower case?
This Map<String, Object> is probably not needed, since you already have used BranchPropertyStrategy
This Map<String, String>, isn't it? It may be confusing to put them into private constants
add generics
setErrorMessage
I am not sure this cast is necessary.
I am not sure this cast is sufficient.
Same remark as in the other file.
Same remark as for the use of Optional
Same remark as in the use of Optional
Unused variable
We can use the mojo to make it work for me.
We can use the mojo to make it.
Same question as above, why do we need null check here?
Same question as above, why null?
Here we should check if the index is null before casting, right?
This logic seems twisted; making the code unreadable, we check if there there is an active-action on the container-id, or if there is an active-action on its active/standby counterparts, after that we check if there is a standby-container-manager present? Would it be possible to a. first check if a standby-container-manager is present? Or b. can hasActiveOrStandbyContainerHasActiveOr standbyContainer first?
Would info logging be useful here?
Would info logging be useful here? Or warn?
Can the stackFrame be null? If it is not used, we can just return false.
Can the stackFrame be null? If it is not used, we can just return true?
break?
returning feedback to users seems a good idea.
returning feedback to users seems a good practice.
returning feedback to users seems a good idea
The trade method is really long. Consider refactoring into multiple smaller and more concise methods.
The trade function is really long. Consider refactoring into multiple smaller and more concise methods.
The trade method is really long. Consider refactoring into multiple smaller and more concise methods..
nit: doJoin(otherStream, (no new line)
line length
nit: replace with the new line
Is the success here relevant to the retry? Can you remove it?
Is the success here relevant to the retry?
Is the success here necessary?
I don't think that trace message should be displayed as "some layer can be found".
I don't think that trace message should be displayed as "some layer can be closed."
I don't think that trace message should be printed.
suggestion byte[] component1Bytes = HashComponentsTestTable.encodeUnsignedVarLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER); assertThat(hashOfFirstTwoComponents.get().isEqualTo(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER)).asLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER) has a nice implementation.
suggestion byte[] component1Bytes = HashComponentsTestTable.encodeUnsignedVarLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER); assertThat(hashOfFirstTwoComponents.get().isEqualTo(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER)).asLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER).asLong(TEST_VALUE_INTEGER).asLong(TEST_VALUE_INTEGER).asLong(TEST_VALUE_INTEGER).toByteArray()
suggestion byte[] component1Bytes = HashComponentsTestTable.encodeUnsignedVarLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER, TEST_VALUE_INTEGER); assertThat(hashOfFirstTwoComponents.get().isEqualTo(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER)).asLong(TEST_VALUE_INTEGER, TEST_VALUE_INTEGER).toByteArray();
This may be better as an explicit check to the non-nullness of the vector. I think it's probably better to have something like: java Set<Sensitivity> vector = new HashSet<>(Arrays.asList("fooensitivities")); for (Sensitivity) { if (figitivities.keySet().contains(someInt)) {
This may be better as an explicit check to the tolerance in the trimming if one of the vector is not a fixed value.
This may be better as a Set.
this is a redundant cast
this is a redundant prefix as well.
what if template is null?
Just a question, why did you check this for every group? If you are in the same file you are in the middle of aImportObject being the same. Why not check the getLineNumber()!= null for every of the params?
Just a question, why did you check this for every group? If you are in the same file you are in the middle of aImportObject being the same. Why not check the getLineNumber()!= 1
Just a question, why did you separate this out? If the method is mandatory and only the import method name too.
Don't add this.insightCard.builder()
Don't need this.insightCard.builder()
Don't add a space.
I think this should still be LayoutInflater.from(context)
I think this should still be called from within the LayoutInflater.from(context) method.
I think this should still be called from within the LayoutInflater.from(context)
Do we want to set the classes that want the other preconditions?
Do we want to set the classes that want the other PR to support?
Do we want to set the classes that want the other PR?
Move end to same line
move end to same line
move message to same line
This is PK. You have to change myData to the reason why it was needed.
This is PK. You have to change myData to the reason why it was changed?
This is PK. You have to change myData to the reason why it was changed.
Is NodeList Iterable? I can't check at the moment, but if it is, then it's usually better to use a Set.
Is NodeList Iterable? I can't check at the moment.
Is NodeList Iterable?
You can have the lastPos as in the line above, to avoid null checking.
You can have the lastPos as in the line above, to avoid null checking (since you are checking the deprecate first)
You can have the lastPos as in the line above, to avoid null checking (and maybe you can use the same object).
you can simply use memKeys1.size()
you can simply use memKeys.size()
you can simply use memKeys2.size()
Actually, the exception is not.toString() instead of ehClient - I think you can do something similar with the cleanup
Actually, I think the whole purpose of the cleanup here is to use the same approach as the cleanupReceived.shutdown() and close() method. Can this be refactored to something like the following?
Actually, I think the whole purpose of the cleanup here is to use the same approach as the cleanupReceived.shutdown() and close() method. Can this be merged into the one above?
Could you extract this up to a method?
Could you extract this to a method?
extract this to a method?
Consider adding this in another commit, it's easier to note the (important) change/fix.
Can be static (and following ones).
Consider adding this in another commit, it's easier to note this in another commit.
Should we check for ePerson here? If ePerson is null, we should throw a more meaningful error here.
Should this be ePersonRest.isCanLogIn() || ePersonRest.isCanLogIn()?
Should we check for ePerson here instead? If ePerson is null, we should throw a more meaningful error here.
Are we sure that this works? At least it should be val.bai().
Are we sure that this works? At least it should be val.isIndex().
Do we need to make this change?
Why metric
Why metric[metric](<LINK_0> is deprecated. Since we are changing this code, consider using following instead.
Why metric[metric](<LINK_0> is deprecated?
e.logReady
e.getMessage()
this line is repeated in Agent.log.
Can we add a null check?
Can we add a repository.setProgressMonitor(revision) after this check?
Can we add a repository.setProgressMonitor(revision) after this?
add wait for shell
add timeout text
add try/catch block
If this is a debug message, you should trace the exception.
If this is a debug message, you should trace the info.
If this is a debug message please change
I think if this is the new notation you accept it as-is, fall back only if the regex is required.
I think that in this case the regex above are missing. Let's make this as a constant.
I think that in this case the regex above are missing.
I think this can be changed to: if (charset == null) { return; }
I think this should be written as a constant
We should probably handle the encoding being null
I don't think it's a good idea to keep the Prometheus stable so folks using grafanat almost always have their names. You need to use _uus_ to convert a _last_ row to string. So, I think it may be better to just use the P rows for _next_ loop and let the iterator check and if it works.
I don't think it's a good idea to keep the Prometheus stable so folks using grafanat almost always have their names. You need to use _uus_ to convert a _last_ row to string. So, I think it's better to just use the int result of tuples and let the code that calls _60-64 as it finds the first element.
I don't think it's a good idea to keep the Prometheus stable so folks using grafanat almost always have their names. You need to use _uus_ to convert a _last_ row to string. So, I think it's better to just use the int result of tuples and let the code that calls _60-64 as a mask
same question about skipping skipping space
same question about skipping space
same question as above
Let's remove leaseManager from class variable
Let's remove leaseManager from class.
Let's rename this to recordShardSyncer.
why is this needed? I don't see any tests using the same command in the file.
why is this required? I don't see any tests using the old logic in the directory.
why is this required? I don't see any tests using the old logic in the git history
Why not just use the org.junit.Assume.assumeTrue(API_KEY, INDEX_NAME)?
Why not just use the org.junit.Assume.assumeTrue(API_KEY_BYTES)?
Why not just use the org.junit.Assume.assumeTrue(API_KEY, INDEX_NAME);
Could we use an easier variable for this?
Could we use an easier variable for these assertions?
I would use a variable for the index.
typos: "*to*"
typos: sequence*
typos: "*to*"?
Typo: return!Boolean.TRUE.equals(config.getReadAllResources())
Should we check if apiOperation == null first?
Should we check if apiOperation is null first?
Check if uuid is empty
Check if uuid are empty
So this can be deleted?
I would think Ehcache<K, V> can be moved outside the while loop.
I would think Ehcache<K,V> refKeyType = get(cache); if(cache!= null) { throw new IllegalArgumentException("Ehcache<K,V>"); }
I would think Ehcache<K,V> refKeyType = get(cache); if(cache!= null) { throw new IllegalArgumentException("Ehcache<K, V>"); }
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup
innerPosInRowGroup -> innerPosInRowGroup posInRowGroup -> positionInRowGroup
Can you move the core adapter out of the property itself? This way we don't have one place to start it.
Can you move the core adapter out of the property itself? This way we don't have right-middle arguments.
Can you move the core adapter out of the property itself? This way we don't have one place to start the class.
Should this method be synchronized?
Can we rename this method to RealmCache?
Can we avoid the Realm instance here?
missing white space in front of parameter.
missing white space in front of line s.
missing semicolon.
If CredentialItem.Username isn't a password, it's just a String.
If CredentialItem.Username isn't a password, this would also be a password.
If CredentialItem.Username isn't a password, this would be a password.
I'd be more consistent with 0 or 1, but I don't see a valid 0 here.
I'd be more consistent with 0 or 1, but I don't know if I'm right.
I'd make a test that verifies that 0 <= getNumNoneroRegisters() == getMaxOverflowValue().
Won't this end up doing the same thing as before?
Won't this end up doing the same thing as above?
Won't this end up inserting a new row twice?
If you test that the query is null, this test will fail. (Never 400)
If we set null as default, we should throw an exception.
If we set null as default, we should throw an exception. I think this change is fine.
nit: remove curly braces around single line blocks
nit: remove curly brackets around single line blocks
This needs symmetry.
This won't be the same as in the other methods if it's not slim, as other methods in the same package are simplier.
This won't be the same as in the other methods if it's not slim, as surrounding code
This won't do anything? For readability, could you please define them in an if statement?
Once you remove the modelService from the modelService, please make sure you read it correctly.
Better to be rebased on <LINK_0>
Should be final
What does the above line mean?
What is the reason for adding this empty line?
What is the reason for adding this blank line?
This looks like we can remove the try/catch, since we already do this here [here](<LINK_0>
This looks like we can remove the try/catch, since we already do the same thing in ImportPhotoPdfDialogFragment#L59
This looks like we can remove the try/catch, since we already do the same thing in ImportPhotoPdfDialogFragment#L24listFiles
you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the "if", the main local variable is not useful
you should replace the test by (primeRefining!= null) and execute statements from the else block. Then always return primeRefining field after the "if", the main local variable is not useful
you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the "if" statement.
Shall we wrap the close() call in a try catch block to make it more readable?
Shall we wrap the close() call in a try/finally block to ensure the stream is closed?
The close() method of the factory class is a try/finally block, so you can do try/finally on the reader
"src.dir" is repeated twice
"src.dir" is repeated twice. Please extract to a constant
"src.dir" is used only here
I don't think this is correct. If you were to override this to work, I would expect it to be a no-op.
I don't think this is correct. If you were to override this to have different default Locale, you might have different definition groups. In that case, I would prefer to leave them out.
I don't think this is correct. If you were to override this to have different default Locale, you might have different default implementations for the message field and others, but not others.
Do we can make this a constructor, or can it be declared in the constructor?
Do we can make this a util method to reduce code duplication (in the if/else block)?
Do we can make this a util method to reduce code duplication (in the if/else statement)?
can you add logs?
can you put iterator.getJoinToInputOpName into a loop?
can you put iterator.getJoinToInputOpStream() call here?
why did you change to final here? should be outside of the scope of the patch.
why did you change to final here? should be outside of the scope of the patch..
why did you change to final here? it should be outside of the scope of the patch.
Use another signature: for (Stereotypes : controls)
Use another signature: for (Stereotypes :...) {
Use another variable for variable name.
You should use LabelInternationalizationUtils.getSetLabelCommand directly I think
You should use LabelInternationalizationUtils.getSetLabelCommand directly I believe
You should use LabelInternationalizationUtils.getSetCommand directly I think
This one is the same as the other one. Can we have a pre-defined message here?
This test is the same as the one above except for the file -- can we put a pre-defined message around it?
This test is the same as the one above except for the file -- can we put a header value?
Why it is changed to "system.max"?
Why it isn't important?
Why that?
log.info() and throw an exception
this method can be private
log.info() and provide another third parameter
What are the messages that are not FULL? Should we just remove the truncation point from the start and use the whole partition?
What are the messages that are not FULL? Should we just remove  truncation point from the start and use the whole partition?
What are the messages that are not FULL? Should we just remove voltcompiler?
What about PROJECTS_VOLUME_NAME?
What about PROJECTS_VOLUME_NAME in the enum?
Let's use Objects.equals()
why not using getClass().getSimpleName() instead of eTree?
why not using getClass().getSimpleName()?
why not just call getClass().toString() here and then remove the toString() below?
I'd make this even more clear by checking the content of the URL: <LINK_0>
I'd rather use a constant for "Url signature:" or a literal "url". This method can be used in several places
I'd rather use a constant for "Url signature:" or a literal "url". It's used many times in the code
Is it a "Resource not found" exception?
Is it a "Resource not found" exception? If so, we should log it.
Is it a "Resource not found" or an exception?
I thought we wanted to avoid the old semi-colon, but I remember that there's a reason we can do the same here?
I thought we wanted to avoid the old semi-colon, but I remember that's done on the bottom.
shouldn't this be an INFO?
Catching exceptions for badness of failure when file is hidden.
Catching exceptions for bad output
CheckForNull return
ddf
ddf?
ddf ".
check whether the key is in this.stateTypes or not? if (!this.stateTypes.containsKey(alias)) { throw new UnregisteredAliasException(alias, false); }
@yongpingchen What do you think about adding target type to responseBody? I think that using reflection is not good way in this situation.
check whether the key is in this.stateTypes or not? if (!this.stateTypes.containsKey(alias)) { throw new UnregisteredAliasException(Alias, false); }
Should we only assign the external ID if it changes?
Should we only assign the external ID if we're not going to the external ID?
Should we only assign the external ID if we're not null?
You can use LOC instead of the lambda.
Do we need this path?
You can use LOC
Why do we need this check?
Use same constant.
Use same constant for all places.
else throw FalconException(e)
else throw FalconException with no message.
else log()
if condition is not met, should there be a catch block for null?
if condition is not met, should there be a catch block?
if condition is not met, should there be a catch block for if statement?
Maybe it's better to check if isEmpty()?
Maybe it's better to check if trim()?
Why it's specific?
please replace with if (StringUtils.isNotEmpty(subjects)) {
please replace with if (StringUtils.isNotEmpty(subjects)) {... }
please use Map.of()
I think you want to warn the user as an error, where something went wrong: Users can't send google.realm as the second parameter
I think you want to warn the user as an error, where something went wrong: Users can't send google.realm as the second argument
I think you want to warn the user as a non-zero exit code.
Also use a constant.
Also use the constant here
Also use the constant here?
This one should be an warn.
This should be an warn.
This check should be done in the beginning of the method.
Remove system.out.
Remove system out.
removed
This evaluates to true: if you are not allowed > is they? Or if a newFitness is a default, what do you think?
Shouldn't this check for production is disabled in default configuration? If they are not, what about replacing this with a normalFitness name?
This evaluates to true: if you are not allowed > is they
I think this should be in the main method of this class because it's a converter?
I think this should be in the main method of this class because it's a copy of Contract
this empty method would be great.
Should this assert that.equals() is equal?
would it be better to assert the registration of the event in the "kr" instead?
would it be better to assert that the event is being propagated instead?
missing unit tests for this in HashJoinSegmentStorageAdapterTest
missing unit test for this in HashJoinSegmentStorageAdapterTest
missing unit tests for this in HashJoinSegmentStorageManagerTest
Is it the AutoCloseable way to handle this?
Is it the 'public', or can this be replaced with a logger?
Is it the 'public', or can this be used in any case?
typo in the variable.
Please use the double assignment to see if it is possible to change it with the double assignment.
Please use the double assignment operator to see if it is worth readability.
I don't think we need this.
I don't think we want to ship in here. I think you can just use UTC.
I don't think we want to ship in here. I think you need @NonNull
extract the client and lookup into a private method so that we can keep the code more readable
extract the client and lookup into a method so you can do it in one place
extract the client and lookup into a private method so that we can keep the code more readable.
"Shall we print the full path to the error message?
"Shall we change this to print standard message only
"Shall we print the full path to the JSON body"
same question
same question. The above uses monoError. Same thing.
same question and reason
how about using an IllegalArgumentException here instead? > "Thrown to indicate that a method has been passed an illegal or inappropriate argument." from [Oracle doc](<LINK_0>
how about using IllegalArgumentException here instead? > "Thrown to indicate that a method has been passed an illegal or inappropriate argument." from [Oracle doc](<LINK_0>
use IllegalArgumentException instead? > "Thrown to indicate that a method has been passed an illegal or inappropriate argument." from [Oracle doc](<LINK_0>
This is redundant, you already know that quotaStorage is not null
I don't understand this block - you're trying to update a quota only if the argument is not null (which is valid)
I don't understand this part - you're trying to update a quota storage domain, but the code is updating a storage domain, right?
This one too.
The name of the variable is too general.
This one too
FieldAware analyzer = boost == null?... :...
FieldAwareQuery should never be null, could it?
FieldAware analyzer = boost == null?... :... so that we don't accidentally handle the "default case" case.
Nit: Use the constant seekToEnd instead of using "latest".
Nit: Use the constant seekToEnd is more meaningful name.
Nit: "No custom setting defined for Kafka setting defined for Kafka setting"?
You can use this: ArrayList<ChangeData> results = new ArrayList<>();
Move this to front of the condition.
Move this to the previous line.
you will need to use state.getERO here as well.
please use state.equals("dimlevel")
you will need to use state.getERO here as well
Here we should have something like "catch (GENERIC_EXECUTE)" to avoid GENERIC_EXECUTE.
For the new line GENERIC_EXECUTE, the name is GENERIC_EXECUTE.
Here we should use GENERIC_EXECUTE.
Add.isEmpty()
Add.isEmpty() check
Add braces
Should be a switch.
should be a switch statement
Should be a warn.
This is redundant
This is unused
This is never called
if we return number >= numberOfDataPoints, then we can assume that the number is unique.
As per the project, if we return number at the end of dataPoint, we do the numberOfDataPoints to be null?
As per the project, if we return number at the end of dataPoint, we can reduce this final
One more thing, if you want to use a timeout here, you can use a timeout. This will create a new random amount of time.
One more thing, if you put the wait logic in a separate step (with a timeout) it can use a timeout.
One more thing, if you put the wait logic in a separate step (with a timeout) you can use a timeout. This is then a timeout.
I would also add instanceof here.
I would also add instanceof here, to avoid ClassCastException.
I would have used ExecutionException#getCause() to fix the problem.
You can just check that the array is not empty so you don't need to include the return value.
You can just check that the return value is not null at the end
You can just use Arrays.asList()
I'd use createQuery() and addQuery() to get the id.
Please use the version of getEntities that takes some time. I'd recommend taking taking a extQuery and select the single element from there.
Please use the version of getEntities that takes some time. I'd recommend taking taking a extant code as a parameter.
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and SysMLResource.QUDV_LIBRARY_PATH
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and.appendFragment.getTransactionalEditingDomain() to remove the.appendFragment("QUDV_LIBRARY_PATH")
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and.appendFragment.getTransactionalEditingDomain() to make sure there is no model.
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME) + "etc/hadoop" here. Also the next line.
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME) + "/etc/hadoop" here. Also the next line.
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME) + "etc/hadoop" here instead?
I think we can use the data column directly here, and avoid the double query parameter.
I think, this returns null to avoid the else
final
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())"?
Minor thing: please use "something <operator> null" convention.
I suggest to improve the debug message in this case, and mention in it also the returned value.
Why is the cast needed?
Why is angle a true?
Why is this function called setData()?
Should you check for null if you can avoid the other openIntentChooser()!= null?
Should you check for null if you can avoid the other openIntentChooser() ever catch?
Should be done in openIntentChooser()!= null
Maybe refactor this into a method since it is the same code on both the annotation / method and the setter is the same.
Maybe refactor this into a method since it is the same code on both the annotation /.
Maybe it's worth to use.equals() on the bean names
The logic here is different than what's used here. Can this be extracted into a separate method?
This logic is used twice, so I would extract it a bitstream format.
This logic is used twice, can this be factored out?
Is this line really needed?
Is there a reason for not doing it here?
Is there a reason for not doing this here?
I believe we can also get rid of the variable: java final String engine = scriptInterpreter.eval("include([\"Engine.getProperty("name")).replace("projectId", engineContainer.getParameter().getString("prefix", engineContainer.getName())).callMember("source", engine);
I believe we can also get rid of the variable: java final String engine = scriptInterpreter.eval("include([\"Engine.getProperty("source")).before(1, );
I believe we can also get rid of the variable: java final String engine = scriptInterpreter.eval("include([\"Engine.getProperty("name")).replace("projectId", engineContainer.getParameter().getString("prefix", engineContainer.getName())).callMember(tr("String")).replace("projectId", engineContainer.getLocalizedMessage());
You can use Collections.singletonList(tmp) here, to avoid copying the array twice.
You can use Collections.singletonList(tmp) here but it's not the same thing.
You can use Collections.singletonList(tmp) here.
_really_ not necessary to call separate method.
NP:?
NP:
Since the snapshot returned appendCheckpoint is a global snapshot that shouldn't regress, shouldn't we just select the first checkpoints snapshot and make sure the checkpoints snapshot is not written?
Since the snapshot returned appendCheckpoint is a global snapshot that shouldn't regress, shouldn't we just select the first checkpoints snapshot and make sure the checkpoints snapshot is not written to stable before the snapshot is processed.
Since the snapshot returned _expected, it is always greater than the first checkpoints we want to go, don't we?
Put the { on the next line; on the next line.
Put the { on a assignment level.
Redundant braces.
I'm thinking we can refactor it to something like this: if (!cmdEntity.isCallbackNotified()) { return false; }..
I'm thinking we can refactor it to something like this: if (!cmdEntity.isCallbackNotified) { return false; }..
I'm thinking that we should also check that the status is FAILED for all the command status.
Exception may be null
Exception may be logged once and better.
Exception may be logged as well
consider giving this boolean a name that describes its /meaining/, not what it is - e.g., doesStatusProhibitConnect
consider giving this boolean a name that describes its /meaining/, not what this is - e.g., doesStatusProhibitConnect
consider giving this boolean a name that describes its /meaining/, not what it means.
With warning: the URLTarget can be null, you don't have to call equals on it.
With warning: the URLTarget can be null, so that it gets initialized.
This gets deleted in the main thread.
I don't think "I" is the wrong way here... if the entry size is Long.MAX_VALUE, can you add "I" ("I don't expect bytes to be accepted")? So why don't you use %1s to avoid error?
I don't think "I" is the wrong way here... if the entry size is Long.MAX_VALUE, can you confirm? Or was this a bug in the end of the original exception?
"IxffffffffL"
The names (__id, __cas) should come from TemplateUtils, although they seem to be hard-coded in several other places.
The names (__id, __cas) should come from __id, as they seem to be hard-coded in several other places.
The names (__id, __cas) should come from __id, as they are generally not meant to be used anywhere.
This check should only be done if the trace is enabled.
This check should only be done if the trace is enabled, the style that is not enabled.
This check should only be done if the trace element is null.
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {} supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {} to supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
I know this is only part of this change, but could you please revert this change?
I know this is only part of this change, but could you please revert this change.
I know this is only part of the scope of this PR, but could you please fix this typo?
Missing space after if
Info or port port?
Space after if
Please be consistent with set operations in the other tests.
Please be consistent with set operations on this test.
Please be consistent with the other operations on this test.
Exception should be used instead.
Exception should be thrown from this method, not thrown from constructor.
Exception should be thrown from this method, not thrown from this method.
Should you be logging a warning instead?
This should be a DEBUG log, not an error
This should be treated the same
pls consider extracting it to a constant (i.e. DEFAULT_SSH_PORT)
pls consider extracting it to a constant (i.e. DEFAULT_HTTPS_PORT)
plz move the code to a new method, similar to what is done in NewHostModel
Won't this create a garbage collection for every request?
Won't this create a new list everytime? since we are not going to get a whole list.
Won't this create a garbage collection for every request? Use [getContent()](<LINK_0>
consider making this a smaller number of tests: a maximum number of times, in a particular case, we can't overwrite the same value.
consider using a StringBuilder instead of a string builder?
consider using a StringBuilder instead of a StringBuilder?
just curious, what would happen if pageBuilder.reset() return false? And the PageBuilder will always be reset to the page.
just curious, what would happen if pageBuilder.reset() return false? And the PageBuilder is always reset to the page.
just curious, what would happen if pageBuilder.reset() return false?
can we use a constant for this?
Suggestion: extract a method that does the right thing to do, and use it here and below.
Why it has to be changed?
You should use the ModelResponse.Status.FAILED in this case.
You shouldn't return the ModelResponse directly.
You should return the ModelResponse directly.
Why do we need this change? It seems to me that getChild() is only invoked if there is no evaluator hasn't been initialized.
Why do we need this change?
It seems wrong to move all the requireNonNull checks into the constructor.
please reformat code
please reformat this line
please reformat code a little bit.
Same here with not needing the local variable.
Same here with not needing the local var.
Same here with not needing the local variables.
Why have you update the errorMap to errorMap?
Are you sure that errorMap is working?
Why have you update the errorMap to have errorField?
Formatting
Could be final
Needs a if
Even though it's here, doesn't there be a test for this? (applies to other pieces of code too)
And a small thing here. I'd rather use Arrays.asList(a, b) here instead of the old one here.
Even though it's here, doesn't there be a test for this? (applies to other pieces of tests)
Can we use a foreach loop here?
Can you fix this to use IntelliJ?
Can you fix this to use IntelliJ
Doesn't feel right to put this feature in this class--the consumer isn't really a bound variable. Moreover, putting the consumer behavior in this class relies on BindFactory being the default binder if there is no annotation on the method parameter--but this can be overridden through SqlObjects.setDefaultParameterCustomizerFactory().
Doesn't feel right to put this feature in this class--the consumer isn't really a bound variable. Moreover, putting the bound property on the method name seems a bit odd to me.
Doesn't this need to be if there are no annotation names associated with the method parameter type?
If we're using {2} token but not LOCAL_ID, I don't think we should be using {2}
If this method is invoked multiple times, it should be local variable outside of the try block.
If this method is invoked multiple times, it should be local variable outside of the if statement.
Maybe we could factor out the parts which create JavaFX nodes here? A bit more SLAP lines.
Maybe we could factor out the parts which create JavaFX nodes here? A bit more SLAP invocations are very similar.
Maybe we could factor out the parts which create JavaFX nodes here? A bit more SLAP invocations is very long for many components and be very similar.
@dmzaytsev let's replace this with a try-with-resources
@dmzaytsev let's replace this with a try
@dmzaytsev let's replace this string with a static final
why we drop the channel if we aren't reading, can we also write to the log
why we drop the channel if we are in the same call?
why this?
another spot where it's done, didn't see how this works.
this should probably be a!isAppVisible
another spot where it's okay.
please remove
Please remove the else, it is always false when we are sure there is no disk
Please remove the else, it is always true and not false.
Do we need to check if currentGroupDwrf is null?
If none of the methods have a method, we could get away with the stripe.isPresent()?
If none of the methods have a method, we could get away with the direct dereference. This can be united.
It looks like this message is kind of confusing.
It seems you are logging here.
It seems you are logging this message anywhere, right?
Can you just add the timezone variable in the constructor instead of this.window?
Can you just add the timezone variable in the constructor or make it a constant?
Can you make this a constant?
the return of the result is hard to follow code wise. either return once, or return once result is retrieved.
the return is hard to follow code wise. either return once, or return once result is retrieved.
the return value of the result is hard to follow code wise. either return once, or return once result is retrieved.
null == adapter
null!= adapter
null == adapter?
builder.validateBuilder() is used in both ctors.
builder.validateBuilder() is used in three places.
builder.setDefaultAttribute() is used in DefaultUtils as well.
Please change **@NoAccrschema@** for **@C_AcctSchema_ID@ @NotFound@**
Please change **@NoAcctschema@** for **@C_AcctSchema_ID@ @NotFound@**
Please change **@NoAcctSchema_ID@ @NotFound@**
![MINOR](<LINK_0> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "now". [![rule](<LINK_1>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "now". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_0> 'Severity: MINOR') Missing curly brace. [![rule](<LINK_1>](<LINK_2>
Nitpick, use braces
Nit-pick, use braces
Nit pick: use braces
Please use a logger instead of e.printStackTrace()
Please use a logger instead of e.printStackTrace
Please use a logger to log the exception.
nit: Request.class.cast(RestResponse.class)
nit: space after if
[minor] I think you can create a method delete() from this class. It will simplify this.
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one we expect.
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one you expect.
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one we expect. I think it would require to catch the exception and make sure to fail one line before the other.
since we are before can do action, you should also check that getVdsGroup() is not null
since we are before can do action, we should also check that getVdsGroup() is not null
since we are before can do action, you should also check that getVdsGroup()!= null
Can be replaced with lambda
Can you rename this variable to txOperation or similar?
Can you rename this variable to be more specific?
fEntries.clear()
assertNotNull(fEntries)
entry.getValue()
I would suggest a static import of Optional.empty() to simplify the code
I would suggest a static import of Optional.ofNullable, in this case you just get the full stack trace. It's not a big deal, but if you feel like you can also do a little cleaner.
I would suggest a static import of Optional.ofNullable, in this case you just get the full stack trace. It's not a big deal, but if you feel like you can also do a null check.
What if we add a link with a timeout like "maxTimedOut(true)"?
issue: what am I missing here is the reason for the deprecation warning?
What if we add a link with a timeout like "maxTimedOut(true, message, timeout)"?
Why.equals and not.equals? Also if their API considers to the {
Why.equals and not..? Also if their API considers to the {
Why.equals and not..? Also if their API considers to the { }
Please create an abstract method that will make the code easier to read.
Please create an abstract method that will make the code more readable.
Please create an abstract method that will make the code more readable
You should return directly: java if (pageSupplier.isBlocked().isDone()) { return (currentPage!= null) &&!currentPage.isFinished(); }
You should return directly: java if (pageSupplier.isFinished()) { return (currentPage!= null) &&!currentPage.isFinished(); } else { return (currentPage!= null); }
You should return directly: java if (pageSupplier.isFinished()) { return (currentPage!= null) &&!currentPage.isFinished(); }
Why do you need it here? Shouldn't it be (! (!))?
Why do you need it here? Shouldn't it be (! (!)))?
Why do you need it here? Shouldn't it be MappingTypeMapping class?
does this need to be null?
can you explain this change?
does this need to be null checked?
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the sub-classes will not be fired by the user. I don't think it's necessary for it.
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the sub-classes might deserve its own the trace. I don't think it's necessary to have it.
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the sub-classes might deserve its own the experiment. I don't think it's necessary to have the same trace as the event.
List<Partition> up = new ArrayList<>();
I think this can be changed to return up.stream().map(Replica::isUp).collect(Collectors.toList());
I think this can be changed to return up.stream().filter(Replica::isUp).map(Partition::isUp)
Use the same format as above.
Should IdentityClient follow the same builder pattern as the other one?
Use the same format as above. :)
Please use StringBuilder
Please use StringBuilder here instead of StringBuffer.
Please use StringBuilder instead of StringBuffer.
Please handle InterruptedException and set interrupted flag. Why after interrupt you wait up to 10 seconds below?
Please handle InterruptedException and set interrupted flag. Why after interrupt you wait up to 10ms?
Please handle InterruptedException and set interrupted flag. Why after interrupt you wait up to 10 minutes?
Let's usesnmp.getEntities().containsOnly(Restrictions.ilike("snmp.ilike")) instead of assuming that we are all the same.
Let's usesnmp.getEntities().containsOnly(Restrictions.ilike("snmp.ilike")) instead of assuming that we are all the same
Let's usesnmp.getEntities().containsOnly(Restrictions.ilike("snmp.ilike")) for the same reasons.
this should be Timber.e
this should be Timber.v
this should be Timber
These 2 lines are duplicated. It should be factored out into a method.
These two lines are duplicated. It should be factored out into a method.
These 2 lines are duplicated. It seems like it should be factored out into a method.
Can we change this to be like if (rexNode instanceof RexNode &&!meta.equals(rexNode)) {?
Can we change this to be like if (rexNode instanceof RexNode &&!isDistinct()) { return null }
Can we move this case to LxNode?
Why not continue to LOG.info here?
Why not continue to LOG.info here? Is it necessary?
Why not continue here?
Unconventional space.
Un-used => missed
Un-nest : > /plus/..
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, I suggest to stick to it as far as possible.
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though)
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways.
Is this supposed to be the same Date instance? If midnight happens in between the creation of the two instances, this test will fail.
Shouldn't this be the same Date instance as above? If midnight happens in between the creation of the two instances, this test will fail.
Is this ever the same as above? If midnight happens in between the creation of the two instances, this test will fail.
can you please use new HashSet<>(new HashSet<>(2) here?
how about using an existing constant for the*/-collection?
can you please use new HashSet<>(new HashSet<>());?
Could you extract new ValueListTypeTestTypeTestTypeTestType.create() to a separate method?
creation of assertionTypeTestType is duplicated in both testTransformXDRResponseToCheckPolicy and testTransformXDRResponseToCheckPolicy.
creation of assertionTypeTestType is duplicated in both testTransformXDRResponseToCheckPolicy and testTransformXDRResponseToCheckPolicy
I don't think this is right. Seems like the assert below ensures that the output is 'null'.
I'm not sure that's a good idea. ATM is to assert that the list is empty rather than the first one.
I'm not sure that's a good idea. ATM is to assert that the list exists and the input is built at the end.
Is this a duplicate of the same algorithm? It's a bit weird to make a difference between the two branches.
Is this a duplicate of the same algorithm? It's a bit convoluted, maybe we could rename the file to something else?
Is this a duplicate of the same algorithm? It's a bit convoluted.
Needs to consider that deleteVolumeIdsFromMounts should use the same name for all of the instances
Needs to consider that deleteVolumeIdsFromMounts should use the same name for all of them.
oh, this is strange. In my opinion, it is not so nice to wrap all instances of the lock in a block. If you want to make sure that the lock is not done, you should wrap this lock in a block.
I think you meant LOGGER.debug("found {}", rfa);?
I think you meant LOGGER.debug("found appender {}?", ");
Does this still need to be null?
We should not be able to use dbClient.qualityGateDto().selectQualityGate() instead of dbClient.getQualityGateId().
We should not be able to use dbClient.qualityGateDto().selectQualityGate() instead.
We should not be able to use dbClient.qualityGateDto().selectQualityGate() instead of dbClient.getQualityGateId()
can you please include the example a test with a descriptive message? for example "Homo_sapiens_assemblyreturn_list"
can you please include the example a test with a function that returns the first element of the list?
can you please include the example a test with a descriptive message?
If we are using this for the main query API, we could do it on the next line.
If we are using this code for creating large objects this time we could have cache API for pre-kafka-common.utils.
If we are using this code for creating large objects this time we could have cache API for creating and removing unnecessary code.
Minor: Any reason for the two calls to UserPrivate and UserPrivate classes?
Minor: Any reason for the two methods use UserPrivate and UserPrivate classes?
Minor: Any reason for this to be public?
Can we call indexFileChannel here as well?
Can we check if index file already open and flush a new file?
Can we check if index file already open and flush a new one?
I'm not sure this is correct. What happens if the batched is empty?
I'm not sure this is correct. What happens if the batched is empty? It seems like this will throw an exception.
I'm not sure this is correct. Why are we doing something similar to the existing 'query' query? It seems to me that the metric could be empty, no?
This looks like it's reformatting.
refactor to get rid of this?
refactor?
don't need to check Refreshed here?
don't need to check Refreshing and/or refresh?
don't need to check Refreshing and/or refresh logic
what is this good for?
What is this good for?
what is the good for?
ignoreTagChanges needs to be in a try/finally since the tag add or removal can trigger a lot of code.
Remove blank line.
remove?
nit: this is a bit confusing, since I'm not sure if this is going to work on, but maybe I'd prefer to keep it as is and just compare with the expected value.
nit: this is a bit confusing, since I'm not sure if this is going to work on, but maybe I'd prefer to keep it as is and just compare with the expected metrics?
nit: this is a bit confusing, since it's not really a test.
This test was testing the bloom_filter_test expression macro function rather than a generic bloom filter sql test, so I think the test for the bloom filter should be ignored.
This test was testing the bloom_filter_test expression macro function rather than a generic bloom filter sql test, so I think the query should be ignored.
The same, use java.util.Base64Function.
Here we have NULLIF(dim1 'a') = NULL being translated as, - Old, when NullHandling.sqlCompatible() is NullHandling.sqlCompatible(), the same as dim2 = 'a' OR dim2 IS NULL.
Here we have NULLIF(dim1 'a') = NULL being translated as, - Old, when NullHandling.sqlCompatible() is NullHandling.sqlCompatible()
Here we have NULL_CA
need to be changed here
Should be accessed in a test to avoid this.
need to be changed to *this*
This needs a charset.
This should use a constant.
This should be a 500 long?
rename to 'no'
rename to type
rename to 'no' or readable
You can just use metaData.getObject(i) here.
You can just use metaData.getObject(i) here instead.
I would just use "i" here
shouldn't need the throws declaration?
shouldn't need the throws declaration for the exception
shouldn't need the throws declaration?
if you replace all "the content content" with "aces" with "MyFileACE" and you'll get a ACE that can be closed, and the content of a file will be unknot closed.
if you replace all "the content content" with "aces" with "MyFileACE" and you'll get a ACE that can be closed, and the content of a file will be closed.
if you replace all "the content content" with "aces" with "MyFileACE" and you'll be a bit more clear
Use two-argument constructor
Use two-argument constructor.
Multiple constructor.
Can you make this more specific?
Can you make this more final?
Can you make this final?
No, this method should not throw interrupted exceptions.
No, this method should not throw interrupted exceptions. We should not throw interrupted exceptions.
No, this method should not throw interrupted exceptions. You should not throw interrupted exceptions.
Why this needs to be a static?
Why this needs to be a named constant?
Why this needs to be a core method?
s/HTTP_BIND
s/HTTP_GROUP/HTTP_BIND
s/HTTP_GROUP/HTTP_ADMIN/class/g.
nit: extra space.
extra space.
nit: extra spaces.
redundant else
redundant else clause
redundant elses
Suggestion: should it be > 0
Suggestion: should it be > 0?
please remove
Could you print the full path
Why is this changed to static?
Could you correct the formatting of the arguments here?
I don't think there's a SamzaException in the logs. Please add a more specific message.
I don't think you'll need to log the exception as well.
I don't think there's a SamzaException in the logs. Please change to SamzaException.
I do not think that logging?
I do not think that logging here is useful, but I would prefer to not log it.
I do not think that logging here is useful
Please don't make a difference between the two IF statements: if (orphaned) { return Branch.decorate(project, Branch); }
Please don't make a difference between the two IF statements: if (!_factory.getBranch(project)) { return Branch.decorate(project, _factory); } Just my personal preference.
Please don't make a difference between the two IF statements: if (!_factory.getBranch(project)) { return Branch.decorate(project, Branch); }
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeHelper should be using one specific date pattern that ES is always using. I guess the TimeHelper should be using one specific date pattern.
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeHelper uses the TimeHelper as a method that ES is always using one specific date pattern.
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeHelper should be using one specific date pattern that ES is always using.
Over time.
Over time I see what this is doing.
Over time, I think.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace them with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again?
Please replace: if (log.isDebugEnabled()) { log.info("Power-Management Host '{}' failed: {}", getParameters().getFENCE_OPERATION_OPERATION_FAILED); log.info("Power-Management: {} of host '{}' failed: {}", getParameters().getFENCE_OPERATION_FAILED);
Please replace: if (log.isDebugEnabled()) { log.info("msg: {} failed.{}", result.getVds().getStatus(), result.getVds().getStatus());
Please replace: if (log.isDebugEnabled()) { log.info("Power-Management Host '{}' failed: {}", getParameters().getFENCE_OPERATION_OPERATION_FAILED); log.info("Power-Management: {} of host '{}' failed", getParameters().getVdsName(), result.getVdsName());
too: no need to do this. We have to check for null before using it.
no need to do this. We have to check for null before using it.
too: no need to do this. We have to check for null before calling get.
I think it would be better to check if action is not null
I think it would be better to check if date is equal to the created date
I think it would be better to check if date is equal to the passed date
Can you please add a patient. since the patient is not a concept in the same order as the patient? You will get the id to the patient without taking any patient.
Can you please add a patient. since the patient is not a concept in the same order as the patient? You will get the id to the patient without any id
Can you please add a patient. since the patient is not a concept in the same order as the patient? Otherwise if the patient is imported you will get a patient without any id field.
Cleanup?
t is not used.
t is not used anywhere else
The event description and doc should be eventInfo.containsKey(eventInfo)
Wouldn't it be better to iterate over the values of the map and add it to the map?
The event description and doc should be eventSpec mapping as well.
This is the same as isClient.
Remove the unused variable.
Can be simplified to return ((F) zf).get();
This code block is repeated three times, maybe we can extract a private method?
This code block is repeated three times, maybe we can extract a helper method?
This code block is repeated three times, maybe we can extract a method? Or a method?
The above two lines can be merged into one.
move this to the declaration of the Group and use that method
BORDER
I don't think this block is needed because you already set the value for ex in the catch block
I don't think this block is needed because you already set the value for this error message
I don't think this block is needed because you already set the value for success in the catch block
Strings.isNull(token)
Strings.isNullOrEmtpty
String.format?
you are only setting flag to false, but still unnecessary loop operations are executed
you are only setting flag to false, but still you are re-reucking with it
you are only setting flag to false, but still you are re-reusing flag :)
iteration = 1 should go after the logging.
iteration = 1 seems pretty dangerous.
final
Could we rename the variable to numberOfInitialCheckpoints?
Could we rename the variable to numberOfInitialCheckpoints or something better?
Could we rename the variable to numberOfInitialCheckpoints? It looks like we might use this variable
It also doesn't allow me to change the destination branch if my change is in DRAFT state. I think for draft changes we should definitely allow to change the destination branch.
It also doesn't allow me to change the destination branch if my change is in DRAFT state, but if the change is in DRAFT state, I think for draft changes we should definitely allow to change the destination branch.
It also doesn't allow me to change the destination branch if my change is in DRAFT state. I think for draft changes we should definitely allow to change the destination branch (for example, maybe change the destination branch on a change).
You can use a lambda here.
You can use a lambda here
You can use a lambda here?
Missing check for null, so the workbench will never return null.
Missing check for null, so the workbench will never return null
Missing check for null.
I think this could be done in the constructor.
I think this could be replaced with: java Set<String> scopes = new ArrayList<>()
I think this could be replaced with Set.of()
I think I'd rather put the filter only if memoryAlreadyBeingRevoked is false.
I think I'd rather get rid of this filter.
I think I'd rather put the filter only if memoryAlreadyBeingRevoked is true.
why did this need to be public?
this is not necessary, I think.
this is not necessary, I think it exposes the API
Something weird has to do with this. The Exception is not thrown.
It seems like 'Invalid tableSource' is undefined or 'DataSource' in the error message. Do you think that it makes sense to describe what we are doing here?
It is undefined or field name in the exception message.
Please, define a constant and refer to it in this class, instead of duplicating it here.
Please, define a constant and refer to it in this class, as well.
Please define a constant for this.
Use.toString()
Use.isEmpty()
Use createDefault()
It was args, not argb, that was supposed to be checked for null.
It was args, not argb, that was supposed to be checked for null. We should be checked for null.
It is args, not argb, that was supposed to be checked for null.
import static
import static?
unnecessary line
No need to use an else statement since the if block ends with a return.
No need to use else statement since the if block ends with a return statement.
No need to wrap this line?
This should be replaced with checkState(Strings.isNullOrEmpty(docId))
This should also be checkState(Strings.isNullOrEmpty(docId))
This should be a constant as it is used twice.
Do we need to check key!= null
Do we need to check key here?
Do the key!= null
call setDBConnection(stm, false, 0, 0, 1);
why not ret here?
why not setDBConnection(stm, p, 1, 1);
There is no need to try/catch here, just let it be getAndSet(null).
There is no need to try/catch here - just let the IOException bubble up and all the other should be Exception
There is no need to try/catch here - just let the IOException bubble up and rethrow it with the other PR
the aforementioned "never return null" rule would be good for all the null checks
the aforementioned "never return null" rule would be good for all the null checks.
the aforementioned "never return null" rule would be good
Please add the Identifier of Contentlet, for troubleshooting purposes.
Please add the Identifier of the Contentlet for troubleshooting purposes.
Please add a space after the comma
This won't always be true. Why are you calling the same method twice?
Typo: missing the parameter type.
This won't always be true. Is that OK?
See above (it could be added via SessionManager.getRepresentationConsideredAsDangling(representationpresentation);
See above (it could be added via if (it.hasNext())
See above (it could be added via if (it.hasNext()) {
I think this would be clearer if the switch statement was inverted?
I think this would be clearer if the switch was uncollector. Or just 'limit'?
I think this would be clearer if the switch statement would be inverted?
redundant parentheses
public methods should be protected.
line too long
You should probably use the join() method and store the result in a local variable.
You should probably use the join method and store the result of cacheTopology.
You should probably use the join() method and you get the result from the join()
It would be better to use an actual chromosome, that is not used.
It would be better to use an enum instead of a string for the first letter.
It would be better to use an enum instead of a string for the actual number.
Seems to use BuiltinSort.of(new KLabelConstantSort.DEFAULT_SET_ITEM_LABEL), same as above.
should be a  sort, not a K.
Seems to use BuiltinSort.of(new KLabelConstantSort()) instead of joining around a string
Executor.collection()?
final Map< fixture, DEFAULT HEAP Type)
final
this is similar to Compressor
this is similar to Decryptor
here is similar to Compressor
new lines
new String("makak") is useless
new String() is useless
This value can be changed to be constants.
Should we read a file?
This value should be constants.
catch throwable?
catch IOE?
catch?
A small thing, but maybe we can store destPid in a variable to avoid the duplicate calls
A small thing, but maybe we can store destPid as a variable to avoid the duplicate calls
A small thing, but maybe we can store destPid to a variable and then have a variable depositObject.
The justification itself could have a single quote under it...
The justification itself could be null for these Calibrtion classes.
The justification itself could be null for these Calibrtion classes
Same here - unresolved merge conflict.
Same here - unresolved merge conflict
Same question - does this fix any conflict?
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change the assertTrue to assertFalse.
Do you expect an answer to this? If you don't, then you need to change this error message. If you don't, then you need to change the assertTrue to assertFalse.
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change this error message.
Why do you catch ValidationOptions.ERROR here? There's no Morphia-specific code that's being tested. But see above for assertions that the test method is throwing an exception.
Why do you catch ValidationOptions.class? There's no Morphia-specific code that's being tested. But do we really need to assert that the underlying database works?
Why do you catch ValidationOptions.class? There's no Morphia-specific code that's being tested. But do we really need to assert that the underlying database was actually inserted?
You cannot use try-with-resources statement here.
You cannot use try-with-resourcesresources here.
You cannot use try-with-resources statement.
Avoid duplicate method calls in this method
Avoid duplicate code
Avoid duplicate method calls in this method.
let's verify the result
let's verify the error
let's verify the whole function
can it be Type.BOOLEAN_VALUES?
can it be sth like "Type.BOOLEAN,..."?
can it be sth like "Type.BOOLEAN,...".equals(type) (without second s)
.trim() is not null. I'd prefer to have a variable to hold the expression.
.trim() is not required here
Please use camel case.
This method has an external annotation now. But it does not matter.
This method has an external annotation now. But it's not cached in the XML file. What's the reasoning behind this change?
This method has an external annotation now.
The String returned by getSchema is not parsed, this will throw an NPE if the JSON is not parsed. The String returned by getSchema will return null, but I'm not sure it's returned from Phoenix instead.
The String returned by getSchema is not parsed, this will throw an NPE if the JSON is not parsed. The String returned by getSchema will return null.
The String returned by getSchema is not parsed, this will throw an NPE if the JSON is not parsed. The String returned by getSchema will return null, but I'm not sure it's returned by the PR.
PGProperty is not part of this change.
PGProperty is not part of this patch.
PG should be a password (PGProperty)
This method could be improved. SshKeyStoreException and SshKeyStoreException should be used in this class. You can use the same block of code here.
This method could be improved. SshKeyStoreException and SshKeyStoreException should be used in this class.
This method could be improved. SshKeyStoreException and SshKeyStoreException should be used instead.
I believe that iteration(null) is more readable.
I believe that iteration(null) is not the same as ValueHolder.
I believe that iteration(null) is not the same as sync.
Shouldn't this be made private?
Shouldn't this be made protected?
Shouldn't this be removed?
UpdateProgress is a private method of UpdateProgress#okResponse, so this code doesn't need to get called from the start method.
UpdateProgress is a private method of UpdateProgress#save, so this code doesn't need to get called twice.
Needs to be in the try block as well
also add assertion for existence and key?
also add baseAccount here?
also add assertion for existence and key
"we got the 'name' to be the 'name' file
"should" this exception be removed?
"we got the 'name' to a different package" element as we did before that
This can be simplified to: if (( maxLength == null) || (maxLength == null) { return; }
This can be simplified to: if (( maxLength == null) || (maxLength == null)) { return; }
Rather than returning a null value, can we just set a non-null maxLength?
Should this be done in the if statement below?
Should the if statement be moved to the if statement below?
Should this be an else if?
Why not using the repository name here?
Why not just set it in the finally block?
Why not just set it in the constructor?
See getAllLifesCache in the next commit
See getAllLifesCache
See getAllLifesCache()
Can't we do another map call in between, which casts the payload to object? So, something like this: this.reportWrongEventMessage(expectedEvents);
Can't we do another map call in between, which casts the payload to object? So, something like this: this.reportWrongEventMessage(expectedEvents).stream().filter(finder -> stream.reportWrongEventMessage(expectedEvents), actualEventMessage);
Can't we do another map call in between, which casts the payload to object? So, something like this: this.reportWrongEventMessage(expectedEvents).stream().map(payload -> (Object) payload).reportWrongEventMessage(expectedEventMessage);
Change to: this.operatorContext = spillerFactory.newPagesIndexFactory();
Change to: requireNonNull(operatorContext, "operatorContext is null");
Change to: this.operatorContext = spillerFactory.newPagesIndexFactory( spillerFactory, spillerFactory.newPagesIndexFactory());
I think this introduces a bug. The password should be fixed by adding a host to the message that says the new behavior should be considered.
I think this introduces a bug. The password should be fixed by adding a host to the message that says the new behavior should be fixed.
I think this introduces a bug. The password should be fixed by adding a host to the message that says the new behavior should be kept in the message.
Could you add the checkAccess(application) method to the application?
Could you add the checkAccess(application) method as well?
Could you add the checkAccess(application) method to the applicationStore as well?
You should compare event.getId() instead.
You should use assertJis instead.
same suggestion as above
I think it isn't worth to replace the loop with the following: if (private.contains("binaries")) {... }
I think it isn't worth to replace the loop with the following: LOGGER.error("Failed to change Allure permissions", e); Logger.error("Failed to change Allure", e);
I think it isn't worth to replace the loop with the following: LOGGER.error("allure", e); throw new RestAction( "Failed to change Allure permissions", e);
The original author of the EncounterService.getEncounterDate() is used instead of EncounterType.getEncounterDate(). You should use it here as well.
The original author of the EncounterService.getEncounterDate() is used instead of EncounterType.getEncounterDate(). You should use EncounterType.of
The original author of the EncounterService.getEncounterDate() is used instead of EncounterType.getEncounterDate()
wrapping the exception with a try-with-resources block.
If we decide to close the InputStream, we should probably throw a RuntimeException and log the exception.
If we decide to close the InputStream, we should probably throw a RuntimeException here too.
.stream().map(variable -> memberDescriptions.get().equals(task.get())).collect(Collectors.toList());
I'm a bit confused by this part. It is only used in unit test. So, not sure if we can just inline it.
.stream().map(variable -> memberDescriptions.get().equals(task.get())).collect(Collectors.toList())
Do we need to make sure thatuserId == null is set? (Can we have a test for this as well?)
Do we need to make sure thatuserId == null is passed? (Same for other methods as well)
If we want to make sure that userId is null, maybe we should move that condition out of the if (userId!= null) branch?
Can you handle this as a case where the import static org.apache.commons.lang3.ArrayUtils has a helper for getting the base64 string.
Can you handle this as a case where the import static org.apache.commons.lang3.ArrayUtils has a helper for getting the base64 string?
Can you close this in a finally block?
A lot of this logic seems to be reused for each handler. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each place, instead we need it to be reused for each handler. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each layer. Is there a way we can generify it to save some code duplication?
Why we need this additional check?
Why we need this map?
The event type is now unrelated to this change.
I think this should be 'commit'.
I believe this should be 'commit'.
I believe this should be 'commit', not 'timestamp.
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
Should this result in all active connections being discarded? During runtime this may happen if the config is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
Should this result in all active connections being null? And if so, you should throw an exception on the server side.
suggestion throw new StreamsException("Could not find topic: " + topic);
suggestion throw new StreamsException("Could not find topic: " + topicSerializer);
suggestion throw new StreamsException("Could not find topic (with topic " + topicSerializer + ": " + topic) + "' for task " + topicSerializer.
throw new Exception("One can be used with a non-public user", e);
throw new Exception("One can be used.", e);
throw new Exception("One can be null") instead?
Minor suggestion to use putMember here to improve readability
Minor suggestion to use putMember here to improve readability.
Minor optimization: re-put?
Why do you log the exception?
Why do we log the exception?
Why do we log the exception here?
The return type for.getTrace() could be overriden in CtfKernelEvent too.
The return type for.getTrace() could be overriden in CtfKernelEvent too. Also, do we need to change CtfKernelEvent too?
The return type for.getTrace() could be overriden in CtfKernelEvent too. I think.
why not just return new TestMethodName()? Given the same TestHelper classesmycompany:
why not just return new TestMethodName()? Given the same TestHelper classesmycompany: <LINK_0>
why not just return new TestMethodName()? Given the same TestHelper classes are one after the tests.
Could you add a method to evict just for this purpose?
Could you add a method to evict just for this call as well?
15 seconds seems a bit long.
Code style: Always surround blocks with curly braces, even one liners.
Let's please avoid throwing IllegalArgumentException when a resource is not found.
Code style: Always surround blocks with curly braces.
Hard code is ok. This is the default behaviour (i.e. do not default)
Hard code is ok. This is the default behaviour (i.e. the bytes from bytes).
Minor: move the last check after the buffer size is set.
Does that need to be logged out?
Does that need to be public?
Does variable need to be logged here?
Please remove the extra stuff here.
Why not remove the extra stuff here?
Why the extra stuff here?
I believe getHeader() can be replaced with anyMatch()
Do people really need to specify initialCapacity?
I believe getHeader() can return null if header is not present.
Should this be listening_port instead of hardcoding? Also I think it's better to just read the URL
Should this be listening_port instead of hardcoding?
Should this be listening_port instead?
rename to colorModel
rename to operation
rename to operationEnabled
@vmaletta does this mean that the contentDto is not null
@vmaletta does this mean that the contentDto is not null?
@vmaletta add isContentDto
Assert.warn(<LINK_0>
Assert.isNotNull() is redundant here
Assert.isNotNull() is unnecessary here
Same here, I think we don't need it. And if message is null, then we can just do:.withMessage("cannot send a message")
Same here, I think we don't need it. And if message is null, then we can avoid it.
Same here, I think we don't need it. And if message is null, then we can avoid NPE and if not send it to message.
(optional) I would test this for empty()
static import?
static import
if you use dlmsHelperService.validateAndCheck you reuse some validation logic that covers the checks in the next llines
if you use dlmsHelperService.getAndCheck you reuse some validation logic that covers the checks in the next llines
Change log level to debug
String.valueOf(boolean)
String[] = Boolean.toString();
String[]?
I think it is more efficient to just iterate over the values than to remove the other ones and iterate on them.
I think it is more efficient to just choose the other map than the original one and then iterate over the map.
I think it is more efficient to just iterate over the values than to remove the other ones and iterate over the map.
I think you need to move the _heuristic = TwoPhaseOutcome.FINISH_OK; to the same place as the local JTA one.
I think you need to move the _heuristic = TwoPhaseOutcome.FINISH_OK; to the same place as this.
I think you need a new line after the if.
not sure if this should be part of the test. it would be better to have a frame or something in the test if it fails.
not sure if this should be part of the test..
not sure if this would work for two windows..
Can be checked for equality.
should be checked for equality.
Can be checked for Disks
StyleFactory.newChild. Should be moved to the previous line.
get the reference at some point in the code. Should be: new FileEdgeStyleFactory<>
StyleFactory.newChild.
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "if the @r value is greater than or equal to zero" for one showing. So can you check for <=0 instead?
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "if the @r value is greater than or equal to zero" for one showing. So can you check for <LINK_0>
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "if the @r value is greater than or equal to zero" for one showing. So can you check for <LINK_0> here?
Why do we need to have this.?
Why do we need to have this.buffer here?
Why do you need this?
Cast to (int) containerViewWidth and call this method directly (int)
Cast to int instead?
Cast to int?
Shouldn't this line with the next line?
Consider flipping this and other inlines.
Why use the third parameter?
It is a bit strange to catch exceptions that are thrown by the handler.getBridge() method only. That is, if the bridgeHandler is null, it will silently fail.
It is a bit strange to catch NPE here if bridgeHandler is null.
It is a bit strange to catch exceptions that are thrown by the handler.getBridge() method only. That is, if the bridgeHandler is null it will silently fail.
Hey @idelcano What about to move it to the constructor, does it make sense to keep the getter as static?
Hey @idelcano What about to move it to the constructor, does it make sense to keep the getter as private static?
Magic number
I don't think we need to explicitly set the package name (see org.sonar.java.util.HashTest for example)
I don't think we need to explicitly set the package name (as we do in integration tests).
I don't think we need to explicitly check that the issue is not empty.
.map(v -> KnoxRoles).filter(s ->!groupNames.isEmpty()).anyMatch(c -> mTemplateProcessor.getGroupName().equals(i))).collect(Collectors.toSet());
.map(v -> v.getComponent(i)).filter(Optional::isPresent) is equivalent to.map(Map.Entry::getKey)
.map(s -> stack.getComponent(i)).anyMatch(c -> mTemplateProcessor.getGroupName());
This should be removed.
This should be changed to!response.getResponseHeader().
This should be removed to match the following line.
why are we registering metricDtoList after we re-register it?
why are we registering metricDtoList after we re-register this?
why are we registering new metrics?
Simpler proposal: java getNbExpr(plan.getNamedExpr(), referenceNames[i])
Simpler proposal: java String referenceNames = context.getExpr();
Simpler to base base: Use indexNames.lengthd index instead of length check.
Lines 56-71 shouldn't be indented while they are inside if statement.
Lines 56-71 shouldn't be indented.
Lines 56-71 shouldn't be indented while they are inside the if.
Use stateEncoding instead of stateEncoding here?
What if stateEncoding is null?
Use stateEncoding to keep the order consistent with equals.
If you rename the variable to res
If you rename the variable to stillVersion, then the variable name is misleading. In fact, the variable name is actually misleading. It's not clear what it is.
If you rename the variable to stillVersion, then the variable name is misleading. In fact, the variable name is actually misleading. It's not clear enough.
So you are setting this twice and throwing a different exception? Not sure if this is enough severe exception.
So you are setting this twice and to a separate method? This looks very similar to the previous one.
Not sure, but maybe we should log these errors?
No need to break here, it's already handled by the Codacy.
No need to break here, it's already handled by the Codacy
Maybe improve the formatting here? If so, we should improve the compiler a bit the abstraction :)
NIT issues again.. and it makes sense to use Logger?
NIT issues again..?
NIT issues again.. it would be better to use an word lambda here.
It would be cleaner to use an assertEquals
It would be better to use an anonymous class here
It would be cleaner to use an anonymous class here
Can you put a method for this that takes a SymbolAllocator? There is no need to put it back again in the diff.
Can you put a method for this that takes a SymbolAllocator? There is no need to put it back in the diff.
Can you put a method for this? This looks almost identical to the one above.
You can probably do this in onLoadMore
You can do this in onLoadMore
You can probably do this in a single statement: adapter.setProgressVisible(true);
Should this be a copy?
Should this be a constant?
Should this be a RuntimeException?
Please add fail(); after the addColumn() call.
Why do you need to change the asserts?
Please add fail(); after the addColumn() call
We could bail out earlier by changing the check further up to java Lg. Util.isSimlarId(sim))?
We could bail out earlier by changing the check further up to java Lg. Util.isSimlarId(sim);
We could bail out earlier by changing the check further up to java Lg. Util.isSimlarId(sim)) || (a == b)? 0 : (btw)
it does not make sense to have both last repl id and chkpt for partition...table??
we need to load last repl id and do not add partition id
all these are load right?
"Sorting by total price doesn't work"
"Sorting by total"
undefined
Should be added to the field in the constructor.
Should be added before we set this.myRepository = null;
Should be added before we set this.myRepository = null; and then we don't need it.
What? Is there any reason for this if statement?
What? Is there any reason for this if statement?
What? Is there any reason for this?
producer is no longer used
producer == null?
producer == null?... : below
You can use assertTrue and assertFalse here.
You can use assertTrue and assertFalse, like you did for the other tests
You can use assertTrue and assertFalse because it can be for the other tests
username.trim().clear() may be null here, and if username is null, username can be null, username and password.
username.trim().clear() can be used to remove username and password
username.equals("password").
This is how the thread pool should be written using a synchronized block: while (true) { synchronized (e.g., TimeUnit.SECONDS); } }
This is how the thread pool should be written using a single thread (e.g., fs.exists()).
This is how the code handles this.
Should we print in info level?
Suggest we don't create a new stream for json.
Minor: we can use ISE and StandardCharsets.UTF_8 for debugging
What about applying the same sort of circuitingDirection that does not change due to a check?
What about applying the same sort of circuitingDirection that does not change the same thing?
What about using "final" instead of null?
this block can be final
this is wrong with my previous semantic
this is wrong with my previous version
Move clientDetails.acquireReadLockOnKeyPCacheDate(keyp) out of the try block
Move clientDetails.acquireReadLockOnKeyPCacheDateByIdP to the end of the method?
Move clientDetails.acquireReadLockOnKeyPCacheDateByIdP to the end of the method? If not, we should remove clientDetails.acquireReadLockOnKeyPCache.
you could use: String.join(collect(Collectors.joining("&")));
you could use: String.join(String s)?
use: String.join(":", 2);
Should be a static constant
Should be a static field.
Should be a static
please dont touch old formats, whatever they do let them do that
please don't touch old formats - much easier to read.
please dont remove explicit initialization
nit: I think we usually prefer to keep the builder as a short variable name.
I think we need to keep the builder as a short term.
nit: I think we usually prefer to keep the builder as a short variable.
I'm really not sure that projectString should be externalized. If so, we probably need a way to set the project name.
I'm talking about this change or it should probably live with an error condition.
I'm really not sure that projectString should be externalized. If so, we probably need a way to set the project name
i think this Exception is never thrown?
i think this helps you remove the null checks?
i think this still needs to be null?
Should be removed.
Should be removed to match our log output.
Should be removed to match our Java unit tests
Can we use static import?
Can we do this without relying on the client side?
Can we get rid of the'session'?
add curly braces here too
ditto, use ==
add final
Can you bring this into a method and call it from here?
Can you bring this into an implementation that will be handled by the Operator annotation?
Can you bring this into an implementation that will be handled by the operator bar?
Can we make this a method in GrillService to get the conf?
Can we make this a method in GrillRepository instead?
Can we make this a FAILED constant?
It might be better to throw an exception in the catch block.
It might be better to throw an exception.
It might be better to throw an exception instead of just logging it.
This will throw an NPE if there is no match. I'd have suggested the following code: if (resultMatches.isNotEmpty(result)) { return false; }
This will throw an NPE if there is no match. I'd have suggested this before.
if there is no match, should we have completeExceptionally here?
We should have a kReturn. That way we'll have an error-prone approach in core code.
We should have a try/catch here with a checked exceptions based on the interface. This way we'll have a crash when entering the app.
We should have a try/catch here with a checked exceptions based on the interface. This way we'll have a crash.
Do we need a printout here?
This should be info
This should be a logger.info
Is it necessary?
Is it necessary to store this as a constant?
Isn't it better to call it parseImage?
This log message is no longer accurate. Why remove it?
You should remove this log line.
This log message is no longer accurate.
I'm wondering why do we need to check for the case that the namespace has been updated correctly?
I'm wondering if we can do this check once.
I'm wondering why do we need to check for the case that the namespace has been changed here and in the future.
Can be simplified: this.contents = false;
Why not just replace this with the later one?
Can be removed
why not just use a StringBuilder here?
this is a super minor typo, but it seems like it should be "wanted".
this is a super minor typo, but it seems like it should be "return range"
The row width is not aligned with the latest columns in the editor. I am sure this has no effect here.
The row width is not aligned with the latest columns in the editor. I am sure this has not been tested?
The row width is not aligned with the latest columns, which is what was the issue was?
this isn't used
this is already a String
this can be package private
Should we put SystemConfig.getPanelInfo() into a separate method? I don't think we really need to keep this method.
Should we put SystemConfig.getPanelInfo() into a separate method? I don't think we really need to keep it.
Should we put SystemConfig.getPanelInfo() into a separate method? I don't have a great reason why we are not using System.out here.
Change to StringBuilder or append method instead.
Change to Log instead of printStackTrace.
Change to StringBuilder instead.
Souldn't this be static?
Should this sort order be configurable?
Souldn't this sort order be reversed?
better to use the official way here true instead than "true"
better is to use the official way here true instead than "true"
better to use the official way here true instead than "true" here
This should be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
This should now be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
This should ideally be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
This code will spam the logs. Can you convert this back to a static method and call tryLock() on the lockRoot?
This code will spam the logs. Can you convert this back to a static method and call  sleep on a new thread?
This code will spam the logs. Can you convert this back to a static method and call  sleep on its own.
If we end up keeping same list in getGIDs, we could getGIDs before going through these. What do you think?
If we end up keeping same list in getGIDs, we could getGIDs before going through GIDs.
If we end up keeping same list in getGIDs, we could get multiple entries for a given list.
You can use a local variable to avoid the containsKey() call.
You can use a local variable to avoid the containsKey() call
You can use a local variable for the defaultUUID
rename to member
rename to members
rename to package
Use ImmutableList.Builder
Use ImmutableList.builder()?
Use ImmutableList.Builder()?
Would be nice to have a constant for the NEW_TASK as well
Would be nice to use a constant here
sort!
Also verify this is never null, and if it's null, you can just flip this around and the next line.
Also verify this is never called, and if it's null, you can just flip this around and the next line.
Also verify that the default value is correct?
Shouldn't this be an enum?
Shouldn't this be an Enum?
Shouldn't this be an else?
Is this worth asserting that it is not null?
Is this right? We are not using the same exception when the test fails.
Is this worth a catch for the test?
Can we add more context here about which consumer this is? Looks like you can log this instead of KafkaSystemEnvelope?
Can we add more context here about which consumer this is? Looks like you can log this instead of KafkaSystemEnvelope.
Can we add more context here about which consumer this is? Looks like you can log this instead of KafkaSystemReader?
Would be worth checking that filepathObj.getStringValue() returns a String, not null.
Would be worth checking that filepathObj.getStringValue() returns a String, not a String?
Would be worth checking that getStringValue() returns a String, not an Object?
use a constant for "code"
we should use a constant for "code"
use a URLBuilder
Typo: "cannot be"
Typo : "cannot be"
Typo : "cannot be null"
I think we can use a class called CaptureProcessConfig. It will be more appropriate to create a factory class in the given class.
I think we can use a class called CaptureProcessConfig. From other side it is not possible to use the same class to define the scheduler.
I think we can use a class called CaptureProcessConfig. From other side it is not possible to define and initialize this class which is 'threads'.
Why favoriteGroups.isEmpty()??
Why favoriteGroups.isEmpty()?
Why favoriteGroups.isEmpty()?? Run formatter
Should this be BATCH_NOT_FOUND?
Should this have a single return? Because if it is a single blob (the batchOperationInfo is a collection) then we know the value is an empty string.
Should this have a single return? Because if it is a single blob (the batchOperationInfo is a batch) it throws an exception.
Let's move this line above the for loop. Otherwise it will not be necessary if the previous value is null.
Let's move this block to the beginning of the method, just so the end of the method is more readable
Let's move this line above the for loop. Otherwise it will not be necessary if the for loop is done above it.
I would suggest extracting this if statement to a method in LSWorkerHeartbeatStageTest.
I would suggest extracting this if statement to a method in LSWorkerHeartbeatRunnable() that just takes the state and returns as arguments.
I'm not sure if we want to use this as an argument, but I would suggest to move the call to LSWorkerHeartbeatStageTest.
Nice fix!
Nice way to keep this code.
Nice way to do this...
Instead of displaying an error message and thus annoying the user, the app could convert the error message to something like "Add an error message" or something like that.
Instead of displaying an error message and thus annoying the user, the app could convert the error message to lower case automatically.
Instead of displaying an error message and thus annoying the user, the app could convert the error message to something like "Add an error message"
entry
entry.set(null)
entry is the proper name.
conflicted?
conflicted
conflict event?
Any reason that we want to hide the loading dismisses the dialog if we are on the dismissing it?
Any reason why we want to hide the loading dismisses the dialog if we are on the dismissing it?
Any reason why we want to hide the loading dismissing some of the controls to conditional checking on the dismissing is shown?
Why do we need to split into multiple lines?
I think we should log this to WARN in default.
I think we should log this to WARN in production only.
Looks wrong. But getRaw(column) == 0 is always true. Why not just return 0 if left and right == null?
Looks wrong. But getRaw(column) == 0 is always true. Why not just return 0 if left == null?
Looks wrong. But getRaw(column) == Row.getRaw(column) == 0 is always true. Why not make it private?
I'm not sure this should be a 400 string instead of a 500.
This should be a KafkaConsumer instance.
This should be a pipeline.
Do we really need to check? Can't we always pass stopGlusterServices=true and leave the logic to really stop ore not to MaintenanceVdsCommand/HostUpgradeCallback
Why do we need to check that gluster service status here? Shouldn't this be checked in MaintenanceVdsCommand or HostMaintenanceCallback itself?
Do we really need to check that gluster service status here? Shouldn't this be checked in MaintenanceVdsCommand or HostMaintenanceCallback itself?
suggestion if (target.isMap() &&!target.isSimpleType()) { MappingConstructor.put(entry.getKey(), targetEntity.getTypeInformation().getValue()); } } else if (targetTypeInformation.isTypeInformation()) { throw new IllegalArgumentException("Unknown property type: " + value.getValue()); }
suggestion if (target.isSerialization() && map.contains(entry.getKey())) {
suggestion if (target.isMap() &&!target.isSimpleType()) { MappingConstructor.put(entry.getKey(), targetEntity.getTypeInformation().getValue()); } } else if (targetTypeInformation.isTypeInformation()) { throw new IllegalArgumentException("Unknown property type: " + targetEntity.getTypeInformation().isSerialization(source.getValue(), targetEntity.getTypeInformation().isTypeInformation()); } } boolean ignoreMissingType = Boolean.TRUE; for (Map.Entry<String, Object> targetType : map.entrySet()) { if (target.getTypeInformation().isMap(target)) { return value.put(entry.getKey(), targetEntity.getTypeInformation().isMap(targetClass.getValue(), targetEntity.getTypeInformation().isMap(targetClass.getValue())); } } return false;
why not use  literalType.value() instead of literalType.
why not use.map( literalType -> literalType.equals(2));
why not use  literalType.values() > 1?
Please don't swallow exceptions.
Assert.fail() call is missing.
Assert.fail() the first thing is swallowed.
Is this method really needed?
Is this method really meant to be used?
Is this method really meant to be public?
That's a leftover from my previous PR, so I think this test is missing a failure. The test becomes more verbose and easier to read.
That's a leftover from my previous PR :)
Java 8 has a missing semicolon.
this can be removed as well
this can be removed
this can be removed as well :)
Not necessary with with this, but is there a chance that project.getIProjectToIdConverter() could return null?
Not necessary with with this, but is there a chance that project.getIProjectToIdConverter() can return null?
Not necessary with with this, but is there a chance that project.getIProjectToIdConverter() could be null?
Optional.ofNullable(offset1)
Optional.ofNullable(offset2) which is unnecessary.
Optional.empty()
"L" should be "l".equals(mAssetName)
"null" should be "null"
"null" should be "U".equals(mAssetName)
Can you clarify this?
Can you camelcase for variable names?
Can you camel-case?
Perhaps you could do something like: smi.enableIsolation(fs, colfs.enableIsolation());
Perhaps you could do something like: smi.enableIsolation()
Do you think there is a reason not to do the following?
Something minor: You could use ConfigValues.class.getSimpleName() instead of hard-coded class name.
Something minor: You could use ArrayList<VdcOption> result = new ArrayList<>(); for (VdcOptionDAO callback : list) { result.add(option); } }
Something minor: You could use ArrayList<VdcOption> result = new ArrayList<>(); for (VdcOptionDAO callback : list) { result.add(option_name); }
Not sure we need to also check the count here?
Not sure we need to remove this. If the contract for vsCount is a little bigger, there might be some sort of difference.
Not sure we need to remove this.
Defensive copy
This should be in a flow that checks if unspilledLookupSourceProvider is null, not in the next check
This should be in a flow that checks if unspilledLookupSourceProvider is null, not in the close method
I would prefer to add a {} for single quotation marks as it is done with path formatting
I would prefer to add a {} for single quotation marks as it is done with existing configuration
I would prefer to add a {} for single quotation marks as it is done with normal path.
nit: IllegalStateException -> IllegalArgumentException/VerifyException?
nit: you could use ImmutableList.empty()
Use toImmutableList
shouldn't azureLeaderElector.start() always return false at this point?
shouldn't azureLeaderElector.start() always return true at this point?
shouldn't azureLeaderElector.tryBecomeLeader() always return false at initialization?
nit: better to use parameterized logging instead of string concatenation.
nit: better to use parameterized logging LOG.info("message: {}", limit, begin);
nit: better to use parameterized logging
This is not consistent with the value of the method.
This is not consistent with the value of the field.
This is not consistent with the value of meterToJsonObject method.
Can you add the string to favAppsList();
Can you add the string to favAppsList?
Can you add the string to favAppsList
If you touch block, this line is unnecessary.
If you touch this method, this should be replaced with return block.getRetainedSizeInBytes() <= compactBlocks.values().length;
If you touch this method, this should be new code.
Do we want to do log.debug(...) here?
Do we want to do anything and log.debug?
Do we want to do anything if we don't want to log the exception?
I believe you can use the CompositeSiteBackupResponse here? if (trace) { sendAndFinish(); }
I believe you can use the CompositeSiteBackupResponse here? if (trace) { sendAndFinishOne(); }
I believe you can use the CompositeSiteBackupResponse here? :P
I think here should be "9"
I think here should be "64k"
I think here should be "64kSize"
should this be disposed in finally block?
should this be disposed when no longer called?
could you use Promises.supplyAsync
Can we make this method final and use it in the other constructor instead of hardcoding this one?
The renames to map is fine.
Can we make this map more specific and use Radix here.
This line does absolutely nothing
This line should be moved inside the if statement below
This line should be moved above the if statement.
There is already a method for this so you don't need to use that class.
There is already a method for this, so use that instead of the for loop here.
There is a method for this that would be better than have it be.
Need to put this back - cannot change the API
Need to put this back - cannot change this API
Need to put this back - cannot change it
Could just make a private static final?
Could just make a separate data processor instead and register that one.
Could just make a separate data processor instead.
You should add a warning log also here
You should add a warning log also here for ERROR.
You should add a warning log also here,
downloadsMenuItem would b a better name.
downloadsMenuItem would b a better name. If we use a dialog, then we should show the dialog.
downloadsMenuItem would b a better name. Should we show the dialog?
if possible, please check that row.getIfPresent() is not null
if Column metric is < 0 then, should we check that row.getIfPresent() is not null?
if Column metric is < 0 then, should we check that there's a selector that needs to be cached?
rather than hardcode the string, can use class name
Can use the class name
Can use string literal
@mcivantos-tribalyte I'd like to setBlock(otherState) here as well. Shouldn't that be a problem?
@mcivantos-tribalyte I'd like to setBlock position here too
@mcivantos-tribalyte I'd like to setBlock(otherState) here as well.
it would be better to use getForceLedgerHandle() to access the ledger id, this is a separate method.
it would be better to use getForceLedgerResponse() to access the ledger id, this is a separate method.
it would be better to use getForceLedgerHandle() to access the ledger id, this is a method.
i don't think this should be done anymore
i think this should be done before the try block.
i don't think this is what we want... if you end up with the original exception you will be expecting
static import
ImmutableMap.of()
static import assertThrows
How about using.trim() for that?
How about using.trim()?
How about using.trim() for the String.
We can have "org.apache.hadoop.mapreduce.Parquet.Page.ByteBuffer"
We can use "org.apache.hadoop.mapreduce.Parquet.Page.ByteBuffer"
We should throw exception if value is null.
fID.getAttribute() returns null, which means it can be null?
fID.getAttribute() returns null, which means it will be null?
space after if
This change seems beyond the scope of this PR.
change this whole block of code to include a braces
change this whole block from private to public
rename 'bp'
cleaner code.
rename 'commit'
I still don't see how this can ever be null. It's initialized above and never set to null.
I still don't think it's needed at all. It's initialized automatically.
I still don't see how this can ever be null. It's initialized above and never set to true again.
Can you extract out the construction of the setUp() function to a local variable?
Can you extract out the test code?
Can you extract out the setup() function to a local variable?
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore.
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, we shouldn't need this anymore.
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to add an interface for the setters, and that's fine.
Why is this method removed?
Why is this method static?
Why is this step necessary? This test does not seem to check anything.
missing space after,
missing space after 'for'
missing space between exception name and the
why not have java docs to explain what this does? ( why it does it in that way etc)
why not have java docs to explain what this does? ( why it does that)
why not have java docs to explain what this does?
@sleshchenko looks like this class is changed by mistake
@fanifieiev the same above.
@dilini-muthumala Dilini, why cast to string vs string?
delete this line
remove this line
delete empty line
You can remove the redundant brackets
you can remove the redundant brackets
You can remove the redundant brackets here
Why not just use Jenkins.getInstance().getQueue()? (there are already a lot of places in this class)
Why not just use Jenkins.getInstance().getQueue()? (there are already a lot of places in the code)
Why not just use Jenkins.getInstance().getQueue()? (Changeocked above)
I don't think we need this empty block.
I don't think we need this else block.
I don't think we need this empty check.
It's not clear to me that value can ever be null, but you can also make a NullObject to prevent people from being able to re-serializeNulls.
It's not clear to me that value is a Number and a map of ParamConverter.serializeNulls can be used instead.
Simpler to decouple.
This would be better as a setter for the username and password.
This would be better as a setter for the date field.
This would be better as a constant
Another nitpick: It looks like we are calling this exact same setTitle twice. Do you think it'd be better to remove the public void setTitle(CharSequence title) { override and add a helper method for setting the title?
Another nitpick: It looks like we are calling this exact same setTitle twice. Do you think it'd be better to remove the public void getString(CharSequence title) { override and add a helper method for setting the title?
Another nitpick: It looks like we are calling this exact same setTitle twice. Do you think it'd be better to remove the public void getString(CharSequence fragment, int mPostList) { override and add a helper method for setting the title?
nit: Just making sure to include the values in the message.
nit: Just making sure to include the values in the config.
nit: What about calling closeKeyValues() instead?
Can this not result in loosing data? If a job is already running, a change happens and a change happens, would that lock not loose the new data?
Can this not result in loosing data?
Isn't this not autobuild?
Use the StringBuffer instead of a StringBuilder.
Use the StringBuffer instead of a String. The tests are in the wrong order.
I'd rather have a conditional here that checks for the nullness before calling this function.
Collections.emptySet()
Collections.emptyList()
Collections.emptySet()?
the token will not always be " ", sometimes it depends on ldap.accountFullName
the token will not always be ">", sometimes it depends on ldap.accountFullName
the token will not always have " ", sometimes it depends on ldap.accountFullName
nit, throw IllegalArgumentException("namespace cannot be null or empty");
nit, just use _zkAddress.
nit, throw IllegalArgumentException("namespace cannot be null or empty")
I think it should be Json.of
I think it should be Json
I think it should be Json here
This can be simplified as java List<ContingencyState> counts = counts.values(); counts.put(truthState, parameter);
This can be simplified as java List<ContingencyState> counts = new HashMap<>();
This can be a java type.
Permanent can be null.
PermanentOrLKI otherwisw thr resolution will make this use the permanent.
You can use game.getPlayer(() -> controller.getPermanentOrL1.createInstance(entity)) instead.
Not sure why this was hardcoded?
Not sure why you are setting the wrong spot here, but not the one you're basically cloning the dev version.
Not sure why you are setting the wrong spot here?
Doesn't.get() also return null?
Doesn't.get() also return null? If so, you can remove.isPresent() altogether.
Doesn't.get() also return true?
If the settings is null, I don't see any reason to keep it. I'm not sure if the string below should be "my_time" in both cases, if you want to get a null string here, you should only append it to the end of the string.
If the settings is null, I don't see any reason to keep it. I'm not sure if the string below should be "my_time" in both cases, if you want to get a null string (which will be "my_time_and_date"). Also, I don't know if the preference is squashed at the end with the string resource, but I don't know if it's great that you don't depend on the context of the main activity.
If the settings is null, I don't see any reason to keep it. I'm not sure if the string below should be "my_time" in both cases, if you want to get a null string (which will be "my_time_and_date"). Also, I don't know if the preference is squashed at the end with the string resource, but I don't know if it's great that you don't need to set it to the default here.
Please add a space after "if"
Please add a space after ".
This is now unused.
Let's break this loop into multiple lines
Let's break this loop into two for loops
Let's break this loop into multiple loop.
Too many ;)
Too many ;s :)
Too many ;s
Well, we don't know if it's easy to miss the viewer. I guess the viewer does need to be set before.
Well, we don't know if it's easy to miss the viewer. I guess the viewer does need to be updated too?
lambda?
Same here, we don't need to declare "int" as the Long param for the blob key. And in the previous case, only in the try block would be good.
Same here, we don't have the try/catch squashing. Would it be better to use the same approach for all these cases?
Same here, we don't need to declare "int" as the Long param for the blob key. And in the previous case, only in blobSize case would be checked.
not needed
not needed if we use empty ends here
not needed I think.
why we need http here doesn't make sense?
what we need http here doesn't make sense?
why we allow http here doesn't make sense?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?
Not specific to this code change, but what if the error is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?
Not specific to this code change, but what if the error occurs? It's not clear which item was sent, right? Maybe it's better to only log message when it occurred?
don't use assertTrue()
don't use File.append()
don't use assertTrue() or assertThat()
Can use StringUtils.isNotEmpty here
Can you use StringUtils.isNotEmpty here
Can you use StringUtils.isNotEmpty here?
ping me if I'm wrong, but this probably doesn't matter
ping me if I'm wrong, but this looks like a new game so it would not be null
ping me if I'm wrong, but this looks like a new game so it doesn't get updated
The name'startThreads' is confusing. Maybe rename it to 'ownerUrl' or something.
The name'startThreads' is confusing. Maybe rename it to 'owner' or something.
The name'startThreads' is confusing. Maybe rename it to 'ownerUrl' or something?
Should be get rid of the toString() call.
This should be get rid of the toString() call.
This should be getUncheckedInitialOperationAdapter
In this block, we should use the J2D to create the Bundle[] for the model classes, to avoid code duplication.
In this block, we should use the J2D to create the Bundle[] for the model classes.
In this block, we should use both J2Generated and S.createFactoryMethod.
Extract notification to a method notifyIfInitialServerCallDone
Extract this into a method, since it's used twice
Minor: Define the courseData.
This should be a field, not a member.
This should be extracted into a local variable, since it is used 3 times.
This should be extracted into a local and used in the same method
Is this better than re-using?
Is this better to do something like: java final BobManager init = init("(""), init); changed.replaceAll("(", "); changed);
Is this better than re-creating the init code?
Nice! I just realized that it could be a Noop as the wait loop may fail some time out to stop tasks. If you really want to wait for the thread to continue, you should return from getActiveTasks().
Nice! I just realized that it could be a Noop as the wait loop may fail some time out to stop tasks. If you really want to wait for the thread to continue, you should return at the end of the running thread.
Nice! I just realized that it could be a Noop as the wait loop may fail some time out to stop tasks. If you really want to wait for the thread to continue, you should return out of the while loop.
I don't think we need to wait timeout logic.
I don't think we need to wait timeout == 1000
I don't think we need to wait timeout logic, we can have a timeout.
Why don't we do this like the Set<Message> constructor? So we don't have to do it here
Why don't we do this like the Poll interrupted exception? :smile:
Why don't we wrap here - it is missed if no exception during stop()?
Shouldn't this be.reverseLookup(dnsResolver.get())?
Nitpick: this will be more readable by calling.reverseLookup(dnsResolver.get())?
Nitpick: this will be more readable by re-use in the next line.
I would rather return another warning ("Blank project name in the list")
I would rather return another set of projects here, as this makes sense returning a project name in the UI.
I would rather return another warning (Blank line)
What would be the case that could not be covered by numSteps.run(ChunkerInterleaved.class)?
What would be the case that could not be covered by the test?
What if this line is called?
can you do: repo.getRepoId().generateId().generateId().generateId().toLower();
can you encapsulate this in a method?.getRepoId().generateId().generateId()
can you do: repo.getRepoId().generateId().generateId().generateId().toExternal()?
Instead of catching and ignoring exception, should we catch it here as well?
Instead of catching and ignoring exception, should we catch that more specific exceptions?
Instead of catching and ignoring exception, should we catch it here?
IgniteCacheFutureImpl already has a IgniteBiTupleProcessorProcessor, so it should be cleaned up.
I think it's better to start IgniteCacheFuture#onDone(threadId, key) inside method.
IgniteCacheFutureImpl already handles null...
This is not a good way to handle this. Just use file.get(fileName) instead of find.
This is not a good way to handle this. Just use file.get(fileName) to get the file name and the file name
This is not a good way to handle this. Just use file.get(fileName) instead of.replaceAll
nitpick: I would prefer to use method reference: () -> adapterConfig.setRealmName(authEndPoint).orElseThrow(() -> new SecurityException("Connection name for security check is not configured!"));
nitpick: I would prefer to use method reference: () -> adapterConfig.setRealmName(authEndPoint).orElseThrow(() -> new SecurityException("Connection name for security check is not configured!")
nitpick: I would prefer to use method reference: > Optional<String> emptyList()
Isn't this the same as oldCredential?
Method could be reused here.
String password = oldCredential.indexOf("}");
Do we need this branch?
Do we need this new LoadContentAnswer(...)?
Do we need this change?
I think this will crash the app if something goes wrong. That's just going to be handled.
I think this will crash the app if something goes wrong. That's just going to be handled by the Android app (the very easy way of doing this): java Util.openInputStream(file, path);
I think this will crash the app if something goes wrong. That's just going to be handled by logging the error.
It would probably be better to return null and have this case fall through to the else than return null.
Don't catch this error.
It would probably be better to return null and have this case fall through to queryParamMap.
Does this test pass?
Typo: base file probably doesn't mean you should assert on content
Typo: base file symbol.
Should we not terminate this thread if we're inside the ScopeCleanupWorker? And can you confirm that the thread will always be interrupted?
Should we not terminate this thread if we're inside the ScopeCleanupWorker?
Should we move this to the finally block? And can we change the description of the exception?
I don't think we need this extra \n, given we already have a method for this on the String.join. Can be simplified to use.map(COMMA ->.map(value ->.map(value ->.value))
I don't think we need this extra \n, given we already have a method for this on the String.join. Can be simplified to use.map(COMMA::escapeValue)
I don't think we need this extra \n, given we already have a method for this on the String.join. Can you use.map(COMMA::escapeValue)
why do we throw out the service exception instead of ignoring it?
why do we throw out the SpongeException instead of logging it?
why do we throw out the SpongeException instead of using a literal logger?
getCallPeerPanel() can return null. Why couldn't you pass 'getCallListener' into it?
getCallPeerPanel() can return null. Why couldn't you just get the addCallListeners from it?
getCallPeerPanel() can return null. Why couldn't you pass the Keywordsbia as a parameter?
Catch Throwable instead of Exception.
Any specific reason for putting this in a catch?
Any specific reason for putting this in a different catch?
I think we should use something that has the format of the IAM package for encoding to help us identify any possible issues with encoding etc Looking at it the com.cloudant.tests.HttpIamTest#iamApiKey would probably be an appropriate thing to make public and share between tests. Of course the value would need updating to something useful instead of the current "iam" string value.
I think we should use something that has the format of the IAM package for encoding etc Looking at it the com.cloudant.tests.HttpIamTest#iamApiKey would probably be an appropriate thing to make public and share between tests. Of course the value would need updating to something useful instead of the current "iam" string value.
I think we should use something that has the format of the IAM package for this test. Otherwise we might see us with encoding etc Looking at it the com.cloudant.tests.HttpIamTest#iamApiKey would probably be an appropriate thing to make public and share between tests. Of course the value would need updating to something useful instead of the current "iam" string value.
Let's make the test more explicit, e.g. createGroupToGroup(newUser, group))
Let's make the test more explicit, e.g. createGroupToGroup()?
Let's make the test shorter.
Illegal arguments?
Illegal exception here?
Illegal exception here.
please move this to CommonUtilTest.java
this file is never deleted. Original code was only created once, which was the issue was fixed. Please move it to a class variable.
this file is never deleted. Original code was only executed if there is an issue with the file name change. Please leave it.
Shall give detailed error message with source/destination Db/table names.
Shall give detailed error message with source/destination Db/table name.
Shall give detailed error message with source/table names.
Small change: "Does you implement this in otpTestBase?
Small return: "base!= null"
otp!= base?
use getIntValueStyle() here instead of get(0)
use getIntValueStyle()
use getIntValueStyle() here instead of looping.
This is the only place this method is used. Please don't use the return value of filters.
This is the only place this method is used. Please use a private static method.
This is the only place this method is used. Please don't use the same modifier.
URI build logic does not fit in the builder itself. Instead I would use.map(Cat cat.getPedigree().isPresent()).
URI build logic does not fit in the builder itself. Instead I would use.map(Cat cat.getPedigree().isPresent()) to get the Cat cat on a param at all, as it's already in the range method.
URI build logic does not fit in the builder itself. Instead I would use.map(Cat cat.getPedigree().isPresent()) to get the String instance, and in the builder itself, it's easier to read.
@manuelplazaspalacio this is wrong. What does this handler do?
@manuelplazaspalacio this is wrong. What does this handler do to do that?
@manuelplazaspalacio this is wrong. What does this handler do to do to clear the result after the list has completed?
We can make a testcontainer method or an enum to make sure we can catch it in the test.
We can make a testcontainer method or an enum to make sure we can catch it here as well.
We can make a testcontainer method or an enum to make sure we can catch it here too.
setErrorMessage
Please use a list instead of an array
Please use a list of authors
== ->.equals
message should be "Comparator"
message should indicate what is wrong.
Use getResults() instead.
Use getResults method.
Long lines are redundant.
FORM authentication is something we need to be able to support with the query URL. In this case, I think it's a bit more clear to have the request URI by its id, and have the following just do the query URI instead of the URL.
FORM authentication is something we need to be able to support with the query URL. In this case, I think it's a bit more clear to have the request URI by its id, to strip the URL from the URL.
FORM authentication is something we need to be able to support with the query URL. In this case, I think it's a little more clear to have the requestUri after just a request.
Unnecessary.
1. I wonder if we should just use target.get normalized to avoid the need to call releaseOrTarget. 2. If this is a normalized form, then the normalized name returned by the method.
I don't think this would work if the normalized value is a set..
Why not use the tcArgs.replaceAll("", "*") in the try-catch block instead?
Why not use the tcArgs.replaceAll("", "*") in the try-catch block instead of a try/catch?
Why not use the tcArgs.swixParser_ErrorParsingArgumentsException?
same here, why do you need to add a break?
Can we use a fake file instead?
again, you should have a fail
All hard coded strings that used as a key to get data the bundle should use constant in Router.java.
All hard coded strings that used as a key for this should be declare as constant in Router.java.
All hard coded strings that used as a key to get data the bundle should be declare as constant in Router class.
Fun fact about L?
Fun fact about localization: %%(format)
isNumericFormat can be moved to a Function
Why do you need to stop container in finally block?
why do you need to stop container in finally block?
Why do you need to stop container in constructor?
why is this necessary? I admit I don't know how will the stacks work.
why is this necessary? I admit I don't know how will the stack get filled in?
i don't think you need this. here.
Could you please remove the System.out call?
Could this be a static variable?
Could you please remove the System.out?
Call the constructor with registerNull() and fail fast
Call the constructor with registerNull() and force the getter call if it is not necessary.
Call the constructor with registerNull() and force the getter if it is not null.
There's a AbortException thrown here. An RuntimeException will be thrown when creating a new AbortException.
There's a AbortException thrown, should it be handled at the top of the method?
There's a View::hasPermission() method
nit - move the deceleration one line up..
nit - move the deceleration one line up.. }
reorder
static
static import
Maybe a static method?
I think this is a bit too long. It might be better to use a try-with-resources block so that we don't need to worry about closing the table.
I think this is a bit too long. It might be better to use a try-with-resources block so that we don't need to declare this array
I think this is a bit too long. It might be better to use a try-with-resources block so that we don't need to close the table.
Looks like the 4th parameter is no longer needed. Since we have it at the init.
Looks like the 4th parameter should be constants
Looks like the 4th parameter should be constants.
setReturnValue can be Guid? As the snapshot entity is not populated apart from Id, so is there any need in returning this?
setReturnValue can be Guid? As the snapshotName is not populated apart from Id, so is there any need in returning this?
setReturnValue can be Guid? As the snapshot name is not populated apart from Id, so is there any need in returning this?
Could you put the else brackets on same line and add a space? } else {
Could you please put the brackets on same line and add a space? } else {
Could you please put the else brackets on same line and add a space?
Shouldn't this be an IllegalArgumentException?
Shouldn't this be IllegalArgumentException?
Shouldn't this be fatal?
I think you could do: if (vol.getId() == null) { return Collections.emptyList(); } else { return new RuntimeException("Internal volume name: " + P.getDeviceId().toString() + " is used by vm" + maxDataVolumes.size()); }
I think you could do: if (vol.getId() == null) { return Collections.emptyList(); } else { return new RuntimeException("Internal volume name: " + P.getDeviceId().toString() + " is used by vm" + minSize.
I think you could do: if (vol.getId() == null) { return Collections.emptyList(); } else { return new RuntimeException("Internal volume name: " + P.getDeviceId().toString() + " is used by vm" + maxDataVolumes.getId()); }
should we only on recurse here if ids is instanceof HudsonConfiguration?
does this need to be 2?
awesome
This if statement is not needed. if debug is enabled, there are more than 1 message.
This if statement is not needed. if debug is enabled, there is no need to add the event.
This can be trace level.
Should be final
Should also be checked for centroids here.
Should also be checked for centroids
I like the fertilizerItem and fertilizerItem.... Why don't you use an Integer[]?
I would expect an tilizerItem and then just fertilizerItem....
I would expect an tilizerItem and then just fertilizerItem.get()?
I don't think this is the right way to go. I was intending to have an integer division before the last time. However, if it was int then it's probably slower than String.format(toPrint) { final long time = unit.toPrint(); final String 30 = unit.toPrint; if (toPrint == 30) { return (toPrint == 30) { return 30; } final int nanos = unit.toPrint; return unit;
you can use TimeUnit.DAYS.toMillis()
I don't think this is the right way to go. I was intending to have an integer division before the last time.
I don't understand this branch. Why just not to create it in this case? Because this is exactly what you do outside of this method. You call takeProducer again, you'll just not adding it in this new function.
I don't understand this branch. Why just not to create it in this case? Because this is exactly what you do outside of this method. You call takeProducer() and not unlock(), it calls takeProducer(). I would just say just the first thing.
I don't understand this branch. Why just not to create it in this case? I don't understand this branch.
You need to use negNum instead of just negNum: suggestion negNum = dais.getCause();
You need to use negNum instead of just negNum: suggestion negNum = dais.get();
You need to use negNum instead of just negNum, since you are not going to use that
Maybe use ordinalDescriptorMap.containsKey(this.baseDescriptorMap)
lastPosition!= -1?
lastPosition!= -1
Should check for disposal.
shouldn't this be checking for disposal.
why make this a public?
Shouldn't this be the other way around? e.g. Unexpected Exception is caught!
Shouldn't this be explicit? e.g. "HTTP"?!
Shouldn't this be!=?
state.index could be moved outside the loop and into a local variable.
state.index() isn't needed here since you already check for state == null.
state.index() isn't needed here since you already check for state.index == 1
> What about extracting complex.getPublisherDetails(simpleImage) to a function?
Shouldn't Ads do this for us?
Shouldn't Ads do this job?
We may have a class called getPublicPort but then we can still use that in other places.
We may have a class called getPublicPort but then we can still use that if we don't need it.
We may want to validate against a possible protocol that could be provided by Expression.getPublicPort(page)
<LINK_0>
change %s must not be null
change %s to %s
The events can be extracted to a local variable for the events.
The events can be extracted to a local variable for the events since you are in the constructor.
The events can be extracted to a method to avoid duplication.
Should we add the navigator's dependencies when this is not supported?
should we add the navigator's dependencies when this is not supported?
Should we add the navigator's dependencies when this is not available?
Can be _split_..('_','');'
Can be _split_..('_','');_
Can we add _item_ to _properties_?
You should check for attribute.getAttributes() before doing a check in all code.
You should check for attribute.getAttributes() before using map.
You should check for attribute.getAttributes() before using map.put.
Is it possible to reach this line? I find it a bit hard to follow.
Why change the waitTimeMs? I do not think we should do it in this condition.
Nit: updateTimeMs -> waitTimeMs
I think we still need to decrease population jobs here as well?
I think we still need to set populationJob as populationJob. Otherwise, we already have one IndexPopulationJob which is very low, and we can still use it when passing objects to IndexPopulationJob.
I think we still need to set populationJob as populationJob. Otherwise, we already have one IndexPopulationJob which is very low, and we can still use it when it is too low.
Why not private Ref<Ref> refs = Git.lsRemote(ref.getPeeledObjectId(), r1);
Why not private Ref<Ref> refs = Git.lsRemote();?
Why not compare refs with ==?
Here too - use Integer.valueOf(0)
Can you use Integer.valueOf(0)
Can you use Integer.valueOf(0) instead?
This assignment seems useless
Can we use the same style for the other CTextSize form?
This is a strictly necessary check
You can use Map.Entry::cast here instead of HashMap.
Only use of ArrayList?
You should use Map.Entry here?
WattleFragment name is being used at all?
What do you think of that change?
WattleFragment name is being used anywhere in the code
as long as we're fail or use parseRuntime method to throw exception
please fail() before catch statement
as long as we're fail on this line
I think it may be better to move the mkdirs() inside the if block.
I think it may be better to move the mkdirs() check inside the if block.
I am not entirely sure it is better to log the exception. Shall we throw a Pinot IOException here?
Can you extract a constant for the name?
Can you extract a constant for this?
Can you extract a constant for the name case?
Please name this method as something like SketchHolder<JETCH>
Please name this method as something like SketchHolder enum
Please name this method as something like SketchHolderETCH1
Is this a little clunky? Does it work if we don't do this? I think it would be feasible if we could remove the schema type check.
Is this a little clunky? Does it work if we don't do this? I think it would be more readable if we could just have a single return statement protected boolean isAnonymousSchemaDescr=isInitialDefaultSchemaDescr=stream().map(DefaultSchemaDescr::getSchema).collect(Collectors.toList());
Is this a little clunky? Does it work if we don't do this? I think it would be more readable if we could just have a single return statement protected boolean isAnonymousSchemaDescr=true; and then we'll avoid having this variable and using the isClosed method.
space
Wrong cast.
space after,
Why do you create the task with the task manager?
I don't think we need to introduce the task.
Why do we have to stop the task manager?
Can we use TextUtils.equals here since comparing strings are immutable?
Can we use TextUtils.equals(...) instead of ==?
Can we use TextUtils.equals here since comparing strings are null safe
is still needed here IMHO
is still necessary here IMHO
is still required here IMHO
A warning: - Remove this check on schemaManager.isDeprecated() - Use this instead of if-else blocks. - If people don't want to, we can @Deprecated be used by the PRs.
A warning: - Remove this check on schemaManager.isDeprecated() - Use this instead of if-else blocks. - If people don't want to pollute it with Deprecated, then you need to return the deprecated method
A warning: - Remove this check on schemaManager.isDeprecated() - Use this instead of if-else blocks.
we shouldn't make the setting of the flag conditional on autostartup
the setting of the flag isn't required here since it is setting the property to null in the constructor. and I think the setting of the flag should be done here also.
shouldn't we make the setting of the flag conditional on autostartup
please reformat code
please regroup these two lines
please re format the code
as we discussed, you should use pathMatcher.getDefault().getPathMatcher(), finding one URI.
as we discussed, you should use pathMatcher.getDefault() (I believe it's a bit simpler to read and cache using pathMatcher in a static variable)
as we discussed, you should use pathMatcher.getDefault() (I believe it's a bit more efficient) to create a File object and reuse it.
Is this handled by prov instanceof ILabelProvider?
Is this covered by any of the tests?
Is this handled by prov instanceof List?
Is it relevant to the operation? If so, this should be an error
Is this change relevant? If not, I think it should be part of the operation.
Is this change relevant?
The method name sounds a bit strange to me (having the words "subscription filter" twice). I currently do not have a better name in mind, though.
Please also set the view to gone when there is an error (line below).
Please also set the view to gone when there is an error (line below). I've set it to debug but it says that there is no view.
need to add a null check here, as described above
need to add a null check here for model.getProvisioning().
need to remove
to connect to secure / handle it. I know the code was different, but you don't want to split on it. If the code was moved from your commit that you should validate it.
to connect to secure / handle it. I know the code was different, but you can't use String.valueOf.
to connect to secure nimbus
Consider switching this to a stream: java return locations.stream().filter(location -> encoding!= null).map(Map.of(x, y)).collect(MoreCollectors.toImmutableList());
Consider switching this to a stream: java return locations.stream().filter(location -> encoding!= null).map(Map.of(encoding, encoding));
Delete the surrounding brackets even if they don't have been used.
throws Exception is not needed
throws Exception should not be necessary
throws Exception is not needed.
Why should the cast to int here?
This and the cast seems unnecessary.
The.remove on line 74 seems unnecessary.
Didn't we have to escape this into an appStatus like this?
Didn't we have to also printAnsi_ID()?
Didn't we have to escape this into an appStatus like so:?
model.getGenericParams() is an expensive call (make sure it gets the PSI tree). Please capture the value, then test and use it.
model.getGenericParams() is an expensive call (make sure it gets the PSI tree). Please use.equals() instead.
model.getGenericParams() is an expensive call.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMetsIT to test reload from DB.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMesIT to test reload from DB.
A save to DB is missing here (and above in ExportDms).
I believe that you can use the below code to access the date local time.
I believe that you can use the below code to access the date of time.
I believe that you can just use the result of that method.
May I ask you the purpose to check "retry_count"?
May I ask you the purpose to check "sub"?
May I ask you the purpose to check "sub"?
Rather than doing this, I would move the Calendar from the getInstance() methods and remove the Calendar from the method.
Rather than doing this, I would move the Calendar from the getInstance() methods and remove the setTimeInMillis from the event handler.
This can be just Collection.
no need to check the Realm instance?
i am not sure why we need this check..
i am not sure why we need this check?
Why should we use overload of saveAllInTransactionScope()?
Why should this use overload of saveAllInTransactionScope()?
Why should we use overload of saveAllInTransactionScope()? I don't think this is needed as we have a callback for it
Should read the opposite, not the opposite
Should read the opposite name.
Should read the opposite, not the opposite.
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
What about putting this into the else block and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
What about putting this into the else branch and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go to the front, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go to the front, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away. But worst, if you click or Alt-Tab to another application to make it go away.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
can't we call pluginsToRemove.getPluginInfosByKeys() and pluginsToRemove.getPluginInfosByKeys() the plugin can be called instead?
can't we call pluginsToRemove.getPluginInfosByKeys() and pluginsToRemove to install the plugin?
can't we call pluginsToRemove.getPluginInfosByKeys() and pluginsToRemove.getPluginInfosByKeys() the plugin can be called in pluginClasses
This is not needed.
This is not needed anymore.
this is not needed.
Since the 31 API is configurable, can this be reduced to: java return withUser.getAuthorities(), withUser.nameTokenClaimName(attr, principal);
Since the 31 API is configurable, can this be reduced to: suggestion return withUser.getAuthorities(), withUser.nameTokenClaimName(attr, principal);
Since the 31 API is configurable, can this be changed to: suggestion return withUser.getAuthorities(), withUser.nameTokenClaimNameToken(request.Authorities);
Should this use try with resources?
Do you really need all this.num = Math.min(bytes, bytes.remaining()); here?
Do you really need all this.num = Math.min(body, bytes.remaining()); here?
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:155: error: NULL_DER object diagramPath = formSessionHandler.getSession() instanceof EditorSession? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 154. 155. > formsContainer.render(graphUuid, UUID.class);
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:155: error: NULL_DER object diagramPath = formSessionHandler.getSession() instanceof EditorSession? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 154. 155. > formsContainer.render(graphUuid, UUID.class);
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? :)
nit: space after if
nit: spaces after if
nit: space after //
Maybe we should just use Stream for this?
Maybe we can just use Stream.of here?
Maybe we can just use Stream.of here
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it. Also you use the same key set here.
Why do you start in an inconsistent state?
suggestion if (currentLabels == null) {
suggestion LOG.debug("Can't find find symbol che.infra.kubernetes.cluster-namespaces", namespace);
suggestion if (currentLabels!= null) {
Why do we save within the loop?
Why do we need to return the group?
Why do we need to return the results?
Can we use the same approach as in other places?
Can we use the same approach as in other pr?
Can we assert something in this method?
@pynicolas I'm not sure we need this variable. I would inline it.
@pynicolas I'm not sure we need this variable. I would inline it to hasOnlyEmptyStatements method.
@pynicolas I'm not sure we need this variable?
I don't get this part. If you're not using the first clause it's illegal to be an exception.
I don't get this part. If anything I'd rather keep the first clause and keep the second variable.
I don't get this part. If you're not using the first clause it's illegal to be an empty list.
This and the change should be removed and the change should be reverted this change.
This change should be removed and the change should be reverted this change.
This and the change should be removed and the change should be reverted.
This should also be: Set<ToolName> result = promptHandler.getTool(guiName); if (doPrompt) { return Optional.of(toolName, "No tool provided and no defaults configured"); } return Optional.of(doPrompt.class);
This should also be: Set<ToolName> result = promptHandler.getTool(guiName); if (doPrompt) { return Optional.of(toolName, "No tool provided and no defaults configured"); } else if (doPrompt) { return Optional.of(toolName, promptHandler); } else { return Optional.of(toolName, promptHandler); }
This should also be: Set<ToolName> result = promptHandler.getTool(guiName); if (doPrompt) { return Optional.of(toolName, "No tool provided and no defaults configured"); } return Optional.of(doPrompt.class, PromptContinueHandler.class, "No tool provided and no defaults configured");
It would be nice to move this to inside the for loop.
It would be nice to move this inside of the for loop.
It would be nice to move this outside of the for loop.
Why do we want to support this now?
Why do we want to return an empty list?
Why do we want to return a list?
In the other hand, the ACCUMULATED_RESULTS sounds strange -- it might not be a _extractLATED_RESULTS sounds strange given its a getKind()!= null
In the other hand, the ACCUMULATED_RESULTS sounds strange -- it might not be a _extractLATED_RESULTS sounds strange. I'd rather __EDIT_RESULTS sounds better. If the result is empty then we can remove the if else.
In the other hand, the ACCUMULATED_RESULTS sounds strange -- it might not be a _extractLATED_RESULTS sounds strange. I think it's actually a minor performance issue, but I think it's better to remove the if else as it was already there.
ok, now it doesn't force the user to handle role.... if it's not valid, there's a bug, it should be the token as it's not checked. But if you just want to check.
ok, now it doesn't force the user to handle role.... if it's not valid, there's a bug, it should be the token as it's not checked. But if you just want to confirm.
ok, now it doesn't force the user to handle role.... if it's not valid, there's a bug, it should be the token as it's not checked.
Is using getAdapter() and getAdapter() guaranteed to return custom getAdapter()? We may want to use getAdapter() and make getAdapter() simpler.
Is using getAdapter() and getAdapter() guaranteed to return custom getAdapter().getCount()? so how can we handle the case for RelativeLayout?
Is using getAdapter() and getAdapter() guaranteed to return custom getAdapter()? We may want to use getAdapter() and make getAdapter() return custom getAdapter().
You should also cast the IStructuredViewer to an ITextEditorExtension3.
You should also cast the IStructuredViewer to an IStructuredViewer.
You need to cast the patch to IStructuredViewer.
Might as well use isEmpty()
Might as well use equals()
Might as well use azure-core.
Can't we extract these duplicate intent.putExtra and startActivity(intent) to outside the if-else? (line 101,102 and 115,116)
Can't we extract these duplicate intent.putExtra and startActivity(intent) into outside the if-else? (line 101,102 and 115,116)
Can't we extract these duplicate intent.putExtra and startActivity(intent) to outside the if? (line 101,102 and 115,116)
Why did you remove the deleteOnExit if it isn't empty?
Why did you remove the deleteOnExit if it is not already called in the delete.
Why did you add to the sized form here?
rename to createFromPrintfStyle()
rename to createFromPrintfStyle and then test
rename to formatStringFormat
Are you sure that this check is needed?
Are you sure that this is an important update?
Are you sure that this check will always succeed?
Ah this is a lot of code I did above. I think it would be worth extracting a helper method here as well.
Ah this is a lot of code I did above. I think it would be worth extracting a helper method.
prefer the 2 - magic strings...
Irrelevant change I'll do this myself.
Irrelevant change I'll do it myself.
Irrelevant change I'll do it right?
No need to wait, I'm not sure if it will work properly
No need to wait, I'm not sure if it will fails
No need for a sleep
The path variable is not necessary; VoltFile::getCanonicalPath() should be called only once.
The path variable is not necessary, voltdbRoot.getPaths() may be null at this point.
The path variable is not necessary, voltdbRoot.getPaths() may be null at this point
Same question as above. And below as well.
I think you should remove the project :wink:
Same question as above. And below.
Please use static imports for AssertJ.
Please use static imports for Asserting
Please use static imports for Asserting.
nit: could make a constant and name it ""
nit: could make a constant and use it here to be consistent with the rest of the tests
nit: could make a constant and use it here to be obvious
I would put this after the if
Same here, it should be fine :)
I would keep the old entry as local...
it's unnecessary, but I don't think it needs to be public.
Probably want to be careful with this.
Probably missing the field?
"created procedure" instead of "ppid"
" receiver" instead of "ppid="
"created procedure" instead of "ppid="
that's what I meant.'startVms' is for s/startedVms/startedVms
that's what I meant.'startVms' is for s/startedVms/startedVms/
that's what I meant.. don't you want to do that?
looks like we don't need to check varlogsMap.isEmpty()
looks like we don't need to check varlogsMap.isEmpty()?
looks like we don't need to check varlogsMap.isEmpty()?
Remove the!, it's redundant with the return.
Remove the!, it's unneeded to check for null
Remove the!, it's unneeded to check
same issue here: space between if and (
same issue here: try-with-resources
same issue here: space between if and (.
It is better to do this check inside the if (isWindows()) block so that we are not doing what we need to do. java if (isbnd.info("-run")) { return; }
It is better to do this check inside the if (isWindows()) block so that we are not doing what we need to do. java if (isbnd.info("-run")) { return; } It will be done in the reverse order
It is better to perform checks that the correct objects are created
Using parallelStream would be clearer here. What do you think?
Using parallelStream would be better here. What do you think?
Using parallelStream would be clearer here
InsertOrOr RealmObject?
InsertOrOrMessage or something?
InsertOrOrOrMessage or something
I forgot to mention in the other review: It's always good to call Preconditions.checkNotNull on nullable parameters. See other status as an example.
I forgot to mention in the other review: It's always good to call Preconditions.checkNotNull on nullable parameters. See other status to mention in the future.
It's always good to call Preconditions.checkNotNull on nullable parameters. See other status as an example.
is this really needed here?
is this really needed here?
is this really needed?
I would move this inside the catch block
I would move this inside the catch, right? So this is one-liner
remove this change
nit: "T"})" May be clearer (and never actually)
nit: } catch (Throwable t) {
nit: "T"})" (and other places)
There are a lot of extra space in this method. IMHO it's better to create a new line of code instead of a string concatenation.
There are a lot of extra space in this method. please consider replacing it with a new line.
There are a lot of extra space in this method. IMHO it's better to create a new line before the { and } instead of a string concatenation.
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an archaius AsyncK.
It would be handy to have archaius in the thread name so it is easier to spot at a glance and realize it is an entrySet
It would be a graceful message in this method.
We could also try to use the icon theme here, for instance the user icon.
we could also try to use the icon theme here, for instance the user icon.
We could also try to use the icon theme here, for instance the icon theme.
This is not ideal, because it will be a percentile of interval, making it a string.
This is not ideal, because it will be a percentile of interval, making it a string. I would suggest to do it here instead of d.getSummaryHistogram() as a dependency.
This is not ideal, because it will be a percentile of interval, making it configurable.
we can remove the debug log here and in other places
we can remove the log line.
remove debug log
When is this created?
When does this happen?
When is this pull request supported?
Should check for filter not exists before adding it to the map?
Should check for filter not exists before doing this?
Can you check if the filter exists in the map before doing this?
{}
{} is missing
{} }
It would be nice to avoid declaring this constant (several occurrences in this file) for example.
It would be nice to avoid declaring this constant (several places) as well.
It would be nice to avoid declaring this constant (we can just use it when creating the string)
Is there a better way to check for null?
Is there a value we can use here?
For log4jConfigError
Map<Type, HIVE_META_ERROR, "unknown" should be OK, and we don't need to use the Parquet file mode.
Map<Type, HIVE_META_ERROR, "unknown"...
Map<Type, HIVE_META_ERROR, ParquetOutputFormat> is the default value of the file name.
Sounds ok to me that the outcome matches the false return
Seems to match the return of false asserted a few lines above this one
Sounds ok to me that the outcome matches the false return of the false return
This variable is not being used anywhere. Can you create a private static final constant that includes both the DEFAULT_CUSTOM and the constructor?
This variable is not being used anywhere. Can you create a private static final constant that includes both the DEFAULT_CUSTOM and the one in this constant?
This variable is not being used anywhere. Can you create a private static final constant that includes both the DEFAULT_CUSTOM and the one in this constant?
Maybe add assertion that condition is more than one CaughtTimeoutException
Maybe we could add a message to this exception
Maybe we could add a message to this case?
I think that we should not need this 'else' part.
I think that we should not need this at all.
This is misleading.
I'm not sure if DEVICE_TESTS should be used here.
I'm not sure if DEVICE_TESTS is the correct default. It should be a constant.
I'm not sure if DEVICE_TESTS is the correct default. It should be a separate PR.
Why don't we just return the response?
Why don't we just return the mono?
Why don't we just return the collection?
INFO level: WARN or ERROR
INFO?
final
As it's a nullable field, null protection would be good just in case: if (occurrence!= null) {...
As it's a nullable field, null protection would be good just in case.
Nice, I think I've fixed that!
Can this supplier give both jpg form data and length?
Can this test be made private?
Can this test be made private?
Change to a loop
Change to new HashMap<>();
Change to repositories?
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexact seek is disabled
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexactSeek is disabled
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexactSeek is true.
[optional] Is it possible to write this as: getProject().getFullName() > buildListener(build)?
Missing.isEmpty()
Missing.isEmpty() check
This should potentially result in the caller of this method and not the call to Tristate.
This should potentially result in the caller of this method and not the callers that it needs to know about. It would be nice to let the caller handle it...
The log level for this is too important.
I am pretty sure, is this a deterministic way of detecting this kind of alert? Perhaps "table [Codacy](<LINK_0> Issue found: [[Codacy](<LINK_1>
I am pretty sure, is this a deterministic way of detecting this kind of alert? Perhaps "table [Codacy](<LINK_0> Issue found: [Codacy](<LINK_1>
I am pretty sure, is this a deterministic way of detecting this kind of alert? Perhaps "table [Codacy](<LINK_0> Issue found: [[odacy](<LINK_1>
unless whitespace characters are needed here (here and in the isSuccessful method)
unless whitespace characters are valid, this should be an else if (processPayeeAchAccountNew...)
unless whitespace characters are needed here (here and in the isSuccessful method), this should be StringUtils.split().
I want to say this should be numMachineOption.isPresent(), so we should fail to get the default value for the sshMachineOption.
I want to say this should be numMachineOption.isPresent(), so we should fail to get the default size of the sshMachineOption.
Coding style :(
In the other files you use <LINK_0> for checking whether the string is a constant. Just check if the string is not null and do a comparison using that.
s/schema/field
s/schema/field name/?
Yes those would come in arbitrary order, so leaving it this way is too naive. But the analysis's own trace source should always come first and those specifics come after. _That_ order is important.
Yes those would come in arbitrary order, so leaving it this way is too naive. But the analysis's own module source should always come first and those specifics come after. _That_ order is important.
Yes those would come in arbitrary order, so leaving it this way is too naive. But the analysis's own module source should always come first and those specifics come after.
This should be using dnsResolver.reverseLookup(futures, dnsResolver.getCircuitBreakerConfig().get(instanceOf(CallNotPermittedException));
This should be dnsResolver.reverseLookup(futures, dnsResolver);
This should be using dnsResolver.reverseLookup(futures, dnsResolver);
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig.
this should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
We should probably check if the class code is in getName(), and not!= here.
We should probably update getName() to use as mentioned in <LINK_0>
We should probably check if the class code is in getName(), and not instanceof.
I think this should be mergeFunc.containsKey(key) && stats1.containsKey(key) == stats2.get(key)
I think this should be mergeFunc.containsKey(key) && stats1.containsKey(key) == stats1.get(key)
I think this should be merged with the new function replaceFunc#containsKey
What will happen if exception is thrown here? Previously when we initialized everything beforehand we had a clear path: node fails to restore memory and shuts down. Now with this change we don't even have a checked exception to catch, it is wrapped into unchecked.
What will happen if exception is thrown here? Previously when we initialized everything beforehand we had a clear path: node fails to restore memory and shuts down. Now with this change we don't even have them.
Is this exception correct? Previously when exception is thrown.
That's a bit strange. Why do we need 2 input streams?
That's a bit strange. Why do we need any input array?
Do we need more than one input?
Why do you need to change this? I would expect a null check on getDataAltitude here.
Why do you need to change this? I would expect a different artifact to be used for testing purposes.
Why do you need to change this? I would expect a null check on getDataAltitude here. This method should be removed.
Are you trying to overwrite the former version of the public repo?
Are you only trying to set the project name and that of the live repo?
Are you trying to overwrite the former version of the public method?
what are these magic numbers here for? it feels like this should be a static constant.
what are these magic numbers representing 3? it feels like this should be a static constant rather than an enum.
what are these magic numbers representing 3? it feels like this should be a static constant rather than an int but that's what it is.
should be 'null'
can be null
should be equals
pay.getPermanentOrLKIBattlefield(destination.getTarget())
pay.getPermanentOrLKIBattlefield(allele)
pay is only one time variable
Can we make this log message more specific? It is only making a SAVE_ID magic number.
Can we make this log message more specific? It is only making a SAVE_ID magic number...
Can we make this log message more specific? It is only making a SAVE_SYNC constant, but it's not about stats.
you should use the equals method.
you should probably use the 'else operator' method which does the same as above.
you should probably use the 'else' expression as mentioned above.
Arrays.copyOf?
Can be static.
Could use Arrays.copyOf
I would throw an IllegalStateException instead.
I think this should throw an IllegalStateException instead.
I would throw an IllegalStateException instead. RuntimeException might be better.
|| not &&? is storeAlwaysIndicdicating a boolean.
|| not &&? is storestate a requirement to make cooperative work?
|| not &&? is storeAlways
also assert forceWrite called times.
assert forceWrite called times.
also assert forceWrite called times?
nit: we could do the same thing with the new method and return the pingFuture, which basically makes this method more readable.
nit: we could do the same thing with the new method and return the pingFuture, which is not the same thing.
nit: we could do the same here.
minor nit: this can be shortened to: || (applies to the next line)
minor nit: this can be shortened to single line : new long[] { "application/json" }
minor nit: this can be shortened to single line : java } else {
Should we move that magic number to a named constant?
Should we extract "Gyclomatic Number" to a named constant?
Should we simply check that the result of the'maxECState' value?
context.setPollRetryMs(true);
context.getPollRetryMs() can return null.
context is null instead of task.
Isn't this the default return type?
Isn't this the default value?
Use DefaultPlayerService.getInstance.getAsync(false)
if it is all the same, move the DONE case to the switch-case? Just a bit more readable.
if this is all the same, move the DONE case to the switch-case? Just a bit more readable.
if the DONE case is ok, move the constants start to the switch-case? Just a bit more readable.
Just remark: you could introduce this variable, it would be clearer if you used the switch.
Just remark: you could introduce this variable, it would be better if you used the switch.
And this one
suggestion: how about extracting this into a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
suggestion: how about extracting this to a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
suggestion: how about extracting this into a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to String entity = this.f.isSetReadOnly();
You can do better this way: java if (temp.get("Name").isEmpty()) {... }
You can do something like: if (temp.get("Name").isEmpty()) { return; } if (ulimit!= null) { l.setName(temp.toString()); } // Add this to the for loop }
You can do something like: if (temp.get("Name").isEmpty()) { return; } if (ulimit!= null) { l.setName(temp.toString()); }
you prefer to declare REMAINDER_UNSUPPORTED_NAME in the else block rather than it in the if
you prefer to declare REMAINDER_UNSUPPORTED_NAME in the else, and use it in the if in the else
you can merge these two ifs into one
The indentation is a bit confusing here, it'd be nice if the overrides were shifter to the right past the first column of the new AuthorizationEntity line
The indentation is a bit confusing here, it's not just "return new AuthorizationEntity("plugin_framework_plugin", project.getName());
The indentation is a bit confusing here, it's not just "return new AuthorizationEntity("plugin_framework_plugin", project.getName());".
This is dangerous; it's possible that the alert gets no longer visible. The log message could be something like the following, or the debug message could be longer visible.
This is dangerous; it's possible to avoid the 'this' keyword in the log message. The variable probably doesnt need to pre-compute it.
This is dangerous; it's possible that the alert gets no longer visible. The log message could be something like the following, or the debug message could be considered higher.
did we want to set this on the task thread?
did we only want to set the non-existent type here?
did we only want to set the non-existent type for the task?
Missing final
Missing D.
Missing final.
Let's move these necessary before the accessibleForInstructor
suggestion.orElseThrow(() -> new IllegalArgumentException("The differ is not defined"));
suggestion.orElseThrow(() -> new IllegalArgumentException("The differ is not associated with student");
thanks for jdk 1.7 support!
thanks for jdk 1.7 support
thanks for jdk 1.7 support.
This should be a warn. Even though we're going to retry and everything might possibly be recovered, it is important for sysadmins to know that a failure happened.
This should be a warn level message. Even though we're going to retry and everything might possibly be recovered, it is important for sysadmins to know that a failure happened.
This should be a warn. Even though we're going to retry and everything should be recovered, it is important for sysadmins to know that a failure happened.
What is the reason why this new method was added?
What is the reason for not using a new String instance here?
What is the reason why this data was removed?
Just for consistency, avoid the cast to IFunction in the first place.
Just for consistency, avoid the cast to IFunction here.
Just for consistency, use IFunction.apply(p.getName(5)).
Since the commandId is not used, can you move it there?
I think it would be clearer to move the logic of the commandId and response to the generic method of Exception handler class, if not then the method is not generic.
Since the commandId is not set, it would be not set to true by default.
Could be defined in O(N)
Could be defined in class
Could be just int since it is really ints
Error message should be updated to use SQLPattern or some kind of regex.
Error message should be updated to use SQLPattern or some kind of regex
Error message should be updated to match the form name
Wouldn't be better to call gwrpClient here?
Wouldn't be better to call this constructor in the gwrp class here?
Wouldn't be better to call this constructor in the gwrp class?
final InfiniumGTCFile without the variable.
final InfiniumGTCFile::new
put in a finally block.
is / or /?
is Exception assigned to new RuntimeException?
is / or /? I am not sure that is a good idea to encode the result, but reading the file stream looks better.
Why do we need to clear the session here?
Why do we need to clear the tenant here? If it's not used, right?
Why is this done here?
The closing InputStream is in memory context.
use try-with-resources to ensure closing
The closing InputStream is not necessary
Just Log.debug("Starting the OpenmrsUtil.", e);
Just log.debug("Starting the OpenmrsUtil.", e);
Just log.debug("Starting the Openmrs configuration", e);
should we close the channel here?
should we throw an exception?
should this be callback.onError?
ExistingEntityException is thrown, isn't an UnknownEntityException a more valid choice?
ExistingEntityException is thrown, isn't the UnknownEntityException a more valid choice?
ExistingEntityException is thrown, isn't an UnknownEntityException a better fit here?
nit: could we throw IllegalStateException instead?
Please throw a more descriptive exception
nit: we can use final
Could we provide the values of this exception to the log message? In the case of an empty record, we could avoid the log line.
Could we provide the values of this exception to the log message? In the case of an exception, do we want to know which domain was caused?
Could we provide the values of this exception to the log message?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "save". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "save". [![rule](<LINK_2>](<LINK_0>
nit: runTime -> runtime
runTime -> runtime
It's enough to have only one public method.
if (filename.equals(sheetName)) { analyzer.addConfiguredProperty( "properties"); }
if (filename.equals(sheetName)) { analyzer.setConfiguredProperty(false); }
if (filename.equals(sheetName)) { analyzer.addConfiguredProperty( " " + filename); }
I'm not sure how it should be a warning message. It should be something like "UserMisUserMisMatchCachedToken"?
I'm not sure how it should be a warning message. It should be something like "User in retrieved token cache doesn't match the user name."
I'm not sure how it should be a warning message. It should be something like "User in retrieved token cache doesn't match the user cache."
can you use %L here?
can you use the constants from SizeOf.
can you use the constants from d.
I guess this should never happen in theory
I think this should be a feature of a utility class, which is visible to the whole framework. It can be called Environment or something like that.
I guess this should be a feature of a utility class, which is visible to the whole framework. It can be called Environment or something like that.
All of these local variables should be final.
All of these local variables should be replaced with 4 spaces.
All of these local variables should be used in all places.
What about using.trim()? <LINK_0> If I understand it correctly, would also allow usage of Environment Variables?
What about using.trim()? <LINK_0> If I understand it correctly, would also allow example <LINK_1>
What about using.trim()? <LINK_0> If I understand it correctly, would also allow user to allow adding _blanks_ namespace in case of no user.
Use the constant from CUSTOMIED.
Use Objects.equals() instead.
Make the method static?
Is this callback getting called on permissions only? If so, then mark this as @Nullable.
Is this really needed?
Is this callback getting called on permissions only?
you can use lamdas.
you can use lambaly here too.
you can use lamdas here too.
The parameter is marked as @NonNull.
The parameter of these are in 'create' commit.
The parameter is marked as @Nullable.
Should use HttpLogging.log(Level.KEY_ELASTIC_HOST, "9300"));
Should use HttpLogging.log(Level.KEY_ELASTIC_PORT, "9300"));
Should use HttpLogging.log(Level.KEY_ELASTIC_HOST, "9300");
why this is here?
why?
why this?
Shouldn't this be!transaction.isEmpty()?
Shouldn't this be!file.equals(transaction.getCompt())?
Shouldn't this be!file.equals(transaction.getCompt(), allExecution())?
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().equals(""); * Use a ternary operator when concatenating the strings instead of if/else blocks: java throw new Exception(tl("voiceSilencedReason") + (sender.hasMuteReason()? tl("userIsAwaySelfWithMessage")) : "
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().equals(""); * Use a ternary operator when concatenating the strings instead of if/else blocks: java throw new Exception(tl("voiceSilencedReason") + (sender.hasMuteReason()? tl("host", sender.getMuteReason())));
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().equals(""); * Use a ternary operator when concatenating the strings instead of if/else blocks: java throw new Exception(tl("voiceSilencedReason") + (sender.hasMuteReason()? tl("userIsAwaySelfWithMessage")) : "";
Please use a constant to the left hand side of the util.
Please use a constant to the left hand side of the line.
Please use a constant here.
Nit: redundant
Nit: redundant else
Companion
nit: use contigMap.get(0) instead of new Vector() here.
nit: use contig variable for the variable name
nit: use contigMap.get(0) instead of new () -> ()
I think this will throw a NPE since the httpRequest.size() will always be empty
I think this will throw a NPE since the ooKeeper subclass will throw an NPE
I think this will throw a NPE since the httpRequest.size() will always be null
It seems that the exception should be caught and handled in the finally block.
It seems that the exception should be caught and handled higher.
This should be error level.
Will it create Audit Log for every 5 minute?.
Will this schedule for every online volume?. if meta-volume exists, we might want to set the isGluster meta volume for the new volume. This way you can avoid calling this every 5 minutes. The current way, it is getting called for every online volume!
Will this schedule for every 5 minute?.
Don't think it's necessary to show the button on the 'default' button'.
Don't think it's necessary to show the button on the'replaceMode' button on the UI thread. If you just want to make sure it button works, it would be nice to have something like: new LeftRightButton_Header(searchLabel);
Don't need the leading {.
What about using a regex here?
What if the URL contains a "?path:<path>"?
What happens if the URL contains a trailing slash? Does that work?
The two if statements can be combined into one. java return (String) recipientToRecipientStatistics.computeIfAbsent(recipientTeam, recipientName, k -> new LinkedList<>());
The two if statements can be combined into one. java return (String) recipientToRecipientStatistics.computeIfAbsent(recipientTeam, recipientName, k2.getValue());
The original code was better, I think.
I'm confused why this else is needed in Slice slice. I had a block with toBlock, but now it looks like type.setSlice would be a better name.
I'm confused by why this else is needed in Slice slice. I had a block with toBlock, but now it looks like the only difference is that you can add the value to the else.
I'm confused by why this else is needed in Slice slice. I had a block with toBlock, but now it looks like the only difference is that you can add the value to the value.
Unused code.
Unused code. You could use this.
Unused code
We can use Preconditions.checkArgument to check that result is not null
We can use Preconditions.checkArgument to check that Middleware is not null
You can use Preconditions.checkArgument()
Exception
Swallowing exceptions here is bad!
Swallowing exceptions
why do you need to make this info instead of info?
why do you need to log this?
why do you need to make it info instead of info?
You should use String.valueOf() here
You should use the constant DEFAULT_PROPERTY_REN_VALUE constant instead of null here in this case.
You would have to initialize this before the loop and start the transaction. Otherwise you end up having two entries for each attribute.
To avoid sync when requestSent is called, the requestSent can still take a long time after the requestSent.
To avoid sync when requestSent is called, the metadata will be updated, correctly, be sure to keep the requestSent as is.
To avoid sync when requestSent is called, the requestSent can still take a long time (it seems to be the last node after a long period)
In both cases (collection=" and "status" are used) it will be much easier to read.
In fact, the payload is not a JSONObject, so the fact that if there is no payload, the schema main job will be ignored. This is why the condition can be removed.
In fact, the payload is not a JSONObject, so the fact that if there is no payload, the schema main operation should be executed.
1. Why do you need it here? 2. Why do you need it at all?
1. Why do you need it here? 2. Custom Properties class is used only from the first place.
1. Why do you need it here? 2. Custom Properties class is used only from the single place.
Use TemporaryFolder temporaryFolder @Rule for the test case.
Use TemporaryFolder temporaryFolder @Rule for what is needed?
Use TemporaryFolder temporaryFolder @Rule for setting journals?
suggestion return workflow.getWorkflowVersions().removeIf(workflow -> Objects.equals(workflowVersion.getName(), referencePair.getWorkflowVersions().removeIf(workflow.getName())));
Nitpick: return workflowVersion.equals(workflowVersion.getName())? null : referencePair.getWorkflowVersions().removeIf(workflow -> Objects.equals(workflowVersion.getName())));
Nitpick: return workflowVersion.equals(workflowVersion.getName())? null : referencePair.getWorkflowVersions().removeIf(workflowVersion -> Objects.equals(workflowVersion.getName())));
It would be a bit faster to sample before applying the map.
It would be a bit faster to sample before applying the map. Same below.
It would be a bit faster to sample before applying the map. Just put the result of the map.
The return value of the trace is only used for the experiment and not for the experiment.
The return value of the trace is only used for the experiment and not for the name view.
I don't think we should return the ITmfTraceElement object here. The implementation of TmfTraceElement would be the job of the trace.
Maybe use the cache.getCache(testName, data) method as well?
Maybe use the new method on CacheRegistry rather than the singleton?
Maybe use the new method call as well?
Log message should get cleaned up to remove braces.
Log message? It should get cleaned up to remove braces.
Probably should get cleaned up to remove braces.
We have to do the same thing, but we do not support the first element in the list. I think we need to define the size of the list, and use a hash to avoid the array allocation.
We have to do the same thing, but we do not support the first element in the list. I think we need to define the size of the list, and use a hash to avoid the tree creation, for the list.
We have to do the same thing, but we do not support the first element in the list. I think we need to define the size of the list, and use the iterator to do the iter, not the list.
inputSchema is not null and inputSchema is a valid schema. The return value is a boolean.
inputSchema is not null, you can use the existing converter
inputSchema is not null, you can use the existing logic.
I think it would be better to test with some more description instead of exception.
I think it would be better to throw exception with some message that the exception is thrown since it was marked as fail.
I think it would be better to test with some more description instead of exception: fail( deploymentInfo.getDeploymentInfo().get() );
Same bug: RevWalk walk needs to be released after commit, not an EGit walk.
Same bug: RevWalk walk needs to be released after commit.
From a commit message this could also be a link.
We should create a separate, generic class for this execution, since the body of the method is always the same.
We should create a separate, generic class for these cases, since the body of the method is always the same.
We should create a separate, since the body of the method is always the same.
What do you think about changing this log message to "Failed to get the event from " + _clusterName + " is not found"?
I think it would be better to keep this log in the caller's log
What do you think about changing this log message to "Failed to get the request from " + _clusterName?
If number instanceof Integer is always false, it may be faster to check if number.isNumber() is true.
If number instanceof Integer is always false, it may be faster to check if number.doubleValue() == 0 (or Math.min(bigDecimal) <= 1).
If number instanceof Integer is always false, it may be faster to check if number.isNumber() is a boolean.
The default implementation should still be permanent, right? I think if you want to make it possible to figure out why it's necessary or not? I admit it doesn't seem likely, but I think this should be throwing an IllegalStateException or other Exception instead of returning.
The default implementation should still be permanent, right? I think if you want to make it possible to figure out why it's necessary or not? I admit it doesn't seem likely, but I think it's better to make that change.
The default implementation should still be permanent, right? I think if you want to make it possible to figure out why it's necessary or not? I admit it doesn't seem likely, but I think this should be default.
Indentation is wrong from here on.
info: can't find symbol here
infof?
should be: model.isSetSsh() && model.getSsh().isSetId()
should be done via mapper of string->enum
should be: model.setSsh(model.getSsh().getSsh().isSetId())
This is not the standard way of getting the domain from the db, you should be able to use StorageDomainStaticDAO.update()
This is not the standard way of getting the domain from db, you should be able to use StorageDomainStaticDAO.update()
add space between the and the new line
Why not usebillingDate here?
Why not usebillingDate!= null?
Why "root"?
Not needed.
I think it's better to keep the original exception as it was.
I think it's better to keep the initialization of the table inside the constructor (with spaces).
It looks like trimTrailingWhitespaces() is also valid to set endIdx to 0 if endIdx is empty.
It looks like trimTrailingWhitespaces() is also valid to set endIdx to 0.
It looks like you can drop the trim altogether and just scan for that case.
I don't get the style with the rest of parameters, but seems like you're using a plain old style when there is no annotations?
I don't get the style with the rest of parameters, but seems like you're using a plain old style when there is no parameters?
I don't get the style with the rest of parameters, but seems like there is a lot of parameters while logging and execution handles this?
Why do we need this condition?
Why do we need this?
Why do we need this -1- bellow?
Related to the server reference?
Related to the commend doing this in the test?
Related to the commend doing this in the test code?
To prevent this issue, does it make sense to let the method throw the exception?
To prevent the NPE, wouldn't it be better to let the exception bubble up and fail the test?
To prevent the NPE, wouldn't it be better to let the exception bubble up to the caller?
Any reason why the logic here is different than for userData just above?
Any reason why the logic here was different than for userData just above?
Any reason why the logic here wasn't there before?
If you do the check poly.isEmpty() then you could do it earlier and if the index is met not create an array in the first place.
If you do the check polys are always created anyway, you could do it earlier and if the index is met not create an array in the first place.
If you do the check poly.isEmpty() then you could create an array in the first clause and if-InteriorRingN.isEmpty() > 0 anyway.
This is not the same as the one used in the other, you don't need this here.
This is not the same as the one used in the other, you don't need to create a local variable on every call.
This is not the same as the one on line 94. Please remove.
Isn't it easier to just do anything with the change.e()?
Isn't it easier to just do something to turn off the model?
Isn't this change needed?
It might be better to log this in the error level.
You need to check the type of thumbnail here as well, to avoid unnecessary string concatenation.
You need to check the type of thumbnail here as well, to avoid unnecessary string concat.
Did you replace this with LOG.warn("Could not retrieve rule with id %s referenced by a non-existing rule key", ruleId, RuleKey);?
Did you replace this with LOG.warn("Could not retrieve rule with @RuleKey {}"?
Did you replace this with LOG.warn?
minor: I noticed AmbryDataNode.getHostname() will print out DataNode, so you can remove Node in your log message.
minor: I noticed AmbryDataNode.getHostname() will print out DataNode, so we can remove Node in your log message.
minor: I would suggest renaming (1)currentReplicas to previousReplicaId (2) updated to (1)
Extract logic to determine index name into its own function since you could also reuse it in the delete action.
Extract logic to determine index name into its own function since you could also reuse it in the delete index.
Extract column name into a variable since you could also reuse it in the delete action.
Why is additionalNamenodes.length() necessary?
Why is additionalNamenodes being set on the variable?
Why is additionalNamenodes being checked in the loop above?
use context.getComponentId() to inject into event sender
use context.getComponentId() to inject into event
use context.getComponentId() to inject into event loop
This can be simplified to just "return current!= null" and remove the else clause.
This can be simplified to just "return current!= null" and remove the else.
This can be simplified to just "return current!= null;"
I am not sure how this worked. I expected it to go from CheckpointBarrierListenerFutures before calling advanceToEndOfEventTime.
I am not sure how this worked. I expected it to be called during first checkpoint listener. The checkpoint listener is completed then for the CheckpointCoordinator executor, but now we have to call advanceToEndOfEventTime().
I am not sure how this worked. I expected it to be called during first checkpoint listener. The checkpoint listener is completed then for the CheckpointCoordinatorExecutor.
Doesn't look like okBuf.isOK() is used for anything special.
Doesn't look like okBuf.isOK should be used here (and below).
Doesn't matter much.
Would be good to explain why the change to :wink:
Would be good to explain why the change to :P
Would be good to explain why the slightly lower-case of this?
![MINOR](<LINK_1> 'Severity: MINOR') Use a "get" method instead of "find()". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "get" local variable "content". [![rule](<LINK_0>](<LINK_2>
This is a duplicated code, can we extract it?
I would change this to: exportPage!= null? newPage.getCodecName() : null
I would change this to: exportPage!= null? bloomFilter : dictionaryPage.getCodecName();
I would change this to: exportPage!= null? newPage.getCodecName() : null;
I'm seeing this on the next line after the 'if'. Should be: if (timed == null) { timedOut = true; } else { timedOut = null; }
I'm seeing this on the next line after the 'if'. Should be: if (timed == null) { timedOut = true; } else { timedOut = true; }
Let's move this outside the synchronized block.
Why not adding this after the test?
please remove.
Why not just move this into the fail method?
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
Both of these work the same at the moment, but it would probably be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
Both of these work the same at different levels, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
It looks like we could have srtpManager.close() to clean up the stream state after the call to acquire the streams.
It doesn't look like we'll have to do this. It doesn't have to be inside the if I don't spot the stream in the file...
It doesn't look like we'll have to do this. It doesn't have to be inside the if I don't end up with the same name as before.
We don't need to do this in the constructor.
We don't need to do this.
We don't need to do this in the constructor, can we just use a local variable to reduce GC
TopologyLock is not needed here
check topology id before creating the new version
same here, this is not needed
@inverno We should still take advantage of the "name" variable. This is not going to work at all in this PR.
@inverno We should still take advantage of the "name" variable. This is not going to work at all in this PR!
@inverno We should still take advantage of the "name" variable. This is not needed at all in this PR.
Use Sets.newHashSet rather than new HashSet<LogEntry>(creator)
nit: can you move this to a method and then use it here?
nit: can you move this to a constant
Wondering if we need to clean the folder when the test is done?
Wondering if we need to clean the file when the test is done?
Wondering if we need to clean the folder when the test is executed?
Does not handle entry being removed or not modified.
does not handle entry being removed or not modified.
==
Do you think this is necessary (and not.now().plusDays(7);
Do you think this is necessary (and not.now())? It would be good to have this in the next method though.
Do you think this is necessary (and not.now())? It would be good to have this in the next method if you can.
compareTo should not return an int, shouldn't it?
compareTo should not return an int, shouldn't it? <LINK_0>
compareTo should not return an "id" in the response. <LINK_0>
not sure if this is required. you should assume that the client cert file is not associated with the password.
not sure if this is required. you should assume that the client cert file is not associated with the certificate.
spaces
The exception should be logged as a warning
Result in the Exception?
The exception should be logged here too!
Another example of setting null before loading...
If you want to keep the first element within the list then you can get rid of the null check.
If you want to keep the first element within the list then you can get rid of the first element.
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts. Or if this setMembers contain the unretired concepts.
Can you confirm that those four Concepts have the same code? You should prove that this setMembers contain the unretired concepts.
Shouldn't these be else if?
Shouldn't this be else if?
Shouldn't these three lines be part of the else?
This should be shared with other tests. It's possible to use a shared helper method to get the metadata.
This should be shared with other tests.
This should be shared with the other test methods.
Wondering why this needs synchronized?
Wondering why synchronized?
Wondering if we should catch RuntimeException here.
This code block should be using the currentCard from utils
This code block should be in new line
remove
that's more readable to put each line to a separate method: java Argument fullArg = prettyArg.GREEN;
that's more readable to put each line to a separate method: java Argument fullArg = prettyFormatter.GREEN;
that's more an error message, maybe just the line AnsiEscapes.GREEN or similar?
I know this is just a refactor, but please remove the return...super.tearDown() still needs to be called at the end.
This is wrong; you're returning before calling super.tearDown() at the bottom of the function. Express this more directly: if (mHasWifi) { //... the rest of the wifi-specific teardown... } super.tearDown();
I know this is just a refactor, but please remove the return...super.tearDown() still needs to be called at the bottom of the function.
gaps is not null?
gaps is not null.
gaps is null, truncated?
I would suggest to swap the order of these checks, for example, this: <LINK_0>
I would suggest to swap the order of these two checks, for example, assertTrue(super.equals(obj))
I would suggest to swap the order of this.equals().
What about extracting aliasConfig as a constant?
What about pulling with the same aliasConfigDef variable?
What about pulling with the same alias part?
Is it really needed, as partService.hidePart(part) never returns null
Is it really needed, as partService.hidePart(part) is always false
Is it possible to be in the partService? I would expect it to be inside of the if, and return true here
Again, the local variable ListDataProjectListDataProjectList should be renamed to listDataProjectDataProject
Again, the local variable ListDataProjectListList should be renamed to listDataProjectDataProject
Again, the local variable ListDataProjectList should be renamed to listDataProjectDataProject
if (zoneStrings == null) { return null; }
if (zoneStrings == null) { return null; } String[] zoneStrings = new String[len]; int len = zoneStrings[i].length(); return zoneStrings;
why is this new String[]?
We need to check if oldData is not null here, since we will skip old data
We need to check if oldData is not null here.
We need to check if oldData is not null here, since we will skip anyways.
Because we're not using the subscribe() functionality, we don't need to configure a consumer to use a null value. We can use the org.apache.commons.lang3.StringUtils.isNotEmpty() check instead
Because we're not using the subscribe() functionality, we don't need to configure a consumer to use a null value. We can use the org.apache.commons.lang3.StringUtils.isNotEmpty() check instead.
Because we're not using the subscribe() functionality, we don't need to configure a consumer to use a null value. We can use the org.apache.commons.lang3.StringUtils.isNotEmpty() here.
I am not sure where does the snapshot get fired from the snapshot?
I do not think this is what I want. The Error code does not seem to be for generic errors.
I do not think this is what I am asking.
See above, I think this can be replaced by java return loadedModel.get(config.getSparkContext().getSparkContext().getSparkContext().build());
See above, I think this can be replaced by java return loadedModel.get(config.getSparkContext().getSparkContext().getSparkContext().empty();
See above, I think the lack of this line is the same as the inputField.
Why not move these in a for loop?
Why not move the same logic into a separate method for all 3 nodes?
Why not move the same logic into a new function for all 3 nodes?
nit: same here, should be RepositoryEventTypeEnum.EVENT_RESH_FOR_ALL_TRASH_FOR_ALL_WORKSH_FOR_ALL_TRASH_FOR_ALL_WORKTREE
nit: same here, should be RepositoryEventTypeEnum.EVENT_TRASH_FOR_ALL_WORKSH_FOR_ALL_TRASH_FOR_ALL_TRASH_FOR_ALL_WORKTREE
nit: same here, should be RepositoryEventTypeEnum.EVENT_RESH_FOR_ALL_TRASH_FOR_ALL_TRASH_FOR_ALL_WORKTREE
Please move this block to a private method called toString() to the end of the class.
Please move this block to a method called verifyAndOpenBlock(), so that the value of the queue is located in the initialized list.
Please move this block to a private method called toString() to the end of the file.
Do you need to remove this line? I think that at this point it wont work if the special case is not covered.
Do you need to remove this line? I think that at this point it wont work if the special case is applied.
Do you need to remove this line? I think that at this point it wont work if the specializingBean is not null.
return true might be a bit more straight-forward and you'd save yourself one variable
return true might be a bit more straight-forward and you could save yourself one variable
return true would be a bit more straight-forward and you'd save yourself one variable
[minor] Space before {?
[minor] Space after if
[minor] Space before {
same....I'd be happy to use Unchecked.wrap() without wrapping the rest.
same....I'd be happy to use Unchecked.wrap() without wrapping the exception.
same....I'd be happy to use Unchecked.wrap() without closing the statement.
waitCondition.getText() instead.
waitCondition.getText()
debug
@ochaloup, I would have expected the ts down below, which is what I would expect. You need to move the ts.get() check after the xidsToRecoverForParent() call.
@ochaloup, I would have expected the ts down below, which is what I would expect. You need to move the ts.get() check after the xidsToRecoverForParent() check.
@ochaloup, I would have expected the ts down below, which is what I would expect. You need to move the ts == null check inside. I would say what is the tsrts check here, but I am not sure if there is any change in behavior.
Why catch and then catch here? What's the other catch?
Why catch and then catch here? What's the reason I think?
Why catch and then catch here? What's the reason for catching the exceptions?
I don't think it matters, but it seems that this test has any value.
I don't think it matters, but it seems that this test has to be written with a Map
I don't think it matters, but it seems that this test has to be written with a Map rather than a Map
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent() here.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: We can just no declaration.getParent().getParent() here.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on this line.
This feels like a good behavior... The only thing I can see is that the test would be in a teardown() method, which is called after the test.
This feels like a good behavior... The only thing I can see is that the test would be in a teardown() method, which is called after the test. If its the case, it might be perhaps cleaner to move this into a teardown() method and remove the tearDown() from the finally block.
This feels like a good behavior...
Can you explain this?
Can you explain a bit more how the request works?
Can you add a space for the param?
Is it possible that this could be null?
Is it possible to use taskInfosPerJob? It could be more generic.
Is it possible that this could be null? I think that we don't need to check for it.
SAPConstants.TRANSPORT_SAP_EXT
SAPConstants.asMap_VERSION_SAP_bc
SAPConstants.asMap_VERSION_SAP_EXT
I think it would be better to use constants.
I think it might be better to use constants.
I think it might be better to give a more user friendly name for some reason.
This should be for(String downloading) ); to be like the rest of the file.
This should be for(String downloading) ); to be like the rest of the method.
This should be for(String downloading) ); to be like the other method.
getting the same metrics on both cases
getting the same metrics on both cases?
getting the same metrics on both cases.
avoid to call to removeNotificationListener
add a null check for those 2 elements
reverse
Please add a null check, cause NullPointerException if filter is null
Please add a null check, cause NullPointerException when filter is null
I wonder if it is worth to add a null check, and throw an exception if filter is null
I think we could use the lastName field here instead of the string.
I think we could use an NPE here here...
I think we could use the lastName field here instead of a string.
Grate! I think we don't need an if (file!= null) any more after this.
Grate! I think we don't need an if (file == null) any more after this.
Can we change this to the UncheckedIOException instead? There is really nothing to do with the messaging...
Catching Exception is too broad here.
Catching Exception is too broad -- that it catches OutOfMemoryError.
Identification of the hyperLinkify are there. The jira issue is that it's only for a DlmsUtils.getFileExtensionString().
Useless extra line
Useless extra line.
Useless line
nit: wrapFactory.createInternalHiveSplit(path, directory, format)
static import formatFactory
static import
new ArrayList<String>(revision) looks better.
new ArrayList<String>(revision) is always used.
Don't use 2 options.
the request is not needed.
the request is not null
the request is not null!
I think this should have a label for the index. Otherwise, it's only updated as one index.
I think this should have a label for the index. Otherwise, it gets mapped to something that is confusing.
I think this should have a label for the index. Otherwise, it may be confusing to debug.
Please correct me if I'm wrong.
Please make sure to have a blank line, please.
Please make sure to have a blank line, please
when would this happen and if it happens then the window will simply have progress indication and actually nothing will happen
This appears to me to be a redundant check as it is already done in line 119
when would this happen?
Better to use equals to compare string
Better to use equals on enum
Better to use equals to compare strings
Please use vx instead of ((I would have added a cast)
Please use vx instead of r
Please use vx instead of r...
I would use that instead of System.getProperty method.
I would throw instead of just RuntimeException
I think it should be debug
This test seems to be unnecessary for the SuppressWarnings("unchecked").withPayload(out).
This test seems to be unnecessary for the SuppressWarnings("unchecked") below.
This test seems to be unnecessary for the SuppressWarnings("unchecked")...
I'm thinking that this should be moved to the resource instead of pulling the list from the properties. We can merge this with the one below.
I'm thinking that this should be moved to another 'else' part of Startable After all the logs to be merged into one. Do we need to change the log message?
I'm thinking that this should be moved to another 'else' part of Startable After all the logs to be merged into one. Do we need to change that?
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think I would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/* urls and only try <LINK_0>
please split this method into two separate methods.
we can have a different order than the previous setting so that we process the correct ordering if we use the test order.
we can have a different order than the previous setting so that we process the correct ordering if we use the test ordering
JUnit asserts would be even better, as it fails on the class.
JUnit asserts would be even better, as we are using string formats. Please remove the method.
JUnit asserts would be even better, as we are using string formats. Please remove the declaration.
I think you should use the same message as above if (exceptionExpression == null) { if (exceptionExpression.is(Tree.Kind.exceptKeyword()) { throw new RuntimeException(ctx, "Merge"); }
I think you should use the same message as above.
I think you should use the same message as above if (exceptionExpression == null) { this.elements = null; } else { //... }
Same as above: java conf.setController(new ControllerConf());
Same as above: java conf.setController(System.getenv("localhost: conf.get(i))
Same as above: java conf.setController(System.getenv("localhost: conf.get")
what if there's no StandardCharsets.UTF_8?
what if there's no String defined?
what if there's no default charset?
getString("category.getString("title")) can be replaced by getString()
getString("category.getString("title")) is repeated 4 times. Use a function.
:p
if the store is null, should we check it?
pass the exception as the second parameter to shutdownBlobStore.
pass the exception as the second parameter of Exception
I think here we should use invokeMethodWithoutException() as this is more specific to a server error
I think here we should use invokeMethod instead.
I think here we should use invokeMethodWithoutException() as this is more specific to a runtime exception
You can use the lambda expression but I think java if ((keyHandler.getoomManager() == null) { return; }
You can use the lambda expression but I think java if ((keyHandler.getoomManager() == null) && getL.getoomManager().registerContextMenu(contextmenu, 2)) { return null; }
You can use the lambda expression but I think java if ((keyHandler.getoomManager() == null) && getL.getoomManager().registerContextMenu(context)) { return; }
On a local branch of mine I have already removed the remove method of CoreRegistry. That you remove it here is a sign that it shouldn't be in the CoreRegistry for the first place.
On a local branch of mine I have already removed the remove method of CoreRegistry. That you remove it here is a sign that it shouldn't be in the CoreRegistry for the first place. If you need a Context that contains objects only temporarly then you can create a child context via Registry for the child context.
On a local branch of mine I have already removed the remove method of CoreRegistry. That you remove it here is a sign that it shouldn't be in the CoreRegistry for the first place. If you need a Context that contains objects only temporarly then you can create a child context via Registry for the actual folder.
Does this print exception? If so, it should be logged somewhere
Better to use log4j
Better to use log4j.
That needs to use maskedSelectionFlags too.
That's not the right place to use maskedSelectionFlagsScore => mHasLanguageScore
That's not the right place to use maskedSelectionFlagsScore. It should be getFormatTextLanguageScore.
I don't think it's safe to call this from the reader, especially when something gets added to the writer. Have you tested this with the following? java String binarySubPath = Optional.ofNullable(CdrBinarySubPath.getHeader(CdrBinarySubPath));
I don't think it's safe to call this from the reader, especially when something gets added to the writer. Have you tested this with the following? java String binarySubPath = Optional.ofNullable(derivativeSubPath).map(String::valueOf).collect(Collectors.joining("\n")); I'd probably also like to consider whether there's some property with the value of the binarySubPath somewhere, or even better, to make it configurable as well.
I don't think it's safe to call this from the reader, especially when something gets added to the writer. Have you tested this with the following? java String binarySubPath = Optional.ofNullable(derivativeSubPath).map(String::valueOf).collect(Collectors.joining("\n")); I'd probably also like to consider whether there's some property with the value of the binarySubPath + " in ".getBody()." (you'd probably need to add the file header in the reader).
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return. This avoids too "deep" nesting.
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return in the if. This avoids too "deep" nesting.
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return in the if. The code is uncovered by the "if" branch which is difficult to understand.
While I understand your question, I would suggest getting rid of the two lines above and adding parenthesis for clarity.
While I understand your question, I would make it so that you don't have to specify the path in the mapInfoBean. That way, it is not possible to use two different providers for the same approach.
While I understand your question, I would make it so that you don't have to specify the path in the mapInfoBean. That way, it is not possible to use two different providers for the same attribute.
U.logHandshakeNeeded() sounds a bit like a method name, but it's a good idea to rename what's happening here.
U.logHandshakeNeeded() sounds a bit like a method name, but it's a good idea to rename what's going on.
U.logHandshakeNeeded() sounds a bit like a method name, but it's a good idea to rename what it's doing.
Instead of re-initializing everything, we should be fine here as well
Instead of re-initializing everything, we should be able to have the lock held by the listeners or let the client know about this.
Instead of re-initializing everything, we should be able to have the lock held by the listeners.
For errors I would recommend to rename "Connection for project" to "r"
For errors I would recommend to rename "Connection for project" to " which will make it clearer
For errors
toString() is unnecessary
toString() is unnecessary here.
toString() is unnecessary here
index + 1? (it seems not a bit weird)
index + 1
index + 1?
Can you do the same thing as the one above on L380's resolve failure cases
Can you do the same thing as the one above on L391?
Can you do the same thing in the else here.
Needs a space after the comma.
Was this change intended?
imo we should be using a builder here instead of java.build(true)
almost same for all the test cases. #Closed
almost same for all the test cases? #Closed
almost same for all the change in this file
Do you think it makes sense to check configDetails if sslQueryTimeMS is null? There may be a configDetails when configDetails is null.
Do you think it makes sense to check configDetails if sslQueryTimeMS is missing?
Do you think it makes sense to check configDetails if sslQueryTimeMS is not null? My main concern is that if configDetails is null we'll catch a NPE.
The operation is a bit confusing, I don't understand why we needed to clear region state. This is an internal state, but the procedure might be running. Not sure what was the right thing to do.
The operation is a bit confusing, I don't understand why we needed to clear region state. This is an internal state, but the procedure might be running. Not sure what was the right thing to do. What if the regionNode is in the Master, but the Master has been stopped? Do we want to remember that?
The operation is a bit confusing, I don't understand why we needed to clear region state. This is an internal state, but the procedure might be running. Not sure what was the right thing to do. What if the regionNode is in the Master, but the Master has been stopped? That is, we don't have any servers to use it.
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the title to null here and removing the need for the trim logic.
Thanks for refactoring this method
Thanks for refactoring this method, I prefer to define the code as a String array.
should be tried to find the usage languages (e.g. layOutUsage() vs getUsages() + ">=" + usageView.getUsages();
should be tried to find the usage languages (e.g. layOutUsage() vs Advisor())
should be tried to find the usage languages (e.g. layOutUsage() vs getUsages() + ">=" + usageView.getUsages());
is there a reason why this has to be public?
is there a reason why this was added?
is there a reason why this has to be public?
To be consistent with other change, can we merge these two if conditions?
Please remove 'this'.
Please, move this to after line 50
remove?
remove "set member" and simply addPolicyRemoved(member)
remove "set member"
I would suggest to rename it to _public_
I would suggest to name it as _else_
I'm not sure it is better to use java.util.List<T> enum.
This is similar to the other list, will add all fields to the list
This is similar to the other list, will add all fields to this list, which will perform some extra logic on the list
This is similar to the other list, will add all fields to the list if the argument does not contain any fields.
Can you add a \n after the comma?
Can you add a \n after the comma? I think this would be part of the exception message
Can you add a \n to the error message?
I'd prefer keyType.equals(keyType) to make the code more readable.
I'd prefer keyType.equals(keyType) to make sure the keyType is not missing.
I'm not sure why you didn't use keyType.equals here.
Why not retrieve the addAll on the table? You only need to call update in one place.
Why not retrieve the addAll on the table? You only need to call it once, right?
Why not retrieve the addAll on the table?
Collections.emptyList()
Collections.emptyList() is cleaner
This should be a private static final
do it in one line
use CollectionUtils.isNotEmpty
I think this should be equals
I am just not 100% sure why the conversion to BigInteger is needed here.
I just noticed this and I am wondering why the conversion to BigInteger is needed here.
I am just not 100% sure why this is needed here.
@cuenyad Is it worth performing this validation? (int)
@cuenyad Is it worth creating a constructor for this case?
@cuenyad Is it needed?
Could we use try-with-resources here?
Please use try-with-resources instead of closing manually
Can we use try-with-resources here?
Uh, I see. :)
Uh, I'm not sure we should change this.
Umm... I'm not sure this should be moved to the first commit.
I would suggest to simplify it to java String specificOffsets = tableOptions.getOptionalString(); String specificOffsets = formatOptions.getOptional(SCAN_OFFSETS, long.format("Invalid value for option '%s' but was %s", option)); //NON-NLS-1 //NON-NLS-2
I would suggest to simplify it to java String specificOffsets = tableOptions.getOptionalString(); String specificOffsets = formatOptions.getOptional(SCAN_OFFSETS, long.format("Invalid value for option '%s' but was %s", SCAN_OFFSETS,...)
I would suggest to extract this logic into a method, e.g. validateScanStartupMode(String::toLowerCase)
According to exactly <LINK_0>, there is no guarantee that the same ava damage can be used for both tests.
According to exactly <LINK_0>, there is no guarantee that the same ava damage throws an exception.
This is incorrect. We need to validate that the same time is set to max time.
nit: move these changes to AnnotationProcessors as suggested before
nit: move these two lines to a function so we can reference the method directly on the Stream api.
nit: move these changes to AnnotationProcessors as suggested before merging this PR.
redundant line
remove this, it's not RUNNING or REP_ide
remove this line
if there is a style element in the list: this is not a DRepresentationElement, nor a semantic element...
if there is a style element in the list: this can be null.
if there is a style element in the list: this is not a DRepresentationElement.
Please change a static import to tick as it was previously.
Please change a static import to tick as this was previously.
Please change a static import.
This is not guaranteed if the user is doing this wrong, it needs to be the default value, not the other way around.
This is not guaranteed if the cache is doing the same as the default constructor, otherwise this will throw an NPE if it is null.
This is not guaranteed if the user is doing this check.
It might be a little cleaner to use SUM rather than _aggregationType == null && propertyPath.getType() / AggregationType.MAX;
It might be a little cleaner to use SUM rather than _aggregationType == null && propertyPath.getType() / AggregationType.MIN;
It might be a little cleaner to just return here, to avoid double nesting.
I am not sure why this is needed
I am not sure we need this lock.
please keep the doc
There is no need to use the same name in the function. Just return family.names().toLowerCase()
There is no need to use the same name in both if and else. Just return true.
There is no need to use the same name in both if and else. Just return.
You probably need to pass this to some local variable so you can use some method to this method.
You can use some method to pass this to some private method.
You probably need to pass this to some local variable so you can use some local variables for this.
addAll
Missing @Override
Missing @Override.
This seems inconsistent. the methods are already configured with a fallback that looks for the Could not find a fallback string. Why should that be treated in the fallback and this message in the error handler? And... are there really two different messages to describe the same error?
This seems inconsistent. the methods are already configured with a fallback that looks for the Could not find the path... and this message could be confusing. Why should we have the fallback and a fallback string? And... are there really two different messages to describe the same error?
This seems inconsistent. the methods are already configured with a fallback that looks for the Could not find the path... and this message could be confusing. Why should we have the fallback and a fallback string?
Why change to create?
Why?
clone
This can be just List<IProject>
This can be just List<Resource>
This can probably be just List
Formatting
left this line
Formatting issue
I may suggest just do: if (m.getDelivery() > 0) {... }
I think it is OK in this case, but it shouldn't be allowed to bubble as "queue" is an exception. Just a suggestion.
I think it is OK in this case, but it shouldn't be allowed to bubble as "queue" is an exception. Just a suggestion to ensure noConsumer will be thrown.
Maybe Log the exception as a second parameter?
Maybe Log an error here?
Maybe Log the exception as a second parameter?
what about multiple storage domains?
what happens if you have disks on a destination cluster?
what's the point of having this method?
What is the advantage of workDir() here? Can we reduce the number of returns at the same time?
What is the need for this change?
What is the advantage of workDir() here?
Parentheses formatting.
rename to'removed' or something (more specific)
rename to 'no' or 'assigned'?
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
You could keep this declaration after the throw Exception, so you don't do it if the column has to be set to false. Or maybe you could do it if (left.equals(last))
You could keep this declaration after the throw Exception, so you don't do it if the column has to be set to false. Or maybe you could do it if (left.equals(last)) { throw Exception; }
Nice idea to have:+1: for the SQL string with anything else, I think it might be better to use the SQLDatabaseUtils. SQLDatabase() for that.
Nice idea to have:+1: for the SQL string with the SQL string "revid"
Nice idea to have:+1:
Missing final
Use Ds3DocSpecEmptyImpl
use Ds3DocSpecEmptyImpl
Objects.equal()?
Objects.equal(widget, other.blah) returns false if CounterArtifact is not Comparing. That is a bit strange to use equals().
Please use Objects.equal()
can we make this more readable something like Total running and waiting tasks [], Maximum compaction queue capacity []. Thanks
can we make this more readable something like Total runningCompactTasks = 0, stats.size() * dynamicConfig.getCoordinator().getCoordinator().stream().filter(p ->!partitions.isEmpty()).findFirst().orElse(null);
can we make this more readable something like Total runningCompactTasks = 0, stats.size() * dynamicConfig.getCoordinator().getCoordinator().stream().filter(IntegrationTasks::getCoordinator).findFirst().orElse(null);
It is strange that you have _allTasksCount = 0 when there are no tasks to be _streamTask.get(unAssignedTaskIndex %d), numberOfTasksPerInstance - _distinctTasksPerInstance_ is only used for the indexing boundary and you don't need to update it.
It is strange that you have _allTasksCount = 0 when you use a <>. However, if you find a better name for this field, you can still use it as a regular ArrayList for the task that contains _allTasks and you don't have to bother with a random random number of tasks.
It is strange that you have _allTasksCount = 0 when you use a <>. However, if you find a better name for this field, you can still use it as a regular ArrayList for the task that contains _allTasks and you don't have to bother with a random assignment on each iteration.
Missing white space after the bracket.
Missing each bracket in the?
Missing each bracket in the if.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder?
Is this the recommended way in the system is to call this from the TestXAResourceRecovery?
Is this the recommended way in the system is to call this ms
why not using z <= bPlayer?
Is there a special reason for using  here?
I think this might be cleaner to use z <= bz - z
Does it make sense to add a constant for KafkaFuture? Or could it be just as well?
Do we want to add a message to the KafkaFuture? Or could it just be a property?
Does this method need to be synchronized? Or is it thread-safe?
This method is very similar to testTopic(). It should be created in Topic().
This method is very similar to testTopicDetails. We should create a separate class for each test.
This method is very similar to publish()
You can replace ksession.insertAllRules() with ksession.insertAll().
You can replace ksession.insertAllRules with ksession.insertAllRules().
You can replace this if with assertEquals(expected, actual).
not sure how this line was added here - this initialization is done in line 67 and needs to be removed.
not sure how this place is added here - this initialization is done in line 67 and needs to be removed.
not sure how this exception is caught here - this initialization is done in line 67 and needs to be removed.
Can we put this into a private method please?
Can we put this into a private method to improve readability?
Can we put this into a private method to reduce code duplication?
1. Why the map isn't static? 2. Why the map is not static method?
1. Why the map isn't static? 2. Do you need to use toString() for this?
oh, I see. So, you're copying the map to an array? Don't use toArray()?
shouldn't we remove that else block?
else if (compareTime < compareTime) { above
else if (compareTime < compareTime) { above above?
switch/case?
switch/case? same for other fields?
switch/case? it feels unsuable
Please use the static import for String.format.
Please use Guava's [StandardCharsets.UTF_8 instead of new URIBuilder().setPath(class.getName())
Please use the static import for Strings.nullToEmpty
Slightly more. :smile:
Slightly unrelated, but as you remove this, the if is not necessary.
Slightly unrelated, but the selection listener should not be added to the SWT.CHECK
Duped code. Any way of sharing?
Duped code. Why not just join them in util?
Duped code. Why not just throw an exception?
[optional] List<LINK_0>
[minor] List<JobView>?
[minor] List<JobView>
I think throwing this out will still kill the startup process. Would it be better to use the log level of the exception here?
I think throwing RuntimeException is sufficient here since the code doesn't actually throw the exception.
I think throwing RuntimeException is sufficient here.
will be better to assert the fact that.stream() is not null
will be better to assert the fact that'manuel' is not null
will be better to assert the fact that'manuel' is not zero
Why do we need to explicitly call ProcessorContext.getStateStore(Thread.currentThread().getName()) twice?
Why do we need to explicitly call ProcessorContext.getStateStore(Thread.currentThread().getContext())? It would be much cleaner if we just passed in through the constructor.
Why do we need to explicitly call ProcessorContext.getStateStore(Thread.currentThread().getContext())? It would be much cleaner if we just pass in the context here.
You need the "temp" name here, as you're just going to use it.
You need the "build" method to avoid the old value > 0 as well.
You need the "build" method to avoid the old value > 0 as you do in the constructor.
We can't need to hide the information from the PrefManager class.
We can't need to hide the information from the PrefManager.java into variables.
This is can be removed.
The actual fix is this alone right?
The actual fix is here, right?
The actual fix is here, no matter what. This boolean indicates that it's really a problem, but it seems redundant.
Use File.separator instead of.
Use File.separator instead of "/"
Use File.separator
Just curious.. shouldn't this be reversed? I'm not sure if there is any difference in the original code. If you want to keep the original way, you may need to write a test that calls arrayAccounts on the same account.
Just curious.. shouldn't this be reversed? I'm not sure if we want to keep the original value. It may be worth creating a ticket to improve the readability of the code.
Just curious.. shouldn't this be reversed? I'm not sure if there is any difference in the original code. If you want to keep the original way, you may need to write a test that calls arrayAccounts on the same thread.
The service is not used for this test, is it intentional?
The service is not used for this test, which should be deleted
The service is not used for this test, which should be deleted here.
I think you meant LOGGER.debug("No rootLogger exception.");?
I think you meant LOGGER.debug("https", rootLogger call.
I think you meant LOGGER.debug("https", COMMIT USERNAME)?
do not remove this
do not use this
do not use hardcoded values
Add a severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Add a severe logging message here describing the issue to server owners (and maybe tell them them they will need to downgrade for now).
Add a severe log message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Now you can use the index
Now you can use index instead of addAll
Now you can use index instead of index
Optional: there's a preconditions check.
Optional: there's a deterministic way to detect the exception.
Optional: theres a preconditions check.
@vilchik-elena why are we not assert on both cases?
@vilchik-elena why do we need both tests?
@vilchik-elena why do we need a class field?
Since the Parser has a UndefinedPropertyException, we need to catch the case where the name of the query parameters are mapped.
Since the Parser has a UndefinedPropertyException, we need to catch the case where the message is wrong.
Since the entityClass need to be a separate line, it seems like this should be entityClass
Not sure how this is related, but if you've changed that, probably don't want to be the best way to do this. :+1:
Not sure how this is related, but if you've changed that, probably don't want to be a bug.
Not sure how this is related, but if you've changed that, probably don't want to be the best way to do this.
This should be in a finally block. Otherwise the caller might see an NPE.
This should be in a try-with-resource block. Otherwise the caller might see an NPE.
This should be in a try-with-resource block. Otherwise the caller might see the updated merge status before this close() call.
This looks unrelated to the commit.
This catch block is too long. Line wrap would be a bit better.
This catch block is duplicated below.
You need to set this to null by id, you don't need to make sure that they are the same
You need to set this to null by id, you don't need to make sure they are the same
You need to set this to null by id, i.e dateRetired, retiredBy, retired
Don't bother, but you can put this in a try/finally block to make sure that resources are closed.
Don't bother, but you can put this in a try/finally block.
Don't bother.
Isn't there a related change here?
Is there a specific reason that we are returning in this method?
Is there a reason we are performing this same check twice?
why not: boolean ret = false; try( Connection connection = ds.getConnection(); PreparedStatement prepareStatement = connection.prepareStatement(selectQuery); ) { prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try (resultSet = prepareStatement.executeQuery()) { if (resultSet.next()) { ret = true; } } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
why not: boolean ret = false; try( Connection connection = ds.getConnection(); PreparedStatement prepareStatement = connection.prepareStatement(selectQuery); ) { prepareStatement.setString(2, domain); try (resultSet = prepareStatement.executeQuery()) { if (resultSet.next()) { ret = true; } } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
why not: boolean ret = false; try( Connection connection = ds.getConnection(); PreparedStatement prepareStatement = connection.prepareStatement(selectQuery); ) { prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try (resultSet = prepareStatement.executeQuery()) { if (resultSet.next()) { ret = true; } } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will add LocalConfig to uutils.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "projectStore". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_1>](<LINK_0>
else if on line 1 above, then maybe we could remove the nesting.
You could also use && instead. <LINK_0>
You could also use && instead.
How is this change necessary?
Why not createNetwork?
Can you explain this code to?
Replace passenger!= this with!Objects.equals(passenger, this)
Replace passenger!= this with Objects.requireNonNull(passenger, this)
Replace passenger!= this with!Objects.equals(passenger, this);
Why do we need this change?
Why do we need a separate listener here?
Why do we need both of these fields?
We should unify the logic to tell the progressBar visibility. This is set in the instance.
We should unify the logic to see that the progressBar visibility is set.
We should un-use the TTL of the controls.
suggestion log.tracef("L1 in progress");
suggestion log.tracef("L1 in progress : " + key);
suggestion log.tracef("L1 invalidation can occur", key);
I think you should put the label into a constant because you can use it here.
I think you should refactor this message, so the information is updated at all.
I think you should put the label id in a constant, so you can remove it
throw new IllegalStateException("page is null");
output row group is not used
throw new IllegalStateException("page is not supported");
Shouldn't this be just "else"? Also, and below
Why is this just a warning?
Needs a null check for the current id.
This would probably be a good time to change this to fire exception as the user would not like this. I am not sure if this should cause the exception to be thrown out of the box.
This would probably be a good time to change this to fire exception as the user would not like this. I am not sure if this should cause the exception to be thrown out of the box here, but if we change the level at this point it doesn't show up.
This would probably be a good time to change this to fire exception as the user would not like this. I was hoping we could not lose the stack trace of the exception.
Same. Should this be HTTP?
Same. Should this be HTTP instead?
Same. Should this be HTTP status?
possible exception!= the 2nd parameter should be checked.
possible exception is thrown here?
lo assertArgs even?
Would be good to have a switch statement instead of an if/else
Would be good to have a switch statement instead of these two.
Would be good to have a switch statement instead of these separate ifs.
merge with the previous line
merge into the previous line
merge into this line
Can you please use equals instead of!=?
I wonder why this is false. Can't you return true?
Can you please compare the class names here?
Can we extract this code to some method?
Can we extract this code to a method for the stages?
Can we extract this code to some helper method?
Note that this constructor is public API, so you could use the following signature: Validate.notNull(schemaXml, "invalid Solr schema file, " + schemaFile);
Note that this constructor is public API, so you could use the following: this(schemaXml, null, schemaXmls, "invalid Solr schema file,...");
Note that this constructor is public API, so you could use the following: this(schemaXml, null, schemaXmls, "invalid Solr schema file,...") -> this.schemaXmls);
As before, this is shared code with File..CompareEditorInput. Shared superclass?
As before, this is shared code with File.CompareEditorInput. Shared superclass?
As before, this is shared code with File..CompareEditorInput. Shared superclass.
refundHistoryId={}] [refundHistoryId={}] [refundHistoryId={}] [refundHistoryId={}]", refundHistory.getExternalId(), refundHistory.getStatus(), refundHistory.getExternalId());
You've said that historyEndDate can be null. Why the change from historyStartDate?
refundHistoryId={} was updated from refundHistory.getExternalId(), refundHistory.getStatus()
What is the reason behind this change?
What is the reason of this? log.info("Error in Kafka Consumer from topic " + m_args + " is not a Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from Kafka Consumer from scheduler");
Do you need this at the top?
I think APPLICATION_SECURITY_DOMAINS should only be used when the file is created.
I think APPLICATION_SECURITY_KEY should only be done when the file is created.
I think APPLICATION_SECURITY_DOMAINS should also be used.
do we need the case insensitive checks?
do we need the special case for min.equalsIgnoreCase here?
should be optimized to the caller of this.equalsIgnoreCase here.
I think "nestedValueIndex" is always using String.format. It would be simpler if you used "nestedValueIndex" for you.
This cast looks unnecessary?
This cast looks unnecessary.
It is hard to distinguish between default value of DEFAULT_LOOKUP_ORDER_SOURCE_MONITOR_INTERVAL - STREAMING_SOURCE_MONITOR_INTERVAL);
We can set the default value of DEFAULT_LOOKUP_ORDER_SOURCE_MONITOR_INTERVAL to 'latest' and get rid of the DEFAULT_LOOKUP_ORDER constant.
It is hard to distinguish between default value of DEFAULT_LOOKUP_ORDER_SOURCE_MONITOR_INTERVAL.
Typo? "-regtest/"?
Typo? "Y"?
Typo? "Yshould be "?
suggestion if (isPaused) {
suggestion if (isAppReady()) {
suggestion if (isPlayer()) {
tissueOrigin is not set here. This should be set by tissueOrigin
I think we should add a check tissueOrigin before setUpdatedBy
tissueOrigin is not set here. This should be set by Agent.
In this case I think it might be nice to pass the task into the log.
In this case I think it might be nice to go ahead and merge these into one log.
did you mean "For" here?
Use Guid.isNullOrEmpty
NGuid.toString() could be replaced with Guid.isNullOrEmpty
Consider to use Guid.isNullOrEmpty
why did you change the equals to a NON-NLS
why did you add this param? It will be consistent with the cmd.
why did you add this param? It will be consistent with the other commands.
nit: I think it's unnecessary to make these methods public
nit: I think it's unnecessary to make these methods public, since they are only used in tests
nit: I think it's unnecessary to make these methods public, since they are the same for every new test
I think it would be easier to build cause of AmbiguousSymbolImpl all this time.
I think it would be easier to build cause of AmbiguousSymbolImpl all we want to replace.
I think we should replace the 'private' visibility by 'TheSymbols'.
We are going to synchronize on the channelProxy while we are still doing the same. It might be better to move the openConnection() call into the ChannelProxy constructor.
We are going to synchronize on the channelProxy while we are still doing the same. It might be better to move the openConnection() call into the ChannelProxy rather than through a separate method.
We are going to synchronize on the channelProxy while we are still doing the same. It might be better to move the openConnection() call into the ChannelProxy constructor (without to extra if check) so we don't have to be extra careful reading
Remove from local cache. Publish.
Remove from local cache. Publish. This seems to be used from other place.
Remove from local cache. Publish. This seems to be used from other places.
This seems to produce warnings if the same "instanceof" warning.
I would prefer to return the field.
I would prefer to return the field directly.
this is a larger change. if I handle the case with exception but wrap it with another exception that then causes an exception.
this is a larger change. if I handle the case with exception but wrap it with another exception that then causes an exception the current logic is to actually show the top level exception. wheras now it punts to handle something that then great.
this is a larger change. if I handle the case with exception but wrap it with another exception that then causes an exception the current logic is to be triggered and wrap it with another exception.
Since ASN1InputStream is not being closed, the service constructor should be removed.
Since ASN1InputStream is not being closed, the service constructor will still be removed.
Since ASN1InputStream is not being closed, the service name is not updated at all.
rename to launch
instanceof check is not needed here.
rename to launch or launch
> Use Log.e(TAG, MESSAGE_DISABLED, PackageManager.class); [](start = 23, length = 4) Log.e(TAG, PackageManager.class);
> Use Log.e(TAG, MESSAGE_DISABLED, PackageManager.getInstance()); [](start = 23, length = 4) Log.e(TAG, PackageManager.class);
> Use Log.e(TAG, MESSAGE_DISABLED, PackageManager.class);
Should this be removed?
Should this be left in?
I would remove this
@NielsCharlier remove these empty lines?
@NielsCharlier remove these empty lines
@NielsCharlier remove these empty lines.
Yes, I think this would be more readable (and simple) similar to what I suggested in the other enums.
Yes, I think this would be more readable (and readable).
Yes, I think this would be more readable (and simple) similar to what we did in the other enums.
can you rename nativeJavaLangImports?
can you rename nativeJavaLangImports to match {}?
use diamond operator
maybe this could be simplified a bit: return (input.getGroupType()!= Group.SIMPLE) || input.getGroupType().isAggregateFunctionSupported(input);
maybe this could be simplified a bit: return (input.getGroupType()!= Group.SIMPLE) || input.getGroupType()!= Group.SIMPLE) || input.getGroupType()!= Group.SIMPLE;
IMO this could just be return input.getGroupSets().size();
Please use a regular if condition here.
Please use a regular if condition.
Please use the variable name of the "value" variable.
It may be better to add a message to the job.
It would be better to add a createDirectory method for this.
It may be better to add a createDirectory method for this.
Even here, is there a possibility of an exception?
Any possibility of adding this, could you make it more obvious?
response is null
I don't think that only the new alias should contain the aliases, since it's a list of alias. I think that's the case.
I don't think that only the new alias should contain the aliases, since it's a list of alias. I think that's the case, but that's not there.
I don't think that only the new alias should contain the aliases, since it's a list of alias.
This needs to use.addTargetEffect(new PermanentPowerCount()) on the same effect
This isn't necessary, it doesn't use the constructor for.getSpellAbility()
This needs to use.addTargetEffect(new PermanentPowerCount()) on the sides of that file
setErrorMessage
setFehlermeldung("getWorkflowService().getWorkflowService().getWorkflowService().getWorkflowService()..class");
setFehlermeldung("getWorkflowService().setErrorMessage") should go in line 179, it will be shown twice.
use { } around if and {
use { } around if
This is dangerous. You must use {"}
Nit: you can use java.util.Properties#isCloudEnabled() to get this.
Nit: you can use java.util.Properties#getCloudApiProperties() to get this.
Nit: you can use java 8 features.
Should this still add the following activity where the fragment is added? The logic is the same as this method of RxView.
Should this still add the following activity where the fragment is added? The logic is the same as this method of RxViewFragment.
Should this still add the following activity where the fragment is added? The RxView.search_tab_title property is set in ManageImageFragment.
while at this, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
while at it, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
while at this, could it be refactored to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
![MAJOR](<LINK_1> 'Severity: MAJOR') Cast one of the operands of this addition to a "adapter". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Cast one of the operands are to a "false" [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Cast one of the operands are to a "adapter". [![rule](<LINK_2>](<LINK_0>
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
you may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes. Or at least suppress the dialog show behavior.
Please specify why you are using "," as a separator b/w key and value.
Please specify why you are using ":" here.
Please specify why you are using + to log the exception.
Could you please rename this variable to children.
Could you please rename this to something like selectedChildren.getFilteredChildren()?
Please fix formatting.
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).map(item -> (T)item).collect(Collectors.toList());
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).map(item -> (String)item).collect(Collectors.toList());
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).collect(Collectors.toList());
please log the whole exception
no need for this line
empty line
This isn't a change in behaviour, as per <LINK_0>
This isn't a change in behaviour, just change the old user.
This assertion is not needed.
The variable is not necessary, use more meaningful names.
The assertion method should be replaced by assertThat(actualDetectedLanguageList).isEmpty().
The assertion method should be replaced by assertThat(actualDetectedLanguageList).isEmpty();
This is invalid output.
This is invalid output. Test was trying to fix the error message
This are invalid output.
I think this is a bit confusing. It took me a while to understand where the logic is written and then the variable can be named second. So it is specifically a bit confusing that it returns a boolean. I'm not sure if this is correct, since it is a loop.
I think this is a bit confusing. It took me a while to understand where the logic is written and then the variable can be named second. So it is specifically a bit confusing that it returns a boolean. I'm not sure if this is correct, since it is a loop of a single statement. What is your intent?
I think this is a bit confusing. It took me a while to understand where the logic is written and then the variable can be named second. So it is specifically a bit confusing that it returns a boolean. I'm not sure if this is correct, since it is a loop. What if select() is called multiple times?
Should this be catch (Exception ignored)?
Should this have a better name?
Should this be catch (Exception e)?
:+1: for using the previous assertion
:+1: for using the constants
:tada:
Nice way to do this code. It doesn't seem to be necessary but it would be nice to be able to move todlepin.
Nice way to do this code. It doesn't seem to be nice!
Nice way to do this code. It doesn't make sense to have the switch statement above in the switch.
Can you please add a message to the exception?
Can you please add a message here to make sure that the exception is actually thrown?
Can you please add a message here to make sure the exception is actually thrown?
Are we sure that this one is not null? I guess it's fine to log it, too.
Are we sure that this one is not null? I guess it would be good to log at least the other way around to know.
Are we sure that this one is not null? I guess it would be good to log at least the other cases.
I think this was necessary. This was the problem with the original code, but only woudln't it be unit tested.
I think this was necessary. This was the problem with the original code, but only woudln't it be package scope for this?
I think this was necessary. This was the problem with the original code, but only wutd about it.
I don't see where this method is used outside of this class.
I don't think we need to set this to null.
I don't see where this method is used...
Fix cyclomatic complexity sonar issue
Extract hasMbusDeviceTypeIdentification() as a variable since you're doing it multiple times.
Extract hasMbusDeviceTypeIdentification() as a variable since you're use it in both places.
You should use a StringBuilder (the same goes for all the other usages of this PR).
You should use a LinkedHashSet to preserve the order.
You should use a StringBuilder (the same goes for all the other usages of this PR)
Maybe the form should be set to null, in case the plugin is not initialized.
I'm not sure that this should be here. In fact, if the file exists, it will simply skip doing. Maybe the IFile.toString() call should be enough.
I'm not sure that this should be here. In fact, if the file exists, it will likely fail.
Why not define a new variable for this?
Reuse constant from all BreakpointConfigurationDto
Reuse constant from all of this
This "synchronized" seems not needed as TLSNIOWriteStream.shutdown() already protects it.
This line should be moved below the while loop. Also, the release may be moved outside the try.
This line should be moved below the while loop.
Did you consider to remove this list all hosts from the cluster?
can you please remove this redundant check as well?
Can you please remove this redundant check?
We're a bit confused about this. I guess we could easily use JGitFileSystem as a constructor that takes a JGitFileSystem and a GaugeUpdateListener.
We're using a Visitor here, which is nice, but I guess we could easily make JGitFileSystem as a field.
We're a bit confused about this. I guess we could easily use JGitFileSystem as a constructor that takes a JGitFileSystem and an java.io.FileSystem as a constructor dependency. This way we could make JGitFileSystem a bit cleaner.
Maybe worth to make this a part of the name, like isL0
Maybe worth to make this a part of the name, like isL03.
Name should start with lower case as well
Given this is used only in the scheduler, why do we need to subscribe here?
Why is this different from the one used above?
Why so?
The random suffix is not needed for this test.
Remove this?
Remove this
I would add in reproducing all the tests that use this model to show showJudgments (for example, logIndex(....) just.
I would add in reproducing all the tests that use this structure to make it easier to understand.
I would add in reproducing all the tests that use this model to show showJudgments and groups
It might be better to put this before the cancel call, so that the job is cancelled.
It might be better to put this before the cancel call, so that the job is also removed.
It might be better to put this before the cancel call.
I think this test is useless
I think this test belongs to Org1 as well
I don't understand how this test is necessary
Add newline before return.
Add newline before return().
Add newline before return?
What about making this change?
what about making this change?
What about making this change to 'disallowed'?
Maybe remove the first :?
optional: you can use getImageView() as first :D
optional: you could add the first :
Hi @victornoel We have lots of messages in the exception message. Should we instead print that?
nit: space after if
nit: missing space after if
What happens if there is no location specified? Is there a fake location in this case?
What happens if there is no location specified? Is there a problem then?
What happens if there is no location specified? Is there a fake location in that case?
There are cases where deletedEdges is always null and deletedEdges were null.
There are cases where deletedEdges is always null and deletedEdges will not be null.
There are cases where deletedEdges == null?
So the source is not set to null so we can't just cast here?
So the source is not "null" here? is it possible to convert a double array to a "null" and have the filter as a nested map?
So the source is not "null" here? is it possible to convert a BigDecimal to an integer and then do the comparison separately? Seems like the source should be an array.
It is better to make this more specific and handle condition with a simple == instead of > 1 check.
It is better to use Iterators.empty() here, and for the optional: this.currentIterator.hasNext()
It is better to make this more specific and handle condition with a simple ==.
Catch Throwable here as well, so that we can easily see the error stack trace in the log.
Catch Throwable here?
Throwable?
Add final keyword.
Add final keyword
final
Please use a better name (primaryKeys, primaryKeyColumns).
Can you use a better name (primaryKeys, primaryKeyColumns).
Can you use a better name instead of a string (primaryKeys, primaryKeyColumns).
why not call getDbFacade().getStorageServerConnectionDAO()?
why not using getDbFacade().getStorageServerConnectionDAO().getAuthenticationId()?
why not just getDbFacade().getStorageServerConnectionDAO().get(storageConnection)
Why are we adding this?
NonNull?
Whitespace
Is this a typo? (e.g. by {0}")
Is this a typo? (e.g., {0}")
Is this a typo or maybe?
We should be able to remove this else block and add a return after the if. It would be cleaner to have the caller handle the null and catch an exception if needed.
We should be able to remove this else block and add a return after the if
We should be able to remove this else block and add a return after the if. It would be cleaner to have the code under the if condition and throw an exception if it fails.
use this utils method for error <LINK_0>
use this utils method for this
use this utils method
The rest of this function can be moved below into the "try" block so we don't have to do multiple places at the same time. Can it be moved to a method to keep it consistent?
The rest of this function can be moved below into the "try" block so we don't have to do multiple places at the same time. Can we delay this on some of the records? Also, we are trying to avoid asynchronous operations. I think the source of such a thing should be done here right?
The rest of this function can be moved below into the "try" block so we don't have to do multiple places at the same time. Can we delay this on some of the records? Also, we are trying to avoid asynchronous operations. I think the source of such a thing would be much better.
Same here messager should never be null. Otherwise we can't report.
How is it possible that we can't report the same message in the case of a problem? We shouldn't ignore messages.
Same here messager should never be null. Otherwise we can't report that
typo
Interface appended to variable name
Interface appended to name
nit: error message is slightly misleading, we can say "rawHashTables is empty".
can be simplified to: if (!rawHashTables.isEmpty()) {
can be simplified to assertThrows
Must be Outcome.Benefit to keep good card
It should use the card's Outcome.Discard
It should use the card's Outcome.Discard.
@kirankumarkolli - do you need to update this file with the proper spotbug issue which is failing here?
@kirankumarkolli - you need to update this file with the proper spotbug issue which is failing here <LINK_0>
@kirankumarkolli - do you need to update this file with the proper spotbug issue?
The logic of this function is good, it should be covered by your tests.
The logic of this function is good, but it should be covered in test.
The declaration of these statements can be removed.
Collection or array
Collection or array?
Collection or toArray()?
This change does not belong here, it would be better to revert the I think. And the same probably applies to all the ITs in this file.
This change does not belong here, it would be better to revert the I think. And for all the other cases. What do you think?
This change does not belong here, it would be better to revert the I think. And the same probably applies to all the ITs in this patch.
pls. consider to use {...}
return getOninvokeMethod(MethodInfo);
return true or false
Is this the only way to do this? If we need this, we can probably stay consistent with the rest of the codebase?
Is this the only way to do this? If we need this, we can probably stay consistent with the rest of the code?
Is this the only way to do this? If we need this, we can use a Set.
StringUtils.hasDurableSubscription(bindingProperties.getConcurrency())
StringUtils.isBlank?
should it be the first?
Why do you need to create a directory here? Shouldn't the directory be deleted already?
Why do you need to create a directory here? Shouldn't the file be deleted all?
Why do you need to create a directory here? Shouldn't the directory be deleted all?
I would prefer to use Optional<Boolean> here, like the other places below.
I would prefer to use Set<Status> here instead of always returning true.
I would prefer to use Set<Status> here
Can't this string be removed? I'd prefer a constant.
I'd prefer a new File[] {... }.
Can't this string be a constant?
Style-nit: Spaces around operators
Spaces around operators
Spaces around <>
Why did you make this change?
Why are we using a local variable now?
Why is this needed?
Please remove this file name from test code.
Let's move this file name to finally block.
Let's move this file name to finally block
@prahladyeri true should be on the next line
@prajym maybe a reason for this line?
@prahladyeri true should be on the next line.
I think this test is not optimal: assertThat(firsts.size() - 2);
I think this test is not optimal: assertThat(firsts.size()).isEqualTo("null");
I think this test is not optimal: assertThat(firsts.size()).isEqualTo("null"));
I think we can replace both with: if (targetAsMapping.isMappingMapping()) { merge(sourceChild, targetChild); }
I think we can replace both with: if (targetAsMapping == null) { return; } else if (targetAsMapping.children() == null) { merge(sourceChild); }
I think we can replace both with: if (targetAsMapping == null) { return; } else if (targetAsMapping.children() == null) { merge(...) }
I believe this can be converted to an AtomicBoolean
I don't think this is safe. This kind of broad check is a bit necessary, and this will not actually speed up the security measure.
I don't think this is safe. This kind of broad check is necessary.
Don't put non-indexedEntities in a property.
Don't remove anything...
Don't remove anything... :D
transoromation is always processing (Optional) present element but the last element. IMO it would be nice easier if Transformation would have different method to read not consumed output.
transoromation is always processing (Optional) present element but the last element. IMO it would be nice easier if we could move Transformation.process(elementOptional).
transoromation is always processing (Optional) present element but the last element. IMO it would be nice easier if Transformation would have different method to read not consumed output
i don't see any uses for the hardcoded clocks in unit tests.
i don't see any uses for the hardcoded clocks.
i don't see any uses for the BSLD unit tests
If you add an thenAccept here then the damage of the previous method would be successful and the state is unlinked, right?
If the second location is removed, the second location should be removed.
If you add an thenAccept here then the damage of the previous method would be called anyway.
2 corrections: 1. Static imports 2. Have this as a constant, since it won't change its value during the entire execution
2 corrections: 1. Static imports 2. Have this as a constant?
2 corrections: 1. Static imports 2. Have this as a constant.
We should save even more instances by directly prepending to Lists instead of appending to Queues: java List<T> first = Stream.of(from(t), Tuple.of(t.iterator(), first).iterator(); if (predicate.test(t)) { return Tuple.of(t, first); } else { return Tuple.of(first, second); }
We should save even more instances by directly prepending to Lists instead of appending to Queues: java List<T> first = Stream.of(from(t), Tuple.of(t.iterator(), first).iterator(); if (predicate.test(t)) { return Tuple.of(t, first); } else { return Tuple.of(first, first); }
We should save even more instances by directly prepending to Lists instead of appending to Queues: java List<T> first = Stream.of(from(t), Tuple.of(t.iterator(), first).iterator(); if (predicate.test(t)) { return Tuple.of(t, first); } else { return Tuple.of(first, second); } }
Should we use the executor here with the appropriate timeout (500?).
Should we check if debug is enabled?
Should we call Thread.sleep() here?
Use a constant for isNullOrEmpty
Should we use a constant for this?
Should we use a constant for isNullOrEmpty here?
Typo: timestamp -> range
Typo: timestamp -> tableRef
Typo: timestamp
Are these extra checks necessary since they all extend any superinterfaces?
Are these extra checks necessary since they all extend the same type?
Are these extra checks necessary since we already check for null?
These two ifs can be combined into one.
Nit: I think the indentation of the ifs are redundant.
Nit: I think that the concatenations aren't necessary here.
I think you can simply use TimeUnit.SECONDS.sleep(50); instead of TimeUnit.SECONDS?
I think you can simply use System.currentTimeMillis() instead.
I think you can simply use TimeUnit.SECONDS.sleep(50); instead of TimeUnit.SECONDS here.
Use try-with-resources.
Use [Bundle.readLine()](<LINK_0> instead
Use [Bundle.readLine(String)](<LINK_0> - java.nio.file.String)
for comparison with an enum it's better to use ==.
for comparison with an empty list it's better to use ==.
for comparison with an enum it's better to use ==
nit... You can say - "g.dummy-classes"
nit... You can say - "... 1"
nit... You can say - " - [ ] ["...]",...
Rather than invoking.METHOD_NAME, you should put it in the setup method.
Rather than invoking.METHOD_NAME, you could use a simple for loop for the whole statement.
Rather than invoking.METHOD_NAME, you could use a try-with-resource pattern to get proper values
as we're going through these messages, we've stopped putting 'inputSchema' as null' in the input schema
as we're going through these messages, we've stopped putting 'inputSchema' as an argument, and sometimes it doesn't make sense to have this condition here.
as we're going through these messages, we've stopped putting 'inputSchema' as an argument, and sometimes it doesn't make sense to have this exception message. If it's a valid schema, we should also have it.
Formatting again.
Formatting...
Formatting
I'd change is back to 50 for consistency with CDT.
I would change is back to 50 for consistency with CDT.
I'm confused the for loop here.. is it safe to assume that the same maxSize will be a long?
Can we use a logger here?
Can we log the error and not return an error?
Should we log or fail the test here?
please log the exception, so the stack trace will be printed.
Can we log the exception here rather than simply printing the stacktrace?
Can we log the exception here rather than simply printing the stacktrace? We are already logging in the console for it.
you can use the value for journalNodeBase
you can use the test helper method here
you can use the value for journalNodeNames here
Must be object.change(db). The Change is not involved.
Must be object.change(db) to the ChangeData.
Must be object.change(db).
final
final ViewerComparator<ITreeSelection> value = newValue.length();
final ViewerComparator<ITreeSelection> value = newValue.length;
nit:.with-snapshot-id -> <LINK_0>
nit: This test doesn't care whether the snapshot is supported.
nit: This test doesn't care whether the snapshot is actually created or not. But I'd like to see the 'empty' exception.
Space after if
Style-nit: Space after if
Style-nit: space after if
Either with <>, or completely without.
Either with <LINK_0> or completely without.
Either with < or completely without.
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_3>](<LINK_4>![MINOR](<LINK_1> 'Severity: MINOR') Do something with the "boolean" value returned by "delete". [![rule](<LINK_3>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_3>](<LINK_4>![MINOR](<LINK_1> 'Severity: MINOR') Do something with the "boolean" value returned by "delete". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_2>](<LINK_0>
java assertThat(foo1, "foo2").incrementAndGet();
I know this is copy-pasted from the other tests, but we should maybe use a common method for each test.
I know this is copy-pasted from the other tests, but we should maybe do assertEquals(Foo.class, foo1)
@rishabh-997 there is a good way to put this in a well-test.
@rishabh-997 there is an empty space in the message.
@rishabh-997 there is a good reason for adding such "final".
IgniteThread is created for each thread.
Typo: v
IgniteThread is created for each run of game
remove the extraneous space
remove the extraneous space after the descriptor
remove the extra line
No need to init local variable and return.
No need to init local variable
No need to init local variable and just return.
We can just check if oldStoreDef exists before doing this check. Same in your tests.
We can just check if oldStoreDef exists before doing this check. Same in update()
We can just check if oldStoreDef exists before doing this check. Same for the other tests.
You might want to write the iterator and assert that the iterator is empty if you do not have to do it like this?
You might want to write the iterator and assert that the iterator is empty if you do not support the preceding or not, otherwise the test will fail.
You might want to write the iterator and assert that the iterator is empty if you do not support the preceding or not, because otherwise it will be getting the same result.
You could probably do sb.append(IgniteUtils.nl_...);
You could probably do the sb.append(IgniteUtils.nl_...);
You could probably do the sb.append(IgniteUtils.nl_...);.
Check log message.
Check log message above?
Check log
No need to create a new Date object and then transform it into OffsetDateTime. You can use OffsetDateTime.now() directly
No need to create a new Date object and then transform it into OffsetDateTime. You can move this code to OffsetDateTime.now() function.
No need to create a new Date object and then transform it into OffsetDateTime. You can move this code to OffsetDateTime.now() directly
if an exception is thrown for a directory, the rest of the method is too long
if an exception is thrown for a directory, the rest of the code is leaking too.
if an exception is thrown for this file, the rest of the method should be extracted
You could use the Bukkit API which returns a UUID instead of a UUID.
You could use the Bukkit API which returns a UUID instead of a String.
You could use Bukkit API which returns a UUID instead of a UUID.
should be final
should be filtered out?
should be filtered out, not necessary
What is this for?
I think this should be a synchronized
I think this should be a synchronized.
Define a final static int STORAGE = Integer.MAX_VALUE + 5.toString();.
Define a final static int STORAGE = Integer.MAX_VALUE + 5.toString();
Define a constant for the number.
Would it be better if we could avoid code duplication with the getCurrentListener() method?
Would it be better to add a method getCurrentListener() to get listener and call this method directly?
Would it be better to add a method getCurrentListener() to get the listener and call this method directly?
You can use!Strings.isNullOrEmpty(prefix)
You can use!Strings.isNullOrEmpty(prefix) here.
import Constants
nit, do the same for the null check
nit, do the same for the one above?
nit, do the same for the change above?
It seems that CountDownLatch.append(value) is used in multiple tests. Maybe it is better to put it in a helper method?
It seems that CountDownLatch.append(value) is used in multiple tests. Maybe it is better to put it in a helper method.
It seems that CountDownLatch.append(value) is the missing key.
I think this should stay before this PR in favor of making the TwitterErrorHandler respect the Twitter4j RateLimitStatus reset time. I'm volunteering to do that, so unless STREAMS-311 can't be fixed without it I'd say to put this back to 10.
I think this should be in the PR in order to minimize the TwitterErrorHandler respect the Twitter4j RateLimitStatus reset time. I'm volunteering to do that, so unless STREAMS-311 can't be fixed without it I'd say to put this back to 10.
I think this should be removed
For now we should keep this method package visible only
For now it should keep this method package visible only
For now we should keep this method package visible only.
What was the reason for this change?
Why did you change this?
What did you think of using Mockito here?
Let's say these (!useCustomMountPath.isCustomMountPath())
Let's say these (!useCustomMountPath.useCustomMountPath())
Let's say why these statements were grouped together.
The indentation level shouldn't be changed.
The indentation level shouldn't be changed. the new test doesn't make sense.
The indentation level shouldn't change.
please remove xxx and xxx from xxx
please remove space before, and after + sign
please remove space before, and use param.
Can we not catch this error, it seems like it should be debug level?
update
Can we not catch this error, it seems like it should be debug level log?
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the directory).
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the bytes with the same name).
why not just return subPaths here?
why not use instanceof?
why dont we use instanceof Map.Entry?
I don't like this variable. It looks like it's used only once.
I wouldn't use this variable and the one above it (result.getGridSetId()!= null)
I wouldn't use this variable and the one above it (which includes the value)
nit: error message could be more descriptive.
nit: error message could be more descriptive. Suggestion: "New limit cannot be negative."
nit: error message could be more descriptive
unnecessary space
not needed
not sure about this method.
I am not sure that this change is correct. Why the caller should pass in null and not throw an exception?
I am not sure that this change is needed. Why this change?
I am not sure that this change is needed. Why the test is to allow both trim and isEmpty?
This call should not be done before we set the initial datya received. Also, this call should be done from the FilesTabView class
You should not be able to set the initial datya received. Also, this call should be done from the FilesTabView class
This call should be done before we set the initial datya received. Also, this call should not be done from the FilesTabView class
Does this mean that statement.isClosed() is useless?
Does this mean that statement.isClosed() || statement.is("create database") == null?
Does this mean that statement.isClosed() is useless? Is it a "protected" method that could be deleted?
Not part of your changes, but can you make this more descriptive?
Remove final
Remove final.
toOSString() gets platform dependent path - Consider the case where there are CRC32 files on disk.
this should be toOSString()
needs to be 'String=true'
This looks good.
This looks good, but is it intentional to just rethrow the exception here?
This looks good!
This should be the other way around and use it in the other try-with-resources syntax
This should be a plain String[] array right?
Use try with resources.
This test is very similar to JmsMessageWithTraceHeaders.shouldPublishAndConsumeJmsMessageWithTraceHeaders. If possible it would be nice to make both test cases more concise to use
This test is very similar to JmsMessageWithTraceHeaders. If possible it would be more appropriate for a similar test.
This test is very similar to JmsMessageWithTraceHeaders. If possible it would be more appropriate for a follow up change.
should the execute statement be refactored to use camel case instead of GroovyShell and retrieving them?
should we consider to create the GroovyShell and pull request into constructor instead of creating them?
should we consider to create the GroovyShell and pull request into constructor instead of creating it in constructor?
I rename BreakpointConfigurationDto to ws
rename it to BreakpointConfigurationDto
Filter breakpoints with hitCount = true
Would it make sense to move this line down to where we switch to egress mode?
Would it make sense to move this line down to where we switch to egress legs?
Would it make sense to move this line down to where we switch to egress legs for the third phase?
This should be done before the for loop, as long as we're not building the new data.
This should be done before the for loop, while we're iterating over the existing topic.
This should be getTopologyCustomState()
Prefer get retval here as well.
Prefer getThrowable and SshConnectionPool.getInstance().getConnection() instead.
Is this method used elsewhere?
maybe add a null check for instanceId?
maybe we should add a null check for instanceId?
maybe add a null check for instanceId == LwM..
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getDataClient().sampleRowKeys(request.build()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
Since it is used multiple times, make this a separate function returning BigtableSession.toTableName(configuration.getTableId())
style nit: no braces around single line blocks
style nit: no braces here
like above, can you use JUnitUtil.testExpectedException?
If you do a GridLayoutViewer.get(0).setTrace(true) then you have to go directly to the fXYViewer method in the parent class. I think it's a better solution, as it could be called after dragging in the view, and then showing the selection in the trace.
If you do a GridLayoutViewer.get(0).setTrace(true) then you have to go directly to the fXYViewer method in the parent class. I think it's a better solution, as it could be called after dragging in the view.
If you do a GridLayoutViewer.get(0).setTrace(true) then you have to go directly to the fXYViewer method in the parent class. I think it's a better solution, as it could be called after dragging in the event.
When did we start supporting yE supporting day to S3?! Was that added recently? I didn't think that was supported in the current version of Travis.
When did we start supporting yE supporting day to S3?! Was that added recently? I didn't think that was supported in the current version of 1.1.3 connector.
When did we start supporting yE supporting yE supporting day? I didn't think that was supported in the current version of Travis.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
There is already logging for that in the EncryptionUtils.encrypt catch block
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put that code here.
Warn log level seems to high for a normal state transition.
Warn log level seems to high for a normal situation.
Why do we need this if else block?
Add LOG.warn("Failed to replicate {}: {}", ee.getRegionLocation(), e); after the try-catch block?
Add LOG.warn("Failed to replicate {}: {}", ee.getRegionLocation(), e); before the try-catch block?
Add LOG.warn("Failed to replicate {}: {}", ee.getRegionLocation(), e); before the try {} block?
Why is this not using getpreferences()?
Why is this not using get()?
Why is this not using get value?
Use ProjectRights instead of InheritedRights, and just InheritedRights.
Use ProjectRights instead of InheritedRights, and just InheritedRights,?
Use ProjectRights instead of InheritedRights.
Please,a dd these lines and add NON-NLS tag TransactionalEditingDomain domain = ServiceDiagrams.EMPTY_MAP_FNON-NLS-2
Please,a dd these lines and add NON-NLS tag TransactionalEditingDomain domain = ServiceDiagrams.getInstance().getDiagrams();
Please,a dd these lines and add NON-NLS tag TransactionalEditingDomain domain = ServiceDiagrams.EMPTY_MAP_NON-NLS-2
Already added to the trace output, you may want to override a default trace output. But in order to avoid the same problem for the container, you need to override the trace output
Already added to the trace output, you may want to override a default trace output. But in order to avoid the same problem for the container, you need to override the trace output, so you will get a bit more manually.
Already added to the trace output, you may want to override a default trace output. But in order to avoid the same problem for the container, you need to override the trace output, so you will get to the same model
Couldn't this just be: java return Arrays.stream( genericTypeMapping.spliterator(), false).filter(methodReturnType -> { if ( genericTypeMapping.isEmpty()) { return null; } String expectedType = methodParameters.get(i); return 42; } }
Couldn't this just be: java return Arrays.stream( genericTypeMapping.spliterator(), false).filter(methodReturnType -> { if ( genericTypeMapping.isEmpty()) { return null; } String expectedType = methodParameters.get(i); return tmp; }
Couldn't this just be: java return Arrays.stream( genericTypeMapping.spliterator(), false).filter(methodReturnType -> { if ( genericTypeMapping.isEmpty()) { return null; } String expectedType = methodParameters.get(i); return 42; }?
I think we could have inlined this variable java ws = dbClient.getAnalysisUuid(analysisMetadataHolder.getUuid()).get();
I think we could have this duplicate as a method
I think we could have inlined this variable
is there a similar query here? Perhaps we can use something like: log.error("Waited {}ms for connection that failed validation
is there a similar query for "Waited {}ms"?
is there a similar query here? Perhaps we can use something like: log.error("Waited {}ms for connection which failed validation
Should we remove the executor in finally block?
IMHO it is unused, as it was already logged in DataService
IMHO it sounds like a DataBrokerConnectionFactory but unused variable?
Even though it's here, doesn't there be a test for this? (applies to other pieces of code too)
Even though it's here, but isn't there a reason to System.out here? (applies to other tests)
Even though it's here, doesn't there be a test for this? (applies to other tests)
I'd like to see this code further refactored.
I'd like to see this as a constant, so it can be translated by the plugin.xml.
I'd like to see this code further, the setFilter method contains the javassist even if "Is this file exists and should be called "getFilePath(...)".
should this be final?
should this be continue?
should this be producer?
to be on the same line, you don't need to create an arraylist, change to: private List<Pair<VDS, Integer>> parameters) { List<VDS> parameters = new ArrayList<>( lunsSizePairs); lunsSizePairs = containers.stream().map(l -> luns.getLUN_id()).collect(Collectors.toList()); return Collections.unmodifiableList(vdsSizePairs, lunsSizePairs); }
to be on the same line, you don't need to create an arraylist, initialize it with @Inject as a member variable outside of the for loop.
to be on the same line, you don't need to create an arraylist, initialize it with @Nullable.
You added a parameter but this command is also used from other places, so this will cause compilation failures.
The prefix of 'console' is redundant and 'getMacAddress()' is already used.
The mac address is now redundant. Please remove it.
So hideNewPane = true and this is a modified file, I am unable to hide the left side?
So hide all dialogs in the same class, I am unable to hide the left side?
So hideButton.setValue() returns false if hideWhitespace is false, I am unable to hide the left side?
Let's use UtilMethods.isSet(this) here for consistency
Let's use UtilMethods.isSet(this) for this code
Let's use UtilMethods.isSet(this) here for consistency with the code
Don't use the uuid temp variable, rather than just the name, otherwise we're just returning the hash call.
Don't use the uuid temp variable, rather than just the name, otherwise you're just returning the hash call.
Don't use the uuid temp variable, rather than just the name, otherwise we're just returning the hash of the work in the log?
let's rename this to RelationshipRequest
let's rename this to CONDITION_PERSON_UUID
let's rename this to CONDITION_PERSON_ID_UUID
Move this to catch
Move this to catching only the first condition and throw the exception.
Move this to catching the exception and throw it.
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
@Happy-Neko I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
@Happy-Neko I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better name for a project.
same here, don't you need to put the 3 lines above this one (candAlias, Alias)
Should that be <=?
Should that be <=?
I don't think this is the right thing to do here - it seems like it's sub-classes.
This line seems to be the same as the above one. Does it make sense to do it here?
This line seems to be the same as the above one. Does it make sense to throw an exception here?
nit: Topic is not a mutable map so we can avoid the double hash lookup?
nit: Topic has been changed from String.format to Topic as well.
nit: Topic is not a mutable map so we can avoid the double hash lookup.
We should throw exception here? Or it throws exception we need to handle?
We should throw exception here? Or it throws exception?
We should fail if in at least one event is disabled. I guess we can avoid changing the log entirely.
Please use NLS.bind() here.
Please use Helper.setErrorMessage which bundles both calls.
Please use NLS.bind() instead of concatenation.
SpdxListedLicense = null; should be enough here.
SpdxListedLicense = this.getLicenseId(); should be the same as below
SpdxListedLicense = null; should be checked first.
It would be good to explain here, e.g.: // Friend results are all included. Own results are only included if some friend has a goal in the same category.
It would be nice to explain here, e.g.: // Friend results are all included. Own results are only included if some friend has a goal in the same category.
It would be good to explain here, e.g: // Friend results are all included. Own results are only included if some friend has a goal in the same category.
Or, assertThat(category.getAttributes(), hasItem(new MetacardImpl(metacard)).
Or, assertThat(category.getAttributes(), hasItem(new MetacardImpl(metacard)).containsOnly(object));
Or is this method needed?
Should there be a copy here not a shared copy?
Should there be a copy?
Should there be a copy here not a potentially null?
probably just move this to a different method so that we're always calling read twice
probably just move this to a different method so that we're always calling read twice.
Uh, this would be clearer.
there is a util method for this.
Can we find a way to differentiate this?
Can we find a way to differentiate the payload field after the get?
Ths should be one sql statement where there is a join between calls.
the sql statments should be in a db transaction
sql statement can join writerId and dbusage
order of operands
order by element name should be updated to be more consistent with other methods
call equals on two lines
Does not need the code for this?
Does this mean that no longer the code for this class?
Does not need the code for this..
This should be another else if, otherwise it will look like the old code.
This should be another else if, otherwise it will look strange to me.
This should be another else if?
I believe that we need to use the same code as in the base class.
I believe that we need to use the same code as above. Could we have a private method to do this?
I believe that we need to use the same code as the base class.
Was it intended to use == instead of '=='?
Was it possible to use == instead of mCurrentLocation?
Unlongended changes
Static import the constant?
For methods that generate a body we should be verifying the expected body.
Let's use the constant instead.
Place in ApplicationConstants instead.
Place in ApplicationConstants instead
Can you use [this](<LINK_0>
this can be simplified to: private static String toString().getBytes(CharsetUtil.UTF_8)
this can be simplified to: private static String toString().getBytes(CharsetUtil.UTF_8) {
this can be simplified to: private static String toString() {
Swapping these around breaks all other GUI's.
Swapping the around breaks all other GUI's.
translate
do not change this test, it should still check if proper encounter is returned from createEncounter service
this equal is now redundant, just check if action returns proper encounter object
do not change this test, it should still check if action returns proper encounter object
Remove this addComponent() (not 0).
Remove this addComponent() (as well as the priority queue)?
Remove this addComponent() (not 0)
unused variable?
requireNonNull
pointless extra line
Don't need this change.
Don't need to change this.
Don't need this else block.
Why is this needed?
Why is this changed?
Why is this changing?
You don't need to check for null here.
You don't really need to check for null here.
You can move this loop out of the loop.
@PARSE_SET_RATIO); if (!other.getIndex(other)) { registerSet(other, other); }
@PARSE_SET_RATIO); if (!other.getIndex(other)) { registerSet(other); }
if other.getIndex()!= 0 is not the case, this will break.
@weisebrazil move the variable to the first line of the method
Shall we reuse the constant : )
@weisebrazil move the variable to the first line.
Nit: We don't need this null check
Strange whitespace, and this should be in a separate line
Strange whitespace, and this should be in a separate line.
I don't think we need to modify the exchange scope (instead of having separate maps)
I don't think we need to modify the exchange scope (we had it already before)
I don't think we need to modify the exchange scope (we have to do it now). But if we don't need to make the partitionedExchange field any longer, it may be removed from the future.
Group exception types handled identically in a single catch block.
please remove this log or replace it with a slf4j logger.
please remove this log or replace it with a logger.
Why do you create constants if you have to use them?
Can you create constants for this event?
Can you make this method private?
Should use error callback.
Is there any use case for this?
Should this use error callback?
Suggest to add an exception as the cause.
Suggest to add an exception as well and use fail() if exception is thrown.
Suggest to add an exception as well and use error message?
assertTrue is redundant here.
You can also use assertTrue here.
You can also use the assertFail here.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, I think it would be nice to remove it from the existing message.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, I think it would be better to remove it from the method signature here.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call().
@Josephblt in cases like this you can use functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I guess it is cleaner and easier to understand, but just as a suggestion.
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I guess it is cleaner and easier to understand, but just as a suggestion
@Josephblt in cases like this you can use a more functional code like List<String> uuids = new ArrayList<>();
I think get was more approriate here
This is a common pattern to be used so other classes can benefit from it. I think get was more approriate here
If it isPublicIPAddressly used so consider creating the predicate and return this.
Checking this is probably redundant now when we return an Optional<LabelMeta>?
Checking this is probably redundant now when you return an Optional<LabelMeta>?
Checking this is probably redundant now when you have the labelMeta itself. Why should it return null?
Minor improvement: Could use a static import here as well.
Minor improvement: Could use a static import here.
Minor improvement: Could use Directives.tries(projectId).
is it really needed?
is it really needed?
is it really needed??
WDYT about moving such logic to InternalRuntime and do not bootstrap at all if installers are missed
WDYT about moving such logic to [this](<LINK_0>
WDYT about moving such logic to OpenShiftRuntime and use it in CheSeleniumSuiteModule?
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this method final. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this conditional on the "if" condition. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this conditional on the "else" block of code "if" so that it is never called twice on this call. [![rule](<LINK_1>](<LINK_2>
Let's remove alias check
Let's remove alias
Let's remove alias check here
I think there is no point in going to use here
I think there is no point in going to not have an attributeExpressionExecutors.length == 0 in this case, even if there is no.
I think there is no point in going to not have an attributeExpressionExecutors.length == 0 in this case, even if there are no arguments.
> Files (delete) are not atomic. Better use a try-with-resources idiom.
> Files (delete) the file to ensure the file is deleted. Better to use a temp file
You can maybe use Files.write for this: java IOUtils.write(tempFile, file);
No need to check for null
Slightly more readable this for each recipe.getPos()
No need to check this, it can just be done in getRecipeForInput
Here you could directly use TextUtils.isEmpty(parentId)},) instead of a loop.
Here you could directly use TextUtils.isEmpty(parentId)},) instead of a null check
This method should be private.
Can you please add isTraceEnabled check?
Duplicated code. Please consider to create pmmlCompilerMessages a constant.
Duplicated code. Please extract it also to a method and reuse
Device should be rebooted before part of the device.
Device should be rebooted before test starts, to avoid clash with another device.
abortedOpcode
I think we need to use our logger instead of System.out.println
I think we need a logger.
I think this should be using our logger instead of System.out.println
If we throw an exception it should be logged with the same message.
If we throw an exception it shouldn't be logged, right?
If we throw an exception it should be logger.error("File at least one entry was not found", resolveRegistryPath);
The formatting looks off.
new File(expected.length);
The formatting for each file seems a bit off.
This is incorrect:![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
This is incorrect:![MAJOR](<LINK_1> 'Severity: MAJOR') Make this method synchronized. [![rule](<LINK_2>](<LINK_0>
This is incorrect:![MAJOR](<LINK_1> 'Severity: MAJOR') Make this line start at column 9. [![rule](<LINK_2>](<LINK_0>
this is the only way to decide if host is in K, right?
I used the same logic to handle here.
this is the only way to enable this to work when host is in Voltserver.
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); }
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); }
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); } return Optional.empty();
Can you replace and add the log message?
Can you replace lines 354-361d with : > I am pretty sure this works as long as the default limit is lower than the limit.
Can you replace lines 354-361d with : (1) or transit to add the limit, as a parameter, default?
There is a weird way to handle this. I would like to see a less common solution (if we really want to handle a failure when both succeed). At this point, we should write a normal error message and return that to the end of the method.
There is a weird way to handle this. I would like to see a less common solution (if we really want to handle a failure when both succeed). At this point, we should write a normal error message and return that to the user (root error) or throw an exception.
There is a weird way to handle this. I would like to see a less common solution (if we really want to handle a failure when both succeed). At this point, we should write a normal error message and return that to the user (root error) instead of aka Gerrit.
suggestion if ((isClan(campaign)) && isClan(null)) {
suggestion if ((isClan(campaign)) && isClan(base)) {
suggestion if (isClan(n)) {
Why is the catch block required here? Can't it be wrapped with try-catch block?
Why is the catch block required here? Can't it be wrapped in try-catch block?
Shall we add service name to log message?
@Happy-Neko we should ensure that null is taken here if it is set in the xml file
@Happy-Neko we should ensure that null is taken here if it is set in the constructor.
@Happy-Neko we should ensure that null is taken here if it is set in the constructor
Why change it?
Should be better to remove this part
Formatting
there is no reason to explicitly close the reader here?
there is no guarantee that the reader is closed. Either do it in a finally block or just always?
there is no guarantee that this should always be an HTTP error.
This is usually a good idea.
This is usually a good idea to use base URL instead of this logic.
This is usually a good idea to use base URL instead of this.
Instead of this whole if statement, could you add a check to make sure the code is called with a null (or empty) null so that it's clear we're never seeing null? We might want to add a check on instanceOf check somewhere.
Instead of this whole if statement, could you add a check to make sure the code is called with a null (or empty) null so that it's clear we're always returning null?
Instead of this whole if statement, could you add a check to make sure the code is called with a null (or empty) null so that it's fast? We're never seeing nulls on an annotation.
.stream() (also in other places)
This is not a good idea..build() would be doing ImmutableMap.copyOf(stages.stream())
This is not a good idea. :P
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block.
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block. We should also log error on this throw block.
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block. we should also log error on this throw block.
Is it possible to catch InterruptedException here?
Is it possible to catch InterruptedException here and set a specific instance?
Is it possible to catch InterruptedException here and set a custom exception?
Why are we replacing the field here?
Why are we passing the hive here?
Why are these mutable?
should this be configKey.get(PolicyConfigKey.HEALTH_POLICY_MODE)
Would it be better to do "deactivated" here?
should this be configKey.get(PolicyConfigKey.HEALTH_POLICY_MODE))
Why not use the moduleMap parameter here?
Why not use the module here?
Why not use moduleReqName for View?
nit: what about if (adapter!= null) { return; } if (mRecyclerView == null) { mRecyclerView.setVisibility(adapter); } else { mRecyclerView.setVisibility(adapter); } } return null;
nit: what about if (adapter!= null) { return; } if (mRecyclerView == null) { mRecyclerView.setVisibility(adapter); } else { return View.GONE; } return View.VISIBLE;
nit: what if we make this more explicit?
Declaration should just be Map
Declaration should simply be Map
Declaration shouldn't be just Map
This way it won't return any template which has no effect. I believe it should be simply 'Entity'.
This way it won't return any result, you should wrap it with Templates.add(vmTemplate.getTemplates().addAll(collection));
This way it won't return any result, you should wrap it with Templates.add(vmTemplate.getTemplates().size())
nit: Could use a ternary here.
nit: Could use a template pattern for this.
nit: Could use HttpUrlConnection.HTTP_GROUP.
You need to also store the end time here?
You need to also store the lastStartTime: long lastStartTime = parse(time, ssq); if ( lastEndTime!= -1) { return; } where it's not start yet.
You need to also store the lastStartTime: long lastStartTime = parse(time, ssq); if ( lastEndTime!= -1) { return; }
This should probably be WorkflowInstanceAction.getInt()
This should probably be WorkflowInstanceAction.class.getSimpleName() instead of hard-coded string.
This should probably be WorkflowInstanceAction.getInstance().getWorkflowInstanceId()
setErrorMessage
setFehlermeldung: Please replace this log call and setErrorMessage which bundles both calls.
setFehlermeldung -> setErrorMessage
I don't see a need to keep the declaration on a separate line.
Can't we keep the declaration on a separate line? I don't see a need to keep the declaration on a separate line.
Can't we keep the declaration on a separate line? I don't see a need to keep the original line.
Normally you should be skipping the service.pid key in the generator, not in the beginning.
Normally we should be skipping the service.pid key in the generator, not in the horizon set.
Normally we should be skipping the service.pid key in the generator, not sure if the view exists.
Move to L428 as the 'if' below, then we don't even need to compute how many times it's done even if we have that 'if'?
Move to L428 as the 'if' block below, then we don't even need to compute if its not boolean?
Move to L428 as the 'if' below, then we don't even need to compute how many times it's done even if they're not in the right order. And most of the time time even if they don't care.
style nit: remove the spaces before and after the brackets
style nit: remove the spaces before &&.
style nit: remove the spaces before && as well
User can't be null if the user didn't provide a valid email. This check will fail if we have email.
User can't be null if the user didn't provide a valid email.
User can't be null if the user didn't supply an email.
It looks like o.isSyncingEnabled can be replaced with o.isSyncingEnabled()
It looks like o.isSyncingEnabled can be removed now since it's already used in the get()
It looks like o.isSyncingEnabled can be removed now since it's already used in the get method.
@rishabh-997 "src" is a better name.
nit: exception is dropped
return resultFS
Remove the AuthenticationException catch block.
Remove the 2-arg constructor.
Do we need to cache the result?
I think that we should use Thread.currentThread().interrupt() when the thread is interrupted interrupted ExecutorService.
I would modify this to use the newer format: <LINK_0>
I think that we should use Thread.currentThread().interrupt() when the thread is interrupted instead of returning.
Should all of these be public?
Should we initialize this in the constructor and have it pass null.
Should all of these copy-pasted into a copy?
@maria-farooq What is a use case for this?
@maria-farooq What is a use case for this? We don't want to show the URI, right?
@maria-farooq Hmm, here we are doing the right thing, with the current logic, we should make sure that the scheme is a valid host, not a protocol. This would be better, for example, with a port://uri= uri path instead of a URL.
We should also define a prefix for the string as well to avoid duplication of the paths.
We should also define a test for the path, so that we can be sure the format is the path for the user.
We should also define a test for the path, so that we can be sure the format is the same.
This test can be removed, no?
This test can be removed, doesn't it?
This test can be run in parallel without more modern version
Unless I am missing something, the array creation with new Object[] {... } is not needed, and had better be removed.
Unless I am missing something, the array creation with new Object() method is not needed, and had better be removed.
Unless I am missing something, the array creation with new Object() method is not needed, because no passing in a reference to the method.
This whole convoluted mess can be replaced with Paths.get(config.getPKIDir(), "certs", name)
This whole convoluted mess can be replaced with Paths.get(config.getPKIDir(), "certs", name);
This whole convoluted mess can be replaced with a single try-with-resources block
We can't assume this will cause the upload to fail. I think we can set the maxMediaIdPredicate and the check we do in OnMediaProgressMax.
We might want to add a TODO here and in all the places, to make it easier to debug as well.
We can't assume this will cause the upload to fail.
This will require us to special-case an empty collection everywhere, which I think will make the code confusing and probably error prone during maintenance. I think it'd be nice to modify granularIntervals.getGranularityGranularitySpec(). It could be nice to have a method that returns an Optional<Granularity>, which returns an empty list if inputIntervals is null.
This will require us to special-case an empty collection everywhere, which I think will make the code confusing and probably error prone during maintenance. I think it'd be nice to modify granularIntervals.getGranularityGranularitySpec(). It could be nice to have a method that accepts a GranularitySpec interface to initialize them with null as the default.
This will require us to special-case an empty collection everywhere, which if inputIntervals is null.
There's no need for the empty case.
There's no need for the null check.
Spacing.
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "execute" is 12 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "execute" is 12 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
should not use the "Null" part but use the fully qualified name?
should not use the "Null" part.
int non-zero number
I tend to put ">=" for these kinds of things, juuust in case something weird happens. Maybe it's just me.
I tend to put ">=" for these kinds of things, juuust in case something weird happens. Maybe it is just me.
I tend to put this (which is not in the middle of you) until you want to put it back!
This can be simplified, right? else if (event.get(PublishedInfo.TIME_MODIFIED, new Date(PublishedInfo.TIME_MODIFIED, new Date(event.getSource())) {
This can be simplified, right? else if (event.get(PublishedInfo.TIME_MODIFIED, new Date(PublishedInfo.TIME_MODIFIED, new Date())) {
This can be simplified, right?
Can you please revert the changes on this file? It's not necessary to do so, but on a separate line if you prefer.
Can you please revert the changes on this file? It's not necessary to do so.
Can you please revert the changes on this file? It's not always the same as the previous state, so it's not known to time.
Why not have the cancel(true) and shutdown the CheckResult checkResult(AsyncReporter::check) in a finally block?
Why not have the cancel(true) and shutdown the CheckResult checkResult(AsyncReporter::check) in a finally block? Then it would only clean up the regular if (log.isDebugEnabled()).
Why not have the cancel(true) and cancel only the first? Then it's clear form the second.
RenamingThreadFactoryProxy would be nice, since it is the default value when you have a diff
RenamingThreadFactoryProxy would be nice, since it is very hard to read
RenamingThreadFactoryProxy would be nice, but I think it would be nice to have a diff
This could also be removed
This could be removed
This could also use the ==
![MAJOR](<LINK_1> Make "getSystemPropertyFile" a "static" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this method final so that it is only instantiated once. [![rule](<LINK_1>](<LINK_2>
@since 9.3 originSystem property.
needsComma I think would be a better name than hasComma
can we put indent a space after the {?
if size > 1 I think it should throw exception, so the caller can decide how to write and then use it.
@carl-mastrangelo shouldn't we be calling it label.remove()?
@carl-mastrangelo I wonder why we shouldn't make a body at all and not just call it get's body?
@carl-mastrangelo I wonder why we need to check for null before calling get on the handler?
this can be simplified to ((Util.ICP4D_DEPLOYMENT_URL)!= null)
this can be simplified to ((Util.ICP4D_DEPLOYMENT_URL)).
this can be simplified to ((Util.ICP4D_DEPLOYMENT_URL)!= 1)
I think we should consider making the "false" as the default if there is no "true".
I think we should use "false" here.
I think we should consider having a "false" for this case.
Isn't the try/catch different to the ones in the catch?
Isn't it the createCinderDomainId method? Maybe we should add some logging in the catch block.
Isn't it the createCinderDomainId method? Maybe we should add an audit log for the audit log?
Should we consider a list of Guid vdsmTaskIdList being null?
Should we consider a list of Guid so vdsmTaskIdList will be null?
Should we consider a list of Guid so vdsmTaskIdList will be empty?
Any reason this can't just be numToRemoveSecond = 0?
Any reason this call was just to verify the content of the media content as well?
Any reason this can't just be numToRemoveSecond = 0?
Log the exception here.
Log the exception?
Log the exception here?
rm
rm.
rm public
Hmm, this is not really required, if we have more than one timeout we should at least make this configurable?
Hmm, this is not really required, if we have more than one timeout we should at least log those IgniteEx messages,
Hmm, this is not really required, if we have more than one timeout we should at least have them set in them.
this is hard to reason about. Perhaps: Sha256Hash(rawRow, rowSize, metric.getColumn().getValue());
this is hard to reason about. Perhaps: Sha256Hash(rawRow, specs, Long.toHexString(rawRow))
this is hard to reason about. Perhaps: Sha256Hash(rawRow, specs, Long.toHexString(rawRow))...
As far as I can see, the code would be more readable. Also this could be rewritten as: private static final int InsnNode = context.getSourceDebugExtension() { if (context.getSourceDebugExtension() == i) { return; } // etc. if (context.getSourceDebugExtension() == i) { return; } // etc.
As far as I can see, the code would be more readable. Also this could be rewritten as: private static final int InsnNode = context.getSourceDebugExtension() { if (context.getSourceDebugExtension() == i) { return; } // etc. if (context.getSourceDebugExtension() == i) { return; } // etc. }
As far as I can see, the code would be more readable. Also this could be rewritten as: private static final int InsnNode = context.getSourceDebugExtension() { if (context.getSourceDebugExtension() == i) { return; } // etc.
A cast to IStatus is missing here.
The message should be "The workbenchWindow"
No need to cast
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "add" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "set" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "add". [![rule](<LINK_2>](<LINK_0>
You can use try-with-resources for both scanner and csis in the same block.
You can use try-with-resources java try (Scanner csis = new Mutation(tableName, Authorizations.setColumnFamilies()) {
You can use try-with-resources java try (Scanner csis = new AuthorizationsScanner(tableName, Authorizations.setColumnFamilies(1) + "value2",...);) {
Is there a reason to accessing a list here instead of a set and then converting to threads?
Is there a reason to move this declaration to a separate function?
Is there a reason to accessing a list here instead of a set and then converting to array?
You should be able to put this in the ReportNode.getMetricsWithoutChildren() method
You should put this in the synchronized block below
You should be able to put this in the ResourceGroupNode itself that is being translated from the metricGroup.
I don't know if this can be null here, but if you have to manually close the connection you should be able to do if (activity == null) { return; }
I think you can't really use the result of mPresenceView.append(providerId) function here.
I don't know if this can be null here, but if you have to manually close the connection you should be able to do if (activity == null) { return; } This prevents the need to perform the check at the end.
It seems that we also need to define the triggers for this or at least the number of entries in the map.
It seems that we also need to define the triggers for this or at least the regex?
And here.
public static? Is that keyword ordering important in this codebase?
String.format would be easier to read
String.format would be easier to read.
Use byte[] - probably better for most of the UTF-8 references
Use byte[]-styles
Use byte[]-styles.
catch operator?
catch Exception
catch throwable
This is a 5-line method that you have to do with the current thread as the request is in Utils.java.
This is a 5-line method that you have to do with the current thread as the request is in Utils.create(...)
This is a 5-line method that you have to do with the current thread as the request is in Utils.java. Maybe you can refactor it into a common method?
If this is null should probably be treated the same
If this is null then should probably be treated the same
If this is null should probably be treated as an empty string
now you can just do int scanId = telephony.requestNetworkScan(
now we can just do int scanId = telephony.requestNetworkScan(
now you can just do int scanId = super.requestNetworkScan(telephony);
- check mKeyPair.is not null
- check mKeyPair.isKeyStore()
- check mKeyPair!= null
I'd suggest keeping this as a java.lang.Long fromEventId (if people don't call toString()). With this change, I'd also make the query string a constant
I'd suggest keeping this as a java.lang.Long fromEventId (if people don't import this class)
I'd suggest keeping this as a java.lang.Long fromEventId (if people don't call toString()). With this change, I'd add a note that this is the query itself.
Nitpicking: do you mind splitting this in 2 tests for readability / style.
We can simplify this if statement to java if (site == null || post.isWPCom() || post.isWPCOMCredentials()) { return; } String[] TextUtils.isEmpty(site);
We can simplify this if statement to java if (site == null || post.isWPCom() || post.isWPCOMCredentials()) { return; } String[] TextUtils.isEmpty(post.getLink());
Check args?
Check args? As above, no need to assign.
Check args? Is the field is no longer needed?
Could we include the name of the exception as well?
Could you explain the use of FileAttributeView here?
Could we include the path /path?
And this is the same as the code above, you can move it to a private method and call it twice.
And this is the same as the code above, you can move it to a private method and call it here.
And this is not needed
I think the braces are redundant now.
I think the braces are redundant now
I think the braces are missing here
nit: the return type here is redundant
nit: the return type here is not necessary.
nit: the return type here is not necessary
Can we just use tpchValue.equals(columnType) here?
Can we just use tpchValue.equals(columnType) instead of columnType?
Can we invert this if?
Should the name of the token be changed from Text to user?
Should the name of the token be updated as well?
Should the name of the token be changed from Text to /?
Is it possible that the connector will never be 'null'?
Is it possible that the connector will not be 'in' at all?
Is it possible that the connector will never be 'null' for credentials as well?
I think this should be getInternalNumericId().
I think this should be getInternalNumericId()
I'm not sure this is correct. If id is null, should we just throw an IllegalStateException?
Please dont do this test, it is just a role (for the service, and the name of the test)
Please dont do this test, it should be true since it is called in a @BeforeTestUsers feature.
Please dont do this test, it is just a warning.
computeIfAbsent?
How about a test like this? computeIfAbsent seems more appropriate.
3 seconds?
Use.get() instead of.add().
Use.get() instead of this.
Use the constructor to get the token from card.
Could you also add a reference to the modelTypeName here?
Can you also remove "Anonymous".
Can you also remove "Anonymous type".
Should this be!Objects.equals()?
Should be!Objects.equals(Object, String)
Should be!Objects.equals(Object, boolean)
s/track/Failed
Won't this corrupt the exception?
Ignore?
we should handle return types java.util.Date and java.sql.Date
we should handle return types java.util.Date and java.Date
we should handle return types java.util.Date and java.util.Date
Why did the change to 1?
could we change this to unit test?
can we change this to unit test?
why do we check/break here, it is already covered in the while clause condition.
why do we check/break here, it is already covered in the for loop below.
why do we check/break here, it is already covered in the for loop below?
The field name has a getBytes method. I was thinking that the class would get called for each field, shouldn't it be the string representation of the dataOffsetBits? If so, that's not a good idea.
The field name has a getBytes method. I was thinking that the class would get called for each field, shouldn't it be the string representation of the dataOffsetBits?
The field name has a getBytes method. I was thinking that the class would get called for each field, shouldn't it be in the public method?
typo
Move this into the finally block
Fix the error message
now that the expected value is updated, is the replace all still needed?
now that the expected value is updated, is this replace all still needed?
now that the expected value is updated, is this expected?
Missing <LINK_0>
s/component/param/
Missing <>
Use a standard tag instead of using a magic number.
Use a constant instead of hardcoding "//"
Use a standard tag instead of hardcoding the scope.
This should handle the case where the map is not empty as it may not be returned by the map. Even though the map is immutable, it may not be exposed from changes to client code. So this map is not intended to be modified by another thread.
This should handle the case where the map is returned by MenuItem or that map is not empty.
This should handle the case where the map is missing from the map, and if it does not make sense to access the whole map outside the loop.
We should log the error and print the stack trace.
We should log the error and print the stacktrace.
We should log the error instead.
This is a test, so let's not change it
This is a test, so let's not get it.
This is a test, so let's not get it. If you need a test for this, the test should fail anyway.
you may have just copied this over, but is there a reason this returns null instead of catching the NPE?
you may have just copied this over, but is there a reason to use the reader?
you may need to use reader.readLine() here
Please don't print the stack trace.
Please don't print the path in memory.
Please don't print the line character inside this class.
What is the benefit of having a switch here?
There are separate tests for this, Pull them out into a method and reuse.
What is the benefit of having setHeader in the builder instead of searching HttpHeader?
I have a feeling that if we try to ling the code, we need to try to initialize the streams. If we want to try first, we should try to avoid the code duplication. But even though we need the try-with-resources
I have a feeling that if we try to ling the code, we need to try to initialize the streams. If we want to try first, we should try to avoid the code duplication. But even though we need the try-with-resource I have been trying to read the code, I almost tried it and it didn't get anything else...
I have a feeling that if we try to ling the code, we need to try to initialize the streams. If we want to try first, we should try to avoid the code duplication. But even though we need the try-with-resource I have been trying to read the code, I almost tried it and it didn't get the code.
Extract private method?
static import
Extract method?
A random header id should be added if httpHeaders is null.
This shall be done to a simple if statement.
This shall be done to avoid these.
Not a big deal but I'd recommend using a Util.isWindowsHaxmInstallCommandLine() here (which would make it fail)
Not a big deal but I'd recommend using a Util.isWindowsHax here
typo
can you change this so it isn't related to the protocol? Maybe need to change the SubscribeHelper and have it in one place?
can you change this so that it does not break older clients?
can you change this so it isn't related?
why not just set the body here?
why not use a null query?
why not use a try-with-resources?
Can we use the same MetadataFieldUtil method?
Can we use the same MetadataSchemaService here?
Can we use the same MetadataFieldUtil function?
Perhaps single quotes around actual code
Perhaps single quotes around actual text
Perhaps single quotes around actual code?
@inverno This null check is redundant.
@vilchik-elena This null check is redundant.
@inverno This null check is redundant, the null check will never be reached.
Instead of passing a listener in the middle of the callback chain, should the queue reader manage its own queue? Can the queue be full?
why does this need to insert a listener in the middle of the callback chain? Can the queue reader manage its own queue?
Instead of passing a listener in the middle of the callback chain, should the queue reader manage its own queue? Can this use a different callback instance?
The length can't be null, can it? if so, do we need check for length and MAX_NUMBER_OF_UTF8 or something similar?
The length can't be null, can it? if so, do we need check for length and MAX_NUMBER_OF_UTF8?
The length can't be null, can it?
Not sure if this is a good idea, but I think it would be more readable if you was something like: java.filter(NotificationCategory::isRead).map(NotificationCategory::getName).collect(Collectors.toList());
Not sure if this is a good idea, but I think it would be more readable if you was something like: java @Override public void readNotificationActionAlready(NotificationState action) { if (NotificationCategory.isRead()) { return true; } for (NotificationState action : READ_ATTRIBUTE) {... } }
Not sure if this is a good idea, but I think it would be better if you was used %s instead of _ prefix.
how about renaming this variable to noStarlarkHandle?
what about renaming this variable to noStarlarkHandle?
how about replacing all of the code with a variant that returns true?
This test will pass even without your latest change, right? Seems like this would be a problem with the test below. Contains use assertEquals("Access Token TEST_IDTOKEN_UP", TEST_IDTOKEN_UPN.getId());
This test will pass even without your latest change, right? Seems like this would be a problem with the test below. Contains use assertEquals("Access Token TEST_IDTOKEN_PREFIX", TEST_IDTOKEN_UPN.getId());
This test will pass even without your latest change, right? Seems like this would be a problem with the test below.
final
final.
Duplicate assertion
I think it will be better to perform the removal of the managed block disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
I think it will be better to perform the removal of the managedBlock disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
I think it will be better to perform the removal of the managed block disks after we start the async operations to remove the regular images because the removal will be removed. (as the removal of the cinder disks)
minor: this variable is not used outside of this patch. You can put it in a private method.
minor: this is a little confusing since you are changing the logs in this file. Please change this to debug
minor: this variable is not used outside of this patch. You can put it in a private variable in this class.
maps should have a better name.
maps should be final or do we need to have this?
Block should be camelCase, this is just a wrapper.
Remove the catch block and let the exception propagate normally (which fails the test)
Remove the catch block and let the exception propagate normally (which fails the test).
Remove the catch block and let junit handle the exception.
Could use the Constant.messages.getString(context) method.
Could use the Constant.messages.add() method.
Could use the Constant.messages.getString(context) instead.
You can use game.getPlayer(player.getPermanentOrLAND(3)).
You can use game.getPlayer(player.getPermanentOrLAND()) instead of calling isVisible on player.
You can use game.getPlayer(player.getPermanentOrLAND(...)). That way always won't call onNext() which doesn't require that.
What's the motivation behind this change?
replication -> data
redundant
We need to get the LifecycleListener from the interface, maybe use it for the common controller.
We can use LifecycleListener.getServiceName(ProtocolEvent.ACTIVE); for wrapping the LifecycleListener.
We need to get the LifecycleListener each time, maybe use it as well?
Now that we have the same type, why not just check for null?
Now that you have the same type, why not just check for null?
Now that you have the same type, why not just return ICompilationUnit.class.cast(fModel); instead.
taskGroupEntry is thread-safe so I think it should be possible to make this Runnable instead of TaskData.isRunning()
taskGroupEntry is thread-safe so I think it should be possible to make this taskGroupEntry.getValue() return null and then throwing an exception. It also catches NPE in the old code.
taskGroupEntry is thread-safe so I think it should be possible to make this taskGroupEntry.getValue() return null.
Let's make this a separate method, with a descriptive name.
Let's move this into a separate function, like boolean updatePartError()
I'm having trouble reading this. I think it would be easier if we extract this into a method, something like boolean updatePartError()
[minor] Just use getIn().setHeader("date", get()); rather than just shorten the code below.
[minor] Just use getIn().setHeader("birthday",");
[minor] Just use getIn().setHeader("birthday.APRIL", getStartOffset(), getTempdate());
Is it okay to throw an exception here?
Is it worth throwing an exception here?
Is there a reason we do not use the regular delete operation here?
Please rename this variable list to pushResults for example
Please rename this variable list to pushResults to avoid duplication.
Please make this variable final.
This log statement is wrapped in a RuntimeException. Should it be logged at DEBUG or should the isDebugEnabled check be removed?
Does it make sense to log the exception?
Does it make sense to log the isDebugEnabled if clause, or are you sure that the trace log is wrapped in a log?
I think we should use == instead of equals here.
I think we should use assertEquals, it does the actual work.
I think we should use assertEquals, it is a bit more readable
Why this change should be a part of this PR? cardinality - numS should be a little cleaner and easier to understand.
Why this change should be a part of this PR?
Why this change should be a split??
Space after,.
Can these be extracted to a method?
Can these be extracted to a setUp method?
no need for the assertThat(res.getDependencies()).isEqualTo(4);
no need for the assertThat(res.getDependencies()).hasSize(4);
no need for the final to call this method twice
please use.equals() instead of.equals()
please use.trim().isEmpty()
please use.trim().isEmpty() instead of length check
I think we should put the thread name in a constant, and then use it in the thread.
I think we should put the thread name in a constant, and then use it in the runnable instead of waited the thread.
I think we should put the thread name in a constant, and then use it in the runnable instead of waited for "GONE".
assertEquals(boolean actual, boolean expected)
assertTrue(boolean actual, boolean expected)
assertTrue(Iterables.isEmpty())
can it be faster to call it e.g. return i;
can it be faster to call it app?
can it be faster to call it app
nit: looks like you're doing ++i here right? What's the point of it?
nit: seems like this can be simplified as awaitPartitionMapExchange()
nit: seems we can just use MAX_CLUSTER_SIE * 3 here.
null -> getMessage
null?
null ->!
same as above, please use RepositoryFiles.trash
same as above, you can use injected artifact
same as above, you can use injected artifact.exists()
Please move this call to the outer try-catch as the error will be emitted in the onNext function. You want to make sure that onNext is called once per subscription.
Please use the SynchronousObservable type here. This particular class is a member variable.
Please use the SynchronousObservable type here. This particular class is a member variable, so that when implementing the SynchronousObservable type, we won't need to manage to access the class context.
Is this really an error log message?
Is this really an error situation?
Is this really an error message?
Instead of setting this logic ourselves, I'd just add a helper method to do this: private void updateBroadcastMemoryContext(Page pageContext context) { long currentMemoryUsage = localUserMemoryContext.getWorkContext().getWorkContext().getWorkContext().getWorkContext().toBytes(); if (Blur.getEstimatedSize() && currentMemoryUsage!= null) { currentMemoryUsage.setBytes(page.getPositionCount()); }
Instead of setting this flag, I'd just do the current userMemoryContext.getWorkContext().getOptionsContext().getUnique(PositionContext.class);
Instead of setting this current user memory, just use the supplier
I think we can just check if it is empty before we return to make sure that we return to avoid throwing an exception here.
I think we can just check if it is empty before throwing an exception here.
I think we can just check if it is empty before we return.
I don't think the finally is needed. If there is a problem with the current code, it seems that we will be stuck with a null pointer exception here. Consider moving this to the finally block in the try block.
I don't think the finally is needed. If there is a problem with the android code it seems to be saved in the database, and it's still needed. If we don't, there will be a bug in the current code, and we should be able to remove this line.
I don't think the finally is needed. If there is a problem with the current code, it seems that we will be stuck with a null pointer exception here. Consider returning null.
Just passing in the namespace should always be true -> NewPreferencesPreferences_GLOBAL_PREFERENCES_DIRNAME + " here and in 1855"
Just passing in the namespace should always be true -> NewPreferencesPreferences_GLOBAL_PREFERENCES_DIRNAME + "driver-host"
Just passing in the namespace should always be true?
Please don't use the exceptions, so no need to wrap them in a RuntimeException (to allow them to be thrown by the mapper)
Please don't use the exceptions type unless we're going to throw. I think it would be better to throw a RuntimeException instead.
Please don't use the exceptions, so no need to include the parameters.
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
This can throw if there are no principals. It should probably have an explicit check for the builder
This can throw if there are no principals. It should probably have an explicit check to throw a proper exception
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility methods for creating and deleting a case.
It looks like we have duplication of code in the ingest file filters tests; we should look into creating some new utility methods for creating and deleting a case.
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility methods for creating and deleting one.
rename to event
rename to child or event
rename to event or something
This should return!TypedObjects.isEmpty(request)
This should return false if the command is already present, otherwise it may be empty.
This should return false if the targetEditPart is already there.
Agreed. I'm wondering if we should not _not_ set the environment value with a default, and catch the exception and not just the error message?
Agreed. I'm wondering if we should not warn when components are set.
Agreed. I'm wondering if we should not _not_ allow the component to be empty, but we can't just use the output stream so that we can get a final output.
I think it is better to extract all this code into a method and call it from this method: buf.append(t1.getClass().getName()).append("\n")
I think it is better to extract all this code into a method and call it from both the t1 and t1.getLocalizedMessage() as is too long.
I think it is better to extract all this code into a method and call it from this method: buf.append(t1.getClass().getName()).append("\n");
Better use java if (!CollectionUtils.isNotEmpty(folderFile)) { return new IllegalArgumentException("Incorrect path to folder " + fileName + ". Reason: " + extensionFile.trim()); }
Better use java if (!CollectionUtils.isNotEmpty(folderFile)) { return new IllegalArgumentException("Incorrect path to folder " + fileName + ". Reason: " + extension); }
Better use java if (!CollectionUtils.isNotEmpty(folderFile)) { return new IllegalArgumentException("Incorrect path to folder " + fileName + ". Reason: " + extensionFile.getAbsoluteFile()); }
It seems we have two methods, except one can be unified. Perhaps we should change it to Vector.of(...)?
It seems we have two methods, except one can be unified. Perhaps we should change it to Vector.fromNullable(...)?
It seems we have two methods, except ophin, arrayRate and decayRate. How about shortening the condition?
why not write to a temp file?
why not write to a temp file in the directory?
why not write to a temp file in a field?
this method is big, please refactor to more readable code
this method is big, please extract to clearIndexOfValue,
this method is big, please extract to method,
Can be rewritten as java if (cacheTypes.size() > 0) { cacheTypes.add(sortedType); }
Can be rewritten as: if (cacheTypes.size() > 0) { cacheTypes.add(sortedType); }
Can be rewritten as java if (cacheTypes.size() > 0) { cacheTypes.addAll(cacheTypes); }
same question as above for request
Can we put the perf clientMetrics in a function?
Can we put the perf client metrics into a method?
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression and avoid having to pass over memberClass.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression which replaces memberClass.getName() in the ternary expression.
Return an empty list instead of null (same for L59)
Return an empty list instead of null (which probably doesn't need to be null)
Return an empty list instead of null (same for line 59)
replace with ProjectUtil.isFolder
replace all these exceptions with ProjectUtil.isPut(new IResource[] {... }
replace with "catch" and "should not be needed"
This is a little confusing. I'd suggest we close the "Socket Name" and "tempProto" directly.
This is a little confusing. I'm not sure how "tempProto" can be folded into the "populate" method. What do you think?
This is a little confusing. I'm not sure how "tempProto" can be folded into the "populate" method.
I'd rather go with a NULL value.
I'd rather go with the flipped message instead of the local result.
I'd rather go with the flipped message instead of the 'getOutput().getError()'.
Shouldn't we check if long calls are made and return null?
Shouldn't we check if long calls are made and return false?
Shouldn't we check if long calls are made and make sure it gets an error?
Code role should be removed.
validateSecurityRoleName is never null.
not sure why we need to check for emptiness
I think it would be more clear to return task.getInternal().getScheduledTime().stream().filter(task -> task.getInternal().equals(task.getInternal())).forEach(task -> {... });
I think it would be more clear to return task.getInternal().getScheduledTime().stream().filter(task -> task.getInternal().equals(task.getInternal().longValue())).forEach(task -> {... });
I think it would be more readable if it had a task.getInternal().getScheduledTime() call instead of the stream().
is there a reason to synchronize on the iteration, or the thread is already interrupted?
is there a reason to synchronize on the whole method? In the future I'd be wrong here and there's only one thread calling flush, but the code in this case, meaning the thread should be responsible for closing it. That way the iteration is guaranteed to be greater than the one thread in the loop, which is bad
is there a reason to synchronize on the whole method body and then add the thread to it?
1. I wonder if it is better to get into test state without testing. 2. Why don't we set the listener before testing?
Why don't we assign the listener before the test?
Hey @inverno Why don't you get the listener outside the test?
This should be put into a constant.
Why remove the need for a separate variable?
Why put // into a constant?
This should have a space after the comma.
This should read the property from the config file and could use default value.
This should have { }.
Writer is not closed, so close it.
Writer is not closed, so just close it.
Writer is not closed?
I think it would be best to add an additional constructor parameter to the map.
I think it would be best to add a case for the evaluator's values (in case it has more than one param per row).
I think it would be best to add a case for the evaluator's values (in case it has more than one param per line).
Could be public
Could be static
Could be static.
why storageManager.PutRequest, and not StorageManager?
why storageManager.PutRequest, instead of highest TokenMap?
rename to StorageManager
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase.
Please do not use log4j one more.
Please do not print stack trace
final
Assert that the card has been destroyed at the end of the test?
Assert that the card has not been deleted.
This is the same logic as we have above. So we should probably extract this out into a method or method somewhere.
This is the same logic as we have above. So we should probably extract this into a method or method somewhere.
This is the same logic as we have above. So we should probably move the suggested logic out into a method somewhere.
I think you can use the interface instead of this:.withClass(() -> SIKey.LOAD_BALANCING_FACTORY);
I think you can use the interface instead of this:.withClass(() -> SIKey.LOAD_BALANCING_POLICY_CLASS))
I think you can use the interface instead of the IllegalStateException (in this case a couple of other tests).
You can just use an instance variable for this
You can just use an if (this.spongeTexts.removePlayerDisconnect()) {...
You can just use an if (this.spongeTexts.removePlayerDisconnect) {...
you can use \t for the indentation instead of spaces
why are we indenting in the logs?
This should probably use the Guard class to check for empty strings
A much faster way to do this would be to just: Map<Class<?>, Object> infos = new HashMap<>(); for ( Id<Class<?>, Object> entry : entityInfos.getSessionFactory()) { infos.put( entityInfo); }
A much faster way to do this would be to just do a lookup for the computeIfAbsent.
A much faster way to do this would be to just do a lookup on the computeIfAbsent.
could we use a more descriptive name?
could we make this a constant?
can we use a more descriptive name?
Probably should be SURF RAM login, same for description.
Probably should be SURV RAM login, same for description.
Probably should be %, same for description.
There is a typo here. Sentences should start performance (it can be more specific)
There is a typo here. Sentences should start performance?
There is a typo here. Sentences should start performance (it can be removed too)
We should move this logic to a helper method like createOutputMessage() where that is used. There is several methods to do that (and others)
We should move this to a method like createOutputMessage(Message<?>)
We should move this logic to a helper method like createOutputMessage(Message<?>) which is called on the next line. That way the caller doesn't have to worry about creating and where this is thread-safe.
why this. and not use scene.getSceneID()?
please remove the.getSceneID() since you are using this.
please remove the.getSceneID()
Is there a reason you don't use TextUtils.isEmpty() here? if (result == null ||!email.equals(email)) {.. } else {.. }
Is there a reason you don't use TextUtils.isEmpty() here? If you're checking for empty string first, then you can use TextUtils.isEmpty() instead.
Is there a reason you don't use TextUtils.isEmpty() here?
You also have to remove the m_isLeader check since it's only DONE if m_isLeader is true.
You also have to remove the m_isLeader check since it's only DONE if m_isLeader is null.
You also have to remove the m_isLeader check here since it's not going to be null.
could use TmfNanoTimestamp
Is the signal necessary?
Is this method meant to be updated?
as we are changing how the digest is computed anyway, can we add another \n here?
as we are changing how the digest is computed anyway, can we use buf.append(',');
as buf.append(',');
assertTrue instead
Is this assert necessary?
assertTrue
Just use == instead of equals: if null == existing use of an ==.
Just use == instead of equals: if null == existing use of "h"
just use == for an exception.
DatastreamProducerRecordBuilder?
DatastreamEventInput was defined as a constant in DatastreamEvent.java.
DatastreamEventMessages.messageIds_kafka-origin-partition is already defined for event.metadata. Please remove it.
getScore() doesn't look like this. There's no guarantee that the solver config will be started.
getScore() doesn't look like this. There's no guarantee that the solverFactory will be closed.
getScore() doesn't look like milliseconds is used in the
This should be above the try/catch
This should be.log
This should be simplier than it will cause any trouble
You can move this check to superclass
You can move this check into superclass
you can move this check to superclass
This method is doing the same thing, but as you're already downloading the whole file, why do you need to fail on the file?
This method is doing the same thing, but as you're already downloading the whole file, could you pass it to this method in a lot?
This method is doing the same thing, right?
i think this can be simplified to get rid of the null check and just return usable.get(null, null);
i think this can be simplified to just get rid of the null check and return the usable variable.
i think this can be removed.
Would it be better to have a special case for when we have truth?
Would it be better to have a special case for when we have multiple DISTINCT keyword?
Would it be better to have a separate constant for this?
typo
static import
final
You should have the same, and just return at the end of the method.
You should have the same, and just return at the end.
You should have the new IllegalArgumentException(...).
Use for (String url : headers)
Use map?
Use for (String url : headers) {
This fits properly in the previous line
This line is duplicated
This fits properly after the previous line
That would be slightly clearer if you would change this to TProgressUpdateCompleted.
Does this mean that command result will be null?
That would be slightly clearer if you would change this to TProgressUpdateCompleted.waitForUpdateCompleted.
Not sure what this test is supposed to test.
Not sure what the message body is supposed to be.
Abandon that this is actually important. Is this the expected behavior?
There is a new FileAccessException file that you can use instead of string concatenation.
Can you use "hibernate" here?
There is a new FileAccessException file that you can use instead of file.exists() ;)
is it possible for the smallestFilesToCompact is a non-zero entry size?
is it referring to smallestFilesToCompact is a little smarter than just calling getSecond?
is it referring to smallestFilesToCompact is a little smarter than just calling getSecond()?
how about results.addAll(subDomainMatch, path, secure) here?
how about results.addAll(subDomainMatch, path, secure)
how about results.addAll(subDomainMatch, path, false)?
suggestion } catch (NoSuchAlgorithmException nsae) {
suggestion } catch (NoSuchAlgorithmException nsae) { }
suggestion log.error("Unable to initialize default X509ExtendedTrustManager", nsae);
s/originalContentType/type/
s/originalPayload/originalPayload
_originalPayload instanceof byte[]_
I don't think we need this. The readBuf method is already read from the ByteBuffer, it can't be used.
I don't think we need this. The readBuf method is already read from the ByteBuffer, that is covered by the method.
I don't think readBuf return value, it is likely to be 0 here.
This can be simplified by doing a filter using.filter(queryId ->!queryIdMap.containsKey(FORCE_FREE_TAG))
This can be simplified by doing a filter using.filter(queryId ->!queryIdMap.containsKey(FORCE_FREE_TAG)).collect(Collectors.toMap( queryId -> {.. })
This can be simplified by doing a filter using.filter(queryId ->!queryIdMap.containsKey(FORCE_FREE_TAG)).
SAP
Typo in variable name
Typo in variable name.
Why don't we assert message here?
Why don't we assert message here any more?
Why don't we assert message here any longer?
use a constant for 0 to avoid typos
use a constant for 0 to avoid any typos
remove the use of dummy variables
Should we be using CachingField?
Should we be using ValueObject.asNativeString() here?
Should we be using ValueObject.asNativeString?
Can you change this to an interface?
could you change this to an interface?
could you change this to an if?
Use constant for port
Use ==, this will cause to NPE
Use constant for string type
Activator.PLUGIN_ID use activator of tmf.core
Activator.PLUGIN_ID use String.format(...) instead of concatenation
Activator.PLUGIN_ID
I think a better way to do this would be to have a APP_SERVER_NAME rather than "group-id="+equalsIgnoreCase(cluster_name) log statement here so we can prevent this here.
I think a better name for this - "group-id="+key) or something like this..
I think a better name for this - "group-id="+confname) or something like this..
Don't need this line.
In the case of trainer does not have any retry, we should find any error.
In the case of trainer, there is no Data for the epoch. Why can't we use AsyncDataProvider here?
I think it is correct to use resultsService.next() as it is used a few lines above.
I think it is correct to use resultsService.next() here.
I think it is correct to use resultsService.next() here. That way, we can use Collections.singletonList(next) and it will be faster.
maxSize being an index, that is the minimum between buffer and the maximum size. Btw, I'm not sure it is the best approach.
maxSize being an index, that is the minimum between buffer and the maximum size. Btw I'm not sure it is the best way to handle this.
maxSize being an index, that is the minimum between buffer and the 'every.
[minor] Just pass in the matcher and avoid the need for [this](<LINK_0>
[minor] Why are we doing a literal check here for better readability?
[minor] Why are we doing a %s here for better readability?
Should always be true since it is the same as isStudent
Should always be true since it is the same as isStudent.
Should always be true since it is the same as in the else if
It could be simplified to... java data.get(obj);
It could be simplified to... if (logger.isDebugEnabled()) {... }
It could be simplified to... if (logger.isDebugEnabled()) { data =... }
Why the copyReqBuilder to copyReqBuilder to a temp var?
Why the copyReqBuilder.copy(source) and copyReqBuilder to copyReqBuilder?
Why the copyReqBuilder to copyReqBuilder?
final
this variable is not used anywhere.
this is not needed.
We could use method reference here: java final Node node = event.getContent() instanceof NodeDefinition; final Node node = (HasName) element; if (node.getContent() instanceof NodeDefinition) { final Node node = (Node) element; final Element Definition) element = ((HasName) element).getDefinition(); final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Node node = (Node) element; final Element Definition) element = ((HasName) element).getDefinition(); final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element; final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element; final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element; final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element;... } }
We could use method reference here: java final Node node = event.getContent() instanceof NodeDefinition; final Node node = (HasName) element; if (node.getContent() instanceof NodeDefinition) { final Node node = (Node) element; final Element Definition) element = ((HasName) element).getDefinition(); final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Node node = (Node) element; final Element Definition) element = ((HasName) element).getDefinition(); final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element; final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element; final Node node = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = element.getContent(); if (node.getContent() instanceof NodeDefinition) { final Element element = ((HasName) element).getDefinition(); final Element element = (Definition) element;... } }
We could use getDefinition() as an Optional<Definition>, and store it as a final field instead.
could you change this to a fixed error message?
could you change this to a fixed message?
Is this with an error msg?
how about using the hashCode() equals()?
how about using the hashCode() here?
how about using the hashCode() equals() instead of hashCode()?
This looks like a copy paste mistake, it should be Sns.
This looks like a copy paste mistake, it should be sns.
This looks like a copy paste mistake, it should be Sns
Up to you: if (response.getStatus() == null) { return toRpcResponse.Status.NOT_FOUND; }?
Catching a 500 exception here seems too broad.
Up to you.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce this anonymous class number of lines from 22 to at most 20. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this line start at column 9. [![rule](<LINK_2>](<LINK_1>
We should have this row defined in a base class.
if this listed the available names it'd probably be very helpful for people
if this listed the available names it'd probably be very helpful for users.
It'd be nice to have some common Deserializer methods. Throw an exception if the object is empty
use Field.class
use ExportedProperty.class
use guava
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if addDefaultRoute fails, perhaps it makes sense not to set mDefaultRouteSet to true?
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if add mDefaultRoute fails, perhaps it makes sense not to set mDefaultRouteSet to true?
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if addO is true, perhaps it makes sense not to set mDefaultRouteSet to true?
(minor)
(minor) Also, shouldn't this be an if statement?
(b)
1. It will be nice to remove the RuntimePermissions from here - only E.g., there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> 2.
1. It will be nice to remove the RuntimePermissions from here - only E.g., there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> 2. Currently there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> )
1. It will be nice to remove the RuntimePermissions from here - only E.g., there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> 2. Currently there will be added privileged block instead of <LINK_0> (discussion in <LINK_1> )
I don't think you've set the builder's capacity to 0 here and below...
I don't think you've set the builder's capacity to 0 here and remove the header.
I don't think you've sufficient the toString() operator.
I think saga.getClass().isPrimitive() is more appropriate, as that's what we want to do.
I think saga.getClass().isPrimitive() is more appropriate, as that's what we want to have.
I think saga.getClass().isPrimitive() is more appropriate, as that's what I had before with the get.
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.computeIfAbsent(recipientTeam, k -> new LinkedHashMap<>());
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.get(recipientTeam, k -> new LinkedHashMap<>());
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.getOrDefault(recipientTeam, k -> new LinkedHashMap<>());
In case of exception, we shouldn't make a command with nocallcall (I think it's ok to ignore it) and set cellElement
In case of exception, we shouldn't make the cellCount == 0 case. I think that we can define a field with a single element instead of referencing a new one.
In what case can we put a line break?
should probably be channelIsAdmin check?
Should we be able to just assign the set of existing substudies?
Should we be able to just assign the substudies of the account?
You could eliminate the need for the function here. You could just inline it.
You could eliminate the need for the function here. You could just inline it into the code, right?
You could eliminate the need for the if (artifactsLocation.getFileName(' ')) { executeShellProcess(file, artifactsLocation); }
If the new version is null, we should throw an exception instead of returning null.
If the new version is null, we should throw an exception instead of passing null.
If anchromosome, we should have the correct version be null.
checkTypeMismatch at the end?
checkTypeMismatch at the moment?
checkTypeMismatch at the beginning of the method
Can we move this line to the front of the if statement?
Can we move this case to the first switch statement?
Can we move this case to the first screen type?
Also, here we should use getType(TransformFunction.class) instead of FUNCTION_MAP.
Also, here we should use Arg indicating whether this will happen for all transform function is in the middle of the transform function.
Also, here we should use Arg indicating whether this will happen for all transform function types
Should we add a metric here?
Should we add a lock to pipeline here?
Should we add a write lock here?
coding style: try-with-resources?
I think it would be faster to load the config once, and then close it in the finally block.
coding style: try-with-resources.
store method: String[] w = "view"; for (String entry : entries) {"
store method: String[] entries = "hi there.read("file", "target");
rename to entry
I think the queryTag variable should be renamed to handle*InResponse. In this case, handle usage of the formatter and the else branch below it.
I think the queryTag variable should be renamed to handle*InResponse. In other words, are you sure that the TransportFactory is always of type Optional?
I think the queryTag variable should be renamed to handle*InResponse
I believe you can put this line after the first assertAllInformationMatch method.
The fsData is never null so you should assert that there are no equals to be present?
The fsData is never null so you should assert that there are no equals to be?
here we'll want to throw only if we are not already tracing this packet.
here we'll want to throw only if we are already tracing this packet.
here we'll want to throw only if we are not already tracing this packet:
Please merge both the conditionals into one
Please merge both the if and move code into a separate method
Please merge both the conditionals into one line
Remove the containsKey and directly call cacheNewValue here.
Remove the containsKey and directly call cacheNewValue
Remove the containsKey wrapper
why do we need to do that? I'm not sure we want the token to be stable after this.
it means that we need to do a token.setAttribute(auth_config, boolean) in order to support login, no?
it means that we need to do a token.setAttribute(auth_config, boolean) in order to support login, correct?
R.array.getString(R.array.server_url_key) can be simplified to r.getLastText().
R.array.getString(R.array.uri_url) can be simplified to r.getLastText().
helper method can take in multiple places, I think it would be nicer.
You could also use getString() in place of strings.xml.
You could do more elegantly using StringUtils.stringToIntString(R.plurals.length)
You could do more elegantly using StringUtils.stringToIntString(R.plurals.length) now.
extra space
space between () and brackets
space
Shouldn't this be "' with value '" + target + "' with value '" + target + "'");? And do we need to add this as a here?
Shouldn't this be "' with value '" + target + "' with value '" + target + "'");?
Shouldn't this be "' with value '" + target + "' with value '" + target + "'");? Why is it needed for the other methods? Also I don't think we should add this as a necessary add field in the Impl class?
Use _int_ instead of _byte_ to allow for values > 127...
_loc_ can be defined locally only when needed: java case _loc_
_loc_ can be defined locally only when needed: java case _int_ => 127...
What is the use of expected and actual in this test?
What is the use of expected.patient?
What is the use of expectedException
@felipeaziz Use Integer.compare(techList, date, Patient.class) instead of two English names.
@felipeaziz Use Integer.compare(techList, person.getPositive().getCode(), Comparator.comparing(Technology::getName));.
Please use English only for variables.
Wrong check for you, IMHO
Wrong check, should be!unifiedMessage.getCategory().isEmpty()
Wrong check for you, IMHO.
Use 'Guava'.
Use 'getEntity()' method to populate the connection with no parameters.
Use 'getEntity()' method to do the casting
It seems like we are creating an authorization user for each test, which means we are dealing with an existing user. Wouldn't it be better to just throw a RuntimeException?
It seems like we are creating an authorization user for each test, which means we are dealing with an existing user. Wouldn't it be better to just throw a void method for the WorkflowWorkflowService?
It seems like we are creating an authorization user for each test, which means we are dealing with an existing user. Wouldn't it be better to just throw a void method for setting the current status?
Typo here.
You don't need the builder here.
You don't need the builder here anymore.
Isn't this a bit present? I think it would be cleaner to throw an exception if we could have a RNAResource throw an exception if the latter is not found.
Isn't this a bit present? I think it would be cleaner to throw an exception if we could have a RNAResource that checks the arguments?
Isn't this a bit present? I think it would be cleaner to throw an exception if we could have a RNAResource throw an exception if the latter of those are not supported?
>80 chars and extract
use static import
use static import?
ArrayList should be constructed with fixed capacity.
Why not to use the NODE_CHANNEL constant?
Why not to use the NODE_PORT here?
I didn't get why you didn't use RtForks in MkForksTest tests. We should check MkForks instead
I didn't get why you didn't use RtForks in MkForksTest tests. We should test MkForks instead
I didn't get why you didn't use RtForks in MkForksTest tests. We should check MkForks in MkForksTest
log the exception
log the exception stack trace
log the exception message
I am not sure which operation we need to handle. What happens if expiry is null?
I am not sure which operation we need to handle. What happens if expiry is set to UTF-8?
I am not sure which operation we need to handle.
This can be a bit more efficient as it was originally added. Like other pool.acquire() calls.
This can be a bit more efficient as it is not populate() method. Like other pool that is created in pool.
This can be a bit more efficient as it is not populate() method. Like other pool that is created in one try{}finally.
Shouldn't this be logged instead?
Shouldn't this exception be logged?
Shouldn't this exception be logged instead?
Use already definedVmDevice in the model provider
Use formatter please
Use formatter
Might want to remove the System.out.println from the logs.
Do we need this? or is it just for debugging?
Do we need this?
This should be an IOException so that it doesn't get logged.
This should be an IOException so that it can be dropped.
This should be an IOException.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might change any state.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might change somewhere.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in).
Accidental line break?
Accidental copy & paste
Unnecessary?
I think it should be c.clear()
We should use cache.clear() instead.
We should use cache.clear()
Any reason for the specific guard? I.e. gtk_VERSION is always known. Any reason for the specific guard?
Any reason for the specific guard? I.e. gtk_VERSION is always known. Is there any reason for it?
Any reason for the specific guard? I.e. gtk_VERSION is always known.
We should do this logging in there too.
You might want to consider logging the current metrics rather than sending it to the metricName?
You might want to consider logging the metricName, too.
Should be checked for null.
Should be in an else.
Should be moved to after.
Splash?
Why is this line needed?
Why is this second block needed?
.map_url -> PortalConfig.portal_url
.map_url ->.getPortalConfig()
.map_url ->.ifPresent( webMapItem -> {
Formatting: addDnsTimeoutEvent(wrappedMonitor, new WrappedNetworkMonitor())
Formatting: addDnsTimeoutEvent(wrappedMonitor, new WrappedNetworkMonitor(wrappedMonitor));
Formatting: addDnsTimeoutEvent(wrappedMonitor, new WrappedNetworkMonitor()).
Change 'else' statement to block i.e. add braces.
Change 'else' statement to block i.e. add curly braces.
Change 'else' statement to block i.e. add { }.
How about making this a constant?
How about having this code in a common place?
How about making this a constant and maybe even an enum?
Nit: Why can't we just do List<AbstractReflection> itemType = dataTable), EDIT:
Nit: Why can't we just do List<AbstractReflections> itemType = dataTable), EDIT:
Nit: Why can't we just do List<AbstractReflections> itemType = dataTable), and change the type to one of the other?
I think you can use streams here instead: return StreamSupport.stream(a, b).map(a -> b.getInterpolatedStopsDoNotHaveTimes(f, b)).collect(Collectors.toList());
I think you should be able to use streams here instead, which would be great.
I think you can use streams here instead: return StreamSupport.stream(a, b).map(a -> b.getInterpolatedStopsDoNotHaveTimes(f, b))
Shouldn't we rather compare the number of entries in the hash and set the actual number of entries in the syncManager?
Shouldn't we rather compare the number of entries in the hash and set the actual number of entries in UserAccountManager.java?
Shouldn't we rather compare the contents of the hash set in UserAccount and avoid any refresh?
We should add a space after "if (urls.isEmpty()) {"
We should add a space after the if and before the {
We should add a space after the if and always use { and }
Maybe consider String.valueOf() to circumvent NPE.
Maybe Maybe String.valueOf() to circumvent NPE.
Maybe Maybe String.valueOf()
Why do we need to create the list if it's not going to be used?
Why do we need to create the list if it isn't empty?
Why do we need to create the list if it's not empty?
Absolute path for example?
Absolute state is not correct
s/long/Long
How about a const?
could you put this a class constant?
could you put this a const?
I think this is obsolete, but a change in the surrounding pause would be simpler than there.
I think this is obsolete, but a change in the surrounding pause would have been easier to follow
I think this is obsolete, but a change in the surrounding pause would have been easier to follow...
The constant must be before the variable.
The constant must be before a variable.
The variable name is misleading.
I preferred the old way where we had methods getAllDimensions. BetterCodeHub will probably ding this for complexity and number of lines.
I preferred the old way where you had methods getAllDimensions. BetterCodeHub will probably ding this for complexity and number of lines.
I preferred the old way where we had methods getAllDimensions. BetterCodeHub will probably ding this for readability.
I think this check is not necessary if the account does not exist or has been moved.
I think this check is not necessary if the account is not exists or has been deleted.
I think this check should be done in a private method.
It looks like this path can be null.
It looks like this path is different from fieldNames. I think it's easier to read.
It looks like this path is not needed.
if you look at the config, don't you think it will be a good idea to fail the request instead?
if you look at the config, don't you think it will be a good idea to fail the metric here?
if you look at the config, don't need to mark it as deprecated.
@vkdrn Thanks for toString()
@vkdrn Thanks for toStringHelper
@Override
You need to compare these values with 'null'.
You may want to use Arrays.asList() here
You need to compare these values with equals
Why does this return srcGlobalSnapshot.getMetadata(). It should be inside the if clause in a method
Why does this need to be higher than the above?
Why does this return srcGlobalSnapshot.getMetadata(). It should be inside the if clause.
if the disk doesn't exist you'll fail with NPE here, please first verify that it exists.
if the disk doesn't exist you'll fail with an exception. please first verify that it exists.
if the disk is plugged to the VM, please first verify that it's not a domain.
I'd put this in a try/finally block, to ensure the callback is closed even if an exception occurs.
I'd put this in a try/finally block, to ensure the tracing is released even if an exception occurs.
I'd put this in a finally block.
It's better to use JsonValue#toString()
It's better to use System.currentTimeMillis() instead of replace(...)
It's better to use System.currentTimeMillis() instead of replace(event.getJsonArray("events"));
You should use a Guava Closer to make this more readable.
You should use a ConcurrentPack[0] here
You should use a Guava Closer to make this more readable
You do not print in the exception message any context information, it is sign of bad usage.
You do not print in the exception message any context information, use the logger.
You do not print in the exception message any context information, it is sign of improper place to go
**entourage** block can be tricky to debug. Maybe we could include a case where the user has to be consentourageActivity or something similar to include the name to the user.
**entourage** block can be tricky to debug. Maybe we could include a case where the user has to know whether the user is a user or not, and have both email and phone.
**nit**: space between if and (
Why do we need to synchronize on the variable?
Why do we need this check?
Why are these changes required?
I'm not sure this is the right place to use getRefundsForPayment with it. I think this will double check as well.
I'm not sure this is the right place to use getRefundsForPayment with it. Then we can have multiple places where we call getRefundsForPayment with the private method, wdyt?
I'm not sure this is the right place to use getRefundsForPayment with it. Then we can have multiple places where we call getRefundsForPayment with the first X.
recommended, but in this case, i don't like this.
why is timeout-int0?
why is this private?
you can compare the size of GlusterVolumeSizeInfo and do the check inside the if clause
you can compare the size of GlusterVolumeSizeInfo and you do not need to compare the sizes.
primitive boolean
shouldn't we also check for the group name here?
shouldn't we also check for the group here?
I think we should also store the selected name as a variable
Would it be a good idea to keep those indentations as small as possible?
Would it be a good idea to keep these methods unchanged?
Would it be a good idea to put these three segments into a method and a separate method to reduce duplication?
Feels a little funky that this check is failing for me. If the latter sounds like it was to begin with, then it will have to go into the pipeline.
Feels a little funky that this check is failing for me. If the latter sounds like it was to begin with, then it will have to go into the code result in a clearer way.
Feels a little funky that this check is failing for me. If the latter sounds like it was to begin with, then it will have to go into the job.
This assertion would be better (and not be needed in the new FileSnapshot)
This assertion would be hard to read. The read is called like a FileSnapshot which is supposed to be used here.
This assertion would be hard to read. The read is called like a method which is already called above.
Unused method in the class.
Unused method in the code please.
Unused method in the code please
We have to improve readability here.
We have to improve readability here. I don't think this is necessary.
We have to improve readability here. I don't think this is necessary. In particular, what happens if replicas is empty, but the total number of replicas is not?
can contribution.edge() be null
can contributions be null
can contribution.getImage() be null
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to be used here.
nit: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to be used here.
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to avoid null checks.
/s/in/is
/s/in/is and not/
/s/in/is/
Call RxJavaHooks.onError so no exception is lost.
Call RxJavaHooks.onError so no event will be lost.
Call RxJavaHooks.onError so no finally block is lost.
Here reset should not be inside update(), otherwise since StampedLock is not reentrant, this could be deadlock
Here reset should be inside update() method, otherwise since StampedLock is not reentrant, this could be deadlock
public?
I think it's better to use extractChartViewer.getCheckedElements() in the base class.
I think it's better to use a local variable for the base class to store the CounterTreeViewerEntry
I think it's better to use a map view instead of a set here
won't this catch(Exception) catch a checkArgument() failure?
won't this catch(Exception) catch a checkArgument?
won't this catch(Exception) catch a checkArgument() failure?
Maybe extract this code to a method?
Maybe extract this to a field in the class?
Maybe extract this to a field in the class field of this class?
The method should be renamed to htmlNode.
The method should probably be the one that was created in the next line.
The method should probably be the one that takes a panelNode instead of the extension, so the user can get an NPE.
Is this part of the code still needed?
/proc/self/mounts/*://?
/proc/self/mounts/self/mounts/*://?
should it be a debug instead of info?
Should this be debug instead of info?
Can you make it a local variable?
final
static import table
static import
EntityType.getRegistry().getRegistry().
EntityType.getRegistry().getRegistry().getRegistry().
EntityType.getRegistry().
I would put this in a util method in PlanTree.java.
I would put this in a util method in PlanUtils.isDefaultPreferenceColumnTypeResolver
static import
Have we confirmed that permissionList.add(permissionList);
Have we confirmed that permissionList.contains(permissionList.class) does the same thing?
Have we confirmed that permissionList.contains(permissionList.class) is null?
the last two changes are unnecessary.
the last two instanceof checks are unnecessary.
The last two instanceof checks could be combined into one.
It would be better to call getActivity() here instead of getContext() as a parameter. This way we'd only need to call getActivity() once.
It would be better to call getActivity() here instead of getContext() as a parameter. This way we don't need to call getActivity() repeatedly instead.
It would be better to call getActivity() here instead of getContext() as a parameter. This way we don't need to call track() and any value.
This must be a builder without a null check.
This must be a builder. It is the id of the provider id.
This must be a builder. It is the id of the provider id in the provider.
why is this related to deploymentconfig now?
why is this related to deploymentconfig here?
why is this related to deploymentconfig?
you need to call force.force(true) twice here
you need to call force.force(true) twice
you need to call force.forceforce(true) twice
please use getProperty("java.version") instead of String.format.
please use System.getProperty("java.version", System.getProperty("os.name"), "java.version").toString()
please use String.format instead of +.format
I think you should leave this empty line, as it was already used in the class above.
I think you should leave this empty line, as it was already used in the class (i.e. the order of parameters)
I think you should leave this empty line, as it was already used in the class (i.e. the order of parameters).
this.
this. can be removed
public?
This should be a builder.
This is another one. Do we need to add it as session Id?
This should be generic to: <LINK_0>
no need for qualified name here
no need for qualified name
no need for qualified path here
This method has an external annotation now.
This method has an external annotation now. But it is not cached in the TmfCpuAspect.
This method has an external annotation now. But it is not cached in the TmfViewerViewer.getTraceType().
Please add also VOOBSERVER.
Please add also VOOBSERVER. They don't have any other members because it is not a member of this fragment.
Please add also VOOBSERVER. They don't have any other members because it is not a member of this class.
No need to use UriBuilder
don't need to use UriBuilder
don't use UriBuilder
Could we keep the implementation so developers can override how the notification is built if they want to add new features or modify settings? MixpanelPushNotification.isValid is false only
Could you keep the implementation so developers can override how the notification is built if they want to add new features or modify settings? MixpanelPushNotification.isValid is false only
Could you keep the implementation so developers can override how the notification is built if they want to add new features or modify settings (that's why makeNotificationIf... methods were protected if devs are overriding MixpanelFCMMessagingService)?
Not needed.
Not necessary.
Is this necessary?
Why not using.size()?
That's a nit, but could we make it more clear where to do empty conditional?
That's a nit, but could we make it more clear where to use conditional expression instead of using +?
Will this test pass after the year 2100?
Will this test pass before the year 2100?
Will this test pass without a date?
why are these changed to 128?
why are we explicitly adding cookie as keyPath?
why are we explicitly adding cookie as keyPath?
Can ignoreDTD is false? If ignoreDTD is false, then we should allow DTDs.
This could be handled in the if (ignoreDTD) statement. If ignoreDTD is false, then we should allow DTDs.
This could be handled in the if (ignoreDTD) statement. If ignoreDTD is false, then you should allow DTDs.
I'd use append instead of the keySet as you do in the other constructor.
I'd use append instead of the keySet as you do in the other constructor. This is not a big deal, but a bad practice because there are other places using the immutable list.
I'd use append instead of the keySet as the values for each dialect
I think it's okay to remove this 'final', and create a separate PR #2capSocket(
I think it's okay to remove this 'final' keyword. Up to you.
Shall we undo this?
should this be rethrowing?
should this be set in a finally block?
should this be set in onViewCreated() callback?
What about putting creation of the sequence here instead of looping over the sequence?
Where is the value being used?
Where is the sequence? Shouldn't we use a new instance of the object?
I'm not sure why we need this. I thought that VmDeviceUtils.getVmElement() is null.
I'm not sure why we need this. I doubt it is needed for the VM
I'm not sure why we need this..
Should this be in the doTextBox?
Should this be in the if (!visibleTextBox.isMetaKeyDown()) { textBox.setVisible(true); }?
Should this be inside the if block?
Looks like you didn't use the plugin to generate this test correctly. Can you use the plugin to generate this test correctly?
Looks like you didn't use the plugin to generate this test case before, but it looks like you got the registry and registry1 used here.
Looks like you didn't use the plugin to generate this test case before, but it looks like you got the registry and registry1233.
@ivandalbosco The reader is not closed
@pynicolas Can you explain this?
@ivandalbosco Is this the try catch needed?
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code drops it right through to the failure event handler. The previous code would translate it first.
Doesn't there need to be a translation call in the case the message is ERROR_MESSAGE? This code drops it right through to the failure event handler. The previous code would translate it first.
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code drops it right through to the event handler. The previous code would translate it first.
Why assugning this and not just using the VdcBllErrors.ImageDoesNotExistInDomainError
Why assugning this and not just using the VdcBllErrors?
Why assugning the log is not enough?
I think. value() returns a value in the range [0, 1), so you'd want to check <.125 instead.
I think. value() returns a value in the range [0, 1), so you'd want to check < 0 instead.
I think. value() returns a value of the value.
What is the default category? I'm a little bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
What is the default category? I'm a bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
What is the default category? I'm a little bit confusing the definition. But this component is used by "database" for task queuing so :-) of course we can change later.
Remove
Missing final
Missing @since
Slightly confused by this logic. We should either use Jackson (String) or use JacksonUtils.
Slightly confused by this logic. We should probably handle the case of length and use a List.
Slightly confused by this logic. We should probably define a type with a null keyValues array.
You don't need to wait for it here.
I believe you should verify that the results caret button is disabled here too.
You don't need to click on that.
See the new code in each test: if (private static boolean is equivalent) { return damagePerRound.getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(defender.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().
See the new code in each test: if (private static boolean is equivalent) { return damagePerRound.getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(defender.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().
See the new code in each test: if (private static boolean is equivalent) { return damagePerRound.getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(defender.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(base.getDefender().getDefender().getDefender().getDefender().getDefender().equals(defender.getDefender
You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.
You need a check for packs.length!= 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.
You need a check for packs.length == 0 here to just return early
Missing white space after the parenthesis.
Missing space between ) and!
Missing curly braces.
I think vm.get().version() >= success is more appropriate here.
I think vm.get().version() doesn't give any sense here.
I'm not sure we need this boolean.
I would rather use plain "false" here. It is sufficient.
I would rather use plain "true" here. It is sufficient.
I would rather use plain "equals" here. It is sufficient.
what if vms is empty? why would i care to deactivate the iso domain? after making the call to getVmById
what if vms is empty? why would i care to get some storage pool if it is empty?
what if vms is empty? why would i care to add it?
Merge these two if statements.
Merge these two if-elses into one for loop.
Merge these two ifs into one for loop please.
I think it would be better to use RestUtils.getRequestPath(frontendMetrics.getAccountsSecurityPostProcess()) here. This will remove the need for the new PR.
I guess this can be handled by the caller (test)
I guess this can be handled by the caller (test) where an exception is thrown in the constructor.
I don't think it matters in the future, just changing it!
I don't think it would make sense to use different things here
I don't think it matters in the future, just changing it to a name it should be the other way around, since it is the same on different scheme of things, not the same way.
Minor: Wouldn't it be better to move this to config?
Minor: Wouldn't it be better to move this for loop in the config?
Minor: Wouldn't it be better to move this for loop in the config instead of using MirrorTask?
final
this stream should be closed
this can be declared final
This should probably be "," so that the user can resize the table in that case (which seems to be fine, but we could use a constant for this as well).
This should probably be "," so that the user can resize the table in that case (which seems to be fine, but we could use a constant for the column name).
This should probably be "," so that the user can resize the table in that case (which seems to be fine, but we could use a constant for this.)
Inline this method.
Inline this loop.
Inline this variable.
This processing must be done in the middle of the transformer. Right?
This processing must be done in the middle of the transformer
This processing must be done in the middle of the method.
change to getHeader(span)
change to getHeaders().getTraceId().
Should this be public? (I'm surprised to see all over the place)
Typo, should be "ClusterEventProcessor"?
I think using this approach will be less fragile.
Format
![Codacy](<LINK_0> Issue found: [A method/constructor should not explicitly throw java.lang.Exception](<LINK_1>
leftover debug statement
leftover debug statement please
We can create a temporary Parquet file where the column is declared as type. In the future we would need to create a column name for partition-level column.
We can create a string variable for this.
We can create a variable for column name columns to avoid the same name.
nit: I think it'd be better to use an anonymous class (or a constant) to create the ID only from Object and then pass it to create the object.
nit: I think it'd be better to use an anonymous class (or a constant) to create both the anonymous classes.
nit: I think it'd be better to use an anonymous class (or a constant) to create the ID only from Object.
Optional: use Boolean.TRUE.toString()
you should use Boolean.TRUE.toString() instead of Boolean.TRUE.toString()
Optional: use Boolean.TRUE.toString() instead of Boolean.TRUE.toString()
can we make this a constant and have it calculated once. Also, will help in having a name.
can we make this a constant and have it calculated once. Also, will help in having a name. Also, we really need to mock all the instances of time.
can we make this a constant and have it calculated once.
Why are we only allowed to handle metrics by metric name?
Why are we only allowed to iterate over the metricsRegistry, but not the metrics registry?
Why are we only allowed to iterate over the metrics registry?
NullException (nit) suggestion Preconditions.checkNotNull(row.getAndCacheRowNumbers(), rowNumbers.size());
NullException?
NullException (missing )
Should we have a check for null on input or input?
Should we extract to a common method?
Log a warning "...
addListeners (see other PR)
addListeners (see other PRs)
addListeners
Would prefer if Date was initialized using ts's getValue and getScale converted to ms
Would prefer if Date was initialized using ts's getValue and getScale converted in guava
Would prefer if Date was initialized using getValue and getScale converted to ms
Please use File.log instead of using File.log().
Please use File.log instead of System.out
Please use File.log instead of using File.log()
not.build()
this can be replaced with.ifPresent(this::build)
this can be replaced with.build()
I don't think this is needed if getLogger() is expensive.
I don't think this is needed if getLogger() is null.
I don't think this is needed if getLogger() is nullable.
Please add import to avoid fully-qualified class references.
Please use reverted code according to our code style.
Please use reverted code according to this patch.
The following seems more readable: rootBaseDir.get(i).equals(rootBaseDir.get(i)); childPath.toAbsolutePath().normalize().forEach((path, path) -> Paths.get(i));
The following seems more readable: rootBaseDir.get(i).equals(rootBaseDir.get(i))
The following seems more readable: rootBaseDir.get(i).toString().filter(e ->!healthy.startsWith(i)).forEach(rootBaseDir::toString);
you can use Assert.assertEquals(executor, participant.getStateMachine()) instead.
you can use Assert.assertEquals(executor, participant.getStateMachine()) here.
you can use TestUtils.getTestParticipant() instead of this. That would help avoid the test failure.
a random number can be potentially large, better to use an ArrayList
a random number is a bit long, can we use an ArrayList here instead of sort?
sort these names
Not a big deal, but could you replace "private" with "private" visibility by a name?
Not a big deal, but could you replace "private" with "private"
Please revert this explicit call
Could be replaced by SpongeImpl.getMultiWorldCommandPatches().
Could be replaced by: SpongeImpl.getGlobalConfig().getCommands().get(name)
Could be simplified: java SpongeImpl.getGlobalConfig().getCommands().get(name)
Add "column name"
Add some message when you change the code
Add "column mapper"
Setting the status to COMPLETE if it is could save an update
Setting the status to COMPLETE if it is could save an update.
Setting the status to COMPLETE if it isn't exists would make sense
I suggest to use the following code : List<User> membersIDs = groupAddRequest.getUsers().stream().filter(groupAddRequest -> group.getName() == null).collect(Collectors.toList());
I suggest to put this in a separate iteration. If the user is not loaded please delete.
I suggest to put this in the debug log.
Does this have side-effects? Otherwise could be a performance benefit to moving it inside of the if condition below.
Does this have side-effects? Otherwise could be a performance benefit from moving it inside of the if condition below.
Does this have side-effects? Otherwise could be a performance benefit to moving it inside the if condition below.
Would it be better to use getBoolean here instead?
Would it be better to use EmbeddedAdapter here? I know it's not used for anything, but it's more Expressions since it's only used by the app.
Would it be better to use getBoolean() instead of getInstance() here?
this will cause the pool to be updated for the same metrics tenant. isn't it?
isn't it better to use the Metrics interface?
it seems that the name should be updated for the pool
What is the purpose of having separate methods?
What is the use case for having separate methods?
What is the use case for having separate methods here (just for clarity)
why?
why not?
why not use?
The method is not being used here. isPreferred going to be sufficient for other methods like this.
The method is not being used here. isPreferred?
The method is not being used here. isPreferred going to be sufficient for other methods?
this should be set in the doPopulate() not in deprecatedPopulate()
shouldn't we also check if the vm is set in the parameters?
shouldn't we also check if the vm is set before trying to find the VM?
is this defined in the mapper?
is this defined in the scope of this issue?
this is unused
This should be a log statement.
This should be a synchronized method.
This should be a WARN or lower.
suggestion dataMap.put(toData(e.getKey(), DataData.V4_1))
Shouldn't this be toData(e.getKey())?
suggestion dataMap.put(toData(e.getKey(), DataMap.V4_1))
It might be worth adding a log statement here, to make sure we know it was successfully processed.
It might be worth adding a log statement here, to make it explicitly.
It might be worth adding a log statement here, to make it clear this is only called once.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the configurationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the adhoc from different packages is often not a good idea. It might be cleaner if obtaining the actual response is treated alike in different endpoints.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the configurationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might not be cleaner if obtaining the actual response is treated alike in different endpoints.
Will this swallow the exception?
Will this handle when the remote volume is up?
Will this cause a node exception?
suggestion.setThrown(() -> callback.onSuccess(commitTransaction.toMillis(timeout)).commit();
suggestion.setThrown(() -> callback.close());
suggestion.setThrown(() -> callback.onSuccess(commitTransaction(e)).set(timeout);
Do we need a case for ids.isEmpty()?
Do we need double checking for null for credentials here?
Do we need double checking for null, task Name?
static import SortOrder.ASC
parameter.getLimit() is just a weird way to understand
parameter.getLimit() is already long
This is fine as a Set.
This is fine as a Set here.
This is fine as a Set here :)
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
Hmm, didn't think of this earlier, but it might make sense to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
Hmm, didn't think of this earlier. I think that it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
This variable is redundant.
This variable is never used.
This check is redundant.
This var need to be named as a final static member.
This var is not needed, right? since it is used only once
This var is not needed
if (a.getFullName()!= null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); }else if(a.getPreferredEmail()!= null && emailMatches.size() < maxMatches.size())) { emailMatches.add(a); }
if (a.getFullName()!= null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); }else if(a.getPreferredEmail()!= null && emailMatches.size() < maxMatches.size()) { emailMatches.add(a); }
if (a.getFullName()!= null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); }else if(a.getPreferredEmail().toLowerCase().contains(str)) { emailMatches.add(a); }
No need for log here. The next method already logs a warning.
I don't think we need a boolean flag here. Leave it unset
No need for log here. The next orElseThrow method already returns an AssertionError
expiringObject == null -> expiringObject
expiringObject can be moved to the following if/else statement: completableFuture.computeIfAbsent(key, completableFuture);
expiringObject can be moved to the following if/else block :)
I'd change to "SetDao."
I'd change to "Set<OvfDisk>"
please use warn
Please use the new message here as well
Please use the new message here as well.
Please use StorageConstants.EXPORT_NETWORK_CONCURRENT.
Is there a reason you don't use the constructor with no arguments? Since you are trying to create a new one.
Is there a reason you don't use the constructor with no arguments? Since you are trying to create a new empty f2 table and keep the constructor synchronized
Is there a reason you don't use the constructor with no arguments? Since you are trying to create a new empty f2f you only have one.
disposables is null if (disposables!= null && disposables.clear()) { disposables.clear(); }
disposables is null if (disposables!= null &&!disposables.isDisposed()) { disposables.clear(); }
disposables is null if (disposables!= null) { disposables.clear(); }
I would prefer this as a constant string.
I would prefer this as a constant such as Provider<IMergeContext>.
I would prefer this as a constant such as IndexDiffConstants.DEFAULT_GIT_BASE
shouldn't it check the getCluster().getCpuName()!= null?
shouldn't it check the getCluster().getCpuName() too?
shouldn't it check the getCluster().getCluster().getCpuName() too?
The if condition can be simplified to if ( associationType == Query.COLLECTION ) { filter = joinableHelper.isNotEmpty( filter )? StringUtils.isNotBlank( filter ) : ""; } else if (StringUtils.isNotEmpty( filter ) { filter.getEnabledFilters(); }
The if condition can be simplified to if ( associationType == Query.COLLECTION ) { filter = joinableHelper.isNotEmpty( filter )? StringUtils : ) { filter.getEnabledFilters(); }
The if condition can be simplified to if ( associationType == Query.COLLECTION ) { filter = joinableHelper.isNotEmpty( filter )? filter : null; }
This is sufficient use of corsHeaders.get(mapping): List<String[]> getHeaders(CORS_PREFIX) { final List<String[]> headerMap = new ArrayList<>(); headerMap.put(CORS_PREFIX, correlationId); return headerMap.put(mapping, corsHeaders); }
This is sufficient use of corsHeaders.get(mapping): List<String[]> getHeaders(CORS_PREFIX) { final List<String[]> headerMap = new ArrayList<>(); headerMap.put(CORS_PREFIX, correlationId); return headerMap.computeIfAbsent(mapping, corsHeaders); }
This is sufficient use of corsHeaders.get(mapping): List<String[]> getHeaders(CORS_PREFIX)
The else is not necessary.
The else is not necessary. We have the same issue as the previous code.
The else is not necessary. We have the same issue as the previous check.
This isn't the right place to do this. You could have this logic in the parse method (maybe have it static method), then we could put it there and call it from the elsewhere.
This isn't the right place to do this. You could have this logic in the parse method (maybe have it static method), then we could put it there.
This isn't the right place to do this. You could have this logic in the parse method (maybe have it static method), then we could put it there and call it from the constructor.
You could use a private static final variable for _no-op_ arg here.
You could use a private static final variable for _no-op_ arg to avoid creating a new variable for for clarity.
You could use a private static final variable for _no-laxed constants, so I think this could be changed in the future
Use isEmpty() rather than getGroupBy()
Use isEmpty() rather than.length() - that's obviously more readable.
Use isEmpty() rather than.length() > 0
This is not necessary here, we can assert that the file is not deleted.
When changing to DecisionNode, this test will fail.
When changing to DecisionNode, I think we should check that.
Let's make sure we're using String concatenation with + to make the code more readable.
Let's make sure we're using String concatenation
Let's make sure we're using String concatenation or param with +
Need to use getString() for those as well
Need to use getString() for these
Need to use getString() since it is used for other methods
same here, need "else": ConsoleDeviceEnabled should be set according to template
same here: need "else": ConsoleDeviceEnabled should be set according to template
same here, need "else": ConsoleDeviceEnabled should not be set according to template
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final SupervisorActor.ActorRegistration actorRegistration = startResponse.orElseThrow(cause -> new AssertionError("Expected the start to succeed.", cause));
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final SupervisorActor.ActorRegistration actorRegistration = startResponse.orElseThrow(cause -> new AssertionError("Expected the start to succeed.", cause);
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final SupervisorActor.ActorRegistration actorRegistration = startResponse.orElseThrow(cause -> new AssertionError("Expected the start to succeed.");
I think this is a bit too long, can we refactor it to use a common utility?
I think this will break existing clients.
I think this is a bit too long, can we refactor it to use a utility method?
I think just passing file is enough instead of file.getPath()
I think just passing file is enough instead of file.getFileNum()
I think just passing file.getPath() is enough, since it will be used in the finally block
How does the retry handler distinguish "failure in initialization + failure in handling all items" from "success in initialization + failure in handling all items"?
How does the retry handler distinguish "failure in initialization + failure in handling all items"?
How does the retry handler distinguish "failure in initialization + failure in handling all items" from "success in handling all items"?
.getTrace() may return null at this point. We should probably add a null check
.getTrace() may return null
.getDiagnosticService() maybe?
Could you use buildAndStartWithDirectExec() here?
Please use assertThat.
Please use assertThat().
Should be indented one time in the code.
Can't we use isEmpty() here?
Should be indented and return.
redis() should be accessed as static method.
This line can lead to a DNS lookup (blocking call). Would createUnresolved work as well?
There's a duplicate method here.
Is there a reason to do this here rather than in the PreparedStatement statement?
Is there a reason to do this here rather than in the if statement?
Is there a reason why this is needed?
Extra empty line
Unclear if I like the empty sizeInBytes...
isEmpty?
@Happy-Neko Same here, use it
@Happy-Neko Same here, seems like it should be handled by the constructor and return
@Happy-Neko Same here, seems like it can return the result directly
Use try-with-resources
Use try-with-resource
Use try-with-resource instead
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration? Can you take a look at the Jekins configuration?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration? Can you explain the change?
The translation should be done only if getToken() is invoked by getToken() is invoked by Request.getObserve()
The translation should be done only if getToken() is invoked by getToken() is invoked by getToken()
The translation should be done only if getToken() is invoked by getToken() is invoked by getRaw().getToken() before calling get()
Please don't use brackets around single line blocks (see L120)
Please don't use brackets around single line blocks (see 10 spaces in the file)
Please don't use brackets around single line blocks (see 10 spaces in the diffs)
wrap
Should we wrap this
Should wrap this
It would be nice to add these back. I'm not familiar with eria to add these headers by default.
It would be nice to add these back. I'm not familiar with piggybacked.
It would be nice to add these back. I'll send you.
this should be a warn
this should be a debug/trace
this should be a debug message
Would it be better to make the method non-static and have something like this?
Would be good to have a e.g. "LDAP search" method
Would be good to have a e.g. "LDAP search" method which has a non-null attrName there
remove this line. It is not needed.
Missing {}
remove this line
Can you remove "throws Exception" here?
Can you remove all the need for this?
Can you remove "throws Exception" here.
Why are we interrupting the current thread if it's running?
Why are we interrupting the current thread if it's running? That seems like a strange behavior.
Why are we interrupting the current thread if it was running?
Replace with synchronized
I think this lifecycle is not needed
I think this lifecycle is not necessary
nit: remove ArgChecker.isTrue from here
nit: check the variable name for the sign before the qualifier
nit: check the variable name for the sign before the return statement
Unnecessary new line.
Unnecessary blank line.
Unnecessary parentheses?
@jomarko I would suggest renaming it to something like CUSTOM_GENESIS_GENESIS instead of CUSTOM
Maybe it is better to cache the result and print it instead of throwing an exception?
@jomarko I would suggest renaming it to originalName, and then keeping it a string.
You can do this via java awsConf.setSocketBufferSizeHints(conf, DEFAULT_MAXIMUM_UPLOAD_TIMEOUT_MILLIS)
You can do this via java awsConf.setSocketBufferSizeHints(conf, DEFAULT_MAXIMUM_UPLOAD_TIMEOUT_S);
You can do this via java awsConf.setSocketBufferSizeHints(conf, DEFAULT_MAXIMUM_UPLOAD_TIMEOUT_MILLIS) {
Why don't you use that?
Why don't you use the same delta?
Why unnecessary change?
If you look at the implementation of ReplKeyTracker, it does not need to be synchronized. Also, maybe we should only need to synchronize on keyOnlyTracker as well.
If you look at the implementation of ReplKeyTracker, it does not need to be synchronized. Also, maybe we should only need to synchronize on keysPerSegment.getSegment(key) and check for null
If you look at the implementation of ReplKeyTracker, it does not need to be synchronized. Also, maybe we should only need to synchronize on keyOnlyTracker when we have callbacks.
Can be a static string?
Can be a static final
Can be a constant?
Isn't it better to represent reference directly in the isMappedExample instead of reference.getIdentifier()?
Isn't it better to represent reference directly in the isMappedExample instead of reference?
Isn't it better to represent reference directly in the ProbeType enum?
This can be static
This can be static, right?
Can't we use StringUtils.isBlank?
Maybe we could put some lines in the if block above like: java final Button event = KeyboardEvent.focus();
Maybe we could put some lines in the if block above like: java final Button event = (event instanceof KeyboardEvent)? ((String) event).get pk(keyEvent);
Maybe we could use a function like KeyboardEvent or something similar?
Minor: space before {
Let's put html variables in constants
space after (
channel.close().sync();
channel.close();
channel.close() looks redundant
nit: you can remove the switch now.
nit: you can remove the switch here as it is just a static import.
nit: you can remove the switch here as it is just a static initializer.
Do you mean JSON.optJSONObject(String) here?
Do you know why you can do the conversion at this point? What about changing the values to string?
Do you know why you can do the conversion at this point? What about json/string?
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventThread.join(EVENT_THREAD_JOIN_TIMEOUT);
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventThread.isAlive()
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventThread.isAlive() or something like that.
Perhaps a note? We don't want to check the status code.
Perhaps a note is that a utility method is used?
Perhaps a note is that the status is changed to http://localhost/api?
for consistency, would it make sense to use a local variable here?
for the order, it would be more clear if this was done as a HashSet
for the order, it would be more clear if this was done as a HashSet.
I think it is better to use StringBuilder
I think it is now better to use StringBuilder
I think it is better to use format
"Type information is missing" or sth like that
"Type information is missing" or "Type information is missing"
"Type information is missing" or sth like that.
I don't think it's necessary to put this block inside the builder. You have a new method: TradeWrapper tradeMsg = new TradeWrapper(serializer, tradeMsg); threadMsg.addClassHeader(trade instanceof TradeWrapper);
I don't think it's necessary to put this block inside the builder, right? Why can't we just use the builder directly?
I don't think it's necessary to put this block inside the builder, right? Why can't we just use the builder?
I'm not sure this is right - shouldn't this set to true?
shouldn't this set to true?
I'm not sure this was correct. It should be [better](<LINK_0>
primitive (int) would be sufficient
primitive (int) will be sufficient
primitive (int) would be sufficient.
could be import static, it doesn't matter too much
could be extracted to a field, it doesn't have to be used twice
could be rewritten with a call to track the type system property.
formatting
braces
It looks like these changes
No need to use a local variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis / x = new HeaderAxis( x - sdArea); return x;
No need to use a local variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis / x = new HeaderAxis( x x, sdArea); return x;
No need to use a local variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis / x = new HeaderAxis( x - sdArea); return x; }
You can use a newly added test method instead.
You can use a newly added test case for this.
Why not use a dummy string?
this could be encapsulated on a method called findFirstStepByStructure.
this could be encapsulated on a method called findFirstStepByData
this could be encapsulated on one line
Can we put a private method something like this? Otherwise it will be called twice.
Can we put a condition on this? Otherwise it will be injected on every request
Can we put a private method something like this? Otherwise it will be called twice we have a private method
Curious: it might be safer to check!hasFree? WrappedBytes.getValue() : false and return the same value if it is not null.
Curious: it might be safer to check!hasFree?
Curious: it might be safer to check!hasFree? WrappedBytes.getValue() : false and return the same value if it's null.
NACK. this undoes #1272
Just change this to security.getCertificates()?
Just change the access to security.
Here, I see that config.getBooleanProperty() is null.
Here, I think you can directly use config.getBooleanProperty() which is null.
Here, I think you can directly use config.getBooleanProperty() instead of config.get().
Ideally we are as specific as possible with exceptions based on what developers might see.
Ideally I would prefer as specific as possible with exceptions based on what developers might see.
Ideally I would see what developers might see.
Why this extra query?
Why do we need to create SQL object here?
Why do we need to create SQL node here?
suggestion userLayer.createUserLayer(e.getMessage(), "Failed to encode the feature as GeoJSON Exception");
suggestion userLayer.createUserLayer(e.getMessage(), "Failed to encode the feature as GeoJSON.");
suggestion userLayer.createUserLayer(e.getMessage(), userLayer.getfcMsg());
This works, but we have static factory methods for specific use cases. GatewayError.baseError(msg)?
This works, but we have static factory methods for specific use cases. GatewayClientException::baseError = GatewayClientException.from(BaseAuthorisation); private static void visitGatewayError(BaseAuthorisation exception) { try { return GatewayClientException.class.getResource(message); } catch(BaseAuthorisationException e) { logger.error("Error loading Stripe", e); } catch (Throwable e) { logger.error("Error loading Stripe, e); } } private static void handleGatewayError(BaseAuthorisation exception) { String errorId = e.getCause(); final String errorId = e.getCause(); final Stripe e = e.getCause(); final String responseId = e.getCause(); final String responseId = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response =
This works, but we have static factory methods for specific use cases. GatewayClientException::baseError = GatewayClientException.from(BaseAuthorisation); private static void visitGatewayError(BaseAuthorisation exception) { try { return GatewayClientException.class.getResource(message); } catch(BaseAuthorisationException e) { logger.error("Error loading Stripe", e); } catch (Throwable e) { logger.error("Error loading Stripe, e); } } private static void handleGatewayError(BaseAuthorisation exception) { String errorId = e.getCause(); final String errorId = e.getCause(); final Stripe e = e.getCause(); final String responseId = e.getCause(); final String errorId = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response = e.getCause(); final String response =
I don't think this exception handling is required. The test fails if the deployment is not there and you can ignore the correct error message.
I don't think this is the correct exception handling. Shall we have a test case that re-throw the correct exception and fail the test?
I don't think this exception handling is required. The test fails if the deployment is not there and you can ignore it.
@NielsCharlier I'm not sure about this one. Does this even work with fiss? Is there any better way to do this?
@NielsCharlier I'm not sure about this one. Does this even work with fiss? Is this a valid file or files, or just the empty file?
@NielsCharlier I'm not sure about this one. Does this even work with fiss? Is this a valid file or files, or just the empty filename?
Isn't this the same problem as the other array default?
Isn't this the same problem as the other enum?
Isn't this the same problem as before? CastType is not tested?
put else in a new line
put else in { }
put else in new line
style nit: missing braces
Nitpick: I believe you shouldn't need this line.
shouldn't this be a.toString()?
Shouldn't this be capital T?
Shouldn't this be capitalisation? I think it should be renamed to export
Shouldn't this be inside the if?
@fanifieiev the same above.
@pecko let's use Collections.singletonList() here instead of Arrays.asList()
@inverno This can be an FlatDifftic
overflow = ((xl  yl) & (xl  zl)) < 0;
overflow = ((xl > yl) & (xl  zl)) < 0;
overflow = ((xl  yl)) & (xl  zl)) < 0;
I think this could just be: if (buffer.get(i) < length)
I think this could just be: if (buffer.get(i) < 0 || received.length)
I think this could just be "if (trace)"
Looks like there are leftover printlns in addition to the assertions?
Looks like there are leftover printlns in addition to the blocks?
Looks like there are leftover / reuse the code?
This could be replaced with Files.readAllLines(PublicKeyEntry).
This could be replaced with Files.readAllLines(PublicKeyEntry). I think that might be better.
This could be replaced with Guava's Stream API.
The "if" statement contains a blank line.
The "if" statement contains a single "else" statement.
The "if" statement used here for completeness.
I think it would be good to add the path to the log.warn line before deleting the file?
I think it would be good to add the path to the log.warn line before deleting.
I think it would be good to add the file listing as a static variable.
could we simplify the logic as: if (childType == null) { return new MessageType(ctx.getParquetType(), ImmutableList.of()); } typeBuilder.add(childType); parentType = childType;
could we simplify the logic as: if (childType == null) { return new MessageType(subfield, baseType); } typeBuilder.add(childType); parentType = childType;
could we simplify the logic as: if (childType == null) { return new MessageType(subfield, baseType); } typeBuilder.add(childType); parentType = childType; } return new MessageType(subfield, baseType);
@vilchik-elena Please use full path building.
@vilchik-elena Please explain why we need to use concatenation here.
@vilchik-elena Please use the size of the list.
Should we be checking if this is!= 0?
Should we be checking if this is a single store?
Should we be checking if this is a single stores?
you can inline item
please inline item
consider replacing memo
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved system memory. I suppose we will always need to set aside a part of our memory size.
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved system memory. I suppose we will always need to set aside a part of our heap FACTOR and I like the problem.
I don't think we need to set reserved pool here. Removing reserved pool does not necessitate removing reserved system memory.
This is out of scope of this PR but I'm wondering if it would be useful to move this inside a finally block.
This is out of scope of this PR but I'm wondering if it would be useful to separate out these and close the cveDB, given that it already been closed?
This is out of scope of this PR but I'm wondering if it would be useful to move this inside the block?
I think this should be ChannelSftp
Sort of believe we should consider this method as well.
Sort of believe this should be FU or LRU
check for non null?
check for non null? and call super.add on dispose?
check for non null? and call super?
I think you need to get the top of the file in case there is an existing data.
I think you need to get the top of the file in general.
I think you need to get the top of this for loop.
We want this to be 1000 or so, some thing completely beyond the output we should get - we basically want to keep all output so we can check what we are fine.
We want this to be 1000 or so, some thing completely beyond the output we are saving 3 times.
We want to check which version is the same as the one above.
filterResults is not used
filterResults is not used anywhere
It is not clear which condition do not contain yet,
ClassLoadingContext should be declared as protected in the class.
ClassLoadingContext should only be accessed if at least one extension is available.
ClassLoadingContext or enricher, should we use extensionLoadingContext?
If this is the case it's not clear what the original test is doing. I think it's more readable to do: assertEquals(test.subList(0, expected.size), filterDepth - 1, filterDepth - 1, filterDepth - 1, filterDepth + 1);
If this is the case it's not clear what the original test is doing. I think it's more readable to do: assertEquals(test.subList(0, expected.size), filterDepth - 1, filterDepth - 1, filterDepth + 1);
If this is the case it's not clear what the original test is doing. I think it's more readable to do: assertEquals(test.testAll(subListDepth - 1, filterDepth - 1, filterDepth - 1, filterDepth - 1);
Can this response be read and verified?
Can this response be read?
Can this response be read? Or is this response not populated?
+1 for using dataSchema.length as the delimiter delimiter can be "-compression"
+1 for cases where the dataSchema is created and the list is empty (i.e. use +)
+1 for using dataSchema.length as the delimiter delimiter can be a bit out of the loop
Not needed
nit: Not needed
static import?
I would tend to only add the last element in the map.
I would tend to use.equals() as it is safer to keep the previous order.
I would tend to only add the last element in the map, then the loop would execute the next loop.
use fieldType rather than fieldSchema in the message.
use fieldType rather than fieldSchema in the exception message.
use fieldType rather than fieldSchema in all fields.
Should "This is likely to be NTPROC_JUNK_ID"?
Should "This is likely to be "was caused by a node"?
Should "This is likely to be "was caused by a node failure or intentional"?
This also doesn't look like a good idea to have an enum to check for it.
This also doesn't check for null.
This also doesn't look like a good idea.
I think I'd want to print the amount logged at the end instead of the first time.getDayOfMonth() = true; for (PlayerChecker.getDayOfMonth() : end.length(); f.setStrictConvention(start + end, end);
I think I'd want to print the amount logged at the end instead of the first time.getDayOfMonth() = true; for (int i = start + end; i < end.getDayOfMonth; i++) easier (substring = start + end + end););
I think I'd want to print the amount logged at the end instead of the first time.getDayOfMonth() = true; for (PlayerChecker.getDayOfMonth() : start + end);); wdyt?
Since we want to update the entire widget, I think we can use a single [ event](<LINK_0> element here.
Since we want to update the entire widget, I think we can use a single [ui](<LINK_0> to update the content of the ui model.
Since we want to update the entire widget, I think we can use a single [ui](<LINK_0> to update the content of the entire widget. This is a little bit complicated.
optional: this only asserts that the branch exists but is not.
optional: this only asserts that the branch exists in the commitSha1 method. It already checks if the tag exists in the parent branch and throw an exception if not.
optional: this only asserts that the branch exists in the commitSha1 method. It already checks if the tag is there or not.
This could be done outside of the for loop since you are not using it multiple times.
This could be done outside of the for loop since you are creating the cache right?
This could be done in a separate commit which introduces improvements.
_are_ possible?
_are_ avisitCode attachment?
::equals
Looks like we can set a waiterId here (this.setAndUpdateState(waiterId, false)?
Looks like we can set and final boolean so that we don't need to set and unboxed again.
Looks like we can set and final.
let's use try-with-resources
let's use AssertJ for assertions
let's use try with resources?
Return an empty list (Collections.emptyList()).
Return an empty string (Collections.emptyList()).
Return a String (Collections.emptyList()).
Why no else here?
Why else if this returns false?
Why else if this has no context?
Why didn't you use a mock here?
Why didn't you use putInt?
Why didn't you use getSceneOfManger here?
This needs to be wrapped in a try... catch block to ensure the close() is called multiple times.
This needs to be wrapped in a try...catch block to ensure the close() is called multiple times.
This needs to be wrapped in a try... catch block to ensure the close() is called multiple times
Do you think it's worthwhile to check!headers.isEmpty() as well? Same for container.headers().add(RestUtils.Headers.TARGET_CONTAINER_NAME)
Do you think it's worthwhile to check!headers.isEmpty() as well? Same for container's check.
Do you think it's worthwhile to check!headers.isEmpty() as well? Same for container.headers().add(RestUtils.Headers.TARGET_CONTAINER_NAME, targetAccountName))
Shouldn't we return the EndpointRegistryInfo and not the registry id?
Shouldn't any Registry object be returned here?
Shouldn't we return the EndpointRegistry object when it is provided?
This should be at least logged at trace level, to avoid logging.
This should be at least logged at debug level.
This should be before the if.
I think that this loop would likely be better if it used split()
I think that this loop would likely be better if you used split()
I think that this loop would likely be easier if it used split()
It looks like we don't need to lock the email field again here. Also, shouldn't this condition be here?
This doesn't have to be here. Set the email in a class member, you can use the user directly. Also, you don't need to do this twice.
It looks like we don't need to lock the email field again here. Also, shouldn't this condition be "emailFieldValidator.email_email_length"?
This should be moved to QuorumPeerConfig.java
This will be there even no need to have this sleep.
This will be there even no need to have this sleep?
nit: move this to a private function, something like: int mbraId = mAid.getValueLength();
nit: move this to a private function, something like: int mbraId = -1; this.database(index)
nit: move this to a private function, and call it here as well.
The author of this line should be executed 4 times.
The problem with trying to create a String and not very obligatory.
The problem with trying to create a String and not use the sitemap URLs.
You can remove the following if-else block
You can remove the extra parenthesis
You can remove the following if-else block here
Why do we need to avoid doing this? What can we just return null?
Why do we need to avoid doing this? What about if we just return null?
Why do we need to Ignore? What then?
I would suggest to add getLogicalTimestampTimeUnit here.
I would add getLogicalTimestampTimeUnit here.
I would suggest getLogicalTimestampTimeUnit here.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the selected OS.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the selected OS. Ideally, fill this values using the selected OS.
- no need to explicitely add the null here if it is not found
IIRC jdt.ls.
IIRC jdt.ls.lib.io.File.
I guess final.
More magic numbers; use variables for longitude/latitude?
More magic numbers; use constants for longitude/latitude?
More magic numbers; replace with variables/assigning
Leftover debug statement?
We don't need this if statement.
We don't need this if block.
can't we check that it is the same as the block below?
can't we check that the big fields are empty?
can't we check that it is the same as the block above?
This toolingPod should be moved into the xml
This toolingPod should be moved into the xml class.
This toolingPod should be moved up into the build toolingPod.
Rather than hard-coding the string in the class, I think it's better to have a static final String variable that can be checked by the class.
Rather than hard-coding the string, I think it's better to have a static final String variable that can be checked by the class.
Rather than hard-coding the string in the class, I think it's better to have a static final String variable that is checked by this class.
Don't log and throw the same exception
Do not log and throw the same exception
Don't log and throw the same exceptions
This should be 'if (color!= null)'.
This should be 'if (color!= null || color.startsWith("#define-color"))'.
This should be > 0.
we need to include typed values here, then we could rename t to t
we need to include typed values here, otherwise we will break all of these tests.
we need to include typed tags...
This line is long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
This line is long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort().toString(), layoutHandle.getTupleDomain());
This line is long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort());
Maybe you should include the null-value too.
Maybe you should include the null-check on the Properties class?
Maybe you should include the null-check on the config value here.
We should make this a constant for the default content-length strings
Let's use a constant for this
We should make this a constant for the default being null.
I believe you can also iterate over keyCount and check the returned value.
I believe you can also iterate over the values here, with the repeated values.
I believe you can also iterate over the values here, using the same keyCount
I think the try catch here is no longer needed.
I think the exception caught here is either Unimportant or not an exception.
I think the try catch here is probably not needed.
nit: you can remove the redundant brackets
I think you can remove the redundant brackets
nit: remove the redundant brackets
Code style
Code style in new code is longer and readable
Code style in new lines
i am wondering why this change. The contract of decorateHtmlElementList is not part of this method.
i am wondering why this change. The contract of decorateHtmlElementList is not part of this class as it needs to be so in the abstract method.
i am wondering why this change. The contract of decorateHtmlElementList is not part of this method. The implementation of decorateHtmlElementList(field) changed to return decorateHtmlElementList(field, field); that was so the rule this change would have to be part of equals.
Shouldn't null here just be interpreted as an empty array?
Shouldn't a null here just be interpreted as an empty array?
Shouldn't null here be interpreted as an empty array?
The City class is defined in another package used by other tests. I would recommend using a class defined within the test itself. It is easier to maintain the code.
The City class is defined in another package used by other tests. I would recommend using a class defined in City could potentially break the test.
The City class is defined in another package used by other tests. Any changes in City could potentially break the test. I would recommend using a class defined within the test itself.
I think simplify and use it in the same place, benefit of moving this logic out of the if/else, so it's clearer in the if/else block
I don't think there is a need to swap the order of the checks. It might be cleaner to move this logic into it's own method, then use it in the same if block
I think simplify and use it in the same place, benefit of moving this logic out of the if/else block
You should use.isEmpty() to check for empty string.
Just use.isEmpty()
Just use "return..." to make the test more readable.
This method is synchronized, but do we need to wrap these three lines?
Why don't you wrap the [tokenToToken](<LINK_0>
This method is synchronized, but do we need to keep a lock on the token
Can you use a lambda here?
Can we use a lambda here?
Can't we use a lambda here?
I'm not sure how useful this is, but is it?
We should probably use Objects.equals for this
We should probably use Objects.equals for this, too.
I'd suggest not assuming an object will be returned since we might switch implementations
I'd suggest not assuming an ArrayList will be returned since we might switch implementations
I'd suggest not assuming an directly will be returned since we might switch implementations
Please use the following if branch: java if (path == null) { return null; } foundField = getField(path.indexOf('/'));
Please use the following if branch: java if (path == null) { return null; } foundField = getField(path);
Please use path.contains("") instead of path.indexOf().
It seems that kWorker would be null in some cases, could we check it here too?
It seems that if the kWorker is null the task won't have been set, so the error message could be misleading.
It seems that it'd be useful to record that kWorker was null in onWorker.getId() and it would result in NPE.
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this code is a lot easier to follow.
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this code is a bit easier to follow.
hey guys, here it is what I should do by doing content.getTarget().orElseThrow(e -> new ArrayList<>()
This is not 'per node' It is the count of all CPUs defined in all NUMA nodes.
This is not 'per node' It is the count of all CPUs defined in all NUMA nodes?
The count of all CPUs defined in all NUMA nodes are NUMA nodes.
Is it possible to use Jenkins.getInstance() here?
Looks like it is necessary to save the value in Jenkins for a global variable.
Looks like it is necessary to save the value in context.getResourceAsStream().
As mentioned in <LINK_0>, it is a Safer to get the wrong id of the persistence step, but I assume we want to still return the same list when passing the SingularityTaskId list to the DB. Can we get the SingularityTaskIds from the SingularityRequest to avoid a number of repetition?
As mentioned in <LINK_0>, it is a Safer to get the wrong id of the persistence step, but I assume we want to still return the same list when passing the SingularityTaskId list to the DB. Can we get the SingularityTaskIds from the SingularityRequest to avoid a number of events?
As mentioned in <LINK_0>, it is a Safer to get the wrong id of the persistence step, but I assume we want to still return the same list when passing the SingularityTaskId list to the DB. Can we get the SingularityTaskIds from the tailSet instead?
I'd extract this string to a constant.
I'd extract this line inside a method to reduce duplication
I'd extract this line inside a method to reduce duplication.
Error message could be logged to spam.
Error message could be logged to severe
Error message could be logged to spammy logs.
This won't make the code more readable.
This won't make the code more readable. Let's say that we're doing this only for cluster-config-clusters?
Let's continue to the same logic as the one above.
Use the existing JSON API. You will have to do this manually.
Use the existing door for creating a new storage pool.
Use the existing id please.
You have changed the default value here to something else that you could have added. What do you think?
You have changed the default value here to something else that you added. What you are changing is a new instance here to have it.
You have changed the default value here to something else that you could have added. What you are changing is a new instance here to have it.
consider extracting to a method
consider using List.of()
getSucceeded(true)
Can we do this?
Can we do this instead?
Can we do this::maximumSize
Cache the getMode()
Formatting again.
Formatting
I don't think this is needed. @ODORA0 Can you please explain why this was removed?
I don't think this is needed. @ODORA0 Can you please explain why this was changed.
I don't think this is needed. @ODORA0 Can you please explain why this was needed?
Shouldn't it be template.getServletContext()?
Shouldn't this be done at the beginning of the method?
Shouldn't it be better to use the utility method for this?
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces here
If you need to squash the BufferedInputStream and have a new BufferedInputStream(HttpResponseStatus.INTERNAL_SERVER_ERROR). It will accomplish the same thing...
I would have used default charset here.
I would have used default charset here since this will break existing behavior.
Please use a method called 'name' rather than 'csv.
Please use a method called 'org.springframework.web.example.CaseCaptor' that does the same thing.
Please use a method called 'org.springframework.web.util.Json' or 'java.lang.String' instead.
Why is this condition different from the IO methods?
Why do we have to reset this flag when the readOptions method is never called?
Why do we have to reset this flag when the readOptions method is called?
We should make savedConnection a constant and reuse it here.
Is this the same as the one above?
Is this the same with the rest of the stuff?
How do you get the number of files twice?
How do you get the number of files before calling checkPointWriter1?
Make this into a test.
I would do instead of a for-each loop, you can do everything in the for-loop. But if you prefer to keep it more concise, you can do instead of calling.keySet() on a List it will avoid some memory leak...
I would do instead of a loop, you can use.isEmpty()
I would do instead of a for-each loop, you can do more than just the iteration
This should be WFLY-4294 says this op will fail in runtime on a server.
WFLY-4294 says this op will fail in runtime on a server. But it looks like WFLY-4294 says this op will fail.
This should be WFLY 9+ only.
Please add final for exception, and rename it to ex
Please add final for cause, e
Isn't isPreferredNetworkInterface(item) an empty list?
Should be "column name column is not found"
Need to call getName() with a non-null string
Should be "column name"
This is a bit strange: size is interpreted as a negative number (or zero). So I would use isEmpty() here.
This is a bit strange: size is interpreted as a negative number (or zero). So I would use isEmpty instead.
This is a bit strange: size is interpreted as a negative number (or zero). So I would use isEmpty().
Need to revert this line.
Need to use a self loop
custom copy constructor must be applied to the values.
Maybe we can consider logging the exception here, instead of tracking the failure state? WDYT?
Maybe we can consider logging the exception here, instead of trackable to give more context?
Maybe we can consider logging the exception here, instead of trackable to give users the ability to track media?
I could generally go with the sleep earlier, but we should get rid of the sleep.
I could generally go with the sleep earlier, but we should get rid of the sleep. Could we not just go with the increment below?
I could generally go with the sleep earlier, but we should get rid of the sleep. It's a little more clear as e.g. let's just go with that.
Should this be outside of the try block?
Should this be done in finally block?
Should the thread be interrupted so that threads can see the lock in the finally block?
redundant statements.
NPE, since they do not NPE, maybe Objects.equals() is enough
NPE, since members can be null
Does this file need to be a static variable? Can we make it a static variable and use it here?
Does this file need to be a global variable? Can you make the checkPointFolder more specific?
Does this file need to be a global variable? Can we make it final?
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called?
Add a check here to ensure that the serialDataReceived method was not called.
Why do we need this?
Why have you added this code block? Just return the js Header.getInstances(newAPIException("offset"), null)
Why have you added this code block? Just return the js Header.getInstances(newAPIException("offset"), null))
This line can be replaced with:.put( sum.get(index));
This line can be replaced with: ListBox.clear( sum);
This line can be replaced with: ListBox.clear()
Just use it's better to keep it, because it's an arbitrary bit not to show it when not, the client sends an incorrect hand ID.
Just use it's better to keep it, because it's an arbitrary bit not to show it when not, the api is better.
Just use it's better to keep it, because it's an arbitrary bit not to have it?
We already know that it is empty. Maybe!next.set( new MutableObject<>( next )?
We already know that it is empty. Maybe!next.set( new MutableObject<>( next ) )?
We already know that it is empty. Maybe!next.set( true )?
Missed it at previous review. Question - why via getTaskIdList()? and not via VmStaticDao()?
Missed it at previous review. Question - why via getTaskIdList()? and not via BackendCollection()?
not needed and use 'equals'
can you please extract to a method and call it twice in the file?
can you please extract to a method and call it twice in the same file?
can you please extract to a method?
I would prefer "None" here.
I would prefer "None" here..
I would use "None" here.
why put this query out of the for loop?
use a for loop here? I think we can just put the values here.
use a for-each loop here?
Why not using principal instanceof X500Principal?
Why not using principal instanceof X500Principal?
Why it is not a new one?
Do we need a synchronized block to prevent multiple threads from making the same transaction? Can we bound a state where we don't do it at multiple places?
Do we need a synchronized block to prevent multiple threads from being created? Can we use synchronized?
Do we need a synchronized block to ensure that only one threads are operating on the same object? Can we write a unit test?
String url = this.get("url");
String url = display.get("url");
String url = this.get("url");?
This code is repeated several times, please extract it to a private method
This code is repeated several times, please extract it to a private method.
This code is repeated several times, please move it to a private method
Thread.currentThread().interrupt();?
Thread.currentThread().interrupt(); is better.
Thread.currentThread().interrupt();
Does this really need to be public?
Revert this change.
Revert this change?
s/src/main/java/org/json/ManageDomains/
Can be simplified to: java ManageDomains expected = System.exit(1);
s/src/main/java/org/json/ManageDomainsResultEnum/
It would be good to factor out this logic into a method.
It would be a good idea to catch NPE here.
It would be good to factor out this logic into a separate method.
I'm not familiar enough with this. I have to check if this is a directory or not, but I run into a NPE (which is not a good idea). So, please make sure to check if a directory is valid (which is not a directory).
I'm not familiar enough with this. I have to check if this is a directory or not, but I run into a NPE (which is not a good idea). So, please make sure to check if a directory is present (which is not a directory).
I'm not familiar enough with this. I have to check if this is a directory or not, but I run into a NPE (which is not a good idea). So, please make sure to check if a directory is valid.
Is this going to be called for every single client?
Is this going to be called from multiple threads?
Is this really needed?
Should task.getStateDefinition().getName() be defined as a variable?
Should we do it in every iteration?
Should do the same thing here and below
Why public? I don't see any news usage in this method.
Why public?
Why this change?
Consider using the?: syntax to replace the idiom with tabs?
Consider replacing these for loops with the same loop.
Consider replacing these for loops with the middle
java itemGroup = ((AbstractFolder) itemGroup).getParent();
not sure if the itemGroup is an instanceof Item?
not sure if the Item?
The method name is deprecated, so this could be removed.
The method name doesn't seem to change anything.
The change listener shouldn't have to be setup. Also, the listener should return the interface.
nit: can we check for null before calling.trim(), here and if it is empty we return null (empty)
nit: can we check for null before calling this method since it will throw NPE.
nit: can we check for null before calling.trim(), here and if it is empty, just return null
you can introduce new interface that you can ask if the run should use fork or not. default would be true, also if the new interface is not supported by context (as before)
you can introduce new interface that you can ask if the run should use fork or not. default would be false, also if the new interface is not supported by context (as before)
you can introduce new interface that you can ask if the run should use fork or not. default would be true, also if the new interface is not supported by context (as before).
we should add the openTree or clear the tree
we should add the openTree or clear the multiTreeAPI.
we should add the openTree or clear the multiTree map
This code relies on BracketIndex#equals(String, int) which looks like a bug. Is it possible to use the index of the entire tree (i.e. lastIndexOf(-1)?
This code relies on BracketIndex#equals(String, int) which looks like a bug. Is it possible to use the index of the current index (i.e. a + b + a) index instead of a + b + a + b + a process?
This code relies on BracketIndex#equals(String, int) which looks like a bug. Is it possible to use the index of the converted index, and a check if the index is of type 'a' and a substring() of it?
remove "es" and use [Optional](<LINK_0>
remove "es" and throw IllegalArgumentException
remove "es" and throw IllegalArgumentException for better readability.
Would this be a different value of fireOnlyUpdatedPanes be a different value? If this was the case, shouldn't this be part of the PR?
Would this be a different value of fireOnlyUpdatedPanes be a different value? If this was the case, shouldn't this be part of the operation in the "get" check above?
Would this be a different value of fireOnlyUpdatedPanes be a different value? A different property could be passed to the OutputFormat for the submitted scenarios. It would be a bug in this case, and a bug in the pipeline's docs.
There is already a [NetworkReferenceImpl](<LINK_0>; ad it to the base test class predicates and use it here instead.
There is already a [NetworkReferenceImpl](<LINK_0>; a [NetworkReferenceBase](<LINK_1>
There is already a [NetworkReferenceImpl](<LINK_0>; a [NetworkReferenceBase](<LINK_1>.
Not your fault, but this assertion seems to be unnecessary if you remove.
Its better to remove this and have a logger if needed.
Remove sysouts.
Why is it required to be a list within properties class?
Why is it required to get the whole stack trace from applicationContext?
Why is it required to get the whole stack trace from applicationContext.properties?
Try grabbing textExtendedSubheaderDataLength from null in context. This could also be defined as a field, and is there a reason to use it?
Try grabbing textExtendedSubheaderDataLength from null in initializeFixedLengthString() when it is not present. Needs a test for it.
Try grabbing textExtendedSubheaderDataLength from null in context. This could also be defined as a field, and this setter (textExtendedSubheaderData) should be returned.
I don't think there is any reason to put new LocaleSettingHandler(String)?
I don't think there is any reason to put new LocaleSettingHandler(locale); in new LocaleSettingHandler(null)?
I don't think there is any reason to put new LocaleSettingHandler(locale); in new LocaleSettingHandler(null??
See if you can rewrite this as if (change.getAddedSize() ) {...
See if you can rewrite this as if (change.getAddedSize() ) {
See if you can combine these two if blocks into 1
Should be java if (replyTo == null) { replyTo = handler.getMethod(); } else { replyTo = new replyTo(method); } (and if (replyTo!= null) { checkTo ann => }
Should be java if (replyTo == null) { replyTo = handler.getMethod(); } else { replyTo = null; }
Should be java if (replyTo == null) { replyTo = handler.getMethod(); } else { replyTo = new replyTo(method); } (and if (replyTo == null) { checkTo ann => }
Ah, OK, that would be clearer.
Ah, OK, that would be better.
Ah, OK, I was just checking this on my IDE
This should be done in the different patch, not here.
This should be done in the constructor, not here.
This should be done in the different patch, not here
This doesn't look right, should be Entity.toString() instead of.contains?
This doesn't look right, should be Entity.toString() instead of Entity.toString()?
This doesn't look like a Entity.
this part is the same as in restoreDatabase, could you refactor it into a separate method?
this part is the same as in restoreEnvironment, could you refactor it into a separate method?
this part is the same as in restoreSchema, could you refactor it into a separate method?
Still wrong index... It really must be dependent on the TmfEventTableColumn, we cannot assume that it is either in creation or visible order.
The index is the column creation order, but the 'columns' parameter can be in any order.
This will resolve visible columns even if they were not requested by the method...
Remove the first null check here
Remove the first null check here and simply call the instance variable in line 78
Remove the first null check here and simply call the instance variable in the if
I can't see anyone looking for the message. You have some gateway account to provide a different type than the key.
I can't see anyone looking for the message. You have some gateway account for it.
I can't see anyone looking for the message. You have some service but not implemented this.
This name is not very specific to the upgrade.vcf to help to help with debugging.
This method name is not right. str is no longer used in the name
This name is not very specific to the upgrade.vcf to help to clean up a lot of the differences.
cause exception is not logged?
cause exception is not caught?
not necessary?
Don't need this.
Don't need this line
Don't we need a new line?
debug/trace/remove?
log the ErrataModel name is already defined.
log the ErrataModel name is already used.
what's the purpose of this test? The original test should fail the test
do you need to undo the.map()?
what's the purpose of this test?
@tmjee before awaitTermination you should call shutdown Then assert that awaitTermination returned true Than then shutdownNow
@tmjee It's better to create all Callable instances ant then submit them via ExecutorService#invokeAll()
@tmjee before awaitTermination you should call shutdown Then assert that awaitTermination returned false Than then shutdownNow
suggestion "Required fields: " + reqVal.bind(" --json;
suggestion "Required fields: " + reqVal.bind(" --parent-accession", "");
suggestion "Required fields: " + reqVal.bind()
Better create a constant errMsg and use string literal here like in the other places.
Better create a constant errMsg and use string literal here like in the other places where it's used
Better create a constant errMsg and use string literal here like in the other places where minor is assigned
IMO, it'd be better to check if classType.getHaxeClass() is called first.
IMO, it's better to check if classType.getHaxeClass() is called first.
suggestion return classType.getHaxeClass();
tableHandles is null
requireNonNull
validator lookup
@jinified you can also put a call to PickerTextField.getIssueLabels(). And I don't think you have to use it.
@jinified you can also put a call to PickerTextField.getIssueLabels().
@jinified you can also put a call to PickerTextField.getIssueLabels();
Now that the mock is important, I think this should be null.
Now that the mock is important, I think this should be just null.
Now that the mock is important, I think this should be just getClass().getName()
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the resource is being set to null, it is not required.
resource will be null here. You need to "import" the trace to the workspace and provide a workspace relative path.
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the resource is "org.eclipse.papyrus.uml.diagram.ui.tools.api.util.Resource".
I don't think you need this check. You shouldn't have any "this" column, unless it's null, and for a row, the table and column names.
I don't think you need this check. You shouldn't have any "this" column, unless it's null, and for a row, the table and column names of that column.
I don't think you need this check. You shouldn't have any "this" column, unless it's a special row.
Seems to me that this would be an "else if" as one of both cases.
Seems to me that this would be an "else if" as well.
Seems to me that this would be an "else if" as one of the other places.
if you're refactoring this block, would you mind reverting this to a separate PR?
if you're refactoring this block, would you mind reverting this block of code to a separate function?
if (log.isTraceEnabled())
@nvazquez you shouldn't make this function protected just to avoid people from accidentally using it.
@nvazquez you shouldn't make this function protected just to avoid people from accidentally using it, can you just remove it?
@nvazquez you shouldn't make this function protected just to minimize it?
suggestion response.print("s", bundleName); Although response is already logged in process(List<String>)
suggestion response.print("error", bundleName); Although response is already logged in process(List<String>)
suggestion response.print("s", bundleName);
Unnecessary blank line.
PatchSet parentIds cannot be null. You need to say it cannot be null.
Unnecessary newline.
We should assert that the result is not null.
We should assert that the keys are getting returned, not just that we expect it to fail.
We should assert that the keys are not equal, assuming we have a consumer type.
This loop may be unnecessary since we do not want to have a HashSet here.
This loop may be unnecessary since we know the users has been logged in.
This loop may be unnecessary.
Throwing a RuntimeException might be a better approach. It might be something like the following to be a little more informative: java throw e; } catch (InterruptedException | ExecutionException e) { throw new IllegalStateException(e); }
Throwing a RuntimeException might be a better approach here.
Throwing a RuntimeException might be a better approach.
add an overload which takes a file with the actual file type.
add an overload that takes a file with the target file type.
use SnapshotDescriptor here
Throw a new exception here.
Throw a RuntimeException here.
This is not needed here. Add it to the cause.
nit: Add "A" here and in the next line
nit: Add " master" here and in the next line
nit: Add " master" here and in the finally block
Same question as above
Same issue with the change in the PR description.
Similar to the one below, we should update the resource config after refresh.
The indentation here is the same as alert.
The indentation here is the wrong abstraction.
Better with unit tests.
What happens if the date was not set?
What happens if the condition is null?
What happens if the date is null?
it looks like a constant
it would be better to wrap this in a constant
it seems like a constant
Is this correct? What if someone is given a "StoredWorkflowDefinition" and is empty?
Is this correct? What if someone is given a "StoredWorkflowDefinition" and will have no information?
Is this correct? What if someone is given a "StoredWorkflowDefinition" and will have no state definition?
CosiamLdapUserDetailsImpl is completely unrelated to this change. Please use ((userDetailsService) attribute).userExists); instead.
CosiamLdapUserDetailsImpl is completely unrelated to this change. Please use ((userDetailsService) attribute).userExists)) instead of proxy.
CosiamLdapUserDetailsImpl is completely unrelated to this change. Please use ((userDetailsService) attribute).userExists)) instead of proxy comparison
I think this should be warn
this should be.path(path)
this should be.path(path)?
nit: we can use TimeUnit.SECONDS.sleep(100).
nit: we can use the TimeUnit.SECONDS.sleep(100).
nit: we can use TimeUnit.SECONDS.sleep(Duration.of(...))
Cosmetic: This looks good, but the bindingResult variable should be declared as a class variable/variable
Cosmetic: This looks good, but the bindingResult variable should be declared as a class variable/method
Cosmetic: This looks good, but the bindingResult check should be executed only if the storageId exists.
1) Please make it a 'final' field, and use it here, instead of creating a new instance. 2) Instead of creating new VmTemplate(), you could just pass the actual value from the backend request
1) Please make it a 'final' field, and use it here, instead of creating a new instance. 2) Instead of creating new VmTemplate(), you could just pass the actual value as is to the backend request
1) Please make it a 'final' field, and use it here, instead of creating a new instance. 2) Instead of creating new VmTemplate(), you could just pass the actual value as is to the call above.
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This is dangerous because alerts bigger than 1MB will break the emitter
This should have the data source name, like dataRuleThrottler.start.
This condition is repeated in the constructor. We should check firstPartitioning!= null here, and return firstPartitioning!= null.
This condition is repeated in the constructor. We should check firstPartitioning!= null here, and return or condition.
This check also needs to be simplified. We can have only a check for firstPartitioning!= null, and in case firstPartitioning is empty, we never set to null.
The Exception is never thrown.
The Exception is never thrown. I think the test is missing.
The Exception is never thrown. Can be removed.
1 =
1 => 1
1 = 2 =
You also have to replace anyMatch with allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
You also have to replace allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
You also have to replace allMatch with anyMatch, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
Why are we comparing this with false?
I think we can use this.value = GraphData.class.cast(GraphData) here
Returning null will break the parsing.
Nice :+1:
Nice collectLongs!
Nice collect :)
Now one can only static import state methods for either TransformationState/ProcessState, but that isn't a big issue
Now one can only static import state methods for either TransformationV2 or TransformationState. This is a big issue
Now one can only static import state codes
The first half of this method is very similar to some of listPhrasesForPage(), could you refactor por favor?
The last half of this method is very similar to some of listPhrasesForPage(), could you refactor por favor?
The first half of this method is very similar to some of listPhrasesForPage(), can you refactor por favor?
Can you also use assertPipe here?
Can you also set the encoding?
Can you also use assertSame here?
Why this needs to be done? Waiting for some time, can we wait for it to complete before?
Why this needs to be done? Waiting for some reason is to take the time.
Why this needs to be moved?
Do you need this? The constructor already assumes that it is called on the argument and when it is called?
Do you need this? The constructor already assumes that it is called on the argument?
Do we need this?
we should log this exception
this block is repeated in <LINK_0>
we need to catch this block
I don't think this check is needed anymore as there is a call to the Resource.getWorkspace().getRoot()
I have this text could be inside if (pomComponent instanceof IResource)
I don't think this check is needed anymore as there is a call to validateInput
I am not familiar with the test - why do we need to call the function again?
I am not familiar with the test - why do we need to call the function???
I am not familiar with the test - why do we need to cast the DistributContext to a Response?
We don't usually use local variables where possible.
style: } else {
We don't usually use local variables where possible. You can inline these
Lets go to the if (.split(..)){ populate } for (int i = 0; i < ((Integer) br.length; i++) {.split( } }
Ctrl + D
Lets go to the if (.split(.split( ), ) {...} form
use channelIsAlreadyLoaded instead, this would be handled by channelIsAlreadyLoaded()
use the same style as above (which is declared in the while loop)
use channelIsAlreadyLoaded instead, this would be handled by channelIsAlreadyLoaded.
line > 120 chars
line > > 120 chars
line > 120 characters
The sleep is too big. Typically, it takes time, time, time, and time.
The sleep is too big. Typically, it would take more time, that the  axis is explicitly set to true.
The sleep is too big. Typically, it would take more time, that the D sleep is after all the seconds.
Add a new method to the timeoutReachedMessage to do the same thing...
Add a new method to the timeoutReachedMessage to make it easier to read.
Add a new method to util.failures.
<LINK_0>
Add description as an additional message
Add description as a message
miss a fail() after this line
have a block here?
miss a fail() after the catch, here and elsewhere
Nit: budgetObject.getInt("amount") is redundant, since you're just doing it right?
Nit: budgetObject.getLimit() returns the value of the supposed budget.
Nit: budgetObject.getLimit() returns a string.
It should be more clear to put the port name into the properties file.
It should be more clear to me for if it is a bug.
It should be more clear to put the port name into the properties file as well.
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run.getId());
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run);
This seems like it should be changed back to original code
It's better to throw more specific exceptions than doing one of them, rather than relying on them to throw the right exception.
How about doing this instead? java TypeNotFoundException { Other exceptions are thrown, avoiding possible exceptions for e.getCause() etc.
It's better to throw more specific exceptions than doing one of them, rather than relying on them to throw the names of the exception.
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName()); }
We don't want to invoke setVds(), because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName()); }
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName(), then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName()); }
We can change this to private to match the existing constructor, which takes a default value.
We can change this to private to match the existing constructor, which does this in a different patch.
We can change this to null as well to default value.
if you use CollectionUtils.isNotEmpty() for expression here
if you use CollectionUtils.isNotEmpty() for expression which is a little better
if you use CollectionUtils.isNotEmpty()
need to use StringUtils.hasText(); hasAttribute allows an empty String.
need to use "clean-on-flush" here to ensure the value is either "flush-size" or "flush-size".
need to use "clean-on-flush" here to ensure the value is always in the same value (just like the others).
I would add a log here, stating that the key was not found in the map.
I would add a log here, stating that the key was not found
I would add a log here, stating the attempt was done when the key was set.
We should go to these two DBs to perform authorization, just like we do in SnomedRelationshipIndexEntry
We should go to these two DBs to perform authorization, just like we do in SnomedRelationshipIndexEntry.
We should go to the index, though.
.stream().map(this::getSlaveInfo).filter(state -> slaveInfo.size() == null || slaveInfo.size().stream().map(MesosSlaveInfo::getSlaveInfo).collect(Collectors.toList());
:ant: I'd use StringUtils.isEmpty() rather than.stream().map(this::getSlaveInfo).filter(slave -> StringUtils.isEmpty(item.getSlaveInfo())).collect(Collectors.toList());
:ant: I'd rather use StringUtils.isEmpty( slaveInfo::getSlaveInfo)
travis runs in dev.
travis runs of dev.
travis is failing here.
The new AffineTransform(graphics2d.getTransform()); is better.
The new AffineTransform(graphics2me); is missing.
The new AffineTransform(graphics2me); is missing. Please check.
wrap this in an else clause
Replace this with an external call
wrap this in an else block?
Can use feedback response ID?
Can use feedback response ID here?
Can have feedback response ID?
Please add the indent to highlight the blocks and avoid the mess in the code.
Please add the blocks and avoid the mess in the code.
Please check the blocks and avoid the mess in the code.
I'd like to set a flag to false here, and set it to true.
I'd like to prevent calling this method to "void GTK" rather than checking if the state is GTK3.22.
I'd like to prevent calling this method to "void GTK".
I'd use.forEach
the disk is not attached to the db so it's unneeded.
the disk is not attached to the db so why do we need it?
I would go with this.
I would go with this as a separate method.
I would go with stream iteration :)
Won't this cause the exception to be thrown if the exchange fails?
Won't this cause the test to fail if the exchange fails?
Should it be expected = exchange.getOut();?
"uppercase".equals(textTransform) && textToInsert!= null
"uppercase".equals(textTransform) && textToInsert == null
"uppercase".equals(textTransform)
Usually we don't do this.
Usually we use a single string reference mentioned above?
Usually we don't add this.
Nit: Not sure if there is like a good way to go. Just.map and let it be one-liner.
Minor: Use helpers for m -> m.memberId() since you have a few other places.
.map(res -> m.memberId())..
I think if you leave it as-is, it will keep it more readable with java Map<String, String> allVerbs = new HashMap<>();
I think if you leave it as-is, it will keep it more readable with java Map<String, Object> allVerbs = new HashMap<>();
I think if you leave it as-is, it will keep it more readable with java Map<String, String> allVerbs = new HashSet<>();
nit: no need for the getString() here.
nit: no need to set the click handler here.
nit: no need to set the click
We should use baseUrl variable instead of this in the constructor.
We should use the constants from the RequestHandler instead of this field.
We should use the constants from the RequestHandler instead of this class.
@codepoet2017390 You have already initialized this variable, why do we need it?
@codepoet2017390 You have already initialized this variable, why not use the new APIs?
@codepoet2017390 You have already initialized it before the nanoTime() call.
What if the snapshot is not a snapshot?
What if the snapshot was not started?
What if the snapshot was not started? Can you throw exception?
fullName can be null for an "Anonymous Coward". So this will NPE. We need to invert the order of the equals.
fullName can be null for an "Anonymous Coward". So this will NPE. We need to invert the order of the 'else'.
fullName can be null for an "Anonymous Coward". So this will NPE. We need to invert the order of the equals-check.
This should be reverted, then we can remove this code.
This should be reverted, then we can remove this code and the placeholder
This should be reverted, then we can remove this code and the placeholder?
I think you should add a null check here to avoid the current if statement.
I think you should add a null check here because : Optional<String> s = call.getCause(); if (fStyle == null) { return; }
I think you should add a null check here to avoid the current if.
Component type for variable device might be DOMAIN_TARIFF_SWITCHING?
Component type for the inactive device exception :(
Component type for the inactive device exception should be UnknownEntityException.
do you need to log here and below?
minor: Instances here is not required, right?
INFO level
This cast seems unnecessary.
This cast seems a bit dangerous to me. Can we do something like the following? java Aggregator lock = child.get(tb); if (child.eos()!= null) { return; } final TupleBatch tb = child.getIndices(); if (fields.length == 1) { return null; } child.addTuple(sb, row, row, offset);
This cast seems a bit dangerous to me. Can we do something like the following? java Aggregator lock = child.get(tb); if (child.eos()!= null) { return; } final TupleBatch tb = child.getIndices(); if (fields.length == 1) { return null; } final TupleBatch tb = child.next(); if (row!= null) { return child.getIndices(); } return null;
Iterator could return multiple items erroneously and pass.
Iterator<Object> iterator = Iterator.next(Iterator.iterator(), store.getPayload(), Iterator<Object>);?
Iterator<Object> iterator = storeIterator.iterator(); and remove // no iterator...
we can use a different constant for "determinism" and "determinism" if we have a problem
we can use a different constant for "determinism" and "determinism" if we have a different order
we can use a different constant for "determinism" and "determinism".
you can use the shorter path for this and avoid the need for casting.
you can use the shorter path for this and avoid the need for casting as well
you can use the shorter path here and below.
since this is true, you should use java.util.Objects.equals
since!=null is redundant here.
since!=null is redundant here
It might be worth including the fact that you did a random number.
It might be worth including the fact that you did a.next() here instead of a new String.
It might be worth including the fact that you did a.next() here instead of the new reference.
This method can be simplified to: java bloomFilterIndex = props.getMaxBloomFilterBytes(); if (path.length!= 1 || bloomFilter.size() == 1 || bloomFilterInt.contains(column)) { optimalFilterWriter = new bloomFilterWriter(maxBloomFilterSize, bloomFilter); } return new BlockSplitBloomFilter(optimalNumOfBits, value);
This method can be simplified to: java bloomFilterIndex = props.getMaxBloomFilterBytes(); if (optimalIndex == 1) { // throw exception } return; }
This method can be simplified to: java bloomFilterIndex = props.getMaxBloomFilterBytes(); if (optimalIndex == 1) { // throw exception } return;
Why don't you not simply use contains() here?
Using getClass() is clearer. I don't think we should change this class
Using getClass() is clearer. I don't think we should change this class in this class
doesn't this need to be done in GerritUtil.configure()?
doesn't this need to be done in GerritUtil.run()?
remoteConfig
wouldn't this be info?
these are magic strings.
wouldn't this be DEBUG instead?
This function is getting rather long, can it be refactored into some smaller functions?
This defines what we are migrating from, and we are migrating from, so I'll leave it as NORMALIATION in this case
This defines what we are migrating from, and we are migrating from boxc3 data
We need a test that ensures that the command is completed.
We need a test that ensures that the command has no disk.
We need a test that confirms that the command that was loaded in the background.
I don't think the need for this variable.
I don't think the catch block is necessary. Can you refactor that into a separate method?
I don't think the catch block is necessary. Can you refactor that?
Isn't this line already happening in the previous test?
Isn't this line already happening in the Utils?
template variable is unused
Do we also need to verify that the callback is called?
I would recommend replacing this assertion with adding a method called _doAnswer()_.
Do we also need to verify that the callback is called? I don't think this test is actually needed anymore.
this is the right place to put the password and key as part of the command. Would suggest to lower-case this as well?
this is the right place to put the password and key as part of the command. Would suggest to lower case the first letter.
this kind of logging should be done inside the command.
Can we do this instead? I'm not sure what the test was doing now, but would it work if the queryStreams() was removed?
Can we do this instead? I'm not sure what the test was doing now, but would it work if the queryStreams method were inserted into the second query stream?
Doesn't we need to test this with the first non-stream task?
newFuture is never null, so it's not necessary to check for null.
newFuture is never null, so it's not null.
newFuture is never null.
because writer.put() can fail, you should enclose it in a try/finally like: try { //... } finally { writer.close() }
because writer.put() can fail, you should enclose it in a try/finally like: try { // do } finally { writer.close() }
because writer.put() can fail, you should enclose it in a finally block.
Why change it to assertThat(orderNotification.getOrderCode(), is(2));
is it better to keep style with the new line
formatting
We could omit this line. We also need to add the specification of this section.
We could omit this line. We also need to add the specification of ExportManager.
We could add a line break after #18n.
Please fix spacing.
Please fix the ResponseMessage here.
Please fix the indentation.
Can you make this package-private and remove the public modifier?
Can you make this package-private and remove the public modifier? It would also be an important modifier.
You should be able to just call this Entities.createEntities.
It seems like this is changing the behaviour in the first place, and now it's safe to change the transaction in a case of error.
It seems like this is repeated several times, and it might have worth extracting it to a method
It seems wrong, and it shouldn't have a null check.
Why add mutating methods? Just put this in the constructor.
Why add mutating methods? Just put this in the method.
'this' is never used.
Do we ever expect this to happen?
Do we ever expect this is a RuntimeException?
Do we really need this?
we can use R.drawable.***_MIT_FLAG_ACTIVITY_NEW_TASK
we can use R.drawable.***_MIT_WAIT_DURATION
we can use R.color.xml
Perhaps also be a good idea to change BeanDefinitionBuilder. a value (in case BeanDefinitionBuilders are not the same as the identifier).
Perhaps also need to set the value on the invocation of the builder.
Perhaps also be a good idea to change BeanDefinitionBuilder. a simple BeanDefinitionBuilder... I think it is a super confusing.
The same here than for PreviewImageFragment.
Use findItem with the particular ID of the root. See findItem(item). No need to do both.
Use findItem with the particular ID of the root.
In the discussed with @rkavanap we should find a way to store them in a String instead of a byte[].
Please log the missing space between  and {
In the discussed with @rkavanap we should find a way to store them in a String instead of dSpaceObject
(pointer.getCorrelationID()!= null) -> Cause.getCorrelationID(correlationID);
(pointer.getCorrelationID()!= null) -> isEmpty()?
(pointer.getCorrelationID()!= null)? Won't that cause a NPE when it is not called by the CorrelationID?
If the component's _visible_ attribute is removed, the Properties component will be created in the main package and it will have been removed from the system. I think this will need to be changed, but perhaps it's better for this change to just skip the "else" condition.
If the component's _visible_ attribute is removed, the Properties component will be created in the main package and it will have been removed from the system. I think this will need to be changed, but perhaps it's better for performance to only run the "input" config when creating the children.
If the component's _visible_ attribute is removed, the Properties component will be created in the main loop. This needs to be changed to only run once.
Sleep might make this test flaky. Would it be ok to do future.get() here instead?
Sleep might make this test flaky. Would it be ok to do this? Tests don't have any idea.
Sleep might make this test flaky. Would it be ok to do this without a test? Also, I think this is testing that the test will not fail.
Could we add a log message as well?
Can we add a log message as well?
Could we add a break; after this loop?
You can use.map(...) instead of.collect()
You will need to run this on the fly.
You can use.map(...) instead of.map(...).
Looks like column.getDataSetDef(); is duplicated here
Looks like column.getDataSetContext() is not null here
Looks like column.getDataSetDef(); is duplicated here.
Set the storage type to Collections.singletonList()
this could be a bit shorter with a method reference
this could be a bit shorter, i.e. "<NFS>"
I'm not sure it's good idea to throw exceptions. How about throwing IllegalArgumentException?
What do you mean by default?
What do you think about it?
This value should be a constant (the same as the one in the link constructor). At least the same time it's used for the field/method; if it's not set, we can fetch the value and set it to null.
This value should be a constant. For instance, use [this](<LINK_0>
This value should be a constant (the same as the one in the link constructor). At least the same time it's used for the field/method; if it were changed, then we can change the message slightly to something like "Could not retrieve the JMS link"...
Users can use this pattern to name it. Change them to something like "OpenWals".
Name "OpenWals"
Users can use this method instead of iterating over allWalState.
This can be a List.
this can be a List<VDS>, as it is used only in editAction.
This can be a List<VDS>.
static import
These two lines could be combined into one.
These two lines are in the wrong order.
In this case, it's better to use.equals on server than == Subject.ANONYMOUS.equals(subject.getUserId()) WDYT?
In this case, it's better to use.equals on server than == Subject.ANONYMOUS.equals(subject.getUserId())
In this case, it's better to use.equals on server than == Subject.ANONYMOUS.equals(subject.getUserId()) here so that one of the other is really similar.
It would be good to have log.debug("swagger-Forwarded-For: {}" and "swagger": "swagger", "swagger": "urls", "swagger": "2.0", "value=" + swaggerPort + swaggerPort + swaggerPort + swaggerPort);
It would be good to have log.debug("swagger-Forwarded-For: {}" and "swagger": "swagger", "swagger": "urls", "swagger": "2.0", "value=" + swaggerPort + swaggerPort + swaggerPort);
It would be good to have log.debug("swagger-Forwarded-For: {}" and "swagger": "swagger", "swagger": "urls", "swagger": "2.0", "value=" + swaggerPort + swaggerPort + swaggerPort + swaggerPort + swaggerPort);
This looks like a functional change, not a logging change?
You only want to use the logging for these exceptions, not the stack trace
You only want to use the catch block for these exceptions, not just IO exceptions.
Create a constructor without the last field?
Create a constructor without the first field?
Create a constructor without a field?
What is the point of 'next()' if there is only one element? Is it possible to combine two cases?
What is the intention of 'next'?
What is the point of 'next()' if there is only one element? Is it possible to simplify the code?
You can reuse the configs from TestHelper.getTestMethodName() and TestHelper.getTestMethodName()
You can reuse the configs from TestHelper.getTestMethodName() and TestHelper.getTestMethodName().
You can reuse LK_ADDR attribute so we don't need this property at all.
same here for the test
unrelated change
same here for the else
I am not sure at this point, the Org should be executed at the end. I think you should throw Exception at the end of the method.
I am not sure at this point, the Org should be executed at the end. I think you should throw RuntimeException at the end of the method.
I am not sure at this point, the Org should be executed at the end. I think you should throw Exception at the beginning of each method.
please change the return value.
please put the return value.
please change the return value. A boolean and the return value.
Not sure if I just can't see it, but should we close the zkWorker if we get an exception?
Not sure if I just can't see it, but should we close the zkWorker if we get an exception? (This is why I didn't see it at this point)
Not sure if I just can't see it, but should we check the exception message here as well?
if (visible) {.setText("WatchDog", "The linking prizes"); }
if (visible) {.setText("WatchDog", "The link is a bit shorter."); }
if (visible) {.setText("WatchDog", "The 'index' should be 'nn'ed)...
Hmm, and the old code is even more readable, could we refactor these ifs into a single method?
Hmm.. We're going to need to trim these set anyway, since we're adding the same functionality.
Hmm.. We're going to need to trim these set anyway, since we're adding isEmpty above.
Can you change this to a WARN or something more relevant?
Can you change this to a WARN or lower?
Can you change log.debug level?
This may be changed to Set<Clients> safeGetLatest(org.apache.commons.lang.ImmutableSet.of(delegate.latestSequencesPreparedOrAcceptedCached(Optional.of(node), null));
This may be changed to Set<Clients> safeGetLatest(org.apache.commons.lang.ImmutableSet.of(delegate.latestSequencesPreparedOrAcceptedCached(Optional.of(cacheKey), null))
This may be changed to Set<Clients> safeGetLatest(org.apache.commons.lang.reflect.Method.invoke(this::processDigest)
Why do you check which lightStatusListeners.get() here?
Why are you checking here?
Why do you check here for unknown event type?
possible NPE here: index might try to eval Integer.valueOf(null) this needs protection especially in an API code because we don't know what will be sent
possible NPE
possible NPE afterwards: index might try to eval Integer.valueOf(null) this needs protection especially in an API code because we don't know what will be sent
nit: This test doesn't appear to be testing anything.
nit: the expected result should be the first call
nit: the expected result should be the first parameter since it is never used
should use {}-placeholders instead of string concat
should add {}-placeholders instead of string concat
should use {}-placeholders instead of string concatenation
it seems that the fExtractAction is used in a few places, so it should be in the class
it seems that the fExtractAction is used in a few places, so it should be extracted to a method
it seems that the fExtractAction is used in a few places, so it should be in a common place
I would add a call to repaint here.
I would add a call to the constructor of the SchedulerUtil (i.e. the property of the SchedulerUtil). This way we will be able to get the UI thread name every time.
I would add a call to the constructor of the SchedulerUtil (i.e. the property of the SchedulerUtil). This way we will be able to add a call to the UI thread.
I'm not sure this is the right place to put the modules into a stream and then again we're done with the new log messages, but now that we have the whole list of modules, it will not change. Could you please revert this change?
I'm not sure this is the right place to put the modules into a stream and then again we're done with the new log messages, but now that we have the whole trace. Does this not seem to be the desired behavior?
I'm not sure this is the right place to put the whole stream module name, but this will return all the loggers.
These Predicates.alwaysTrue(bl -> Integer.compare(predicate, "predicate is not supported").
These Predicates.alwaysTrue(bl -> Integer.compare(predicate, "predicate bit")
These Predicates.alwaysTrue(bl -> Integer.compare(predicate, "predicate bit") would be a bit clearer
Are you sure the result is always non-null? (same for other places)
Are you sure the result is always non-null? (that is, the result is always empty)
Are you sure the result is always empty? Wouldn't result always be empty?
This seems to me like a very long time. What about servlet or server (server, server and server) - could be simplified to server.output()
This seems to me like a very long time. What about servlet or server (server, server and server) - could be used to not call server.output().
This seems to me like a very long time. What about servlet or server (server, server and server)?
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
IfpreviousFormatParameters is empty you will enter this if while it used to not be the case before.
If previousFormatParameters is empty this will not be the case before previousFormatParameters = null;
Shall we use shutdownStatusMessage here and in the catch block as well?
Shall we use shutdownStatusMessage here and in the catch clause?
Shall we have a log message like "Error while getting Template Exception"
Maybe we can store it in a static field? Also, missing docs
Maybe we could store it in a static field? Also, missing docs
Maybe we can store it in a static field? Also, missing docs.
Please revert this change, too. e.g. Please revert it.
Please revert this change, too. e.g. final int SCAN.
Please revert this change, too.
This is a bit confusing to me -- we are verifying the environment variable is set to null, but we don't want to verify this method is called.
This is a bit confusing to me -- we are verifying the environment variable is set to null, but then why we don't do it here?
This is a bit confusing to me -- we are verifying the environment variable is set to null, but we don't want to be sure this will not happen.
The constant looks very strange here. I'd suggest using something like this: java final int offset = calendar.get(Calendar.DAY_OF_MONTH) == 1?... :...
The constant looks very strange here. I'd suggest using new StringBuilder().append("0") or + if (month == null) { return ""; }
The constant looks very strange here. I'd suggest using new StringBuilder().append("0") or + if (month == 0) { return ""; }
I think it's better to pull out a separate method, such as createCheckpointInProgressRequest (or a separate one for each CheckpointInProgressRequest) that can be reused in both cases. Your code is doing transform/fail, right?
I think it's better to pull out a separate method, such as createCheckpointInProgressRequest (or a separate one for each CheckpointInProgressRequest) that can be used in this method.
I think it's better to pull out a separate method, such as createCheckpointInProgressRequest (or a separate one for each CheckpointInProgressRequest)
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to keep it as is.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to keep it here too.
Looks like the 4th parameter is a typo :)
Down below we throw.
Inline create() methods here.
Inline create here.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering. Or you can create a convenient method for type T to be used for filtering.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering. I would suggest keeping the different hash functions for type T to be used for filtering.
All the code in get() should be replaced by calling endpoint.getOut() and then the exchange method can be used there.
All the code in get() should be replaced by calling endpoint.getOut() and then the endpoint can be used to do the same in the end.
All the code in get() should be replaced by method.
Can you make this method final? It's not a big deal then.
Can you make this method final? It's not a big deal but it might be worth writing your own code as well.
Can you make this method final? It's not a big deal but will be good to have it in your first review.
I don't think you need this line.
I don't think you need this line: symbols.stream().anyMatch(s -> symbols.contains("django"))
I don't think you need this line: symbols().stream().anyMatch(s -> symbols.contains("django"))
This one should be called after onComplete.call().
This one should be called after onComplete.call(). No need to confirm
This one should just be called after onComplete.call().
test case for response objects is not applicable.
test case for responseObj.
test case for response objects is not present in the response.
I would prefer to check that the dataComplexDataCodec is an ProtobufDataCodec and not an actual conversion.
I would prefer to check that the dataComplexDataCodec is not null before verify that it is actually filled.
I would prefer to use static imports as much as possible
Can it be package private?
Can it be null?
Can we include the partition below as well?
is it good that the relativeTo value should always be relativeTo == null? So we can get a NPE.
is it good that this is null? So we can't just get null here.
is it good that this is null?
this is very confusing - we are prettier with Class<?> which is not used but is there a way to safely override this method?
this is very confusing - we are prettier with Class<?> which is not used but is there a way to safely override this.
this is very confusing - we are prettier with Class<?> which is not used but is there a way to safely cast it to Set?
Is this better as null to avoid potential NPEs?
Is this null safe? I tend to make use of guava as nulls
We prefer immutable collections.
I'm really not sure about this. I meant: java neighborBlockPos.MutableBlockPos(b, y, coordonate(b, y, coordonate(b, coordonate)) neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction ;
I'm really not sure about this. I meant: java neighborBlockPos.MutableBlockPos(b, y, coordonate(b, y, coordonate)) neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction ;
I'm really not sure about this. I meant: java neighborBlockPos.MutableBlockPos(b, y, coordonate(b, y, coordonate)) neighborWrapable |= 1 << direction); neighborWrapable |= 1 << direction ;
Guid can be null
hostCount can be null
Guid should be replaced with Guid.isNullOrEmpty().
Using an enum as mentioned above, this would become if (savePaths!= NONE) which seems cleaner to me.
Using an enum as mentioned above, this would become if (saves identical).
Using an enum here seems cleaner to me.
And again, you can make the iterator more specific: for (Player player : gameState.hasGameState(any())
You can make this function static
And again, you can make the iterator in GameState.
We should use distinct from colVals.
We should use Collections.emptyList()
We should use Collections.emptyList() instead
Why not use the String.format() syntax?
Please use our [pipeline names](<LINK_0> config strings.
Please use our [pipeline names](<LINK_0> instead.
Make this variable final
make this variable final
refactor to be more specific? like **parent**
Actually, we don't need to sleep here anymore
Actually, we don't need to sleep here
Actually, we don't need to wait a bit for the event count
Change the name of the object and use a interimEntries.
Change are useless and can be removed
Change the name of the object and use a interim variable.
Just to be safe, do no need to break as it is already in the while condition, or if we want to break before the while loop remove from the loop.
Just to be safe, do no need to break as it is already in the while condition, or if we want to break before the while loop remove from the while loop.
Just to be safe, do no need to break as it is already in the while loop.
These values should be debug level.
In the past of this debug message, please identify where this is necessary.
In the past of this debug message, please update the print stack.
Wrong variable, should be member-group
Wrong variable, should be memberAttributes.add(attribute.getName());
Wrong variable, should be memberAttributes.add(attr {});
Shouldn't Dto.getName() return an empty String instead of null?
Shouldn't Dto.getName() be all sequencingParameters?
constants
mvn clean verify fails with checkstyle. Fluo prefers using {} instead of if/else
mvn clean verify fails with checkstyle. Fluo prefers using {}
mvn clean verify fails here: <LINK_0> -P
You can just do getHeaders().getFirst() on the response.
You can use Attachment.HEADER_ID_HEADER
again, I think 403 forbidden should be used instead.
should there be a failure here?
should it be TransportException?
why?
Thanks for pointing out this out. I don't see how it works with the linkToEdge functionality.
Thanks for pointing out this out.
Should we use preconditions?
Why do you need this change?
Why do you do this here and in the below?
Why do you do this here and not in the test?
java if (this.streamSize < 0 || this.chunkPos < CHUNK_SIE) { throw new IOException(e.getCause()); }
java if (this.streamSize < 0 || this.chunkPos > 0) {
java if (this.streamSizeInBytes == 0 || this.chunkPos > 0) {
Clbebee = new B>() { @Override public B b; void foo() {... } }
Clbebee = new B>() { @Override public B b; void foo(String s1 ); } };
Extra white lines
This test is not very robust. The mask of test is not very specific to some point and some others may start with "stop" set. I am wondering whether some of the following might be better, but not sure.
This test is not very robust. The mask of test is not very specific to some point and some others may start with "stop" set.
This test is not very robust. The mask of the test is not very specific to some of the others.
This will spam the logs for me. Can we include the email in the log file?
This will spam the logs for me. Wouldn't it be better to do: "Failed to registration user for registration service email: " + email, e);
This will spam the logs for me. Wouldn't it be better to do the JSONs. After all, we have our own message for the email?
nit: Can you make this final?
Typo in "nr" to "nr".
Typo in "nr" to "bundle".
should we log the error at debug level here?
should we log the error at debug level?
Is this a debug statement?
Does it make sense to use the name node instead? The propertyCursor.properties() is also not used.
Does it make sense to have this continue to use the propertyCursor instead?
Does it make sense to use the name node instead? The propertyCursor.properties() is also not used at all.
suggestion
Please update this method to use Filespace instead of ","
Please log warn here.
So, do you expect the application to crash in those circumstances?
This is neat! We'll have to remember to use it elsewhere!! ;)
This is neat! We'll have to remember to use it elsewhere!! :P
This two lines get wrong. I think you can get rid of the two lines above.
This two lines get called twice. I think you can drop the second param and just set the second argument in the method.
This two lines get called twice. I think you can drop the second 'theCek parameter and just set it to 2 lines above.
Would it help to extract a method for this PR?
Is it possible to extract a method for this PR?
Is it possible to extract a method for this sth like that?
Consider extracting this block into a method: java private boolean isLambdaParameter(DetailAST ast) { final DetailAST parent = ast.getParent(); final DetailAST parent = parent.getParent(); if (parent!= null) { return parent.getParent(); } else { return parent.getParent(); } }
Consider extracting this block into a method: java private boolean isLambdaParameter(DetailAST ast) { final DetailAST parent = ast.getParent(); final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); if (parent!= null) { return parent.getParent(); } else { return parent.getParent(); } }
Consider extracting this block into a method: java private static boolean isLambdaParameter(DetailAST ast) { final DetailAST parent = ast.getParent(); final DetailAST parent = parent.getParent(); final DetailAST parent = parent.getParent(); if (parent!= null) { return parent.getParent(); } else { return parent.getParent(); } }
nitpick: [Boolean.parseBoolean(String)](<LINK_0> never throws an exception: [![rule](<LINK_1>](<LINK_2>
nitpick: [Boolean.parseBoolean(String)](<LINK_0> never throws an exception: java public static boolean isCodeValid(String s) { if (s!= null &&!r.isShowCodeValid()) { return!r.isShowCodeValid(); } return s; } so you could simplify this to java boolean in =!r.isShowCode();
nitpick: [Boolean.parseBoolean(String)](<LINK_0> never throws an exception: java public static boolean isCodeValid(String s) { if (s!= null &&!r.isShowCodeValid()) { return!r.isShowCodeValid(); } return s; } so you could simplify this to java boolean in =!r.isShowCodeValid(); if (s!= null &&!r.isShowCodeValid()) { return!r.isShowCodeValid(); } else { return s; } }
Change this to java if (clients!= ClientHelper.empty()) {
Change this to java if (clients!= ClientHelper.empty()) {...
Change this to java if (clients!= ClientHelper.empty()) {... }
Should we use StringBuilder here?
Is there a reason not to use StringBuilder here?
Is there a reason not to use StringBuilder instead of StringBuffer?
Since you are using this when you have nested objects, this would be easier to read.
Since you are using this when you have nested objects, this would be better to use when( provider.class ) to create those objects.
Since you are using this when you have nested objects, this would be better to use when( provider.getPopulator()).
Instead of this, can we remove the "isView"? Since this is a test case, should it be skipped in this method?
Instead of this, can we remove the "isView" check altogether?
nit: you can remove this
Any reasons why this is a double-/?
Any reasons why this is a static constant?
Any reasons why this is a static configuration?
You should always compare strings using the equals method in Java. Testing using the == method might only return true accidentally.
You should always compare strings using the equals method in Java. Testing using the equals method might only return true accidentally.
You should always compare strings using the equals method in Java. Testing using the equals method makes it much more difficult to read
extract the text to Barcode barcodeProperties.
extract these strings to constants
extract these strings to constants.
I would extract this logic (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide better readability but also code reusability.
I would extract this logic (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide well the same code in my opinion.
Maybe a good idea to return the generated token.
you can just use lockChannel.lock()
you can just use ledgerId here as well
you can just use ledgerId here as well.
AJ, An encounter also has a time limit of 2 days set to close if the medical date of visit is null. The 'patient' is the value of a closed encounter. The  vital is the 'Framework' construct. :) The 'page' for a occurrence of the indeterminate  vital provider is the indeterminate ''. :) The 'Service' for a occurrence of the indeterminate  vital type: <LINK_0>
AJ, An encounter also has a time limit of 2 days set to close if the medical date of visit is null. The 'patient' is the value of a closed encounter. The  vital is the 'Framework' construct. :) The 'page' for a occurrence of the indeterminate  vital provider is the indeterminate ''. :) The 'Service' for a occurrence of An encounter. :) The occurrence of the indeterminate  vital is the indeterminate ''. :) The 'Service' for a occurrence of An encounter. :) The occurrence of the indeterminate  vital is the indeterminate ''. :) The 'Service' for a null pointer indeterminate : <LINK_0> -Kevin
AJ, An encounter also has a time limit of 2 days set to close if the medical date of visit is null. The 'patient' is the value of a closed encounter. The  vital is the 'Framework' construct. :) The 'page' for a occurrence of the indeterminate  vital provider is the indeterminate ''. :) The 'Service' for a occurrence of An encounter. :) The occurrence of the indeterminate  vital is the indeterminate ''. :) The 'Service' for a occurrence of An encounter. :) The occurrence of the indeterminate  vital is the indeterminate ''. :) The 'Service' for a occurrence of An encounter. :) The occurrence of the indeterminate  vital is the indeterminate ''. :) The 'Service' for a null pointer indeterminate : <LINK_0> -Kevin
What if a student or unregistered user calls this endpoint?
What if a student or unregistered user calls this method?
What if a student or unregistered user calls this as course.
[optional] Obviously this will print 83 characters when the length > 80.
[optional] Obviously this will print 83 characters when the length > 80. If the length == 1.
[optional] Obviously this will print 83 characters when the message is 83 characters.
I think we need a null check here that we're not going to use JedisPoolFactory.MODEL.getConfig().redisAuth() right?
I think we need a null check here that we're not going to use JedisPoolFactory.MODEL_TIMEOUT_TIMEOUT as well
I think we need a null check here that we're not going to use JedisPoolFactory.MODEL_TIMEOUT_TIMEOUT as well?
Assert it
Please mind the original on a test.
Assert
I think this should be "Type"
I think this should be "Type" not "Admin"
I think this should be "Type" not "Expression"
can we avoid the ArgSpec implementation here (and in ArgSpec)
should this be || timestep?
should this be taken out of the cursor?
suggestion LOGGER.trace("ISBN { } not found for ottobib", identifier); This is the recommended way
suggestion LOGGER.info("ISBN { } not found for ottobib", identifier); This is the recommended way
suggestion LOGGER.trace("ISBN { } not to Sb", identifier); This is the recommended way
Is this really needed?
Collections.singleton() should work here.
Collections.singleton().
I generally don't like this boolean check, but I think it would help if (mIsShader == null ||!mIsShader.getShader().equals(true)) {
I generally don't like this boolean check, but I think it would help if (mIsShader == null ||!mIsShader.isIdentityTransformDirty()) {
I generally don't like this check, but I think it would be a good idea to move this check into mIsShader()
do not set the correlationId for the request. It is only applicable for the reqeust of the response.
do not set the correlationId for the request. It is only applicable for the reqeust of the request.
asserttrue....
Let's use Optional here.
Let's remove the type of annotation and use the default value from AvroElasticMemoryMessage.
Let's remove the type of error.
Maybe rename to rootSelectionId.
Maybe rename to rootSelection.
Maybe rename to rootSelectionFields.
<LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
<LINK_0> If this source change was intended, can you change this line to 46?
<LINK_0> If this source change was intended, can you take a look at <LINK_1> and see if this broke the PR?
Are you sure that this catch statement is really needed?
Are you sure that this catch block is really needed?
Are you sure that this catch block is actually needed?
You might want to store a whole number of bytes in a variable rather than casting it.
You could actually cache the whole thing, since it's pretty constantly doing string manipulation. I think we could just log the whole thing in a nested try-catch block.
You could actually cache the whole thing, since it's pretty constantly doing string manipulation. I think we could just log the whole thing in a single place, but that's somewhat more complicated.
Rename this as false to indicate privacy policy in the system
Rename this as false to indicate privacy policy in the system.
Rename this method to match the existing on kitDescriptor
zoomIn and zoomIn
zoomIn and zoomOutEnabled attribute are swapped in here, how is it different from the zoomIn?
zoomIn and zoomOutEnabled attribute are swapped
Should we add a fail() after the close() call?
Isn't this a race condition? I think it would be better to catch the exception and continue with the rest?
Isn't this a race condition? I think it would be better to add a fail() after the close() call.
Should you use the same some kind of date, such as sampleName, and dateFormat?
Should you use the same some kind of date, such as sampleName, etc?
Should you also use the date variable from sychronized method?
use a copyFileToTestProjectAsset(... )
why is this needed?
why?
It is a bit confusing that we have a log message but then we can see that it doesn't have a stacktrace.
It is a bit confusing that we have a log message but then remove this log.
It is a bit confusing that we have a log message but then we can see that it doesn't have a context.
This line is duplicated
This line is duplicated. above.
This line is duplicated.
Minor: we should not mix "s" strings as constants.
Minor: we should not use System.out.println with "exp"s.
Minor: we should not use System.out.println with "lo" for the "err" strings.
You can make this more cleanly by using a try-with-resources statement. java try (Client request = request.getBody(); Scribe! :)
You can make this more cleanly by using a try-with-resources statement. java try (this.publicClient) { final String response = request.getBody(); Scribe! :)
You can make this more cleanly by using a try-with-resources statement.
Don't set key and location, in case of failure, this won't work.
Don't set key and location, in case the linkNode gets a null value, you don't need to set it to null.
Don't set key and location, in case the linkNode gets a null value, there's no need to set the object.
This else is redundant.
This else is redundant. There is a couple of other places.
This else is redundant. You can remove it.
You can use Dao which we use in the test (by calling mock(Mock) and then mock it
You can use assertFalse here.
You can use Dao which we use in the test cases
Needs a test for this.
Liens's yeah, this one might read better as a while
Suggest doing it here.
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_G_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdE
nit: you'll need to add a print statement or remove this System.out.println.
I think there's a failure here.
I think it's currently doing all this stuff in this class.
I assume you can remove this, it's not needed since there is a warning instead of an error.
I assume you can remove this, since there is a warning instead of returning null
I assume you can remove this, since there is a warning instead of returning null anyway.
nit: The mocked query can be replaced with assertEquals(memoryPools, server);
nit: The mocked query can be replaced with assertEquals.
nit: The mocked query can be replaced with assertEquals().
We should add assertPatientEntity2.isSynced() to this
We can just add this for an patient which is empty but don't get one
We can just add this for an patient which is empty but don't get(0)
nit: just something with the name of the test implies failure.
Nit: just something with the name of the test implies failure.
nit: just something like this: java Mockito.verify( results )
Replace hardcoded "//" with using Util
Replace hardcoded "//" with using equals()
Replace hardcoded "//;" with using Util.equals()
If we threw this IllegalArgumentException("Uncategorised IO on the currentWorkingDirectory  System.currentWorkingDirectory);
If we threw this IllegalArgumentException("Uncategorised IO workingDir," + message);
If we threw this IllegalArgumentException("Uncategorised IO on the currentWorkingDirectory  System.currentWorkingDirectory());
should be done in an IntentService instead of a "slot-type"
please rename 'use'
should be done in an IntentService
Is this doing what I think it is -- using a normal directory as temp directory - outside or temp folders...
Is this just a normal directory as well? Why are we using a normal directory as a directory - outside or temp folders...
Is this just a normal directory as well? Why are we using a normal directory as the path,.
Can you log the exception too?
It's really hard to come up with a name for this.. not happy with this because it suggests action with DO but doesnt specify the action. I am unable to come up with any better though
It's really hard to come up with a name for this log message. Can you update the metric and make it recordable?
Instead of displaying strings like this should we consider creating some constants for the strings that aren't used in strings.xml?
Instead of displaying strings to the new method, I suggest using  findViewById and move the code to the base class.
Instead of displaying strings like this should we consider creating some constants for the strings that aren't used in strings.xml so you can just call them here.
why don't we use intention here?
why don't we move the R.string into the lamda?
no System.out please
That could be simplified by changing the order of the checks to: if (isValidFeatureValues(match)) { return true; } if (end == null) { return false; } return true;
That could be simplified by changing the order of the checks to: if (isValidFeatureValues(match)) { return true; } if (isValidFeatureValues(match)) { return true; } return false;
That could be simplified by changing the order of the checks to: if (isValidFeatureValues(match)) { return true; } if (isValidFeatureValues(match, false)) { return true; } return false;
Why the check for to be done twice?
Why the cleanup? This is handled by the cleanup
Why this change?
Why do you need another set? Just use fTagLocations to check if it is there or not
why do you need another set? Just use fTagLocations to check if it is there or not
Why do you need another set? Just use fTagLocations to check if it is there or not.
Should we throw an exception if defaultSchema is null?
Should we throw an exception if default schema has tables?
Should this throw an exception?
Suggest using a format string to set the user name.
This should be a 'validate' method.
Suggest using a format string to set the user text.
I usually prefer the depth comparison, a single integer comparison, over two String equality checks.
I usually prefer the depth comparison, not the equals.
I usually prefer the depth comparison, a single integer comparison and prefer the depth comparison.
I think we should be using this form instead: try {... } finally { db.close(); } We do not need to worry about re-review since we are using 'deleted'.
I think we should be using this form instead: try {... } finally { db.close(); }
I think we should be using this form instead: try {... } finally { db.close(); } We do not need to worry about re-review since we are using 'close' for everything.
Should this be in the TemplateProcessor?
Should this be in the PR?
Should not be needed
Let's be consistent and use DiskImage::getDiskImage instead.
Let's be consistent and use DiskImage::getDiskImage here too please.
Let's be consistent and use DiskImage::getName
I don't see why we are returning an empty list. That doesn't seem to be the case?
I don't see why we are returning a list of JobID. This doesn't seem to be the case. the job directory is going to be getting bigger. Instead you should make sure this is what's going on in the cluster.
I don't see why we are returning a list of JobID. This doesn't seem to be the case?
If the model entity is not used, the method will be returning a model object.
If the model entity is not used, the method will be returning the model object.
This is not needed.
These five lines should really all be in their own method, along with the parsing of the timestamp in the beginning.
These statements can be simplified to: return Objects.equals( timestamp, timestamp) && Objects.equals(timestamp, timestampString.substring(0, timestamp.lastIndexOf(".")));
These statements can be simplified to: return Objects.equals( timestamp, timestamp) && Objects.equals(timestamp, timestamp);
why not use java.util.Class here?
Why not use java.util.Class here?
why not use java.util.Class here instead of printing stack trace?
Why not call selectedPulse.get() here like the above?
Why is this null here?
Why is this needed?
Define the actual exception message as a constant to help with readability.
Define the actual exception message as a constant?
Define the actual exception message as a constant to use in this class.
You can select the quality_gate_uuid and check if it's not there
You can select the quality_gate_uuid and check if needed
You can select the quality_gates where the JDBC_gates are built which are not interesting
If someone used this method, then it can use Objects.hash() instead of java.lang.Object.
If someone used this method, then it can use Objects.hash() instead of java.util.hash()
If someone used java.util.Random, this will return an int.
wow, can we just keep totalLifespans and use totalLifespans.getAsInt() every time the value is used?
wow, can we just keep totalLifespans.getAsInt() every time the value is used?
wow, can we just keep totalLifespans but use totalLifespans.getAsInt() every time the value is used?
This seems like a unnecessary change
This seems like a leak of RemappedFlag?
This seems like a leak of RemappedFlag since this is in the same package
Use the new ArrayList<>(ids) throughout this file.
Use the new ArrayList<>(ids) in order to avoid issues with that.
Use the new ArrayList<>(Requirement2[]) syntax.
cle 131
cle t
cle
Why not this.sorted().uniqued()?
Why not IntervalList intervals = new IntervalList intervals? new IntervalList intervals : haplotypeProbabilities.getChrom(snp.getName(), new IntervalList(this));
Why not return intervals.sorted().uniqued()?
java8-isation [forEach][filter]
java8-isation [forEach][map]
java8-isation [forEach]
Why are we doing here? I think it should be done in onMatchingSchema(() -> values.schema().getPropertyIdsForProperty(item.schema()).properties(), node -> { OrderedPropertyValues values = new OrderedPropertyValues( values.schema(), node.id(), null); return values.stream().filter(v -> Pair.of(item.schema().getPropertyIds(), indexDoUpdateEntry.class)).map(item -> (String) index).collect(Collectors.toList()); return values; } OrderedPropertyValues values = new OrderedPropertyValues(null, index);
Why are we doing here? I think it should be done in onMatchingSchema(() -> values.schema().getPropertyIdsForProperty(item.schema()).properties(), node -> { OrderedPropertyValues values = new OrderedPropertyValues( values.schema(), node.id(), null); return values; } }); return null;
Why are we doing here? I think it should be done in onMatchingSchema(() -> values.schema().getPropertyIdsForProperty(item.schema().getPropertyIds())));
This part should be moved below as well.
This needs to be changed.
This part should be moved below as well, in case we generate a list for it.
It's better not to change the variable name to messagePayload, but instead of message.getMessageAttributes().
It's better not to change the variable name to messagePayload, but instead of message.getMessageAttributes()
It's better not to change the variable name to messagePayload, but instead of message.getMessage...
setErrorMessage
setErrorMessage here as well
setErrorMessage
Are you missing a static field, or static field, of the class?
Are you missing a static import for the local variable?
Are you missing a static import for the local variable, or use the class?
Based on the previous code, shouldn't the assertTrue be here?
Based on the previous code, shouldn't the wait be 2500ms?
I would prefer to use assertTrue here.
This list should only contain expectedConceptEntity1's since expectedConceptEntity2'sByUUID=true
This list should only contain expectedConceptEntity1's since expectedConceptEntity2'sByUUID_should return true.
This list should only contain expectedConceptEntity1's since expectedConceptEntity2'sByUUID_should return a true.
@marchof I would assume that expressionAnalyzer.getTypeManager() is also used for symbol %s.
@marchof I would assume that expressionAnalyzer.getTypeManager() is also used for parameter
@marchof I would go a bit more explicit about this. Why is it only used for "is"?
Can be replaced with Clustered.
Can be simplified to Clustered.
Can be simplified to infinispan.
isn't it safer to continue to set the configs if the cronTaskExecutedEvent will be called for every task?
isn't it safer to continue to set the configs if the cronTaskExecutedEvent will be called for every job?
isn't it safer to set the timeout of cronTaskExecutedEvent?
Probably better to use RESULT_OK here.
Probably better to use REQUEST_CODE constant.
Probably better to use a constant for this.
Add Throwable instead of Exception?
Add a new exception as the cause of the new exception type?
Add a Throwable instead of Exception?
Typo, should be 'customProcessorInfo'
Typo, should be Processor
Typo
I think this should be date.getDatasetName() instead of date.get().
I think you need to handle the case where date is null
I think this should be date.getDatasetName() instead of date.get().get().
Can you use placeholders with {} for all arguments?
Can you use placeholders with {} for these arguments?
Can you use placeholders with {} for all arguments? :)
Shouldn't it be done in schedulingACronJob?
I am not sure it is safe to put this here. Won't it obtain the scheduling from scheduling in start() and schedule()?
I am not sure it is safe to put this here. Won't it obtain the scheduling from scheduling in start()?
"The server does not support any of the protocol"
"The server does not support any of the protocol version"
negotiateProtocol is a little misleading.
I would add cacheProcessInstanceId as a field and it is used only once. That way it will be used for each process call.
I would add cacheProcessInstanceId in the order to make it a local variable and start with it.
I would add cacheProcessInstanceId as a field and it is used only once.
toLowerCase
toLowerCase() is missing
Constant
space after "+"
space after 'if'
space after (
I think you need to add a check for vmStatic!= null, which will cause error if the vm is null or if the user didn't create the vmStatic.
I think you need to add a check for vmStatic!= null, which will cause error if the vm is null or empty
I think you need to add a null check here which will cause NPE
Isn't it possible to use streams here?
Isn't it possible to use streams here? for (IP : en) { interfaceIPs; }
Isn't it possible to use streams here? for each!
removeTasks should be in finally block. If task is in an exception then there is no need to stop tasks.
removeTasks should be in finally block.
removeTasks is never used
Style fix: Wrong indentation for method names
Style fix: Wrong indentation for method names.
Style fix: Wrong whitespace
Are you sure you are right is to use the factoryHolder here? I mean, you are closing a transaction when the factory is already there. What if the factory is supposed to be rolled back because something else needs to be done for the user workflow to be correct? Also the GraphDatabaseService should probably have a similar method for each upgrade.
Are you sure you are right is to use the factoryHolder here? I mean, you are closing a transaction when the factory is already there. What if the factory is supposed to be rolled back because something else needs to be done for the user workflow to be correct? Also the GraphDatabaseService should probably be changed to use the same GraphDatabaseService.
Are you should you need to protect against null here? If yes, the synchronized (this) should be preferred over a proper boolean.
We don't want to set the remote source -- do we?
We're not using the remote source -- do we want to set uri back to the web UI?
We're not using the remote source -- do we want to set uri back to the web server?
Style nit: I think this is redundant.
I think this is the best way to handle this.
+1 this is redundant.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java bean prefix of get or is.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove a Java bean prefix of get or is.
.getDeclaredAnnotation()
Won't it be faster to convert this lambda to a map? Iterable<String> FIELD_ISSUE_LIST =.stream().map(String::toString).collect(MoreCollectors.toList())..
Won't it be faster to convert this back to an IndexDefinition from the identified query?
Won't this solve the problem?
Will this exception be logged for some reason?
Will this method be called for all partitions?
Will this method be called by default?
This can be replaced with something like: assertNull(voidedDiagnosisServiceedDiagnosisService);
This can be replaced with something like: assertNull(voidedDiagnosisService)
This can be asserted too.
Shouldn't we return here?
Shouldn't this be type parameter?
Shouldn't we show the view location at the point?
rename to simple
bad naming, please rename to simple
bad naming, I would rename it to simple
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts)
Why do we need frontend changes when we don't plan to expose VmPool.getId in the API?
Please use Objects.equals()
This kit name is not an instance of kitname.
This kit name is not an instance of kit name.
This kit name is not very consistent.
rename to element
final?
inline?
check response code.
check response code. Can response be null?
check response code/response string.
HttpServletResponse.SC_NOT_FOUND
@free4murad Why you put same implementation of subscribe()?
Use??
Again you can use AttributesManagerBl just by casting returned object from ldapcManager.getPerunBl() from Perun to PerunBl.
Again you should check presence of Attribute and Facility within the beans read from ldapcManager.
Again you can use AttributesManagerBl just by casting returned object from ldapcManager.getFacility().
Why did you add this, when you just want to the log statement?
Why did you add this, when you just want to check a PUT?
Why did you add this, when you just want to the log.error?
maybe the first sentence should be "executor submit failed" or something similar?
maybe the first sentence should be "executor submit failed" or something like that?
maybe the first sentence should be "executor submit failed"
I'm not sure why we're adding this check here.
I'm not sure why we're adding prerequisites.isEmpty() here.
I'm not sure what this call is doing. Why do we need it here?
Space after ()
Space after if
Space after.
@cuenyad use regex
@cuenyad use anyMatch instead of isEmpty
@cuenyad use anyMatch instead of noneMatch
Please add braces around ||.
Please add braces around the for loop.
Please add braces around this if statement.
You may want to remove the System.out
You should probably use findEntity() since the list of var0s can be used
You should probably use findEntity() since the list of var0s can be used directly.
this new String[] is unnecessary. These are auto-formats. Please, use Utils.splitString, for example in this file.
this new String[] is unnecessary, please remove it.
this new String[] is unnecessary. These are auto-formats.
Seems like we should be able to use try-catch-finally here?
As above, probably shouldn't use try-with-resources to ensure consistency.
As above, probably shouldn't use try-with-resources to ensure we always get closed.
Why do we need to convert to a list? can't we just iterate over the array?
Why do we need to convert to a list? can't we just iterate over the deserializedObj array?
Why do we need to convert to a List? can't we just iterate over the list?
This expression is never used.
This if-else can be replaced with one statement
This if-else can be removed
So we basically use this to bypass hostname verification?
So we're basically saying this is true?
So we're basically testing this thing now, right?
I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate
I think we should allow to also log the exception stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate
I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate.
Do we need to update the value if newValue == null?
Can we catch any exception here?
Do we need to update the key at all if the update was successful?
Format this file.
Maybe extract this to a separate method.
Maybe extract this to a constant somewhere?
the serialization is not reliable, what is the purpose of this cast?
the serialization is not reliable, what is your opinion?
the serialization is not reliable, what is the purpose of the JSON?
can this be done in a synchronized block in ActiveMQConnection, with the different handlers?
can this be done in a synchronized block in ActiveMQConnection, with the different messages?
should this be done in a synchronized block in ActiveMQConnection, with the different messages?
I think it's better to add this.featureDao.saveFeatures(coordinates).
I think it would be better to add this.featureDao.saveFeatures(coordinates).
I think it would be better to add this.featureDao.saveFeatures(coordinatess)
Isn't the try block needed here? As it is a default value rather than an explicit null.
Isn't the try-block inside the if block? As it is the standard for loop, please initialize it in the try block.
Isn't the try block needed here? As it is a default value rather than an explicit Geometry size.
This is inconsistent with the setText variant.
This is inconsistent with the size of 1.
This is inconsistent with the size of the snackbar.
This was inefficient. Odd... are we cannot cache the result?
This is confusing. What if something is wrong with the root?
This was inefficient. If we go t.get() the values are expensive, we should loop them over the list.
Might it be a problem, but you should probably use the new @NonNull annotation on the parameter here.
Might it be a problem, but you probably want to use the new @NonNull annotation on the parameter here?
Might it make sense to use ColorMode.isOnSameElement() here?
Why don't you use isNotBlank here?
Why don't we use isNotBlank here?
Why don't you use isNotBlank here and remove trailing whitespace?
Cannot we add this to the exception?
Cannot we add this to the message?
Cannot we add this as a warn?
is this really needed?
is this really needed? You could just use the newIoc i in this situation.
is this really needed? You could just use the newIoc i in this case.
Why are you overriding it here? I think it's not good.
Why are you overriding it here? I think it's not good to use the BoundedContext here.
Why are you overriding it here?
Lower case
Lower case should be used
Lower case should be disabled
I think we don't need this if else branch.
I think we don't need to clear the database type here.
I think we don't need to clear the database type here if we use default value.
Should this be using MassRepairOption, ExportViewTypeMap.getQuantity?
Should this be using MassRepairOption, ExportViewTypeMap.SmartLock?
Should this be using MassRepairOption, from PageView?
Wouldn't this lead to a NPE if credentials is null?
Wouldn't this lead to a NPE? If a user has already made modification of the wallet, would it?
Wouldn't this lead to a NPE if credentials is null? If yes, would it be safer to put that before the block and get rid of the isPresent check?
This test method says test not setting the patient id of the patient. The problem is that the order with id 88 in the test dataset does not have any effect on the order being drug. Does this test not pass?
This test method says test not setting the patient id of the patient. The problem is that the order with id 88 in the test dataset does not have any effect on the order being drug. Does this test pass?
This test method says test that properties are not null because you just assert that the person object is empty
need a null check on username and password
need a null check on password
need to check username and password
consider moving the if to the addVmCinderDisks method.
we should consider moving the if to the addVmCinderDisks method.
consider moving the if to the addVmCinderDisks method, that way you can read it
Use foreach?
Use foreach to avoid the'for readability'
Use foreach to avoid the'for loop'
It needs i18n still. You probably just need to create a new logger class in this weld/ejb module
It needs i18n still. You probably just need to create a new logger in this PR if a set
Using a set would probably be simpler
osArch already has a null check for it.
osArch already has a constant for "equals"
osArch already has a constant for "equals".
We don't need to mock it.
We don't need to Remove this (weight.ManagedProperty).
We don't need to Remove this (weight.ManagedProperty)
Shouldn't this be a protected method to make it more accessible to the caller?
Shouldn't this be a separate method to replace the second call to 'else' with a=true'?
Magic number <LINK_0>
Prefer "variants" to express constants
Prefer "variants" to express constants.
Prefer using a constant instead of "magic".
I think it would be more robust to use org.talend.commons.utils.Version, which implements the interface Comparable.
I think it would be more robust to use org.talend.commons.utils.Version, since that class implements Comparable.
I think it would be more robust to use org.talend.commons.utils.Version, since that class is already shared with Java projects
nit, adding parenthesis to the calculation so it is cleaner.
nit, adding {} to the method
Simplify into one line?
Maybe "ArgumentDeclaration".equals(fieldId)
I think you should re-use that logic here
Maybe "ArgumentDeclaration".
nit: we can use length of proxy here instead of target.
I know we are dealing with this but can we not support this approach?
I guess we can remove this.
I don't like this stuff in the getArguments() method. Can you change it to just call getArguments()?
suggestion getArguments() {
I don't like the sec here suggestion getArguments().getString(R.id.getArguments() + "selected_text");
Looks like this map is not used anywhere.
Looks like this line is not needed?
Looks like this map is never used?
Here indentation is screwed again. Just remove the whole try there's no need for this example
Here indentation is screwed again. Just remove the whole try there's no need for these indentation
it's better to show any API call with this access token
This is not a good idea to throw an exception with any message. It's not a good idea to log it
This is not a good idea. The whole point is to include the name in the error message, not just the message
This is not a good idea. The whole point is to include the name in the error message and it's the user name
I would recommend to set testClass to null in the SuiteEnvironment constructor since it is a man-setizable test.
I would recommend to set testClass to null in the SuiteEnvironment constructor since it is also called for other tests
I would recommend to set testClass to null in the other test cases.
Style-nit: Parens aren't necessary here around the new operator.
Wrap this: if (diffBaseId == null || diffBaseId.equals(diffBaseId)) {... }
Wrap this: if (diffBaseId == null || diffBaseId.equals(diffBaseId)) { return; }
suggestion log.warn("Could not delete service account user {}", serviceAccount);
See if you can combine these two lines into 1
See if you can use {} around the block.
I think this line should be removed.
I think this line should be replaced with.equals here.
I think this line should be replaced with.asalized()
I'd call Arrays.asList instead of Arrays.asList
I'd like Ints.toArray(xp, Collections.emptyMap());
I'd call Arrays.asList(xp, Collections.singletonList(collection));
to be consistent with the sorting order here, you could just add checks that currentSortBuffer is not null
should this be public?
should this be before the if statement?
Could you add a overload that takes a timeout?
could be final
could be final.
Does this test fail when it did not delete the file? Was it useful to test it?
Does it make sense to assertTrue() here.
Does this test fail when it did not delete the file?
Why not chain these setting in the previous statement?
Why not chain these setting in the next statement?
Why not chain these?
looks like this method can be left there?
initialize or getStringValue()
initialize?
same as above.
same reason as above.
same thing as above.
Wouldn't the default constructor be easier to use here?
Wouldn't the MockMapBuilder be easier to use and more elegant here?
Wouldn't the default constructor be easier to use and set a default constructor here?
I think it'd be better if this was abstracted by Entry<Long, FileSummary>, and then have Entry<Long, FileSummary> get the Entry<Long, FileSummary> entry. The dedicated method would be refactored by extracting this into Summary class, and also have Entry<Long, Entry> getHostnameOrIp(provider)
I think it'd be better if this was abstracted by Entry<Long, FileSummary>, and then have Entry<Long, FileSummary> get the Entry<Long, FileSummary> entry. The dedicated method would be refactored by extracting this into Summary class, and also have Entry<Long, Entry> getHostnameOrIp(Key<Long, FileSummary>)
I think it'd be better if this was abstracted by Entry<Long, FileSummary>, and then have Entry<Long, FileSummary> get the Entry<Long, FileSummary> entry. The dedicated method would be refactored by extracting this into Summary class, and also have Entry<Long, Entry> getHostnameOrIp(Key<T>)
Rethrow an error if request is invalid or bad.
Rethrow an error if there is no invalid plugin?
Rethrow an error if there is no invalid plugin instead of returning
Suggest having a method that takes the default length and the size of the array, with the comparator used instead of having /int/length > 0.
Suggest having a method that takes the default length and the constructor with the appropriate length.
Suggest having a method that takes the default length and the size of the array, with the comparator used instead of having /int/length / (48).
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated error message![screenshot 2015-09 21 44 35](<LINK_0>
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated error messages.
This logic partly duplicates many times in this loop.
I think that this method is unused. Can we change it to this?
Objects.requireNotNull(user, when) returns false if the user has been removed. Can we change the name of the method to something like isActiveUser()?
Objects.requireNotNull(user, when) returns false if the user has been removed.
One more.
Remove catch Exception.
One more. ;)
is there a reason why the same digit is used?
1. I think the logic here could be refactored, 2. Non-null? Any way that we can make this private?
1. I think the logic here could be refactored, 2. Non-null? Any way that we can have a test that handles this case?
@Serranya Please add spaces before and after the trim
@antonini If you add @SuppressWarnings("unchecked") then this will cause the warning.
@antonini If you add @SuppressWarnings("unchecked") then it can be used in these two checks to avoid unnecessary final keyword.
Should we assert that apiversion is of the created name?
Should this be an assertNull(command, apiversion)?
Should we assert that apiversion is of the first resource?
Here again I would not assert the result of the op, only that resilience strategy has been called.
As with others, I would not assert on the return value of the operation
Here again I would not assert the result of the op, only that resilience strategy has been invoked.
@mkordas, what do you think about changing this to a simple string like "(ASTNode).add("inner join", new char())?
@mkordas, what do you think about changing this to a simple \ and then join?
@mkordas, what do you think about changing this to a simple string like "(ASTNode).zip(...))"?
use this utils method for this
use this utils method to show error
use this utils method
It would be great to parse the content of the array too.
It would be great to parse the content of the JSON to avoid copy-paste issues.
It would be great to parse the content of the JSON to avoid copy-pasted text.
IMO, you can merge both ifs if (rv == null ||!needsUnboxing(ctx)) { return null; }
IMO, you can merge both ifs if (rv == null ||!needsUnboxing(ctx1, command2) -> {
it isn't needed since onReturn() already returns CONTINUE_INVOCATION
Shouldn't an error be thrown here?
Shouldn't IllegalArgumentException be thrown here?
Shouldn't an error be handled here?
Better to just age >= age * Long.parse(cookie);
Better to just set age >= age * Long.parse(cookie);
Better to just age >= age * Long.valueOf(cookie);
This seems like the wrong path... what about moving this one to the 'if' below?
This seems like the wrong path... what about moving this one to the 'if' above?
Nitpick: the simpler simpler :)
I'd move this to a separate method
I'd replace this with a better name.
I'd replace this with a call to isUnknownMuleError
I'm not sure if this can be done in the constructor. Couldn't we have a performance impact?
I'm not sure if this can be done in the constructor. Couldn't we have a performance performance impact?
I'm not sure if this can be done in the constructor. Couldn't we make it protected?
Being a bit more readable.
getRepresentation() -> refresh()
Being with representation() is better.
This early return can be removed.
This doesn't need to be static.
This early return can be avoided.
aren't changing the API name?
again format
!
I think we should put this entire function in the first place so that it can be easily taken when you add an item to the AsyncTask or clear them.
I think we should put this entire function in the first place so that it can be easily taken when you add an item to the global intent.
I think we should put this entire function in the first place.
initializePackageAttributes should be the first operand
is this supposed to be the original?
initializePackageAttributes?
AssertThat(fail)
Assert.fail()
Assert.fail
Why don't you require the property name in the dbcp config file as well in the runtime properties, the values from dbcp config file would be ignored?
Why don't you use the dbcp config file as the runtime properties, the values from dbcp config file would be ignored?
Why change this?
suggestion if (isAskResponse) {
Goodbye.
Goodbye. Good idea
maybe change the message to "Non-HTTP"?
Revert this change
why does this message make sense?
I'm not sure about the condition.
I'm not sure about the use of this variable.
I'm not sure about the use of regex.
again, is this really a SAXNotSupportedException?
Again, why is this needed?
Please remove this and the else clause below.
See getAllOperandsCachesCache
This is inconsistent with the code in the next If If useCache is null, to cover the codebase
See getAllOperandsCache in the quantile
requireNonNull(keyBlockNativeEquals, "keyBlockNative == keyBlockNative == null");
requireNonNull(keyBlockNativeEquals, "keyBlockNative == null");
keyBlockHashCode is null
Good idea. Will do.
Good idea. Will go.
Good job.
Is there a reason to use "lefts" instead of "rights" directly?
Is there a reason to use "rights" instead of "description"?
Is there a reason to use "lefts" instead of "rights"?
Can we extract this as a constant?
Can we extract this as a member variable?
LOG
This is not right. This is a general PR and should be fixed for a refactoring.
This is not right. This is a general RuntimeException. Please leave as is and do not call any more.
This is not right. This is a general RuntimeException. Please leave as is and do not add a catch block here.
Can we use Type.VARCHAR_TYPE instead of FUNCTION_IN?
please use Type.VALUE_ARRAY instead of 0
Can we use Type.VARCHAR_TYPE instead of of 0?
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
@merciesa maybe matter of taste, but why not rather use the new line?
!generatedKeys.isEmpty()
Constants should be generatedKeys.
Constants should be generatedKeys.length
To be super nice, we have a few conventions in dasein: - [x]
To be super nice, we have a few conventions in dasein: - AutoScalingData - ips - identifier
To be super nice, we have a few conventions in dasein: - AutoScalingData - ips - identifiers
Use rewrite instead of get expression.
Use rewrite instead of Context.this
Use rewrite instead
You can use try-with-resources here.
You can use try-with-resources construct here
You can use try-with-resources
It's better to use static import here to simplify the code.
It's better to use static import to make the method to simplify the code.
It's better to use static import to make the method to simplify what code.
Are you sure this is the correct behaviour? The uuid should be taken from the patient, not by the drug other orders.
Are you sure this is the correct behaviour? The uuid should be taken care of by the patient, not allergy.
Are you sure this is the correct behaviour? The uuid should be taken from the patient, not by the drug, so this is what we want.
Please use participantId\":\"" in a file, it's not necessary to do the text for you.
Please use participantId\":\"" in a string literal, it's not necessary to do the text here.
Please use participantId\":\"" in a variable
Can you put the first block within a single if?
Can you put the first block in a single if?
Can you put the first block in a single line, so it's more readable?
If not inlined, requestedCount reference should be read into a local variable outside the loop.
As requestedCount reference may be read into a local variable outside the loop.
If not the requestedCount reference should be read into a local variable outside the loop.
fix formatting add space after bracket
fix formatting add space after an if
fix formatting add space after if
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I don't know the answer, just raising the question.
Before, if there was an exception, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
will this need to be public? I think if we come to this, the instance with new ValueAnimator((new ValueAnimator( iconSpinning... ) will still be added as a simplifications for the other fields.
will this need to be public? I think if we come to this, the instance with new ValueAnimator((new ValueAnimator( iconSpinning... ) will still work.
will this need to be public?
this can be set by user
can be set by user
this can be set by the user
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as this.store = getStore(KEY_SET_A, KEY_SET_B); private Store getStore(Set<String>... sets) { Map<String, String> originalStoreContent = getEntryMap(sets); FakeStore fakeStore = new FakeStore(originalStoreContent); return spy(fakeStore); } especially since there's a getCache() method to encapsulate the cache creation
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as this.store = getStore(KEY_SET_A, KEY_SET_B); private Store getStore(Set<String>... sets) { Map<String, String> originalStoreContent = getEntryMap(null); FakeStore fakeStore = new FakeStore(originalStoreContent); return spy(fakeStore); } especially since there's a getCache() method to encapsulate the cache creation
I'm a bit picky here, but the test will fail if the store is not in the cache. I would recommend using a mock cache instead.
Check lines for xfB and xfB constants.
Check out of the variable.
Check lines for xfB and xfBW as well.
I would rather use the newer: Since the variable is not used then there is no way to detect an instance of this class every time this is called.
I would rather use the newer: Since the variable is not used then there is no way to compile the new instance every time this is called.
I would rather use the newer: Since the variable is not used then there is no way to detect an instance of this class every time this is called and to reset the previousPatterns rather than the new one every time this method is called.
It looks like the cleanup is on heap, so this doesn't need to be in the same location.
It looks like the cleanup will be run in the same process. I believe it won't be fixed now.
It looks like the cleanup is on heap, so this doesn't need to be in the same location as the file path.
Why not just do line.add(getProject().getNameKey());?
why final?
Why not just do lines.add(getProject().getNameKey());?
new StringBuilder().append(AbfsClient.this)
new StringBuilder().append(AbfsClient.this) does this for you.
if (first) { } and move the regular block
It's not good practice to accept an empty map here. The only thing you should find out is that it's not the case and not do anything if it's not in the middle of the chain.
It's not good practice to accept an empty map here. The only thing you should find out is that it's the first thing in the file, and then do the other.
It's not good practice to accept an empty map here. The only thing you should find out is that it's not the case and not do anything if it's not in the middle of the file.
it is safer to perform the comparison the other way: VmDeviceType.valueOf(device.getType()) no risk for NPE.
it is safer to perform the comparison the other way: VmDeviceType.Empty = Engine().getInstance().getImageVmMapDAO().get(device.getType()); if (VmBase.isVm) { VmDeviceType.valueOf(device.getType()); }
it is safer to perform the comparison the other way: VmDeviceType.Empty == VmBase.getInstance().getImageVmMap()?
Why don't we use function manager?
Why don't we check if emit() here and return true?
Why don't we check if emit() is called for every aggregation?
Includes not needed.
Minor: Might as well change this to final (if (o instanceof Status)
Experimental with the check for Stored?
Nitpick: could you please move the preference to an init() method and store it in s.
Nitpick: could you please move the preference to ss.like Objects.requireNonNull()?
Nitpick: could you please move the preference to an init() call?
space after "algebric"
This should be "algebric".
space after "algebric" and "operation"
are you sure? There are non-throwing cases.
are you sure? There are non-throwing cases, right?
are these two catch clauses correct? I'm thinking about them being merged. For example, org.junit.rules.ExpectedException rule = Throwables.expectException(Throwable)
We're abstracting accesses to _parallel property by moving related implementations to ParallelWrapper. Why don't you move this direct access to _parallel property to the class by adding like ParallelParams#copyIfNeeded(Config src, Config dst)?
We're abstracting accesses to _parallel property by moving related implementations to ParallelControl. Why don't you move this direct access to _parallel property to the class by adding like ParallelParams#copyIfNeeded(Config src, Config dst)?
We're abstracting accesses to _parallel property by moving related implementations to ParallelControl. Why don't you move this logic to Config class and use it here?
Can you replace this with our log messages?
Defensive copy-paste - do we have a reason for it?
Defensive copy-paste - do we have a reason for this?
Exceptions.propagateIfFatal(e) will be ignored here
Exceptions.propagateIfFatal(e);
Perhaps a new method on the JavaTypeDefinition?
I think this isChangingLocation(); @Override public boolean alterType(String s) { if (conf.getBoolean(ALTERLOCATION.getChars())) { return; } }
I think this isChangingLocation(); @Override public boolean alterType(String ENABLE_MANAGED_TABLES) { if (conf.getBoolean(ALTERLOCATION.getChars())) { return; }
I think this isChangingLocation() method is not required.
Any reason to not use Collections.emptyMap()?
Any reason to not use Collections#emptyMap()?
Any reason not to use Collections.emptyMap()?
Could throw exceptions.
Could return Flux.defer().
Could return Flux.defer()
Useless extra line
Useless extra line.
Useless extra line, we can avoid.
protected VdsServerWrapper(VDS vdsBroker()) and not vdsBroker()
protected VdsServerWrapper(VDS vdsBroker()) and not vdsBroker = vdsBroker.getHostName()
protected VdsServerWrapper
I'd prefer the following instead: String supervisors.merge(false, spec, false) { supervisors.merge(true); } catch (Exception e) { throw new supervisors.remove(id); }
I'd prefer the following instead: String supervisors.merge(false, spec, false) { supervisors.merge(true); } catch (Exception e) { throw new supervisors.propagate(e); }
I'd prefer the following instead: String supervisors.merge(false, spec, spec.getSupervisor())!= null
This looks like duplicate code (see above) could be in a common method.
This looks like duplicate code (see below) could be in a common method.
Consider refactoring this into a single method.
Why not just Optional.absent() or Optional.of(file)?
Why not just Optional.absent() or Optional.of(String)?
Why not just Optional<String>?
Are you sure that this is necessary? If not, perhaps just use the tooltip of the host name.
Why is this necessary?
Are you sure that this code can be removed?
Why not keep the try?
Why do we need to keep the try?
Why do we need to mark this as final?
It is just hard to parse one of the native code paths, which is not what you need in native code.
It is just hard to parse one of the native code paths, which is not what it is doing.
It is just hard to parse one of the native code paths.
initialize inline in line 38 and final
Can you add final modifier to make the code more obvious?
I would use final
There are checks for the usage of BatchFinderEntry in this class. Do we need a try/catch or something along those lines?
There are checks for the usage of BatchFinderEntry in this class. Do we need a copy here?
There are checks for the usage of BatchFinderEntry in this class. Do we need a new bean with @ClassRule here?
Is this a good idea to make the check more explicit?
Is this a good idea to make sure this gets called before every emit?
Is this a good idea to make the check in Brooklyn's thread safe?
Might be my math skills, but 5 + 20!= 35 ;-)
I think we can move the executor inside the if block. You only have the inited method.
I think we can move the executor inside the if block. You only have the initr.
Can this (and other instances of "Enter" code) be changed to trace level?
Can this (and other instances of "Enter", like in line 54)
Can this (and other instances of "Enter" code) be changed to trace level, like below?
I think it is a good idea to use the constant for the workspace instead of the name of the project.
I think it is a good idea to use the constant here.
I think it is a good idea to use the constant for the workspace instead of the name of the workspace.
shouldn't this be checked for null here?
shouldn't this be caught here?
shouldn't this be externalized?
BoxDto doesn't have a storageLocation, so this will be updated as it was before.
BoxDto doesn't have a storageLocation, so this needs to be changed.
You can use BoxDto without Dtos
Not every id record has an email address.
Not every id record has an email address. But if a mail address was matched, we fall through to the commit message.
Not every id record has an email address. But if a mail address was matched then we fall through to the commit message.
Curious: Why do you need to set this. I think in this case, when you are already calling the %1s above?
Curious: Why do you need to set this. I think in this case, when it is already set to null?
Curious: Why do you need to set this. in debug mode?
I don't think we need this extra empty line, it would have been enough to give no result.
I don't think we need this extra empty line, it would have been useful for other cases
I don't think we need this extra empty line, it would have been useful for other cases to give this.
Please add a check that it is not null.
nit: can you add braces here?
Please add a check that it's not empty.
Shouldnt entry be added to the actual label key?
Shouldnt entry be added to the map?
Shouldnt entry be added to the actual label key?
We should treating CONNECTED and throw the exception. This will also make sure that the application was interrupted.
We should probably log this error to notify.
We should treating CONNECTED and throw the exception. This would also make sure that the application was interrupted.
Can you make 3 a constant for the interval here too?
Can you make 3 a constant for the -1?
Can you make 3 a constant for the interval here?
I would remove this and keep the flow as it was before.
I do not see any reason for this: I would remove this and keep the flow as it was before.
I would remove this and keep the flow as it is.
nitpick: join these lines
nitpick: join these strings into constants
nit: join these lines
This is not correct. It should now be ">". And even more important.
This is not correct. It should now be List<String>, no?
This is not correct. It should now be ">". And later to do the same.
No need for monitor.done() here.
No need for monitor.done() in finally block
Mark with static imports
doesn't these methods create a byte array?
doesn't these methods create a private method?
doesn't it good to change these indents?
Missing curly braces.
Missing braces
Missing braces.
Causes ctf tests to fail
Causes ctf tests to fail.
Constants
why not use t.readLock().lock()?
why not use t as the parameter?
why not >=?
i think you can do something like java.filter(Objects::nonNull).findFirst().map(String::valueOf).filter(Objects::nonNull).findFirst().orElseThrow(() -> new AwsLoadBalancer(cloudLoadBalancer, value))
i think you can do something like java.filter(Objects::nonNull).findFirst().map(String::valueOf).filter(Objects::nonNull).findFirst().map(String::valueOf).collect(Collectors.toList());
i believe you can do something like java.filter(Objects::nonNull).findFirst().map(String::valueOf).filter(Objects::nonNull)
I would have thought that we could use isClassOrFunctionSymbol here, in order to have the conditions one level, one for each expression, and another for loop.
I would have thought that we could use isClassOrFunctionSymbol here, in order to have the conditions one level, one for each expression, and the other is static.
@ivandalbosco Why not just use ||?
Should you use "\n" here (and also at the error message before printing the "VmsList" variable), you might receive a more readable error, where each VM name was started.
Use getStoragePool().getId() also, the id remains the same between the 'old' DC and the 'new'
Should you use "\n" here (and also at the error message before printing the "VmsList" variable), you might receive a more readable error, where each VM name is printed on it.
I don't think we should have this System.out.print() (or System.err) here. Any reason for System.err is around here?
I don't think we should have this System.out.print() (or System.err) here. Any reason for System.err is not here?
I don't think we should have this System.out.print() (or System.err) here. Any reason for consistency?
Use component instead of this. this in this context will refer to the correct URL (which is what it needs to be).
Use component instead of this. this in this context will refer to the correct action bar, not the this.
Use component instead of this. this in this context will refer to the correct URL (which is what it needs to exist).
We should refactor out the try-with-resources block as well.
We should refactor out the logic to use a FileReader here
We should refactor out the try-with-resources block to avoid creating the map in the try clause
These are supposed to be debug-only and in other blocks. You may want to log the exception.
Shall we throw the exception (or log) instead of just logging the exception?
These are supposed to be debug-only and in other blocks.
I think I'd rather throw the IOException, so that we don't get the cause.
I think I'd rather throw the IOException, so that we don't get deal with the error.
I think I'd rather throw the IOException, so that we don't get the result.
Also the message here is wrong (e.g. Unable to get the old password for this component)
Also the message here is wrong (e.g. Unable to get the old password for this.
Also here applies the "try/finally" block.
What is the benefit of using constant for "disabled"?
What is the benefit of using constant "disabled"?
What is the benefit of using constant for the number of value?
![MAJOR](<LINK_1> Make "isSuppressWarningLines" a "static" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> Make "isSuppressWarning" a "static" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> Make "isSuppressWarning" a "static" method. [![rule](<LINK_2>](<LINK_0>
This change seems unrelated. Perhaps, extract it into a separate PR.
This method's logic appears to be an exact copy of serialize(Page page) except for slice = Slices.copyOf(slice); line. Would it make sense to extract this logic into a helper method and make a copy logic conditional on slice.isSlice()?
This method's logic appears to be an exact copy of serialize(Page page) except for slice = Slices.copyOf(slice); line. Would it make sense to extract this logic into a helper method and make a copy logic conditional on slice.isSlice() or have a boolean flag that tells whether the copy should occur or not?
Can you fix this so that webappPath returns a slash?
Can you replace this so that webappPath returns a Id?
Can you fix this so that webappPath returns a Id?
I don't think it makes sense to leave this inside the try. By the way, if the subquery is non-Query, then the query is marked as IncrementalIndex should be marked as io.
I don't think it makes sense to leave this inside the try. By the way, if the underlying query is not prepared, why do you need to pass it back?
I don't think it makes sense to add the exception to the caller.
typo in the variable.
double de-reference
typo in the variable name
I thought about it, but wanted to add brackets to make sure all of these ifs are redundant.
I thought about it, but wanted to add brackets to make sure all of the ifs are equal
I thought about it, but wanted to add brackets to make sure all of the ifs are redundant.
Please add more asserts on the second line.
Please add some asserts on the directory.
Please add some asserts ( interval.length == 2)
I would rather use the VdcActionUtils.canExecute(Arrays.asList(dcAction.class, VdcActionType.class), so the two checks are guaranteed to stay in sync.
I would rather use an anonymous class.
I would rather use an anonymous class here.
add fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
add fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)) here too
add assertion on the JobHelpers.xyViewerIsReadyCondition(chartViewer)
You have two onNexts of the same body as the one with the qualified name. If you want to use the lambda syntax for the project, we should be careful not to change the name.
You have two onNexts of the same body as the one with the compiler. This will cause the build to fail.
Please use the onNext function and then call onNext for the lambda. This will allow the compiler to get the error-prone.
Shall we use SharedSiteInstance here?
Shall we use assertj usage here?
Do we want to assert the content of the connection here?
better to log the uri here too
better to log the uri here as well
better to log the uri, I think
Can just return true if it's incoming and fall through to returning false.
Can just return true if it's incoming and fall through to returning true.
Can just return true if it is instanceof ITask.
don't we want to provide an actual name for the backend type?
don't we want to provide an actual name for the model?
don't we want to support this under the API version?
Typo: 'be'
Typo
static import
I think this change is unnecessary, since it is just a debug log
I think this change looks like a bad change in a few places.
I think this change is unnecessary, since it was just a debug log before
why not just return new TestMethodName()? Given the same TestHelper classesmycompany:
why not just return new TestMethodName()? Given the same TestHelper classesmycompany: <LINK_0>
why not just return new TestMethodName()? Given the same test with the same TestHelper classes :)
I think there's no need to copy the entry part of the array in order to compare it with DOT_GIT_ATTRIBUTES. Instead use RawParseUtil.match() to directly compare the entry name
I think there's no need to copy the entry part of the array in order to compare it with DOT_GIT_ATTRIBUTES... Please use RawParseUtil.match() instead.
I think there's no need to copy the entry part of the array in order to compare it with DOT_GIT_ATTRIBUTES. Instead use RawParseUtil.match() to directly compare the entry name.
Please use StringBuilder.
What's the replacement here?
Why using StringBuilder here?
What's the reason for this change?
What's the reason for marking all methods static?
What does this return?
Can we use!accountService.isAccess here?
Can we use Guava's Streams.stream().filter(_accountService::isAccess).map(Account::isAccess) instead of x.getType?
Can we use Guava's Streams.stream(accountService.get()) instead of the intermediate variable?
1. Why do we need it here?
It is not good practice to have different name like "CHE_WORKSPACE_ID" or "che.tools.api.cluster.name" as prefix
Looks like that line should be removed
What would happen if it is null? Seems like it would be an NPE.
What would happen if it is null? Seems like it would be a bad idea to log it.
What would happen if it is null?
Can you use Objects.hash() here?
Can you use Objects.hash()?
Can you use Objects.hashCode()?
Note that RDFParserRegistry already has a getter for RDFParser and to be initialized with the type you wanted to be able to support.
Note that RDFParserRegistry already has a getter for RDFParser and to be initialized with the type you wanted to check.
Note that RDFParserRegistry already has a getter for RDFParser and to be initialized with the type you wanted to be able to set its default.
I would prefer return commandLineFactory.getInstance().set(null).toString();
I think commandLineInstance() is an instance of this, so it is not needed for this, could be loaded as a field directly.
I would rather return void
don't think you need to append the index into the record itself?
don't think you need to append the index again?
don't think you need to append the index into the list?
Coinmarketcap ratesource is not the best name.
Should extract this line to a new method that returns the Coinmarketcap ratesource.
Coinmarketcap ratesource is always the best name.
I would compare with ==
I would merge this message with the new line.
I would merge this message with the else if
globalUnits?
global constant?
global variable name?
Use the xml / to create the fragments.
Use the HttpActivity#createLayout method instead of this
Use the HttpActivity.create() here instead of this
consider to consolidate into a single if block as both do the same, unless there is a particular reason
consider to consolidate into a method as both do the same, unless there is a particular reason.
consider to consolidate into a single if block as both do the same thing.
Does it make sense to remove the fully qualified name?
Does it make sense to remove the KafkaConsumer's class?
Does it make sense to remove the userSession.getPrincipalId() from the session?
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
I think this can throw if there are no principals. It should probably have an explicit check to throw a proper error message
Again, this can throw if there are no principals. It should probably have an explicit check to throw a proper error message
Can you change this? This isn't really what is causing the listeners to be used in the current code. Why is this needed?
Can you change this? This isn't really related to the bug that related to this change.
Can you change this? This isn't really what is causing the listeners to be used in the current code.
update to update as well
update to update the expected value.
update to update the expected value instead?
We don't have to create new VO from a VO, just cast it to Privilege Exception. You can get richMembers on this specific case.
We don't have to create new VO from a VO, just cast it to Privilege Exception.
Please add method checkGroupIsExistsException and throw InternalErrorException.
does this constructor need to also add edges, if present -- or is that somehow taken care of?
should this be vector.getValue()?
does this constructor need to also add edges?
Shouldn't we use RtlAwareTextView as a child?
Shouldn't this be (and a few lines below)
Shouldn't this be (and a few lines down)
Please use the method reference order of assertBuildPlan
Please use the new method.
Please use the method reference order of assertBuildPlan and buildBuildPlan.
it seems that this could use the builder directly
can use null?
I would use the builder here instead of the value that takes a string
I think we should check if empty or whitespace only if there is whitespace only in the text.
I think we should check the GPU resource only if there is no GPU.
I think we should check if empty or whitespace only if there are GPUs in the second execution?
nit: this is statically imported so it's not likely to be used over time.
minor: this is statically imported so it's not likely to be used in tests.
minor: this is statically imported so it's not likely to be used to mock the time.
This will cause the second parameter to be null.
This will cause the second argument to this method.
This will cause the second parameter to be null, right?
I think it was possible to rewrite it with cipherSuite() using the proper resolveCipher method
I think it was possible to rewrite it with cipherSuiteProvider.getCipher(cipherSuite) (which can be null) instead.
I think it was possible to rewrite it with cipherSuiteProvider.getCipher(cipherSuite) instead.
We can consider adding this value to QueryServicesOptions.STATS_INVALID_ROW_NAME_FOR_PARALLELIATION.toString() and this.duration.toString() call below.
We can consider adding this value to QueryServicesOptions.STATS_INVALID_ROW_NAME_FOR_PARALLELIATION and IB_ENABLED_ATTRIB.toString()
We can consider making this value a constant.
This method makes the code more readable, so I would extract the identical call to a method returning "featureState.getFeatureState(featureState)".
This method will remove the duplication of the changed code.
This method makes the code more readable, so I would extract the identical call to a method.
fValue
fValue() can be null
fValue?
Isn't this already a Long?
Isn't this the same as the one above?
Isn't this just a duplicate?
We could simplify this to: if (a.equals(m.getFullName())) { return null; } // We don't need the else branch.
You can insert an empty group if the group is null.
We could simplify this to: if (a.equals(m.getFullName())) { return null; }
What about currentUser.getObjectId() instead of currentUser.getObjectId()?
What about currentUser.getObjectId().equals( userId )?
What about currentUser.getObjectId() instead of currentUser.getObjectId()?
ss.getStart / ss.getCurrentEndTime
ss.getCurrentEndTime
few
Do we really need this? Can't we just create auth auth once and reuse it?
Do we need this? Can't we just create the auth class in the close method?
Do we really need this? Can't we just create auth auth once we have it?
IMO it's better to iterate over the rules instead of looping over the rule names.
IMO it's better to iterate over the rules instead of looping over the rule and then iterate over them to remove the more inefficient than the existing list.
IMO it's better to iterate over the rules instead of looping over the rule and then iterate over them to remove the final results later on.
nit: could we reuse basePanelPreferences.prefs?
nit: can we reuse this?
Could we reuse basePanelPreferences.prefs?
@Christopher-Chianelli that's not the case since it is currently written in Druid, and I think this is what we mean. Can you please clarify?
@Christopher-Chianelli that's not the case since it is currently written in Druid, and I think this is what we mean. Can you please review the code style please?
@Christopher-Chianelli that's not the case since it is currently written in Druid, and I think this is what we mean. Can you please review the code style guide to see what getInterval is chosen?
Only source.getAttempts should return the date or the current value. For all, the end, are using the timestamp from the db. You need to add a new method VoneOffset.UTC.
Only source.getAttempts should return the date or the current value. For all, the end, are using the timestamp from the db. You need to take a look at the source code that starts with.
Only source and destination is not null
Add newline before return.
Add newline before return?
Add newline before return
Should this throw an exception instead?
throw new IllegalArgumentException("Unknown access mode: " + mode);
Should this throw an exception instead of returning null?
This 'else' branch is unnecessary, the return after 'if' returns.
This 'else' branch is unnecessary, you are not updating more than once
This Wondering what it is doing before, but it might be bad to keep it in getEntity() and make a new method
Isn't this the same as the one above?
Isn't this the same as the one used for IndexTool?
Isn't this the same as the one above? maybe a warn?
I wonder if we could end up with some issue, having bean.defaultOutputChannel() and the interceptorRunner in the same case. I'd say that we really should move these logic out of the if (LOG.isDebugEnabled()) {... } block and remove the check in the else clause.
I wonder if we could end up with some issue, having bean.defaultOutputChannel() and the interceptorRunner in the same case. I'd say that we really should move these logic out of the if (LOG.isDebugEnabled()) {... } block.
I wonder if we could end up with some issue, having bean.defaultOutputChannel() and the interceptorRunner in the same case. I'd say that we really should move these logic out of the if (should be in the else block).
same here - the length should be updated to take into account the sequence
same here - the length should be updated to take into account the offset
same here - the length should be set instead of offset
log.error.
Math.max
need to handle the exceptions properly
This could be a List<String>.
This could be a huge performance improvement, since it would make the code shorter and more readable.
This could be a huge performance improvement, because it would make the code shorter and more readable.
please use a static import for explicit methods
please use a static import
please use a static import for this
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames.size() and removedNetworks.size() to variable so it's not calculated multiple times.
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames.size() and removedNetworkAttachments.size() to variable so it's not calculated multiple times.
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames and removedNetworkAttachments.size() to variable so it's not calculated multiple times.
double check that no group has been created
again double check that no group has been created
double check that the group hasn't been created
These are the same assertions, would be good to put them into the test 111 :)
These are the same assertions, would be good to put them in the test 111 :)
These are the same assertions, would be good to put them in the test?
Pull out
Pull out.
Pull out of this method.
make BUCK a constant
make BUCK a constant so it does not need to be changed.
make BUCK a constant.
nit: could use "this" here.
nit: "arrange".equals(passwordSpec) instead of "arrange" - "p."
nit: "arrange".equals(passwordSpec)
isEmpty()
// not sure about the best name. If you sort the data contains a space, you can do a isEmpty check.
isEmpty
this is now wrong - we should not check for null. Just call.call()
this is now wrong - we should not check for null squashed by commit
indexHistory
this seems like an unnecessary step - let the factory take care of this.
this seems like an unnecessary step - let the factory do it or better yet, throw an exception?
this seems like an exception.
The 'lun' option should be used instead of 'lun'
The 'lun' interface should be used also here.
The 'lun' option should be used instead of 'unns'
@HorizontalPanels should not be removed.
@HorizontalPanels, please make sure they don't have to be removed.
@HorizontalPanels, please make sure they don't have to be removed?
please move this check to service level
please move this check to method parameter and change it in API
please move this check to method parameter and use string
Depending on what you want to call this table unlock, you should just call 'write(tupleWriter);
Depending on what you want to call this table unlock, you should just call _that_ exception.
Depending on what you want to just call this tableWriter.write(tupleWriter);
I wonder if this should be WorkbenchHandler.getWorkbenchMessages()
Can this be extracted in a method?
I wonder if this should be Workbench.getWorkbenchMessages()
This need to be set in the CSS
This need to be set in the button
This need to be changed.
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback being completed to rely on the callback being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback to be completed to rely on the callback being handled in this kind of manner. (sorry, clicked enter too soon)
public static? Is that keyword ordering important in this codebase?
public static? Is that keyword ordering important in this codebase? I don't think this is a good idea.
public static
We could use CacheContainer#isComparableTo() here, and make ValueMap a bit easier to build it in a separate class.
We could use CacheContainer#isComparableTo() here, and make CacheContainerCacheContainer not implement that. The CacheContainer is supposed to do that.
We could use CacheContainer#isAsync() for null argument.
Can you make a method like this to be a non-static method?
You can use try with resources here for convenience.
You can use try with resources here.
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null? Or empty string?
Did you check here if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
Can these be moved to the next line?
What is the output of this? Should the string be changed?
What is the output of this exception? Should the message be ss?
@original-brownbear can you just set clone() and set clone(), so you don't have to use clone()
@original-brownbear can you just set clone() and set clone()?
@original-brownbear isn't it just not set two separate fields?
Not sure what this test is doing. If we want this to be a String, I think we should leave it ;)
Not sure what this test is doing. If we want this to be a String, I think we should leave it, unless there is a reason it shouldn't be a String.
Not sure why this is necessary
should be debug
Log message should be debug
Log method should be debug
should update currentEvent in the loop?
should update currentEvent to use index instead of index
should update currentEvent to be updated here?
Shouldn't we avoid the asset keyword? Are we sure that Eclipse is started with the -ea switch?
Shouldn't we avoid the asset keyword? Are we sure that Eclipse is started with the -ea switch? If yes, then we should avoid the asset keyword
Why do we need the asset keyword? Are we sure that Eclipse is started with the -ea switch?
@bxf12315 you could have a method that returns EmbeddedHostHandlers and use it to pass the ActiveTask to the constructor.
@bxf12315 you could introduce a method that returns EmbeddedHostHandlers and have its own AutoCloseable interface.
@bxf12315 you could have a method that returns EmbeddedHostHandlers and use it to pass the ActiveHost directly to the constructor.
Is that intentional to remove check for dhg.getDomainName() is null.
can't you use constants.empty() here as well?
Is that intentional to remove check as well?
Hi. Could you please use {}?
delete your space.
Remove temporary directory.
I don't think that's a good idea to make the test more reliable by a visitor that contains the rules.
I don't think that's a good idea to make this more reliable by a visitor that contains the rules.
I don't think that's a good idea to make the test more reliable by a visitor that contains the rules (i.e. order to avoid creation of locations where it fails).
I would replace this if-else with ternary statements to make it shorter. but that's a matter of style - so just consider it
I would replace this if-else with ternary statements to make it shorter. but that's not a big deal.
I would replace this if-else with ternary statements to make it shorter. but that's a matter of taste - so just consider it
Use slf4j instead of String.class, also, we should probably use ((String) null).toString() instead of String.class
Use slf4j instead of String.class, also in case we need to provide a simpler stack trace.
Use slf4j instead of String.class, also, we should probably use ((String) null).toString() instead of toString() to provide proper stack trace
This is not quite right. You need to create a new ArrayList here and do everything in the next line.
This is probably not needed at all if it is a translated message.
This is probably not needed at all if it is one looper
Haven't we already check for blank blob here?
Have you checked that this method is called with a BlobInfo rather than a String?
Consider using Framework.getService here.
nit: why not assertAllExchangesAreCompleted(coaps1);?
nit: why not assertAllExchangesAreCompleted(coapTestEndpoint.class)
nit: why not declare mAllExchanges in createEndpoint?
Perhaps a good idea to change the "now" to "last_scan_submit" as well?
Perhaps a good idea to change the "now" to "last_scan_"?
Perhaps a good idea to change the "now" to "last_scan_"?
newObjectReader(out); and new StringBuilder(toEditList()).append("\n");
new ObjectReader(out); and new StringBuilder(toEdit.getNewName(), filename);
newObjectReader(out); and new StringBuilder(toEdit.getNewName(), filename);
Is there any way to not use StringUtils.join() or directly in the if?
Is there any way to not use StringUtils.format() or directly in the if?
Is there any way to simplify this logic?
Optional: use StringBuilder here.
Optional: use StringBuilder.append(repo).append(timestamp)
Optional: use StringBuilder.
I would rather use a constant for these booleans, for example: java if (cache == null) { cache = new ProtoStreamMarshaller(); }
I would rather use a constant for these booleans, for example: java if(cache == null) { cache = new ProtoStreamMarshaller(); }
I would rather use a constant for these caches, for brevity.
nit: Use requireNonNull.
nit: Use toImmutableList
Use toImmutableList
Can be reduced to a constant?
Can be reduced to a Set<String>, since now that the type is configurable.
Can be reduced to a Set<String>, since now that the type is unused.
I am not sure if this is the correct behaviour. the getId() call is returned here. and in the previous version of equals() wouldn't work..
I am not sure if this is the correct behaviour. the getId() call is returned here. and in the previous version of equals() wouldn't work.
can we have a more descriptive name here?
Could we keep this method on one line? It doesn't seem to exceed recommended length of the line.
Could we keep this one line? It doesn't seem to exceed recommended length of the line.
Could we keep this method on one line? It doesn't seem to exceed recommended length of the line :)
@vzool, i think this log message should be removed to release the lock.
@vzool, i think this should be release()
Typo here, release lock should be in lock.
same here for server.getClientID()
you can do this for each connection get.. you want to do this separately
you can do this for each connection get.. you have a map with every connection
can you use msgClazz == NettyMessage.AddBacklog? ifremoteAddr is a boolean then you can use boolean returned by method.
can you use msgClazz == NettyMessage.AddBacklog?
can you use msgClazz == NettyMessage.AddBacklog? ifremoteAddr is a boolean then you can use return type.
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IllegalArgumentException if there are any problems deleting {@code location}. */ private void delete(Path location) throws IOException { if (location.notExists(location)) { throw new IllegalArgumentException("Could not delete " + location); } } Would this implementation do the same thing?
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IOException if there are any problems deleting {@code location}. */ private void delete(Path location) throws IOException { if (location.notExists(location)) { throw new IllegalArgumentException("Could not delete " + location); } } Would this implementation do the same thing?
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IllegalArgumentException if there are any problems deleting {@code location}. */ private void delete(Path location) throws IOException { if (location.exists() &&!FileUtils.notExists(location)) { throw new IllegalArgumentException("Could not delete " + location); } } Would this method work?
You will have to check if complexTypeMetadata is null here.
You may create a static method which calls complexType.getString() here.
You may create a static method which complexTypeMetadata here.
The same here, you can use new ArrayList<>(selectedEvents.getOutputEvents());
The same here, you can use new ArrayList<>()
The same here, you can use new ArrayList<>(selectedEvents).
please change this to 'clusterState' instead of 'clusterState'
please change this to warn
please change this to 'clusterState'
I would change this to: java exportPageHeaders = pageHeaderWithOffsets.getDictionarySize();
I think it is better to use: java if (readPage!= null) { encodings = new ArrayList<>() } else {... }
I think it is better to use: java if (readPage!= null) { encodings = new ArrayList<>(Arrays.asList(getPos, encodings)); } else {... }
The common logic can be moved out. I would suggest to extend both RemoveBrickStatus and RebalanceStatus from a common class
Shouldnt we return VDSReturnValue itself here? If some exception, succedded flag is set to false, else getTaskId is set to null
Shouldnt we return VDSReturnValue itself here? Maybe we should unset the status
Should we use try-with-resources here?
Should we use try-with-resources here as well?
Do we really need a separate try-catch-block? Can we use try-with-resources here?
2 or 3?
2 or 3? Or are we ok with both?
2 or 3? Or are you multiple failed?
Move this method down to the overridden method?
Move this method down to the overridden method.
Change this method to package local.
didn't we have to set this to false as well?
didn't we have to set this to true as well?
didn't we have to clean up this variable as well?
Looks like a copy/paste error
Looks like a copy/paste error. I would recommend to wrap this in a try-with-resources
Looks like the copy-paste error is not needed
Incorrect indentation.
Typo: space
Nice idea.
without **a** 'MessageHandler'.
without **a** 'MessageHandler'?
**a** 'MessageHandler'.
Is this change due to a specific behaviour? Maybe it's okay to have a test when this happens?
Is this change due to a specific behaviour?
Is this change due to a specific implementation of this page?
Iterables.filter(fEntries, CounterTreeViewerEntry.class)
Iterables.filter(fEntries, CounterTreeViewerEntry::isCumulative)
Iterables.filter(filterEntries, CounterTreeViewerEntry.class)
You added a parameter but this command is also used from other places, so this will cause compilation failures.
You added a parameter but this command is also used by other places, so this will cause compilation failures.
You added a parameter but this command is also used from other places, so this one can be removed.
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to null.
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to null by the state system.
Shouldn't use t=0
There are a few issues with this: 1. You need to compare the idenitifiedUser with all change. 2. It only fails if the change is in the PatchSetApproval. If the user has to deal with it with another user, it should be fine. There are also other issues with this coding style in this file that I can see.
There are a few issues with this: 1. You need to compare the idenitifiedUser with all change. 2. It only fails if the change is in the PatchSetApproval.
There are a few issues with this: 1. You need to compare the idenitifiedUser with all change. 2. It only fails if the change is in the PatchSetApproval. If the user has to deal with it with another user, it should be fine. There are a few different patches that can't be the same because the idenit stores it.
This method seems to be used also.
This method seems to be used only.
This method seems to be used a lot.
I guess you can use Collections.emptyMap() instead of the if-else statement
I'd use Collections.emptyMap() instead of the if-else statement
I'd use Collections.emptyMap() instead
I think.findFirst() is safer here
I think.findFirst() is more readable.
I think.findFirst() is safer here than calling.orElse(null).
Minor typo in unrecognizedFS
Minor typo in variable name; should be malicious
Minor typo in variable name.
After rebasing with master branch, this will cause NPE.
Rename "refresh" to "partitions".
We may want to return replication not enabled for "location"
I think if you move this statement inside the try block, you don't need to catch it
I think if you move this statement inside the try block, you don't need it
I think if you move this statement to a separate method and call it twice in this class, can we make it a one line?
change to LOG.info
change to LOG.out
use LOG.info
The second condition should be: if (attribute == null ||!attribute.getName().isEmpty())
An ArrayList would be faster than List<Attribute>
An ArrayList would be faster than a List.
As it is currently written, stripe.add(stripeIdx) will have no effect.
As it is currently written, stripe never used.
As it is currently written, stripe.add(stripeIdx); will do the trick.
please useCharArrayUtils.EMPTY_LIST
please useCharArrayUtils.EMPTY_STRING instead.
please useCharArrayUtils.EMPTY_STRING instead
You can do away with the added complexity of a negative check in both if and else.
I think you can do away with the added complexity of a negative check in this method.
I think you can do away with the added complexity of a negative check on the config flag, something like: if (!isReconfigEnabled()) {
The name should probably be 'dc' and the others.
The name should be 'custom'
The name should probably be "custom" or "Rpc"
initializeDisksAndReplicasOnNode is always used for this, we can remove it.
initializeDisksAndReplicasOnNode is the same as getSslPort below, which can be quite long.
initializeDisksAndReplicaIds is the same as getSslPort, which can be quite expensive.
extract method
line breaks after PMD
add parameter
Can you please use ProjectUtils.createRelBuilder(RelBuilder.INSTANCE, traits, rel, maybe?
Can you please use input.getTraitSet(Rel.INSTANCE, rel, null) instead of +
Can you please use ProjectUtils.createRelBuilder(RelBuilder, input, rel, child, rel, etc)?
should we use the object avro() instead of Boolean?
should we use the object avro() here?
should we use the object avro() instead of null?
suggestion List<Completion> list = new ArrayList<>();
suggestion ArrayList<Completion> list = new ArrayList<>();
suggestion List<Completion> list = new ArrayList<>(getInstanceService);
@d-molotchko reference the test. You can use assertEquals instead of assertEquals.
@dalifreire let's test the condition instead of 0.00000133
@d-molotchko reference the test instead of assertTrue.
Yes, I agree. Done.
Static import from VersionKeys and parameter.
Yes, I see.
isEmpty()?
Let's collapse these two lines into a single method.
Let's collapse these two lines into a single statement.
Even this is not necessary. This is not really hiding anything.
Even this is not necessary. This is really hiding anything.
Even this is not necessary. This is hiding only the instructor which has instructor, and no need to react to it.
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the file is empty
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the file is being set to the empty name.
wrap
This is the same as the one above except for the PR, but could you please move this to a common method?
This is the same as the one above except for the PR, but could you please move this to a separate method?
This is the same as the one above except for the PR where we should move this logic to CommCareApplication._(). Could you please describe what the issue is that you are trying to do?
@ptirador why you dropped it?
@ptirador why can't it be /pulls/usage/pulls/?
@ptirador why you dropped it? this.request.coordinates().
Is that okay that we wipe out the state manager, in which we would flush the stores and then close them? Would any exception be thrown?
Use TaskType.STANDBY.
TaskType.STANDBY.
:pencil2: You can remove the cast to ((OpenAttributes) util.getMetacardsByFilter(ATTRIBUTE_TEMPLATE_TAG)) below.
:pencil2: You can remove the cast to ((OpenAttributes) : util.List(SecurityAttributes.ACCESS_INDIVID)).map(Result::getMetacardsByFilter);
Can be removed.
Arrays.asList(modelEntry.getKey()).collect
Arrays.asList(modelEntry.getKey()).
Arrays.asList() should work here
Why don't you use Guava's Throwables.propagate() here? Is it possible to use Guava's Throwables.propagate() directly?
Why don't you use Guava's Throwables.propagate() here? It would be a bit more clear if the exception was thrown before the concatenation.
Why don't you use Guava's Throwables.propagate() here?
Make the method static - it is only used in 1 place
Make the method static - it is only used in classes and not the class
Make the method static
A lot more vals please
A lot more vals I believe
A lot more vals please :-)
nit: The only issue I see is that the surrounding if-else branch doesn't have the same effect as the one above in this file.
nit: The only issue I see is that the surrounding if-else branch doesn't need the else block.
nit: The only issue I see is that the surrounding if-else branch doesn't need to be changed since the conditionals are the same.
I'm not sure about this, will it have the timeout on top of the test? Also, wouldn't it make sense to use LeaderElection.shutdown() in this test?
I'm not sure about this, will it have the timeout on top of the test? Also, wouldn't it make sense to use a timeout like LeaderElection.shutdown() somewhere?
I'm not sure about this, will it have the timeout on top of the test? Also, wouldn't it make sense to use a timeout like Awaitility?
@tsurdilo You can use here rather asserting HTTP status code, expectedHttpCode, actualHttpCode, expectedHttpCode, actualHttpCode, expected
@tsurdilo You can use here rather asserting HTTP status code, expectedHttpCode, actualHttpCode, expectedHttpCode, actualHttpCode, expected Status
@tsurdilo You can use here rather asserting HTTP status code, expectedHttpCode, actualReleaseId and expectedHttpCode.
Define the strings in a constant or have it in one place.
path.flow.className.getString("azkaban.flow.flow.flow.txt") in both lines of code
path.flow.className.getString("azkaban.flow.flow.flow.b") in both lines of code
Should be : new ResourceManager(args[current].equals(args[0]))
Should be : new ResourceManager(args[current].equals(args[0]))?
Should be a good idea to use File.separator.
This is impossible, blockLength is an int.
That is impossible, blockLength is an int.
This is impossible. blockLength is an int.
Why did you add this parameter? It always has the exact same value as the other. So maybe just drop it?
Why did you add this parameter? It always has the exact same value as the other. So maybe just drop it?
Why did you add this parameter? It always has the exact same value in validateValue(). So maybe just drop it?
If we change this to return value from jobModelSegmentKey, then we don't need to change this variable to something like: String jobModel = jobModel.get(jobModel);
If we change this to return value from jobModelSegmentKey, then we don't need to change the order.
If we change this to return value from jobModelSegmentKey, then we don't need to change this variable to storeModelSegmentKey.
s/getMessage/get
s/result/getMessage/
Missing generics on ArrayList.
Is this equivalent to org.ovirt.engine.core.common.businessentities.OsType#Other?
Is this equivalent to org.ovirt.engine.core.common.businessentities.OsType#Other?
Is this equivalent to org.ovirt.engine.core.compat.businessentities.OsType#Other?
What does the race condition here? Aren't we still skipping the access token lookup even it's still valid?
What is the purpose of catching the IOException here? Aren't we still doing it for other reasons?
What is the purpose of catching the IOException here?
suggestion mounted.getType().log(Site#getType(), AmmoType.toString());
suggestion MekHQ.getLogger().log(Level.WARNING, "Player other has invalid ammo bin at [A time]: <LINK_0>");
suggestion MekHQ.getLogger().log(Level.WARNING, "Player other has invalid ammo bin at [A,N,B]: mounted.getType().log(Level.WARNING, "Player other has invalid ammo bin at [A,N]. Not mounted");
There's no locking on this? Also, isn't this the functionality you wanted in the Facade layer?
There's no locking on this? Also. isn't this the functionality you wanted in the Facade layer?
There's no locking on this?
I would suggest not to call init here, as Crashlytics didn't have a null check.
I would suggest not to call init here, as this method is called in initBugShaker
I would move this logic to Crashlytics.setMinimumLoggingLevel(getApplicationContext, "onCreate") and remove this logic.
is there a reason why this is public?
More efficient than Arrays.asList(). It is faster
is it correct?
I'd like to be more explicit then we should catch the SSLSocketException here, and wrap it with the message in the exception (it will be thrown by the new code).
I'd like to be more explicit then we should catch the SSLSocketException here, and cast to the implementation. Remove this catch and change the message from the exception.
I'd like to be more explicit then we should catch the SSLSocketException here, and cast to the implementation. Remove this catch and change the message from the exception to SSLSocketException.
Does it make sense to print m_response?
Does it make sense to print table names instead of system property?
Does it make sense to print the message instead of its contents?
Maybe it's better to put the "if ( extras!= null) into a local variable to avoid repeated multiple times.
Maybe it's better to put the "if ( extras!= null) into a local variable to avoid repeated multiple times?
Maybe it's better to put the "if ( extras!= null) into a local variable to avoid duplication?
should we log something if we are traversing a tree?
can you use tracef here too?
should we log something at the end of the job?
You can do:.map(this::getGoal, payload).filter(event ->!getGoals().isEmpty()).findAny().ifPresent(payload -> { if (now.getRelatedLoginID().equals(minEndTime)) { return message; } }).collect(Collectors.toList());
You can do:.map(this::getGoal, payload).filter(Event ->!TextUtils.isEmpty(minEndTime)).map(MessageDestination::getGoal).orElse(null);
You can do:.map(payload -> getGoals()).filter(event ->!getGoals().isEmpty()).findFirst().orElse(null);
Does this mean that we are not throwing an exception?
Does this log just throw a exception?
Does this mean that we would still log the first offset?
If the intention was to add anything to the scores of the ProjectData, you are just adding the disk from the list to the ProjectData.
If the intention was to add anything to the scores of the ProjectData, you are only adding the disk to the ProjectData.
If the intention was to add anything to the scores of the ProjectData, you are just adding the disk from the cache. Do you have any thought?
Don't we need to hold onto the result of FileSystem.create() here? Ditto..
Don't we need to hold onto the result of FileSystem.create() here? Ditto for any other other exception.
Don't we need to hold onto the result of FileSystem.create()? This is a closeable FileSystem object, and it seems like it would be a bad thing to do.
make this final I think
make this final I don't think it should be final
make this final
what's the purpose of this comparison? RefFilter doesn't have any object.
what's the purpose of this comparison? RefFilter doesn't have to be modified either, just refs.
what's the purpose of this comparison? RefFilter doesn't have to be created manually, why aren't they initializing the repo?
It's not safe to return a DoubleArray.of(strikes) directly, so no need to wrap the result to double.
It's not safe to return a DoubleArray.of(strikes) directly, so no need to do the same lookup.
It's not safe to return a DoubleArray.of(strikes) directly, so no need to wrap the whole thing.
I think the expression could just be replaced with throw new IllegalArgumentException("Poorly configured permission '" + annotationClass.getName() + "'");
I think the expression could just be replaced with : throw new IllegalArgumentException("Poorly configured permission '" + annotationClass, e);
I think the expression could just be replaced with throw new IllegalArgumentException("Poorly configured permission '" + annotationClass, e);
missing space after if
missing space between if and (
missing space before if
having a timeout here is good for other methods. If you know how many operations are performed, do you know there's no timeout?
having a timeout here is good for other methods. If you know how many operations are performed, do you know there is an inn of these methods?
typo
Multiple 'if' and'return' statement on the same line.
Multiple 'if' and'return null'.
Multiple 'if' statement makes it hard to understand what's going on.
Instead of calling this method here, you could create a private method that returns this collection.
Instead of calling this method here, you could create a private method that returns an array of found items.
Instead of calling this method here, you could create a private getDefaultXmlValue() method that returns an empty collection.
This message should be "Cannot partitioner."
We're checking for null.
This message should be "Cannot partition on {} does not match partitioner"
I think its better to return at this point (and to keep the function signature in a local variable) before calling it again.
I think its better to create a local variable here - it is not used and there is no need to create a list from the database
I think its better to return at this point
Nit: can we define a variable for this?
Nit: can we define a final variable for this?
Nit: can you define a variable for this?
change to Log.error
change to log.error
space
does  consume() do anything? It's not efficient to create a new byte array.
does Payload need to be re-used?
does Payload need to be rebased on the interface?
These strings can be extracted as constants.
These strings can be extracted a constant.
These strings can be put in constants.
This test doesn't seem to validate anything.
This test case seems excessive.
This test doesn't seem to validate the unsorted table.
Can you put this on one line?
Please revert this change.
Can you put "break" in a variable?
Could we include just the expected value in the exception?
Could we include the expected value in the exception?
Could we include these in the exception message?
If there is an enum that does not have to be compared with ==, so we should simplify this code.
If there is no ProjectState in the cache, this field is declared in the constructor.
If there is an enum that does not have to be compared with ==, we should be using equals().
any reason not to use diamond operator?
any code that sets quarantinedBookies to bookies?
any code that sets quarantinedBookies's default?
We should remove this.
We should remove this. The catch block can be removed.
We should remove this. The catch block is not needed.
Shall we move this to a setUp method and keep the diff lines of code a bit more concise?
Shall we move this code to a setUp like in the other files?
Shall we move this logic to a setUp like in the other files?
I'm not sure if we need this. I think that there's a failure reporting which would need to be updated.
I'm not sure if we need this. I think that there's a failure reporting which would need to be updated. Run this command for you.
I'm not sure if we need this. I think that there's a failure reporting which people might need to do in a different thread, and this may end up running multiple times.
Shouldn't these be done when start/stop polling? It looks like the deviceReductionReductionReduction should also be available.
Shouldn't these be done when start/stop polling? It looks like the deviceReductionReductionReduction should be defined as a specific method.
Shouldn't these be done when start/stop polling? It looks like the deviceReductionReductionReduction should be defined as a default.
We can probably refactor this to be a private method that takes a KieSession and a parameter.
We can probably replace this with RuntimeException (if you are dealing with a catch block).
We can probably replace this with RuntimeException
use.anyMatch() instead of filter()
use.anyMatch()
addLDAPRole
Let's use the replacement as described above.
Let's use the configuration you want to check if the value is valid.
Let's use the placeholder for the exception message. Also needs the space after the comma.
Catching Throwable would be a bit nervous.
Failed do nothing but throw IOException?
Failed do nothing
You can use the logger instead of this.
You can reduce this to debug
You can use the logger instead of System.out
Check how this looks in landscape mode
This can be static
This is in the wrong way of formatting
Do we need to check if input is null?
Do we need a special case for evaluator parameters?
Do we need a special case for evaluator?
This value should be read from the UI in the layer.
This value should be read from the Constants class.
This should be final.
There is no need to create a new configuration here. If you want to be able to create the configuration via properties updateCallback, you could just return properties.forEach((ConfigurationManager) properties.add(ConfigurationManager.PROTOCOL, new configuration());
There is no need to create a new configuration here. If you want to be able to create the configuration via properties updateCallback, you could just return properties.forEach((ConfigurationManager) properties.add(ConfigurationManager.PROTOCOL, new configuration);
There is no need to create a new configuration here. If you want to be able to create the configuration via properties updateCallback, you could just return properties.putAll(properties);
The following part can be moved out of the synchronized block.
The following part can be moved out of the synchronized block: if (connectionChanged) {... }
The following part can be moved out of the synchronized block: if (connection!= null) { ConnectionState.isInMemoryConnection(staleConnection); }
After trying it, we would prefer that the black highlighting would be drawn with two lines. The reason is that when the'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y, rect.y + rect.width, rect.y + rect.height, rect.width); Or I guess alternatively you could draw the highlighting rectangle first then fill the state color which would overwrite the left and right edges...
I suggest we store the black Color as a static final constant.
I suggest we store this as a static final constant.
This is not an issue, but if you wanted to avoid strange name then can you change it to something like quartzTrigger.withJobData(jobIdentity).build()
This is not an issue, but if you wanted to avoid strange name then can you change it to something like: jobIdentity.equals("midnight")
This is not an issue, but if you wanted to avoid strange name, can you change it to something like: jobIdentity.equals("midnight")
Null check?
Null check
Null here?
Can we move this logic to a separate method?
Can we move this logic to a common place?
Can we move this logic to the builder itself?
maybe you could move this logic to a separate method
maybe you could move this into a separate method
maybe you could move this to a common place like checkDynamic
What if host and port are null? Shouldn't we throw an exception?
What if host is null? Shouldn't we throw an exception?
What if host and port are null? Shouldn't we keep the check?
This processing should be done before instantiating the aggregator, right?
This processing should be done before parse() if it's not present.
This is not thread safe.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a little more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variables / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
if you're not checking for this outside of the loop, it's hard to read. IMHO
Same as above. IMHO it's easier to read.
Please remove the else
Can you add project name to the subject?
Can you add project name (see the ticket description) to the subject?
Can you add project name (see line 58) to the subject?
Can logEntries be used instead of TRACE
Can logEntries be used instead of TRACE()
Can logEntries be used here?
should make sure error messages are consistent.
should make sure strings are consistent (see org.eclipse.core.runtime.system.core.system.core.system.service.system.core.model.Extension files).
should make protected.
We cannot assume all the DSpaceObject is the thing being indexed. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
We cannot assume all the DSpaceObject is the thing we want to update. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
Unnecessary braces
This is catching the exception and returning null is bad practice. What is the difference with catching the exception and ignoring it?
This is catching the exception and returning null is bad practice. What is the difference with throwing an exception here?
This is out of scope of this PR but looking at this PR made a lot of the cleanup to check if necessary, as you can check what is done in catch block also. What is the point of catching and ignoring the exception here?
explain this
explain this one
explain this TODO
It's also possible to test that IDENTITY_MAPPING is used, and indeed SESSION_ID should be added to the new one
Typo, should be _returned_.
It's also possible to test that IDENTITY_MAPPING is used, and indeed SESSION_ID should be added in the new code
flip the two?
flip the condition
flip the logic here?
I believe it's easy to have a suggestion for (final String amount : part.getSellValue()) {
I believe it's easy to have a suggestion for (int i = 0; i < parts.size(); i++) {
I believe it's easy to have a suggestion for (final String amount : part.getSellValue() {.. }
You can change the variable name as well
You can change the variable name as well since you use the variable for index
You can save some typing here
Change to DIO Line.
Change to DMLIO Line.
Change to DMLIO
Should it be a little bit clearer to just use isPrivileges(Collections.singleton(ace.getName()) here?
Should the check be moved to isPrivileges() method?
Should the change to isPrivileges(Collections.singleton(ace.getName())) here?
I'd split this into two methods. One for example:.getArguments().getOrderBy().getOrderBy().ifPresent(expression -> {... });
I think this could be simplified using filter instead of ifPresent.
I think this could be simplified by using filter instead of ifPresent.
Use EMPTY_ADDRESS and not null.
Use EMPTY_ARRAY and EMPTY_OBJECT_ARRAY
Use EMPTY_ARRAY
Braces are missing
Missing generics
524 * 2
missing a finally block?
missing a space after "schema"
missing a space after "equals"
this variable can be declared on line 51, maybe in could be more concise
this variable can be declared on line 51, maybe it should be declared somewhere
this variable can be declared on line 229
You must check only when player is null.
You must check owner of two gattlefield and only for one player.
You must check bother.
Is there a reason we need this if-else? Can't we just use instanceof instead?
Is there a reason we need this if-else? Can't we give a more specific error message?
Is there a reason we need this if-else? Can't we give a more specific error message for the exception.
I think you can delete the try/catch and the test case is not necessary?
Same as above, you don't need the cast.
I think you can remove the try/catch here? This is not necessary anymore.
If this throws an exception it should not need to catch it, it is just logging it.
If this is moved to a new line it is not a good idea to throw an exception it should not happen.
If this is moved to a new line it is not an error it will log it and just return null
doesn't need to be final
doesn't need to be ;)
doesn't need to be _public_
Seems like this should be an error?
Seems like this should be 'if (notification.getMeasure() == null)' instead of the default case?
Seems like this should be 'if (notification.getMeasure() == null)' instead of the default case.
You should use String name here as well.
Please use String name = "middleName".
You should use String name here as in first line
I don't think it's possible to call close NGSession if it is in the MultiSession session, which is called on the MultiSession session
I don't think it's possible to call close NGSession if it is in the MultiSession session, which is called in the MultiSession session
I don't think it's possible to call close
The management of the enabled radios is currently in 4(?) places in this file. I think the logic might be clearer.
The final keyword is redundant with the above declaration.
The final keyword is redundant with the above one.
I think.equals() returns a value in the range [0, 1), so you'd want to check <.125 instead.
I think.equals() returns a value in the range [0, 1), so you'd want to check that the value is.
I think.value() returns a value with 0.
I think you should be reading the lock here in a finally block. Thread.interrupted() is a better initialization here.
I think you should be reading the lock here in a finally block. Thread.interrupted() is a better initialization here and then split up the loop.
redundant
We can use the log level of the stack trace when we get it.
We can use the log level of the stack trace logging here.
We can use the log level of the stack trace when we get to this log.
I think this should be in a finally block to ensure that the user sent the error during save()
I think this should be in a finally block to release the resources.
UncheckedIOException?
Blank line before and after <LINK_0>
Blank line before and after the loop
Blank line before and after the bracket.
I remember that QueryParameter#contains above will trigger an NPE if the attribute is not found.
I remember that QueryParameter#contains above will trigger an NPE if the attribute is not found. Is that what we want?
I remember that QueryParameterBase.class uses the QueryParameter constructor to set the filter value, which does not match with appropriate typeName
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
When testing, I got an NPE when studentProfile is null. This needs a non-null check. This needs a non-null check. Also needs a test to prevent that from happening again.
When testing, I got an issue when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
s/callExpression/callExpression/
GrammarExpression is a comma-separated list, it could be extracted to a method callExpression.arguments().size().
GrammarExpression is a comma-separated list, it could be extracted to a method callExpression.arguments().size()
Please use any(State.class) with never() to be more reliable
any(State.class) with never() will be more reliable
Please use any(State.class) with never() (more readable)
Just a space after the {.
Just a space here.
Just a space after the (.
It seems that this check can be simplified to: return ((Set<HiveType>)fromFieldTypes.get(i).equals(toFieldNames) || isFieldTypes.equals(toField)) &&!toFieldNames.equals(toFieldNames.get(i));
It seems that this check can be simplified to: return ((Set<HiveType>)fromFieldTypes.get(i).equals(toFieldNames) || isFieldTypes.get(i) ||...
It seems that this check can be simplified to: return ((Set<HiveType>) || (fromFieldTypes.get(i).equals(toFieldNames)) || (toField) == HiveType.STRUCT) || (toField.equals(toFieldTypes)) && isFreeType == HiveType.STRUCT) ||...
Did you take a look at this? <LINK_0>
Didn't you take a look at this? <LINK_0>
Did I take a look at this? <LINK_0>
I think this broke the sonar build: <LINK_0> If this patch was intended, can you take a look at the Jekins configuration?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you explain the change?
I think this broke the sonar build: <LINK_0>
IMO, this can be simplified to suggestion TokenUtil.findFirstToken(TokenTypes.PARAMETERS(modifiersToken), this.modifiersToken!= null && modifiersToken.branchContains(TokenTypes.LITERAL_PUBLIC));
IMO, this can be simplified to suggestion TokenUtil.findFirstToken(TokenTypes.PARAMETERS(modifiersToken), () -> {.private ); private static String findFirstToken(TokenTypes.LITERAL_SORT) {.map(TokenTypes.LITERAL_PUBLIC) // body of method check }
IMO, this can be simplified to suggestion TokenUtil.findFirstToken(TokenTypes.PARAMETERS(modifiersToken), this.modifiersToken!= null && modifiersToken.branchContains(TokenTypes.PARAMETERS));
Three space after if.
It might be safer to put the both iniParameters and iniFileMap.
gt 120
It's not the only reason that this change was needed, as it was before. Why would be needed?
It's not the only reason that this change was needed, as it was before. Why would this be needed?
Seems like this could be done in add() if it was already done in assign().
this block is repeated in many places, can you extract it to a method and call it from the same method?
this block is repeated in many places, can you extract it to a method and call it from the same service?
this block of code is duplicated in the tests, can you refactor it into a separate method?
same thing as above, can this be a different method?
instead of this can use a constant for "while".
instead of this can use a constant for "while" and "else" blocks, if you like this, can remove the 'if'
Ah, I see. I'm not sure if we need to collect the transactions explicitly..
Ah, I see. I'm not sure if we need to collect the transactions explicitly in the transaction. If this is the case, then we can't replace them with the code above.
Ah, I see you are using the code formatting in the PR :)
Maybe we should rename the parameter typeParameters to AnnotatedParameterizedTypeParameters or something similar?
Maybe we should rename the parameter typeParameters to AnnotatedParameterizedTypeParameters or something like that?
Maybe we should rename the parameter typeParameters to TypeParameter or AnnotatedParameterizedTypeParameters?
This logic is duplicated from line 138, should it be extracted to a method?
This is much more readable, I would extract a method to computeCurvedinate(Line) and call it from there. The code will be more readable
This is much more readable, I would extract a method to computeCurvedinate(Line).
this could be put in a try/catch block I believe.
this could be put in a try/catch block, for example, arranged = formatContainer();
this could be put in a try/catch block.
Can't you keep this Exception?
Can you add a fail() after the comma?
Can you add a fail() after the operation?
A straight port of this is odd. You could call.size() instead.
A straight port of this is odd.
A straight forward is incorrect.
Using assertThat is preferred here to favor consistency.
Using assertThat would help readability.
Using assertThat would make this assertion shorter.
Do we need to use getOutputStreams() here? Can't we use it?
Why are you using getOutputStreams() to get the input?
Why are you using getOutputStreams() here? Is it leaking too?
Would it make sense to use a simple if/else here?.map(Math.max(time, pos)).orElse(null)
Would it make sense to use a simple if/else block, since the range is small/day and may not be necessary? :P
Would it make sense to use a simple if/else block, since the range is small/day and may not be necessary?.orElse(null)
It's preferable to use String.valueOf()
It's preferable to use String.valueOf(size)
It's preferable to use String.valueOf(size) to avoid the null check
:notebook: [System.out.format](<LINK_0> may be able to help here
:notebook: [System.out.format](<LINK_1> may be able to help here
:notebook: [System.out.println](<LINK_0> may be able to help here
Why add this inside the try block?
Why forceWrite?
Why add this inside the if block?
Why do you need the permission check here? Just return if something is wrong.
Is this necessary? Just curious.
Why do you need the permission check here?
I think we need to have two getContents(String) methods here?
I think we need to have a fail here?
NamedElement?
What happens if delete is called after close?
what happens if delete is called after close?
What happens if delete is called after shutdown?
Design wise : I would rename this method to CFG.
Design wise : I would rename this method to CFG.USE.
Design wise : I would factor this into a method tree.
This constructor needs to be synchronized (this) because it is a private method.
Why is this needed?
Why is this needed? I think that the test method would have already do this already.
A WordsEnvironment.getObject() should throw an exception if the object isn't found.
A WordsEnvironment.getObject() should throw this error if the object isn't found.
WordsEnvironment.getObject() should throw this error if the object isn't found.
Shall we wrap this with a try/catch?
Shall we remove this?
Shall we wrap this with a try/catch syntax?
Don't we need a null check here?
Don't we need this anymore?
A check for the null check would be better here.
Should this be Expressions.isBefore?
declare'result' at the top?
Should this be mutually exclusive?
useless parentheses
useless assignment
useless parenthesis
Change this to be: "GOV1-BND4_INFO".
Change this to be: "GOV1-BND1")
Make this as const as well.
Use @Inject pies = new Unzip(PATH_TO_LATEST_OTHER);
Use expectException?
Use expectException? Potential.
This block is too long, please move it to the top of the method.
This is a call to delete().
This block is too long, please move it to a separate method
This should probably use auto-generated to avoid flooding the log.
This should probably use auto-generated to avoid flooding the logs.
This should probably use auto-loglog, since the callback may be executed under the lock.
I'd suggest to add synchronized to the ConcurrentHashMap instead of synchronized here.
I'd suggest to add synchronized to the ConcurrentHashMap to avoid possible contention on the nextProjectNegotiations
I'd suggest to add synchronized to the ConcurrentHashMap to avoid possible contention on the nextProjectNegotiations()
Please double check in decision table with multiple outputs and invocation header cell where a method is called
Please double check if there is an error in the context where it is used.
Please double check in decision table with multiple outputs and invocation header cell where a method is called.
Why does it return null? Also I think this should be a null guard.
Prefer URI#valueOf instead.
Why does it return null?
Same here - refer to my patch. I would like to know why this line was changed.
Same here - refer to my patch.
Same here - refer to my patch. I would like this PR to be more readable.
The constructor doesn't use a setter in the constructor.
The constructor doesn't say that it doesn't contain a path in the resource anymore.
The constructor doesn't say that it doesn't contain a property
Does this also log the information from the Exception?
Does this also log the information from the Cache?
Does this also have to be done anymore?
> AudioManager.getMap()?
> AudioManager.getMap()?
can you explain in user input?
should this be split into two lines?
braces
should this be an empty contains()?
Wouldn't this be problematic when detaching the network from cluster and this code will run?
Wouldn't this be problematic when detaching the network from cluster and this code won't be executed?
Does this really need to be inside hostInterfacesByNetworkName?
why not to check it with lastIndexOf?
why not to check it with lastIndexOf? In the original, there is a check in the if condition, but returns true if it is not.
why not to check it with lastIndexOf? In the original, there is a check in the error itself. It will be helpful to know what flow it actually is.
I know you didn't add this, but shouldn't it happen? ;)
I know this is pre-existing, but why are you doing this on the line above? I think you can do away with the assignment above.
I know this is pre-existing, but why are you doing this on the line above? I think it's correct, please :)
You are using a static import for Char
You are using a static import for UriComponentsBuilder
You are using a static import for UriComponentsFinder.java
I think these variable names should be changed to be the same as the field names now.
I think these variable names should be changed to be the same as the field name now.
I think these variable names should be changed to be the same as the field names now
Can we have this one also be: payload.has(FIELD_OPERATION_PATH)?
Can we have this one also be: payload.has(FIELD_OPERATION_PATH) && payload.has(FIELD_PATH)?
Can we have this one also be: payload.has(FIELD_OPERATION_PATH) && payload.has(FIELD_OPERATION_PATH)
This assertNotNull() can be removed.
Could we also assert the actual size of the expected size?
Could we also assert the actual size?
@vilchik-elena This makes the code harder to read. It's not necessarily calling isThisIdentifier method.
@vilchik-elena This makes the code harder to read. It's not necessarily the case of symbol from the method or method.
@vilchik-elena This makes the code harder to read. It's not necessarily the case of nested?
Perhaps single quotes around actual code
Perhaps single quotes around actual text or "CWL" here?
Perhaps single quotes around actual text
For the sake of argument, I think it's better to use StringUtils.isEmpty(StringUtils.isBlank(metadata))
What if metadata is null?
We don't need to use the resource.
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout CorrelationID.
In theory, there is no JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
Should this be: try (Connection connection = DriverManager.getConnection(connection)) {
Should this be "numbackends"?
Should we have this config.user for the workflow?
Same nit: you can just remove these two lines.
Same here, you can just delete these two methods too
Same here, you can just delete these two methods from the test
We don't need to list the compiledObjects here, since it won't iterate over compiledObjects.
We don't need to list the compiledObjects here, only add it to the map.
We don't need to add the default env vars.
file.endsWith("/") is 'destRoot' in a variable. Use 'destRoot' instead.
file.endsWith("/") is 'destRoot' in the same directory. Use 'destRoot' instead.
file might be empty String
This is a bug, we should not make a widget to locate the feature. The feature may have been created by the 'feature' of the DC or 'onWrite'.
This is a bug, we should not make a widget to locate the feature. The feature may have been created by the 'feature' of the DC or 'on write-only' (which is in the DC) and an xsd that declares the address on the DC format (which is in the DC). The feature also allows us to insert or change the mode to regular or read-only options. A user might have an option to get the mode to tag or something.
This is a bugfix. Suggest changing to use the commit.
I'd like to see it in a " image" list. I'd be able to look into this one, in case of a single drive with a non-empty list, and if image is empty, I think it's fine, but since you're using.get() anyway, I'd prefer to use get() instead
I'd like to see it in a " image" list. I'd be able to look into this one, in case of a single drive with multiple image names.
I'd like to see it in a " image" list. I'd be able to look into this in the repositories view.
This method is returning List<Json> rather than a String. The current logic is not looking up to the response itself. Can we leave it as-is?
This method is getting called from the response right? Can the result be cached or extracted to a variable and then reused?
This method is returning List<Json> rather than a String. The current logic is the same as the method which is updated to use.
suggestion botClient.getLocalPlayer().setCamoCategory(botForce);
Just curious, why're botClient.getLocalPlayer().getCamoCategory()'?
Just curious, why're botPlayer.getLocalPlayer().getCamoCategory()'?
I'm not sure if this is necessary. What happens with an infinite loop here?
I'm not sure if this is necessary. What happens with an empty list of timeout values?
I'm not sure if this is necessary. What happens with an empty list of timeout?
You can change.equals to.equals(BIGINT) ||.equals(INTEGER).....equals(NUMBER_OF_NON_NULL_SIE_IN_BYTES).equals(TIMESTAMP_OF_SIE_IN_BYTES).equals(ordinal).equals(int, MAX_OF_SIE_IN_BYTES).equals(ordinal).equals(val)).to(int).compareTo(ordinal) ).get(i));
You can change.equals to.equals(BIGINT) || type.equals(INTEGER).....equals(NUMBER_OF_NON_NULL_SIE_IN_BYTES).equals(ordinal).equals(val).to(int)..
You can change.equals to.equals(BIGINT) ||.equals(INTEGER).....equals(NUMBER_OF_NON_NULL_SIE_IN_BYTES).equals(TIMESTAMP_OF_SIE_IN_BYTES).equals(ordinal).equals(int, MAX_OF_SIE_IN_BYTES).equals(ordinal).compareTo(NUMBER_OF_TRUE).equals(val)).to(int).compareTo(ordinal) > 0).limit(int).compareTo(NUMBER_OF_SIE_IN_BYTES).equals(ordinal) );
This groupId should be set before FirehoseFactory firehoseFactory from the Emitter. We want to add the groupId as well.
This groupId should be set before FirehoseFactory firehoseFactory from the Emitter. We want to add the event callback to the Emitter only.
This groupId should be set before FirehoseFactory firehoseFactory from the Emitter. We want to add this logic to EmitterBoundaryFactory class.
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the normal or exception flow path, no?
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the same try path or exception flow path, no?
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the normal or exception flow path, no? I know that code looks funny.
Why not just use sanitizeGoogleId(googleId); and do it automatically?
Why not just use sanitizeGoogleId(googleId, " course")?
Why not just use sanitizeGoogleId(googleId, " course") /
Do we really need to parameterize this instead of the raw type?
Do we really need to wrap the expected value in the right hand side of the expression here?
Do we really need to wrap the expected value in the right scope here?
static import HIVE_COERCION_AVRO;
This should be a static final constant.
This check should be done in HiveTableDefinition.
one?
2?
one off
Shouldn't we use [HttpHeaders.SUCCESS](<LINK_0> instead?
Can you remove the quotes not added here?
Shouldn't this be using the environment variable instead?
Fair enough. So, we don't need statefulTasksToRankedCandidates anymore.
prop: It seems like we do not need statefulTasksToRankedCandidates anymore.
Do we need statefulTasksToRankedCandidates anymore?
You are trying to remove these 2 changes here. This is not necessary if you change these test calls.
Missed these 2 changes.
You are trying to remove these 2 changes here.
We should put this code in a private method. Something like getServiceInterface().
We should put this exception in the catch block. Otherwise we end up with this change in the future.
We should put this exception in the catch block above.
This creates a very small List <String> -- so there's no reason to do it here.
This creates a very small List <String> -- so there's no need to convert to a String
This creates a very small List <String> -- so there's no need to convert to a String.
getButtonSource will give you EventInputs directly. (Igneous.joystick2.getButtonSource will give you EventInputs directly.)
getButtonSource will give you EventInputs directly. (Igneous.joystick1.getButtonSource will give you EventInputs directly.)
getButtonSource will give you EventInputs directly
remove first argument
remove extra white space
remove public modifier
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you done)?
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmptyExpression.
1. This is a bug fix, 2. Why is this needed?
1. This is a bug fix, 2. Why is this 'else'?
1. I wonder if using the 'URL' (instead of 'driver')' 2. why result is true?
Could you filter any null entries for aeTitle and aeTitle?
Could you filter any null entries for aeTitle and aeTitle to append?
Could you filter any null entries?
Minor: There is no need to add jobsWithoutConfig.
Minor: There is no need to call getJobConfig() twice. So it can be called on line 91.
Minor: There is no need to call getJobConfig() twice. So it can be done in the same line.
Is this repeated from elsewhere (e.g. Sirius)? Can reuse?
Is this repeated from elsewhere (e.g. S3Config)? Can reuse?
Is this repeated from elsewhere (e.g. Splunk)? Can reuse?
it's confusing to me. Can you perhaps elaborate on what is going on here?
it's confusing to know why this is a transaction. Can you just log the exception?
it's confusing to me. Can you perhaps elaborate on what is going on here.
I would add a null check for elastic agents
I'd add a null check for elastic agents
I'd add a null check for /systemId here.
do we really need a timeout here? I think this makes sense.
do we really need a timeout here? I think this makes sense :)
s/r/isAsync
Can we have a task definition for TasksDefinition and taskDefinitions?
Can we have a task definition for this task definition?
Can we have a task definition for TasksDefinition and then just do taskDefinitions?
v1
should this be v1?
v1?
Nice. We should not set the archives on the other archives, but just the default archives which are not the other.
Nice. We should not set the archives on the other archives if we are not running.
better to set the archives as the -spark-src archives
I think it would be better to have properties.putAll(stepName) method instead of the additional logic if none is the same.
I think it would be better to have properties.putAll(stepName) method instead of the additional logic if it is in the map.
I think it would be better to have properties.putAll(stepName) method instead of the additional logic if you're doing it separately in the superclass
this validation part could be moved to a separate method (see one method for example)
this should be moved to the finally block
this validation part could be moved to a separate method
this should be numberOfRetries.size()
this should be numberOfRetries => 0
this should be numberOfRetries.size(), right?
whitespace
r.a.
r.getContent()
why is this done again? looks like it was done already in line 111
why is this done again? looks like it was done only in one place
why is this done again? I think it was done already in line 111
Are we not going to use the EntityRef here? To avoid confusion, I think it would be better to have the entityRef variable here.
Are we not going to use the EntityRef here? To avoid confusion, I think it would be better to have the entityRef variable to store the reference.
Are we not going to use the EntityRef here?
This looks weird. Why not use <LINK_0>
This looks strange. Why not use <LINK_0>
This looks strange. Why not use <LINK_0>?
might be better to use the titleView.layout here, wdyt?
might be better to use the titleView.
might be better to use the titleView.theme() function here instead of a boolean.
((Server)server).setModuleState(temp, state) is called twice in this loop
((Server)server).setModuleState(temp, state);) is called twice in this loop
( ((Server)server).setModuleState(temp, state) is called twice in this loop
Unrelated change in this PR, but please move it to a separate PR
Unrelated change in this PR
Unrelated change
I think we should check for null here too.
I think we should check for null here too. WorkspaceProject workspace = resolveProject(branch); if (branch.getBranches().equals(branchName)) { return resolveProject(projects, workspaceProject); } return workspaceProject;
I think we should check for null here.
please include the cause.getCause() to ease debugging.
please include the cause.getCause() part before calling generateRequest().
please include the cause.getCause() to the cause
Why use a insertAfterKey and insertAfterKey method to make sure that it clears inserted in the insertAfterKey method?
Why use a insertAfterKey and insertAfterKey method to make sure that we use the data key and the row key?
Why use a insertAfterKey and insertAfterKey method to make sure that we use the data key and the write key?
should we assert at this point before the map is closed?
should we assert at this point?
should we use ProjectBuilder.print() instead of ()?
Why not put TokenTypes.CLASS_DEF here?
Why not put all of these in a separate loop? Wouldn't it make sense to have separate methods for each type?
Why not put TokenTypes.CLASS_DEF?
do we get the redundant newline thing now?
do you get the redundant newline thing now?
do we get the redundant newline thing?
This feels weird - maybe we can collapse this to: if (view == null) { return; } for (WebView view : url);
This feels weird - maybe we can collapse this to: if (view == null) { return; }
This feels weird - maybe we can collapse this to: if (view == null) { view.onPageStarted(); }?
Consider to use static import
Consider to use static import for assertThat
static import
Should this be an assertion for this?
Should we check for this?
Should this be field
else if
else { a = null; }
else { a = -1 }
This should also be included in the exception message
This should also be included in the exception message.
This should also be included in the "else" case.
totalExecutors.containsKey(compConstraintCountMap.entrySet()) should be faster.
totalExecutors.entrySet() can be replaced with Comparator.comparing(Map.Entry::getValue).reversed
totalExecutors.containsKey(compConstraintCountMap.entrySet()) should be the same.
nit: does this need to be a static?
nit: does this need to be public?
nit: can avoid this.
s/Qualifier/Qualifier
s/param/value/
s/param/value/param/
why not put image?
why we need check if vmTemplate.isEmpty()?
why we need copy-pasted?
use a constant
use a List
use a list here
Maybe I'm being daft, but where are the CDA message being added?
Perhaps I'm being daft, but where are the CDA message being added?
Maybe I'm being daft, but where are the CDA message being generated?
Why are we not using this?
Why are we using this?
Why are we not using the Thread.sleep?
Shouldn't it be template.isJSFVersion()?
Shouldn't it be template.isJSFVersion()?
Move it to a new method
List<RepositoryGroup> groups = List.of(groups); List<RepositoryGroup> groups = elements.stream().anyMatch(group -> { if (element instanceof RepositoryGroup && group.isVisible()) { groups.add(group); } } return list; }
List<RepositoryGroup> groups = List.of(groups); List<RepositoryGroup> groups = elements.stream().allMatch(group -> getSelectedNodes()); if (element instanceof RepositoryGroup && group.isVisible()) { groups.add(group); }
List<RepositoryGroup> groups = List.of(groups); List<RepositoryGroup> groups = elements.stream().anyMatch(group -> { if (element instanceof RepositoryGroup && group.isVisible()) { groups.add(group); } } return list; });
nit: I'd suggest to add a helper method for this.
nit: space after (
nit: I'd inline the local variable.
Was this intended? If so, can we just log error message in 'debug'?
Was this intended? If so, can we throw a specific exception?
No need to do this.
why returnValue? if you want to squash it
use Guid.isNullOrEmpty()
why returnValue?
How about creating a job in the Job?
How about creating a job in the JobNode using the logger?
How about creating a job in the template and setting that instead of null?
I'm not sure if this method should be called from here to the service in the CorrelationAttributeManager.
I'm not sure if this method should be called from here to do something like this. It looks like it's doing the same thing as well.
I'm not sure if this method should be called from here to do something like this. It looks like it's doing the same thing as the private method so it can be overridden.
This appears to be a logger instead of System.out.println
This appears to be a logger instead of System.out.println.
This appears to be a logger instead of System.out.println().
I'd catch RuntimeException here as well.
Should this be 'Failed'?
I'd catch RuntimeException here as well
This can be moved into a private method that is called from the parent class.
This can be moved into a private method.
This can be moved into a few lines below.
This is unnecessarily slow when change!= null and we know the branch name from the change object.
Can't this be changed to: IncludedInDetail.getBranches(c)?
Can't this be changed to: IncludedInDetail.getBranches(c)
in the name of this, it's a common use case. I do not want to go through the Pattern to find the Pattern anymore.
in the name of this, it's a common pattern, you should be able to use Pattern.compile(".*(?
in the name of this, it's a common use case. I do not want to go through the Pattern to find the regexp (they're not Pattern anymore)
This code is used in my app. So instead of calling getOwner() I think it's more efficient to do something like this: if (myoptional.isPresent()) { final int myId = prefs.get(ApplicationInfo.getPatientInfo()); if (patientInfo.isInt()) { //... }
This code will never be reached because of my code. If we always return an error, please add a null check.
This code is used in my app. So instead of calling getOwner() I think it's more efficient to create a simple message than my thing.
There should be a null check on this.
There should be a null check on this. There should be a null check on this.
There should be a null check on this. There's no other way to do that.
Not sure this is necessary if responseStart is null.
Not sure this is necessary if headerStart is set to responseStart
Not sure this is necessary if headerStart is set to zero
This should be: throw new UnprocessableEntityException("Unable to determine bitstream", e);
this should be: throw new UnprocessableEntityException("Unable to determine bitstream", e);
nstream = new BitstreamRest?
Shouldn't this be: if (mActive && mWifiStateMachine.isMobile) { mLastPowerState = cm.get(); }
Shouldn't this be: if (mActive && mWifiStateMachine.isMobile) { mWifiStateMachine.sync(); }
Maybe the synchronized block can be removed?
I don't think this is the right place to handle this. Can this happen?
I don't think this is what we want. Have you tested?
This might throw an exception.
Make sure it works, but you're still doing it for every request.
Should this method be private?
Make sure it works, but you're still doing it for every element.
Do you want to keep this?
Do you want to keep this in a local variable and set it to null?
Do you want to keep this here?
I think equals is a safer way to use the constant.
I think 'n' is a reasonable way to handle a case where the fieldId is null.
I think 'n' is a reasonable way to handle a situation where the fieldId is null.
shouldn't you close the BufferedInputStream in the constructor and store it in a try block?
shouldn't you emit the map from the BufferedInputStream?
shouldn't you close the BufferedInputStream in the constructor and set it?
Will fail due to null pointer or db, this line is executed
Will fail due to null value
remove line
It would be better to throw an exception instead of just logging it.
It would be better to throw an exception instead of silently ignoring the result.
It would be better to throw an exception instead of just logging.
Please rename 'getFacings' to 'clearProperty'.
Please rename 'getFacings' to 'clear'.
Please rename 'getFacings(..)' to 'clear()'
Order of these two if conditions should be combined into 1 if clause.
Order of these two if conditions should be combined into one. Otherwise we would not log the exception to the fact that the file ends up in the string.
Order of these two if conditions should be combined into one. Otherwise we would not log the exception to the fact that the file ends up in the directory.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
I think we need to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
I don't want to have us get in the habit of manually building JSON instances. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
The groups should be inside ProjectControl.
The groups should be inside ProjectControl. Also, the groups should be inside ProjectControl.
s/uploadGroup/uploadGroup/
I think this is missing a null check for timeseries but not metadata under it.
I think this is missing an implementation of it, because this _could_ have a queryPlusQuery interface which handles that queryPlus for an existing queryPlusQuery_ interface.
I think this is missing an implementation of it, because this _could_ have a queryPlusQuery interface which handles that queryPlus from an interface.
For the sake of consistency, I'd still add a config. Needs a config.
For the sake of consistency, I'd still add a config.getStaleUserPassword() to the configuration file, and then use that instead of the hard coded "global".
For the sake of consistency, I'd still add a config.getStaleUserPassword() to the configuration file, and then use that instead.
Using the returned AppBase app to get the time.
Remove final at the top.
Using the returned AppBase app here will get a lot of overhead.
I'm not sure that emitIndexUpdateTimeMillis > INSERTED_ROWS (i.e. second or last) would be a better implementation, but it doesn't really matter.
I'm not sure that emitIndexUpdateTimeMillis > INSERTED_ROWS (i.e. second or last) would be a better alternative than that.
I'm not sure that emitIndexUpdateTimeMillis > INSERTED_ROWS (i.e. second or last) would be a better alternative than that. Wondering if there's another place where we handle handle that?
Please combine the block with the following if statement: java if (!healthCheckRegistry.getCRUDController(crudControllers) && crudControllers.getCRUDControllers()) { return false; }
Please combine the following if statement into a single statement: if (!healthCheckRegistry.getCRUDController(crudControllers) && crudControllers.getCRUDControllers().getCRUDControllers()) {
Please combine the following if statement into a single statement: if (!healthCheckRegistry.getCRUDController(crudControllers) && crudControllers.getCRUDControllers().getCRUDControllers())) {
You should use the index variable for the message, like you do on line 186.
You should use the index variable for the message, like you did on line 186.
You should use the index variable for the message, like you did in the other files.
nit: it would be nice to add constant CheckpointRecordJob.EMPTY_CONTEXT, and change the name to CheckpointStorageLocation.
nit: it would be nice to add constant CheckpointRecordJob.EMPTY_CONTEXT, and use it in CheckpointStorageLocation.
nit: it would be nice to add constant CheckpointType.EMPTY_CONTEXT, and use that constant instead.
I think that the try catch block should just be removed
This test is missing a verify that the result contains an empty key.
This test is missing a verify that the result contains a password.
nit: since the index was updated after the assignment is done, I would prefer the message to be the same.
nit: since the index was updated after the assignment is done, I would prefer the message to be consistent with the other log statements.
nit: since the index was updated after the assignment is done, I would prefer the message to be consistent with the other log messages.
Please use getDbFacade() - it makes it easier to unit test.
Please use getDbFacade() - it makes it easier to unittest.
I think the name should be actionGroup, and type.name()
Pass the exception as the second parameter instead of throwing the exception.
Pass the exception as the second parameter instead of throwing the IllegalStateException.
@ Yayiwa do you think it's worth logging in here?
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Are you assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Are we assuming that oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
This looks like it's duplicate of the bounding box, why not just take the bounding box?
This looks like a duplicate of the previous method. Is that intentional?
This looks like a duplicate of the previous method. Is it really needed?
This can be simplified: if (acl == null ||!acl.isEmpty()) { throw new AccessControlPolicy[0] }
This can be simplified: if (acl == null ||!new ACPolicy[0] > 0) { throw new AccessControlPolicy[0] }
This can be simplified: if (acl == null ||!acl.isEmpty()) { throw new AccessControlPolicy[0] } return new AccessControlPolicy[0](b.getContent());
ipEntry entry = new ipEntry(new FileInputStream(path));
ipEntry entry = new ipEntry(new FileInputStream(path))
ipEntry entry = ipEntry.substring(0, annotationClass);
Why not to use ImmutableList.Builder<HiveColumnHandle>?
Why not to use ImmutableList.Builder<HiveColumnHandle>? You don't need to pre-load Domain fields anyway.
Why not to use ImmutableList.Builder<HiveColumnHandle>? You don't need to re-use the return value.
nit: wrap with {}
nit: wrap with {
nit: wrap with { }
Should this be moved out of the loop?
Should this be allowed to return a Ident as name?
Should this be allowed to return a IdentifiedElement?
Just do the same for above.
Just do the same thing here...
these if blocks can be combined
Wouldn't it be safer to do!m_committedBuffers.isEmpty()?
Would it be possible to refactor this and other logic inside a method to reduce duplicate code in the same method?
Would it be possible to refactor this and other logic inside a method to reduce duplicate code?
double check that the group is still here
double check that no group is still here
double check that no group has been created
I'm not sure we should keep this clean and add a private method, e.g. add the VALID_TO and PRNG? This is considered to avoid re-seediing in background when not needed.
I'm not sure we should keep this clean and add a private method, e.g. add the VALID_TO and PRNG? This is considered to avoid re-seediing in background when not necessary.
I'm not sure we should keep this, but just add the original exception to the log, so that we can have a more accurate message. This is really hard coded.
I think it's better to create a method called getPossibleErrorsNumber(TASK_FAIL_ON_DISABLED) and use it.
I think it would be better to create a method TASK_FAIL_FAILURE_MANAGET.
All these methods can be final.
should be 'task 'task ', not 'task'.
should be 'task 'task 'task'.
should be 'task 'task'.
format this as string substitution
start time is -1?
totalStats
can we make resourceName for all the states be same e.g. "state" instead of being specific as that requires the conditional and hardcoding of URLs? I think it's better to have a static variable.
this should be a SERVER_ERROR, reaching here means this filter was added to the wrong place in the code and not a user mistake.
can we make resourceName for all the states be same e.g. "state" instead of being specific as that requires the conditional and hardcoding of URLs? I think we need to give a better name for the API chunk
1) When would 'worked' return null? 2) Why drop the exeption message and use the one?
1) When would 'worked' throw? 2) Why drop the exeption message and use the proper message?
1) When would Status be null? 2) Why drop the exeption message and use the one?
I think this change is not needed. We should remove it.
I think the default should be true. It does not make sense to have an explicit return value. How about add a check for CUSTOM_MODE instead?
I think the default should be true. It does not make sense to have an explicit return value. How about add a check for the pom used and set the default.
You could use IOUtils.validateArg which takes a header and body into the String.
You could use IOUtils.validateArg which takes a String.
You're missing spaces before and after +.
Are you sure that Id is not a string?
Are you sure that hanResource can be used instead of the implementation?
Non-null assertions
Can we just iterate over the list to avoid the intermediate list?
Can we just iterate over currentSubList.get(0) here?
Can we just iterate over currentSubList.get(0) instead?
We can probably just store the actual value in a local variable here.
We don't really need to do this anymore?
We don't really need to do this anymore. See the next PR.
Why is this needed?
Why is this change needed?
Why is this needed? It is already the class name.
Should be meanSingularValue.
Should meanSingularValue.
Should be info level.
Two getBytes(Charset) and helper methods. They are repeated three times.
Two getBytes(Charset) and helper methods. They are hard to read.
Debugging code?
If we are not testing the "positive" argument, we should also test the following cases: * <LINK_0> * <LINK_1>
If we are testing the "positive" flow, we should also test the following cases: * <LINK_0> * <LINK_1>
If we are not testing the "positive" argument, we should also test the following cases: * <LINK_0> * <LINK_1> This is a valid use case.
Since this is an error-prone, I think it might be nicer to have a method something like this: boolean requireTimestampsToSearchActiveTimes = future.getSplits(); if (timestampsToSearch.isEmpty()) { return; }
Since this is an error-prone, I think it might be nicer to have a method something like this: boolean requireTimestampsToSearchActive = future.getSplits(); if (timestampsToSearch.isEmpty()) { return; }
Since this is an error-prone, I think it might be nicer to have a method something like this: boolean requireTimestampsToSearchActiveTimes = future.getSplits(); if (isRetriableToSearch()) { return true; }
Unnecessary code.
mb to crash (ctrl + alt + L)
mb to crash
I think we'd prefer to use the default jetty.getAuthenticationStore().addAuthentication(HttpServletRequest) approach to avoid duplication
I think we'd prefer to use the default jetty.getAuthenticationStore().addAuthentication(HttpServletRequest) method to avoid duplication
I think we'd prefer to use the default jetty.getAuthenticationStore().addAuthentication(HttpServlet.USER_AGENT_CHALLENGE.NONE)
Update log message
Message needs updated; perhaps it would be useful to log details of what went wrong.
Update log messages
It looks like this can be a singleton. Do we need it?
It looks like this should be a warn, not an exception.
It looks like this should be a warn instead of a DEBUG
you should use parameterized logging instead of string concatenation.
use parameterized logging instead of string concatenation.
can you use parameterized logging instead of string concatenation?
Please add a check that offset here is not null.
Please add a check that "this." here to make sure that we pass those on to the pagelists.
Please add a check that "this." here to make sure that we pass those on to the pagedFile.
Should this always be called in the try-catch block? Otherwise, the call would silently fail.
Should this always be called on the hudson.model.Util#createTable? If the location is external then the default location is external, so could be set to CompatibilityUtils.checkDatasetName
Should this always be called on the hudson.model.Util#createTable? If the location is external then the default location is external, so could be set to CompatibilityUtils.checkDatasetName instead.
lets add a short blurb in the field description and in the.md doc file describing that records with a null field get filtered out.
lets add a short blurb in the field description and in the.md doc file describing that records with a null field getLocalizedMessage will be a NullPointerException.
lets add a short blurb in the field description and in the.md doc file describing that records with a null field getLocalizedMessage will be a stack trace.
Why do you close this stream in this try-with-resources block?
Why do you close this stream in constructor?
@subkrish, please move declaration of addTimers to its declaration.
I think it might be better to add RANGER_DATA_URL instead of RANGER_URL here.
I think it might be better to add RANGER_DATA_URL instead of RANGER_HDFS_URL here.
I think it might be better to add RANGER_DATA_URL here.
we might not need GetBlobResult anymore if GetBlobResult already contains the chunk IDs.
why is this useful?
we might not need GetBlobResult anymore if GetBlobResult already contains the chunk ID.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.get method.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.get(). That interrupt will (potentially) interrupt the sleep and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching it and just returning.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.get("Asked to start"); before the catch (Exception e). In that new catch clause is where you call newThread.get("Asked to start the Hawkular CLI version like stop."); above.
Looking at the LayoutConstraintView, both of these classes could be defined within NodeService and parent.
Looking at the LayoutConstraintView, both of these classes could be defined within the abstract classes.
Looking at the LayoutConstraintView, both of these classes could be defined within the abstract class.
Any reason not to include e?
Any reason not to use Iterator()?
Any reason not to use Iterator() instead of looping?
Please format the code according to the new conventions: 1. to add a space between the && and the 'if' - it should be the same. 2. not to put it on the same line as the preceding bracket.
Please format the code according to the new conventions: 1. to add a space between the && and the 'if' - it should be the first line of the condition
Please format the code according to the new conventions: 1. called 2. can you please wrap the line before the brackets..
Defaults in this patch?
Default
Default
Can the code be written more concisely as: criteria.add(Restrictions.isNull(filter.getValue())) { return criteria.getValue(); }
Can the code be written more concisely as: criteria.add(Restrictions.isNull(filter.getValue()))
Can the code be rewritten to use criteria.subList(filter.getValue(), filter.getValue()) here instead of filter.
define a class for this?
same here, use constants.
define a class for this, since it is used only once.
This should probably be else if (accessTravelTimes && lineStart) { to reduce the amount of code duplication
I don't think we should do this anymore
This should probably be else if (accessTravelTimes && line 82).
You pulled the conditional on line 8192 into a local variable.
8192 is better extracted as a constant.
You introduced 8192 in a local variable. Could you use that here?
I don't understand why this isn't the right place to calculate the attribute here. Use a clean private method: getThread() or something along those lines.
I don't understand why this is necessary. Isn't the setting in the correct method?
I don't understand why this isn't the right place to calculate the attribute here. Use the DB with a clean iterator.
These two should be moved to the finally block.
This must be done from whitin the locked block, after we're inlining the list from "resource".
This must be done from whitin the locked block, after we've received the sigal from "notResolving")
I assume this should be 0L instead of 1.
I assume this should be static
I assume this should be negative?
Minor: a stylistic preference would be to have a local variable called "get" and return null here.
Minor: a stylistic point here.
Biome biome's no longer used here.
@ocID WDYT about using a logger?
@ocID can be removed now.
@ocID WDYT about using a logger.error?
This line shouldn't be in the i18n file
This seems to be i18n'ed
Format
I think it would be worth making this error a bit more useful. At least adding it to the message
I think it would be worth making this error a bit more useful. At least adding it to the log.
I think it would be worth making this error a constant.
We do not have to synchronize this method. Shoudl't we use a lock?
We do not have to synchronize this method. Shoudl we use a lock?
We do not have to synchronize this method. Shoudl't we add a synchronized method to the class?
Let's update metadataLoc to avoid re-creating it for newMeta1?
IMO, it's better to reuse code from IgniteToMetaHolder.
Let's update metadataLoc to avoid re-creating it for newMeta1
let's use a collector here, like: Iterable<T> evalBatchSize = new IEvaluationReduceFunction<>(new IEvaluationReduceFunction(conf, evalBatchSize)).mapPartitions(eval -> sc.broadcast(network, position, selection));
let's use a collector here, like: Iterable<T> evalBatchSize = new IEvaluationReduceFunction<>(new IEvaluationReduceFunction(conf, evalBatchSize)).mapPartitions(evalFn, stat.broadcast);
let's use a collector here, please
null == adapter
null!= adapter
null == adapter?
I am not sure if this is the right place to put the query. Also, I don't think we need to make sure all queries are loaded before every query.
I am not sure if this is the right place to put the query. Also, I don't think we need to make sure all queries are loaded at the end.
I am not sure if this is the right place to put the query. Also, I see that the query could be put outside of the response.
I think you should keep this as NORMAL since the equals method is only used for assert.
I think you should keep this as NORMAL since the equals method is only used for the parameter.
I think you should keep this as NORMAL since the equals method is not used
You can use a switch statement here.
Looks like isn't this a BlobProperties wrapper anymore?
Looks like isn't this a copy constructor?
I think here can you refer to the configured time.getHour(), TimeUnit.MILLISECONDS.toEpochSecond() / TimeUnit.MILLISECONDS.toEpochSecond()
I think here can you refer to the configured time.getHour(), TimeUnit.MILLISECONDS.toEpochSecond() / 1000 for the time. It will be more readable.
I think here can you refer to the configured time.getHour(), TimeUnit.MILLISECONDS.toEpochSecond() / 1000 for the time. It will be more readable and more readable.
I would suggest you to add a TODO here, in case there is a significant number of args for a log, and it's not a problem.
I would suggest you to add a TODO here, in case there is a significant number of args for a log file
missing a space after (
Can we make this more readable like java Set<String> unusedTasks = previousAssignmentByInstance.values().stream().flatMap(Collection::stream).filter(x ->!newTasks.contains(x.getName())).collect(Collectors.toSet());
Can we make this more readable like java Set<String> unusedTasks = previousAssignmentByInstance.values().stream().flatMap(Collection::stream).filter(x ->!newTasks.contains(x.getName())).collect(Collectors.toSet()); return unusedTasks;
Can we make this more readable like java Set<String> unusedTasks = previousAssignmentByInstance.values().stream().flatMap(Collection::stream).filter(x ->!newTasks.contains(x.getName())).collect(Collectors.toSet()); return unusedTasks; }
Is this needed?
Is there a reason we're splitting this to TranslateException?
Is there a reason we're splitting this over 2 lines?
Shouldn't this be getDiagnosticCode(marker.diagCode())?
Should this be processed in the for loop?
Shouldn't this be getDiagnosticCode(marker.diagCode())?
wait for the callback to be called, then you don't need to check it again.
wait for the callback to be called, then you don't have to check it again.
wait for the callback to be called, then you don't need to set it to zero
org.apache.commons.lang.Validate
java } catch (NullPointerException e) { LOGGER.log(e); }
org.apache.commons.lang3.Validate#isNull
It is OK to call two different methods here. The implementation of the two methods can be unified in the AccountsLogic class.
It is OK to call two different methods here. The implementation of the two methods can be centralised.
It is best to define a method to do this. Up to you.
This three lines can be done in a private method.
This file can be cleaned up a little
This file can be deleted.
Please move the above line to after the loop.
Please move the above line to a one-liner
can be a while
it would be good to change it to 'equals'.
it would be good to change it to 'equals'
it is a good practice to use 'equals'
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do: Long value = expectedMetrics.get(metric.name()); if (value!= null) { long expectedValue = value.longValue();...
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do Long value = expectedMetrics.get(metric.name()); if (value!= null) { long expectedValue = value.longValue();...
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do: Long value = expectedMetrics.get(metric.name()).longValue();
I'm a bit confused by this, is it necessary to be isCurrentPlanProductIdForLocalBlogId?
I'm a bit confused by this, is it necessary to return isCurrentPlanProductIdForLocalBlogId?
I'm a bit confused by this, is it necessary to be isCurrentPlanProductIdForLocalBlogId(position)
At some point, we need to add a null check here: if (configDir.exists()) {... }
At some point, we need to add a null check here: if (configDir.exists()) { if (configDir.exists()) {... } }
You can use try-with-resources.
The semaphore cannot be equal to the size of permits.
The semaphore cannot be empty, so it's not needed to return anything.
The semaphore cannot be equal to 1 thread, so it's a bit dumb.
This file is used in two places
This try-catch can be at the bottom
This file can be a constant in its location.
Why not make it package-private?
Why not add the this. prefix?
Why not addEventHandler annotation if you register it in the constructor?
There's technically a race condition here, I don't think this function needs to be synchronized, and set the field in this function, since there's probably a race condition.
There's technically a race condition here, I don't think this function needs to be synchronized, and set the field in this function, since there's no thread-safe class, which is probably a thread-safe class.
There's technically a race condition here, I don't think this function needs to be synchronized, and set the field in this function, since there's no thread-safe class, which is probably a different thread.
what if isRunning() returns false? should this be more explicit?
what if isRunning() returns false?
don't catch Exception
This can be replaced by a while loop to avoid the slow condition: if (t.matchShift!= null &&!isGitlink(minRef)) { return; }
This can be replaced by a while loop to avoid the slow condition: if (t.matchShift!= null &&!isGitlink(minRef)) { return; }...
This can be replaced by == instead of t.matchShift.matchShift.matchShift.matchShift.matchShift.matchShift.eof(minRef, t)
rlum.role:vraptor has a method called Target instead of targets
rlum.com.caelum.packageName.vraptor has a method that returns Iterable<Target>
rlum.com.caelum.packageName.vraptor has a method that returns Iterable<Target> for List.
Could you move this log to the top?
Could you move this log message body to the helper method?
Could you move this log to the top of the function?
* Is it a real bug? * If it's not equal to the previous implementation, it's better to use the constant.
why do we need to use the above 2 lines?
* Is it a real bug? * If it's not equal to the same instance, it should be null.
You should have done it right when writing this for the first time
You should have done it right when writing this for the column. Especially when modded WorldProviders are allowed, with arbitrary logic in those methods.
You should have done it right when touching this.
Minor: FileOutputStream outputStream = new FileOutputStream(fullTemp);
Minor: FileOutputStream outputStream = new File(fullTempPath);
You should be using tempDirFile instead of the default.
No need for a separate exception.
No need for a special case?
No need for a +1
Needs to call this as error (or any other exception)
Needs to call this as error (or any exception)
Careful with the error reporting. I would suggest to report this as-is so that we don't always have a specific index (for each item)
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work
I think it'd be better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work, but it is more likely to be used in other classes.
Ah, you should probably catch the exception and wrap it with a RuntimeException and handle it properly. This way DataAccessException doesn't need to be thrown from the TreeMap.
Ah, you should probably catch the exception and wrap it with a RuntimeException and handle it properly. This way DataAccessException doesn't need to be thrown from the init method.
Ah, you should probably catch the exception and wrap it with a RuntimeException and handle it properly. This way DataAccessException doesn't need to be thrown from the TreeMap. I'd rather you could just wrap the DtgovUiException.
We should assert the workflow has been 1 entry.
We should assert something in the value and have a test for it.
Missing generics
extract the in a try/finally to ensure the 'if' statement is closed
extract the in a try/finally to ensure the 'if' statement is closed too
this could also be in a finally clause.
It would be good to throw another exception, instead of ignoring it.
It would be good to throw an exception, instead of ignoring it.
It would be good to throw another exception, instead of IOException, because the cast is not necessary.
Adding new ApiAction(ACTION_EXCLUDE_FROM_SCANS_EXIST, PARAM_SCANS); would be simpler.
Adding new ApiAction(ACTION_EXCLUDE_FROM_SCANS_EXIST, PARAM_SCAN_KEY, true); would be enough.
Adding new ApiAction(ACTION_EXCLUDE_FROM_SCANS_EXIST, PARAM_SCANS); would be enough.
We appear to be re-implementing some of querying logic to find the host for a specific containerId
We appear to be re-implementing some of querying logic to find the host for a specific containerId in this map
We appear to be re-implementing some of querying logic to find the host for a specific containerId in this map here
Please specify why this is again: itcarray[itcarray[i] again.
Please specify why this is again: itcarray[itcarray[i] again
Please specify why this is again: f.tm:itcarray[i].getName()
So if I have 2 sherlockAttributes in the same granularity, we'll get the action content for each element....
So is this sherlockAttributes.RherlockAttributes....
So is this sherlockAttributes....
no need for 'this'
no need for this line
no need for writeLock with empty list
I know that it is not part of your changes, but please add a space in the keys.
I know that it is not part of your changes, but please add a space in the keys. Wouldn't it be better to go into the top of the method?
I know that it is not part of your changes, but please add a space before "=".
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
Remove the hard coded string
Remove this hard coded string
Remove redundant white space
I don't think we need to do this anymore.
I don't think we need to do that here.
I don't think we need to do this here.
don't use e as a variable name; here, instead of e.getContent() instanceof HttpResponseException Could you make this variable final?
No need to log and rethrow as a RuntimeException
don't use e as a variable name; here, instead of e.getContent()
Conflicting name with other ratesources
Remove CoinexchangeRateSource.
CoinexchangeRateSource is a list of other
What is this?
What is this counting here?
What is this counting for?
@fanifieiev the same above.
@sebing please put spaces around :
@bdragan return type... no need to declare throws IOException
May be move this to a private static final class.
May be move this into a private static final String variable and reuse the same variable.
May be move this to a private static final String variable and reuse the same variable.
} catch (Exception e) { throw new RuntimeException(e); }
} catch (Exception e) { throw new SafeRuntimeException(e); }
No need to print stack trace here.
suggestion assertThat(ldapUserDetails.getUsername()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat
suggestion assertThat(ldapUserDetails.getUsername()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo("base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo("base64encoded-issue-1840"); assertThat(
I think it would be better to avoid other loop casting by class name. It is more complicated.
I think it would be better to avoid other cast operations? It looks like a simple loop...
I think it would be better to avoid 'n't' field mapping' in the description? It is more intuitive to users.
magic number? Shouldn't the query be case insensitive?
magic number? Shouldn't the query be added as an argument?
magic number? Shouldn't the query be added as an error?
This should not return true for properties that are not included in the traceElement.
This should not return true for properties that are not included in the traceElement object
You should probably return here
extra blank
extra blank line
please check all code
Do we want an assertion for this?
Do we want an assertion for the number of times?
Do we want to assert this to be false?
Should we check if the file has been deleted for some reason?
Should we check for TEMP_PREFIX being used here?
Should we check if the file has been deleted for some reason? What if the file has been created for the same directory?
I would still throw Exception here instead of printStackTrace
I would still throw Exception here
I would still like to see this in the PR
if (row.size() == 0) { return IntIterators.EMPTY_ITERATOR; } else { IndexedInts row = row.get(dimensionId).iterator(); return IntIterators.EMPTY_ITERATOR; } return null;
if (row.size() == 0) { return IntIterators.EMPTY_ITERATOR; } else { IndexedInts row = row.get(dimensionId).iterator(); } return null;
you can just use a iterator here
style nit: no braces around single line blocks
style nit: missing braces
style nit: missing braces, more of these below
Is it possible to use!nextNode == null ||nextNode == null?
Is it possible to save a subtraction operation? If it is "visit(User)" instead of writing the worst case, it'll be nice
Is it possible to save a subtraction operation? If it is "visit" instead of writing a new value, it's more readable.
new byte[0] instead of new String().format().
new byte[0] instead of new String().length()? Also, doesn't this mean we're creating files for each dashboard regardless of whether they have translations?
new byte[0] instead of new String().join()? Also, doesn't this mean we're creating files for each dashboard regardless of whether they have translations?
not sure that you need a regex here?
not sure that you need the snapshot info from the snapshot?
copy
Generics?
Please replace this assert with a CanDoActionTestUtils call.
Please replace this assert with a canDoActionTestUtils call.
This is not sufficient. Status is only used in tests.
This is not sufficient. Status is always true by default, so it is '{0}' (not '{0}') looks better.
This is not sufficient. Status is always true by default, so it is '{0}' (not '{0}') does not work.
This can probably be moved to the parent only.
This can probably be moved to a private method.
This will probably add the span to the current thread.
The other place in this class where a DomainException is thrown should be explicitly mentioned where a DomainException can be thrown.
The other place in this class where a DomainException is thrown should be explicitly mentioned where a DomainException is thrown.
The other place in this class where a DomainException is thrown should be explicitly mentioned where a DomainException is thrown. You can check the'models' variable.
The first parameter unnecessary is this test.
The first parameter you need to set is the same properties below
The first parameter you need to set is that it was?
Calling getLifecycle() twice (just in case). Then, you can call "this".
Calling getLifecycle() twice (just in case). I'd suggest to call it once in the constructor instead.
Calling getLifecycle() twice (just in case). I'd suggest to call it once in the constructor.
We probably don't want it to be empty?
We probably don't want it to be disabled here?
We probably don't want it to be disabled here, but just suppress it.
Can you please put this as a method method with two parameters? It's easier to read, and avoids the extra "else"s
Make this method private since it's only called from a single place, and maybe the following method could be moved to the walletLogin!= null && st.nextToken().
Can you please put this as a method method with two parameters? It's easier to read, and avoids the extra "else".
I'm not the biggest fan of having the isExpanded/setExpanded still live in the model object, but maybe that is a change that will be a part of <LINK_0>?
I strongly prefer inverting these kinds of tests so that they bail early, instead of wrapping the entire method. E.g.: if (!mStableIdMap.size() &&!mStableIdMap.get(mStableIdMap.size())) { parentWrapper.setExpanded(false); }
I'm not the biggest fan of having the isExpanded() method in the model object, but maybe that is a change that will be a part of <LINK_0>?
I think that if 'if' is true we should start with the one of the disks.
I think that if 'if' is true you should start with the one after the disk.
I think that if the disks.size() == 0 this code will be executed inside the loop, no?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why DefaultsPropertiesContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why EncryptionProvider and ConfigContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why Defaults().
Minor point, I'm not sure if this method could be made private.
Minor point, I'm not sure if this method could be made static.
pwd is never null.
Great!
Won't this move the try/catch for the SamzaException?
Nice!
I believe it should be TypedId
I think it should be TypedId
I believe it should be TypedId.
You could add your own anonymous class to the top of the method for this. here by calling setNotification(...) on each method
You could add your own anonymous class to the top of the method for this. Just the Problems and style.
You could add your own anonymous class to the top of the method for this. Just the Problems and style is wrong too.
I'm not sure if this is necessary, if BackOff is null and the one after the BackOff is too?
I'm not sure if this is necessary, if BackOff is null we're already doing that in the nextBackOff constructor
I'm not sure if this is necessary, if BackOff is null and the list is not created, there is no point in adding it.
would add constants for string constants
would add constants.
would add constants
same here - "this page is not in page"
same question about "this"
same here - "this page is not in page.
Remove firstSense, not this code.
Remove all ifs
Remove firstSense, not sure
put this in a finally block
use UTF-8
put this in @Override
I'm always a bit suspicious about using method calls with ternary operator, since Java will invoke it even if the precondition equals to false
Will buildMobileBy(howToUseLocators::getAnnotated) work for all those variables?
Will buildMobileBy(howToUseLocators::getAnnotated) work for all those?
Not sure if using a StringBuilder is the best option here. This also requires a nitpicking developer how it's used in other tests.
Not sure if using a StringBuilder is the best option here. This also requires a nitpicking developer how to write the test.
Not sure if using a StringBuilder is the best option here. This also requires a nitpicking developer how it's used in several places.
I think you should check here if sSelel is null, as it is a valid call on a trace, to avoid a NPE
I think you should check here if sSelel is null, as it is a valid call on a trace.
I think you should check here if sSelel is null.
When possible, do we need to use them if possible?
We may want to use nullOrEmpty.
We can use nullOrEmpty.
an alternative is to log at just one place with the error code.
an alternative is to put in a method in the base class. For instance, inflightRequestInfo has similar logic with different semantics, we might need to add lock here as well.
an alternative is to put in a method in the base class instead of having to log out the exception.
metadatastreamObject can be null, since it is called in this case, but it's not that important, like that
metadatastreamObject can be null
metadatastreamObject can be null, to avoid NPE
The other test does not have this delay; why is it needed here?
The other test does not have this delay; why is it needed?
The other test does not have this delay; why is it needed here again?
change line arg to callbackListener.onError
change line arg to callbackListener
change
Instead of having a string constant, would it make sense to use a static variable to hold this specific class?
Instead of having a string constant here, would it make sense to use a static variable to hold this specific class?
Instead of having a string constant, would it make sense to use a static variable to hold this specific instance?
I'd prefer to have static import.
I'd prefer to have only one check at a time to avoid doing the check at all.
I'd prefer to have only one check at a time to avoid the else if
This is wrong. The dialog should be open and not called explicitly.
I would move this inside of the if ((null!= dialog) condition (productName == null)
I would move this inside of the workbenchWindow
Nit, these are not necessary. Could you see if you can use the existing assignment context.
Nit, these are not necessary. Could you see if you can use the existing assignment config.
Nit, these are not necessary. Could you see if you can use the constructor directly?
I suggest using the random text for this kind of thing. I know it's not your fault, but you wouldn't have to change the code that is like that.
I suggest using the randomSize method here (and in the next test class). IMHO it's not the right way to go.
I suggest using the random text for this kind of thing. I know it's not your fault, but you wouldn't have to change the code that is like that when you think it's clearer.
The prefix M is used at several places. It could be extracted out as a constant.
The prefix M is used at several places. It could be refactored out into a constant.
The prefix M is used at several places. It could be refactored out into a function.
DataGenerators.getFieldCount() is only called in validateOptions(). Please use the common validateParameters method
DataGenerators.getPhysicalSchema(context.getCatalogTable().getSchema())!= null)
DataGenerators.getPhysicalSchema(context.getCatalogTable().getSchema())
can these be info?
can we log the default value?
can we log the default values?
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
this variable is not used at all and can be removed
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this use of "final". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "deprecated!= null"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
use try with resources
use try with resources.
ctx.close()
This can be a static method because the method is called only once.
This is going to produce a list of arrays. Is this intended?
You can use a logger
Missing case: break;
Missing case insensitive check
Missing case insensitive check here
Is this line really needed? What is the purpose of using Java 8?
Is this line really needed? What will happen if length is null?
Is this line really needed? What is the purpose of using Java 8 and it?
This should be a field, not a RLE file.
Would be nice if try-with-resources to avoid the resource leak
Would be nice if try-with-resources to avoid the copy?
Use the default value when calling setUpstreamMode(name)
This needs to be set as the default for the actual command instead of setting the name.
This needs to be set as the default for the actual fixtures.
imho it would be nicer if this is written more succinctly as: java if (resultSet.getCipherStorageForCurrentAPILevel(service.getCipherStorageName(), "Migrating to a less global storage");
imho it would be nicer if this is written more succinctly as: java Boolean oldCipherStorage = oldCipherStorage.get(key); if (resultSet.hasPasswordForCurrentAPILevel(service, "Migrating"));
prefer log.error to inform the user as to why the device is expired
